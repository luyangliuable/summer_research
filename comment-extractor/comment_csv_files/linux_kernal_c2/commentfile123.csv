 SPDX-License-Identifier: GPL-2.0
 kallsyms not loaded. return NULL 
 valid ksym 
 out of range. return _stext 
 open kallsyms and read symbol addresses on the fly. Without caching all symbols,
  this is faster than load + find.
	
	  A PPC64 ABIv2 function may have a local and a global entry
	  point. We need to use the local entry point when patching
	  functions, so identify and step over the global entry point
	  sequence.
	 
	  The global entry point sequence is always of the form:
	 
	  addis r2,r12,XXXX
	  addi  r2,r2,XXXX
	 
	  A linker optimisation may convert the addis to lis:
	 
	  lis   r2,XXXX
	  addi  r2,r2,XXXX
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2017-2018 Covalent IO, Inc. http:
 randomly selected ports for testing on lo 
 global sockets 
 Init sockets 
 Allow reuse 
 Non-blocking sockets 
 Bind server sockets 
 Listen server sockets 
 Initiate Connect 
 Accept Connecrtions 
 Special case test for skb ingress + ktls 
 advance index past PASS header 
		 Account for pop bytes noting each iteration of apply will
		  call msg_pop_data helper so we need to account for this
		  by calculating the number of apply iterations. Note user
		  of the tool can create cases where no data is sent by
		  manipulating poppushpulletc. For example txmsg_apply 1
		  with txmsg_pop 1 will try to apply 1B at a time but each
		  iteration will then pop 1B so no data will ever be sent.
		  This is really only useful for testing edge cases in code
		  paths.
 FD sets 
		 Redirecting into non-TLS socket which sends into a TLS
		  socket is not a valid test. So in this case lets not
		  enable kTLS but still run the test.
 zero bytes sent case 
 PingPong data from client to server 
 FD sets 
 If base test skip BPF setup 
 Attach programs to sockmap 
 Attach programs to TLS sockmap 
 Attach to cgroups 
 Attach txmsg program to sockmap 
 Detatch and zero all the maps 
 just zero byte could be written 
 strncat() adds + 1 for zero byte 
 Test small and large iov_count values with passredirapplycork 
	 Using data verification so ensure iov layout is
	  expected from test receiver side. e.g. has enough
	  bytes to write test code.
 Tests that omit skb_parser 
 Test cork with hung data. This tests poor usage patterns where
  cork can leave data on the ring if user program is buggy and
  doesn't flush them somehow. They do take some time however
  because they wait for a timeout. Test pass, redir and cork with
  apply logic. Use cork size of 4097 with send_large to avoid
  aligning cork size with send size.
 Test basic startend 
 Test >4k pull 
 Test pull + redirect 
 Test pull + cork 
 Test pull + cork + redirect 
 Test basic pop 
 Test pop with >4k 
 Test pop + redirect 
 Test pop + cork 
 Test pop + redirect + cork 
 Test basic push 
 Test push 4kB >4k 
 Test push + redirect 
 Test push + cork 
 Tests basic commands and APIs 
 catch SIGINT 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2019 Netronome Systems, Inc. 
 SPDX-License-Identifier: GPL-2.0
 Ignore , BPF_FLOW_DISSECTOR, 0);
 To unpin, it is necessary and sufficient to just remove this dir 
 SPDX-License-Identifier: GPL-2.0-only
 On some systems 'ping' doesn't support IPv6, so use ping6 if it is present. 
 SPDX-License-Identifier: GPL-2.0
  To avoid relying on the system setup, when setup_cgroup_env is called
  we create a new mount namespace, and cgroup namespace. The cgroupv2
  root is mounted at CGROUP_MOUNT_PATH. Unfortunately, most people don't
  have cgroupv2 enabled at this point in time. It's easier to create our
  own mount namespace and manage it ourselves. We assume mnt exists.
  Related cgroupv1 helpers are named classid(), since we only use the
  net_cls controller for tagging net_cls.classid. We assume the default
  mount under sysfscgroupnet_cls, which should be the case for the
  vast majority of users.
  enable_all_controllers() - Enable all available cgroup v2 controllers
  Enable all available cgroup v2 controllers in order to increase
  the code coverage.
  If successful, 0 is returned.
 No controllers available? We're probably on cgroup v1. 
  setup_cgroup_environment() - Setup the cgroup environment
  After calling this function, cleanup_cgroup_environment should be called
  once testing is complete.
  This function will print an error to stderr and return 1 if it is unable
  to setup the cgroup environment. If setup is successful, 0 is returned.
 Cleanup existing failed runs, now that the environment is setup 
  join_cgroup() - Join a cgroup
  @path: The cgroup path, relative to the workdir, to join
  This function expects a cgroup to already be created, relative to the cgroup
  work dir, and it joins it. For example, passing "my-cgroup" as the path
  would actually put the calling process into the cgroup
  "cgroup-test-work-dirmy-cgroup"
  On success, it returns 0, otherwise on failure it returns 1.
  cleanup_cgroup_environment() - Cleanup Cgroup Testing Environment
  This is an idempotent function to delete all temporary cgroups that
  have been created during the test, including the cgroup testing work
  directory.
  At call time, it moves the calling process to the root cgroup, and then
  runs the deletion process. It is idempotent, and should not fail, unless
  a process is lingering.
  On failure, it will print an error to stderr, and try to continue.
  create_and_get_cgroup() - Create a cgroup, relative to workdir, and get the FD
  @path: The cgroup path, relative to the workdir, to join
  This function creates a cgroup under the top level workdir and returns the
  file descriptor. It is idempotent.
  On success, it returns the file descriptor. On failure it returns -1.
  If there is a failure, it prints the error to stderr.
  get_cgroup_id() - Get cgroup id for a particular cgroup path
  @path: The cgroup path, relative to the workdir, to join
  On success, it returns the cgroup id. On failure it returns 0,
  which is an invalid cgroup id.
  If there is a failure, it prints the error to stderr.
  setup_classid_environment() - Setup the cgroupv1 net_cls environment
  After calling this function, cleanup_classid_environment should be called
  once testing is complete.
  This function will print an error to stderr and return 1 if it is unable
  to setup the cgroup environment. If setup is successful, 0 is returned.
  set_classid() - Set a cgroupv1 net_cls classid
  @id: the numeric classid
  Writes the passed classid into the cgroup work dir's net_cls.classid
  file in order to later on trigger socket tagging.
  On success, it returns 0, otherwise on failure it returns 1. If there
  is a failure, it prints the error to stderr.
  join_classid() - Join a cgroupv1 net_cls classid
  This function expects the cgroup work dir to be already created, as we
  join it here. This causes the process sockets to be tagged with the given
  net_cls classid.
  On success, it returns 0, otherwise on failure it returns 1.
  cleanup_classid_environment() - Cleanup the cgroupv1 net_cls environment
  At call time, it moves the calling process to the root cgroup, and then
  runs the deletion process.
  On failure, it will print an error to stderr, and try to continue.
 SPDX-License-Identifier: GPL-2.0-only
  Testsuite for eBPF verifier
  Copyright (c) 2014 PLUMgrid, http:plumgrid.com
  Copyright (c) 2017 Facebook
  Copyright (c) 2018 Covalent IO, Inc. http:covalent.io
	 Expected verifier log output for result REJECT or VERBOSE_ACCEPT.
	  Can be a tab-separated sequence of expected strings. An empty string
	  means no log verification.
 Note we want this to be 64 bit aligned so that the end of our array is
  actually the end of the structure.
 test: {skb->data[0], vlan_push} x 51 + {skb->data[0], vlan_pop} x 51 
 jump range is limited to 16 bit. PUSH_CNT of ld_abs needs room 
 jump to error label 
 error label 
	 jump range is limited to 16 bit. every ld_abs is replaced by 6 insns,
	  but on arches like arm, ppc etc, there will be one BPF_ZEXT inserted
	  to extend the error value of the inlined ld_abs sequence which then
	  contains 7 insns. so, set the dividend to 7 so the testcase could
	  work on all arches.
 test the sequence of 8k jumps 
 test to check that the long sequence of jumps is acceptable 
	 is_state_visited() doesn't allocate state for pruning for every jump.
	  Hence multiply jmps by 4 to accommodate that heuristic
 test the sequence of 8k jumps in inner most function (function depth 8)
 test to check that the long sequence of jumps is acceptable 
 main 
 subprog 1 
 subprog 2 
 BPF_SK_LOOKUP contains 13 instructions, if you need to fix up maps 
 struct bpf_sock_tuple tuple = {} 				\
 sk = func(ctx, &tuple, sizeof tuple, 0, 0) 		\
 BPF_DIRECT_PKT_R2 contains 7 instructions, it initializes default return
  value into 0 and does necessary preparation for direct packet access
  through r2. The allowed access range is 8 bytes.
 BPF_RAND_UEXT_R7 contains 4 instructions, it initializes R7 into a random
  positive u32, and zero-extend it into 64-bit.
 BPF_RAND_SEXT_R7 contains 5 instructions, it initializes R7 into a random
  negative u32, and sign-extend it into 64-bit.
 struct bpf_spin_lock {
    int val;
  };
  struct val {
    int cnt;
    struct bpf_spin_lock l;
  };
  struct bpf_timer {
    __u64 :64;
    __u64 :64;
  } __attribute__((aligned(8)));
  struct timer {
    struct bpf_timer t;
  };
 int 
 [1] 
 struct bpf_spin_lock                       
 int val; 
 struct val                                 
 int cnt; 
 struct bpf_spin_lock l; 
 struct bpf_timer                           
 struct timer                               
 struct bpf_timer t; 
	 Allocating HTs with 1 elem is fine here, since we only test
	  for verifier and not do a runtime lookup, so the only thing
	  that really matters is value size in this case.
 need CAP_BPF, CAP_NET_ADMIN, CAP_PERFMON to load progs 
	 libcap is likely old and simply ignores CAP_BPF and CAP_PERFMON,
	  so update effective bits manually
 CAP_PERFMON  - 32);
 CAP_BPF  - 32);
 fallthrough; 
 Returns true if every part of exp (tab-separated) appears in log, in order.
  If exp is an empty string, returns true.
	 If there were some map skips during fixup due to missing bpf
	  features, skip this test.
	 BPF_PROG_TYPE_TRACING requires more setup and
	  bpf_probe_prog_type won't give correct answer
 CAP_BPF  - 32));
 CAP_PERFMON  - 32));
	 Some architectures have strict alignment requirements. In
	  that case, the BPF verifier detects if a program has
	  unaligned accesses and rejects them. A user can pass
	  BPF_F_ANY_ALIGNMENT to a program to override this
	  check. That, however, will only work when a privileged user
	  loads a program. An unprivileged user loading a program
	  with this flag will be rejected prior entering the
	  verifier.
		 Program types that are not supported by non-root we
		  skip right away.
 SPDX-License-Identifier: GPL-2.0
 test ir decoder
 Copyright (C) 2018 Sean Young <sean@mess.org>
 A lirc chardev is a device representing a consumer IR (cir) device which
 can receive infrared signals from remote control andor transmit IR.
 IR is sent as a series of pulses and space somewhat like morse code. The
 BPF program can decode this into scancodes so that rc-core can translate
 this into input key codes using the rc keymap.
 This test works by sending IR over rc-loopback, so the IR is processed by
 BPF and then decoded into scancodes. The lirc chardev must be the one
 associated with rc-loopback, see the output of ir-keytable(1).
 The following CONFIG options must be enabled for the test to succeed:
 CONFIG_RC_CORE=y
 CONFIG_BPF_RAWIR_EVENT=y
 CONFIG_RC_LOOPBACK=y
 Steps:
 1. Open the devlircN device for rc-loopback (given on command line)
 2. Attach bpf_lirc_mode2 program which decodes some IR.
 3. Send some IR to the same IR device; since it is loopback, this will
    end up in the bpf program
 4. bpf program should decode IR and report keycode
 5. We can read keycode from same devlirc device
 Let's try detach it before it was ever attached 
 Write raw IR 
 Read decoded IR 
 Write raw IR 
 Read decoded IR 
 Let's try detaching it now it is actually attached 
 We need a few instructions to pass the min log length 
 Test incorrect attr 
 Test with log big enough 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 Copyright (C) 2020 Facebook, Inc. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
	 attach to this pid so the all bpf invocations will be in the
	  cgroup associated with this pid.
 trigger some syscalls 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019, Oracle andor its affiliates. All rights reserved. 
 use server program 
 Only supports IPv4; see hints initiailization above. 
	 Start xdping-ing from last regular ping reply, e.g. for a count
	  of 10 ICMP requests, we start xdping-ing using reply with seq number
	  10.  The reason the last "real" ping RTT is much higher is that
	  the ping program sees the ICMP reply associated with the last
	  XDP-generated packet, so ping doesn't get a reply until XDP is done.
 We need to wait for XDP setup to complete. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016 Facebook
 Size of the LRU map is 2
  Add key=1 (+1 key)
  Add key=2 (+1 key)
  Lookup Key=1
  Add Key=3
    => Key=2 will be removed by LRU
  Iterate map.  Only found key=1 and key=3
 insert key=1 element 
 BPF_NOEXIST means: add new element if it doesn't exist 
 key=1 already exists 
 insert key=2 element 
 check that key=2 is not found 
 BPF_EXIST means: update existing element 
 key=2 is not there 
 insert key=3 element 
 check that key=3 is not found 
	 check that key=1 can be found and mark the ref bit to
	  stop LRU from removing key=1
 key=2 has been removed from the LRU 
 lookup elem key=1 and delete it, then check it doesn't exist 
 remove the same element from the expected map 
 Size of the LRU map is 1.5tgt_free
  Insert 1 to tgt_free (+tgt_free keys)
  Lookup 1 to tgt_free2
  Insert 1+tgt_free to 2tgt_free (+tgt_free keys)
  => 1+tgt_free2 to LOCALFREE_TARGET will be removed by LRU
 This test is only applicable to common LRU list 
 Insert 1 to tgt_free (+tgt_free keys) 
 Lookup 1 to tgt_free2 
	 Insert 1+tgt_free to 2tgt_free
	  => 1+tgt_free2 to LOCALFREE_TARGET will be
	  removed by LRU
 Size of the LRU map 1.5  tgt_free
  Insert 1 to tgt_free (+tgt_free keys)
  Update 1 to tgt_free2
    => The original 1 to tgt_free2 will be removed due to
       the LRU shrink process
  Re-insert 1 to tgt_free2 again and do a lookup immeidately
  Insert 1+tgt_free to tgt_free32
  Insert 1+tgt_free32 to tgt_free52
    => Key 1+tgt_free to tgt_free32
       will be removed from LRU because it has never
       been lookup and ref bit is not set
 This test is only applicable to common LRU list 
 Insert 1 to tgt_free (+tgt_free keys) 
	 Any bpf_map_update_elem will require to acquire a new node
	  from LRU first.
	 
	  The local list is running out of free nodes.
	  It gets from the global LRU list which tries to
	  shrink the inactive list to get tgt_free
	  number of free nodes.
	 
	  Hence, the oldest key 1 to tgt_free2
	  are removed from the LRU list.
	 Re-insert 1 to tgt_free2 again and do a lookup
	  immeidately.
 Insert 1+tgt_free to tgt_free32 
		 These newly added but not referenced keys will be
		  gone during the next LRU shrink.
 Insert 1+tgt_free32 to  tgt_free52 
 Size of the LRU map is 2tgt_free
  It is to test the activeinactive list rotation
  Insert 1 to 2tgt_free (+2tgt_free keys)
  Lookup key 1 to tgt_free32
  Add 1+2tgt_free to tgt_free52 (+tgt_free2 keys)
   => key 1+tgt_free32 to 2tgt_free are removed from LRU
 This test is only applicable to common LRU list 
 Insert 1 to 2tgt_free (+2tgt_free keys) 
 Lookup key 1 to tgt_free32 
	 Add 1+2tgt_free to tgt_free52
	  (+tgt_free2 keys)
 Test deletion 
 Ensure the last key inserted by previous CPU can be found 
 Cannot find the last key because it was removed by LRU 
 Test map with only one element 
 At least one key should be tested 
 Test list rotation for BPF_F_NO_COMMON_LRU map 
 Make ref bit sticky for key: [1, tgt_free] 
 Mark the ref bit 
 Size of the LRU map is 2
  Add key=1 (+1 key)
  Add key=2 (+1 key)
  Lookup Key=1 (datapath)
  Lookup Key=2 (syscall)
  Add Key=3
    => Key=2 will be removed by LRU
  Iterate map.  Only found key=1 and key=3
 insert key=1 element 
 BPF_NOEXIST means: add new element if it doesn't exist 
 key=1 already exists 
 insert key=2 element 
 check that key=2 is not found 
 BPF_EXIST means: update existing element 
 key=2 is not there 
 insert key=3 element 
 check that key=3 is not found 
	 check that key=1 can be found and mark the ref bit to
	  stop LRU from removing key=1
	 check that key=2 can be found and do _not_ mark ref bit.
	  this will be evicted on next update.
 key=2 has been removed from the LRU 
 Size of the LRU map is 2
  Add key=1 (+1 key)
  Add key=2 (+1 key)
  Lookup Key=1 (syscall)
  Lookup Key=2 (datapath)
  Add Key=3
    => Key=1 will be removed by LRU
  Iterate map.  Only found key=2 and key=3
 insert key=1 element 
 BPF_NOEXIST means: add new element if it doesn't exist 
 key=1 already exists 
 insert key=2 element 
 check that key=2 is not found 
 BPF_EXIST means: update existing element 
 key=2 is not there 
 insert key=3 element 
 check that key=3 is not found 
	 check that key=1 can be found and do _not_ mark ref bit.
	  this will be evicted on next update.
	 check that key=2 can be found and mark the ref bit to
	  stop LRU from removing key=2
 key=1 has been removed from the LRU 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
 Copyright (c) 2019 Cloudflare
 SYN packets do not get passed through generic XDP, skip the
 rest of the test.
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2017 Facebook
 backtrace 
 get_nprocs 
 Adapted from perfutilstring.c 
 Check wild card 
 Tail wild card matches all 
 defined in test_progs.h 
 store counts before subtest started 
 Override C runtime library's usleep() implementation to ensure nanosleep()
  is always called. Usleep is frequently used in selftests as a way to
  trigger kprobe and tracepoints.
 worker always holds log 
 exports env.log_buf & env.log_cnt 
 A bunch of tests set custom affinity per-thread andor per-process. Reset
  it after each testsub-test.
  Trigger synchronize_rcu() in kernel.
 ensure previous instance of the module is unloaded 
 extern declarations for test funcs 
 nothing to do, output to stdout by default 
 stdout and stderr -> buffer 
  Determine if test_progs is running as a "flavored" test runner and switch
  into corresponding sub-directory to load correct BPF objects.
  This is done by looking at executable name. If it contains "-flavor"
  suffix, then we are running as a flavored test runner.
	 General form of argv[0] passed here is:
	  somepathtotest_progs[-flavor], where -flavor part is optional.
	  First cut out "test_progs[-flavor]" part, then extract "flavor"
	  part, if it's there.
 ensure last sub-test is finalized properly 
 grab a test 
 run test through worker 
 wait for test done 
 collect all logs 
 output log 
 wait for test done 
 while (true) 
 print error logs again 
 wait for all dispatcher to finish 
 run serial tests 
 generate summary 
 reap all workers 
 receive command 
 send logs 
 case MSG_DO_TEST 
 Use libbpf 1.0 API mode 
 initializing tests 
 ignore workers if we are just listing 
 launch workers if requested 
 main process 
 main process 
 inside each worker process 
 The rest of the main process 
 on single mode 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2020 Intel Corporation. 
  Some functions in this program are taken from
  Linux kernel samplesbpfxdpsock and modified
  for use.
  See test_xsk.sh for detailed information on test topology
  and prerequisite network setup.
  This test program contains two threads, each thread is single socket with
  a unique UMEM. It validates in-order packet delivery and packet content
  by sending packets to each other.
  Tests Information:
  ------------------
  These selftests test AF_XDP SKB and NativeDRV modes using veth
  Virtual Ethernet interfaces.
  For each mode, the following tests are run:
     a. nopoll - soft-irq processing in run-to-completion mode
     b. poll - using poll() syscall
     c. Socket Teardown
        Create a Tx and a Rx socket, Tx from one socket, Rx on another. Destroy
        both sockets, then repeat multiple times. Only nopoll mode is used
     d. Bi-directional sockets
        Configure sockets as bi-directional txrx sockets, sets up fill and
        completion rings on each socket, txrx in both directions. Only nopoll
        mode is used
     e. Statistics
        Trigger some error conditions and ensure that the appropriate statistics
        are incremented. Within this test, the following statistics are tested:
        i.   rx dropped
             Increase the UMEM frame headroom to a value which results in
             insufficient space in the rx buffer for both the packet and the headroom.
        ii.  tx invalid
             Set the 'len' field of tx descriptors to an invalid value (umem frame
             size + 1).
        iii. rx ring full
             Reduce the size of the RX ring to a fraction of the fill ring size.
        iv.  fill queue empty
             Do not populate the fill queue and then try to receive pkts.
     f. bpf_link resource persistence
        Configure sockets at indexes 0 and 1, run a traffic on queue ids 0,
        then remove xsk sockets from queue 0 on both veth interfaces and
        finally run a traffic on queues ids 1
     g. unaligned mode
     h. tests for invalid and corner case Tx descriptors so that the correct ones
        are discarded and let through, respectively.
     i. 2K frame size tests
  Total tests: 12
  Flow:
  -----
  - Single process spawns two threads: Tx and Rx
  - Each of these two threads attach to a veth interface within their assigned
    namespaces
  - Each thread Creates one AF_XDP socket connected to a unique umem for each
    veth interface
  - Tx thread Transmits 10k packets from veth<xxxx> to veth<yyyy>
  - Rx thread verifies if all 10k packets were received and delivered in-order,
    and have the right content
  Enabledisable packet dump mode:
  --------------------------
  To enable L2 - L4 headers and payload dump of each packet on STDOUT, add
  parameter -D to params array in test_xsk.sh, i.e. params=("-S" "-D")
  Fold a partial checksum
  This function code has been taken from
  Linux kernel includeasm-genericchecksum.h
  This function code has been taken from
  Linux kernel libchecksum.c
 add up 32-bit and 32-bit for 32+c bit 
 add up carry.. 
  This function code has been taken from
  Linux kernel libchecksum.c
  This function has been taken from
  Linux kernel includeasm-genericchecksum.h
 udp hdr and data 
extract L2 frame 
extract L3 frame 
extract L4 frame 
extract L5 frame 
Do not try to verify packets that are smaller than minimum size. 
 Retry if it fails as xsk_socket__create() is asynchronous 
Spawn RX thread 
Spawn TX thread 
 No or few packets will be received so cannot pace packets 
 To only see the whole stat set being completed unless an individual test fails. 
 Simple test 
 Let half of the packets straddle a buffer boundrary 
 Zero packet length at address zero allowed 
 Zero packet length allowed 
 Straddling the start of umem 
 Packet too large 
 After umem ends 
 Straddle the end of umem 
 Straddle a page boundrary 
 Straddle a 2K boundrary 
 Valid packet for synch so that something is received 
 Crossing a page boundrary allowed 
 Crossing a 2K frame size boundrary not allowed 
 reset defaults after potential previous test 
 SPDX-License-Identifier: GPL-2.0
 default, set below 
 Find ingressegress prog for 2nd xdp prog 
 Init forward multicast groups and exclude group 
 Add all the interfaces to group all 
 bind prog_fd to each interface 
 sleep some time for testing 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 set up periodic 1-second timer 
 find next available CPU 
	 unless explicit producer CPU list is specified, continue after
	  last consumer CPU
 skip first sample 
 SPDX-License-Identifier: GPL-2.0-only
  Testsuite for eBPF maps
  Copyright (c) 2014 PLUMgrid, http:plumgrid.com
  Copyright (c) 2016 Facebook
 Insert key=1 element. 
 BPF_NOEXIST means add new element if it doesn't exist. 
 key=1 already exists. 
 -1 is an invalid flag. 
 Check that key=1 can be found. 
 Insert key=2 element. 
 Check that key=2 matches the value and delete it 
 Check that key=2 is not found. 
 BPF_EXIST means update existing element. 
 key=2 is not there. 
 Insert key=2 element. 
	 key=1 and key=2 were inserted, check that key=0 cannot be
	  inserted due to max_entries limit.
 Update existing element, though the map is full. 
 Check that key = 0 doesn't exist. 
 Iterate over two elements. 
 Delete both elements. 
 Check that map is empty. 
 give kernel time to destroy 
 Insert key=1 element. 
 Lookup and delete elem key=1 and check value. 
 Insert key=1 element which should not exist. 
 BPF_NOEXIST means add new element if it doesn't exist. 
 key=1 already exists. 
 -1 is an invalid flag. 
	 Check that key=1 can be found. Value could be 0 if the lookup
	  was run from a different CPU.
 Check that key=2 is not found. 
 BPF_EXIST means update existing element. 
 key=2 is not there. 
 Insert key=2 element. 
	 key=1 and key=2 were inserted, check that key=0 cannot be
	  inserted due to max_entries limit.
 Check that key = 0 doesn't exist. 
 Iterate over two elements. 
 Update with BPF_EXIST. 
 Delete both elements. 
 Check that map is empty. 
 Insert key=1 element. 
 Check that key=1 can be found. 
 Check that key=0 is also found and zero initialized. 
	 key=0 and key=1 were inserted, check that key=2 cannot be inserted
	  due to max_entries limit.
 Check that key = 2 doesn't exist. 
 Iterate over two elements. 
 Delete shouldn't succeed. 
 Insert key=1 element. 
 Check that key=1 can be found. 
 Check that key=0 is also found and zero initialized. 
 Check that key=2 cannot be inserted due to max_entries limit. 
 Check that key = 2 doesn't exist. 
 Iterate over two elements. 
 Delete shouldn't succeed. 
	 nr_keys is not too large otherwise the test stresses percpu
	  allocator more than anything else
 Fill test values to be used 
 Invalid key size 
 Queue map does not support BPF_F_NO_PREALLOC 
 Push MAP_SIZE elements 
 Check that element cannot be pushed due to max_entries limit 
 Peek element 
 Replace half elements 
 Pop all elements 
 Check that there are not elements left 
 Check that non supported functions set errno to EINVAL 
 Fill test values to be used 
 Invalid key size 
 Stack map does not support BPF_F_NO_PREALLOC 
 Push MAP_SIZE elements 
 Check that element cannot be pushed due to max_entries limit 
 Peek element 
 Replace half elements 
 Pop all elements 
 Check that there are not elements left 
 Check that non supported functions set errno to EINVAL 
 Create some sockets to use with sockmap 
 Test sockmap with connected sockets 
 Test update with unsupported UDP socket 
 Test update without programs 
 Test attachingdetaching bad fds 
 Load SK_SKB program and Attach 
 Test map update elem afterwards fd lives in fd and map_fd 
 Test map delete elem and remove sendrecv sockets 
 Put sfd[2] (sending fd below) into msg map to test sendmsg bpf 
 Test map sendrecv 
 Negative null entry lookup from datapath should be dropped 
 Push fd into same slot 
 Delete the elems without programs 
 Test having multiple maps open and set with programs on same fds 
 Test tasks number of forked operations 
 Test map close sockets and empty maps 
 Test that failing bpf_object__create_map() destroys the inner map 
	 Iterate over all maps to check whether the internal map
	  ("mim.internal") has been destroyed.
 Iterate through all elements. 
	 Use the same fd in children to add elements to this map:
	  child_0 adds key=0, key=1024, key=2048, ...
	  child_1 adds key=1, key=1025, key=2049, ...
	  child_1023 adds key=1023, ...
 Check that key=0 is already there. 
 Check that all elements were inserted. 
 Another check for all elements 
 Now let's delete all elemenets in parallel. 
 Nothing should be left. 
 Try to insert key=1 element. 
 Check that key=1 is not found. 
 Insert key=1 element. 
 Check that reading elements and keys from the map is not allowed. 
 StackQueue maps do not support BPF_F_NO_PREALLOC 
 Peek element should fail 
 Pop element should fail 
 reuseport_array does not allow unbound sk 
			
			  reuseport_array does not allow
			  non-listening tcp sk.
 Test lookupupdatedelete with invalid index 
 Test lookupdelete non existence elem 
 Test BPF_ update flags 
 BPF_EXIST failure case 
 BPF_NOEXIST success case 
 BPF_EXIST success case. 
 BPF_NOEXIST failure case 
 BPF_ANY case (always succeed) 
 The same sk cannot be added to reuseport_array twice 
 Test delete elem 
 Add it back with BPF_NOEXIST 
 Test cookie 
 Test elem removed by close() 
 Test SOCK_RAW 
 Close the 64 bit value map 
 Test 32 bit fd 
 SPDX-License-Identifier: GPL-2.0
  Inject packets with all sorts of encapsulation into the kernel.
  IPv4IPv6	outer layer 3
  GREGUEBARE outer layer 4, where bare is IPIPSITIPv4-in-IPv6..
  IPv4IPv6    inner layer 3
 Add some protocol definitions that do not exist in userspace 
 optional SIT prefix 
 halfwords: twice byte len 
 halfwords: twice byte len 
 calculate header offsets 
	
	  Fill packet from inside out, to calculate correct checksums.
	  But create ip before udp headers, as udp uses ip for pseudo-sum.
 add zero byte for udp csum padding 
 sender transmits encapsulated over RAW or unencap'd over UDP 
 connect to destination if not encapsulated 
 otherwise using loopback 
 receiver reads unencapsulated UDP 
 read straggler packets, if any 
	
	  success (== 0) only if received all packets
	  unless failure is expected, in which case none must arrive.
 == 0 
	 RFC 6040 4.2:
	    on decap, if outer encountered congestion (CE == 0x3),
	    but inner cannot encode ECN (NoECT == 0x0), then drop packet.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
 RFC 4291, Section 2.7.1 
 root cgroup 
 non-existent cgroup 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
 BPF prog properties 
 Socket properties 
 Endpoint to bind() to 
 Expected test result 
 if (ip == expected && port == expected) 
 return DENY; 
 else return ALLOW; 
 if (ip == expected && port == expected) 
 return ALLOW; 
 else return DENY; 
		 sys_bind() may fail for different reasons, errno has to be
		  checked to confirm that BPF program rejected it.
 Detaching wo checking return code: best effort attempt. 
 SPDX-License-Identifier: GPL-2.0
  Randomized tests for eBPF longest-prefix-match maps
  This program runs randomized tests against the lpm-bpf-map. It implements a
  "Trivial Longest Prefix Match" (tlpm) based on simple, linear, singly linked
  lists. The implementation should be pretty straightforward.
  Based on tlpm, this inserts randomized data into bpf-lpm-maps and verifies
  the trie-based bpf-map implementation behaves the same way as tlpm.
 'overwrite' an equivalent entry if one already exists 
 add new entry with @key@n_bits to @list and return new head 
 free all entries in @list 
	 Perform longest prefix-match on @key@n_bits. That is, iterate all
	  entries and match each prefix against @key. Remember the "best"
	  entry we find (i.e., the longest prefix that matches) and return it
	  to the caller when done.
 should never get here 
 very basic, static tests to verify tlpm works as expected 
	 Verify the tlpm implementation works correctly regardless of the
	  order of entries. Insert a random set of entries into @l1, and copy
	  the same data in reverse order into @l2. Then verify a lookup of
	  random keys will yield the same result in both sets.
	 Compare behavior of tlpm vs. bpf-lpm. Create a randomized set of
	  prefixes and insert it into both tlpm and bpf-lpm. Then run some
	  randomized lookups and verify both maps return the same result.
	 Remove the first half of the elements in the tlpm and the
	  corresponding nodes from the bpf-lpm.  Then run the same
	  large number of random lookups in both and make sure they match.
	  Note: we need to count the number of nodes actually inserted
	  since there may have been duplicates.
	 With 255 random nodes in the map, we are pretty likely to match
	  something on every lookup. For statistics, use this:
	 
	      printf("          nodes: %zu\n"
	             "        lookups: %zu\n"
	             "        matches: %zu\n"
	             "matches(delete): %zu\n",
	             n_nodes, n_lookups, n_matches, n_matches_after_delete);
 Test the implementation with some 'real world' examples 
 Fill data some IPv4 and IPv6 address ranges 
 Set tprefixlen to maximum for lookups 
 Test some lookups that should come back with a value 
 Test some lookups that should not match any entry 
	 Add nodes:
	  192.168.0.016   (1)
	  192.168.0.024   (2)
	  192.168.128.024 (3)
	  192.168.1.024   (4)
	 
	          (1)
	            \
              (IM)    (3)
	        \
            (2)  (4)
 remove non-existent node 
 unused prefix so far
 same prefix as the root node
 assert initial lookup 
 remove leaf node 
 remove leaf (and intermediary) node 
 remove root node 
 remove last node 
 empty tree. get_next_key should return ENOENT 
 get and verify the first key, get the second one should fail. 
 no exact matching key should get the first one in post order. 
 add one more element (total two) 
 Add one more element (total three) 
 Add one more element (total four) 
 Add one more element (total five) 
 no exact matching key should return the first one in post order 
 0: update, 1: delete, 2: lookup, 3: get_next_key 
			 first half of iterations in forward order,
			  and second half in backward order.
 update must succeed 
 Pass successful exit info back to the main thread
 create a trie 
 create 4 threads to test update, delete, lookup and get_next_key 
 we want predictable, pseudo random tests 
 Test with 8, 16, 24, 32, ... 128 bit prefix length 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
 BPF prog properties 
 Socket properties 
 IP:port pairs for BPF prog to override 
 Expected test result 
 bind 
 connect 
 sendmsg 
 recvmsg 
 return rc 
rc 1);
rc 0);
rc 1);
rc 0);
 if (sk.family == AF_INET && 
     sk.type == SOCK_DGRAM)  { 
      msg_src_ip4 = src4_rw_ip 
      user_ip4 = dst4_rw_addr.sin_addr 
      user_port = dst4_rw_addr.sin_port 
 } 
 return 1 
 if (sk.family == AF_INET6) { 
      user_port = dst6_rw_addr.sin6_port 
 } 
 return 1 
cmp_port 0);
cmp_port 1);
cmp_port 1);
set_cmsg0,
 Try to connect to server just in case 
 Prepare server to connect to 
 Make sure src and dst addrs were overridden properly 
 Test TCP Fast Open scenario 
 Make sure src and dst addrs were overridden properly 
 Prepare server to sendmsg to 
flags0,
		 Try to receive message on server instead of using
		  getpeername(2) on client socket, to check that client's
		  destination address was rewritten properly, since
		  getpeername(2) doesn't work with unconnected datagram
		  sockets.
		 
		  Get source address from recvmsg(2) as well to make sure
		  source was rewritten properly: getsockname(2) can't be used
		  since socket is unconnected and source defined for one
		  specific packet may differ from the one used by default and
		  returned by getsockname(2).
cmp_port0))
 error was expected, reset it 
 error was expected, reset it 
 error was expected, reset it 
 Detaching wo checking return code: best effort attempt. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 Print raw BTF type dump into a local buffer and return string pointer back.
  Buffer will be overwritten by subsequent btf_type_raw_dump() calls
 Print BTF-to-C dump into a local buffer and return string pointer back.
  Buffer will be overwritten by subsequent btf_type_raw_dump() calls
 SPDX-License-Identifier: GPL-2.0
 percpu map fd 
 flags, not used 
 map fd 
 flags, not used 
 Attach the bpf program 
 Every second packet should be dropped 
 Check the counter in the cgroup local storage 
 Bump the counter in the cgroup local storage 
 Every second packet should be dropped 
 Check the final value of the counter in the cgroup local storage 
 Check the final value of the counter in the percpu local storage 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2017 Facebook
 Attach bpf program 
	 All operations with devzero and and devurandom are allowed,
	  everything else is forbidden.
 devzero is whitelisted 
 src is allowed, target is forbidden 
 src is forbidden, target is allowed 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 If (write) 
 return DENY; 
 else return ALLOW; 
 If (write) 
 return DENY; 
 else return ALLOW; 
 same as default, should fail anyway 
 u64 w = (u16)write & 1; 
 return 1 - w; 
 same as default, should fail anyway 
 write = X 
 If (file_pos == X) 
 return ALLOW; 
 else return DENY; 
 If (file_pos == X) 
 return ALLOW; 
 else return DENY; 
 file_pos = X 
 sysctl_get_name arg2 (buf) 
 sysctl_get_name arg3 (buf_len) 
 sysctl_get_name arg4 (flags) 
 sysctl_get_name(ctx, buf, buf_len, flags) 
 if (ret == expected && 
     buf == "tcp_mem\0") 
 return ALLOW; 
 else return DENY; 
 sysctl_get_name arg2 (buf) 
 sysctl_get_name arg3 (buf_len) too small 
 sysctl_get_name arg4 (flags) 
 sysctl_get_name(ctx, buf, buf_len, flags) 
 if (ret == expected && 
     buf[0:7] == "tcp_me\0") 
 return ALLOW; 
 else return DENY; 
 sysctl_get_name arg2 (buf) 
 sysctl_get_name arg3 (buf_len) 
 sysctl_get_name arg4 (flags) 
 sysctl_get_name(ctx, buf, buf_len, flags) 
 if (ret == expected && 
     buf[0:8] == "netipv4" && 
     buf[8:16] == "tcp_mem" && 
     buf[16:24] == "\0") 
 return ALLOW; 
 else return DENY; 
 sysctl_get_name arg2 (buf) 
 sysctl_get_name arg3 (buf_len) 
 sysctl_get_name arg4 (flags) 
 sysctl_get_name(ctx, buf, buf_len, flags) 
 if (ret == expected && 
     buf[0:8] == "netipv4" && 
     buf[8:16] == "tcp_me\0") 
 return ALLOW; 
 else return DENY; 
 sysctl_get_name arg2 (buf) 
 sysctl_get_name arg3 (buf_len) 
 sysctl_get_name arg4 (flags) 
 sysctl_get_name(ctx, buf, buf_len, flags) 
 if (ret == expected && 
     buf[0:8] == "netip\0") 
 return ALLOW; 
 else return DENY; 
 sysctl_get_current_value arg2 (buf) 
 sysctl_get_current_value arg3 (buf_len) 
 sysctl_get_current_value(ctx, buf, buf_len) 
 if (ret == expected && 
     buf[0:6] == "Linux\n\0") 
 return ALLOW; 
 else return DENY; 
 sysctl_get_current_value arg2 (buf) 
 sysctl_get_current_value arg3 (buf_len) 
 sysctl_get_current_value(ctx, buf, buf_len) 
 if (ret == expected && 
     buf[0:6] == "Linux\n\0") 
 return ALLOW; 
 else return DENY; 
 sysctl_get_current_value arg2 (buf) 
 sysctl_get_current_value arg3 (buf_len) 
 sysctl_get_current_value(ctx, buf, buf_len) 
 if (ret == expected && 
     buf[0:6] == "Linux\0") 
 return ALLOW; 
 else return DENY; 
 sysctl_get_current_value arg2 (buf) 
 sysctl_get_current_value arg3 (buf_len) 
 sysctl_get_current_value(ctx, buf, buf_len) 
 if (ret == expected && 
     buf[0:8] is NUL-filled) 
 return DENY; 
 else return ALLOW; 
 -EIO 
 sysctl_get_current_value arg2 (buf) 
 sysctl_get_current_value arg3 (buf_len) 
 sysctl_get_current_value(ctx, buf, buf_len) 
 if (ret == expected && 
     buf[0:4] == expected) 
 return DENY; 
 else return ALLOW; 
 same as default, should fail anyway 
 sysctl_get_new_value arg2 (buf) 
 sysctl_get_new_value arg3 (buf_len) 
 sysctl_get_new_value(ctx, buf, buf_len) 
 if (ret == expected) 
 return ALLOW; 
 else return DENY; 
 sysctl_get_new_value arg2 (buf) 
 sysctl_get_new_value arg3 (buf_len) 
 sysctl_get_new_value(ctx, buf, buf_len) 
 if (ret == expected && 
     buf[0:4] == "606\0") 
 return DENY; 
 else return ALLOW; 
 sysctl_get_new_value arg2 (buf) 
 sysctl_get_new_value arg3 (buf_len) 
 sysctl_get_new_value(ctx, buf, buf_len) 
 if (ret == expected && 
     buf[0:8] == "3000000 " && 
     buf[8:16] == "4000000 " && 
     buf[16:24] == "6000000\0") 
 return DENY; 
 else return ALLOW; 
 sysctl_get_new_value arg2 (buf) 
 sysctl_get_new_value arg3 (buf_len) 
 sysctl_get_new_value(ctx, buf, buf_len) 
 if (ret == expected && 
     buf[0:3] == "60\0") 
 return DENY; 
 else return ALLOW; 
 sysctl_set_new_value arg2 (buf) 
 sysctl_set_new_value arg3 (buf_len) 
 sysctl_set_new_value(ctx, buf, buf_len) 
 if (ret == expected) 
 return ALLOW; 
 else return DENY; 
 sysctl_set_new_value arg2 (buf) 
 sysctl_set_new_value arg3 (buf_len) 
 sysctl_set_new_value(ctx, buf, buf_len) 
 if (ret == expected) 
 return ALLOW; 
 else return DENY; 
 arg1 (buf) 
 arg2 (buf_len) 
 arg3 (flags) 
 arg4 (res) 
 if (ret == expected && 
     res == expected) 
 return ALLOW; 
 else return DENY; 
 arg1 (buf) 
 "600 602\0" 
 arg2 (buf_len) 
 arg3 (flags) 
 arg4 (res) 
 if (ret == expected && 
     res == expected) 
     arg1 (buf) 
     arg2 (buf_len) 
     arg3 (flags) 
     arg4 (res) 
     if (ret == expected && 
         res == expected) 
 return ALLOW; 
 else return DENY; 
 arg1 (buf) 
 arg2 (buf_len) 
 arg3 (flags) 
 arg4 (res) 
 arg1 (buf) 
 arg2 (buf_len) 
 arg3 (flags) 
 arg4 (res) 
 if (ret == expected && 
     res == expected) 
 return ALLOW; 
 else return DENY; 
 arg1 (buf) 
 arg2 (buf_len) 
 arg3 (flags) 
 arg4 (res) 
 if (ret == expected) 
 return ALLOW; 
 else return DENY; 
 arg1 (buf) 
 arg2 (buf_len) 
 arg3 (flags) 
 arg4 (res) 
 if (ret == expected) 
 return ALLOW; 
 else return DENY; 
 arg1 (buf) 
 " -6\0" 
 arg2 (buf_len) 
 arg3 (flags) 
 arg4 (res) 
 if (ret == expected) 
 return ALLOW; 
 else return DENY; 
 arg1 (buf) 
 " -6\0" 
 arg2 (buf_len) 
 arg3 (flags) 
 arg4 (res) 
 if (ret == expected && 
     res == expected) 
 return ALLOW; 
 else return DENY; 
 arg1 (buf) 
 "0xfe" 
 arg2 (buf_len) 
 arg3 (flags) 
 arg4 (res) 
 if (ret == expected && 
     res == expected) 
 return ALLOW; 
 else return DENY; 
 arg1 (buf) 9223372036854775807 
 arg2 (buf_len) 
 arg3 (flags) 
 arg4 (res) 
 if (ret == expected && 
     res == expected) 
 return ALLOW; 
 else return DENY; 
 arg1 (buf) 9223372036854775808 
 arg2 (buf_len) 
 arg3 (flags) 
 arg4 (res) 
 if (ret == expected) 
 return ALLOW; 
 else return DENY; 
 Detaching wo checking return code: best effort attempt. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 COUNT-GLOBAL benchmark 
 COUNT-local benchmark 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 BPF triggering benchmarks 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 per-ringbuf, in bytes 
 use slower output API 
 per-CPU size, in pages 
 exported into benchmark runner 
 RINGBUF-LIBBPF benchmark 
 initial batch to get everything started 
 record data + header take 16 bytes 
 RINGBUF-CUSTOM benchmark 
 Map writable consumer page 
 Map read-only producer page and data pages. 
 clear out top 2 bits 
 add length prefix 
 round up to 8 byte alignment 
 sample not committed yet, bail out for now 
 PERFBUF-LIBBPF benchmark 
 notify only every Nth sample 
 PERFBUF-CUSTOM benchmark 
 copies of internal libbpf definitions 
 mmap()'ed memory 
 for reconstructing segmented data 
 passed into callbacks 
 number of allocated CPU buffers 
 perf event FD 
 BPF_MAP_TYPE_PERF_EVENT_ARRAY BPF map FD 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 BPF triggering benchmarks 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 exported into benchmark runner 
		 Populate hashmap, bloom filter map, and array map with the same
		  random values
 Resize number of entries 
 Set value size 
 For the hashmap, we use the value as the key as well 
 Set number of hash functions 
 Load pointer to map. 
 Copy R10 to R9. 
 Pollute other registers with unaligned values. 
 Store both R9 and R10 with BPF_B and read back. 
 Should read back as same value. 
 val = 0x110; 
 atomic_xor(&val, 0x011); 
 if (val != 0x101) exit(2); 
 r1 should not be clobbered, no BPF_FETCH flag 
 val = 0x110; 
 old = atomic_fetch_xor(&val, 0x011); 
 if (old != 0x110) exit(3); 
 if (val != 0x101) exit(2); 
 Check R0 wasn't clobbered (fxor fear of x86 JIT bug) 
 exit(0); 
 r0 = (s64) -1 
 val = 0x110; 
 old = atomic_fetch_xor(&val, 0x011); 
 if (old != 0x110) exit(3); 
 if (val != 0x101) exit(2); 
		 Check R0 wasn't clobbered (fxor fear of x86 JIT bug)
		  It should be -1 so add 1 to get exit code.
 struct bpf_sock sock = bpf_sock_lookup(...); 
 u64 foo; 
 void target = &foo; 
 if (skb == NULL) target = sock; 
 else target = skb; 
 struct __sk_buff skb = target; 
 skb->mark = 42; 
 if (sk) bpf_sk_release(sk) 
 struct bpf_sock sock = bpf_sock_lookup(...); 
 u64 foo; 
 void target = &foo; 
 if (skb == NULL) target = sock; 
 else target = skb; 
 struct __sk_buff skb = target; 
 skb->mark = 42; 
.errstr = "same insn cannot be used with different pointers",
 struct bpf_sock sock = bpf_sock_lookup(...); 
 u64 foo; 
 void target = &foo; 
 if (skb) target = skb 
 else target = sock 
 struct bpf_sock sk = target; 
 if (sk) u32 foo = sk->mark; bpf_sk_release(sk); 
 struct bpf_sock sock = bpf_sock_lookup(...); 
 u64 foo; 
 void target = &foo; 
 if (skb) target = skb 
 else target = sock 
 struct bpf_sock sk = target; 
 if (sk) sk->mark = 42; bpf_sk_release(sk); 
.errstr = "same insn cannot be used with different pointers",
 Write 3 to stack 
 Put a 1 in R1, add it to the 3 on the stack, and load the value back into R1 
 Check the value we loaded back was 3 
 Load value from stack 
 Check value loaded from stack was 4 
 Write 3 to stack 
 Put a 1 in R1, add it to the 3 on the stack, and load the value back into R1 
 Check the value we loaded back was 3 
 Load value from stack 
 Check value loaded from stack was 4 
	 It happens that the address leak check is first, but it would also be
	  complain about the fact that we're trying to modify R10.
	 It happens that the address leak check is first, but it would also be
	  complain about the fact that we're trying to modify R10.
		 This is an fentry prog, context is array of the args of the
		  kernel function being called. Load first arg into R2.
		 First arg of bpf_fentry_test7 is a pointer to a struct.
		  Attempt to modify that struct. Verifier shouldn't let us
		  because it's kernel memory.
 Done 
 main prog 
 subprog 1 
 subprog 2 
 main prog 
 subprog 1 
 subprog 2 
 val = 0x110; 
 atomic_or(&val, 0x011); 
 if (val != 0x111) exit(2); 
 r1 should not be clobbered, no BPF_FETCH flag 
 val = 0x110; 
 old = atomic_fetch_or(&val, 0x011); 
 if (old != 0x110) exit(3); 
 if (val != 0x111) exit(2); 
 Check R0 wasn't clobbered (for fear of x86 JIT bug) 
 exit(0); 
 r0 = (s64) -1 
 val = 0x110; 
 old = atomic_fetch_or(&val, 0x011); 
 if (old != 0x110) exit(3); 
 if (val != 0x111) exit(2); 
		 Check R0 wasn't clobbered (for fear of x86 JIT bug)
		  It should be -1 so add 1 to get exit code.
 r1 = U64_MAX; 
 u64 val = r1; 
 r1 = (u32)atomic_fetch_or((u32 )&val, 2); 
 r2 = 0x00000000FFFFFFFF; 
 if (r2 != r1) exit(1); 
 exit(0); 
 If this gets ever changed, make sure JITs can deal with it. 
 spill R1(ctx) into stack 
 fill it back into R2 
 should be able to access R0 = (R2 + 8) 
 BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_2, 8), 
 reserve 8 byte ringbuf memory 
 store a pointer to the reserved memory in R6 
 check whether the reservation was successful 
 spill R6(mem) into the stack 
 fill it back in R7 
 should be able to access (R7) = 0 
 submit the reserved ringbuf memory 
 spill R1(ctx) into stack 
 mess up with R1 pointer on stack 
	 fill back into R0 is fine for priv.
	  R0 now becomes SCALAR_VALUE.
 Load from R0 should fail. 
 r4 = 20 
 (u32 )(r10 -8) = r4 
 r4 = (u32 )(r10 -8) 
 r0 = r2 
 r0 += r4 R0=pkt R2=pkt R3=pkt_end R4=inv20 
 if (r0 > r3) R0=pkt,off=20 R2=pkt R3=pkt_end R4=inv20 
 r0 = (u32 )r2 R0=pkt,off=20,r=20 R2=pkt,r=20 R3=pkt_end R4=inv20 
 r4 = 20 
 (u32 )(r10 -8) = r4 
 r4 = (u32 )(r10 -4) fp-8=????rrrr
 r4 = 20 
 (u32 )(r10 -8) = r4 
 r4 = (u16 )(r10 -8) 
 r0 = r2 
 r0 += r4 R0=pkt R2=pkt R3=pkt_end R4=inv,umax=65535 
 if (r0 > r3) R0=pkt,umax=65535 R2=pkt R3=pkt_end R4=inv,umax=65535 
 r0 = (u32 )r2 R0=pkt,umax=65535 R2=pkt R3=pkt_end R4=inv20 
 r4 = 20 
 (u32 )(r10 -8) = r4 
 r4 = (u16 )(r10 -6) 
 r0 = r2 
 r0 += r4 R0=pkt R2=pkt R3=pkt_end R4=inv,umax=65535 
 if (r0 > r3) R0=pkt,umax=65535 R2=pkt R3=pkt_end R4=inv,umax=65535 
 r0 = (u32 )r2 R0=pkt,umax=65535 R2=pkt R3=pkt_end R4=inv20 
 r4 = 20 
 (u32 )(r10 -8) = r4 
 (u32 )(r10 -4) = r4 
 r4 = (u32 )(r10 -4),  
 r0 = r2 
 r0 += r4 R0=pkt R2=pkt R3=pkt_end R4=inv,umax=U32_MAX 
 if (r0 > r3) R0=pkt,umax=U32_MAX R2=pkt R3=pkt_end R4=inv 
 r0 = (u32 )r2 R0=pkt,umax=U32_MAX R2=pkt R3=pkt_end R4=inv 
 (u32 )(r10 -8) = r4 R4=inv,umax=40 
 r4 = (u32 )(r10 - 8) 
 r2 += r4 R2=pkt R4=inv,umax=40 
 r0 = r2 R2=pkt,umax=40 R4=inv,umax=40 
 r2 += 20 R0=pkt,umax=40 R2=pkt,umax=40 
 if (r2 > r3) R0=pkt,umax=40 R2=pkt,off=20,umax=40 
 r0 = (u32 )r0 R0=pkt,r=20,umax=40 R2=pkt,off=20,r=20,umax=40 
 r4 = 4321 
 (u32 )(r10 -4) = r4 
 (u32 )(r10 -8) = r4 
 r4 = (u64 )(r10 -8) 
 a = 0; 
		
		  Note this is implemented with two separate instructions,
		  where you might think one would suffice:
		 
		  BPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),
		 
		  This is because BPF_ST_MEM doesn't seem to set the stack slot
		  type to 0 when storing an immediate.
 b = atomic_fetch_add(&a, 1); 
 Verifier should be able to tell that this infinite loop isn't reachable. 
 if (b) while (true) continue; 
 ultimate return value ,
 Check bounds are OK
 Check bounds are OK
 bpf_strtoul arg1 (buf) 
 bpf_strtoul arg2 (buf_len) 
 bpf_strtoul arg3 (flags) 
 bpf_strtoul arg4 (res) 
 bpf_strtoul() 
 bpf_strtoul arg1 (buf) 
 bpf_strtoul arg2 (buf_len) 
 bpf_strtoul arg3 (flags) 
 bpf_strtoul arg4 (res) 
 bpf_strtoul() 
 bpf_strtoul arg1 (buf) 
 bpf_strtoul arg2 (buf_len) 
 bpf_strtoul arg3 (flags) 
 bpf_strtoul arg4 (res) 
 bpf_strtoul() 
 bpf_strtoul arg1 (buf) 
 bpf_strtoul arg2 (buf_len) 
 bpf_strtoul arg3 (flags) 
 bpf_strtoul arg4 (res) 
 bpf_strtoul() 
 bpf_strtoul arg1 (buf) 
 bpf_strtoul arg2 (buf_len) 
 bpf_strtoul arg3 (flags) 
 bpf_strtoul arg4 (res) 
 bpf_strtoul() 
	 clear_all_pkt_pointers() has to walk all frames
	  to make sure that pkt pointers in the caller
	  are cleared when callee is calling a helper that
	  adjusts packet size
 main prog 
 subprog 1 
 write into stack frame of main prog 
 subprog 2 
 read from stack frame of main prog 
 prog 1 
 prog 2 
 prog 1 
 prog 2 
 main 
 call A 
 call B 
 A 
 B 
 call A 
	 stack_main=32, stack_A=256, stack_B=64
	  and max(main+A, main+A+B) < 512
 main 
 call A 
 call B 
 A 
 B 
 call A 
	 stack_main=32, stack_A=64, stack_B=256
	  and max(main+A, main+A+B) < 512
 main 
 call A 
 call B 
 A 
 B 
 call A 
	 stack_main=64, stack_A=224, stack_B=256
	  and max(main+A, main+A+B) > 512
	 void main(void) {
	    func1(0);
	    func1(1);
	    func2(1);
	  }
	  void func1(int alloc_or_recurse) {
	    if (alloc_or_recurse) {
	      frame_pointer[-300] = 1;
	    } else {
	      func2(alloc_or_recurse);
	    }
	  }
	  void func2(int alloc_or_recurse) {
	    if (alloc_or_recurse) {
	      frame_pointer[-300] = 1;
	    }
	  }
 main 
 call A 
 call A 
 call B 
 A 
 call B 
 B 
 main 
 call A 
 A 
 call B 
 B 
 call C 
 C 
 call D 
 D 
 call E 
 E 
 call F 
 F 
 call G 
 G 
 call H 
 H 
 main 
 call A 
 A 
 call B 
 B 
 call C 
 C 
 call D 
 D 
 call E 
 E 
 call F 
 F 
 call G 
 G 
 call H 
 H 
 main prog 
 subprog 1 
 subprog 2 
 write into stack frame of main prog 
 void return 
 main prog 
 pass fp-16, fp-8 into a function 
 fetch map_value_ptr from the stack of this function 
 write into map value 
 fetch secound map_value_ptr from the stack 
 write into map value 
 subprog 1 
 call 3rd function twice 
 first time with fp-8 
 second time with fp-16 
 subprog 2 
 lookup from map 
 write map_value_ptr into stack frame of main prog 
 return 0 
 main prog 
 pass fp-16, fp-8 into a function 
 subprog 1 
 call 3rd function twice 
 first time with fp-8 
 fetch map_value_ptr from the stack of this function 
 write into map value 
 second time with fp-16 
 fetch secound map_value_ptr from the stack 
 write into map value 
 subprog 2 
 lookup from map 
 return 0 
 write map_value_ptr into stack frame of main prog 
 return 1 
 main prog 
 pass fp-16, fp-8 into a function 
 subprog 1 
 call 3rd function twice 
 first time with fp-8 
 fetch map_value_ptr from the stack of this function 
 write into map value 
 second time with fp-16 
 fetch secound map_value_ptr from the stack 
 write into map value 
 subprog 2 
 lookup from map 
 return 0 
 write map_value_ptr into stack frame of main prog 
 return 1 
 main prog 
 pass fp-16, fp-8 into a function 
 subprog 1 
 1st lookup from map 
 write map_value_ptr into stack frame of main prog at fp-8 
 2nd lookup from map 
 20 
 24 
 write map_value_ptr into stack frame of main prog at fp-16 
 call 3rd func with fp-8, 0|1, fp-16, 0|1 
 30 
 34 
 subprog 2 
 if arg2 == 1 do arg1 = 0 
 fetch map_value_ptr from the stack of this function 
 write into map value 
 if arg4 == 1 do arg3 = 0 
 fetch map_value_ptr from the stack of this function 
 write into map value 
 main prog 
 pass fp-16, fp-8 into a function 
 subprog 1 
 1st lookup from map 
 write map_value_ptr into stack frame of main prog at fp-8 
 2nd lookup from map 
 20 
 24 
 write map_value_ptr into stack frame of main prog at fp-16 
 call 3rd func with fp-8, 0|1, fp-16, 0|1 
 30 
 34 
 subprog 2 
 if arg2 == 1 do arg1 = 0 
 fetch map_value_ptr from the stack of this function 
 write into map value 
 if arg4 == 1 do arg3 = 0 
 fetch map_value_ptr from the stack of this function 
 write into map value 
 main prog 
 pass fp-16, fp-8 into a function 
 subprog 1 
 1st lookup from map 
 write map_value_ptr into stack frame of main prog at fp-8 
 2nd lookup from map 
 26
 write map_value_ptr into stack frame of main prog at fp-16 
 call 3rd func with fp-8, 0|1, fp-16, 0|1 
 30
 34
 subprog 2 
 if arg2 == 1 do arg1 = 0 
 fetch map_value_ptr from the stack of this function 
 write into map value 
 if arg4 == 1 do arg3 = 0 
 fetch map_value_ptr from the stack of this function 
 write into map value 
 main prog 
 pass fp-16, fp-8 into a function 
 subprog 1 
 1st lookup from map 
 write map_value_ptr_or_null into stack frame of main prog at fp-8 
 2nd lookup from map 
 write map_value_ptr_or_null into stack frame of main prog at fp-16 
 call 3rd func with fp-8, 0|1, fp-16, 0|1 
 subprog 2 
 if arg2 == 1 do arg1 = 0 
 fetch map_value_ptr from the stack of this function 
 write into map value 
 if arg4 == 1 do arg3 = 0 
 fetch map_value_ptr from the stack of this function 
 write into map value 
 main prog 
 pass fp-16, fp-8 into a function 
 subprog 1 
 1st lookup from map 
 write map_value_ptr_or_null into stack frame of main prog at fp-8 
 2nd lookup from map 
 write map_value_ptr_or_null into stack frame of main prog at fp-16 
 call 3rd func with fp-8, 0|1, fp-16, 0|1 
 subprog 2 
 if arg2 == 1 do arg1 = 0 
 fetch map_value_ptr from the stack of this function 
 write into map value 
 if arg4 == 0 do arg3 = 0 
 fetch map_value_ptr from the stack of this function 
 write into map value 
 subprog 1 
 spill unchecked pkt_ptr into stack of caller 
 now the pkt range is verified, read pkt_ptr from stack 
 write 4 bytes into packet 
 Marking is still kept, but not in all cases safe. 
 subprog 1 
 spill unchecked pkt_ptr into stack of caller 
 now the pkt range is verified, read pkt_ptr from stack 
 write 4 bytes into packet 
 Marking is still kept and safe here. 
 subprog 1 
 spill unchecked pkt_ptr into stack of caller 
 now the pkt range is verified, read pkt_ptr from stack 
 write 4 bytes into packet 
 Check marking propagated. 
 subprog 1 
 spill unchecked pkt_ptr into stack of caller 
 don't read back pkt_ptr from stack here 
 write 4 bytes into packet 
 subprog 1 
 spill checked pkt_ptr into stack of caller 
 don't read back pkt_ptr from stack here 
 write 4 bytes into packet 
 subprog 1 
 spill checked pkt_ptr into stack of caller 
 don't read back pkt_ptr from stack here 
 write 4 bytes into packet 
 subprog 1 
 spill checked pkt_ptr into stack of caller 
 don't read back pkt_ptr from stack here 
 write 4 bytes into packet 
 subprog 1 
 spill checked pkt_ptr into stack of caller 
 don't read back pkt_ptr from stack here 
 write 4 bytes into packet 
 subprog 1 
 spill unchecked pkt_ptr into stack of caller 
 don't read back pkt_ptr from stack here 
 write 4 bytes into packet 
 fetch map_value_or_null or const_zero from stack 
 store into map_value 
 subprog 1 
 if (ctx == 0) return; 
 else bpf_map_lookup() and (fp - 8) = r0 
 write map_value_ptr_or_null into stack frame of main prog at fp-8 
 first make allocated_stack 16 byte 
	 now fork the execution such that the false branch
	  of JGT insn will be verified second and it skisp zero
	  init of fp-8 stack slot. If stack liveness marking
	  is missing live_read marks from call map_lookup
	  processing then pruning will incorrectly assume
	  that fp-8 stack slot was unused in the fall-through
	  branch and will accept the program incorrectly
	 r8 = !!random();
	  call pruner()
	  if (r8)
	      do something bad;
 because max wasn't checked, signed min is negative 
 csum_diff of 64-byte packet ,
 Just make sure that JITs used udivumod as otherwise we get
  an exception from INT_MIN-1 overflow similarly as with div
  by zero.
 Get an unknown value 
 Make it small and 4-byte aligned 
	 add it to skb.  We now have either &skb->len or
	  &skb->pkt_type, but we don't know which
 dereference it 
 Fill the top 8 bytes of the stack 
 Get an unknown value 
 Make it small and 4-byte aligned 
	 add it to fp.  We now have either fp-4 or fp-8, but
	  we don't know which
 dereference it for a stack read 
 Get an unknown value 
 Make it small and 4-byte aligned 
	 add it to fp.  We now have either fp-4 or fp-8, but
	  we don't know which
 dereference it for a stack read 
 Get an unknown value 
 Make it small and 8-byte aligned 
	 Add it to fp.  We now have either fp-8 or fp-16, but
	  we don't know which
 Dereference it for a stack write 
	 Now read from the address we just wrote. This shows
	  that, after a variable-offset write, a priviledged
	  program can read the slots that were in the range of
	  that write (even if the verifier doesn't actually know
	  if the slot being read was really written to or not.
	 Variable stack access is rejected for unprivileged.
	 Dummy instruction; needed because we need to patch the next one
	  and we can't patch the first instruction.
 Make R0 a map ptr 
 Get an unknown value 
 Make it small and 8-byte aligned 
	 Add it to fp. We now have either fp-8 or fp-16, but
	  we don't know which.
 Spill R0(map ptr) into stack 
 Dereference the unknown value for a stack write 
 Fill the register back into R2 
 Try to dereference R2 for a memory load 
	 The unpriviledged case is not too interesting; variable
	  stack access is rejected.
	 In the priviledged case, dereferencing a spilled-and-then-filled
	  register is rejected because the previous variable offset stack
	  write might have overwritten the spilled pointer (i.e. we lose track
	  of the spilled register when we analyze the write).
 Fill the top 16 bytes of the stack. 
 Get an unknown value. 
 Check the lower bound but don't check the upper one. 
	 Point the lower bound to initialized stack. Offset is now in range
	  from fp-16 to fp+0x7fffffffffffffef, i.e. max value is unbounded.
 Dereference it indirectly. 
 Fill the top 8 bytes of the stack 
 Get an unknown value 
 Make it small and 4-byte aligned 
	 add it to fp.  We now have either fp-4 or fp-8, but
	  we don't know which
 dereference it indirectly 
 Fill the top 8 bytes of the stack 
 Get an unknown value 
 Make it small and 4-byte aligned 
	 add it to fp.  We now have either fp-516 or fp-512, but
	  we don't know which
 dereference it indirectly 
 Fill only the second from top 8 bytes of the stack. 
 Get an unknown value. 
 Make it small and 4-byte aligned. 
	 Add it to fp.  We now have either fp-12 or fp-16, but we don't know
	  which. fp-12 size 8 is partially uninitialized stack.
 Dereference it indirectly. 
 Fill only the top 8 bytes of the stack. 
 Get an unknown value 
 Make it small and 4-byte aligned. 
	 Add it to fp.  We now have either fp-12 or fp-16, but we don't know
	  which. fp-16 size 8 is partially uninitialized stack.
 Dereference it indirectly. 
 Fill the top 16 bytes of the stack. 
 Get an unknown value. 
 Make it small and 4-byte aligned. 
	 Add it to fp.  We now have either fp-12 or fp-16, we don't know
	  which, but either way it points to initialized stack.
 Dereference it indirectly. 
 Fill the top 16 bytes of the stack. 
 Get an unknown value. 
 Make it small and 4-byte aligned. 
	 Add it to fp.  We now have either fp-12 or fp-16, we don't know
	  which, but either way it points to initialized stack.
 Dereference it indirectly. 
 Fill the top 16 bytes of the stack. 
 Get an unknown value. 
 Make it small and 4-byte aligned. 
	 Add it to fp.  We now have either fp-12 or fp-16, we don't know
	  which, but either way it points to initialized stack.
 Dereference it indirectly. 
 r0 has upper bound that should propagate into r2 
 spill r2 
 clear r0 and r2 
 fill r3 
 r3 has lower and upper bounds 
 r0 has upper bound that should propagate into r2 
 spill r2 
 clear r0 and r2 
 fill r3 
 r3 has lower and upper bounds 
 spill r0 
 The verifier will walk the rest twice with r0 == 0 and r0 == map_value 
 The verifier will walk the rest two more times with r0 == 20 and r0 == unknown 
 fill r3 with map_value 
 skip ldx if map_value == NULL 
 Buggy verifier will think that r3 == 20 here 
 read from map_value 
 val = 3; 
 old = atomic_xchg(&val, 4); 
 if (old != 3) exit(1); 
 if (val != 4) exit(2); 
 exit(0); 
 val = 3; 
 old = atomic_xchg(&val, 4); 
 if (old != 3) exit(1); 
 if (val != 4) exit(2); 
 exit(0); 
 map_value_ptr -= map_value_ptr 
 R2=inv(umin=1, umax=8) 
 map_value_ptr -= map_value_ptr 
 R2=inv(umin=1, umax=8) 
 Get an unknown value 
 branch conditions teach us nothing about R2 
  0. r2 = (u32 )(r1 + data_end)
  1. r4 = (u32 )(r1 + data)
  2. r3 = r4
  3. r3 += 42
  4. r1 = 0
  5. if r3 > r2 goto 8
  6. r4 += 14
  7. r1 = r4
  8. if r3 > r2 goto 10
  9. r2 = (u8 )(r1 + 9)
 10. r0 = 0
 11. exit
  0. r2 = (u32 )(r1 + data_end)
  1. r4 = (u32 )(r1 + data)
  2. r3 = r4
  3. r3 += 42
  4. r1 = 0
  5. if r3 > r2 goto 8
  6. r4 += 14
  7. r1 = r4
  8. if r2 < r3 goto 10
  9. r2 = (u8 )(r1 + 9)
 10. r0 = 0
 11. exit
 Dead branch. 
 user_ip6[0] is u64 aligned 
 msg_src_ip6[0] is _not_ u64 aligned 
 user_ip6[0] is u64 aligned 
 msg_src_ip6[0] is _not_ u64 aligned 
 Call to skb_load_bytes() omitted. 
 reg, bit 63 or bit 0 set, taken 
 reg, bit 62, not taken 
 imm, any bit set, taken 
 imm, bit 31 set, taken 
 all good - return r0 == 2 
 r2 = 0x0000'0000'ffff'ffff 
 r2 = 0 
 no-op 
 access at offset 0 
 exit 
 r2 = 0xffff'ffff'ffff'ffff 
 r2 = 0xffff'ffff 
 r0 = <oob pointer> 
 access to OOB pointer 
 exit 
 r2 = 0xffff'ffff'ffff'ffff 
 r2 = 0xfff'ffff 
 r0 = <oob pointer> 
 access to OOB pointer 
 exit 
 r1 = [0x00, 0xff] 
 r2 = 0x10'0000'0000 
 r1 = [0x10'0000'0000, 0x10'0000'00ff] 
 r1 = [0x10'7fff'ffff, 0x10'8000'00fe] 
 r1 = [0x00, 0xff] 
 r1 = 0 
 no-op 
 access at offset 0 
 exit 
 r1 = [0x00, 0xff] 
 r1 = [0xffff'ff80, 0x1'0000'007f] 
	 r1 = [0xffff'ff80, 0xffff'ffff] or
	       [0x0000'0000, 0x0000'007f]
	 r1 = [0x00, 0xff] or
	       [0xffff'ffff'0000'0080, 0xffff'ffff'ffff'ffff]
 error on OOB pointer computation 
 exit 
 not actually fully unbounded, but the bound is very high 
 r1 = [0x00, 0xff] 
 r1 = [0xffff'ff80, 0x1'0000'007f] 
	 r1 = [0xffff'ff80, 0xffff'ffff] or
	       [0x0000'0000, 0x0000'007f]
	  difference to previous test: truncation via MOV32
	  instead of ALU32.
	 r1 = [0x00, 0xff] or
	       [0xffff'ffff'0000'0080, 0xffff'ffff'ffff'ffff]
 error on OOB pointer computation 
 exit 
 r1 = 0x7fff'ffff 
 r1 = 0xffff'fffe 
 r1 = 0 
 no-op 
 access at offset 0 
 exit 
 r1 = (u32)1 << (u32)32 = ? 
 r1 = [0x0000, 0xffff] 
 computes unknown pointer, potentially OOB 
 potentially OOB access 
 exit 
 r1 = [0x00, 0xff] 
 r1 = [-0x01, 0xfe] 
 r1 = 0 or 0xff'ffff'ffff'ffff 
 r1 = 0 or 0xffff'ffff'ffff 
 computes unknown pointer, potentially OOB 
 potentially OOB access 
 exit 
 r1 = 2 
 r1 = 1<<32 
 r1 = 0 (NOT 2!) 
 r1 = 0xffff'fffe (NOT 0!) 
 error on computing OOB pointer 
 exit 
 r1 = 0xffffFFFF00000001 
 check ALU64 op keeps 32bit bounds 
 invalid ldx if bounds are lost above 
 r1 = 0xffffFFFF00000001 
 r1 = 0x2 
 check ALU32 op zero extends 64bit bounds 
 invalid ldx if bounds are lost above 
 This used to reduce the max bound to 0x7fffffff 
 Verifier rewrite for unpriv skips tail call here. 
 split for s390 to succeed 
 load map value pointer into r0 and r2
 load some number from the map into r1
 depending on r1, branch:
 branch A
 branch B
 common instruction
 depending on r1, branch:
 branch A
 branch B
 verifier follows fall-through
 fake-dead code; targeted from branch A to
 prevent dead code sanitization
 load map value pointer into r0 and r2
 load some number from the map into r1
 depending on r1, branch:
 branch A
 branch B
 common instruction
 depending on r1, branch:
 branch A
 branch B
 verifier follows fall-through
 fake-dead code; targeted from branch A to
 prevent dead code sanitization, rejected
 via branch B however
 Marks reg as unknown. 
 val = 3; 
 old = atomic_cmpxchg(&val, 2, 4); 
 if (old != 3) exit(2); 
 if (val != 3) exit(3); 
 old = atomic_cmpxchg(&val, 3, 4); 
 if (old != 3) exit(4); 
 if (val != 4) exit(5); 
 exit(0); 
 val = 3; 
 old = atomic_cmpxchg(&val, 2, 4); 
 if (old != 3) exit(2); 
 if (val != 3) exit(3); 
 old = atomic_cmpxchg(&val, 3, 4); 
 if (old != 3) exit(4); 
 if (val != 4) exit(5); 
 exit(0); 
 r0 = U64_MAX; 
 u64 val = r0; 
 r0 = (u32)atomic_cmpxchg((u32 )&val, r0, 1); 
 r1 = 0x00000000FFFFFFFFull; 
 if (r0 != r1) exit(1); 
 exit(0); 
 val = 0; 
 r0 = &val 
 r0 = atomic_cmpxchg(&val, r0, 1); 
 if (r0 != 0) exit(1); 
 exit(0); 
 r0 = &val 
 val = r0; 
 r0 = atomic_cmpxchg(&val, r0, 0); 
 r1 = r0 
 exit(0); 
 r6 is our tp buffer 
 move the key (== 0) to r10-8 
 lookup in the map 
 exit clean if null 
 shift the buffer pointer to a variable location 
 clobber whatever's there 
 This file contains sub-register zero extension checks for insns defining
  sub-registers, meaning:
    - All insns under BPF_ALU class. Their BPF_ALU32 variants or narrow width
      forms (BPF_END) could define sub-registers.
    - Narrow direct loads, BPF_BHW | BPF_LDX.
    - BPF_LD is not exposed to JIT back-ends, so no need for testing.
  "get_prandom_u32" is used to initialize low 32-bit of some registers to
  prevent potential optimizations done by verifier or JIT back-ends which could
  optimize register back into constant when range info shows one register is a
  constant.
	 An insn could have no effect on the low 32-bit, for example:
	    a = a + 0
	    a = a | 0
	    a = a & -1
	  But, they should still zero high 32-bit.
 Upper bits are unknown but AND above masks out 1 zero'ing lower bits 
 val = 0x110; 
 atomic_and(&val, 0x011); 
 if (val != 0x010) exit(2); 
 r1 should not be clobbered, no BPF_FETCH flag 
 val = 0x110; 
 old = atomic_fetch_and(&val, 0x011); 
 if (old != 0x110) exit(3); 
 if (val != 0x010) exit(2); 
 Check R0 wasn't clobbered (for fear of x86 JIT bug) 
 exit(0); 
 r0 = (s64) -1 
 val = 0x110; 
 old = atomic_fetch_and(&val, 0x011); 
 if (old != 0x110) exit(3); 
 if (val != 0x010) exit(2); 
		 Check R0 wasn't clobbered (for fear of x86 JIT bug)
		  It should be -1 so add 1 to get exit code.
 val = 0x110; 
 old = atomic_fetch_and(&val, 0x011); 
 if (old != 0x110) exit(3); 
 if (val != 0x010) exit(2); 
 exit(0); 
 leak reference 
 leak reference 
 leak reference 
 leak reference 
 leak reference 
 reference in r0 may be NULL 
 reference in r0 may be NULL 
 goto end 
 if (offsetof(skb, mark) > data_len) exit; 
 mark == 0? 
 Leak reference in R0 
 sk NULL? 
 if (offsetof(skb, mark) > data_len) exit; 
 mark == 0? 
 sk NULL? 
 sk NULL? 
 unchecked reference 
 subprog 1 
 unchecked reference 
 subprog 1 
 subprog 1 
 spill unchecked sk_ptr into stack of caller 
 subprog 1 
 return sk 
 subprog 1 
 spill unchecked sk_ptr into stack of caller 
 subprog 2 
 subprog 1 
 spill unchecked sk_ptr into stack of caller 
 now the sk_ptr is verified, free the reference 
 subprog 2 
 if (sk) bpf_sk_release() 
 bpf_tail_call() 
 if (sk) bpf_sk_release() 
 bpf_tail_call() 
 Look up socket and store in REG_6 
 bpf_tail_call() 
 if (sk) bpf_sk_release() 
 Look up socket and store in REG_6 
 if (!sk) goto end 
 bpf_tail_call() 
 Check that the packet is at least 64B long 
 sk = sk_lookup_tcp(ctx, skb->data, ...) 
 !bpf_sk_fullsock(sk) is checked but !bpf_tcp_sock(sk) is not checked 
 u64 val = operan1; 			\
 u64 old = atomic_fetch_add(&val, operand2);  \
 if (old != operand1) exit(1); 		\
 if (val != result) exit (2); 		\
 exit(0); 					\
 1-byte read from family field 
 2-byte read from family field 
 4-byte read from family field 
 1-byte read from protocol field 
 2-byte read from protocol field 
 4-byte read from protocol field 
 1-byte read from remote_ip4 field 
 2-byte read from remote_ip4 field 
 4-byte read from remote_ip4 field 
 1-byte read from remote_ip6 field 
 2-byte read from remote_ip6 field 
 4-byte read from remote_ip6 field 
 1-byte read from remote_port field 
 2-byte read from remote_port field 
 4-byte read from remote_port field 
 1-byte read from local_ip4 field 
 2-byte read from local_ip4 field 
 4-byte read from local_ip4 field 
 1-byte read from local_ip6 field 
 2-byte read from local_ip6 field 
 4-byte read from local_ip6 field 
 1-byte read from local_port field 
 2-byte read from local_port field 
 4-byte read from local_port field 
 8-byte read from sk field 
 invalid 8-byte reads from a 4-byte fields in bpf_sk_lookup 
 invalid 1,2,4-byte reads from 8-byte fields in bpf_sk_lookup 
 out of bounds and unaligned reads from bpf_sk_lookup 
 in-bound and out-of-bound writes to bpf_sk_lookup 
 reg, high bits shouldn't be tested 
 instructions used to output a skb based software event, produced
  from code snippet:
  struct TMP {
   uint64_t tmp;
  } tt;
  tt.tmp = 5;
  bpf_perf_event_output(skb, &connection_tracking_event_map, 0,
 			 &tt, sizeof(tt));
  return 1;
  the bpf assembly from llvm is:
         0:       b7 02 00 00 05 00 00 00         r2 = 5
         1:       7b 2a f8 ff 00 00 00 00         (u64 )(r10 - 8) = r2
         2:       bf a4 00 00 00 00 00 00         r4 = r10
         3:       07 04 00 00 f8 ff ff ff         r4 += -8
         4:       18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00    r2 = 0ll
         6:       b7 03 00 00 00 00 00 00         r3 = 0
         7:       b7 05 00 00 08 00 00 00         r5 = 8
         8:       85 00 00 00 19 00 00 00         call 25
         9:       b7 00 00 00 01 00 00 00         r0 = 1
        10:       95 00 00 00 00 00 00 00         exit
      The reason I put the code here instead of fill_helpers is that map fixup
      is against the insns, instead of filled prog.
 ctx->meta->seq
 ctx->task
 fixup_map_array_48b
 keep buf for seq_write
 Don't run, just load
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Politecnico di Torino
 SPDX-License-Identifier: GPL-2.0 
 Copyright (c) 2018 Facebook 
 just to validate we can handle maps in multiple sections 
 just verify we can reference both maps 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
 Verify that new destination is available. 
 Bind to device and unbind it. 
 Rewrite congestion control. 
 Rewrite destination. 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2017 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 8-byte aligned .data 
 4-byte aligned .rodata 
 same "subprog" name in both files 
 but different formula 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 long 
 [1] 
 unsigned long 
 [2] 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
 Verify that new destination is available. 
 Rewrite destination. 
 Rewrite source. 
 SPDX-License-Identifier: GPL-2.0
 Force local address to [::1]:22223. 
 Rewire service [fc00::1]:60000 to backend [::1]:60124. 
 Expose local server as [fc00::1]:60000 to client. 
 Expose service [fc00::1]:60000 as peer instead of backend. 
 Copyright (c) 2017 VMware
  This program is free software; you can redistribute it andor
  modify it under the terms of version 2 of the GNU General Public
  License as published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  General Public License for more details.
 SPDX-License-Identifier: GPL-2.0
 These are the identifiers of the BPF programs that will be used in tail
  calls. Name is limited to 16 characters, with the terminating character and
  bpf_func_ above, we have only 6 to work with, anything after will be cropped.
 DestinationHop-by-Hop Options IPv6 Ext. Header 
 Fragmentation IPv6 Extension Header 
 Verifies this variable offset does not overflow 
 Dispatches on ETHERTYPE 
 Protocol not supported 
 Parses on IPPROTO_ 
 Only inspect standard GRE packets with version 0 
 Step over GRE Flags and Proto 
 Step over chksum and Padding 
 Step over key 
 Step over sequence number 
 IP header cannot be smaller than 20 bytes 
			 From second fragment on, packets do not have headers
			  we can parse.
			 No need to parse fragmented packet unless
			  explicitly asked for.
	 hlen is in 8-octets and does not include the first 8 bytes
	  of the header
		 No need to parse fragmented packet unless
		  explicitly asked for.
 Account for double-tagging 
 Only allow 8021AD + 8021Q double tagging and no triple tagging.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2017 Facebook
 SPDX-License-Identifier: GPL-2.0
  Copyright 2020 Google LLC.
 This is the first fmod_ret program, the ret passed should be 0 
	 If the input_reval is non-zero a successful modification should have
	  occurred.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 spin_lock in hash map 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 4-byte aligned .data 
 8-byte aligned .rodata 
 same "subprog" name in both files 
 but different formula 
 different name andor type of the variable doesn't matter 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 weak and shared between both files 
 should stay zero 
 same "subprog" name in all files, but it's ok because they all are static 
 but different formula 
 Global functions can't be void 
 This function can't be verified as global, as it assumes raw_tpsys_enter
  context and accesses syscall id (second argument). So we mark it as
  __hidden, so that libbpf will mark it as static in the final object file,
  right before verifying it in the kernel.
  But we don't mark it as __hidden here, rather at extern site. __hidden is
  "contaminating" visibility, so it will get propagated from either extern or
  actual definition (including from the losing __weak definition).
 long id, same as in BPF_PROG below 
 this weak instance should lose, because it will be processed second 
 here we'll force set_output_ctx1() to be __hidden in the final obj file 
 ctx definition is hidden in BPF_PROG macro 
	 keep input value the same across both files to avoid dependency on
	  handler call order; differentiate by output_weak1 vs output_weak2.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Jesper Dangaard Brouer 
 Userspace will update with MTU it can see on device 
 BPF-prog will update these with MTU values it can see 
 Expected retval on successful test 
 When ifindex is zero, save net_device lookup and use ctx netdev 
 mtu_len is also valid when check fail 
 Fail 
 Exceed MTU with 1 via delta adjust 
 Success in exceeding MTU check 
 Expected retval on successful test 
 Borderline test case: Minus delta exceeding packet length allowed 
	 Minus length (adjusted via delta) still pass MTU check, other helpers
	  are responsible for catching this, when doing actual size adjust
 Expected retval on successful test 
	 API allow user give length to check as input via mtu_len param,
	  resulting MTU value is still output in mtu_len param after call.
	 
	  Input len is L3, like MTU and iph->tot_len.
	  Remember XDP data_len is L2.
 Fail 
	 API allow user give length to check as input via mtu_len param,
	  resulting MTU value is still output in mtu_len param after call.
	 
	  Input length value is L3 size like MTU.
 Exceed with 1 
 Success in exceeding MTU check 
 Expected retval on successful test 
 Fail 
 Exceed MTU with 1 via delta adjust 
 Success in exceeding MTU check 
 SKB Direct-Access variant 
 Fail 
 Exceed MTU with 1 via delta adjust 
 Success in exceeding MTU check 
 Expected retval on successful test 
 Borderline test case: Minus delta exceeding packet length allowed 
	 Minus length (adjusted via delta) still pass MTU check, other helpers
	  are responsible for catching this, when doing actual size adjust
 Expected retval on successful test 
	 API allow user give length to check as input via mtu_len param,
	  resulting MTU value is still output in mtu_len param after call.
	 
	  Input length value is L3 size.
 Fail 
	 API allow user give length to check as input via mtu_len param,
	  resulting MTU value is still output in mtu_len param after call.
	 
	  Input length value is L3 size like MTU.
 Exceed with 1 
 Success in exceeding MTU check 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 Copied from mm.h 
 Copied from kdev_t.h 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 will set before prog run 
 will collect results during prog run 
		 test mode is used by selftests to
		  test functionality of bpf_hash_map iter.
		 
		  the above hashmap1 will have correct size
		  and will be accepted, hashmap2 and hashmap3
		  should be rejected due to smaller keyvalue
		  size.
		 update the value and then delete the <key, value> pair.
		  it should not impact the existing 'val' which is still
		  accessible under rcu.
	 non-test mode, the map is prepared with the
	  below bpftool command sequence:
	    bpftool map create sysfsbpfm1 type hash \
	    	key 12 value 8 entries 3 name map1
	    bpftool map update id 77 key 0 0 0 1 0 0 0 0 0 0 0 1 \
	    	value 0 0 0 1 0 0 0 1
	    bpftool map update id 77 key 0 0 0 1 0 0 0 0 0 0 0 2 \
	    	value 0 0 0 1 0 0 0 2
	  The bpftool iter command line:
	    bpftool iter pin .bpf_iter_bpf_hash_map.o sysfsbpfp1 \
	    	map id 77
	  The below output will be:
	    map dump starts
	    77: (1000000 0 2000000) (200000001000000)
	    77: (1000000 0 1000000) (100000001000000)
	    map dump ends
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Carlos Neira cneirabustos@gmail.com 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
	 If the verifier doesn't refine bpf_get_task_stack res, and instead
	  assumes res is entirely unknown, this program will fail to load as
	  the verifier will believe that max buf_sz value allows reading
	  past the end of entries in bpf_seq_write call
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
	 Return 1 OR'ed with the first bit set to indicate
	  that CAP_NET_BIND_SERVICE should be bypassed.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 EPERM, bounds check 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2016 VMware
  Copyright (c) 2016 Facebook
  This program is free software; you can redistribute it andor
  modify it under the terms of version 2 of the GNU General Public
  License as published by the Free Software Foundation.
 hard-coded to 8 byte 
 172.16.1.100 
 ::11 
 172.16.1.100 
 172.16.1.100 
 Set VXLAN Group Policy extension 
 ::11 
 172.16.1.100 
 Open Virtual Networking (OVN) 
 4-byte multiple 
 ::11 
 Open Virtual Networking (OVN) 
 4-byte multiple 
 single length check 
 172.16.1.100 
 single length check 
 ::11 
 single length check 
 NEXTHDR_ICMP ) {
 ::11 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
	
	  if the struct's size is multiple of 16, compiler will put it into
	  .rodata.cst16 section, which is not recognized by libbpf; work
	  around this by ensuring we don't have 16-aligned struct
 prevent compiler to optimize everything out 
 we should never enter this loop 
 prevent compiler to optimize everything out 
 validate verifier can derive loop termination 
 prevent compiler to optimize everything out 
 validate verifier can allow full loop as well 
 SPDX-License-Identifier: GPL-2.0
 One map use devmap, another one use devmap_hash for testing 
 map to store egress interfaces mac addresses 
 Using IPv4 for (BPF_F_BROADCAST | BPF_F_EXCLUDE_INGRESS) testing 
 Using IPv6 for none flag testing 
 All others for BPF_F_BROADCAST testing 
 The following 2 progs are for 2nd devmap prog testing 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 tcp_mem sysctl has only 3 ints, but this test is doing TCP_MEM_LOOPS 
 because 30 doesn't fit into 512 bytes of stack 
	 a workaround to prevent compiler from generating
	  codes verifier cannot handle yet.
 SPDX-License-Identifier: GPL-2.0
 these are identical, but keep them separate for compatibility with the
  section names expected by test_tc_redirect.sh
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 bpf_prog_array, used by kernel internally to keep track of attached BPF
  programs to a given BPF hook (e.g., for tracepoints) doesn't allow the same
  BPF program to be attached multiple times. So have three identical copies
  ready to attach to the same tracepoint.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 userspace should set it 
 to test bpf_htab.count 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 modifiers and typedefs are ignored when comparing keyvalue types 
 this definition will lose, but it has to exactly match the winner 
 update values with key = 2 
 lookup values with key = 1, set in another file 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Isovalent, Inc.
 Relocation tests for __u64s. 
 Relocation tests for strings. 
 Relocation tests for structs. 
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
	 For SYN packets coming to listening socket skb->remote_port will be
	  zero, so IPv6TCP headers are loaded to identify remote peer
	  instead.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 field order is mixed up 
 we have test_progs[-flavor], so cut flavor part 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
  load is successful
  #define TWFW_MAX_TIERS (64u)$
 rule->seqnum  64 should always be 0 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 clang will not unroll at all.
  Total program size is around 2k insns
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2017 Facebook
 llvm will optimize both subprograms into exactly the same BPF assembly
  Disassembly of section .text:
  0000000000000000 test_pkt_access_subprog1:
  ; 	return skb->len  2;
         0:	61 10 00 00 00 00 00 00	r0 = (u32 )(r1 + 0)
         1:	64 00 00 00 01 00 00 00	w0 <<= 1
         2:	95 00 00 00 00 00 00 00	exit
  0000000000000018 test_pkt_access_subprog2:
  ; 	return skb->len  val;
         3:	61 10 00 00 00 00 00 00	r0 = (u32 )(r1 + 0)
         4:	64 00 00 00 01 00 00 00	w0 <<= 1
         5:	95 00 00 00 00 00 00 00	exit
  Which makes it an interesting test for BTF-enabled verifier.
 make modification to the packet data 
 to force ordering of checks 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Cloudflare 
	 We need a temporary buffer on the stack, since the verifier doesn't
	  let us use the pointer from the context as an argument to the helper.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 WARNING: This implemenation is not necessarily the same
  as the tcp_dctcp.c.  The purpose is mainly for testing
  the kernel BPF logic.
 g = 12^4 
 Switch to fallback 
		 Switch back to myself which the bpf trampoline
		  stopped calling dctcp_init recursively.
 Switch back to fallback 
 Expecting -ENOTSUPP for tcp_cdg_res 
 Expired RTT 
 alpha = (1 - g)  alpha + g  F 
			 If dctcp_shift_g == 1, a 32bit value would overflow
			  after 8 M packets.
	 We handle RTO in dctcp_cwnd_event to ensure that we perform only
	  one loss-adjustment per RTT.
 Minimal DCTP CE state machine:
  S:	0 <- last pkt was non-CE
 	1 <- last pkt was CE
		 CE state has changed, force an immediate ACK to
		  reflect the new CE state. If an ACK was delayed,
		  send that first to reflect the prior CE state.
 Don't care for the rest. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Covalent IO, Inc. http:
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2017 Facebook
 copy paste of jhash from kernel sources to make sure llvm
  can compile it into valid sequence of bpf instructions
 Nothing left to add 
	 don't update iph->daddr, since it will overwrite old eth_proto
	  and multiple iterations of bpf_prog_run() will fail
 jhash of ipv4 packet   &&
 jhash of ipv6 packet )
 don't believe your eyes!
  below function has 6 arguments whereas bpf and llvm allow maximum of 5
  but since it's _static_ llvm can optimize one argument away
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 this weak extern will be strict due to the other file's strong extern 
 these two definitions should win 
 just make sure all the relocations work against .text as well 
	 make sure we actually use above special externs, otherwise compiler
	  will optimize them out
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
 Copyright (c) 2019, 2020 Cloudflare
  Destination port and IP used for UDP encapsulation.
 This is a bit of a hack. We need a return value which allows us to
  indicate that the regular flow of the program should continue,
  while allowing functions to use XDP_PASS and XDP_DROP, etc.
 Convenience macro to call functions which return ret_t.
 Linux packet pointers are either aligned to NET_IP_ALIGN (aka 2 bytes),
  or not aligned if the arch supports efficient unaligned access.
  Since the verifier ensures that eBPF packet accesses follow these rules,
  we can tell LLVM to emit code as if we always had a larger alignment.
  It will yell at us if we end up on a platform where this is not valid.
	 NB: tail musn't have alignment other than 1, otherwise
	 LLVM will go and eliminate code, e.g. when checking packet lengths.
	 Clang seems to optimize constructs like
	     a - b + c
	  if c is known:
	     r? = c
	     r? -= b
	     r? += a
	 
	  This is a problem if a and b are packet pointers,
	  since the verifier allows subtracting two pointers to
	  get a scalar, but not a scalar and a pointer.
	 
	  Use inline asm to break this optimization.
 Check whether off + len is valid in the non-linear part. 
 Returns a pointer to the start of buf, or NULL if len is
  larger than the remaining data. Consumes len bytes on a successful
  call.
  If scratch is not NULL, the function will attempt to load non-linear
  data via bpf_skb_load_bytes. On success, scratch is returned.
 Parse the L4 ports from a packet, assuming a layout like TCP or UDP. 
	 Ports in the L4 headers are reversed, since we are parsing an ICMP
	  payload which is going towards the eyeball.
	 The highest reasonable value for an IPv4 header
	  checksum requires two folds, so we just do that always.
	 An IP header without options is 20 bytes. Two of those
	  are the checksum, which we always set to zero. Hence,
	  the maximum accumulated value is 18  2  0xffff = 0x8fff7,
	  which fits in 32 bit.
	 We understand five extension headers.
	  https:tools.ietf.orghtmlrfc8200#section-4.1 states that all
	  headers should occur once, except Destination Options, which may
	  occur twice. Hence we give up after 6 headers.
 NB: We don't check that hdrlen == 0 as per spec. 
 fallthrough; 
 hdrlen is in 8-octet units, and excludes the first 8 octets. 
 Decode next header 
			 The next header is not one of the known extension
			  headers, treat it as the upper layer header.
			 
			  This handles IPPROTO_NONE.
			 
			  Encapsulating Security Payload (50) and Authentication
			  Header (51) also end up here (and will trigger an
			  unknown proto error later). They have a custom header
			  format and seem too esoteric to care about.
 We never found an upper layer header. 
 This function has to be inlined, because the verifier otherwise rejects it
  due to returning a pointer to the stack. This is technically correct, since
  scratch is allocated on the stack. However, this usage should be safe since
  it's the callers stack after all.
 Global metrics, per CPU
 Changing the ethertype if the encapsulated packet is ipv6
	 Loop protection: the inner packet's TTL is decremented as a safeguard
	  against any forwarding loop. As the only interesting field is the TTL
	  hop limit for IPv6, it is easier to use bpf_skb_load_bytesbpf_skb_store_bytes
	  as they handle the split packets if needed (no need for the data to be
	  in the linear section).
		 IPv4 also has a checksum to patch. While the TTL is only one byte,
		  this function only works for 2 and 4 bytes arguments (the result is
		  the same).
 swap L2 addresses 
	 This assumes that packets are received from a router.
	  So just swapping the MAC addresses here will make the packet go back to
	  the router, which will send it to the appropriate machine.
 Remove ip->saddr, add next_hop->s_addr 
 Get the next hop from the GLB header.
  Sets next_hop->s_addr to 0 if there are no more hops left.
  pkt is positioned just after the variable length GLB header
  iff the call is successful.
 Skip "used" next hops. 
 No more next hops, we are at the end of the GLB header. 
 Skip the remainig next hops (may be zero). 
 Fill a bpf_sock_tuple to be used with the socket lookup functions.
  This is a kludge that let's us work around verifier limitations:
     fill_tuple(&t, foo, sizeof(struct iphdr), 123, 321)
  clang will substitue a costant for sizeof, which allows the verifier
  to track it's value. Based on this, it can figure out the constant
  return value, and calling code works while still being "generic" to
  IPv4 and IPv6.
 Kludge: we've run out of arguments, but need the length of the ip header. 
 We should never receive encapsulated echo replies. 
	 The source address in the outer IP header is from the entity that
	  originated the ICMP message. Use the original IP header to restore
	  the correct flow tuple.
 We should never receive encapsulated echo replies. 
 Swap source and dest addresses. 
	 Pass bogus packets as long as we're not sure they're
	  destined for us.
	 Make sure that all encapsulation headers are available in
	  the linear portion of the skb. This makes it easy to manipulate them.
 We never have any options. 
 TODO Check UDP length? 
	 We now know that the packet is destined to us, we can
	  drop bogus ones.
 metrics have already been bumped 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 when an extern is defined as both strong and weak, resulting symbol will be strong 
 these two weak variables should lose 
 just make sure all the relocations work against .text as well 
	 make sure we actually use above special externs, otherwise compiler
	  will optimize them out
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2020 Google LLC.
 Copyright (c) 2016,2017 Facebook
  This program is free software; you can redistribute it andor
  modify it under the terms of version 2 of the GNU General Public
  License as published by the Free Software Foundation.
 It only does v4-in-v4 
 It only does v6-in-v6 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 unused 
 callback for inner hash map 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019, Oracle andor its affiliates. All rights reserved. 
 Record time reply received. 
 verifier is fussy here... 
 No more space for values? 
 Now convert reply back into echo request. 
 Now convert request into echo reply. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 negative offset, verifier failure. 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Google LLC. 
 The format string is filled from the userspace such that loading fails 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 It only does v4-in-v4 
 It only does v6-in-v6 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Cloudflare
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 Packet parsing state machine helpers. 
 cur_off = end of segments, start of possible TLVs
 we can only go as far as ~10 TLVs due to the BPF max stack size
 workaround: define induction variable "i" as "long" instead
 of "int" to prevent alu32 sub-register spilling.
 we reached the padding or HMAC TLVs, or the end of the SRH
 the following can't be moved inside update_tlv_pad because the
 bpf verifier has some issues with it
 cannot pad for 1 byte only
 Add an Egress TLV fc00::4, add the flag A,
 and apply End.X action to fc42::1
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 we have test_progs[-flavor], so cut flavor part 
 validate pid + tgid matches 
 test variadic BPF_CORE_READ macros 
 test BPF_CORE_READ_STR_INTO() returns correct code and contents 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 non-existing BPF helper, to test dead code elimination 
 strong 
 invalid, but dead code - never executed 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 original get_constant() returns val - 122 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  BTF-to-C dumper tests for implicit and explicit padding between fields and
  at the end of a struct.
  Copyright (c) 2019 Facebook
 ----- START-EXPECTED-OUTPUT ----- 
 ------ END-EXPECTED-OUTPUT ------ 
 ----- START-EXPECTED-OUTPUT ----- 
 struct padded_explicitly {
 	int a;
 	int: 32;
 	int b;
 };
 ------ END-EXPECTED-OUTPUT ------ 
 algo will explicitly pad with full 32 bits here 
 ----- START-EXPECTED-OUTPUT ----- 
 struct padded_a_lot {
 	int a;
 	long: 32;
 	long: 64;
 	long: 64;
 	int b;
 };
 ------ END-EXPECTED-OUTPUT ------ 
 32 bit of implicit padding here, which algo will make explicit 
 ----- START-EXPECTED-OUTPUT ----- 
 struct padded_cache_line {
 	int a;
 	long: 32;
 	long: 64;
 	long: 64;
 	long: 64;
 	int b;
 	long: 32;
 	long: 64;
 	long: 64;
 	long: 64;
 };
 ------ END-EXPECTED-OUTPUT ------ 
 ----- START-EXPECTED-OUTPUT ----- 
 struct zone_padding {
 	char x[0];
 };
 struct zone {
 	int a;
 	short b;
 	short: 16;
 	struct zone_padding __pad__;
 };
 ------ END-EXPECTED-OUTPUT ------ 
 SPDX-License-Identifier: GPL-2.0
 typically virtio scsi has max SGs of 6 
 Verifier will fail with SG_MAX = 128. The failure can be
  workarounded with a smaller SG_MAX, e.g. 10.
 typically virtio blk has max SEG of 128 
 Copyright (c) 2017 Facebook
  This program is free software; you can redistribute it andor
  modify it under the terms of version 2 of the GNU General Public
  License as published by the Free Software Foundation.
 copy paste of jhash from kernel sources to make sure llvm
  can compile it into valid sequence of bpf instructions
 Nothing left to add 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
	 This will be kept by clang, but removed by verifier. Since it is
	  marked as __weak, libbpf and gen_loader don't error out if BTF ID
	  is not found for it, instead imm and off is set to 0 for it.
 this will fail if kfunc doesn't reuse its own btf fd index 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2020 Google LLC.
 Don't let an executable delete itself 
	 new_dentry->d_inode can be NULL when the inode is renamed to a file
	  that did not exist before. The helper should be able to handle this
	  NULL pointer.
 This uses the local storage to remember the inode of the binary that a
  process was originally executing.
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 .data section 
 .bss section 
 .rodata section 
 .data section 
 .bss section 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 userspace should set it 
	 Make sure bpf_get_netns_cookie is callable.
		 Not interested in SOL_IP:IP_TOS;
		  let next BPF program in the cgroup chain or kernel
		  handle it.
 bypass optval>PAGE_SIZE 
		 Not interested in SOL_SOCKET:SO_SNDBUF;
		  let next BPF program in the cgroup chain or kernel
		  handle it.
		 Not interested in SOL_TCP:TCP_CONGESTION;
		  let next BPF program in the cgroup chain or kernel
		  handle it.
		 Verify that TCP_ZEROCOPY_RECEIVE triggers.
		  It has a custom implementation for performance
		  reasons.
 EPERM, bounds check 
 EPERM, unexpected data 
 EPERM, bounds check 
 Reset system call return value to zero 
 Always export 0x55 
		 Userspace buffer is PAGE_SIZE  2, but BPF
		  program can only see the first PAGE_SIZE
		  bytes of data.
 EPERM, unexpected data size 
 EPERM, deny everything except custom level 
 EPERM, bounds check 
 EPERM, couldn't get sk storage 
		return 0;  EPERM, kernel should not have handled
			    SOL_CUSTOM, something is wrong!
 Reset system call return value to zero 
	 Make sure bpf_get_netns_cookie is callable.
		 Not interested in SOL_IP:IP_TOS;
		  let next BPF program in the cgroup chain or kernel
		  handle it.
 bypass optval>PAGE_SIZE 
 Overwrite SO_SNDBUF value 
 EPERM, bounds check 
 Always use cubic 
 EPERM, bounds check 
 Original optlen is larger than PAGE_SIZE. 
 EPERM, unexpected data size 
 EPERM, bounds check 
 Make sure we can trim the buffer. 
		 Usepace buffer is PAGE_SIZE  2, but BPF
		  program can only see the first PAGE_SIZE
		  bytes of data.
 EPERM, unexpected data size 
 EPERM, deny everything except custom level 
 EPERM, bounds check 
 EPERM, couldn't get sk storage 
	ctx->optlen = -1;  BPF has consumed this option, don't call kernel
			    setsockopt handler.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
 Rewrite source. 
 Unexpected source. Reject sendmsg. 
 Rewrite destination. 
 Unexpected destination. Reject sendmsg. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2017 Facebook
 copy paste of jhash from kernel sources to make sure llvm
  can compile it into valid sequence of bpf instructions
 Nothing left to add 
 jhash of ipv4 packet   &&
 jhash of ipv6 packet )
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 local flavor with reversed layout 
 local flavor with nestedoverlapping layout 
	 a and c overlap in local flavor, but this should still work
	  correctly with target original flavor
 read a using weird layout 
 read b using reversed layout 
 read c using original layout 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 FIXME: nexthop_is_multipath is not handled here. 
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0
	 Structure does not need to contain all entries,
	  as "preserve_access_index" will use BTF to fix this...
	 Structure does not need to contain all entries,
	  as "preserve_access_index" will use BTF to fix this...
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
 WARNING: This implemenation is not necessarily the same
  as the tcp_cubic.c.  The purpose is mainly for testing
  the kernel BPF logic.
  Highlights:
  1. CONFIG_HZ .kconfig map is used.
  2. In bictcp_update(), calculation is changed to use usec
     resolution (i.e. USEC_PER_JIFFY) instead of using jiffies.
     Thus, usecs_to_jiffies() is not used in the bpf_cubic.c.
  3. In bitctcp_update() [under tcp_friendliness], the original
     "while (ca->ack_cnt > delta)" loop is changed to the equivalent
     "ca->ack_cnt  delta" operation.
#define BICTCP_BETA_SCALE    1024	 Scale factor beta calculation
					  max_cwnd = snd_cwnd  beta
 BIC HZ 2^10 = 1024 
 Two methods of hybrid slow start 
 Number of delay samples for detecting the increase of delay 
 4ms 
 16 ms 
 = 7171024 (BICTCP_BETA_SCALE) 
 1024crtt 
 calculate the "K" for (wmax-cwnd) = crtt  K^3
   so K = cubic_root( (wmax-cwnd)rttc )
  the unit of K is bictcp_HZ=2^10, not HZ
   c = bic_scale >> 10
   rtt = 100ms
  the following code has been designed and tested for
  cwnd < 1 million packets
  RTT < 100 seconds
  HZ < 1,000,00  (corresponding to 10 nano-second)
 1c  2^2bictcp_HZ  srtt, 2^40 
 BIC TCP Parameters 
 increase cwnd by 1 after ACKs 
 last maximum snd_cwnd 
 the last snd_cwnd 
 time when updated last_cwnd 
 origin point of bic function 
	__u32	bic_K;		 time to origin point
 min delay (usec) 
 beginning of an epoch 
 number of acks 
 estimated tcp cwnd 
 number of samples to decide curr_rtt 
 the exit point is found? 
 beginning of each round 
 end_seq of the round 
 last time when the ACK spacing is close 
 the minimum rtt of current round 
 "struct_ops" prefix is a requirement 
 "struct_ops" prefix is a requirement 
		 We were application limited (idle) for a while.
		  Shift epoch_start to keep cwnd growth to cubic curve.
  cbrt(x) MSB values for x MSB values in [0..63].
  Precomputed then refined by hand - Willy Tarreau
  For x in [0..63],
    v = cbrt(x << 18) - 1
    cbrt(x) = (v[x] + 10) >> 6
 0x00     0,   54,   54,   54,  118,  118,  118,  118,
 0x08   123,  129,  134,  138,  143,  147,  151,  156,
 0x10   157,  161,  164,  168,  170,  173,  176,  179,
 0x18   181,  185,  187,  190,  192,  194,  197,  199,
 0x20   200,  202,  204,  206,  209,  211,  213,  215,
 0x28   217,  219,  221,  222,  224,  225,  227,  229,
 0x30   231,  232,  234,  236,  237,  239,  240,  242,
 0x38   244,  245,  246,  248,  250,  251,  252,  254,
 calculate the cubic root of x using a table lookup followed by one
  Newton-Raphson iteration.
  Avg err ~= 0.195%
 a in [0..63] 
 it is needed for verifier's bound check on v 
	
	  Newton-Raphson iteration
	                          2
	  x    = ( 2  x  +  a  x  )  3
	   k+1          k         k
  Compute congestion window to use.
 count the number of ACKed packets 
	 The CUBIC function can update ca->cnt at most once per jiffy.
	  On all cwnd reduction events, ca->epoch_start is set to 0,
	  which will force a recalculation of ca->cnt.
 record beginning 
 start counting 
 syn with cubic 
			 Compute new K based on
			  (wmax-cwnd)  (srtt>>3  HZ)  c  2^(3bictcp_HZ)
 cubic function - calc
	 calculate c  time^3  rtt,
	   while considering overflow in calculation of time^3
	  (so time^3 is done by using 64 bit)
	  and without the support of division of 64bit numbers
	  (so all divisions are done by using 32 bit)
	   also NOTE the unit of those veriables
	 	  time  = (t - K)  2^bictcp_HZ
	 	  c = bic_scale >> 10
	  rtt  = (srtt >> 3)  HZ
	  !!! The following code does not have overflow problems,
	  if the cwnd < 1 million packets !!!
 change the unit from usec to bictcp_HZ 
 t - K 
 crtt  (t-K)^3 
 below origin
 above origin
 cubic function - calc bictcp_cnt
 very small increment
	
	  The initial growth of cubic function may be too conservative
	  when the available bandwidth is still unknown.
 increase cwnd 5% per RTT 
 TCP Friendly 
 update tcp cwnd 
 if bic is slower than tcp 
	 The maximum rate of cwnd increase CUBIC allows is 1 packet per
	  2 packets ACKed, meaning cwnd grows at 1.5x per RTT.
 Or simply use the BPF_STRUCT_OPS to avoid the SEC boiler plate. 
 end of epoch 
 Wmax and fast convergence 
 Account for TSOGRO delays.
  Otherwise short RTT flows could get too small ssthresh, since during
  slow start we begin with small TSO packets and ca->delay_min would
  not account for long aggregation delay when TSO packets get bigger.
  Ideally even with a very small RTT we would like to have at least one
  TSO packet being sent and received by GRO, and another one in qdisc layer.
  We apply another 100% factor because @rate is doubled at this point.
  We cap the cushion to 1ms.
 first detection parameter - ack-train detection 
			 Hystart ack train triggers if we get ack past
			  ca->delay_min2.
			  Pacing might have delayed packets up to RTT2
			  during slow start.
 obtain the minimum delay of more than sampling packets 
 Some calls are for duplicates without timetamps 
 Discard delay samples right after fast recovery 
 first time call or link delay decreases 
 hystart triggers when cwnd is larger than some threshold 
 SPDX-License-Identifier: GPL-2.0
 In-place tunneling 
 MPLS label 1000 with S bit (last label) set and ttl of 255. 
 space for L2 header  vxlan header ... 
 space for L2 header  vxlan header ... 
	 Most tests encapsulate a packet into a tunnel with the same
	  network protocol, and derive the outer header fields from
	  the inner header.
	 
	  The 6in4 case tests different inner and outer protocols. As
	  the inner is ipv6, but the outer expects an ipv4 header as
	  input, manually build a struct iphdr based on the ipv6hdr.
 Read the IPv6 header 
 Derive the IPv4 header fields from the IPv6 header 
 filter only packets we want 
 add L2 encap (if specified) 
 add room between mac and network header 
 prepare new outer network header 
 store new outer network header 
 if changing outer proto type, update eth->h_proto 
 filter only packets we want 
 add L2 encap (if specified) 
 add room between mac and network header 
 prepare new outer network header 
 store new outer network header 
 does not match, ignore 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 Copyright (c) 2017 Facebook
  This program is free software; you can redistribute it andor
  modify it under the terms of version 2 of the GNU General Public
  License as published by the Free Software Foundation.
	 Allow access to devzero and devrandom.
	  Forbid everything else.
 1:5 devzero 
 1:9 devurandom 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Test weak ksyms.
  Copyright (c) 2021 Google
 existing weak symbols 
 test existing weak symbols can be resolved. 
 typed 
 typeless 
 non-existent weak symbols. 
 typeless symbols, default to zero. 
 typed symbols, default to zero. 
 tests existing symbols. 
 tests non-existent symbols. 
 tests non-existent symbols. 
 can't happen 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
 Copyright (c) 2019 Cloudflare
 packet should only have an MSS option
 SPDX-License-Identifier: GPL-2.0
 Check multi-prog update. 
 Check tail call limit. 
 SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) 
 Sample program which should always load for testing control paths. 
 SPDX-License-Identifier: GPL-2.0
 b is certainly 0 here. Can the verifier tell? 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 sub5() is an identitify function, just to test weirder functions layout and
  call patterns
 compensates sub1()'s + 1 
 unfortunately verifier rejects `struct task_struct t` as an unkown pointer
  type, so we need to accept pointer as integer and then cast it inside the
  function
 this ensures that CO-RE relocs work in multi-subprogs .text 
	 perform some CO-RE relocations to ensure they work with multi-prog
	  sections correctly
 (1 + 1) + (2 + 3 + (4 + 1)) = 12 
 (3 + 2) + (4 + 3 + (4 + 1)) = 17 
 prog3 has the same section name as prog1 
 (5 + 3 + (4 + 1)) + 6 = 19 
 prog4 has the same section name as prog2 
 (7 + (5 + 3 + (4 + 1)) + (6 + 1)) + (8 + 1) = 36 
 SPDX-License-Identifier: GPL-2.0-only
		 BPF_CGROUP_INET_SOCK_RELEASE is _not_ called
		  when we return an error from the BPF
		  program!
 SPDX-License-Identifier: GPL-2.0
	 Multiple locations to make sure we patch
	  all of them.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 will set before prog run 
 will collect results during prog run 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
www.tessares.net> 
	 Just do it for once, when called from our own test prog. This
	  ensures the map value is only updated for a single CPU.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
 172.16.0.1 
 192.168.1.254 
 Rewrite source. 
 Unexpected source. Reject sendmsg. 
 Rewrite destination. 
 Unexpected source. Reject sendmsg. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
	 This BPF program performs variable-offset reads and writes on a
	  stack-allocated buffer.
 Copy the input to the stack. 
 The first byte in the buffer indicates the length. 
	 Append something to the buffer. The offset where we write is not
	  statically known; this is a variable-offset stack write.
	 Index into the buffer at an unknown offset. This is a
	  variable-offset stack read.
	 
	  Note that if it wasn't for the preceding variable-offset write, this
	  read would be rejected because the stack slot cannot be verified as
	  being initialized. With the preceding variable-offset write, the
	  stack slot still cannot be verified, but the write inhibits the
	  respective check on the reasoning that, if there was a
	  variable-offset to a higher-or-equal spot, we're probably reading
	  what we just wrote.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Cloudflare
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 struct type global var. 
 int type global var. 
 READ_ONCE 
 !rq has not been tested, so verifier should reject. 
 SPDX-License-Identifier: GPL-2.0
  The kernel struct pt_regs isn't exported in its entirety to userspace.
  Pass it as an array to task_pt_regs.c
 Prove that uprobe was run 
 SPDX-License-Identifier: GPL-2.0
 face:b00c:1234:5678::abcd 
 Socket in test case has guarantee that old never equals to new. 
 u8 narrow loads:
 u16 narrow loads:
 Bind to device and unbind it. 
 Test for misc socket options. 
 Set reuseport and unset 
 SPDX-License-Identifier: GPL-2.0 
 Copyright (c) 2020 Facebook 
 it's possible to use anonymous struct as inner map definition here 
		 changing max_entries to 2 will fail during load
	 (void ) cast is necessary because we didn't use `struct inner_map`
	  in __inner(values, ...)
	  Actually, a conscious effort is required to screw up initialization
	  of inner map slots, which is a great thing!
	 Here everything works flawlessly due to reuse of struct inner_map
	  and compiler will complain at the attempt to use non-inner_map
	  references below. This is great experience.
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2021. Huawei Technologies Co., Ltd 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Google LLC. 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  BTF-to-C dumper test validating no name versioning happens between
  independent C namespaces (structunionenum vs typedefenum values).
  Copyright (c) 2019 Facebook
 ----- START-EXPECTED-OUTPUT ----- 
------ END-EXPECTED-OUTPUT ------ 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 unused 
 callback for array and lru timers 
	 increment bss variable twice.
	  Once via array timer callback and once via lru timer callback
	 key == 0 - the callback was called for array timer.
	  key == 4 - the callback was called from lru timer.
 rearm array timer to be called again in ~35 seconds 
		     i <= 100   for current LRU eviction algorithm this number
				 should be larger than ~ lru->max_entries  2
			 lru_key cannot be used as loop induction variable
			  otherwise the loop will be unbounded.
			 add more elements into lru map to push out current
			  element and force deletion of this timer
 look it up to bump it into active list 
			 keep adding until key changes underneath,
			  which means that keytimer memory was reused
 check that the timer was removed 
 call timer_cb1 asap , 0);
	 init more timers to check that array destruction
	  doesn't leak timer memory.
 callback for prealloc and non-prealloca hashtab timers 
 re-arm the timer again to execute after 1 usec 
		 cancel arr_timer otherwise bpf_fentry_test1 prog
		  will stay alive forever.
			 bpf_timer_cancel should return 1 to indicate
			  that arr_timer was active at this time
 try to cancel ourself. It shouldn't deadlock. 
		 delete this key and this timer anyway.
		  It shouldn't deadlock either.
		 in preallocated hashmap both 'key' and 'val' could have been
		  reused to store another map element (like in LRU above),
		  but in controlled test environment the below test works.
		  It's not a use-after-free. The memory is owned by the map.
 try to cancel ourself. It shouldn't deadlock. 
		 delete this key and this timer anyway.
		  It shouldn't deadlock either.
		 in non-preallocated hashmap both 'key' and 'val' are RCU
		  protected and still valid though this element was deleted
		  from the map. Arm this timer for ~35 seconds. When callback
		  finishes the call_rcu will invoke:
		  htab_elem_free_rcu
		    check_and_free_timer
		      bpf_timer_cancel_and_free
		  to cancel this 35 second sleep and delete the timer for real.
 number of times to trigger timer_cb2 
 update the same key to free the timer 
 update the same key to free the timer 
	 init more timers to check that htab operations
	  don't leak timer memory.
 and with non-prealloc htab 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0 
 Copyright (c) 2021 Hengqi Chen 
 SPDX-License-Identifier: GPL-2.0
 Update results 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020, Oracle andor its affiliates.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 inputs 
 outputs 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 Though test_pkt_access_subprog2() is defined in C as:
  static __attribute__ ((noinline))
  int test_pkt_access_subprog2(int val, volatile struct __sk_buff skb)
  {
      return skb->len  val;
  }
  llvm optimizations remove 'int val' argument and generate BPF assembly:
    r0 = (u32 )(r1 + 0)
    w0 <<= 1
    exit
  In such case the verifier falls back to conservative and
  tracing program can access arguments and return value as u64
  instead of accurate types.
	 bpf_prog_load() loads "test_pkt_access.o" with BPF_F_TEST_RND_HI32
	  which randomizes upper 32 bits after BPF_ALU32 insns.
	  Hence after 'w0 <<= 1' upper bits of $rax are random.
	  That is expected and correct. Trim them.
 original get_skb_len() returns skb->len 
 check that BPF extension can read packet via direct packet access 
 check that legacy packet access helper works too 
 original get_skb_ifindex() returns val  ifindex  var 
 original get_constant() returns val - 122 
 make modifications to the packet data 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 stop the iteration 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2017 Facebook
  This program is free software; you can redistribute it andor
  modify it under the terms of version 2 of the GNU General Public
  License as published by the Free Software Foundation.
 This program shows clangllvm is able to generate code pattern
  like:
    _tcp_send_active_reset:
       0:       bf 16 00 00 00 00 00 00         r6 = r1
     ......
     335:       b7 01 00 00 0f 00 00 00         r1 = 15
     336:       05 00 48 00 00 00 00 00         goto 72
    LBB0_3:
     337:       b7 01 00 00 01 00 00 00         r1 = 1
     338:       63 1a d0 ff 00 00 00 00         (u32 )(r10 - 48) = r1
     408:       b7 01 00 00 03 00 00 00         r1 = 3
    LBB0_4:
     409:       71 a2 fe ff 00 00 00 00         r2 = (u8 )(r10 - 2)
     410:       bf a7 00 00 00 00 00 00         r7 = r10
     411:       07 07 00 00 b8 ff ff ff         r7 += -72
     412:       bf 73 00 00 00 00 00 00         r3 = r7
     413:       0f 13 00 00 00 00 00 00         r3 += r1
     414:       73 23 2d 00 00 00 00 00         (u8 )(r3 + 45) = r2
  From the above code snippet, the code generated by the compiler
  is reasonable. The "r1" is assigned to different values in basic
  blocks "_tcp_send_active_reset" and "LBB0_3", and used in "LBB0_4".
  The verifier should be able to handle such code patterns.
 This test case needs "sock" and "pt_regs" data structure.
  Recursively, "sock" needs "sock_common" and "inet_sock".
  However, this is a unit test case only for
  verifier purpose without bpf program execution.
  We can safely mock much simpler data structures, basically
  only taking the necessary fields from kernel headers.
 Define various data structures for state recording.
  Some fields are not used due to test simplification.
 The below data structure is packed in order for
  llvm compiler to generate expected code.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 runner doesn't search for \t, just ensure it compiles 
 non-NULL fmt w NULL data should result in error 
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 unused 
 callback for inner hash map 
 Do a lookup to make sure 'map' and 'key' pointers are correct 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2020 Google LLC.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
  Matches map2 definition in linked_maps2.c. Order of the attributes doesn't
   matter.
 This should be the winning map definition, but we have no way of verifying,
  so we just make sure that it links and works without errors
 update values with key = 1 
 lookup values with key = 2, set in another file 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Isovalent, Inc.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 inputs 
 outputs 
 inner state 
 copy from reserved sample to a new one... 
 ...and then discard reserved sample 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 face:b00c:1234:5678::abcd 
	 This writeread is a bit pointless but tests the verifier and
	  strparser handler for readwrite pkt data and access into sk
	  fields.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Politecnico di Torino
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 don't override the exit code 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Google LLC. 
 Convenient values to pretty-print 
 Integer types 
 IP addresses 
 Symbol lookup formatting 
 Kernel pointers 
 Strings and single-byte character embedding 
 Overflow 
 Padding of fixed width numbers 
 No args 
 No buffer 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 undef #define UNROLL 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 Testing delete 
 SPDX-License-Identifier: GPL-2.0
 fails to load without expected_attach_type = BPF_XDP_DEVMAP
  because of access to egress_ifindex
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  BTF-to-C dumper test for multi-dimensional array output.
  Copyright (c) 2019 Facebook
 ----- START-EXPECTED-OUTPUT ----- 
 ------ END-EXPECTED-OUTPUT ------ 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 write to stack 
 ignore spurious events 
 get required size 
 ignore spurious events 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 Always return CG_OK so that no pkt will be filtered out 
	 Not the testing egress traffic or
	  TCP_LISTEN (10) socket will be copied at the ingress side.
 Server socket 
 Client socket 
 Not the testing egress traffic 
 It must be a fullsock for cgroup_skbegress prog 
 Not the testing egress traffic 
 The userspace has created it for srv sk 
	 Even both cnt and cnt10 have lock defined in their BTF,
	  intentionally one cnt takes lock while one does not
	  as a test for the spinlock support in BPF_MAP_TYPE_SK_STORAGE.
 Not the testing ingress traffic to the server 
 Only interested in TCP_LISTEN 
 It must be a fullsock for cgroup_skbingress prog 
 SPDX-License-Identifier: GPL-2.0
 EPERM, bounds check 
 EPERM, unexpected optval from the kernel 
 Reset system call return value to zero 
 EPERM, bounds check 
 EPERM, unexpected optval from the kernel 
 Reset system call return value to zero 
 EPERM, bounds check 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 tcp_mem sysctl has only 3 ints, but this test is doing TCP_MEM_LOOPS 
 because 30 doesn't fit into 512 bytes of stack 
 SPDX-License-Identifier: GPL-2.0
  SOL_TCP is defined in <netinettcp.h> while
  TCP_SAVED_SYN is defined in already included <linuxtcp.h>
 Test reading fields in bpf_sock_ops using single register 
 Test failure to set largest cb flag (assumes not defined) 
 Set callback 
 Update global map w result of setsock opt 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 return value thats in invalid range
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 pragma unroll doesn't work on large loops 
 90 calls 
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
 taken from syskerneldebugtracingeventsrandomurandom_readformat 
 skip if non-zero value_p 
 The size of stackmap and stackid_hmap should be the same 
 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
 Copyright (c) 2020 Cloudflare
 Macros for least-significant byte and word accesses. 
 Addressable keyvalue constants for convenience 
 Host byte order 
 Redirect packets destined for port DST_PORT to socket at redir_map[0]. 
 Redirect packets destined for DST_IP4 address to socket at redir_map[0]. 
 Redirect packets destined for DST_IP6 address to socket at redir_map[0]. 
 Check that bpf_sk_assign() returns -EEXIST if socket already selected. 
 Success, redirect to KEY_SERVER_B 
 Check that bpf_sk_assign(BPF_SK_LOOKUP_F_REPLACE) can override selection. 
 Success, redirect to KEY_SERVER_B 
 Check that bpf_sk_assign(sk=NULL) is accepted. 
 Success, redirect to KEY_SERVER_B 
 Check that selected sk is accessible through context. 
 Try accessing unassigned (NULL) ctx->sk field 
 Assign a value to ctx->sk 
 Access ctx->sk fields 
 Reset selection 
 Assign another socket 
 Access reassigned ctx->sk fields 
 Success, redirect to KEY_SERVER_B 
 Check narrow loads from ctx fields that support them.
  Narrow loads of size >= target field size from a non-zero offset
  are not covered because they give bogus results, that is the
  verifier ignores the offset.
 Narrow loads from family field 
 Narrow loads from protocol field 
 Narrow loads from remote_port field. Expect SRC_PORT. 
 Narrow loads from local_port field. Expect DST_PORT. 
 Narrow loads from IPv4 fields 
 Expect SRC_IP4 in remote_ip4 
 Expect DST_IP4 in local_ip4 
 Expect 0.0.0.0 IPs when family != AF_INET 
 Narrow loads from IPv6 fields 
 Expect SRC_IP6 in remote_ip6 
 Expect DST_IP6 in local_ip6 
 Expect :: IPs when family != AF_INET6 
 Success, redirect to KEY_SERVER_B 
 Check that sk_assign rejects SERVER_A socket with -ESOCKNOSUPPORT 
 Success, pass to regular lookup 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2017 Facebook
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2020 Google LLC.
 MAC header is not set by the time cgroup_skbegress triggers 
 SPDX-License-Identifier: GPL-2.0
 Copyright Amazon.com Inc. or its affiliates. 
			 The name of the abstract UNIX domain socket starts
			  with '\0' and can contain '\0'.  The null bytes
			  should be escaped as done in unix_seq_show().
 unix_mkname() tests this upper bound. 
 SPDX-License-Identifier: GPL-2.0
 Force local address to 127.0.0.1:22222. 
 Rewire service 1.2.3.4:60000 to backend 127.0.0.1:60123. 
 Expose local server as 1.2.3.4:60000 to client. 
 Expose service 1.2.3.4:60000 as peer instead of backend. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause) 
 Sample program which should always load for testing control paths. 
 SPDX-License-Identifier: GPL-2.0
 172.16.1.100 
 172.16.2.100 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 non-existing symbol, weak, default to zero 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020, Oracle andor its affiliates. 
 NULL task or task->fs, don't count it as an error. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020, Oracle andor its affiliates. 
 NULL points to a readable struct lowcore on s390, so take the last page 
 Use where expected data string matches its stringified declaration 
 TRACE_EVENT(netif_receive_skb,
 	TP_PROTO(struct sk_buff skb),
 Ensure we can write skb string representation 
 Check invalid ptr value 
 Verify type display for various types. 
 simple int 
 zero value should be printed at toplevel 
 simple char 
 zero value should be printed at toplevel 
 simple typedef 
 zero value should be printed at toplevel 
 typedef struct 
 typedef with 0 value should be printed at toplevel 
 enum where enum value does (and does not) exist 
 simple struct 
 empty struct should be printed 
 struct with pointers 
 NULL pointer should not be displayed 
 struct with char array 
 leading null char means do not display string 
 handle non-printable characters 
 struct with non-char array 
 For non-char, arrays, show non-zero values only 
 struct with bitfields 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  BTF-to-C dumper tests for struct packing determination.
  Copyright (c) 2019 Facebook
 ----- START-EXPECTED-OUTPUT ----- 
------ END-EXPECTED-OUTPUT ------ 
 SPDX-License-Identifier: GPL-2.0
 only interested in SOL_CUSTOM 
 EPERM, bounds check 
 EPERM, couldn't get sk storage 
 Reset system call return value to zero 
 only interested in SOL_CUSTOM 
 EPERM, bounds check 
 EPERM, couldn't get sk storage 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 clang will not unroll the loop 600 times.
  Instead it will unroll it to the amount it deemed
  appropriate, but the loop will still execute 600 times.
  Total program size is around 90k insns
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 will set before prog run 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 only dump map1_id and map2_id 
 fill seq_file buffer 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2020 Google LLC.
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 Copyright (c) 2019 Facebook
 full unroll by llvm #undef NO_UNROLL 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 ret should be 2 
 ret should be 12 
 SPDX-License-Identifier: GPL-2.0
 Data length determine test case 
 sizeof(pkt_v4) 
 test too large offset 
 sizeof(pkt_v6) 
 Max tail grow 3520 
 No matching test 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 fixed two first members, can be extended with new fields 
 record two different relocations with the same accessor string 
 accessor: 0:0 
 accessor: 0:0 
	 Validate relocations capture array-only accesses for structs with
	  fixed header, but with potentially extendable tail. This will read
	  first 4 bytes of 2nd element of in_ext array of potentially
 accessor: 2 
 SPDX-License-Identifier: GPL-2.0
 invalid 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  BTF-to-C dumper test for majority of C syntax quirks.
  Copyright (c) 2019 Facebook
 ----- START-EXPECTED-OUTPUT ----- 
 ------ END-EXPECTED-OUTPUT ------ 
  While previous function pointers are pretty trivial (C-syntax-level
  trivial), the following are deciphered here for future generations:
  - `fn_ptr2_t`: function, taking anonymous struct as a first arg and pointer
    to a function, that takes int and returns int, as a second arg; returning
    a pointer to a const pointer to a char. Equivalent to:
 	typedef struct { int a; } s_t;
 	typedef int (fn_t)(int);
 	typedef char  const  (fn_ptr2_t)(s_t, fn_t);
  - `fn_complext_t`: pointer to a function returning struct and accepting
    union and struct. All structs and enum are anonymous and defined inline.
  - `signal_t: pointer to a function accepting a pointer to a function as an
    argument and returning pointer to a function as a result. Sane equivalent:
 	typedef void (signal_handler_t)(int);
 	typedef signal_handler_t (signal_ptr_t)(int, signal_handler_t);
  - fn_ptr_arr1_t: array of pointers to a function accepting pointer to
    a pointer to an int and returning pointer to a char. Easy.
  - fn_ptr_arr2_t: array of const pointers to a function taking no arguments
    and returning a const pointer to a function, that takes pointer to a
    `int -> char ` function and returns pointer to a char. Equivalent:
    typedef char  (fn_input_t)(int);
    typedef char  (fn_output_outer_t)(fn_input_t);
    typedef const fn_output_outer_t ( fn_output_inner_t)();
    typedef const fn_output_inner_t fn_ptr_arr2_t[5];
 ----- START-EXPECTED-OUTPUT ----- 
 ------ END-EXPECTED-OUTPUT ------ 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 define few struct-s that bpf program needs to access 
 same as kernel's struct net_device  {
 field names and sizes should match to those in the kernel 
 order of the fields doesn't matter 
 TRACE_EVENT(kfree_skb,
          TP_PROTO(struct sk_buff skb, void location),
 read eth proto 
 raw tp ignores return value 
 send first 72 byte of the packet to user space 
 fentry sees full packet including L2 header 
	 fexit sees packet without L2 header that eth_type_trans should have
	  consumed.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 NAMED_ENUM_VAL3 value is optional 
 ANON_ENUM_VAL3 value is optional 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 unsigned bitfields 
 signed bitfields 
 non-bitfields 
 bitfield read results, all as plain integers 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0
 192.168.1.254 
 127.0.0.1 
 Socket in test case has guarantee that old never equals to new. 
 u8 narrow loads:
 u16 narrow loads:
 Bind to device and unbind it. 
 Test for misc socket options. 
 Set reuseport and unset 
 SPDX-License-Identifier: GPL-2.0
 Dummy prog to test TC-BPF API 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
  These three programs get executed in a row on connect() syscalls. The
  userspace side of the test creates a client socket, issues a connect() on it
  and then checks that the local storage associated with this socket has:
  cookie_value == local_port << 8 | 0xFF
  The different parts of this cookie_value are appended by those hooks if they
  all agree on the output of bpf_get_socket_cookie().
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
 taken from syskerneldebugtracingeventsschedsched_switchformat 
 skip if non-zero value_p 
 The size of stackmap and stackid_hmap should be the same 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2020 Facebook 
 type mismatch 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 .bss 
 .data 
 ignore irrelevant invocations 
 ignore irrelevant invocations 
 ignore irrelevant invocations 
 ignore irrelevant invocations 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 weak and shared between two files 
 same "subprog" name in all files, but it's ok because they all are static 
 but different formula 
 Global functions can't be void 
 This function can't be verified as global, as it assumes raw_tpsys_enter
  context and accesses syscall id (second argument). So we mark it as
  __hidden, so that libbpf will mark it as static in the final object file,
  right before verifying it in the kernel.
  But we don't mark it as __hidden here, rather at extern site. __hidden is
  "contaminating" visibility, so it will get propagated from either extern or
  actual definition (including from the losing __weak definition).
 long id, same as in BPF_PROG below 
 this weak instance should win because it's the first one 
 here we'll force set_output_ctx2() to be __hidden in the final obj file 
 ctx definition is hidden in BPF_PROG macro 
	 keep input value the same across both files to avoid dependency on
	  handler call order; differentiate by output_weak1 vs output_weak2.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
  This program is free software; you can redistribute it andor
  modify it under the terms of version 2 of the GNU General Public
  License as published by the Free Software Foundation.
 sizeof(pkt_v4) 
 shrink too much 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2020 Google LLC.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 stop the iteration 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 out of bound access w.r.t. hashmap1 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 impossible path 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 It was in cookie mode 
 Is it the testing traffic? 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2020 Google LLC.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Isovalent, Inc. 
 This will make map creation to fail 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 pragma unroll doesn't work on large loops 
 90 calls 
 SPDX-License-Identifier: GPL-2.0 
 Copyright (c) 2018 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 only pass through sys_enters from test process 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 filter out udp6 sockets 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 spin_lock in hash map 
 spin_lock in array 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Cloudflare
 toggled by user-space 
 toggled by user-space 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 SPDX-License-Identifier: GPL-2.0 
 Copyright (c) 2018 Covalent IO, Inc. http:
 Fill 'tuple' with L3 info, and attempt to find L4. On fail, return NULL. 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook 
	
	  The ip_protocol could be a compile time decision
	  if the bpf_prog.o is dedicated to either TCP or
	  UDP.
	 
	  Otherwise, reuse_md->ip_protocol or
	  the protocol field in the iphdr can be used.
			 The connection is being torn down at the end of a
			  test. It can't contain a cmd, so return early.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 data_map[2] = in_val; 
 data_map[1] = data_map[0]  2; 
 data_map[far] = in_val  3; 
 Packet parsing state machine helpers. 
 cur_off = end of segments, start of possible TLVs
 we can only go as far as ~10 TLVs due to the BPF max stack size
 we reached the padding or HMAC TLVs, or the end of the SRH
 the following can't be moved inside update_tlv_pad because the
 bpf verifier has some issues with it
 cannot pad for 1 byte only
 cannot pad for 1 byte only
 check if egress TLV value is correct
 This function will push a SRH with segments fd00::1, fd00::2, fd00::3,
 fd00::4
 room for 4 segments
 Add an Egress TLV fc00::4, add the flag A,
 and apply End.X action to fc42::1
 Pop the Egress TLV, reset the flags, change the tag 2442 and finally do a
 simple End action
 4 segments + Egress TLV + Padding TLV
 Inspect if the Egress TLV and flag have been removed, if the tag is correct,
 then apply a End.T action to reach the last segment
 4 segments
 SPDX-License-Identifier: GPL-2.0
 set all the flags which should return -EINVAL 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2020 Facebook 
 type mismatch 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 unsigned bitfields 
 signed bitfields 
 non-bitfields 
 bitfield read results, all as plain integers 
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 SPDX-License-Identifier: GPL-2.0
 the maximum delay we are willing to add (drop packets beyond that) 
 flow_key => last_tstamp timestamp used 
 should we throttle? 
 do not queue past the time horizon 
 set ecn bit, if needed 
 drop malformed packets 
 drop malformed packets 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
	 [1] &level passed to external function that may change it, it's
	      incompatible with loop unroll.
	 Loop unroll can't be used here due to [1]. Unrolling manually.
	  Number of calls should be in sync with NUM_CGROUP_LEVELS.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2020 Google LLC.
 lsm is ok, lsm.s fails 
 SPDX-License-Identifier: GPL-2.0
 192.168.1.254 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
		 FIXME: temporary use bpf_probe_read_kernel here, needs
		  verifier support to do direct access.
		 FIXME: container_of inside SOCK_INODE has a forced
		  type conversion, and direct access cannot be used
		  with current verifier.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
	 max entries and value_size will be set programmatically.
	  They are configurable from the userspace bench program.
	 max entries,  value_size, and # of hash functions will be set
	  programmatically. They are configurable from the userspace
	  bench program.
	 max entries, key_size, and value_size, will be set
	  programmatically. They are configurable from the userspace
	  bench program.
 Tracks the number of hits, drops, and false hits 
 stop the iteration 
 SPDX-License-Identifier: GPL-2.0 
 Copyright (c) 2018 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Cloudflare Ltd.
 Copyright (c) 2020 Isovalent, Inc.
 Pin map under sysfsbpftcglobals<map name> 
 Must match struct bpf_elf_map layout from iproute2 
 Fill 'tuple' with L3 info, and attempt to find L4. On fail, return NULL. 
 Options are not supported 
	 Note that the verifier socket return type for bpf_skc_lookup_tcp()
	  differs from bpf_sk_lookup_udp(), so even though the C-level type is
	  the same here, if we try to share the implementations they will
	  fail to verify because we're crossing pointer types.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
	 The implementation here tailored to a particular
	  setting of USER_HZ.
 SPDX-License-Identifier: GPL-2.0
 test ir decoder
 Copyright (C) 2018 Sean Young <sean@mess.org>
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2017 Facebook
 taken from syskerneldebugtracingeventsschedsched_switchformat 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
	 The implementation here tailored to a particular
	  setting of USER_HZ.
 SPDX-License-Identifier: GPL-2.0
  Check if we can migrate child sockets.
    1. If reuse_md->migrating_sk is NULL (SYN packet),
         return SK_PASS without selecting a listener.
    2. If reuse_md->migrating_sk is not NULL (socket migration),
         select a listener (reuseport_map[migrate_map[cookie]])
  Author: Kuniyuki Iwashima <kuniyu@amazon.co.jp>
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 +1 for flags 
 RESEND bit does not use a byte 
 +1 kind, +1 kind-len 
 bpf_test_option is not found 
		 We should not even be called since no header
		  space has been reserved.
	 Same as the nodata version.  Mostly to show
	  an example usage on skops->skb_len.
 Reserve maximum that may be needed 
 The kernel is calculating the MSS 
		 Don't clear the write_hdr cb now because
		  the ACK may get lost and retransmit may
		  be needed.
		 
		  PARSE_ALL_HDR cb flag is set to learn if this
		  resend_syn option has received by the peer.
		 
		  The header option will be resent until a valid
		  packet is received at handle_parse_hdr()
		  and all hdr cb flags will be cleared in
		  handle_parse_hdr().
 No options will be written from now 
		 saved_syn is not found. It was in syncookie mode.
		  We have asked the active side to resend the options
		  in ACK, so try to find the bpf_test_option from ACK now.
	 ENOMSG: The bpf_test_option is not found which is fine.
	  Bail out now for all other errors.
 Fastopen 
		 Cannot clear cb_flags to stop write_hdr cb.
		  synack is not sent yet for fast open.
		  Even it was, the synack may need to be retransmitted.
		 
		  PARSE_ALL_HDR cb flag is set to learn
		  if synack has reached the peer.
		  All cb_flags will be cleared in handle_parse_hdr().
 No options will be written from now 
		 The PARSE_ALL_HDR cb flag was turned on
		  to ensure that the previously written
		  options have reached the peer.
		  Those previously written option includes:
		      - Active side: resend_syn in ACK during syncookie
		       or
		      - Passive side: SYNACK during fastopen
		 
		  A valid packet has been received here after
		  the 3WHS, so the PARSE_ALL_HDR cb flag
		  can be cleared now.
		 Active side resent the syn option in ACK
		  because the server was in syncookie mode.
		  A valid packet has been received, so
		  clear header cb flags if there is no
		  more option to send.
		 Passive side was in fastopen.
		  A valid packet has been received, so
		  the SYNACK has reached the peer.
		  Clear header cb flags if there is no more
		  option to send.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 some types are shared with test_core_reloc_type_based.c 
 preserve types even if Clang doesn't support built-in 
	 We use __builtin_btf_type_id() in this tests, but up until the time
	  __builtin_preserve_type_info() was added it contained a bug that
	  would make this test fail. The bug was fixed ([0]) with addition of
	  __builtin_preserve_type_info(), though, so that's what we are using
	  to detect whether this test has to be executed, however strange
	  that might look like.
	 
	    [0] https:reviews.llvm.orgD85174
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 pragma unroll doesn't work on large loops 
 90 calls 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 shuffled layout for relocatable (CO-RE) reads 
	 next pointers for kernel address space have to be initialized from
	  BPF side, user-space mmaped addresses are stil user-space addresses
 SPDX-License-Identifier: GPL-2.0
 Permit pretty deep stack traces 
 Allocate per-cpu space twice the needed. For the code below
    usize = bpf_get_stack(ctx, raw_data, max_len, BPF_F_USER_STACK);
    if (usize < 0)
      return 0;
    ksize = bpf_get_stack(ctx, raw_data + usize, max_len - usize, 0);
  If we have value_size = MAX_STACK_RAWTP  sizeof(__u64),
  verifier will complain that access "raw_data + usize"
  with size "max_len - usize" may be out of bound.
  The maximum "raw_data + usize" is "raw_data + max_len"
  and the maximum "max_len - usize" is "max_len", verifier
  concludes that the maximum buffer access range is
  "raw_data[0...max_len  2 - 1]" and hence reject the program.
  Doubling the to-be-used max buffer size can fix this verifier
  issue and avoid complicated C programming massaging.
  This is an acceptable workaround since there is one entry here.
 write both kernel and user stacks to the same buffer 
 SPDX-License-Identifier: GPL-2.0
 IPPROTO_GRE 
 172.16.1.100 
 172.16.16.100 
 172.16.1.100 
 172.16.16.100 
 IPPROTO_GRE 
 fb01::1 
 fb10::1 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 options received at passive side 
 Check the header received from the active side 
 IPv6 (40) + Max TCP hdr (60) 
 The option is 4 bytes long instead of 2 bytes 
 Test searching magic with regular kind 
 Test searching experimental option with invalid kind length 
 Test searching experimental option with 0 magic value 
	 Test loading from skops->syn_skb if sk_state == TCP_NEW_SYN_RECV
	 
	  Test loading from tp->saved_syn for other sk_state.
	 Reserve more than enough to allow the -EEXIST test in
	  the write_active_opt().
 Store the same exprm option 
 Check the option has been written and can be searched 
		 Search the win scale option written by kernel
		  in the SYN packet.
		 Write the win scale option that kernel
		  has already written.
 Check the SYN from bpf_sock_ops_kern->syn_skb 
 Passive side should have cleared the write hdr cb by now 
	 Passive side is not writing any non-standardunknown
	  option, so the active side should never be called.
 No more write hdr cb 
 Recheck the SYN but check the tp->saved_syn this time 
 The ack has header option written by the active side also 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 Max supported length of a string with unsigned long in base 10 (pow2 - 1). 
 Max supported length of sysctl value string (pow2). 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Covalent IO, Inc. http:
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 int a.a.a and b.b.b accesses 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  BTF-to-C dumper test for topological sorting of dependent structs.
  Copyright (c) 2019 Facebook
 ----- START-EXPECTED-OUTPUT ----- 
------ END-EXPECTED-OUTPUT ------ 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 fields of exactly the same size 
 unsigned fields that have to be downsized by libbpf 
 total sz: 40 
 fields with signed integers of wrong size, should be rejected 
 real layout and sizes according to test's (32-bit) BTF 
 can't use `void `, it is always 8 byte in BPF target 
 total sz: 20 
 make sure no accidental zeros are present 
 Prevent "subtraction from stack pointer prohibited"  \
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Google 
 percpu struct fields 
 percpu int 
 cpu_rq(0)->cpu 
 struct type global var. 
 int type global var. 
 test bpf_per_cpu_ptr() 
 should always be valid, but we can't spare the check. 
 test bpf_this_cpu_ptr 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0
   Copyright(c) 2018 Jesper Dangaard Brouer.
  XDPTC VLAN manipulation example
  GOTCHA: Remember to disable NIC hardware offloading of VLANs,
  else the VLAN tags are NOT inlined in the packet payload:
   # ethtool -K ixgbe2 rxvlan off
  Verify setting:
   # ethtool -k ixgbe2 | grep rx-vlan-offload
   rx-vlan-offload: off
 linuxif_vlan.h have not exposed this as UAPI, thus mirror some here
 	struct vlan_hdr - vlan header
 	@h_vlan_TCI: priority and VLAN ID
 	@h_vlan_encapsulated_proto: packet type ID or len
 Priority Code Point 
 Canonical Format Indicator 
 VLAN Identifier 
 Make sure packet is large enough for parsing eth + 2 VLAN headers 
 Handle outer VLAN tag 
 Handle inner (double) VLAN tag 
 Convert to host-byte-order 
 Hint, VLANs are choosen to hit network-byte-order issues 
 0xFAB 
 #define TO_VLAN  4000  0xFA0 (hint 0xOA0 = 160) 
 Drop specific VLAN ID example 
	
	  Using XDP_ABORTED makes it possible to record this event,
	  via tracepoint xdp:xdp_exception like:
	   # perf record -a -e xdp:xdp_exception
	   # perf script
Commands to setup VLAN on Linux to test packets gets dropped:
 export ROOTDEV=ixgbe2
 export VLANID=4011
 ip link add link $ROOTDEV name $ROOTDEV.$VLANID type vlan id $VLANID
 ip link set dev  $ROOTDEV.$VLANID up
 ip link set dev $ROOTDEV mtu 1508
 ip addr add 100.64.40.1124 dev $ROOTDEV.$VLANID
Load prog with ip tool:
 ip link set $ROOTDEV xdp off
 ip link set $ROOTDEV xdp object xdp_vlan01_kern.o section xdp_drop_vlan_4011
 Changing VLAN to zero, have same practical effect as removing the VLAN. 
 Change specific VLAN ID 
 Modifying VLAN, preserve top 4 bits 
  Show XDP+TC can cooperate, on creating a VLAN rewriter.
  1. Create a XDP prog that can "pop"remove a VLAN header.
  2. Create a TC-bpf prog that egress can add a VLAN header.
 Ethernet MAC address length 
 bytes 
 bytes 
 Skip packet if no outer VLAN was detected 
 Moving Ethernet header, dest overlap with src, memmove handle this 
	
	  Notice: Taking over vlan_hdr->h_vlan_encapsulated_proto, by
	  only moving two MAC addrs (12 bytes), not overwriting last 2 bytes
 Note: LLVM built-in memmove inlining require size to be constant 
 Move start of packet header seen by Linux kernel stack 
 delete p[7] was vlan_hdr->h_vlan_TCI 
 delete p[6] was ethhdr->h_proto 
	 Assuming VLAN hdr present. The 4 bytes in p[3] that gets
	  overwritten, is ethhdr->h_proto and vlan_hdr->h_vlan_TCI.
	  The vlan_hdr->h_vlan_encapsulated_proto take over role as
	  ethhdr->h_proto.
 Skip packet if no outer VLAN was detected 
 Simply shift down MAC addrs 4 bytes, overwrite h_proto + TCI 
 Move start of packet header seen by Linux kernel stack 
=====================================
   BELOW: TC-hook based ebpf programs
  ====================================
  The TC-clsact eBPF programs (currently) need to be attach via TC commands
Commands to setup TC to use above bpf prog:
export ROOTDEV=ixgbe2
export FILE=xdp_vlan01_kern.o
# Re-attach clsact to clearflush existing role
tc qdisc del dev $ROOTDEV clsact 2> devnull ;\
tc qdisc add dev $ROOTDEV clsact
# Attach BPF prog EGRESS
tc filter add dev $ROOTDEV egress \
  prio 1 handle 1 bpf da obj $FILE sec tc_vlan_push
tc filter show dev $ROOTDEV egress
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  BTF-to-C dumper tests for bitfield.
  Copyright (c) 2019 Facebook
 ----- START-EXPECTED-OUTPUT ----- 
 struct bitfields_only_mixed_types {
 	int a: 3;
 	long b: 2;
 	_Bool c: 1;
 	enum {
 		A = 0,
 		B = 1,
 	} d: 1;
 	short e: 5;
 	int: 20;
 	unsigned int f: 30;
 };
 ------ END-EXPECTED-OUTPUT ------ 
 it's really a _Bool type 
 A = 0, dumper is very explicit 
 B = 1, same 
 20-bit padding here 
 this gets aligned on 4-byte boundary 
 ----- START-EXPECTED-OUTPUT ----- 
 struct bitfield_mixed_with_others {
 	char: 4;
 	int a: 4;
 	short b;
 	long c;
 	long d: 8;
 	int e;
 	int f;
 };
 ------ END-EXPECTED-OUTPUT ------ 
 char is enough as a backing field 
 8-bit implicit padding 
 combined with previous bitfield 
 4 more bytes of implicit padding 
 24 bits implicit padding 
 combined with previous bitfield 
 4 bytes of padding 
 ----- START-EXPECTED-OUTPUT ----- 
 struct bitfield_flushed {
 	int a: 4;
 	long: 60;
 	long b: 16;
 };
 ------ END-EXPECTED-OUTPUT ------ 
 flush until next natural alignment boundary 
 SPDX-License-Identifier: GPL-2.0
 invalid program on DEVMAP entry;
  SEC name means expected attach type not set
 valid program on DEVMAP entry via SEC name;
  has access to egress and ingress ifindex
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 4 byte hole 
 spin_lock in hash map run time test 
 spin_lock in array. virtual queue demo 
 spin_lock in cgroup local storage 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 SPDX-License-Identifier: GPL-2.0 
 Copyright (c) 2021 Hengqi Chen 
 trigger unix_listen 
 SPDX-License-Identifier: GPL-2.0
 pid ,
 cpu 0 , -1 
 flags );
 query (getpid(), pmu_fd) 
 SPDX-License-Identifier: GPL-2.0
 find map fds 
 give some time for bpf program run 
 disable stack trace collection 
	 for every element in stackid_hmap, we can find a corresponding one
	  in stackmap, and vise versa.
 SPDX-License-Identifier: GPL-2.0
  Tests for attaching, detaching, and replacing flow_dissector BPF program.
 Expect success when attaching a different program 
 Expect failure when attaching the same program twice 
 Expect failure creating link when another link exists 
 Expect failure creating link when prog attached 
 Expect failure attaching prog when link exists 
 Expect failure detaching prog when link exists 
 Expect no prog attached after successful detach 
 Expect no prog attached after closing last link FD 
 Expect success replacing the prog when old prog not specified 
 Expect success F_REPLACE and old prog specified to succeed 
 Expect success updating the prog with the same one 
 Expect update to fail w old prog FD but wo F_REPLACE
 Expect update to fail on old prog FD mismatch 
 Expect update to fail for invalid old prog FD 
 Expect update to fail with invalid flags 
 Expect failure when new prog FD is not valid 
 Expect failure when new prog FD type doesn't match 
 Expect failure when netns destroyed 
 Expect link info to be sane and match prog and netns details 
 Expect no info change after update except in prog id 
 Leave netns link is attached to and close last FD to it 
 Expect netns_ino to change to 0 
 First run tests in root network namespace 
 Then repeat tests in a non-root namespace 
 Move back to netns we started in. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 trigger tracepoint 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 trigger 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 not check contents, but ensure read() ends without error 
 The expected string is less than 16 bytes 
 unlink this path if it exists. 
	 file based iterator seems working fine. Let us a link update
	  of the underlying link and `cat` the iterator again, its content
	  should change.
	 create two maps: bpf program will only do bpf_seq_write
	  for these two maps. The goal is one map output almost
	  fills seq_file buffer and then the other will trigger
	  overflow and needs restart.
	 bpf_seq_printf kernel buffer is 8 pages, so one map
	  bpf_seq_write will mostly fill it, and the other map
	  will partially fill and then trigger overflow and need
	  bpf_seq_read restart.
 setup filtering map_id in bpf program 
 do read 
 iterator with hashmap2 and hashmap3 should fail 
 hashmap1 should be good, update map values here 
 do some tests 
 test results 
 update map values here 
 do some tests 
 test results 
 do some tests 
 test results 
 update map values here 
 do some tests 
 test results 
 An iterator program deletes all local storage in a map. 
 do some tests 
 test results 
 This creates a socket and its local storage. It then runs a task_iter BPF
  program that replaces the existing socket local storage with the tgid of the
  only task owning a file descriptor to this socket, this process, prog_tests.
  It then runs a tcp socket iterator that negates the value in the existing
  socket local storage, the test verifies that the resulting value is -pid.
 do some tests 
 test results 
 remove \0 and \t from str, and only keep the first line 
	 Read CMP_BUFFER_SIZE (1kB) from bpf_iter. Read in small chunks
	  to trigger seq_file corner cases. The expected output is much
	  longer than 1kB, so the while loop will terminate.
 read CMP_BUFFER_SIZE (1kB) from procpidmaps 
 strip and compare the first line of the two files 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020 Google LLC.
 SPDX-License-Identifier: GPL-2.0
  Copyright 2020 Google LLC.
 TODO: conflict with get_func_ip_test 
 input_retval ,
 want_side_effect ,
 want_ret );
 input_retval ,
 want_side_effect ,
 want_ret );
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Data past the end of the kernel's struct xdp_md must be 0 
 Meta data's size must be a multiple of 4 
 data_meta must reference the start of data 
 Meta data must be 32 bytes or smaller 
 Total size of data must match data_end - data_meta 
 RX queue cannot be specified without specifying an ingress 
	 Interface 1 is always the loopback interface which always has only
	  one RX queue (index 0). This makes index 1 an invalid rx queue index
	  for interface 1.
 The egress cannot be specified 
 SPDX-License-Identifier: GPL-2.0
 only trigger BPF program for current process 
 trigger few samples, some will be skipped 
 skipped, no ringbuf in slot 1 
 poll for samples, should get 2 ringbufs back 
 expect extra polling to return nothing 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 Allow fastopen without fastopen cookie 
	 Clear the RESEND to ensure the bpf prog can learn
	  want_cookie and set the RESEND by itself.
 Enforce syncookie mode 
 MSG_EOR to ensure skb will not be combined 
 The last ACK may have been delayed, so it is either 1 or 2. 
 SPDX-License-Identifier: GPL-2.0
 BPF_REG_1 - 1st argument: context
 BPF_REG_2 - 2nd argument: offset, start at first byte
 BPF_REG_3 - 3rd argument: destination, reserve byte on stack
 BPF_REG_4 - 4th argument: copy one byte
 bpf_skb_load_bytes(ctx, sizeof(pkt_v4), ptr, 1)
 if (ret == 0) return BPF_DROP (2)
 if (ret != 0) return BPF_OK (0)
	 make sure bpf_skb_load_bytes is not allowed from skb-less context
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 Load BTF in native endianness 
 Get raw BTF data in non-native endianness... 
 ...and open it as a new BTF instance 
 both raw data should be identical (with non-native endianness) 
 make sure that at least BTF header data is really swapped 
 swap it back to native endianness 
 now header should have native BTF_MAGIC 
 now modify original BTF 
 and re-open swapped raw data again 
 the type should appear as if it was stored in native endianness 
 SPDX-License-Identifier: GPL-2.0
 check that opening fails with invalid pinning value in map def 
 open the valid object file  
 check that pinmap was pinned 
 check that nopinmap was not pinned 
 check that nopinmap2 was not pinned 
 check that same map ID was reused for second load 
 should be no-op to re-pin same map 
 but error to pin at different location 
 unpin maps with a pin_path set 
 and re-pin them... 
 get pinning path 
 set pinning path of other map and re-pin all 
 get pinning path after set 
 should only pin the one unpinned map 
 check that nopinmap was pinned at the custom path 
 remove the custom pin path to re-test it with auto-pinning below 
 open the valid object file again 
	 set pin paths so that nopinmap2 will attempt to reuse the map at
	  pinpath (which will fail), but not before pinmap has already been
	  reused
 should fail because of map parameter mismatch 
 nopinmap2 should have been pinned and cleaned up again 
 pinmap should still be there 
 test auto-pinning at custom path with open opt 
 check that pinmap was pinned at the custom path 
 remove the custom pin path to re-test it with reuse fd below 
 test pinning at custom path with reuse fd 
 check that pinmap was pinned at the custom path 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 enforce 64-bit arch 
 [1] int 
 [2] ptr to int 
 [3] struct s1 { 
      int f1; 
 } 
 pointer size should be "inherited" from main BTF 
 [4] struct s2 {	
      struct s1 f1;	
      int f2;		
      int f3;	
 } 
 BTF-to-C dump of split BTF 
 some libc implementations don't do this 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 TCP_CA_NAME_MAX 
 Verify the setsockopt cc change 
 TCP_CA_NAME_MAX 
 destroy can take null and error pointer 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 trigger everything 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 install signal handler and notify parent 
 close read 
 close write 
		 boost with a high priority so we got a higher chance
		  that if an interrupt happens, the underlying task
		  is this process.
 notify parent signal handler is installed 
 make sure parent enabled bpf program to send_signal 
 wait a little for signal handler 
 wait for parent notification and exit 
 restore the old priority 
 close write 
 close read 
 group id , 0 
 wait until child signal handler installed 
 trigger the bpf send_signal 
 notify child that bpf program can send_signal now 
 wait for result 
 notify child safe to exit 
	 Some setups (e.g. virtual machines) might run with hardware
	  perf events disabled. If this is the case, skip this test.
 pid ,
 cpu , -1  flags );
 Let the test fail with a more informative message 
 SPDX-License-Identifier: GPL-2.0
 failure cases 
 SPDX-License-Identifier: GPL-2.0
 query the number of effective progs and attach flags in root cg 
 query the number of effective progs in last cg 
 query the effective prog IDs in last cg 
 detach bottom program and ping again 
 mix in with non link-based multi-attachments 
 detach link 
 detach legacy 
 attach legacy exclusive prog attachment 
 attempt to mix in with multi-attach bpf_link 
 detach 
 attach back link-based one 
 check legacy exclusive prog can't be attached 
 replace BPF programs inside their links for all but first link 
 Attempt program update with wrong expected BPF program 
 Compare-exchange single link program from egress to egress_alt 
 ping 
 close cgroup FDs before detaching links 
 BPF programs should still get called 
 cgroup_id should be zero in link_info 
 First BPF program shouldn't be called anymore 
 leave cgroup and remove them, don't detach programs 
 BPF programs should have been auto-detached 
 SPDX-License-Identifier: GPL-2.0
TC_ACT_REDIRECT || size != 54 ||
TC_ACT_REDIRECT || size != 74 ||
 SPDX-License-Identifier: GPL-2.0-only
 Triggers BPF program that updates map with given key and value 
 Setup program and fill the map. 
 Lookup and delete element. 
 Fetched value should match the initially set value. 
 Check that the entry is non existent. 
 Setup program and fill the map. 
 Lookup and delete element. 
 Fetched value should match the initially set value. 
 Check that the entry is non existent. 
 Setup program and fill the LRU map. 
 Insert new element at key=3, should reuse LRU element. 
 Lookup and delete element 3. 
 Value should match the new value. 
 Check that entries 3 and 1 are non existent. 
 Setup program and fill the LRU map. 
 Insert new element at key=3, should reuse LRU element 1. 
 Clean value. 
 Lookup and delete element 3. 
 Check if only one CPU has set the value. 
 Check that entries 3 and 1 are non existent. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 .type = PERF_TYPE_SOFTWARE, 
 pid ,
 cpu 0 , -1 
 flags );
 create kernel and user stack traces for testing 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 trigger tracepoint 
 attach fentryfexit and make sure it get's module reference 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2019 Facebook 
 invalid cpu ID should fail with ENXIO 
 non-zero cpu wo BPF_F_TEST_RUN_ON_CPU should fail with EINVAL 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
		 If jit is enabled, we do not have a good way to
		  verify the sanity of the kernel stack. So we
		  just assume it is good if the stack is not empty.
		  This could be improved in the future.
 trigger some syscall action 
 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
 Copyright (c) 2020 Cloudflare
	 We want to simulate packets arriving at conn, so we have to
	  swap src and dst.
 SPDX-License-Identifier: GPL-2.0
 ensure we can lookup internal maps by their ELF names 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 load program 
 attach probe 
 trigger 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 trigger everything 
 SPDX-License-Identifier: GPL-2.0
 Demonstrate that bpf_snprintf_btf succeeds and that various data types
  are formatted correctly.
 generate receive event 
	
	  Make sure netif_receive_skb program was triggered
	  and it set expected return values from bpf_trace_printk()s
	  and all tests ran.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020 Google LLC.
 Check that already linked program can't be attached again. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 retprobe ,
 self pid ,
 trigger & validate uprobe 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 enforce 64-bit arch 
 [1] int 
 [2] ptr to int 
 [3] struct s1 { 
      int f1; 
 } 
 pointer size should be "inherited" from main BTF 
 [4] struct s2 {	
      struct s1 f1;	
      int f2;		
      int f3;	
 } 
 duplicated int 
 [5] int 
 duplicated struct s1 
 [6] struct s1 { 
      int f1; 
 } 
 enforce 64-bit arch 
 [1] int 
 [2] ptr to struct s1 
 [3] ptr to struct s2 
 [4] struct s1 { 
      struct s1 f1; 
      struct s2 f2; 
 } 
 [5] struct s2 { 
      int f1; 
 } 
 [6] int 
 [7] ptr to struct s1 
 [8] fwd for struct s2 
 [9] ptr to fwd struct s2 
 [10] struct s1 { 
      struct s1 f1; 
      struct s2 f2; 
 } 
 enforce 64-bit arch 
 [1] int 
 [2] ptr to struct s1 
 [3] fwd for struct s2 
 [4] ptr to fwd struct s2 
 [5] struct s1 { 
      struct s1 f1; 
      struct s2 f2; 
 } 
 [6] int 
 [7] ptr to struct s1 
 [8] fwd for struct s2 
 [9] ptr to struct s2 
 [10] struct s1 { 
      struct s1 f1; 
      struct s2 f2; 
 } 
 [11] struct s2 {	
      struct s1 f1;	
      struct s2 f2;	
      int f3;		
      struct s1 f4;	
 } 
 [12] ptr to fwd struct s2 
 [13] struct s3 { 
      struct s2 f1; (fwd) 
 } 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Keep in sync with 'flags' from eth_get_headlen. 
		 For skb-less case we can't pass input flags; run
		  only the tests that have a matching set of flags.
	 Do the same tests but for skb-less flow dissector.
	  We use a known path in the nettun driver that calls
	  eth_get_headlen and we manually export bpf_flow_keys
	  via BPF map in this case.
 Test direct prog attachment 
 Test indirect prog attachment via link 
 SPDX-License-Identifier: GPL-2.0 
 Copyright (c) 2021 Hengqi Chen 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 full unroll by llvm 
 full unroll by llvm 
 full unroll by llvm 
	 partial unroll. llvm will unroll loop ~150 times.
	  C loop count -> 600.
	  Asm loop count -> 4.
	  16k insns in loop body.
	  Total of 5 such loops. Total program size ~82k insns.
	 no unroll at all.
	  C loop count -> 600.
	  ASM loop count -> 600.
	  ~110 insns in loop body.
	  Total of 5 such loops. Total program size ~1500 insns.
 fails );
	 partial unroll. 19k insn in a loop.
	  Total program size 20.8k insn.
	  ~350k processed_insns
 no unroll, tiny loops 
 no unroll, tiny loops 
 non-inlined subprogs 
 SPDX-License-Identifier: GPL-2.0
 NOTE: cause events loss 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2020 Google LLC.
	 Assert that we can access the metadata in skel and the values are
	  what we expect.
 Assert that binding metadata map to prog again succeeds. 
	 Assert that we can access the metadata in skel and the values are
	  what we expect.
 Assert that binding metadata map to prog again succeeds. 
 SPDX-License-Identifier: GPL-2.0
 Step 1: Check base connectivity works without any BPF. 
 Step 2: Check BPF policy prog attached to cgroups drops connectivity. 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2019 Facebook 
 pid ,
 cpu 0 , -1  flags );
 closing mfd, prog still holds a reference on map 
 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
  This test sets up 3 netns (src <-> fwd <-> dst). There is no direct veth link
  between src and dst. The netns fwd has veth links to each src and dst. The
  client is in src and server in dst. The test installs a TC BPF program to each
  host facing veth in fwd which calls into i) bpf_redirect_neigh() to perform the
  neigh addr population and redirect or ii) bpf_redirect_peer() for namespace
  switch from ingress side; it also installs a checker prog on the egress side
  to drop unexpected traffic.
	 Switch sys to the new namespace so that e.g. sysclassnet
	  reflects the devices in the new namespace.
  open_netns() - Switch to specified network namespace by name.
  Returns token with which to restore the original namespace
  using close_netns().
 setup in 'src' namespace 
 setup in 'fwd' namespace 
	 The fwd netns automatically gets a v6 LL address  routes, but also
	  needs v4 one in order to start ARP probing. IP4_NET route is added
	  to the endpoints so that the ARP processing will reply.
 setup in 'dst' namespace 
 bpf_fib_lookup() checks if forwarding is enabled 
	 Start a L3 TUNTAP tunnel between the src and dst namespaces.
	  This test is using TUNTAP instead of e.g. IPIP or GRE tunnel as those
	  expose the L2 headers encapsulating the IP packet to BPF and hence
	  don't have skb in suitable state for this test. Alternative to TUNTAP
	  would be e.g. Wireguard which would appear as a pure L3 device to BPF,
	  but that requires much more complicated setup.
	 Load "tc_src_l3" to the tun_fwd interface to redirect packets
	  towards dst, and "tc_dst" to redirect packets
	  and "tc_chk" on veth_dst_fwd to drop non-redirected packets.
 Setup route and neigh tables 
	 Run the tests in their own thread to isolate the namespace changes
	  so they do not affect the environment of other tests.
	  (specifically needed because of unshare(CLONE_NEWNS) in open_netns())
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 BTF_KIND_INT 
 should re-use previously added "int" string 
 invalid int size 
 invalid encoding 
 NULL name 
 empty name 
 PTRCONSTVOLATILERESTRICT 
 points forward to restrict 
 ARRAY 
 int [10] 
 STRUCT 
 UNION 
 invalid, non-zero offset 
 ENUM 
 FWDs 
 TYPEDEF 
 FUNC & FUNC_PROTO 
 VAR 
 DATASECT 
 DECL_TAG 
 types appended from the second BTF 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 we don't care about the rest 
 trigger exactly two samples 
 good readwrite cons_pos 
 bad writeable prod_pos 
 bad writeable data pages 
 good read-only pages 
 good read-only pages with initial offset 
 only trigger BPF program for current process 
 2 submitted + 1 discarded records 
 poll for samples 
 -EDONE is used as an indicator that we are done 
 we expect extra polling to return nothing 
 now validate consumer position is updated and returned 
 start poll in background w long timeout 
 turn off notifications now 
 give background thread a bit of a time 
	 sleeping arbitrarily is bad, but no better way to know that
	  epoll_wait() DID NOT unblock in background thread
 background poll should still be blocked 
 BPF side did everything right 
 clear flags to return to "adaptive" notification mode 
	 produce new samples, no notification should be triggered, because
	  consumer is now behind
 background poll should still be blocked 
 still no samples, because consumer is behind 
 now force notifications 
 now we should get a pending notification 
	 due to timing variations, there could still be non-notified
	  samples, so consume them here to collect all the samples
 3 rounds, 2 samples each 
 BPF side did everything right 
 SPDX-License-Identifier: GPL-2.0
 TCP_CA_NAME_MAX 
 IP_TOS - BPF bypass 
 IP_TTL - EPERM 
 SOL_CUSTOM - handled by BPF 
 IP_FREEBIND - BPF can't access optval past PAGE_SIZE 
 SO_SNDBUF is overwritten 
 TCP_CONGESTION can extend the string 
 TCP_ZEROCOPY_RECEIVE triggers 
 rejected by BPF 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 Check that already linked program can't be attached again. 
 zero results for re-attach test 
 SPDX-License-Identifier: GPL-2.0
 r6 is our tp buffer 
 one byte beyond the end of the nbd_request struct 
 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
 Copyright (c) 2020 Cloudflare
  Test BPF attach point for INET socket lookup (BPF_SK_LOOKUP).
  Tests exercise:
   - attachingdetachingquerying programs to BPF_SK_LOOKUP hook,
   - redirecting socket lookup to a socket selected by BPF program,
   - failing a socket lookup on BPF program's request,
   - error scenarios for selecting a socket from BPF program,
   - accessing BPF program context,
   - attaching and running multiple BPF programs.
  Tests run in a dedicated network namespace.
 External (address, port) pairs the client sends packets to. 
 Internal (address, port) pairs the server listensreceives at. 
 Add a connected socket to reuseport group 
 for CHECK macro 
 Enabled for UDPv6 sockets for IPv4-mapped IPv6 to work. 
 Late attach reuseport prog so we can have one init path 
 Server socket bound to IPv4-mapped IPv6 address 
 Reply from original destination address. 
 query flags ,
 prog id is still there, but netns_ino is zeroed out 
 want just one server for non-reuseport test 
	 Regular UDP socket lookup with reuseport behaves
	  differently when reuseport group contains connected
	  sockets. Check that adding a connected UDP socket to the
	  reuseport group does not affect how reuseport works with
	  BPF socket lookup.
 Add an extra socket to reuseport group 
 Connect the extra socket to itself 
 Read out asynchronous error 
 second server on destination address we should never reach 
 reuseport prog );
 Read out asynchronous error 
 Put a connected socket in redirect map 
 Try to redirect TCP SYN  UDP packet to a connected socket 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  Tests for libbpf's hashmap.
  Copyright (c) 2019 Facebook
 force collisions 
	 set up multimap:
	  [0] -> 1, 2, 4;
	  [1] -> 8, 16, 32;
 verify global iteration still works and sees all values 
 iterate values for key 1 
 iterate values for key 2 
 force collisions 
 SPDX-License-Identifier: GPL-2.0
	 BPF program enforces a single UDP socket per cgroup,
	  verify that.
 We can reopen again after close. 
	 Make sure the program was invoked the expected
	  number of times:
	  - open fd1           - BPF_CGROUP_INET_SOCK_CREATE
	  - attempt to openfd2 - BPF_CGROUP_INET_SOCK_CREATE
	  - close fd1          - BPF_CGROUP_INET_SOCK_RELEASE
	  - open fd1 again     - BPF_CGROUP_INET_SOCK_CREATE
 We should still have a single socket in use 
 SPDX-License-Identifier: GPL-2.0
 can not attach BPF_XDP_DEVMAP program to a device 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 trigger 
 output_weak2 should never be updated 
 SPDX-License-Identifier: GPL-2.0
	 tests with t->known_ptr_sz have no "long" or "unsigned long" type,
	  so it's impossible to determine correct pointer size; but if they
	  do, it should be 8 regardless of host architecture, becaues BPF
	  target is always 64-bit
		
		  When the test is run with O=, kselftest copies TEST_FILES
		  without preserving the directory structure.
	
	  Diff test output and expected test output, contained between
	  START-EXPECTED-OUTPUT and END-EXPECTED-OUTPUT lines in test case.
	  For expected output lines, everything before '' is stripped out.
	  Also lines containing comment start and comment end markers are
	  ignored. 
{next} "  ignore comment startend lines 
		 "out {sub(^[ \\t]\\, \"\"); print}' '%s' | diff -u - '%s'",
		 test_file, out_file);
	err = system(diff_cmd);
	if (CHECK(err, "diff",
		  "differing test output, output=%s, err=%d, diff cmd:\n%s\n",
		  out_file, err, diff_cmd))
		goto done;
	remove(out_file);
done:
	btf__free(btf);
	return err;
}
static char dump_buf;
static size_t dump_buf_sz;
static FILE dump_buf_file;
static void test_btf_dump_incremental(void)
{
	struct btf btf = NULL;
	struct btf_dump d = NULL;
	struct btf_dump_opts opts;
	int id, err, i;
	dump_buf_file = open_memstream(&dump_buf, &dump_buf_sz);
	if (!ASSERT_OK_PTR(dump_buf_file, "dump_memstream"))
		return;
	btf = btf__new_empty();
	if (!ASSERT_OK_PTR(btf, "new_empty"))
		goto err_out;
	opts.ctx = dump_buf_file;
	d = btf_dump__new(btf, NULL, &opts, btf_dump_printf);
	if (!ASSERT_OK(libbpf_get_error(d), "btf_dump__new"))
		goto err_out;
 First, generate BTF corresponding to the following C code:
	 
	id = btf__add_enum(btf, NULL, 4);
	ASSERT_EQ(id, 1, "enum_id");
	err = btf__add_enum_value(btf, "VAL", 1);
	ASSERT_OK(err, "enum_val_ok");
	id = btf__add_int(btf, "int", 4, BTF_INT_SIGNED);
	ASSERT_EQ(id, 2, "int_id");
	id = btf__add_struct(btf, "s", 4);
	ASSERT_EQ(id, 3, "struct_id");
	err = btf__add_field(btf, "x", 2, 0, 0);
	ASSERT_OK(err, "field_ok");
	for (i = 1; i < btf__type_cnt(btf); i++) {
		err = btf_dump__dump_type(d, i);
		ASSERT_OK(err, "dump_type_ok");
	}
	fflush(dump_buf_file);
	dump_buf[dump_buf_sz] = 0;  some libc implementations don't do this 
	ASSERT_STREQ(dump_buf,
"enum {\n"
"	VAL = 1,\n"
"};\n"
"\n"
"struct s {\n"
"	int x;\n"
"};\n\n", "c_dump1");
 Now, after dumping original BTF, append another struct that embeds
	 
	fseek(dump_buf_file, 0, SEEK_SET);
	id = btf__add_struct(btf, "s", 4);
	ASSERT_EQ(id, 4, "struct_id");
	err = btf__add_field(btf, "x", 1, 0, 0);
	ASSERT_OK(err, "field_ok");
	err = btf__add_field(btf, "s", 3, 32, 0);
	ASSERT_OK(err, "field_ok");
	for (i = 1; i < btf__type_cnt(btf); i++) {
		err = btf_dump__dump_type(d, i);
		ASSERT_OK(err, "dump_type_ok");
	}
	fflush(dump_buf_file);
	dump_buf[dump_buf_sz] = 0;  some libc implementations don't do this 
	ASSERT_STREQ(dump_buf,
"struct s___2 {\n"
"	enum {\n"
"		VAL___2 = 1,\n"
"	} x;\n"
"	struct s s;\n"
"};\n\n" , "c_dump1");
err_out:
	fclose(dump_buf_file);
	free(dump_buf);
	btf_dump__free(d);
	btf__free(btf);
}
#define STRSIZE				4096
static void btf_dump_snprintf(void ctx, const char fmt, va_list args)
{
	char s = ctx, new[STRSIZE];
	vsnprintf(new, STRSIZE, fmt, args);
	if (strlen(s) < STRSIZE)
		strncat(s, new, STRSIZE - strlen(s) - 1);
}
static int btf_dump_data(struct btf btf, struct btf_dump d,
			 char name, char prefix, __u64 flags, void ptr,
			 size_t ptr_sz, char str, const char expected_val)
{
	DECLARE_LIBBPF_OPTS(btf_dump_type_data_opts, opts);
	size_t type_sz;
	__s32 type_id;
	int ret = 0;
	if (flags & BTF_F_COMPACT)
		opts.compact = true;
	if (flags & BTF_F_NONAME)
		opts.skip_names = true;
	if (flags & BTF_F_ZERO)
		opts.emit_zeroes = true;
	if (prefix) {
		ASSERT_STRNEQ(name, prefix, strlen(prefix),
			      "verify prefix match");
		name += strlen(prefix) + 1;
	}
	type_id = btf__find_by_name(btf, name);
	if (!ASSERT_GE(type_id, 0, "find type id"))
		return -ENOENT;
	type_sz = btf__resolve_size(btf, type_id);
	str[0] = '\0';
	ret = btf_dump__dump_type_data(d, type_id, ptr, ptr_sz, &opts);
	if (type_sz <= ptr_sz) {
		if (!ASSERT_EQ(ret, type_sz, "failedunexpected type_sz"))
			return -EINVAL;
	} else {
		if (!ASSERT_EQ(ret, -E2BIG, "failed to return -E2BIG"))
			return -EINVAL;
	}
	if (!ASSERT_STREQ(str, expected_val, "ensure expectedactual match"))
		return -EFAULT;
	return 0;
}
#define TEST_BTF_DUMP_DATA(_b, _d, _prefix, _str, _type, _flags,	\
			   _expected, ...)				\
	do {								\
		char __ptrtype[64] = #_type;				\
		char _ptrtype = (char )__ptrtype;			\
		_type _ptrdata = __VA_ARGS__;				\
		void _ptr = &_ptrdata;					\
									\
		(void) btf_dump_data(_b, _d, _ptrtype, _prefix, _flags,	\
				     _ptr, sizeof(_type), _str,		\
				     _expected);			\
	} while (0)
 Use where expected data string matches its stringified declaration 
#define TEST_BTF_DUMP_DATA_C(_b, _d, _prefix,  _str, _type, _flags,	\
			     ...)					\
	TEST_BTF_DUMP_DATA(_b, _d, _prefix, _str, _type, _flags,	\
			   "(" #_type ")" #__VA_ARGS__,	__VA_ARGS__)
 overflow test; pass typesize < expected type size, ensure E2BIG returned 
#define TEST_BTF_DUMP_DATA_OVER(_b, _d, _prefix, _str, _type, _type_sz,	\
				_expected, ...)				\
	do {								\
		char __ptrtype[64] = #_type;				\
		char _ptrtype = (char )__ptrtype;			\
		_type _ptrdata = __VA_ARGS__;				\
		void _ptr = &_ptrdata;					\
									\
		(void) btf_dump_data(_b, _d, _ptrtype, _prefix, 0,	\
				     _ptr, _type_sz, _str, _expected);	\
	} while (0)
#define TEST_BTF_DUMP_VAR(_b, _d, _prefix, _str, _var, _type, _flags,	\
			  _expected, ...)				\
	do {								\
		_type _ptrdata = __VA_ARGS__;				\
		void _ptr = &_ptrdata;					\
									\
		(void) btf_dump_data(_b, _d, _var, _prefix, _flags,	\
				     _ptr, sizeof(_type), _str,		\
				     _expected);			\
	} while (0)
static void test_btf_dump_int_data(struct btf btf, struct btf_dump d,
				   char str)
{
#ifdef __SIZEOF_INT128__
	__int128 i = 0xffffffffffffffff;
 this dance is required because we cannot directly initialize
	 
	i = (i << 64) | (i - 1);
#endif
	 simple int 
	TEST_BTF_DUMP_DATA_C(btf, d, NULL, str, int, BTF_F_COMPACT, 1234);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int, BTF_F_COMPACT | BTF_F_NONAME,
			   "1234", 1234);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int, 0, "(int)1234", 1234);
	 zero value should be printed at toplevel 
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int, BTF_F_COMPACT, "(int)0", 0);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int, BTF_F_COMPACT | BTF_F_NONAME,
			   "0", 0);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int, BTF_F_COMPACT | BTF_F_ZERO,
			   "(int)0", 0);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int,
			   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,
			   "0", 0);
	TEST_BTF_DUMP_DATA_C(btf, d, NULL, str, int, BTF_F_COMPACT, -4567);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int, BTF_F_COMPACT | BTF_F_NONAME,
			   "-4567", -4567);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, int, 0, "(int)-4567", -4567);
	TEST_BTF_DUMP_DATA_OVER(btf, d, NULL, str, int, sizeof(int)-1, "", 1);
#ifdef __SIZEOF_INT128__
 gcc encode unsigned __int128 type with name "__int128 unsigned" in dwarf,
	 
	if (btf__find_by_name(btf, "unsigned __int128") > 0) {
		TEST_BTF_DUMP_DATA(btf, d, NULL, str, unsigned __int128, BTF_F_COMPACT,
				   "(unsigned __int128)0xffffffffffffffff",
				   0xffffffffffffffff);
		ASSERT_OK(btf_dump_data(btf, d, "unsigned __int128", NULL, 0, &i, 16, str,
					"(unsigned __int128)0xfffffffffffffffffffffffffffffffe"),
			  "dump unsigned __int128");
	} else if (btf__find_by_name(btf, "__int128 unsigned") > 0) {
		TEST_BTF_DUMP_DATA(btf, d, NULL, str, __int128 unsigned, BTF_F_COMPACT,
				   "(__int128 unsigned)0xffffffffffffffff",
				   0xffffffffffffffff);
		ASSERT_OK(btf_dump_data(btf, d, "__int128 unsigned", NULL, 0, &i, 16, str,
					"(__int128 unsigned)0xfffffffffffffffffffffffffffffffe"),
			  "dump unsigned __int128");
	} else {
		ASSERT_TRUE(false, "unsigned_int128_not_found");
	}
#endif
}
static void test_btf_dump_float_data(struct btf btf, struct btf_dump d,
				     char str)
{
	float t1 = 1.234567;
	float t2 = -1.234567;
	float t3 = 0.0;
	double t4 = 5.678912;
	double t5 = -5.678912;
	double t6 = 0.0;
	long double t7 = 9.876543;
	long double t8 = -9.876543;
	long double t9 = 0.0;
 since the kernel does not likely have any float types in its BTF, we
	 
	ASSERT_GT(btf__add_float(btf, "test_float", 4), 0, "add float");
	ASSERT_OK(btf_dump_data(btf, d, "test_float", NULL, 0, &t1, 4, str,
				"(test_float)1.234567"), "dump float");
	ASSERT_OK(btf_dump_data(btf, d, "test_float", NULL, 0, &t2, 4, str,
				"(test_float)-1.234567"), "dump float");
	ASSERT_OK(btf_dump_data(btf, d, "test_float", NULL, 0, &t3, 4, str,
				"(test_float)0.000000"), "dump float");
	ASSERT_GT(btf__add_float(btf, "test_double", 8), 0, "add_double");
	ASSERT_OK(btf_dump_data(btf, d, "test_double", NULL, 0, &t4, 8, str,
		  "(test_double)5.678912"), "dump double");
	ASSERT_OK(btf_dump_data(btf, d, "test_double", NULL, 0, &t5, 8, str,
		  "(test_double)-5.678912"), "dump double");
	ASSERT_OK(btf_dump_data(btf, d, "test_double", NULL, 0, &t6, 8, str,
				"(test_double)0.000000"), "dump double");
	ASSERT_GT(btf__add_float(btf, "test_long_double", 16), 0, "add long double");
	ASSERT_OK(btf_dump_data(btf, d, "test_long_double", NULL, 0, &t7, 16,
				str, "(test_long_double)9.876543"),
				"dump long_double");
	ASSERT_OK(btf_dump_data(btf, d, "test_long_double", NULL, 0, &t8, 16,
				str, "(test_long_double)-9.876543"),
				"dump long_double");
	ASSERT_OK(btf_dump_data(btf, d, "test_long_double", NULL, 0, &t9, 16,
				str, "(test_long_double)0.000000"),
				"dump long_double");
}
static void test_btf_dump_char_data(struct btf btf, struct btf_dump d,
				    char str)
{
	 simple char 
	TEST_BTF_DUMP_DATA_C(btf, d, NULL, str, char, BTF_F_COMPACT, 100);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, char, BTF_F_COMPACT | BTF_F_NONAME,
			   "100", 100);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, char, 0, "(char)100", 100);
	 zero value should be printed at toplevel 
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, char, BTF_F_COMPACT,
			   "(char)0", 0);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, char, BTF_F_COMPACT | BTF_F_NONAME,
			   "0", 0);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, char, BTF_F_COMPACT | BTF_F_ZERO,
			   "(char)0", 0);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, char, BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,
			   "0", 0);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, char, 0, "(char)0", 0);
	TEST_BTF_DUMP_DATA_OVER(btf, d, NULL, str, char, sizeof(char)-1, "", 100);
}
static void test_btf_dump_typedef_data(struct btf btf, struct btf_dump d,
				       char str)
{
	 simple typedef 
	TEST_BTF_DUMP_DATA_C(btf, d, NULL, str, uint64_t, BTF_F_COMPACT, 100);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, BTF_F_COMPACT | BTF_F_NONAME,
			   "1", 1);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, 0, "(u64)1", 1);
	 zero value should be printed at toplevel 
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, BTF_F_COMPACT, "(u64)0", 0);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, BTF_F_COMPACT | BTF_F_NONAME,
			   "0", 0);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, BTF_F_COMPACT | BTF_F_ZERO,
			   "(u64)0", 0);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, u64,
			   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,
			   "0", 0);
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, u64, 0, "(u64)0", 0);
	 typedef struct 
	TEST_BTF_DUMP_DATA_C(btf, d, NULL, str, atomic_t, BTF_F_COMPACT,
			     {.counter = (int)1,});
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, BTF_F_COMPACT | BTF_F_NONAME,
			   "{1,}", { .counter = 1 });
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, 0,
"(atomic_t){\n"
"	.counter = (int)1,\n"
"}",
			   {.counter = 1,});
	 typedef with 0 value should be printed at toplevel 
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, BTF_F_COMPACT, "(atomic_t){}",
			   {.counter = 0,});
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, BTF_F_COMPACT | BTF_F_NONAME,
			   "{}", {.counter = 0,});
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, 0,
"(atomic_t){\n"
"}",
			   {.counter = 0,});
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, BTF_F_COMPACT | BTF_F_ZERO,
			   "(atomic_t){.counter = (int)0,}",
			   {.counter = 0,});
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t,
			   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,
			   "{0,}", {.counter = 0,});
	TEST_BTF_DUMP_DATA(btf, d, NULL, str, atomic_t, BTF_F_ZERO,
"(atomic_t){\n"
"	.counter = (int)0,\n"
"}",
			   { .counter = 0,});
	 overflow should show type but not value since it overflows 
	TEST_BTF_DUMP_DATA_OVER(btf, d, NULL, str, atomic_t, sizeof(atomic_t)-1,
				"(atomic_t){\n", { .counter = 1});
}
static void test_btf_dump_enum_data(struct btf btf, struct btf_dump d,
				    char str)
{
	 enum where enum value does (and does not) exist 
	TEST_BTF_DUMP_DATA_C(btf, d, "enum", str, enum bpf_cmd, BTF_F_COMPACT,
			     BPF_MAP_CREATE);
	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd, BTF_F_COMPACT,
			   "(enum bpf_cmd)BPF_MAP_CREATE", 0);
	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd,
			   BTF_F_COMPACT | BTF_F_NONAME,
			   "BPF_MAP_CREATE",
			   BPF_MAP_CREATE);
	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd, 0,
			   "(enum bpf_cmd)BPF_MAP_CREATE",
			   BPF_MAP_CREATE);
	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd,
			   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,
			   "BPF_MAP_CREATE", 0);
	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd,
			   BTF_F_COMPACT | BTF_F_ZERO,
			   "(enum bpf_cmd)BPF_MAP_CREATE",
			   BPF_MAP_CREATE);
	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd,
			   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,
			   "BPF_MAP_CREATE", BPF_MAP_CREATE);
	TEST_BTF_DUMP_DATA_C(btf, d, "enum", str, enum bpf_cmd, BTF_F_COMPACT, 2000);
	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd,
			   BTF_F_COMPACT | BTF_F_NONAME,
			   "2000", 2000);
	TEST_BTF_DUMP_DATA(btf, d, "enum", str, enum bpf_cmd, 0,
			   "(enum bpf_cmd)2000", 2000);
	TEST_BTF_DUMP_DATA_OVER(btf, d, "enum", str, enum bpf_cmd,
				sizeof(enum bpf_cmd) - 1, "", BPF_MAP_CREATE);
}
static void test_btf_dump_struct_data(struct btf btf, struct btf_dump d,
				      char str)
{
	DECLARE_LIBBPF_OPTS(btf_dump_type_data_opts, opts);
	char zero_data[512] = { };
	char type_data[512];
	void fops = type_data;
	void skb = type_data;
	size_t type_sz;
	__s32 type_id;
	char cmpstr;
	int ret;
	memset(type_data, 255, sizeof(type_data));
	 simple struct 
	TEST_BTF_DUMP_DATA_C(btf, d, "struct", str, struct btf_enum, BTF_F_COMPACT,
			     {.name_off = (__u32)3,.val = (__s32)-1,});
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum,
			   BTF_F_COMPACT | BTF_F_NONAME,
			   "{3,-1,}",
			   { .name_off = 3, .val = -1,});
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum, 0,
"(struct btf_enum){\n"
"	.name_off = (__u32)3,\n"
"	.val = (__s32)-1,\n"
"}",
			   { .name_off = 3, .val = -1,});
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum,
			   BTF_F_COMPACT | BTF_F_NONAME,
			   "{-1,}",
			   { .name_off = 0, .val = -1,});
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum,
			   BTF_F_COMPACT | BTF_F_NONAME | BTF_F_ZERO,
			   "{0,-1,}",
			   { .name_off = 0, .val = -1,});
	 empty struct should be printed 
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum, BTF_F_COMPACT,
			   "(struct btf_enum){}",
			   { .name_off = 0, .val = 0,});
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum,
			   BTF_F_COMPACT | BTF_F_NONAME,
			   "{}",
			   { .name_off = 0, .val = 0,});
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum, 0,
"(struct btf_enum){\n"
"}",
			   { .name_off = 0, .val = 0,});
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum,
			   BTF_F_COMPACT | BTF_F_ZERO,
			   "(struct btf_enum){.name_off = (__u32)0,.val = (__s32)0,}",
			   { .name_off = 0, .val = 0,});
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct btf_enum,
			   BTF_F_ZERO,
"(struct btf_enum){\n"
"	.name_off = (__u32)0,\n"
"	.val = (__s32)0,\n"
"}",
			   { .name_off = 0, .val = 0,});
	 struct with pointers 
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct list_head, BTF_F_COMPACT,
			   "(struct list_head){.next = (struct list_head )0x1,}",
			   { .next = (struct list_head )1 });
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct list_head, 0,
"(struct list_head){\n"
"	.next = (struct list_head )0x1,\n"
"}",
			   { .next = (struct list_head )1 });
	 NULL pointer should not be displayed 
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct list_head, BTF_F_COMPACT,
			   "(struct list_head){}",
			   { .next = (struct list_head )0 });
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct list_head, 0,
"(struct list_head){\n"
"}",
			   { .next = (struct list_head )0 });
	 struct with function pointers 
	type_id = btf__find_by_name(btf, "file_operations");
	if (ASSERT_GT(type_id, 0, "find type id")) {
		type_sz = btf__resolve_size(btf, type_id);
		str[0] = '\0';
		ret = btf_dump__dump_type_data(d, type_id, fops, type_sz, &opts);
		ASSERT_EQ(ret, type_sz,
			  "unexpected return value dumping file_operations");
		cmpstr =
"(struct file_operations){\n"
"	.owner = (struct module )0xffffffffffffffff,\n"
"	.llseek = (loff_t ()(struct file , loff_t, int))0xffffffffffffffff,";
		ASSERT_STRNEQ(str, cmpstr, strlen(cmpstr), "file_operations");
	}
	 struct with char array 
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_prog_info, BTF_F_COMPACT,
			   "(struct bpf_prog_info){.name = (char[16])['f','o','o',],}",
			   { .name = "foo",});
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_prog_info,
			   BTF_F_COMPACT | BTF_F_NONAME,
			   "{['f','o','o',],}",
			   {.name = "foo",});
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_prog_info, 0,
"(struct bpf_prog_info){\n"
"	.name = (char[16])[\n"
"		'f',\n"
"		'o',\n"
"		'o',\n"
"	],\n"
"}",
			   {.name = "foo",});
	 leading null char means do not display string 
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_prog_info, BTF_F_COMPACT,
			   "(struct bpf_prog_info){}",
			   {.name = {'\0', 'f', 'o', 'o'}});
	 handle non-printable characters 
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_prog_info, BTF_F_COMPACT,
			   "(struct bpf_prog_info){.name = (char[16])[1,2,3,],}",
			   { .name = {1, 2, 3, 0}});
	 struct with non-char array 
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct __sk_buff, BTF_F_COMPACT,
			   "(struct __sk_buff){.cb = (__u32[5])[1,2,3,4,5,],}",
			   { .cb = {1, 2, 3, 4, 5,},});
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct __sk_buff,
			   BTF_F_COMPACT | BTF_F_NONAME,
			   "{[1,2,3,4,5,],}",
			   { .cb = { 1, 2, 3, 4, 5},});
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct __sk_buff, 0,
"(struct __sk_buff){\n"
"	.cb = (__u32[5])[\n"
"		1,\n"
"		2,\n"
"		3,\n"
"		4,\n"
"		5,\n"
"	],\n"
"}",
			   { .cb = { 1, 2, 3, 4, 5},});
	 For non-char, arrays, show non-zero values only 
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct __sk_buff, BTF_F_COMPACT,
			   "(struct __sk_buff){.cb = (__u32[5])[0,0,1,0,0,],}",
			   { .cb = { 0, 0, 1, 0, 0},});
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct __sk_buff, 0,
"(struct __sk_buff){\n"
"	.cb = (__u32[5])[\n"
"		0,\n"
"		0,\n"
"		1,\n"
"		0,\n"
"		0,\n"
"	],\n"
"}",
			   { .cb = { 0, 0, 1, 0, 0},});
	 struct with bitfields 
	TEST_BTF_DUMP_DATA_C(btf, d, "struct", str, struct bpf_insn, BTF_F_COMPACT,
		{.code = (__u8)1,.dst_reg = (__u8)0x2,.src_reg = (__u8)0x3,.off = (__s16)4,.imm = (__s32)5,});
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_insn,
			   BTF_F_COMPACT | BTF_F_NONAME,
			   "{1,0x2,0x3,4,5,}",
			   { .code = 1, .dst_reg = 0x2, .src_reg = 0x3, .off = 4,
			     .imm = 5,});
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_insn, 0,
"(struct bpf_insn){\n"
"	.code = (__u8)1,\n"
"	.dst_reg = (__u8)0x2,\n"
"	.src_reg = (__u8)0x3,\n"
"	.off = (__s16)4,\n"
"	.imm = (__s32)5,\n"
"}",
			   {.code = 1, .dst_reg = 2, .src_reg = 3, .off = 4, .imm = 5});
	 zeroed bitfields should not be displayed 
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_insn, BTF_F_COMPACT,
			   "(struct bpf_insn){.dst_reg = (__u8)0x1,}",
			   { .code = 0, .dst_reg = 1});
	 struct with enum bitfield 
	type_id = btf__find_by_name(btf, "fs_context");
	if (ASSERT_GT(type_id,  0, "find fs_context")) {
		type_sz = btf__resolve_size(btf, type_id);
		str[0] = '\0';
		opts.emit_zeroes = true;
		ret = btf_dump__dump_type_data(d, type_id, zero_data, type_sz, &opts);
		ASSERT_EQ(ret, type_sz,
			  "unexpected return value dumping fs_context");
		ASSERT_NEQ(strstr(str, "FS_CONTEXT_FOR_MOUNT"), NULL,
				  "bitfield value not present");
	}
	 struct with nested anon union 
	TEST_BTF_DUMP_DATA(btf, d, "struct", str, struct bpf_sock_ops, BTF_F_COMPACT,
			   "(struct bpf_sock_ops){.op = (__u32)1,(union){.args = (__u32[4])[1,2,3,4,],.reply = (__u32)1,.replylong = (__u32[4])[1,2,3,4,],},}",
			   { .op = 1, .args = { 1, 2, 3, 4}});
	 union with nested struct 
	TEST_BTF_DUMP_DATA(btf, d, "union", str, union bpf_iter_link_info, BTF_F_COMPACT,
			   "(union bpf_iter_link_info){.map = (struct){.map_fd = (__u32)1,},}",
			   { .map = { .map_fd = 1 }});
 struct skb with nested structsunions; because type output is so
	 
	type_id = btf__find_by_name(btf, "sk_buff");
	if (ASSERT_GT(type_id, 0, "find struct sk_buff")) {
		type_sz = btf__resolve_size(btf, type_id);
		str[0] = '\0';
		ret = btf_dump__dump_type_data(d, type_id, skb, type_sz, &opts);
		ASSERT_EQ(ret, type_sz,
			  "unexpected return value dumping sk_buff");
	}
 overflow bpf_sock_ops struct with final element nonzerozero.
	 
	TEST_BTF_DUMP_DATA_OVER(btf, d, "struct", str, struct bpf_sock_ops,
				sizeof(struct bpf_sock_ops) - 1,
				"(struct bpf_sock_ops){\n\t.op = (__u32)1,\n",
				{ .op = 1, .skb_tcp_flags = 2});
	TEST_BTF_DUMP_DATA_OVER(btf, d, "struct", str, struct bpf_sock_ops,
				sizeof(struct bpf_sock_ops) - 1,
				"(struct bpf_sock_ops){\n\t.op = (__u32)1,\n",
				{ .op = 1, .skb_tcp_flags = 0});
}
static void test_btf_dump_var_data(struct btf btf, struct btf_dump d,
				   char str)
{
#if defined(__i386__) || defined(__x86_64__) || defined(__aarch64__)
	TEST_BTF_DUMP_VAR(btf, d, NULL, str, "cpu_number", int, BTF_F_COMPACT,
			  "int cpu_number = (int)100", 100);
#endif
	TEST_BTF_DUMP_VAR(btf, d, NULL, str, "cpu_profile_flip", int, BTF_F_COMPACT,
			  "static int cpu_profile_flip = (int)2", 2);
}
static void test_btf_datasec(struct btf btf, struct btf_dump d, char str,
			     const char name, const char expected_val,
			     void data, size_t data_sz)
{
	DECLARE_LIBBPF_OPTS(btf_dump_type_data_opts, opts);
	int ret = 0, cmp;
	size_t secsize;
	__s32 type_id;
	opts.compact = true;
	type_id = btf__find_by_name(btf, name);
	if (!ASSERT_GT(type_id, 0, "find type id"))
		return;
	secsize = btf__resolve_size(btf, type_id);
	ASSERT_EQ(secsize,  0, "verify section size");
	str[0] = '\0';
	ret = btf_dump__dump_type_data(d, type_id, data, data_sz, &opts);
	ASSERT_EQ(ret, 0, "unexpected return value");
	cmp = strcmp(str, expected_val);
	ASSERT_EQ(cmp, 0, "ensure expectedactual match");
}
static void test_btf_dump_datasec_data(char str)
{
	struct btf btf = btf__parse("xdping_kern.o", NULL);
	struct btf_dump_opts opts = { .ctx = str };
	char license[4] = "GPL";
	struct btf_dump d;
	if (!ASSERT_OK_PTR(btf, "xdping_kern.o BTF not found"))
		return;
	d = btf_dump__new(btf, NULL, &opts, btf_dump_snprintf);
	if (!ASSERT_OK_PTR(d, "could not create BTF dump"))
		return;
	test_btf_datasec(btf, d, str, "license",
			 "SEC(\"license\") char[4] _license = (char[4])['G','P','L',];",
			 license, sizeof(license));
}
void test_btf_dump() {
	char str[STRSIZE];
	struct btf_dump_opts opts = { .ctx = str };
	struct btf_dump d;
	struct btf btf;
	int i;
	for (i = 0; i < ARRAY_SIZE(btf_dump_test_cases); i++) {
		struct btf_dump_test_case t = &btf_dump_test_cases[i];
		if (!test__start_subtest(t->name))
			continue;
		test_btf_dump_case(i, &btf_dump_test_cases[i]);
	}
	if (test__start_subtest("btf_dump: incremental"))
		test_btf_dump_incremental();
	btf = libbpf_find_kernel_btf();
	if (!ASSERT_OK_PTR(btf, "no kernel BTF found"))
		return;
	d = btf_dump__new(btf, NULL, &opts, btf_dump_snprintf);
	if (!ASSERT_OK_PTR(d, "could not create BTF dump"))
		return;
	 Verify type display for various types. 
	if (test__start_subtest("btf_dump: int_data"))
		test_btf_dump_int_data(btf, d, str);
	if (test__start_subtest("btf_dump: float_data"))
		test_btf_dump_float_data(btf, d, str);
	if (test__start_subtest("btf_dump: char_data"))
		test_btf_dump_char_data(btf, d, str);
	if (test__start_subtest("btf_dump: typedef_data"))
		test_btf_dump_typedef_data(btf, d, str);
	if (test__start_subtest("btf_dump: enum_data"))
		test_btf_dump_enum_data(btf, d, str);
	if (test__start_subtest("btf_dump: struct_data"))
		test_btf_dump_struct_data(btf, d, str);
	if (test__start_subtest("btf_dump: var_data"))
		test_btf_dump_var_data(btf, d, str);
	btf_dump__free(d);
	btf__free(btf);
	if (test__start_subtest("btf_dump: datasec_data"))
		test_btf_dump_datasec_data(str);
}
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Google LLC. 
 The third specifier, %pB, depends on compiler inlining so don't check it 
 The third specifier, %p, is a hashed pointer which changes on every reboot 
 trigger tracepoint 
 Loads an eBPF object calling bpf_snprintf with up to 10 characters of fmt 
 SPDX-License-Identifier: GPL-2.0
 fallback to 5000 on error 
 override program type 
 pid ,
 cpu 0 , -1 
 flags );
 find map fds 
 disable stack trace collection 
	 for every element in stackid_hmap, we can find a corresponding one
	  in stackmap, and vise versa.
	 stack_map_get_build_id_offset() is racy and sometimes can return
	  BPF_STACK_BUILD_ID_IP instead of BPF_STACK_BUILD_ID_VALID;
	  try it one more time.
	
	  We intentionally skip compare_stack_ips(). This is because we
	  only support one in_nmi() ips-to-build_id translation per cpu
	  at any time, thus stack_amap here will always fallback to
	  BPF_STACK_BUILD_ID_IP;
 SPDX-License-Identifier: GPL-2.0
 at least 4 pages of data 
 now double-check if it's mmap()'able at all 
 get map's ID 
 mmap BSS map 
 map as RW first 
 data_map freeze should fail due to RW mmap() 
 unmap RW mapping 
 re-map as RO now 
 mapunmap in a loop to test ref counting 
 data_map freeze should now succeed due to no RW mapping 
 mapping as RW now should fail 
 check some more advanced mmap() manipulations 
 map all but last page: pages 1-3 mapped 
 unmap second page: pages 1, 3 mapped 
 map page 2 back 
 re-map all 4 pages 
 unmap page 1 
 map all 4 pages, but with pg_off=1 page, should fail 
 initial page shift );
 map should be still held by active mmap 
 this should release data map finally 
 we need to wait for RCU grace period 
 should fail to get map FD by non-existing ID 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 trigger 
 10 comes from "winner" input_data_weak in first obj file 
 100 comes from "winner" input_rodata_weak in first obj file 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 set initial prog attachment 
 validate prog ID 
 BPF link is not allowed to replace prog attachment 
 best-effort detach prog 
 detach BPF program 
 now BPF link should attach successfully 
 validate prog ID 
 BPF prog attach is not allowed to replace BPF link 
 Can't force-update when BPF link is active 
 Can't force-detach when BPF link is active 
 BPF link is not allowed to replace another BPF link 
 new link attach should succeed 
 updating program under active BPF link works as expected 
 ifindex should be zeroed out 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Google 
 trigger tracepoint 
 trigger tracepoint 
 trigger tracepoint 
 SPDX-License-Identifier: GPL-2.0
 Expect verifier failure if test name has 'err' 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0
 unmountable pseudo-filesystems 
 unmountable pseudo-filesystems 
 mountable pseudo-filesystems 
 bpf_d_path will return path with (deleted) 
 triggers vfs_getattr 
 triggers filp_close 
 The d_path helper returns size plus NUL char, hence + 1 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 100ms 
 500ms 
 SPDX-License-Identifier: GPL-2.0
 find in kernel module BTFs 		\
 always 8-byte pointer for BPF 	\
 we are interested only in anonymous types 
 ptr -> func_proto -> _Bool 
 ptr -> void 
 _Bool[] 
 validate we can find kernel image and use its BTF for relocs 
 load from libmodules$(uname -r) 
 validate we can find kernel module BTF types for relocsattach 
	 validate BPF program can use multiple flavors to match against
	  single target BTF type
 various structenum nesting and resolution scenarios 
 various array access relocation scenarios 
 enumptrint handling scenarios 
 constvolatilerestrict and typedefs scenarios 
 handling "ptr is an array" semantics 
 int signednesssizingbitfield handling 
 validate edge cases of capturing relocations 
 not read 
 BUG in clang, should be 3 
 validate field existence checks 
 bitfield relocation checks 
 size relocation checks 
 validate type existence and size relocations 
 all zeros 
 BTF_TYPE_ID_LOCALBTF_TYPE_ID_TARGET tests 
 Enumerator value existence and value relocations 
 NULL for tp_btf 
 trigger test run 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 TRISTATE 
 BOOL 
 CHAR 
 STRING 
 INTEGERS 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2021. Huawei Technologies Co., Ltd 
 Need to keep consistent with definition in includelinuxbpf.h 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 1024 should be enough to get contiguous 4 "iter" letters at some point 
 Check that RENAME_EXCHANGE works for directories. 
 Check that RENAME_EXCHANGE works for mixed file types. 
 Check that RENAME_NOREPLACE works. 
 SPDX-License-Identifier: GPL-2.0
 find map fds 
 disable stack trace collection 
	 for every element in stackid_hmap, we can find a corresponding one
	  in stackmap, and vise versa.
	 stack_map_get_build_id_offset() is racy and sometimes can return
	  BPF_STACK_BUILD_ID_IP instead of BPF_STACK_BUILD_ID_VALID;
	  try it one more time.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 prog3 should be broken 
 don't load prog3 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020 Google LLC.
		 Ensure that all executions from hereon are
		  secure by setting a local storage which is read by
		  the bprm_creds_for_exec hook and sets bprm->secureexec.
		 If the binary is executed with securexec=1, the dynamic
		  loader ingores and unsets certain variables like LD_PRELOAD,
		  TMPDIR etc. TMPDIR is used here to simplify the example, as
		  LD_PRELOAD requires a real .so file.
		 
		  If the value of TMPDIR is set, the bash command returns 10
		  and if the value is unset, it returns 20.
 If a secureexec occurred, the exit status should be 20 
 If normal execution happened, the exit code should be 10 
 Run the test with the secureexec bit unset 
 secureexec );
 Run the test with the secureexec bit set 
 secureexec );
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 10 usecs should be enough, but give it extra 
 check that timer_cb1() was executed 10+10 times 
 check that timer_cb2() was executed twice 
 check that there were no errors in timer execution 
 check that code paths completed 
 TODO: use pid filtering 
 SPDX-License-Identifier: GPL-2.0
 test different attr.prog_name during BPF_PROG_LOAD 
 test different attr.map_name during BPF_MAP_CREATE 
 SPDX-License-Identifier: GPL-2.0
 r0 = verdict 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 create perf event 
 Skip the test before we fix LBR snapshot for hypervisor. 
 system doesn't support LBR 
	 Just a guess for the end of this function, as module functions
	  in prockallsyms could come in any order.
 too few entries for the hitwaste test 
	 Given we stop LBR in software, we will waste a few entries.
	  But we should try to waste as few as possible entries. We are at
	  about 7 on x86_64 systems.
	  Add a check for < 10 so that we get heads-up when something
	  changes and wastes too many entries.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020, Oracle andor its affiliates. 
 We do not want to wait forever if this test fails... 
 wait for tracepoint to trigger 
 verify our search string is in the trace buffer 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 Client outside of test cgroup should fail to connect by timeout. 
 Client inside test cgroup should connect just fine. 
	 Create a socket before joining testing cgroup so that its cgroup id
	  differs from that of testing cgroup. Moving selftests process to
	  testing cgroup won't change cgroup id of an already created socket.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 attach two kprobes 
 attach two kretprobes 
 trigger kprobe && kretprobe 
 attach two uprobes 
 self pid ,
 any pid ,
 attach two uretprobes 
 any pid ,
 self pid ,
 trigger uprobe && uretprobe 
 attach first tp prog 
 attach second tp prog 
 trigger tracepoints 
	 now we detach first prog and will attach third one, which causes
	  two internal calls to bpf_prog_array_copy(), shuffling
	  bpf_prog_array_items around. We test here that we don't lose track
	  of associated bpf_cookies.
 attach third tp prog 
 trigger tracepoints 
 generate some branches on cpu 0 
 spin the loop for a while (random high number) 
 create perf event 
 trigger BPF prog 
 prevent bpf_link__destroy() closing pfd itself 
 close BPF link's FD explicitly 
 free up memory used by struct bpf_link 
 trigger BPF prog 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 spare )  sizeof(__u64));
 cut off freplace 
 the target prog should load fine 
	
	  standalone test that asserts failure to load freplace prog
	  because of invalid return code.
 the target prog should load fine 
 It should fail to load the program 
 test invalid return code in the replaced program 
 test with spin lock map value in the replaced program 
 NOTE: affect other tests, must run in serial mode 
 SPDX-License-Identifier: GPL-2.0 
 Copyright (c) 2018 Facebook 
 several different mapv kinds(types) supported by pprint 
 enum E {
      E0,
      E1,
  };
  struct A {
 	unsigned long long m;
 	int n;
 	char o;
 	[3 bytes hole]
 	int p[8];
 	int q[4][8];
 	enum E r;
  };
 int 
 [1] 
 unsigned long long 
 [2] 
 char 
 [3] 
 int[8] 
 [4] 
 struct A { 				
 unsigned long long m;
 int n;		
 char o;		
 int p[8]		
 int q[4][8]		
 enum E r		
 } 
 int[4][8] 
 [6] 
 enum E 					
 typedef struct b Struct_B;
  struct A {
      int m;
      struct b n[4];
      const Struct_B o[4];
  };
  struct B {
      int m;
      int n;
  };
 int 					
 struct b [4] 				
 struct A { 				
 int m;		
 struct B n[4]	
 const Struct_B o[4];
 } 
 struct B { 				
 int m; 
 int n; 
 } 
 const int 					
 typedef struct b Struct_B 	
 const Struct_B 				
 const Struct_B [4] 			
 int 					
 int64 					
 struct A { 				
 int m;		
 int64 n; 
 } 
  struct A {
 	unsigned long long m;
 	int n;
 	char o;
 	[3 bytes hole]
 	int p[8];
  };
 int 
 [1] 
 unsigned long long 
 [2] 
 char 
 [3] 
 int[8] 
 [4] 
 struct A { 				
 unsigned long long m;
 int n;		
 char o;		
 int p[8]		
 } 
  struct A {
 	unsigned long long m;
 	int n;
 	char o;
 	[3 bytes hole]
 	int p[8];
  };
  static struct A t; <- in .bss
 int 
 [1] 
 unsigned long long 
 [2] 
 char 
 [3] 
 int[8] 
 [4] 
 struct A { 				
 unsigned long long m;
 int n;		
 char o;		
 int p[8]		
 } 
 static struct A t 
 [6] 
 .bss section 				
 int 
 [1] 
 static int t 
 [2] 
 .bss section 				
 int 
 [1] 
 static int t 
 [2] 
 .bss section 				
 static void t 
 [1] 
 .bss section 				
 union A 
 [1] 
 static union A t 
 [2] 
 .bss section 				
 union A 
 [1] 
 static union A t 
 [2] 
 .bss section 				
 int 
 [1] 
 unsigned long long 
 [2] 
 char 
 [3] 
 int[8] 
 [4] 
 struct A { 				
 unsigned long long m;
 int n;		
 char o;		
 int p[8]		
 } 
 static struct A t 
 [6] 
 .bss section 				
 int 
 [1] 
 unsigned long long 
 [2] 
 char 
 [3] 
 int[8] 
 [4] 
 struct A { 				
 unsigned long long m;
 int n;		
 char o;		
 int p[8]		
 } 
 static struct A t 
 [6] 
 .bss section 				
 int 
 [1] 
 unsigned long long 
 [2] 
 char 
 [3] 
 int[8] 
 [4] 
 struct A { 				
 unsigned long long m;
 int n;		
 char o;		
 int p[8]		
 } 
 static struct A t 
 [6] 
 .bss section 				
 int 
 [1] 
 unsigned long long 
 [2] 
 char 
 [3] 
 int[8] 
 [4] 
 struct A { 				
 unsigned long long m;
 int n;		
 char o;		
 int p[8]		
 } 
 static struct A t 
 [6] 
 static int u 
 [7] 
 .bss section 				
 int 
 [1] 
 unsigned long long 
 [2] 
 char 
 [3] 
 int[8] 
 [4] 
 struct A { 				
 unsigned long long m;
 int n;		
 char o;		
 int p[8]		
 } 
 static struct A t 
 [6] 
 static int u 
 [7] 
 .bss section 				
 int 
 [1] 
 unsigned long long 
 [2] 
 char 
 [3] 
 int[8] 
 [4] 
 struct A { 				
 unsigned long long m;
 int n;		
 char o;		
 int p[8]		
 } 
 static struct A t 
 [6] 
 static int u 
 [7] 
 .bss section 				
 int 
 [1] 
 unsigned long long 
 [2] 
 char 
 [3] 
 int[8] 
 [4] 
 struct A { 				
 unsigned long long m;
 int n;		
 char o;		
 int p[8]		
 } 
 static struct A t 
 [6] 
 static int u 
 [7] 
 .bss section 				
 int 
 [1] 
 [2] 
 .bss section 				
 int 
 [1] 
 [2] 
 [3] 
 a section 					
 a section 					
 [6] 
 int 
 [1] 
 [2] 
 [3] 
 a section 					
 int 
 [1] 
 [2] 
 .bss section 				
 int 
 [1] 
 [2] 
 [3] 
 int 
 [1] 
 PTR type_id=3				
 [3] 
 int 
 [1] 
 struct A { 				
 int m; 
 VAR type_id=3; 
 } 
 [3] 
 int 
 [1] 
 [2] 
 [3] 
 Test member exceeds the size of struct.
  struct A {
      int m;
      int n;
  };
 int 					
 struct A { 				
 int m; 
 int n; 
 } 
 Test member exceeds the size of struct
  struct A {
      int m;
      int n[2];
  };
 int 					
 int[2] 					
 struct A { 				
 int m; 
 int n[2]; 
 } 
 Test member exceeds the size of struct
  struct A {
      int m;
      void n;
  };
 int 					
 void 					
 struct A { 				
 int m; 
 void n; 
 } 
 Test member exceeds the size of struct
  enum E {
      E0,
      E1,
  };
  struct A {
      int m;
      enum E n;
  };
 int 			
 enum E { 			
 } 
 struct A { 		
 int m; 
 enum E n; 
 } 
 Test member unexceeds the size of struct
  enum E {
      E0,
      E1,
  };
  struct A {
      char m;
      enum E __attribute__((packed)) n;
  };
 int 			
 char 			
 enum E { 			
 } 
 struct A { 		
 char m; 
 enum E __attribute__((packed)) n; 
 } 
 typedef const void  const_void_ptr;
  struct A {
 	const_void_ptr m;
  };
 int 		
 const void 	
 const void 	
 typedef const void  const_void_ptr 
 [4] 
 struct A { 	
 const_void_ptr m; 
 } 
 struct A {
      const void m;
  };
 int 		
 const void 	
 struct A { 	
 const void m; 
 } 
 typedef const void  const_void_ptr;
  const_void_ptr[4]
 int 		
 const void 	
 const void 	
 typedef const void  const_void_ptr 
 [4] 
 const_void_ptr[4] 
 [5] 
 const void[4]  
 int 		
 const void 	
 const void[4] 	
 Array_A  <------------------+
      elem_type == Array_B    |
                     |        |
                     |        |
  Array_B  <-------- +        |
       elem_type == Array A --+
 int 			
 Array_A 			
 Array_B 			
 typedef is _before_ the BTF type of Array_A and Array_B
  typedef Array_B int_array;
  Array_A  <------------------+
      elem_type == int_array  |
                     |        |
                     |        |
  Array_B  <-------- +        |
       elem_type == Array_A --+
 int 
 [1] 
 typedef Array_B int_array 
 [2] 
 Array_A 
 [3] 
 Array_B 
 [4] 
 Array_A  <------------------+
      elem_type == Array_B    |
                     |        |
                     |        |
  Array_B  <-------- +        |
       elem_type == Array_A --+
 int 				
 Array_A 				
 Array_B 				
 typedef is _between_ the BTF type of Array_A and Array_B
  typedef Array_B int_array;
  Array_A  <------------------+
      elem_type == int_array  |
                     |        |
                     |        |
  Array_B  <-------- +        |
       elem_type == Array_A --+
 int 				
 Array_A 				
 typedef Array_B int_array 		
 Array_B 				
 typedef struct B Struct_B
  struct A {
      int x;
      Struct_B y;
  };
  struct B {
      int x;
      struct A y;
  };
 int 
 [1] 
 struct A 					
 int x;	
 Struct_B y;	
 typedef struct B Struct_B 
 [3] 
 struct B 					
 int x;	
 struct A y;	
 struct A {
      int x;
      struct A array_a[4];
  };
 int 
 [1] 
 [2] 
 struct A 					
 int x;		
 struct A array_a[4];	
 int 				
 struct A { 			
     const void m;	
 CONST type_id=3			
 PTR type_id=2			
 int 				
 struct A { 			
     const void m;	
 struct B { 			
     const void n;	
 CONST type_id=5			
 PTR type_id=6			
 CONST type_id=7			
 PTR type_id=4			
 int 				
 int 				
 int 				
 int 				
 int 				
 int 				
 int 				
 int 				
 int 				
 int[16] 				
 int 				
 int[16] 				
 CONST type_id=1 			
 int 				
 int:31 				
 int[16] 				
 CONST type_id=2 			
 int 				
 int:31 				
 int[16] 				
 CONST type_id=2 			
 int 				
 int[16] 				
 int 				
 int[16] 				
 CONST type_id=0 (void) 		
 int 				
 int[16] 				
 CONST type_id=0 (void) 		
 int 				
 const void [16] 			
 CONST type_id=4 			
 void 				
 int 				
 const void [16] 			
 CONST type_id=4 			
 void 				
 int 				
 int[16] 				
 int 				
 int 				
 fwd type 				
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 int 				
 32 bit int with 32 bit offset 	
 int 				
 16 bit int with 0 bit offset 	
 int 				
 btf_value_size < map->value_size 
 int 				
 btf_value_size > map->value_size 
 [1] 
 [2] 
 int ()(int, unsigned int) 
 [3] 
 [1] 
 [2] 
 void ()(int, unsigned int, ...) 
 [3] 
 [1] 
 [2] 
 void ()(int a, unsigned int b, ... c) 
 [3] 
 [1] 
 [2] 
 void ()(int a, ..., unsigned int b) 
 [3] 
 [1] 
 [2] 
 typedef void (func_ptr)(int, unsigned int) 
 [3] 
 const func_ptr 
 [4] 
 [5] 
 [6] 
 [1] 
 [2] 
 [3] 
 [4] 
 [1] 
 void ()(const void ) 
 [2] 
 [3] 
 [4] 
 [1] 
 [2] 
 void ()(int, unsigned int b) 
 [3] 
 [1] 
 [2] 
 void ()(int a, unsigned int <bad_name_off>) 
 [3] 
 [1] 
 [2] 
 void ()(int a, unsigned int !!!) 
 [3] 
 [1] 
 [2] 
 <bad_ret_type> ()(int, unsigned int) 
 [3] 
 [1] 
 [2] 
 void func_proto(int, unsigned int) 
 [3] 
 [1] 
 [2] 
 void ()(const void) 
 [3] 
 [4] 
 [1] 
 [2] 
 void ()(int a, unsigned int b) 
 [3] 
 void func(int a, unsigned int b) 
 [4] 
 [1] 
 [2] 
 void ()(int a, unsigned int b) 
 [3] 
 void <no_name>(int a, unsigned int b) 
 [4] 
 [1] 
 [2] 
 void ()(int a, unsigned int b) 
 [3] 
 void !!!(int a, unsigned int b) 
 [4] 
 [1] 
 [2] 
 void ()(int a, unsigned int) 
 [3] 
 void func(int a, unsigned int) 
 [4] 
 [1] 
 [2] 
 void ()(int a, unsigned int b) 
 [3] 
 void func(int a, unsigned int b) 
 [4] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 [1] 
 [2] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [2] 
 [3] 
 [1] 
 [2] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [3] 
  typedef int arr_t[16];
  struct s {
 	arr_t a;
  };
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 int ,
 arr_t ,
  typedef int arr_t[16][8][4];
  struct s {
 	arr_t a;
  };
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 [6] 
 [7] 
 int ,
 arr_t ,
  typedef int int_t;
  typedef int_t arr3_t[4];
  typedef arr3_t arr2_t[8];
  typedef arr2_t arr1_t[16];
  struct s {
 	arr1_t a;
  };
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 [6] 
 [7] 
 [8] 
 [9] 
 [10] 
 int ,
 arr_t ,
  elf .rodata section size 4 and btf .rodata section vlen 0.
 int 
 [1] 
 .rodata section 
 [2] 
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 [6] 
 [7] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [1] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [3] 
 [1] 
 [2] 
 [1] 
 [2] 
 struct btf_raw_test raw_tests[] 
 Copy header 
 Index strings 
 Copy type section 
 Copy string section 
 int 				
 int 				
 int 				
 int 				
 unsigned int 			
	
	  GET_INFO should error out if the userspace info
	  has non zero tailing bytes.
	
	  GET_INFO should succeed even info_len is larger than
	  the kernel supported as long as tailing bytes are zero.
	  The kernel supported info len should also be returned
	  to userspace.
 Test BPF_OBJ_GET_INFO_BY_ID on btf_id 
 Test btf members in struct bpf_map_info 
 Test BTF ID is removed from the kernel 
 The map holds the last ref to BTF and its btf_id 
 get necessary program info 
 reset info to only retrieve func_info related data 
 check three functions 
		 for the second and third functions in .text section,
		  the compiler may order them either way.
 2 bytes hole 
 unsighed char 			
 unsigned short 			
 unsigned int 			
 int 				
 unsigned long long 		
 2 bits 				
 28 bits 				
 uint8_t[8] 			
 typedef unsigned char uint8_t 	
 typedef unsigned short uint16_t 	
 typedef unsigned int uint32_t 	
 typedef int int32_t 		
 [13] 
 [13] 
 union (anon) 			
 uint64_t ui64; 
 uint8_t ui8a[8]; 
 enum (anon) 			
 struct pprint_mapv 		
 uint32_t ui32 
 uint16_t ui16 
 int32_t si32 
 unused_bits2a 
 bits28 
 unused_bits2b 
 union (anon) 
 aenum 
 uint32_t ui32b 
 bits2c 
 si8_4 
 [17] 
 [18] 
 unsigned int 
 struct pprint_mapv 
	 this type will have the same type as the
	  first .raw_types definition, but struct type will
	  be encoded with kind_flag set.
 unsighed char 			
 unsigned short 			
 unsigned int 			
 int 				
 unsigned long long 		
 [6] 
 [7] 
 uint8_t[8] 			
 typedef unsigned char uint8_t 	
 typedef unsigned short uint16_t 	
 typedef unsigned int uint32_t 	
 typedef int int32_t 		
 [13] 
 [13] 
 union (anon) 			
 uint64_t ui64; 
 uint8_t ui8a[8]; 
 enum (anon) 			
 struct pprint_mapv 		
 uint32_t ui32 
 uint16_t ui16 
 int32_t si32 
 unused_bits2a 
 bits28 
 unused_bits2b 
 union (anon) 
 aenum 
 uint32_t ui32b 
 bits2c 
 si8_4 
 [17] 
 [18] 
 unsigned int 
 struct pprint_mapv 
	 this type will have the same layout as the
	  first .raw_types definition. The struct type will
	  be encoded with kind_flag set, bitfield members
	  are added typedefconstvolatile, and bitfield members
	  will have both int and enum types.
 unsighed char 			
 unsigned short 			
 unsigned int 			
 int 				
 unsigned long long 		
 [6] 
 [7] 
 uint8_t[8] 			
 typedef unsigned char uint8_t 	
 typedef unsigned short uint16_t 	
 typedef unsigned int uint32_t 	
 typedef int int32_t 		
 [13] 
 [13] 
 union (anon) 			
 uint64_t ui64; 
 uint8_t ui8a[8]; 
 enum (anon) 			
 struct pprint_mapv 		
 uint32_t ui32 
 uint16_t ui16 
 int32_t si32 
 unused_bits2a 
 bits28 
 unused_bits2b 
 union (anon) 
 aenum 
 uint32_t ui32b 
 bits2c 
 si8_4 
 typedef unsigned int ___int 	
 [18] 
 [19] 
 [20] 
 [21] 
 unsigned int 
 struct pprint_mapv 
 test int128 
 unsigned int 				
 __int128 					
 unsigned __int128 				
 struct pprint_mapv_int128 			
 si128a 
 si128b 
 bits3 
 bits80 
 ui128 
 Skip lines start with '#' 
				 for percpu map, the format looks like:
				  <key>: {
				 	cpu0: <value_on_cpu0>
				 	cpu1: <value_on_cpu1>
				 	...
				 	cpun: <value_on_cpun>
				  }
				 
				  let us verify the line containing the key here.
 read value@cpu 
 skip the last bracket for the percpu map 
 test various maps with the first test template 
 test rest test templates with the first map 
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 [6] 
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 [6] 
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 [6] 
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 [6] 
 [1] 
 [1] 
 [1] 
 [2] 
 [3] 
 [1] 
 [1] 
 [1] 
 [1] 
 [2] 
 [3] 
 [4] 
 [1] 
 [1] 
 [1] 
 [1] 
 dead jmp \0int a=1;\0int b=2;\0return a + b;\0return a + b;"),
 [1] 
 dead jmp \0return a + b;\0
 [1] 
 [2] 
 [3] 
 [4] 
 dead jmp "
 dead \0 dead \0
 dead \0 dead \0
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 live call "
 dead \0
 dead \0return bla + 1;\0return bla + 1;"
 [1] 
 [2] 
 [3] 
 [5] 
 live call "
 dead \0
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 dead "
 dead \0 dead \0
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 live call "
 dead \0
 dead \0return bla + 1;\0return bla + 1;"
 [1] 
 [2] 
 [3] 
 [4] 
 main linfo \0
 get necessary lens 
 reset info to only retrieve func_info related data 
 prog is not jited 
	
	  Only recheck the info.line_info fields.
	  Other fields are not the concern of this test.
	
	  struct s {
	 	struct s next;
	 	const int a;
	 	int b[16];
	 	int c;
	  }
 int 
 [1] 
 int[16] 
 [2] 
 struct s { 
 [3] 
 struct s next;	
 const int a;	
 int b[16];		
 int c;		
 float d;		
 ptr -> [3] struct s 
 [4] 
 ptr -> [6] const int 
 [5] 
 const -> [1] int 
 [6] 
 tag -> [3] struct s 
 [7] 
 tag -> [3] struct s, member 1 
 [8] 
 full copy of the above 
 [9] 
 [10] 
 [11] 
 [12] 
 [13] 
 [14] 
 [15] 
 [16] 
 [17] 
 int 
 [1] 
 int[16] 
 [2] 
 struct s { 
 [3] 
 struct s next;	
 const int a;	
 int b[16];		
 int c;		
 float d;		
 ptr -> [3] struct s 
 [4] 
 ptr -> [6] const int 
 [5] 
 const -> [1] int 
 [6] 
 [7] 
 [8] 
 [9] 
	
	   CU 1:
	  struct x;
	  struct s {
	 	struct x x;
	  };
	   CU 2:
	  struct x {};
	  struct s {
	 	struct x x;
	  };
 CU 1 
 struct fwd ),	
 [2] ptr -> [1] 
 [3] struct s   
 CU 2 
 [4] struct x   
 [5] ptr -> [4] 
 [6] struct s   
 [1] ptr -> [3] 
 [2] struct s   
 [3] struct x   
 force hash collisions 
	
	   CU 1:
	  struct s {
	 	struct {} x;
	  };
	   CU 2:
	  struct s {
	 	int x;
	  };
 CU 1 
 [1] struct {}  
 [2] ptr -> [1] 
 [3] struct s   
 CU 2 
 [4] ptr -> void 
 [5] struct s   
 CU 1 
 [1] struct {}  
 [2] ptr -> [1] 
 [3] struct s   
 CU 2 
 [4] ptr -> void 
 [5] struct s   
 force hash collisions 
 [1] int 
 [2] enum 
 union kind_flag ),			
 [4] array 
 [5] struct 
 [6] union 
 [7] typedef 
 [8] ptr 
 [9] const 
 [10] volatile 
 [11] restrict 
 [12] func_proto 
 [13] func 
 [14] float 
 [15] decl_tag 
 [16] decl_tag 
 [17] decl_tag 
 [1] int 
 [2] enum 
 union kind_flag ),			
 [4] array 
 [5] struct 
 [6] union 
 [7] typedef 
 [8] ptr 
 [9] const 
 [10] volatile 
 [11] restrict 
 [12] func_proto 
 [13] func 
 [14] float 
 [15] decl_tag 
 [16] decl_tag 
 [17] decl_tag 
 different name 
 different encoding 
 different bit offset 
 different bit size 
 different byte size 
 all allowed sizes 
 different name 
 different encoding 
 different bit offset 
 different bit size 
 different byte size 
 all allowed sizes 
 [1] fwd enum 'e1' before full enum 
 [2] full enum 'e1' after fwd 
 [3] full enum 'e2' before fwd 
 [4] fwd enum 'e2' after full enum 
 [5] incompatible fwd enum with different size 
 [6] incompatible full enum with different value 
 [1] full enum 'e1' 
 [2] full enum 'e2' 
 [3] incompatible fwd enum with different size 
 [4] incompatible full enum with different value 
 int 
 [1] 
 static int t 
 [2] 
 .bss section 				
 int, referenced from [5] 
 [4] 
 another static int t 
 [5] 
 another .bss section 			
 int 
 [1] 
 static int t 
 [2] 
 .bss section 				
 another static int t 
 [4] 
 another .bss section 			
 int 
 [1] 
 static int t 
 [2] 
 void f(int a1, int a2) 
 [3] 
 [4] 
 tag -> t 
 [5] 
 [6] 
 tag -> func 
 [7] 
 [8] 
 tag -> func arg a1 
 [9] 
 [10] 
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 [6] 
 [7] 
 int 
 [1] 
 void f(int a1, int a2) 
 [2] 
 [3] 
 void f(int a1, int a2) 
 [4] 
 [5] 
 tag -> f: tag1, tag2 
 [6] 
 [7] 
 tag -> fa2: tag1, tag2 
 [8] 
 [9] 
 tag -> f: tag1, tag3 
 [10] 
 [11] 
 tag -> fa2: tag1, tag3 
 [12] 
 [13] 
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 [6] 
 [7] 
 [8] 
 [9] 
 int 
 [1] 
 [2] 
 [3] 
 tag -> t: tag1, tag2 
 [4] 
 [5] 
 tag -> tm2: tag1, tag2 
 [6] 
 [7] 
 tag -> t: tag1, tag3 
 [8] 
 [9] 
 tag -> tm2: tag1, tag3 
 [10] 
 [11] 
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 [6] 
 [7] 
 [8] 
 int 
 [1] 
 [2] 
 [3] 
 tag -> t: tag1, tag2 
 [4] 
 [5] 
 tag -> t: tag1, tag3 
 [6] 
 [7] 
 [1] 
 [2] 
 [3] 
 [4] 
 [5] 
 SPDX-License-Identifier: GPL-2.0
 Ensure bytes after string are ones 
 Give prog our userspace pointer 
 Trigger tracepoint 
 Did helper fail? 
 Check that string was copied correctly 
 Now check that no extra trailing bytes were copied 
 Give pid to bpf prog so it doesn't read from anyone else 
 SPDX-License-Identifier: GPL-2.0
 Test shrink with 20 bytes 
 avoid segfault: large buf to hold grow results 
 Test grow with 40 bytes 
 74 ,
 avoid segfault: large buf to hold grow results 
 SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
 Per test 
 Per test 
 Test case-64 
 Determine test case via pkt size 
 Limit copy_size 
 Kernel side alloc packet memory area that is zero init 
 Due limit copy_size in bpf_test_finish 
 Expected grow size 
 Extra checks for data contents 
  0-63  memset to 1 
 64-127 memset to 0 
128-191 memset to 1 
 Test case-128 
 Determine test case via pkt size 
 Copy everything 
 3520 
 Expect max grow size 
 Extra checks for data content: Count grow size, will contain zeros 
 Grow increase 
 Total grow size 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 We do not want to wait forever if this test fails... 
 wait for tracepoint to trigger 
 verify our search string is in the trace buffer 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 check that timer_cb[12] are incrementing 'cnt' 
 100 times more than interval 
 check that code paths completed 
 check that timer_cb[12] are no longer running 
 100 times more than interval 
 SPDX-License-Identifier: GPL-2.0
 ==================== getsockopt ====================  
 return 1 
 return 1 
 return 1 
 r6 = ctx->optval 
 ctx->optval[0] = 0x80 
 return 1 
 r6 = ctx->level 
 if (ctx->level == 123) { 
 ctx->retval = 0 
 return 1 
 } else { 
 return 0 
 } 
 ctx->level = 1 
 r6 = ctx->optname 
 if (ctx->optname == 123) { 
 ctx->retval = 0 
 return 1 
 } else { 
 return 0 
 } 
 r6 = ctx->retval 
 return 1 
 ctx->optname = 1 
 r6 = ctx->optlen 
 if (ctx->optlen == 64) { 
 ctx->retval = 0 
 return 1 
 } else { 
 return 0 
 } 
 ctx->optlen = 65 
 ctx->retval = 0 
 return 1 
 ctx->retval = 123 
 return 1 
 ctx->optlen = 32 
 ctx->retval = 0 
 return 1 
 ctx->optval = 1 
 ctx->optval_end = 1 
 r6 = ctx->optval 
 r2 = ctx->optval 
 r6 = ctx->optval + 1 
 r7 = ctx->optval_end 
 if (ctx->optval + 1 <= ctx->optval_end) { 
 ctx->optval[0] = 0xF0 
 } 
 ctx->retval = 0 
 return 1
 ==================== setsockopt ====================  
 return 1 
 return 1 
 return 1 
 return 0 
 r6 = ctx->optval 
 r0 = ctx->optval[0] 
 return 1 
 r6 = ctx->level 
 if (ctx->level == 123) { 
 ctx->optlen = -1 
 return 1 
 } else { 
 return 0 
 } 
 ctx->level = SOL_IP 
 return 1 
 should be rewritten to SOL_IP 
 r6 = ctx->optname 
 if (ctx->optname == 123) { 
 ctx->optlen = -1 
 return 1 
 } else { 
 return 0 
 } 
 ctx->optname = IP_TOS 
 return 1 
 should be rewritten to IP_TOS 
 r6 = ctx->optlen 
 if (ctx->optlen == 64) { 
 ctx->optlen = -1 
 return 1 
 } else { 
 return 0 
 } 
 ctx->optlen = -1 
 return 1 
 ctx->optlen = -2 
 return 1 
 ctx->optlen = 65 
 r6 = ctx->optval 
 r2 = ctx->optval 
 r6 = ctx->optval + 1 
 r7 = ctx->optval_end 
 if (ctx->optval + 1 <= ctx->optval_end) { 
 ctx->optval[0] = 1 << 3 
 } 
 ctx->optlen = 1 
 return 1
 ctx->retval = 0 
 return 1 
 r6 = ctx->retval 
 return 1 
 ctx->optval = 1 
 ctx->optval_end = 1 
 r6 = ctx->optval 
 r7 = ctx->optval + 1 
 r8 = ctx->optval_end 
 if (ctx->optval + 1 <= ctx->optval_end) { 
 r9 = ctx->optval[0] 
 if (ctx->optval[0] < 128) 
 } 
 } else { 
 } 
 r6 = ctx->optval 
 r7 = ctx->optval + 1 
 r8 = ctx->optval_end 
 if (ctx->optval + 1 <= ctx->optval_end) { 
 r9 = ctx->optval[0] 
 if (ctx->optval[0] < 128) 
 } 
 } else { 
 } 
 SPDX-License-Identifier: GPL-2.0
 this is how USDT semaphore is actually defined, except volatile modifier 
 attach point 
	 Check if new-style kprobeuprobe API is supported.
	  Kernels that support new FD-based kprobe and uprobe BPF attachment
	  through perf_event_open() syscall expose
	  sysbusevent_sourcedeviceskprobetype and
	  sysbusevent_sourcedevicesuprobetype files, respectively. They
	  contain magic numbers that are passed as "type" field of
	  perf_event_attr. Lack of such file in the system indicates legacy
	  kernel with old-style kprobeuprobe attach interface through
	  creating per-probe event through tracefs. For such cases
	  ref_ctr_offset feature is not supported, so we don't test it.
 retprobe ,
 retprobe ,
 self pid ,
 if uprobe uses ref_ctr, uretprobe has to use ref_ctr as well 
 any pid ,
 trigger & validate kprobe && kretprobe 
 trigger & validate uprobe & uretprobe 
 SPDX-License-Identifier: GPL-2.0
 Get prog_id for XDP_ATTACHED_NONE mode 
 Setup prog 
 Get prog_id for single prog mode 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 Check that already linked program can't be attached again. 
 zero results for re-attach test 
 SPDX-License-Identifier: GPL-2.0
 (u32 )(fp - 4) = r0 
 r2 = fp - 4 
 r1 = 1 
 r0 = verdict 
 query the number of effective progs in cg5 
 retrieve prog_ids of effective progs in cg5 
 check enospc handling 
 check that prog_ids are returned even when buffer is too small 
 retrieve prog_id of single attached prog in cg5 
 detach bottom program and ping again 
 test replace 
 replacing a program that is not attached to cgroup should fail  
 replace 1st from the top program 
 replace program with itself 
 detach 3rd from bottom program and ping again 
 detach 2nd from bottom program and ping again 
 SPDX-License-Identifier: GPL-2.0
 hook ifindex = 0 
 hook ifindex < 0 
 hook.attach_point invalid 
 hook.attach_point valid, but parent invalid 
	 These return EOPNOTSUPP instead of EINVAL as parent is checked after
	  attach_point of the hook.
 detach 
 query 
 when chain is not present, kernel returns -EINVAL 
 attach 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 query (getpid(), efd) 
 test zero len 
 test empty buffer 
 test smaller buffer 
 SPDX-License-Identifier: GPL-2.0
  Check if we can migrate child sockets.
    1. call listen() for 4 server sockets.
    2. call connect() for 25 client sockets.
    3. call listen() for 1 server socket. (migration target)
    4. update a map to migrate all child sockets
         to the last server socket (migrate_map[cookie] = 4)
    5. call shutdown() for first 4 server sockets
         and migrate the requests in the accept queue
         to the last server socket.
    6. call listen() for the second server socket.
    7. call shutdown() for the last server
         and migrate the requests in the accept queue
         to the second server socket.
    8. call listen() for the last server.
    9. call shutdown() for the second server
         and migrate the requests in the accept queue
         to the last server socket.
   10. call accept() for the last server socket.
  Author: Kuniyuki Iwashima <kuniyu@amazon.co.jp>
 fastopenq->max_qlen and sk->sk_max_ack_backlog 
		 (TFO_CLIENT_ENABLE | TFO_SERVER_ENABLE |
		   TFO_CLIENT_NO_COOKIE | TFO_SERVER_COOKIE_NOT_REQD)
 All requests will be tied to the first four listeners 
		 The attached XDP program drops only the final ACK, so
		  clients will transition to TCP_ESTABLISHED immediately.
	 Migrate TCP_ESTABLISHED and TCP_SYN_RECV requests
	  to the last listener based on eBPF.
 No dance for TCP_NEW_SYN_RECV to migrate based on eBPF 
	 Note that we use the second listener instead of the
	  first one here.
	 
	  The fist listener is bind()ed with port 0 and,
	  SOCK_BINDPORT_LOCK is not set to sk_userlocks, so
	  calling listen() again will bind() the first listener
	  on a new ephemeral port and detach it from the existing
	  reuseport group.  (See: __inet_bind(), tcp_set_state())
	 
	  OTOH, the second one is bind()ed with a specific port,
	  and SOCK_BINDPORT_LOCK is set. Thus, re-listen() will
	  resurrect the listener on the existing reuseport group.
	 Migrate from the last listener to the second one.
	 
	  All listeners were detached out of the reuseport_map,
	  so migration will be done by kernel random pick from here.
 Back to the existing reuseport group 
 Migrate back to the last one from the second one 
		 Drop the final ACK of the 3-way handshake and stick the
		  in-flight requests on TCP_SYN_RECV or TCP_NEW_SYN_RECV.
 Tie requests to the first four listners 
	 Migrate the requests in the accept queue only.
	  TCP_NEW_SYN_RECV requests are not migrated at this point.
		 Wait for SYN+ACK timers to expire so that
		  reqsk_timer_handler() migrates TCP_NEW_SYN_RECV requests.
 Resume 3WHS and migrate TCP_NEW_SYN_RECV requests 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Google LLC.
 Copyright (c) 2018 Facebook
 SPDX-License-Identifier: GPL-2.0-only
www.tessares.net> 
 padding 
 executes bpf program that updates map with key, value 
 Let tracepoint trigger 
 Add key=1 elem with values set for all CPUs
  Delete elem key=1
  Run bpf prog that inserts new key=1 elem with value=0x1234
    (bpf prog can only set value for current CPU)
  Lookup Key=1 and check value is as expected for all CPUs:
    value set by bpf prog for one CPU, 0 for all others
 max 1 elem in map so insertion is forced to reuse freed entry 
 delete element so the entry can be re-used
 run bpf prog that inserts new elem, re-using the slot just freed 
 check that key=1 was re-created by bpf prog 
 and has expected values 
 Add key=1 and key=2 elems with values set for all CPUs
  Run bpf prog that inserts new key=3 elem
    (only for current cpu; other cpus should have initial value = 0)
  Lookup Key=1 and check value is as expected for all CPUs
	 Set up LRU map with 2 elements, values filled for all CPUs.
	  With these 2 elements, the LRU map is full
 run bpf prog that inserts new key=3 element, re-using LRU slot 
 check that key=3 replaced one of earlier elements 
 and has expected values 
 SPDX-License-Identifier: GPL-2.0
 Set IP_TOS to the expected value (0x80). 
	 Attach child program and make sure it returns new value:
	  - kernel:      -> 0x80
	  - child:  0x80 -> 0x90
	 Attach parent program and make sure it returns new value:
	  - kernel:      -> 0x80
	  - child:  0x80 -> 0x90
	  - parent: 0x90 -> 0xA0
	 Setting unexpected initial sockopt should return EPERM:
	  - kernel: -> 0x40
	  - child:  unexpected 0x40, EPERM
	  - parent: unexpected 0x40, EPERM
	 Detach child program and make sure we still get EPERM:
	  - kernel: -> 0x40
	  - parent: unexpected 0x40, EPERM
	 Set initial value to the one the parent program expects:
	  - kernel:      -> 0x90
	  - parent: 0x90 -> 0xA0
 Set IP_TOS to the expected value (0x80). 
 Attach child program and make sure it adds 0x10. 
 Attach parent program and make sure it adds another 0x10. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Cloudflare
 TCP sock is under repair right now 
 Turn off without window probes 
 Create a map, populate it with one socket, and free the map. 
 do some tests 
 test results 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 generate some branches on cpu 0 
 spin the loop for a while (random high number) 
 TODO: often fails in concurrent mode 
 create perf event 
 ensure we get at least one perf_event prog execution 
	 perf_event is still active, but we close link and BPF program
	  shouldn't be executed anymore
 make sure there are no stragglers 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 trigger 
 SPDX-License-Identifier: GPL-2.0
 Test read and writes to the stack performed with offsets that are not
  statically known.
 Give pid to bpf prog so it doesn't trigger for anyone else. 
 Initialize the probe's input. 
 This will be returned in probe_res. 
 Trigger probe. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 skip the last iteration for expected total 
 SPDX-License-Identifier: GPL-2.0
 Align the .BTF_ids section to 4 bytes 
	 Check BTF_ID_LIST(test_list_local) and
	  BTF_ID_LIST_GLOBAL(test_list_global) IDs
 Check BTF_SET_START(test_set) IDs 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 inner1 = input, inner2 = input + 1, inner3 = input + 2 
 inner2 = input, inner1 = input + 1, inner4 = input + 2 
 inner5 = input + 2 
	 we need to either wait for or force synchronize_rcu(), before
	  checking for "still exists" condition, otherwise map could still be
	  resolvable by ID, causing false positives.
	 
	  Older kernels (5.8 and earlier) freed map only after two
	  synchronize_rcu()s, so trigger two, to be entirely sure.
 SPDX-License-Identifier: GPL-2.0
 pid ,
 cpu 0 , -1 
 flags );
 check NULL prog array query 
 try to get # of programs only 
 try a few negative tests 
 invalid query pointer 
 no enough space 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 validate values are pre-initialized correctly 
 validate we can pre-setup global variables, even in .bss 
 validate pre-setup values are still there 
 now set new values and attach to get them into outX variables 
 trigger tracepoint 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
	 The bpf prog only counts for fullsock and
	  passive connection did not become fullsock until 3WHS
	  had been finished, so the bpf prog only counted two data
	  packet out.
	 Active connection is fullsock from the beginning.
	  1 SYN and 1 ACK during 3WHS
	  2 Acks on data packet.
	 
	  The bpf_prog initialized it to 0xeB9F.
 Prepare listen_fd 
 start_server() has logged the error details 
		 Send some data from accept_fd to cli_fd.
		  MSG_EOR to stop kernel from coalescing two pkts.
 Create a cgroup, get fd, and join it 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 .type = PERF_TYPE_SOFTWARE, 
 override program type 
 pid ,
 cpu 0 , -1 
 flags );
 add PERF_SAMPLE_CALLCHAIN, attach should succeed 
 pid ,
 cpu 0 , -1 
 flags );
 add exclude_callchain_kernel, attach should fail 
 pid ,
 cpu 0 , -1 
 flags );
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook
 Copyright (c) 2019 Cloudflare
 Copyright (c) 2020 Isovalent, Inc.
  Test that the socket assign program is able to redirect traffic towards a
  socket, regardless of whether the port or address destination of the traffic
  matches the port.
 Move to a new networking namespace 
 Configure necessary links, routes 
 Load qdisc, BPF program 
	 SOCK_STREAM is connected via accept(), so the server's local address
	  will be the CONNECT_PORT rather than the BIND port that corresponds
	  to the listen socket. SOCK_DGRAM on the other hand is connectionless
	  so we can't really do the same check there; the server doesn't ever
	  create a socket with CONNECT_PORT.
 connect to unbound ports 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2020 Google LLC.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 Prepare non-reuseport listen_fd 
 Connect to non-reuseport listen_fd 
 Prepare reuseport listen fds 
 Run bpf tcp iter to switch from bpf_cubic to bpf_dctcp 
 Check reuseport listen fds for dctcp 
 Check non reuseport listen fd for dctcp 
 Check established fds for dctcp 
 Check accepted fds for dctcp 
 Load iter_skel 
 Load bpf_cubic 
 Load bpf_dctcp 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 wait until first sys_nanosleep ends and second sys_nanosleep starts 
	 close progs and detach them. That will trigger two nop5->jmp5 rewrites
	  in the trampolines to skip nanosleep_fexit prog.
	  The nanosleep_fentry prog will get detached first.
	  The nanosleep_fexit prog will get detached second.
	  Detaching will trigger freeing of both progs JITed images.
	  There will be two dying bpf_tramp_image-s, but only the initial
	  bpf_tramp_image (with both _fentry and _fexit progs will be stuck
	  waiting for percpu_ref_kill to confirm). The other one
	  will be freed quickly.
 kill the thread to unwind sys_nanosleep stack through the trampoline 
	 The bypassed nanosleep_fexit prog shouldn't have executed.
	  Unlike progs the maps were not freed and directly accessible.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 that's kernel internal BPF_MAX_TRAMP_PROGS define 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2018 Facebook 
 Creating reuseport_array 
 Creating outer_map 
	
	  +1 for TCP-SYN and
	  +1 for the TCP-ACK (ack the syncookie)
	
	  Simulate TCP-SYN and TCP-ACK are handled by two different sk:
	  TCP-SYN: select sk_fds[tmp_index = 1] tmp_index is from the
	           tmp_index_ovr_map
	  TCP-ACK: select sk_fds[reuseport_index = 0] reuseport_index
	           is from the cmd.reuseport_index
	
	  The sk_fds[] is filled from the back such that the order
	  is exactly opposite to the (struct sock_reuseport )reuse->socks[].
 Install reuseport_array to outer_map? 
 Delete reuseport_array from outer_map? 
 test not compatible with socket type 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 trigger probe 
 SPDX-License-Identifier: GPL-2.0
 find map fds 
 give some time for bpf program run 
 disable stack trace collection 
	 for every element in stackid_hmap, we can find a corresponding one
	  in stackmap, and vise versa.
 SPDX-License-Identifier: GPL-2.0
 spurious kfree_skb not on loopback device 
 TODO: fix kernel panic caused by this test in parallel mode 
 set up perf buffer 
 read perf buffer 
	 make sure kfree_skb program was triggered
	  and it sent expected skb into ring buffer
 SPDX-License-Identifier: GPL-2.0
 test_tailcall_1 checks basic functionality by patching multiple locations
  in a single program for a single tail call slot with nop->jmp, jmp->nop
  and jmp->jmp rewrites. Also checks for nop->nop.
 test_tailcall_2 checks that patching multiple programs for a single
  tail call slot works. It also jumps through several programs and tests
  the tail call limit counter.
 test_tailcall_3 checks that the count value of the tail call limit
  enforcement matches with expectations. JIT uses direct jump.
 test_tailcall_6 checks that the count value of the tail call limit
  enforcement matches with expectations. JIT uses indirect jump.
 test_tailcall_4 checks that the kernel properly selects indirect jump
  for the case where the key is not known. Latter is passed via global
  data to select different targets we can compare return value of.
 test_tailcall_5 probes similarly to test_tailcall_4 that the kernel generates
  an indirect jump when the keys are const but different from different branches.
 test_tailcall_bpf2bpf_1 purpose is to make sure that tailcalls are working
  correctly in correlation with BPF subprograms
 nop -> jmp 
 jmp -> nop, call subprog that will do tailcall 
	 make sure that subprog can access ctx and entry prog that
	  called this subprog can properly return
 test_tailcall_bpf2bpf_2 checks that the count value of the tail call limit
  enforcement matches with expectations when tailcall is preceded with
  bpf2bpf call.
 test_tailcall_bpf2bpf_3 checks that non-trivial amount of stack (up to
  256 bytes) can be used within bpf subprograms that have the tailcalls
  in them
 test_tailcall_bpf2bpf_4 checks that tailcall counter is correctly preserved
  across tailcalls combined with bpf2bpf calls. for making sure that tailcall
  counter behaves correctly, bpf program will go through following flow:
  entry -> entry_subprog -> tailcall0 -> bpf_func0 -> subprog0 ->
  -> tailcall1 -> bpf_func1 -> subprog1 -> tailcall2 -> bpf_func2 ->
  subprog2 [here bump global counter] --------^
  We go through first two tailcalls and start counting from the subprog2 where
  the loop begins. At the end of the test make sure that the global counter is
  equal to 31, because tailcall counter includes the first two tailcalls
  whereas global counter is incremented only on loop presented on flow above.
  The noise parameter is used to insert bpf_map_update calls into the logic
  to force verifier to patch instructions. This allows us to ensure jump
  logic remains correct with instruction movement.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 real layout and sizes according to test's (32-bit) BTF
 can't use `void `, it is always 8 byte in BPF target 
	 Emit the following struct with 32-bit pointer size:
	 
	  struct test_struct {
	      void ptr;
	      unsigned long val2;
	      unsigned long long val1;
	      unsigned short val3;
	      unsigned char val4;
	      char: 8;
	  };
	 
	  This struct is going to be used as the "kernel BTF" for this test.
	  It's equivalent memory-layout-wise to test_struct__real above.
 force 32-bit pointer size 
 "long unsigned int" of 4 byte size tells BTF that sizeof(void ) == 4 
 bytes );
 open and load BPF program with custom BTF as the kernel BTF 
 disable handle_signed() for now 
 now re-load with handle_signed() enabled, it should fail loading 
 SPDX-License-Identifier: GPL-2.0
 Matches must be in order of increasing line 
	 Four tests of known constants.  These aren't staggeringly
	  interesting since we track exact values now.
 Tests using unknown values 
 Skip over ethernet header.  
			 First, add a constant to the R5 packet pointer,
			  then a variable with a known alignment.
			 Now, test in the other direction.  Adding first
			  the variable offset to R5, then the constant.
			 Test multiple accumulations of unknown values
			  into a packet pointer.
			 Calculated offset in R6 has unknown value, but known
			  alignment of 4.
			 Offset is added to packet pointer R5, resulting in
			  known fixed offset, and variable offset from R6.
			 At the time the word size load is performed from R5,
			  it's total offset is NET_IP_ALIGN + reg->off (0) +
			  reg->aux_off (14) which is 16.  Then the variable
			  offset is considered using reg->aux_off_align which
			  is 4 and meets the load's requirements.
			 Variable offset is added to R5 packet pointer,
			  resulting in auxiliary alignment of 4.
			 Constant offset is added to R5, resulting in
			  reg->off of 14.
			 At the time the word size load is performed from R5,
			  its total fixed offset is NET_IP_ALIGN + reg->off
			  (14) which is 16.  Then the variable offset is 4-byte
			  aligned, so the total offset is 4-byte aligned and
			  meets the load's requirements.
			 Constant offset is added to R5 packet pointer,
			  resulting in reg->off value of 14.
			 Variable offset is added to R5, resulting in a
			  variable offset of (4n).
 Constant is added to R5 again, setting reg->off to 18. 
			 And once more we add a variable; resulting var_off
			  is still (4n), fixed offset is not changed.
			  Also, we create a new reg->id.
			 At the time the word size load is performed from R5,
			  its total fixed offset is NET_IP_ALIGN + reg->off (18)
			  which is 20.  Then the variable offset is (4n), so
			  the total offset is 4-byte aligned and meets the
			  load's requirements.
 Create an unknown offset, (4n+2)-aligned 
 Add it to the packet pointer 
 Check bounds and perform a read 
 Make a (4n) offset from the value we just read 
 Add it to the packet pointer 
 Check bounds and perform a read 
			 Calculated offset in R6 has unknown value, but known
			  alignment of 4.
 Adding 14 makes R6 be (4n+2) 
 Packet pointer has (4n+2) offset 
			 At the time the word size load is performed from R5,
			  its total fixed offset is NET_IP_ALIGN + reg->off (0)
			  which is 2.  Then the variable offset is (4n+2), so
			  the total offset is 4-byte aligned and meets the
			  load's requirements.
			 Newly read value in R6 was shifted left by 2, so has
			  known alignment of 4.
			 Added (4n) to packet pointer's (4n+2) var_off, giving
			  another (4n+2).
			 At the time the word size load is performed from R5,
			  its total fixed offset is NET_IP_ALIGN + reg->off (0)
			  which is 2.  Then the variable offset is (4n+2), so
			  the total offset is 4-byte aligned and meets the
			  load's requirements.
 (ptr - ptr) << 2 
			 We have a (4n) value.  Let's make a packet offset
			  out of it.  First add 14, to make it a (4n+2)
 Then make sure it's nonnegative 
 Add it to packet pointer 
 Check bounds and perform a read 
 (ptr - ptr) << 2 == unknown, (4n) 
			 (4n) + 14 == (4n+2).  We blow our bounds, because
			  the add could overflow.
 Checked s>=0 
 packet pointer + nonnegative (4n+2) 
			 NET_IP_ALIGN + (4n+2) == (4n), alignment is fine.
			  We checked the bounds, but it might have been able
			  to overflow if the packet pointer started in the
			  upper half of the address space.
			  So we did not get a 'range' on R6, and the access
			  attempt will fail.
 Create an unknown offset, (4n+2)-aligned 
			 Create another unknown, (4n)-aligned, and subtract
			  it from the first one
 Bounds-check the result 
 Add it to the packet pointer 
 Check bounds and perform a read 
			 Calculated offset in R6 has unknown value, but known
			  alignment of 4.
 Adding 14 makes R6 be (4n+2) 
 New unknown value in R7 is (4n) 
 Subtracting it from R6 blows our unsigned bounds 
 Checked s>= 0 
			 At the time the word size load is performed from R5,
			  its total fixed offset is NET_IP_ALIGN + reg->off (0)
			  which is 2.  Then the variable offset is (4n+2), so
			  the total offset is 4-byte aligned and meets the
			  load's requirements.
			 Create an unknown offset, (4n+2)-aligned and bounded
			  to [14,74]
 Subtract it from the packet pointer 
			 Create another unknown, (4n)-aligned and >= 74.
			  That in fact means >= 76, since 74 % 4 == 2
 Add it to the packet pointer 
 Check bounds and perform a read 
			 Calculated offset in R6 has unknown value, but known
			  alignment of 4.
 Adding 14 makes R6 be (4n+2) 
 Subtracting from packet pointer overflows ubounds 
 New unknown value in R7 is (4n), >= 76 
 Adding it to packet pointer gives nice bounds again 
			 At the time the word size load is performed from R5,
			  its total fixed offset is NET_IP_ALIGN + reg->off (0)
			  which is 2.  Then the variable offset is (4n+2), so
			  the total offset is 4-byte aligned and meets the
			  load's requirements.
 We make a local copy so that we can strtok() it 
 SPDX-License-Identifier: GPL-2.0
 check global map 
 3 comes from one listening socket + both ends of the connection 
 check setsockopt for SAVE_SYN 
 check getsockopt for SAVED_SYN 
 check getsockopt for window_clamp 
 Send 1000B of '+'s from cli_fd -> accept_fd 
 Send 500B of '.'s from accept_fd ->cli_fd 
	
	  shutdown accept first to guarantee correct ordering for
	  bytes_received and bytes_acked when we go to verify the results.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Cloudflare
  Tests for sockmapsockhash holding kTLS sockets.
 Disconnect (unhash) a kTLS socket after removing it from sockmap. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 Invalid key size 
 Invalid value size 
 Invalid max entries size 
 Bloom filter maps do not support BPF_F_NO_PREALLOC 
 Test invalid flags 
 Create a map 
 Add a value to the bloom filter 
 Lookup a value in the bloom filter 
 Create a bloom filter map that will be used as the inner map 
 Add the bloom filter map to the outer map 
 Attach the bloom_filter_inner_map prog 
 Ensure the inner bloom filter map can be deleted 
 Set up a bloom filter map skeleton 
 Set up rand_vals 
 Generate random values and populate both skeletons 
 SPDX-License-Identifier: GPL-2.0
 can not attach BPF_XDP_CPUMAP program to a device 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Fill test values to be used 
 Push 32 elements to the input map 
	 The eBPF program pushes iph.saddr in the output map,
	  pops the input map and saves this value in iph.daddr
 Queue is empty, program should return TC_ACT_SHOT 
 TC_ACT_SHOT || size != sizeof(pkt_v4),
 Check that the program pushed elements correctly 
 SPDX-License-Identifier: GPL-2.0
	
	  It's hard to validate the contents of the branch entries bc it
	  would require some kind of disassembler and also encoding the
	  valid jump instructions for supported architectures. So just check
	  the easy stuff for now.
 attach perf_event 
 generate some branches on cpu 0 
 spin the loop for a while (random high number) 
 create perf event 
	
	  Some setups don't support branch records (virtual machines, !x86),
	  so skip test in this case.
  Tests negative case -- run bpf_read_branch_records() on improperly configured
  perf event.
 create perf event 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020 Google LLC.
	 Lock ensures that spin locked versions of local stoage operations
	  also work, most operations in this tests are still single threaded
 Fork and exec the provided rm binary and return the exit code of the
  forked process and its pid.
		 Use the copied usrbinrm to delete itself
		  tmpcopy_of_rm tmpcopy_of_rm.
 Looking up an existing element should fail initially 
 Create a new element 
 Lookup the newly created element 
 Check the value of the newly created element 
 The lookup should fail, now that the element has been deleted 
	 Sets skel->bss->monitored_pid to the pid of the forked child
	  forks a child process that executes tmp_exec_path and tries to
	  unlink its executable. This operation should be denied by the loaded
	  LSM program.
 Set the process being monitored to be the current process 
	 Move copy_of_rm to a new location so that it triggers the
	  inode_rename LSM hook with a new_dentry that has a NULL inode ptr.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
reviews.llvm.orgD109073?");
 SPDX-License-Identifier: GPL-2.0-only
 TODO: use different target function to run in concurrent mode 
 attach 'allowed' trampoline programs 
 and try 1 extra.. 
 ..that needs to fail 
 with E2BIG error 
 and finaly execute the probe 
 SPDX-License-Identifier: GPL-2.0
 AddressSanitizer sometimes crashes due to data dereference below, due to
  this being mmap()'ed memory. Disable instrumentation with
  no_sanitize_address attribute
 load program 
 attach probe 
 set up perf buffer 
 trigger kprobe on every CPU 
 read perf buffer 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 ctx_in != NULL, ctx_size_in == 0 
 ctx_out != NULL, ctx_size_out == 0 
 non-zero [len, tc_index] fields should be rejected
 non-zero [hash, sk] fields should be rejected 
 SPDX-License-Identifier: GPL-2.0
 NOTE: conflict with other tests. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 bind, listen and start server thread to accept 
 connect to server 
 recv total_bytes 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Carlos Neira cneirabustos@gmail.com 
 trigger tracepoint 
	 Create a process in a new namespace, this process
	  will be the init process of this new namespace hence will be pid 1.
 TODO: use a different tracepoint 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
	 Ensure 20 bytes options (i.e. in total 40 bytes tcp header) for the
	  bpf_tcp_gen_syncookie() helper.
 Enforce syncookie mode 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2019 Facebook 
 base line run 
 attach kprobe 
 retprobe ,
 attach kretprobe 
 retprobe ,
 attach raw_tp 
 attach fentry 
 attach fexit 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 pin link 
 check that link was pinned 
 destroy link, pinned link should keep program attached 
 re-open link from BPFFS 
 unpin link from BPFFS, program still attached 
 still active, as we have FD open now 
	 Validate it's finally detached.
	  Actual detachment might get delayed a bit, so there is no reliable
	  way to validate it immediately here, let's count up for long enough
	  and see if eventually output stops being updated
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 TODO: corrupts other tests uses connect() 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 ___shuffled flavor is just an illusion for BPF code, it doesn't really
  exist and user-space needs to provide data in the memory layout that
  matches callback_head. We just defined ___shuffled flavor to make it easier
  to work with the skeleton
 next pointers have to be set from the kernel side 
 trigger tracepoint 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2020 Google LLC.
	 Attach to parent cgroup, trigger packet from child.
	  Assert that there is only one run and in that run the storage is
	  parent cgroup's storage.
	  Also assert that child cgroup's storage does not exist
	 Attach to parent and child cgroup, trigger packet from child.
	  Assert that there are two additional runs, one that run with parent
	  cgroup's storage and one with child cgroup's storage.
	 Attach to parent cgroup, trigger packet from child.
	  Assert that there is three runs, two with parent cgroup egress and
	  one with parent cgroup ingress, stored in separate parent storages.
	  Also assert that child cgroup's storages does not exist
	 Attach to parent and child cgroup, trigger packet from child.
	  Assert that there is six additional runs, parent cgroup egresses and
	  ingress, child cgroup egresses and ingress.
	  Assert that egree and ingress storages are separate.
	 Attach to parent cgroup, trigger packet from child.
	  Assert that there is three runs, two with parent cgroup egress and
	  one with parent cgroup ingress.
	  Also assert that child cgroup's storage does not exist
	 Attach to parent and child cgroup, trigger packet from child.
	  Assert that there is six additional runs, parent cgroup egresses and
	  ingress, child cgroup egresses and ingress.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Cloudflare
  Test suite for SOCKMAPSOCKHASH holding listening sockets.
  Covers:
   1. BPF map operations - bpf_map_{update,lookup delete}_elem
   2. BPF redirect helpers - bpf_{sk,msg}_redirect_map
   3. BPF reuseport helper - bpf_sk_select_reuseport
 Wrappers that fail the test on error and report it. 
 SOCKMAP and SOCKHASH return different error codes 
 Exercise the code path where we destroy child sockets that never
  got accept()'ed, aka orphans, when parent socket gets closed.
 Perform a passive open after removing listening socket from SOCKMAP
  to ensure that callbacks get restored properly.
 Check that child socket that got created while parent was in a
  SOCKMAP, but got accept()'ed only after the parent has been removed
  from SOCKMAP, gets cloned without parent psock state or callbacks.
 Create child while parent is in sockmap 
 Remove parent from sockmap 
 Check that child sk_user_data is not set 
 Check that child socket that got created and accepted while parent
  was in a SOCKMAP is cloned without parent psock state or callbacks.
 Create & accept child while parent is in sockmap 
 Check that child sk_user_data is not set 
 Expecting EOPNOTSUPP before listen() 
 Expecting no entry after unhash on connect(AF_UNSPEC) 
 Populate sock_map[0] to avoid ENOENT on first connection 
 Update sock_map[0] to redirect to a connected socket 
 Check that redirecting across reuseport groups is not allowed. 
 Create two listeners, each in its own reuseport group 
 Connect to s2, reuseport BPF selects s1 via sock_map[0] 
 Expect drop, can't redirect outside of reuseport group 
 insert 
 delete 
 lookup 
 update 
 races with insertdelete 
 child clone 
 SPDX-License-Identifier: GPL-2.0
 wrong size, should fail 
 object loaded - should fail 
 SPDX-License-Identifier: GPL-2.0
  Test XDP bonding support
  Sets up two bonded veth pairs between two fresh namespaces
  and verifies that XDP_TX program loaded on a bond device
  are correctly loaded onto the slave devices and XDP_TX'd
  packets are balanced using bonding.
 skip whitespace 
 skip whitespace 
 skip rx bytes 
 skip whitespace 
	 Load a dummy program on sending side as with veth peer needs to have a
	  XDP program loaded as well.
 vary the UDP destination port for even distribution with roundrobinxor modes 
 Test the broadcast redirection using xdp_redirect_map_multi_prog and adding
  all the interfaces to it and checking that broadcasting won't send the packet
  to neither the ingress bond device (bond2) or its slave (veth2_1).
 populate the devmap with the relevant interfaces 
 Test that XDP programs cannot be attached to both the bond master and slaves simultaneously 
 enslaving with a XDP program loaded is allowed 
 attaching to slave when master has no program is allowed 
 attaching to master not allowed when slave has program loaded 
 attaching XDP program to master allowed when slave has no program 
 attaching to slave not allowed when master has program loaded 
 test program unwinding with a non-XDP slave 
 attaching not allowed when one slave does not support XDP 
 Test with nested bonding devices to catch issue with negative jump label count 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Jesper Dangaard Brouer 
 before test_progs.h, avoid bpf_util.h redefines 
 Hint: needed for CHECK macro 
 Exit if e.g. helper unknown to kernel 
 Extract MTU that BPF-prog got 
 Update "constants" in BPF-prog BEFORE libbpf load 
 Extract MTU that BPF-prog got 
 Update "constants" in BPF-prog BEFORE libbpf load 
 SPDX-License-Identifier: GPL-2.0
 +1 to test for the info_len returned by kernel 
	 Each prog only uses one map. +1 to test nr_map_ids
	  returned by kernel.
 Check bpf_obj_get_info_by_fd() 
		 test_obj_id.o is a dumb prog. It should never fail
		  to load.
 Insert a magic value to the map 
 Check getting map info 
 Check getting prog info 
 Check getting link info 
 Check bpf_prog_get_next_id() 
 The bpf_prog is in the dead row 
		 Negative test:
		  prog_info.nr_map_ids = 1
		  prog_info.map_ids = NULL
 Check bpf_map_get_next_id() 
 The bpf_map is in the dead row 
 Check bpf_link_get_next_id() 
 The bpf_link is in the dead row 
 SPDX-License-Identifier: GPL-2.0
	 Some packets can be still in per-cpu cache, but not more than
	  MAX_PERCPU_PACKETS.
 No packets should be lost 
	 Let's check that bytes counter matches the number of packets
	  multiplied by the size of ipv6 ICMP packet.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
invoked=1,
dsack_dups=0,
delivered=1,
delivered_ce=0,
icsk_retransmits=0);
invoked=2,
dsack_dups=0,
delivered=2,
delivered_ce=0,
icsk_retransmits=0);
 SPDX-License-Identifier: GPL-2.0
 r0 = 1 
 create a cgroup, attach two programs and remember their ids 
 make sure that programs are attached and run some traffic 
 allocate some memory (4Mb) to pin the original cgroup 
 close programs and cgroup fd 
 leave the cgroup and remove it. don't detach programs 
	 wait for the asynchronous auto-detachment.
	  wait for no more than 5 sec and give up.
 don't leave the fd open 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 openloadattach test_pkt_md_access 
 open extension 
 set extension's attach target - test_pkt_md_access  
 loadattach extension 
 open tracing  
 set tracing's attach target - fentry 
 set tracing's attach target - fexit 
 loadattach tracing 
 trigger the test 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 See feature_test_macros(7) 
 For SYS_xxx definitions 
 3x syscalls: 1x attach and 2x gettid 
 trigger at least one exit_creds() 
 sync rcu to make sure exit_creds() is called for "ls" 
 trigger sys_enter, make sure it does not cause deadlock 
 SPDX-License-Identifier: GPL-2.0
 Load XDP program to introspect 
 Load trace program 
	 Demonstrate the bpf_program__set_attach_target() API rather than
	  the load with options, i.e. opts.attach_prog_fd.
 Set up perf buffer 
 Run test program 
	 Make sure bpf_xdp_output() was triggered and it sent the expected
	  data to the perf ring buffer.
 Verify test results 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
	 test6 is x86_64 specifc because of the instruction
	  offset, disabling it for all other archs
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2020 Facebook 
	 the primary goal of this test is to test LBR. Create a lot of
	  branches in the function, so we can catch it easily.
	 This is always true. Use the check to make sure the compiler
	  doesn't remove bpf_testmod_loop_test.
 Magic number to enable writable tp 
 always fail 
 always fail 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook  
 test 1: lookupdelete an empty hash table, -ENOENT 
 populate elements to the map 
 test 2: lookupdelete with count = 0, success 
 test 3: lookupdelete with count = max_entries, success 
 bpf_map_get_next_key() should return -ENOENT for an empty map. 
 test 4: lookupdelete in a loop with various steps. 
		 iteratively lookupdelete elements with 'step'
		  elements each
			 It is possible that we are failing due to buffer size
			  not big enough. In such cases, let us just exit and
			  go with large steps. Not that a buffer size with
			  max_entries should always work.
 check map is empty, errono == ENOENT 
		 iteratively lookupdelete elements with 'step'
		  elements each
			 It is possible that we are failing due to buffer size
			  not big enough. In such cases, let us just exit and
			  go with large steps. Not that a buffer size with
			  max_entries should always work.
 SPDX-License-Identifier: GPL-2.0
 test 1: lookup in a loop with various steps. 
		 iteratively lookupdelete elements with 'step'
		  elements each.
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook  
 int 
 [1] 
 struct bpf_spin_lock                       
 int val; 
 struct val                                 
 int cnt; 
 struct bpf_spin_lock l; 
 Suppress compiler false alarm 
 Suppress compiler false alarm 
 Add new elem 
 Bump the cnt and update with BPF_EXIST | BPF_F_LOCK 
 Bump the cnt and update with BPF_EXIST 
 Update with BPF_NOEXIST 
 Bump the cnt again and update with map_flags == 0 
 Test delete elem 
 SPDX-License-Identifier: GPL-2.0
		 iteratively lookupdelete elements with 'step'
		  elements each.
 check map is empty, errono == ENOENT 
 SPDX-License-Identifier: GPL-2.0
 Copyright Intel Corp. 2018 
	
	  For the test version we need to poll the "hardware" in order
	  to get the updated status for unlock testing.
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2019 Intel Corporation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2019 Intel Corporation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2014-2016, Intel Corporation.
	
	  Limit dax to a single page at a time given vmalloc()-backed
	  in the nfit_test case.
	
	  If badblocks are present, limit known good range to the
	  requested range.
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 strong  override definition of nfit_intel_shutdown_status 
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2019 Intel Corporation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016, Intel Corporation.
 SPDX-License-Identifier: GPL-2.0
 Copyright(c) 2018 Intel Corporation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0
	
	  These kconfig symbols must be set to "m" for nfit_test to
	  load and operate.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright(c) 2013-2015 Intel Corporation. All rights reserved.
  Generate an NFIT table to describe the following topology:
  BUS0: Interleaved PMEM regions, and aliasing with BLK regions
                      (a)                       (b)            DIMM   BLK-REGION
            +----------+--------------+----------+---------+
  +------+  |  blk2.0  |     pm0.0    |  blk2.1  |  pm1.0  |    0      region2
  | imc0 +--+- - - - - region0 - - - -+----------+         +
  +--+---+  |  blk3.0  |     pm0.0    |  blk3.1  |  pm1.0  |    1      region3
     |      +----------+--------------v----------v         v
  +--+---+                            |                    |
  | cpu0 |                                    region1
  +--+---+                            |                    |
     |      +-------------------------^----------^         ^
  +--+---+  |                 blk4.0             |  pm1.0  |    2      region4
  | imc1 +--+-------------------------+----------+         +
  +------+  |                 blk5.0             |  pm1.0  |    3      region5
            +-------------------------+----------+-+-------+
  +--+---+
  | cpu1 |
  +--+---+                   (Hotplug DIMM)
     |      +----------------------------------------------+
  +--+---+  |                 blk6.0pm7.0                 |    4      region67
  | imc0 +--+----------------------------------------------+
  +------+
  ) In this layout we have four dimms and two memory controllers in one
     socket.  Each unique interface (BLK or PMEM) to DPA space
     is identified by a region device with a dynamically assigned id.
  ) The first portion of dimm0 and dimm1 are interleaved as REGION0.
     A single PMEM namespace "pm0.0" is created using half of the
     REGION0 SPA-range.  REGION0 spans dimm0 and dimm1.  PMEM namespace
     allocate from from the bottom of a region.  The unallocated
     portion of REGION0 aliases with REGION2 and REGION3.  That
     unallacted capacity is reclaimed as BLK namespaces ("blk2.0" and
     "blk3.0") starting at the base of each DIMM to offset (a) in those
     DIMMs.  "pm0.0", "blk2.0" and "blk3.0" are free-form readable
     names that can be assigned to a namespace.
  ) In the last portion of dimm0 and dimm1 we have an interleaved
     SPA range, REGION1, that spans those two dimms as well as dimm2
     and dimm3.  Some of REGION1 allocated to a PMEM namespace named
     "pm1.0" the rest is reclaimed in 4 BLK namespaces (for each
     dimm in the interleave set), "blk2.1", "blk3.1", "blk4.0", and
     "blk5.0".
  ) The portion of dimm2 and dimm3 that do not participate in the
     REGION1 interleaved SPA range (i.e. the DPA address below offset
     (b) are also included in the "blk4.0" and "blk5.0" namespaces.
     Note, that BLK namespaces need not be contiguous in DPA-space, and
     can consume aliased capacity from multiple interleave sets.
  BUS1: Legacy NVDIMM (single contiguous range)
   region2
  +---------------------+
  |---------------------|
  ||       pm2.0       ||
  |---------------------|
  +---------------------+
  ) A NFIT-table may describe a simple system-physical-address range
     with no BLK aliasing.  This type of region may optionally
     reference an NVDIMM.
 spa0 iset 
 spa1 iset  + 1 
 permit testing multiple NFITs per system 
 extended status, FW update in progress 
	
	  check offset + len > size of fw storage
	  check length is > max send length
 update already done, need activation 
 finish 
 set 1 second of time for firmware "update" 
 abort 
 successfully aborted status 
 bad control flag 
 sequencing error 
 bogus test version 
 we should never get here 
 for testing, only store up to n records that fit within 4k 
 skip entries outside the range 
	
	  last dimm is selected for test
 we do not erase master state passphrase ever 
	
	  Emulate 3 second activation max, and 1 second incremental
	  quiesce time per dimm requiring multiple activates to get all
	  DIMMs updated.
 lookup per-dimm data 
 for testing, only store up to n records that fit within 4k 
 until spa location cookie support is added... 
	
	  spa0 (interleave first half of dimm0 and dimm1, note storage
	  does not actually alias the related block-data-window
	  regions)
	
	  spa1 (interleave last half of the 4 DIMMS, note storage
	  does not actually alias the related block-data-window
	  regions)
 spa2 (dcr0) dimm0 
 spa3 (dcr1) dimm1 
 spa4 (dcr2) dimm2 
 spa5 (dcr3) dimm3 
 spa6 (bdw for dcr0) dimm0 
 spa7 (bdw for dcr1) dimm1 
 spa8 (bdw for dcr2) dimm2 
 spa9 (bdw for dcr3) dimm3 
 mem-region0 (spa0, dimm0) 
 mem-region1 (spa0, dimm1) 
 mem-region2 (spa1, dimm0) 
 mem-region3 (spa1, dimm1) 
 mem-region4 (spa1, dimm2) 
 mem-region5 (spa1, dimm3) 
 mem-region6 (spadcr0, dimm0) 
 mem-region7 (spadcr1, dimm1) 
 mem-region8 (spadcr2, dimm2) 
 mem-region9 (spadcr3, dimm3) 
 mem-region10 (spabdw0, dimm0) 
 mem-region11 (spabdw1, dimm1) 
 mem-region12 (spabdw2, dimm2) 
 mem-region13 (spadcr3, dimm3) 
 dcr-descriptor0: blk 
 dcr-descriptor1: blk 
 dcr-descriptor2: blk 
 dcr-descriptor3: blk 
 dcr-descriptor0: pmem 
 dcr-descriptor1: pmem 
 dcr-descriptor2: pmem 
 dcr-descriptor3: pmem 
 bdw0 (spadcr0, dimm0) 
 bdw1 (spadcr1, dimm1) 
 bdw2 (spadcr2, dimm2) 
 bdw3 (spadcr3, dimm3) 
 flush0 (dimm0) 
 flush1 (dimm1) 
 flush2 (dimm2) 
 flush3 (dimm3) 
 platform capabilities 
 dcr-descriptor4: blk 
 dcr-descriptor4: pmem 
 bdw4 (spadcr4, dimm4) 
 spa10 (dcr4) dimm4 
		
		  spa11 (single-dimm interleave for hotplug, note storage
		  does not actually alias the related block-data-window
		  regions)
 spa12 (bdw for dcr4) dimm4 
 mem-region14 (spadcr4, dimm4) 
 mem-region15 (spa11, dimm4) 
 mem-region16 (spabdw4, dimm4) 
 flush3 (dimm4) 
 sanity check to make sure we've filled the buffer 
 spa0 (flat range with no bdw aliasing) 
 virtual cd region 
 mem-region0 (spa0, dimm0) 
 dcr-descriptor0 
 dcr-descriptor1 
 sanity check to make sure we've filled the buffer 
 give us some some coverage of the arch_invalidate_pmem() API 
 basic checkout of a typical 'get config size' command 
 test ars_status with zero output 
 test ars_cap with benign extended status 
 test ars_status with 'status' trimmed from 'out_length' 
 test ars_status with 'Output (Size)' including 'status' 
 test extended status for get_config_size results in failure 
 test clear error 
 test firmware activate bus info 
 common alloc 
 pass ;
 pass ;
 per-nfit specific alloc 
 associate dimm devices with nfit_mem data for notification testing 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright(c) 2013-2015 Intel Corporation. All rights reserved.
 SPDX-License-Identifier: GPL-2.0-only
 bus 1 
 bus 2 
	 Failures for a DIMM can be injected using fail_cmd and
	  fail_cmd_code, see the device attributes below
 Each instance can be taken as a bus, which can have multiple dimms 
 SPDX-License-Identifier: GPL-2.0-only
  vsock_test - vsock.ko test suite
  Copyright (C) 2017 Red Hat, Inc.
  Author: Stefan Hajnoczi <stefanha@redhat.com>
 Wait for the server to be ready 
 Notify the server that the client has finished 
 Notify the client that the server is ready 
 Wait for the client to finish 
	 Wait for the remote to close the connection, before check
	  -EPIPE error on send.
	 Wait for the remote to close the connection, before check
	  -EPIPE error on send.
 With the standard socket sizes, VMCI is able to support about 100
  concurrent stream connections.
 Send several messages, one with MSG_EOR flag 
 SPDX-License-Identifier: GPL-2.0-only
  vsock_diag_test - vsock_diag.ko test suite
  Copyright (C) 2017 Red Hat, Inc.
  Author: Stefan Hajnoczi <stefanha@redhat.com>
 Per-socket status 
  Read vsock stats into a list.
 SPDX-License-Identifier: GPL-2.0-only
  vsock test utilities
  Copyright (C) 2017 Red Hat, Inc.
  Author: Stefan Hajnoczi <stefanha@redhat.com>
 Install signal handlers 
 Parse a CID in string representation 
 Wait for the remote to close the connection 
 Connect to <cid, port> and return the file descriptor. 
 Listen on <cid, port> and return the first incoming connection.  The remote
  address is stored to clientaddrp.  clientaddrp may be NULL.
 Transmit one byte and check the return value.
  expected_ret:
   <0 Negative errno (for testing errors)
    0 End-of-file
    1 Success
 Receive one byte and check the return value.
  expected_ret:
   <0 Negative errno (for testing errors)
    0 End-of-file
    1 Success
 Run test cases.  The program terminates if a failure occurs. 
		 Full barrier before executing the next test.  This
		  ensures that client and server are executing the
		  same test case.  In particular, it means whoever is
		  faster will not see the peer still executing the
		  last test.  This is important because port numbers
		  can be used by multiple test cases.
 SPDX-License-Identifier: GPL-2.0-only
 Timeout API for single-threaded programs that use blocking
  syscalls (readwritesendrecvconnectaccept).
  Copyright (C) 2017 Red Hat, Inc.
  Author: Stefan Hajnoczi <stefanha@redhat.com>
 Use the following pattern:
    timeout_begin(TIMEOUT);
    do {
        ret = accept(...);
        timeout_check("accept");
    } while (ret < 0 && ret == EINTR);
    timeout_end();
 SIGALRM handler function.  Do not use sleep(2), alarm(2), or
  setitimer(2) while using this API - they may interfere with each
  other.
 Start a timeout.  Call timeout_check() to verify that the timeout hasn't
  expired.  timeout_end() must be called to stop the timeout.  Timeouts cannot
  be nested.
 Exit with an error message if the timeout has expired 
 Stop a timeout 
 SPDX-License-Identifier: GPL-2.0-only
 Control socket for clientserver test execution
  Copyright (C) 2017 Red Hat, Inc.
  Author: Stefan Hajnoczi <stefanha@redhat.com>
 The client and server may need to coordinate to avoid race conditions like
  the client attempting to connect to a socket that the server is not
  listening on yet.  The control socket offers a communications channel for
  such coordination tasks.
  If the client calls control_expectln("LISTENING"), then it will block until
  the server calls control_writeln("LISTENING").  This provides a simple
  mechanism for coordinating between the client and the server.
 Open the control socket, either in server or client mode 
 Free resources 
 Write a line to the control socket 
 Return the next line from the control socket (without the trailing newline).
  The program terminates if a timeout occurs.
  The caller must free() the returned string.
 Wait until a given line is received or a timeout occurs 
 SPDX-License-Identifier: GPL-2.0-or-later
  tmon.c Thermal Monitor (TMON) main function and entry point
  Copyright (C) 2012 Intel Corporation. All rights reserved.
  Author: Jacob Pan <jacob.jun.pan@linux.intel.com>
 seconds 
unsigned long no_control = 1;  monitoring only or use cooling device for
			        temperature control.
 can be select by tui later 
 for recording thermal data to a file 
cooling device used for the PID controller 
 user selected target zone instance 
 relax control knobs, undo throttling 
 open local data log file 
 The log file must be a regular file owned by us 
 size of long + 1 
 controller output 
	 validate range of user selected target zone, default to the first
	  instance if out of range
 fork 
 kill parent 
 disable TUI, it may not be necessary, but saves some resource 
 change the file mode mask 
 new SID for the daemon process 
 change working directory 
 SPDX-License-Identifier: GPL-2.0-or-later
  tui.c ncurses text user interface for TMON program
  Copyright (C) 2013 Intel Corporation. All rights reserved.
  Author: Jacob Pan <jacob.jun.pan@linux.intel.com>
 one row for tz name, one for trip points 
 daemon mode flag (set by startup parameter -d) 
 must delete panels before their attached windows 
 wrap at 5 
  list cooling devices + "set temp" entry; wraps after 5 rows, if they fit
 2 lines for border 
	 two lines to show borders, one line per tz show trip point position
	  and value.
	  dialogue window is a pop-up, when needed it lays on top of cdev win
	 prepare panels for dialogue, if panel already created then we must
	  be doing resizing, so just replace windows with new ones, old ones
	  should have been deleted by close_window
 Set up the user pointer to the next panel
 start over when term gets resized, but first we clean up 
 get the new screen size 
 rate limit 
		 draw cooling device list on the left in the order of
		  cooling device instances. skip unused idr.
 show cdev binding, y is the global cooling device instance 
 draw a column of spaces to separate thermal zones 
				int k = 0;  per zone trip point id that
					     binded to this cdev, one to
					     many possible based on the
					     binding bitmask.
 draw each trip binding for the cdev 
 draw '' to show binding 
	 draw border after data so that border will not be messed up
	  even there is not enough space for all the data to be shown
 Silence compiler 'unused' warnings 
 list all the available tunables 
 save last choice for target temp 
 print legend at the bottom line 
 draw border last such that everything is within boundary 
 enable keyboard mapping 
 tell curses not to do NL->CRNL on output 
 take input chars one at a time 
 dont echo input 
 turn off cursor 
		 when term size is too small, no dialogue panels are set.
		  we need to filter out such cases.
 top panel filter 
 TAB 
 force refresh 
 make gcc happy 
 draw a horizontal bar in given pattern 
 fill a string with trip point type and value in one line
  e.g.      P(56)    C(106)
  maintain the distance one degree per char
 draw a line as ruler 
 y at tz temp data line 
 fill trip points for each tzone 
 draw trip point from low to high for each tz 
 loop through all trip points 
			 reverse the order here since trips are sorted
			  in ascending order in terms of temperature.
 SPDX-License-Identifier: GPL-2.0-or-later
  pid.c PID controller for testing cooling devices
  Copyright (C) 2012 Intel Corporation. All rights reserved.
  Author Name Jacob Pan <jacob.jun.pan@linux.intel.com>
  PID (Proportional-Integral-Derivative) controller is commonly used in
  linear control system, consider the the process.
  G(s) = U(s)E(s)
  kp = proportional gain
  ki = integral gain
  kd = derivative gain
  Ts
  We use type C Alan Bradley equation which takes set point off the
  output dependency in P and D term.
    y[k] = y[k-1] - kp(x[k] - x[k-1]) + KiTse[k] - Kd(x[k]
           - 2x[k-1]+x[k-2])Ts
 cached data from previous loop 
 input temperature x[k-#] 
  TODO: make PID parameters tuned automatically,
  1. use CPU burn to produce open loop unit step response
  2. calculate PID based on Ziegler-Nichols rule
  add a flag for tuning PID
 init pid params 
 TODO: get it from TUI tuning tab 
 TODO: relax control data when not over thermal limit 
 To be called at time interval Ts. Type C PID controller.
     y[k] = y[k-1] - kp(x[k] - x[k-1]) + KiTse[k] - Kd(x[k]
           - 2x[k-1]+x[k-2])Ts
  TODO: add low pass filter for D term
 error 
 compute intermediate PID terms 
 compute output 
 update sample data 
 clamp output adjustment range 
 SPDX-License-Identifier: GPL-2.0-or-later
  sysfs.c sysfs ABI access functions for TMON program
  Copyright (C) 2013 Intel Corporation. All rights reserved.
  Author: Jacob Pan <jacob.jun.pan@linux.intel.com>
 history of thermal data, used for control algo 
 index to the trec array 
 get states of the cooling device instance 
 scan and fill in trip point info for a thermal zone and trip point id 
 check trip point type 
 TODO: check attribute 
 return instance id for file format such as trip_point_4_temp 
 Find trip point info of a thermal zone 
		 check if trip point temp is non-zero
		  ignore 0invalid trip points
 found a valid trip point 
 check cooling devices for binding info. 
 find the link to real cooling device record binding 
			 find the trip point in which the cdev is binded to
			  in this tzone
			 validate trip point range, e.g. trip could return -1
			  when passive is enabled
  Before calling scan_tzones, thermal sysfs must be probed to determine
  the number of thermal zones and cooling devices.
  We loop through each thermal zone and fill in tz_info struct, i.e.
  ptdata.tzi[]
root@jacob-chiefriver:~# tree -d sysclassthermalthermal_zone0
sysclassthermalthermal_zone0
|-- cdev0 -> ..cooling_device4
|-- cdev1 -> ..cooling_device3
|-- cdev10 -> ..cooling_device7
|-- cdev11 -> ..cooling_device6
|-- cdev12 -> ..cooling_device5
|-- cdev2 -> ..cooling_device2
|-- cdev3 -> ..cooling_device1
|-- cdev4 -> ..cooling_device0
|-- cdev5 -> ..cooling_device12
|-- cdev6 -> ..cooling_device11
|-- cdev7 -> ..cooling_device10
|-- cdev8 -> ..cooling_device9
|-- cdev9 -> ..cooling_device8
|-- device -> ......LNXSYSTM:00device:62LNXTHERM:00
|-- power
`-- subsystem -> ........classthermal
 keep track of valid tzones 
 detect trip points and cdev attached to this tzone 
 index for cdev 
 increment cdev index 
TODO: reverse trip points 
			 there is a gap in cooling device id, check again
			  for the same index.
 detect number of thermal zones and cooling devices 
				 keep track of the max cooling device since
				  there may be gaps.
 we still show thermal zone information if there is no cdev 
 now probe tzones 
 convert sysfs zone instance to zone array index 
 read temperature of all thermal zones 
 circular buffer for keeping historic data 
 set all ctrl cdev to the same state 
 scale to percentage of max_state 
	 TODO: take average of all ctrl types. also consider change based on
	  uevent. Take the first reading for now.
  perf.c
  Performance analysis utility.
  This is the main hub from which the sub-commands (perf stat,
  perf top, perf record, perf report, etc.) are started.
 page_size
 usage()
 returns 0 for "no pager", 1 for "use pager", and -1 for "not specified" 
  returns 0 for "no tui", 1 for "use tui", 2 for "use gtk",
  and -1 for "not specified"
 setup_pager(); 
		
		  For legacy reasons, the "version" and "help"
		  commands can be written with "--" prepended
		  to make them look like flags.
		
		  Shortcut for '-h' and '-v' options to invoke help
		  and version command.
		
		  Check remaining flags.
 Somebody closed stdout? 
 Ignore write errors for pipes and sockets.. 
 Check for ENOSPC and EIO errors.. 
 Turn "perf cmd --help" into "perf help cmd" 
	
	  argv[0] must be the perf command, but the argv array
	  belongs to the caller, and may be reused in
	  subsequent loop iterations. Save argv[0] and
	  restore it on error.
	
	  if we fail because the command is not found, it is
	  OK to return. Otherwise, we just pass along the status code.
 as if we called execvp 
 See if it's an internal command 
 .. then try the external ones 
 libsubcmd init 
 Setting $PERF_CONFIG makes perf read _only_ the given config file. 
	
	  "perf-xxxx" is the same as "perf xxxx", but we obviously:
	 
	   - cannot take flags in between the "perf" and the "xxxx".
	   - cannot execute it externally (since it would just do
	     the same thing over again)
	 
	  So we just directly call the internal command handler. If that one
	  fails to handle this, then maybe we just run a renamed perf binary
	  that contains a dash in its name. To handle this scenario, we just
	  fall through and ignore the "xxxx" part of the command string.
		
		  If the command is handled, the above function does not
		  return undo changes and fall through in such a case.
 Look for flags.. 
 The user didn't specify a command; give them help 
	
	  We use PATH to find perf commands, but we prepend some higher
	  precedence paths: the "--exec-path" option, the PERF_EXEC_PATH
	  environment, and the $(perfexecdir) from the Makefile at build
	  time.
	
	  Block SIGWINCH notifications so that the thread that wants it can
	  unblock and get syscalls like select interrupted instead of waiting
	  forever while the signal goes to some other non interested thread.
 SPDX-License-Identifier: GPL-2.0
  builtin-buildid-cache.c
  Builtin buildid-cache command: Manages build-id cache
  Copyright (C) 2010, Red Hat Inc.
  Copyright (C) 2010, Arnaldo Carvalho de Melo <acme@redhat.com>
 Remove YYYYmmddHHMMSShh directory 
 Try to remove buildid directory 
 Try to remove [kernel.kcore] directory 
 -l is exclusive. It can not be used with other options. 
  builtin-trace.c
  Builtin 'trace' command:
  Display a continuously updated trace of any workload, CPU, specific PID,
  system wide, etc.  Default format is loosely strace like, but any other
  event may be specified using --event.
  Copyright (C) 2012, 2013, 2014, 2015 Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
  Initially based on the 'trace' prototype by Thomas Gleixner:
  http:lwn.netArticles415728 ("Announcing a new utility: 'trace'")
  strtoul: Go from a string to a value, i.e. for msr: MSR_FS_BASE to 0xc0000100
 for arrays
 per syscall BPF_MAP_TYPE_PROG_ARRAY
  The evsel->priv as used by 'perf trace'
  sc:	for raw_syscalls:sys_{enter,exit} and syscalls:sys_{enter,exit}_SYSCALLNAME
  fmt: for all the other tracepoints
  Used with raw_syscalls:sys_{enter,exit} and with the
  syscalls:sys_{enter,exit}_SYSCALL tracepoints
  Used with all the other tracepoints.
 older kernel (e.g., RHEL6) use syscalls:{enter,exit} 
 %s??? ", sa->prefix);
 %s??? ", sa->prefix);
 %s??? ", sas->entries[0]->prefix);
 XXX Hey, maybe for sched:sched_switch prevnext comm fields we can
     fill missing comms using thread__set_comm()...
     here or in a special syscall_arg__scnprintf_pid_sched_tp...
 0 
 mode  }, }, },
 code  },
 arg2  }, }, },
 fd  },
 umyaddr  },
 addrlen  }, }, },
 brk  }, }, },
 fd  }, }, },
 fd  },
 servaddr  },
 addrlen  }, }, },
 flags  }, }, },
 fd  }, }, },
 fd  }, }, },
 cmd 
 arg  }, }, },
 cmd  }, }, },
 attr_flags  }, }, },
 dfd  },
 path  },
 flags  }, }, },
 op  },
 val3  }, }, },
 fd  }, }, },
 flags  }, }, },
  FIXME: Make this available to all arches.
 cmd  },
 arg  }, }, },
 arg  }, }, },
 sig  }, }, },
 fd  }, }, },
 start  },
 behavior  }, }, },
 fd  }, }, },
 fd  }, }, },
 The standard mmap maps to old_mmap on s390x 
 prot  },
 flags 
 offset  }, }, },
 dev_name  },
 flags 
 flags  }, }, },
 from_dfd  },
 from_pathname  },
 to_dfd  },
 to_pathname  },
 flags  }, }, },
 start  },
 prot  }, }, },
 u_name  }, }, },
 flags  }, }, },
 dfd  }, }, },
 dfd  }, }, },
 flags  }, }, },
 dfd  },
 flags  }, }, },
 dfd  },
 flags  }, }, },
 cpu  },
 group_fd  },
 flags  }, }, },
 flags  }, }, },
 access_rights  }, }, },
 key  }, }, },
 start  },
 prot  },
 pkey  }, }, },
 option 
 arg2  },
 arg3  }, }, },
 dfd  }, }, },
 flags  }, }, },
 flags  }, }, },
 flags  }, }, },
 olddirfd  },
 newdirfd  }, }, },
 olddirfd  },
 newdirfd  },
 flags  }, }, },
 sig  }, }, },
 sig  }, }, },
 sig  }, }, },
 policy  }, }, },
 op  },
 flags  }, }, },
 flags  }, }, },
 flags  }, }, },
 flags  },
 addr  }, }, },
 type  },
 protocol  }, }, },
 type  },
 protocol  }, }, },
 fdat  },
 flags  } ,
 mask  }, }, },
 specialfile  }, }, },
 specialfile  }, }, },
 dfd  }, }, },
 flags  }, }, },
 sig  }, }, },
 sig  }, }, },
 name  }, }, },
 dfd  }, }, },
 dirfd  }, }, },
 options  }, }, },
 options  }, }, },
  is_exit: is this "exit" or "exit_group"?
  is_open: is this "open" or "openat"? To associate the fd returned in sys_exit with the pathname in sys_enter.
  args_size: sum of the sizes of the syscall arguments, anything after that is augmented stuff: pathname for openat, etc.
  nonexistent: Just a hole in the syscall table, syscall id not allocated
  Must match what is in the BPF program:
  toolsperfexamplesbpfaugmented_raw_syscalls.c
  We need to have this 'calculated' boolean because in some cases we really
  don't know what is the duration of a syscall, for instance, when we start
  a session and some threads are waiting for a syscall to finish, say 'poll',
  in which case all we can do is to print "( ? ) for duration and for the
  start timestamp.
  filename.ptr: The filename char pointer that will be vfs_getname'd
  filename.entry_str_pos: Where to insert the string translated from
                          filename.ptr by the vfs_getname tracepointkprobe.
  ret_scnprintf: syscall args may set this to a different syscall return
                 formatter, for instance, fcntl may return fds, file flags, etc.
	
	  So that the next arg with a payload can consume its augmented arg, i.e. for rename syscalls
	  we would have two strings, each prefixed by its size.
  We're handling tstamp=0 as an undefined tstamp, i.e. like when we are
  using ttrace->entry_time for a thread that receives a sys_exit without
  first having received a sys_enter ("poll" issued before tracing session
  starts, lost sys_enter exit due to ring buffer overflow).
			
			  syskerneltracingeventssyscallssys_enter
			  egrep 'field:.fd;' ...format|sed -r 's.field:([a-z ]+) [a-z_]fd.+\1g'|sort|uniq -c
			  65 int
			  23 unsigned int
			  7 unsigned long
 When using libaudit we don't know beforehand what is the max syscall id
 Need to memset from offset 0 and +1 members if brand new
	
	  We need to check and discard the first variable '__syscall_nr'
	  or 'nr' that mean the syscall number. It is needless here.
	  So drop '__syscall_nr' or 'nr' field but does not exist on older kernels.
  args is to be interpreted as a series of longs but we need to handle
  8-byte unaligned accesses. args points to raw_data within the event
  and raw_data is guaranteed to be 8-byte unaligned because it is
  preceded by raw_size which is a u32. So we need to copy args to a temp
  variable to read it. Most notably this avoids extended load instructions
  on unaligned addresses
  Check if the value is in fact zero, i.e. mask whatever needs masking, such
  as mount 'flags' argument that needs ignoring some magic flag, see comment
  in toolsperftracebeautymount_flags.c
	
	  Things like fcntl will set this in its 'cmd' formatter to pick the
	  right formatter for the return value (an fd? file flags?), which is
	  not needed for syscalls that always return a given type, say an fd.
			
			  Some syscall args need some mask, most don't and
			  return val untouched.
			
 			  Suppress this argument if its value is zero and
 			  and we don't have a string associated in an
 			  strarray for it.
		
		  If we managed to read the tracepoint format file, then we
		  may end up not having any args, like with gettid(), so only
		  print the raw args when we didn't manage to read it.
		
		  XXX: Noticed on x86_64, reproduced as far back as 3.0.36, haven't tried
		  before that, leaving at a higher verbosity level till that is
		  explained. Reproduced with plain ftrace with:
		 
		  echo 1 > teventsraw_syscallssys_exitenable
		  grep "NR -1 " ttrace_pipe
		 
		  After generating some load on the machine.
		
		  With libaudit we don't know beforehand what is the max_id,
		  so we let trace__read_syscall_info() figure that out as we
		  go on reading syscalls.
	
	  For now with BPF raw_augmented we hook into raw_syscalls:sys_enter
	  and there we get all 6 syscall args plus the tracepoint common fields
	  that gets calculated at the start and the syscall_nr (another long).
	  So we check if that is the case and if so don't look after the
	  sc->args_size but always after the full raw_syscalls:sys_enter payload,
	  which is fixed.
	 
	  We'll revisit this later to pass s->args_size to the BPF augmenter
	  (now toolsperfexamplesbpfaugmented_raw_syscalls.c, so that it
	  copies only what we need for each syscall, like what happens when we
	  use syscalls:sys_enter_NAME, so that we reduce the kerneluserspace
	  traffic to just what is needed for each syscall.
	
	  If this is raw_syscalls.sys_enter, then it always comes with the 6 possible
	  arguments, even if the syscall being handled, say "openat", uses only 4 arguments
	  this breaks syscall__augmented_args() check for augmented args, as we calculate
	  syscall->args_size using each syscalls:sys_enter_NAME tracefs format file,
	  so when handling, say the openat syscall, we end up getting 6 args for the
	  raw_syscalls:sys_enter event, when we expected just 4, we end up mistakenly
	  thinking that the extra 2 u64 args are the augmented filename, so just check
	  here and avoid using augmented syscalls when the evsel is the raw_syscalls one.
 See trace__vfs_getname & trace__sys_exit 
	
	  We need to get ttrace just to make sure it is there when syscall__scnprintf_args()
	  and the rest of the beautifiers accessing it via struct syscall_arg touches it.
 TODO: user-configurable print_opts 
 the closing ')' 
	
	  We only consider an 'event' for the sake of --max-events a non-filtered
	  sys_enter + sys_exit and other tracepoint events.
 \0 
 \0 
		
		  Some syscall args need some mask, most don't and
		  return val untouched.
		
		  Suppress this argument if its value is zero and
		  and we don't have a string associated in an
		  strarray for it.
		
		  XXX Perhaps we should have a show_tp_arg_names,
		  leaving show_arg_names just for syscalls?
	
	  Check if we called perf_evsel__disable(evsel) due to, for instance,
	  this event's max_events having been hit and this is an entry coming
	  from the ring buffer that we should discard, since the max events
	  have already been consideredprinted.
		
		  XXX: Not having the associated syscall info or not findingadding
		  	the thread should never happen, but if it does...
		  	fall thru and print it as a bpf_output event.
	
	  BPF events were not setting PERF_SAMPLE_TIME, so be more robust
	  and don't use sample->time unconditionally, we may end up having
	  some other event in the future without PERF_SAMPLE_TIME for good
	  reason, i.e. we may not be interested in its timestamps, just in
	  it taking place, picking some piece of information when it
	  appears in our event stream (vfs_getname comes to mind).
 +3 is for the event string below and the pid filter 
 event string may be different for older kernels - e.g., RHEL6 
		
		  We're interested only in the user space callchain
		  leading to the syscall, allow overriding that for
		  debugging reasons using --kernel_syscall_callchains
 Should be set like strace -s strsize 
	
	  We're only interested in syscalls that have a pointer:
 The candidate just doesn't copies our pointer arg, might copy other pointers we want.
 The candidate might copy a pointer we don't have, skip it.
		
		  Check if the tentative pair syscall augmenter has more pointers, if it has,
		  then it may be collecting that and we then can't use it, as it would collect
		  more than what is common to the two syscalls.
		
		  If the pair isn't enabled, then its bpf_prog.sys_enter will not
		  have been searched for, so search it here and if it returns the
		  unaugmented one, then ignore it, otherwise we'll reuse that BPF
		  program for a filtered syscall on a non-filtered one.
		 
		  For instance, we have "!syscalls:sys_enter_renameat" and that is
		  useful for "renameat2".
 It'll get at least the "!raw_syscalls:unaugmented"
	
	  Now lets do a second pass looking for enabled syscalls without
	  an augmenter that have a signature that is a superset of another
	  syscall with an augmenter so that we can auto-reuse it.
	 
	  I.e. if we have an augmenter for the "open" syscall that has
	  this signature:
	 
	    int open(const char pathname, int flags, mode_t mode);
	 
	  I.e. that will collect just the first string argument, then we
	  can reuse it for the 'creat' syscall, that has this signature:
	 
	    int creat(const char pathname, mode_t mode);
	 
	  and for:
	 
	    int stat(const char pathname, struct stat statbuf);
	    int lstat(const char pathname, struct stat statbuf);
	 
	  Because the 'open' augmenter will collect the first arg as a string,
	  and leave alone all the other args, which already helps with
	  beautifying 'stat' and 'lstat''s pathname arg.
	 
	  Then, in time, when 'stat' gets an augmenter that collects both
	  first and second arg (this one on the raw_syscalls:sys_exit prog
	  array tail call, then that one will be used.
		
		  For now we're just reusing the sys_enter prog, and if it
		  already has an augmenter, we don't need to find one.
		
		  Look at all the other syscalls for one that has a signature
		  that is close enough that we can share:
		
		  Update the BPF_MAP_TYPE_PROG_SHARED for raw_syscalls:sys_enter
		  with the fd for the program we're reusing:
 HAVE_LIBBPF_SUPPORT
 HAVE_LIBBPF_SUPPORT
	
	  Better not use !target__has_task() here because we need to cover the
	  case where no threads were specified in the command line, but a
	  workload was, and in that case we will fill in the thread_map when
	  we fork the workload in evlist__prepare_workload.
 Is there some thing to flush.. 
				
				  Bail out, can't find the name of the argument that is being
				  used in the filter, let it try to set this filter, will fail later.
	
	  If a global cgroup was set, apply it to all the events without an
	  explicit cgroup. I.e.:
	 
	  	trace -G A -e sched:switch
	 
	  Will set all raw_syscalls:sys_{enter,exit}, pgfault, vfs_getname, etc
	  _and_ sched:sched_switch to the 'A' cgroup, while:
	 
	  trace -e sched:switch -G A
	 
	  will only set the sched:sched_switch event to the 'A' cgroup, all the
	  other events (raw_syscalls:sys_{enter,exit}, etc are left "without"
	  a cgroup (on the root cgroup, sys wide, etc).
	 
	  Multiple cgroups:
	 
	  trace -G A -e sched:switch -G B
	 
	  the syscall ones go to the 'A' cgroup, the sched:sched_switch goes
	  to the 'B' cgroup.
	 
	  evlist__set_default_cgroup() grabs a reference of the passed cgroup
	  only for the evsels still without a cgroup, i.e. evsel->cgroup == NULL.
	
	  If the "close" syscall is not traced, then we will not have the
	  opportunity to, in syscall_arg__scnprintf_close_fd() invalidate the
	  fd->pathname table and were ending up showing the last value set by
	  syscalls opening a pathname and associating it with a descriptor or
	  reading it from procpidfd in cases where that doesn't make
	  sense.
	 
	   So just disable this beautifier (SCA_FD, SCA_FDAT) when 'close' is
	   not in use.
	
	  Now that we already used evsel->core.attr to ask the kernel to setup the
	  events, lets reuse evsel->core.attr.sample_max_stack as the limit in
	  trace__resolve_callchain(), allowing per-event max-stack settings
	  to override an explicitly set --max-stack global setting.
 add tid to output 
 older kernels have syscalls tp versus raw_syscalls 
	
	  FIXME: introduce a intarray class, plain parse csv and create a
	  { int nr, int entries[] } struct...
  XXX: Hackish, just splitting the combined -e+--event (syscalls
  (raw_syscalls:{sys_{enter,exit}} + events (tracepoints, HW, SW, etc) to use
  existing facilities unchanged (trace->ev_qualifier + parse_options()).
  It'd be better to introduce a parse_options() variant that would return a
  list with the terms it didn't match to an event...
	
	  Parsing .perfconfig may entail creating a BPF event, that may need
	  to create BPF maps, so bump RLIM_MEMLOCK as the default 64K setting
	  is too small. This affects just this process, not touching the
	  global setting. If it fails we'll get something in 'perf trace -v'
	  to help diagnose the problem.
	
	  Here we already passed thru trace__parse_events_option() and it has
	  already figured out if -e syscall_name, if not but if --event
	  foo:bar was used, the user is interested _just_ in those, say,
	  tracepoint events, not in the strace-like syscall-name-based mode.
	 
	  This is important because we need to check if strace-like mode is
	  needed to decided if we should filter out the eBPF
	  __augmented_syscalls__ code, if it is in the mix, say, via
	  .perfconfig trace.add_events, and filter those out.
 Was --events used? ) {
	
	  Now that we have --verbose figured out, lets see if we need to parse
	  events from .perfconfig, so that if those events fail parsing, say some
	  BPF program fails, then we'll be able to use --verbose to see what went
	  wrong in more detail.
		
		  If we have _just_ the augmenter event but don't have a
		  explicit --syscalls, then assume we want all strace-like
		  syscalls:
		
		  So, if we have a syscall augmenter, but trace_syscalls, aka
		  strace-like syscall tracing is not set, then we need to trow
		  away the augmenter, i.e. all the events that were created
		  from that BPF object file.
		 
		  This is more to fix the current .perfconfig trace.add_events
		  style of setting up the strace-like eBPF based syscall point
		  payload augmenter.
		 
		  All this complexity will be avoided by adding an alternative
		  to trace.add_events in the form of
		  trace.bpf_augmented_syscalls, that will be only parsed if we
		  need it.
		 
		  .perfconfig trace.add_events is still useful if we want, for
		  instance, have msr_write.msr in some .perfconfig profile based
		  'perf trace --config determinism.profile' mode, where for some
		  particular goalworkload type we want a set of events and
		  output mode (with timings, etc) instead of having to add
		  all via the command line.
		 
		  Also --config to specify an alternate .perfconfig file needs
		  to be implemented.
	
	  If we are augmenting syscalls, then combine what we put in the
	  __augmented_syscalls__ BPF map with what is in the
	  syscalls:sys_exit_FOO tracepoints, i.e. just like we do without BPF,
	  combining raw_syscalls:sys_enter with raw_syscalls:sys_exit.
	 
	  We'll switch to look at two BPF maps, one for sys_enter and the
	  other for sys_exit when we start augmenting the sys_exit paths with
	  buffers that are being copied from kernel to userspace, think 'read'
	  syscall.
				
				  Augmented is __augmented_syscalls__ BPF_OUTPUT event
				  Above we made sure we can get from the payload the tp fields
				  that we get from syscalls:sys_enter tracefs format file.
				
				  Now we do the same for the syscalls:sys_enter event so that
				  if we handle it directly, i.e. if the BPF prog returns 0 so
				  as not to filter it, then we'll handle it just like we would
				  for the BPF_OUTPUT one:
				
				  For now with BPF raw_augmented we hook into
				  raw_syscalls:sys_enter and there we get all
				  6 syscall args plus the tracepoint common
				  fields and the syscall_nr (another long).
				  So we check if that is the case and if so
				  don't look after the sc->args_size but
				  always after the full raw_syscalls:sys_enter
				  payload, which is fixed.
				 
				  We'll revisit this later to pass
				  s->args_size to the BPF augmenter (now
				  toolsperfexamplesbpfaugmented_raw_syscalls.c,
				  so that it copies only what we need for each
				  syscall, like what happens when we use
				  syscalls:sys_enter_NAME, so that we reduce
				  the kerneluserspace traffic to just what is
				  needed for each syscall.
 Using just --errno-summary will trigger --summary 
 summary_only implies summary option, but don't overwrite summary if set 
 SPDX-License-Identifier: GPL-2.0
 max number of arguments 
	
	  Save the allocated event name strings.
	
	  The load and store operations are required, use the event
	  PERF_MEM_EVENTS__LOAD_STORE if it is supported.
 Only enable memory event 
	
	  there is no weight (cost) associated with stores, so don't print
	  the column
 display number of samples 
 str may be NULL in case no arg is passed to -t 
 because str is read-only 
 reset mode 
		
		  default to both load an store sampling
 SPDX-License-Identifier: GPL-2.0
 for struct evsel_str_handler
 based on kernellockdep.c 
 used for sorting 
	
	  FIXME: evsel__intval() returns u64,
	  so address of lockdep_map should be treated as 64bit.
	  Is there more better solution?
 address of lockdep_map, used as ID 
 for strcpy(), we cannot use const 
 these times are in nano sec. 
 flag of blacklist 
  States of lock_seq_stat
  UNINITIALIZED is required for detecting first event of acquire.
  As the nature of lock events, there is no guarantee
  that the first event for the locks are acquire,
  it can be acquired, contended or release.
 initial state 
  MAX_LOCK_DEPTH
  Imported from includelinuxsched.h.
  Should this be synchronized?
  struct lock_seq_stat:
  Place to put on state of one lock sequence
  1) acquire -> acquired -> release
  2) acquire -> contended -> acquired -> release
  3) acquire (with read or try) -> release
  4) Are there other patterns?
 build simple key function one is bigger than two 
	
	  name: the value for specify by user
	  this should be simpler than raw name of member
	  e.g. nr_acquired -> acquired, wait_time_total -> wait_total
 place to store sorted data 
 extra comparisons much complicated should be here 
 returns left most element of result, and erase it 
 broken lock sequence, discard it 
 orphan event, do nothing 
 broken lock sequence, discard it 
 orphan event, do nothing 
 broken lock sequence, discard it 
 broken lock sequence, discard it 
 lock oriented handlers 
 TODO: handlers for CPU oriented, thread oriented 
 Output for debug, this have to be removed 
 TODO: various way to print, coloring, nano or milli sec 
 output raw name 
 cut off name for saving output style 
 CONFIG_LOCKDEP 
 CONFIG_LOCKDEP, CONFIG_LOCK_STAT 
 CONFIG_LOCKDEP, CONFIG_LOCK_STAT 
 CONFIG_LOCKDEP 
 used for info subcommand 
 factor of 2 is for -e in front of each tracepoint 
 TODO: type 
 Aliased to 'perf script' 
 recycling report_lock_ops 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 for backward compatibility 
 filters for controlling start and stop of time of analysis 
  Find first non-memory allocation function from callchain.
  The allocation functions are in the 'alloc_func_list'.
 found 
 see includetraceeventsmmflags.h 
	
	  This is to find the current page (with correct gfp flags and
	  migrate type) at free event.
 skip sample based on time? 
 slab allocator 
 page allocator 
 slab sort keys 
 page sort keys 
 for internal use to find free'd page 
 for internal use to find free'd page 
 for -g 
 SPDX-License-Identifier: GPL-2.0
  This is rewrite of original c2c tool introduced in here:
    http:lwn.netArticles588866
  The original tool was changed to fit in current perf state.
  Original authors:
    Don Zickus <dzickus@redhat.com>
    Dick Fowles <fowles@inreach.com>
    Joe Mario <jmario@redhat.com>
	
	  must be at the end,
	  because of its callchain dynamic entry
 Shared cache line stats 
	
	  The mi object is released in hists__add_entry_ops,
	  if it gets sorted out into existing data, so we need
	  to take the copy now.
		
		  There's already been warning about missing
		  sample's cpu value. Let's account all to
		  node 0 in this case, without any further
		  warning.
		 
		  Doing node stats only for single callchain data.
 Use the last line from sort_entry if not defined. 
 copy sort keys to output fields 
	
	  We dont need other sorting keys other than those
	  we already specified. It also really slows down
	  the processing a lot with big number of output
	  fields, so switching this off for c2c.
 and then copy output fields to sort keys 
	
	  Initialize only with sort fields, we need to resort
	  later anyway, and that's where we add output fields
	  as well.
 Overload number of header lines.
 It's a valid entry if contains stores 
 empty node, skip 
 Display compact version first. 
 reset abort key so that it can get Ctrl-C as a key 
 reset abort key so that it can get Ctrl-C as a key 
 HAVE_SLANG_SUPPORT 
 Fix the zero line for dcacheline column. 
 Fix the zero line for offset column. 
	
	  --no-call-graph
 Only enable memory event 
 No pipe support at the moment. 
 max number of arguments 
		
		  The load and store operations are required, use the event
		  PERF_MEM_EVENTS__LOAD_STORE if it is supported.
 SPDX-License-Identifier: GPL-2.0
  builtin-record.c
  Builtin record command: Record the profile of a workload
  (or a CPU, or a PID) into the perf.data output file - for
  later analysis via perf report.
 = 0: unlimited 
		
		  md->refcount is incremented in record__aio_pushfn() for
		  every aio write request started in record__aio_push() so
		  decrement it because the request is now complete.
		
		  aio write request may require restart with the
		  reminder if the kernel didn't write whole
		  chunk at once.
 1ms 
				
				  Started aio write is not complete yet
				  so it has to be waited before the
				  next allocation.
	
	  map->core.base data pointed by buf is copied into free map->aio.data[] buffer
	  to release space in the kernel buffer as fast as possible, calling
	  perf_mmap__consume() from perf_mmap__push() function.
	 
	  That lets the kernel to proceed with storing more profiling data into
	  the kernel buffer earlier than other per-cpu kernel buffers are handled.
	 
	  Coping can be done in two steps in case the chunk of profiling data
	  crosses the upper bound of the kernel buffer. In this case we first move
	  part of data from map->start till the upper bound and then the reminder
	  from the beginning of the kernel buffer till the end of the data chunk.
		
		  Increment map->refcount to guard map->aio.data[] buffer
		  from premature deallocation because map object can be
		  released earlier than aio write request started on
		  map->aio.data[] buffer is complete.
		 
		  perf_mmap__put() is done at record__aio_complete()
		  after started aio request completion or at record__aio_push()
		  if the request failed to start.
	
	  Call record__aio_sync() to wait till map->aio.data[] buffer
	  becomes available after previous aio write operation.
 ret > 0 - no data, ret < 0 - error 
		
		  Decrement map->refcount incremented in record__aio_pushfn()
		  back if record__aio_write() operation failed to start, otherwise
		  map->refcount is decremented in record__aio_complete() after
		  aio write operation finishes successfully.
 HAVE_AIO_SUPPORT 
	
	  It is possible for this signal handler to run after done is checked
	  in the main loop, but before the perf counter fds are polled. If this
	  happens, the poll() will continue to wait even though done is set,
	  and will only break out if either another signal is received, or the
	  counters are ready for read. To ensure the poll() doesn't sleep when
	  done is set, use an eventfd (done_fd) to wake up the poll().
 HAVE_EVENTFD_SUPPORT
 event.auxtrace.size includes padding, see __auxtrace_mmap__read() 
 Nothing to do if text poke is already configured 
 Text poke must be collected on all CPUs 
	
	  For initial_delay, system wide or a hybrid system, we need to add a
	  dummy event so that we can track PERF_RECORD_MMAP to cover the delay
	  of waiting or event synthesis.
 Set up dummy event. 
		
		  Enable the dummy event when the process is forked for
		  initial_delay, immediately for system wide.
	
	  During this process, it'll load kernel map and replace the
	  dso->long_name to a real pathname it found.  In this case
	  we prefer the vmlinux path like
	    libmodules3.16.4buildvmlinux
	 
	  rather than build-id path (in debug directory).
	    $HOME.debug.build-idf06e17aa50adf4d00b88925e03775de107611551
	
	  If --buildid-all is given, it marks all DSO regardless of hits,
	  so no need to process samples. But if timestamp_boundary is enabled,
	  it still needs to walk on all samples to get the timestamps of
	  firstlast samples.
	
	 As for guest kernel when processing subcommand record&report,
	 we arrange module mmap prior to guest kernel mmap and trigger
	 a preload dso because default guest module symbols are loaded
	 from guest kallsyms instead of libmodulesXXXXXX. This
	 method is used to avoid symbol missing when the first addr is
	 in module instead of in guest kernel.
	
	  We use _stext for guest kernel because guest kernel's prockallsyms
	  have no _text sometimes.
	
	  Mark the round finished in case we wrote
	  at least one event.
 Same Size:      "2015122520103046"
 Output tracking events 
		
		  In 'perf record --switch-output' without -a,
		  record__synthesize() in record__switch_output() won't
		  generate tracking events because there's no thread_map
		  in evlist. Which causes newly created perf.data doesn't
		  contain map and comm information.
		  Create a fake thread_map and directly call
		  perf_event__synthesize_thread_map() for those events.
  evlist__prepare_workload will send a SIGUSR1
  if the fork fails, since we asked by setting its
  want_signal to true.
 Synthesize id_index before auxtrace_info 
		
		  We get here if --switch-output-event populated the
		  sb_evlist, so associate a callback that will send a SIGUSR2
		  to the main thread.
 HAVE_EVENTFD_SUPPORT
	
	  If we have just single event and are sending data
	  through pipe, we need to force the ids allocation,
	  because we synthesize event name through the pipe
	  and need the id for that.
	
	  Normally perf_session__new would do this, but it doesn't have the
	  evlist.
	
	  When perf is starting the traced process, all the events
	  (apart from group members) have enable_on_exec=1 set,
	  so don't spoil it by prematurely enabling them.
	
	  Let the child rip
		
		  Some HW events are generated before COMM event
		  which is emitted during exec(), so perf script
		  cannot see a correct process name for those events.
		  Synthesize COMM event to prevent it.
		
		  Synthesize NAMESPACES event for the command specified.
		
		  rec->evlist->bkw_mmap_state is possible to be
		  BKW_MMAP_EMPTY here: when done == true and
		  hits != rec->samples in previous round.
		 
		  evlist__toggle_bkw_mmap ensure we never
		  convert BKW_MMAP_EMPTY to BKW_MMAP_DATA_PENDING.
			
			  If switch_output_trigger is hit, the data in
			  overwritable ring buffer should have been collected,
			  so bkw_mmap_state should be set to BKW_MMAP_EMPTY.
			 
			  If SIGUSR2 raise after or during record__mmap_read_all(),
			  record__mmap_read_all() didn't collect data from
			  overwritable ring buffer. Read again.
			
			  Reenable events in overwrite ring buffer after
			  record__mmap_read_all(): we should have collected
			  data from it.
 re-arm the alarm 
			
			  Propagate error, only if there's any. Ignore positive
			  number of returned events and interrupt error.
		
		  When perf is starting the traced process, at the end events
		  die with the process and we wait for that. Thus no need to
		  disable events in this case.
 this will be recalculated during process_buildids() 
 --no-call-graph 
 Enable data address sampling for DWARF unwind. 
	
	  If we're using --switch-output-events, then we imply its 
	  --switch-output=signal, as we'll send a SIGUSR2 from the side band
	   thread to its parent.
	
	  We already have the kernel maps, put in place via perf_session__create_kernel_maps()
	  no need to add them twice.
	
	  We already have the kernel maps, put in place via perf_session__create_kernel_maps()
	  no need to add them twice.
  XXX Ideally would be local to cmd_record() and passed to a record__new
  because we need to have access to it in record__exit, that is called
  after cmd_record() exits, but since record_options need to be accessible to
  builtin-script, leave it here.
  At least we don't ouch it in all the other functions here directly.
  Just say no to tons of global variables, sigh.
  XXX Will stay a global variable till we fix builtin-script.c to stop messing
  with it and switch to use the library functions in perf_evlist that came
  from builtin-record.c, i.e. use record_opts,
  evlist__prepare_workload, etc instead of fork+exec'in 'perf record',
  using pipes, etc.
 Make system wide (-a) the default target. 
 Enable mmap build id synthesizing. 
 Enable perf_event_attr::build_id bit. 
 Disable build id cache. 
	
	  Allow aliases to facilitate the lookup of symbols for address
	  filters. Refer to auxtrace_parse_filters().
		
		  In 'perf record --switch-output', disable buildid
		  generation by default to reduce data file switching
		  overhead. Still generate buildid if they are required
		  explicitly using
		 
		   perf record --switch-output --no-no-buildid \
		               --no-no-buildid-cache
		 
		  Following code equals to:
		 
		  if ((rec->no_buildid || !rec->no_buildid_set) &&
		      (rec->no_buildid_cache || !rec->no_buildid_cache_set))
		          disable_buildid_cache();
 Enable ignoring missing threads when -u-p option is defined. 
	
	  We take all buildids when the file contains
	  AUX area tracing data because we do not decode the
	  trace because it would take too long.
 SPDX-License-Identifier: GPL-2.0-only
  builtin-stat.c
  Builtin stat command: Give a precise performance counters summary
  overview about any workload, CPU or specific PID.
  Sample output:
   $ perf stat .hackbench 10
  Time: 0.118
  Performance counter stats for '.hackbench 10':
       1708.761321 task-clock                #   11.037 CPUs utilized
            41,190 context-switches          #    0.024 Msec
             6,735 CPU-migrations            #    0.004 Msec
            17,318 page-faults               #    0.010 Msec
     5,205,202,243 cycles                    #    3.046 GHz
     3,856,436,920 stalled-cycles-frontend   #   74.09% frontend cycles idle
     1,600,790,871 stalled-cycles-backend    #   30.75% backend  cycles idle
     2,603,501,247 instructions              #    0.50  insns per cycle
                                             #    1.48  stalled cycles per insn
       484,357,498 branches                  #  283.455 Msec
         6,388,934 branch-misses             #    1.32% of all branches
        0.154822978  seconds time elapsed
  Copyright (C) 2008-2011, Red Hat Inc, Ingo Molnar <mingo@redhat.com>
  Improvements and fixes by:
    Arjan van de Ven <arjan@linux.intel.com>
    Yanmin Zhang <yanmin.zhang@intel.com>
    Wu Fengguang <fengguang.wu@intel.com>
    Mike Galbraith <efault@gmx.de>
    Paul Mackerras <paulus@samba.org>
    Jaswinder Singh Rajput <jaswinder@kernel.org>
 Default events used for perf stat -T 
 More limited version when the CPU does not have all events. 
 strlen("unit") 
 Check that leader matches cpus with each member. 
 If there's mismatch disable the group and warn user. 
  Read out the results of a single counter:
  do not aggregate counts across CPUs in system-wide mode
		
		  The leader's group read loads data into its group members
		  (via evsel__read_counter()) and sets their count->loaded.
	
	  We need to enable counters only if:
	  - we don't have tracee (attaching to task or cpu)
	  - we have initial delay configured
	
	  If we don't have tracee (attaching to task or cpu), counters may
	  still be running. To get accurate group ratios, we must stop groups
	  from counting before reading their constituent counters.
  evlist__prepare_workload will send a SIGUSR1
  if the fork fails, since we asked by setting its
  want_signal to true.
 poll timeout or EINTR 
 fd revent 
	
	  PPC returns ENXIO for HW counters until 2.6.37
	  (behavior changed with commit b0a873e).
		
		  errored is a sticky flag that means one of the counter's
		  cpu event had a problem and needs to be reexamined.
		
		  For global --per-thread case, skip current
		  error thread.
		
		  bperf calls evsel__open_per_cpu() in bperf__load(), so
		  no need to call it again here.
				
				  Weak group failed. We cannot just undo this here
				  because earlier CPUs might be in group mode, and the kernel
				  doesn't support mixing group and non group reads. Defer
				  it to later.
				  Don't close here because we're in the wrong affinity.
		
		  Now redo all the weak group after closing them,
		  and also close errored counters.
 First close errored or weak retry 
 Now reopen weak 
	
	  Enable counters and exec the command:
	
	  Closing a group leader splits the group, and as we only disable
	  group leaders, results in remaining events becoming enabled. To
	  avoid arbitrary skew, we must read all counters before closing any
	  group leaders.
	
	  We need to keep evsel_list alive, because it's processed
	  later the evsel_list will be closed after.
 Do not print anything if we record to the pipe. 
	
	  render child_pid harmless
	  won't send SIGTERM to a random
	  process in case of race condition
	  and fast PID recycling
	
	  avoid race condition with SIGCHLD handler
	  in skip_signal() which is modifying child_pid
	  goal is to avoid send SIGTERM to a random
	  process
	
	  The evsel_list->cpus is the base we operate on,
	  taking the highest cpu number to be the size of
	  the aggregation translate cpumap.
		
		  die_id is relative to socket, so start
		  with the socket ID and then add die to
		  make a unique ID.
		
		  core_id is relative to socket and die,
		  we need a global id. So we set
		  socket, die id and core id
  Add default attributes, if there were no attributes specified or
  if -d--detailed, -d -d or -d -d -d is used:
  Detailed stats (-d), covering the L1 and last level data caches:
  Very detailed stats (-d -d), covering the instruction cache and the TLB caches:
  Very, very detailed stats (-d -d -d), adding prefetch events:
 Set attrs if no event is selected and !null_run: 
		 Handle -T as -M transaction. Once platform specific metrics
		  support has been added to the json files, all architectures
		  will use this approach. To determine transaction support
		  on an architecture test for such a metric name.
 Detailed events get appended to the event list: 
 Append detailed run extra attributes: 
 Append very detailed run extra attributes: 
 Append very, very detailed run extra attributes: 
	
	  Make system wide (-a) the default target if
	  no target was specified and one of following
	  conditions is met:
	 
	    - there's no workload specified
	    - there is workload specified but all requested
	      events are system wide events
 String-parsing callback-based options would segfault when negated 
	
	  For record command the -o is already taken care of.
	
	  let the spreadsheet do the pretty-printing
 User explicitly passed -B? 
 Nope, so disable big number formatting 
 User passed --no-big-num 
	
	  Display usersystem times only for single
	  run and when there's specified tracee.
	
	  no_aggr, cgroup are for system-wide only
	  --per-thread is aggregated per thread, we dont mix it with cpu mode
	
	  Initialize thread_map with comm names,
	  so we could print it out on output.
	
	  Set sample_type to PERF_SAMPLE_IDENTIFIER, which should be harmless
	  while avoiding that older tools show confusing messages.
	 
	  However for pipe sessions we need to keep it zero,
	  because script's perf_evsel__check_attr is triggered
	  by attr->sample_type != 0, and we can't run it on
	  stat sessions.
	
	  We dont want to block the signals - that would cause
	  child tasks to inherit that and Ctrl-C would not work.
	  What we want is for Ctrl-C to work in the exec()-ed
	  task, but being ignored by perf stat itself:
		
		  We synthesize the kernel mmap record just so that older tools
		  don't emit warnings about not being able to resolve symbols
		  due to procsyskernelkptr_restrict settings and instead provide
		  a saner message about no samples being in the perf.data file.
		 
		  This also serves to suppress a warning about f_header.data.size == 0
		  in header.c at the moment 'perf stat record' gets introduced, which
		  is not really needed once we start adding the stat specific PERF_RECORD_
		  records, but the need to suppress the kptr_restrict messages in older
		  tools remain  -acme
 SPDX-License-Identifier: GPL-2.0-only
  builtin-top.c
  Builtin top command: Display a continuously updated profile of
  any workload, CPU or specific PID.
  Copyright (C) 2008, Red Hat Inc, Ingo Molnar <mingo@redhat.com>
 		 2011, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
  Improvements and fixes by:
    Arjan van de Ven <arjan@linux.intel.com>
    Yanmin Zhang <yanmin.zhang@intel.com>
    Wu Fengguang <fengguang.wu@intel.com>
    Mike Galbraith <efault@gmx.de>
    Paul Mackerras <paulus@samba.org>
	
	  We can't annotate with just prockallsyms
		
		  This function is now called with he->hists->lock held.
		  Release it before going to sleep.
		
		  unlink existing entries so that they can be linked
		  in a correct order in hists__match() below.
 Non-group events are considered as leader 
 zero counters of active symbol 
 Select 0 as the default event: 
	 In order to read symbols from other namespaces perf to  needs to call
	  setns(2).  This isn't permitted if the struct_fs has multiple users.
	  unshare(2) the fs so that we may continue to setns into namespaces
	  that we're observing.
	
	  Initialize the uid_filter_str, in the future the TUI will allow
	  Zooming inout UIDs. For now just use whatever the user passed
	  via --uid.
	 In order to read symbols from other namespaces perf to  needs to call
	  setns(2).  This isn't permitted if the struct_fs has multiple users.
	  unshare(2) the fs so that we may continue to setns into namespaces
	  that we're observing.
 trash return
		
		  Either timeout expired or we got an EINTR due to SIGWINCH,
		  refresh screen in both cases.
		
		  As we do lazy loading of symtabs we only will know if the
		  specified vmlinux file is invalid when we actually have a
		  hit in kernel space and then try to load it. So if we get
		  here and there are _no_ symbols in the DSO backing the
		  kernel map, bail out.
		 
		  We may never get here, for instance, if we use -K
		  --hide-kernel-symbols, even if the user specifies an
		  invalid --vmlinux ;-)
  Check per-event overwrite term.
  perf top should support consistent term for all events.
  - All events don't have per-event term
    E.g. "cpucpu-cycles,cpuinstructions"
    Nothing change, return 0.
  - All events have same per-event term
    E.g. "cpucpu-cycles,no-overwrite,cpuinstructions,no-overwrite
    Using the per-event setting to replace the opts->overwrite if
    they are different, then return 0.
  - Events have different per-event term
    E.g. "cpucpu-cycles,overwrite,cpuinstructions,no-overwrite"
    Return -1
  - Some of the event set per-event term, but some not.
    E.g. "cpucpu-cycles,cpuinstructions,no-overwrite"
    Return -1
 no term for current and previous event (likely) 
 has term for both current and previous event, compare 
 no term for current event but has term for previous one 
 has term for current event 
 if it's first event, set overwrite 
 only fall back when first event fails 
			
			  Specially handle overwrite fall back.
			  Because perf top is the only tool which has
			  overwrite mode by default, support
			  both overwrite and non-overwrite mode, and
			  require consistent mode for all events.
			 
			  May move it to generic code with more tools
			  have similar attribute.
  Allow only 'top->delay_secs' seconds behind samples.
		
		  TODO: we don't process guest user from host side
		  except simple counting.
	
	  When perf is starting the traced process, all the events (apart from
	  group members) have enable_on_exec=1 set, so don't spoil it by
	  prematurely enabling them.
	 
	  XXX 'top' still doesn't start workloads like record, trace, but should,
	  so leave the check here.
 Wait for a minimal set of events before starting the snapshot 
	
	  --no-call-graph
 4 KHz 
			
			  FIXME: This will lose PERF_RECORD_MMAP and other metadata
			  when we pause, fix that and reenable. Probably using a
			  separate evlist with a dummy event, i.e. a non-overwrite
			  ring buffer just for metadata events, while PERF_RECORD_SAMPLE
			  stays in overwrite mode. -acme
	
	  Since the per arch annotation init routine may need the cpuid, read
	  it here, since we are not getting this from the perf.data header.
		
		  Some arches do not provide a get_cpuid(), so just use pr_debug, otherwise
		  warn the user explicitly.
 disable incompatible options 
 display thread wants entries to be collapsed in a different tree 
 SPDX-License-Identifier: GPL-2.0
 Set process name 
 task state bitmask, copied from includelinuxsched.h 
 in tsk->exit_state 
 in tsk->state again 
 PERF_RECORD_FORK event, not sched_process_fork tracepoint 
  Track the current task - that way we can know whether there's any
  weird events, such as a task being switched away that is not current.
 options for timehist command 
 per thread run time data 
 time of previous sched inout event 
 run time 
 time between CPU access by sleep (off cpu) 
 time between CPU access by iowait (off cpu) 
 time between CPU access by preempt (off cpu) 
 time between wakeup and sched-in 
 time of wakeup 
 per event run time data 
 time this event was last seen per cpu 
 highest cpu slot allocated 
 per cpu idle time data 
 track idle times per cpu 
	
	  optimize an existing RUN event by merging this one
	  to it:
	
	  every task starts in sleeping state - this gets ignored
	  if there's no wakeup pointing to this sleep state:
	
	  rusage statistics done by the parent, these are less
	  accurate than the sched->sum_exec_runtime based statistics:
  handle runtime stats saved per thread
		
		  Take came in we have not heard about yet,
		  add in an initial atom in runnable state:
	
	  As we do not guarantee the wakeup event happens when
	  task is out of run queue, also may happen when task is
	  on run queue and wakeup only change ->state to TASK_RUNNING,
	  then we should not set the ->wake_up_time when wake up a
	  task which is on run queue.
	 
	  You WILL be missing events if you've recorded only
	  one CPU, or are only looking at only one, so don't
	  skip in this case.
	
	  Only need to worry about migration when profiling one CPU.
	
	  Ignore idle threads:
			
			  Don't allocate a letter-number for swapper:0
			  as a shortname. Instead, we use '.' for it.
		
		  Are we trying to switch away a PID that is
		  not current?
 run the fork event through the perf machinery 
 and then run additional processing needed for this command 
  scheduling times are printed as msec.usec
  returns runtime data for event, allocating memory for it the
  first time it is used.
  save last time event was seen per cpu
 returns last time this event was seen on the given cpu 
	
	  units row
	
	  separator
 'I' for idle 
 flag idle times with 'i'; others are sched events 
  Explanation of delta-time stats:
             t = time of current schedule out event
         tprev = time of previous sched out event
                 also time of schedule-in event for current task
     last_time = time of last sched change event for current task
                 (i.e, time process was last scheduled out)
  ready_to_run = time of wakeup for current task
  -----|------------|------------|------------|------
     last         ready        tprev          t
     time         to run
       |-------- dt_wait --------|
                    |- dt_delay -|-- dt_run --|
    dt_run = run time of current task
   dt_wait = time between last schedule out event for task and tprev
             represents time spent off the cpu
  dt_delay = time between wakeup and schedule-in of task
 pid 0 == swapper == idle task 
 want main thread for process - has maps 
  Track idle stats per cpu by maintaining a local thread
  struct for the idle task on each cpu.
 allocate the actual thread struct if needed 
	
	  expandallocate array of pointers to local thread
	  structs if needed
 allocate a new thread struct if needed 
 there were samples with tid 0 but non-zero pid 
 copy task callchain when entering to idle 
 show wakeup unless both awakee and awaker are filtered 
 dt spacer 
 want pid of awakened task not pid in sample 
 show wakeups if requested 
 dt spacer 
 want pid of migrated task not pid in sample 
 show migrations if requested 
	
	  If start time given:
	  - sample time is under window user cares about - skip sample
	  - tprev is under window user cares about  - reset to start of window
	
	  If end time given:
	  - previous sched event is out of window - we are done
	  - sample time is beyond window user cares about - reset it
	    to close out stats for time window interest
 add current idle time as last thread's runtime 
			
			  remove delta time of last thread as it's not updated
			  and otherwise it will show an invalid value next
			  time.  we only care total run time and run stat.
 time of this sched_switch event becomes last time task seen 
 last state is used to determine where to account wait time 
 sched out event for task so reset ready to run time 
 print_sched_time returns 2nd arg + 4 
 CPU idle stats not tracked when samples were skipped 
	
	  event handlers for timehist option
 prefer sched_waking if it is captured 
 setup per-evsel handlers 
 sched_switch event at a minimum needs to exist 
 pre-allocate struct for per-CPU idle stats 
 summary_only implies summary option, but don't overwrite summary if set 
	
	  Select "sched:sched_stat_wait" event to check
	  whether schedstat tracepoints are exposed.
	
	  The tracepoints trace_sched_stat_{wait, sleep, iowait}
	  are not exposed to user if CONFIG_SCHEDSTATS is not set,
	  to prevent "perf sched record" execution failure, determine
	  whether to record schedstat events according to actual situation.
	
	  +2 for either "-e", "sched:sched_wakeup" or
	  "-e", "sched:sched_waking"
	
	  Aliased to 'perf script' for now:
 SPDX-License-Identifier: GPL-2.0
 default set to maintain compatibility with current format 
 For metric output 
 user did not ask for it explicitly so remove from the default list 
  verify all user requested events exist and the samples
  have the expected data
		
		  even if fields is set to 0 (ie., show nothing) event must
		  exist if user explicitly includes it on the command line
	
	  set default for tracepoints to print symbols only
	  if callchains are present
	
	  Block overlaps between kernel and user.
	  This can happen due to ring filtering
	  On Intel CPUs the entry into the kernel is filtered,
	  but the exit is not. Let the caller patch it up.
 Load maps to ensure dso->is_64_bit has been updated 
 Avoid redundant printing 
 Handle first from jump, of which we don't know the entry. 
 Print all blocks 
 Patch up missing kernel transfers due to ring filters 
	
	  Hit the branch? In this case we are already done, and the target
	  has not been executed yet.
	
	  Print final block upto sample
	 
	  Due to pipeline delays the LBRs might be missing a branch
	  or two, which can result in very large or negative blocks
	  between final branch and sample. When this happens just
	  continue walking after the last TO until we hit a branch.
 Missing jump. Scan 128 bytes for the next branch 
 Print at least last IP if basic block did not work 
			
			  Hit a missing branch. Just stop.
	
	  The 'return' has already been popped off the stack so the depth has
	  to be adjusted to match the 'call'.
	
	  Try to keep the output length from changing frequently so that the
	  output lines up more nicely.
 print branch_from information 
 print branch_to information 
 Set thread to NULL to indicate addr_al and al are not initialized 
	
	  Check if we need to enable callchains based
	  on events sample_type.
 Enable fields for callchain entries 
 Print before 'exit' deletes anything 
		
		  Already setup? I.e. we may be called twice in cases like
		  Intel PT, one for the intel_pt and dummy events, then
		  for the evsels synthesized from the auxtrace info.
		 
		  Ses perf_script__process_auxtrace_info.
 override event processing functions 
 Find script file relative to current directory or exec path 
	 first word can state for which event type the user is specifying
	  the fields. If no type exists, the specified fields apply to all
	  event types found in the file minus the invalid fields for a type.
 Don't override defaults for +- 
 Don't override defaults for +- 
			 add user option to all events types for
			  which it is valid
  Some scripts specify the required events in their "xxx-record" file,
  this function will check if the events in perf.data match those
  mentioned in the "xxx-record".
  Fixme: All existing "xxx-record" are all in good formats "-e event ",
  which is covered well now. And new parsing code should be added to
  cover the future complex formats like event groups etc.
  Return -1 if none is found, otherwise the actual scripts number.
  Currently the only user of this function is the script browser, which
  will list all statically runnable scripts, select one, execute it and
  show the output in a perf browser.
 Skip those real time scripts: xxxtop.p[yl] 
		
		  Enable guest sample processing.
 make sure PERF_EXEC_PATH is set for scripts 
 Assume pipe_mode indicates native_arch 
 input_name 
 SPDX-License-Identifier: GPL-2.0
  Builtin evlist command: Show the list of event selectors present
  in a perf.data file.
 only needed for pipe mode 
  builtin-buildid-list.c
  Builtin buildid-list command: list buildids in perf.data, in the running
  kernel and in ELF files.
  Copyright (C) 2009, Red Hat Inc.
  Copyright (C) 2009, Arnaldo Carvalho de Melo <acme@redhat.com>
	
	  See if this is an ELF file first:
	
	  We take all buildids when the file contains AUX area tracing data
	  because we do not decode the trace because it would take too long.
	
	  in pipe-mode, the only way to get the buildids is to parse
	  the record stream. Buildids are stored as RECORD_HEADER_BUILD_ID
 SPDX-License-Identifier: GPL-2.0
  Session states:
    OK       - session is up and running
    RECONFIG - session is pending for reconfiguration,
               new values are already loaded in session object
    KILL     - session is pending to be killed
  Session object life and its state is maintained by
  following functions:
   setup_server_config
     - reads config file and setup session objects
       with following states:
       OK       - no change needed
       RECONFIG - session needs to be changed
                  (run variable changed)
       KILL     - session needs to be killed
                  (session is no longer in config file)
   daemon__reconfig
     - scans session objects and does following actions
       for states:
       OK       - skip
       RECONFIG - session is killed and re-run with new config
       KILL     - session is killed
     - all sessions have OK state on the function exit
 New session is defined. 
 Trigger reconfig to start it. 
 Current session is defined, no action needed. 
			
			  Either new or changed run value is defined,
			  trigger reconfig for the session.
	
	  Mark all sessions for kill, the server config
	  will set following states, see explanation at
	  enum daemon_session_state declaration.
	
	  Take signal fd data as pure signal notification and check all
	  the sessions state. The reason is that multiple signals can get
	  coalesced in kernel and we can receive only single signal even
	  if multiple SIGCHLD were generated.
 open the control file 
 open the ack file 
 write the command 
 wait for an ack 
 CMD_LIST 
 CMD_SIGNAL 
 CMD_PING 
 pid daemon  
 base 
 output 
 lock 
 session up time 
 pid 
 name 
 base 
 session dir 
 session output 
 session control 
 session ack 
 session up time 
 If out is defined, then fd is closed via fclose. 
 No change. 
 Remove session. 
 Reconfig session. 
		
		  We monitor config directory, check if our
		  config file was changes.
 F_TLOCK
  Each daemon tries to create and lock BASElock file,
  if it's successful we are sure we're the only daemon
  running over the BASE.
  Once daemon is finished, file descriptor to lock file
  is closed and lock is released.
 original process, exit normally 
 If in is defined, then fd is closed via fclose. 
 SPDX-License-Identifier: GPL-2.0
  builtin-inject.c
  Builtin inject command: Examine the live mode (stdin) event stream
  and repipe it to stdout while optionally injecting additional
  events into it.
 To get things like MAP_HUGETLB even on older libc headers 
	
	  if jit marker, then inject jit mmaps and generate ELF images
		 The vdso maps are always on the host and not the
		  container.  Ensure that we don't use setns to look
		  them up.
 mark it not to inject build-id 
	
	  if jit marker, then inject jit mmaps and generate ELF images
 cannot use dso_id since it'd have invalid info 
 mark it not to inject build-id 
 Allow space in the header for new attributes 
		
		  Keep all buildids when there is unprocessed AUX data because
		  it is not known which ones the AUX trace hits.
		
		  The AUX areas have been removed and replaced with
		  synthesized hardware events, so clear the feature flag.
	
	  Any (unrecognized) arguments left?
		
		  Do not repipe header when input is a regular file
		  since either it can rewrite the header at the end
		  or write a new pipe header.
		
		  to make sure the mmap records are ordered correctly
		  and so that the correct especially due to jitted code
		  mmaps. We cannot generate the buildid hit list and
		  inject the jit mmaps at the same time for now.
		
		  JIT MMAP injection injects all MMAP events in one go, so it
		  does not obey finished_round semantics.
 SPDX-License-Identifier: GPL-2.0-or-later
  builtin-probe.c
  Builtin probe command: Set up probe events by C expression
  Written by Masami Hiramatsu <mhiramat@redhat.com>
 Session management structure 
 Command short_name 
 Parse an event definition. Note that any error must die. 
 Parse a perf-probe command into event 
	
	  The first argument after options can be an absolute path
	  to an executable  library or kernel module.
	 
	  TODO: Support relative path, and $PATH, $LD_LIBRARY_PATH,
	  short module name.
 Bind up rest arguments 
 Expand given path to absolute path, except for modulename 
 Command option callbacks 
 it shows definition 
 Skipped events have no event name 
 We use tev's name for showing new events 
 Save the last valid name 
 Note that it is possible to skip all events because of blacklist 
 Show how to use the event. 
 Get current event names 
	
	  Only consider the user's kernel image path if given.
	
	  Except for --list, --del and --add, other command doesn't depend
	  nor change running kernel. So if user gives offline vmlinux,
	  ignore its buildid.
 Ensure the last given target is used 
			
			  When perf_add_probe_events() fails it calls
			  cleanup_perf_probe_events(pevs, npevs), i.e.
			  cleanup_perf_probe_events(params.events, params.nevents), which
			  will call clear_perf_probe_event(), so set nevents to zero
			  to avoid cleanup_params() to call clear_perf_probe_event() again
			  on the same pevs.
 SPDX-License-Identifier: GPL-2.0
  builtin-annotate.c
  Builtin annotate command: Analyze the perf.data input file,
  look up and read DSOs and symbol information and display
  a histogram of results, along various sorting keys.
  Given one basic block:
 	from	to		branch_i
 	 ----> 
 		|
 		| block
 		v
 		 ----> 
 		from	to	branch_i+1
  where the horizontal are the branches and the vertical is the executed
  block of instructions.
  We count, for each 'instruction', the number of blocks that covered it as
  well as count the ratio each branch is taken.
  We can do this without knowing the actual instruction stream by keeping
  track of the address ranges. We break down ranges such that there is no
  overlap and iterate from the start until the end.
  @acme: once we parse the objdump output _before_ processing the samples,
  we can easily fold the branch.cycles IPC bits in.
	
	  Sanity; NULL isn't executable and the CPU cannot execute backwards
	
	  First block in range is a branch target.
	
	  Last block in rage is a branch.
		
		  XXX filter against symbol
 We're only interested in a symbol named sym_hist_filter 
		
		  FIXME: why isn't this done in the symbol_filter when loading
		  the DSO?
	
	  XXX filtered samples can still have branch entries pointing into our
	  symbol and are missed.
 skip missing symbols 
 fall through 
 Don't sort callchain 
		
		  Special case: if there's an argument left then assume that
		  it's a symbol filter:
	
	  Events of different processes may correspond to the same
	  symbol, we do not care about the processes in annotate,
	  set sort order to avoid repeated output.
	
	  Set SORT_MODE__BRANCH so that annotate display IPCCycle
	  if branch info is in perf data in TUI mode.
	
	  Speed up the exit process, for large files this can
	  take quite a while.
	 
	  XXX Enable this when using valgrind or if we ever
	  librarize this command.
	 
	  Also experiment with obstacks to see how much speed
	  up we'll get here.
	 
	  perf_session__delete(session);
 SPDX-License-Identifier: GPL-2.0
  Include definition of find_map() also used in utilvdso.c for
  building perf.
 SPDX-License-Identifier: GPL-2.0-only
  builtin-kallsyms.c
  Builtin command: Look for a symbol in the running kernel and its modules
  Copyright (C) 2017, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: GPL-2.0
  builtin-bench.c
  General benchmarking collections provided by perf
  Copyright (C) 2009, Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
  Available benchmark collection list:
   sched ... scheduler and IPC performance
   syscall ... System call performance
   mem   ... memory access performance
   numa  ... NUMA scheduling and MM performance
   futex ... Futex performance
   epoll ... Event poll performance
 pi-futexes 
 HAVE_EVENTFD_SUPPORT
 Iterate over all benchmark collections: 
 Iterate over all benchmarks within a collection: 
 Outputformatting style, exported to benchmark modules: 
 default number of times to repeat the run 
  Run a specific benchmark but first rename the running task's ->comm[]
  to something meaningful:
	
	  TODO:
	 
	  Preparing preset parameters for
	  embedded, ordinary PC, HPC, etc...
	  would be helpful.
 No collection specified. 
 No bench specified. 
 SPDX-License-Identifier: GPL-2.0
  builtin-report.c
  Builtin report command: Analyze the perf.data input file,
  look up and read DSOs and symbol information and display
  a histogram of results, along various sorting keys.
 perf_tip()
	
	  (feat_id = HEADER_LAST_FEATURE) is the end marker which
	  means all features are received, now we can force the
	  group if needed.
		
		  A non-synthesized event might not have a branch stack if
		  branch stacks have been synthesized (using itrace options).
 For pipe mode, sample_type is not currently set 
 Silently ignore if callchain is missing 
 ??? handle more cases than just ANY? 
 fallback for people who don't install perf ;-) 
		
		  Usually "ret" is the last pressed key, and we only
		  care if the key notifies us to switch data file.
 Non-group events are considered as leader 
 Already listed. 
 Last one in the chain. 
	
	  No locking needed while accessing machine->threads,
	  because --tasks is single threaded command.
 Count all the threads. 
	
	  Iterate every task down to the unprocessed parent
	  and link all in task children list. Task with no
	  parent is added into 'list'.
 report__setup_sample_type() already showed error message 
	
	  recalculate number of entries after collapsing since it
	  might be changed during the collapse phase.
	
	  --no-call-graph
	
	  Check if we need to enable callchains based
	  on events sample_type.
		
		  Special case: if there's an argument left then assume that
		  it's a symbol filter:
	
	  Branch mode is a tristate:
	  -1 means default, so decide based on the file having branch data.
	  01 means the user chose a mode.
 disable incompatible options 
 Force tty output for header output and per-thread stat. 
				
				  we need to process first few records
				  which contains PERF_RECORD_HEADER_FEATURE.
	
	  Only in the TUI browser we are doing integrated annotation,
	  so don't allocate extra space that won't be used in the stdio
	  implementation.
		
 		  For searching by name on the "Browse map details".
 		  providing it only in verbose mode not to bloat too
 		  much struct symbol.
			
			  XXX: Need to provide a less kludgy way to ask for
			  more space per symbol, the u32 is for the index on
			  the ui browser.
			  See symbol__browser_index.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  builtin-help.c
  Builtin help command
 emacsclient prints its version number on stderr 
	
	  Don't bother checking return value, because "emacsclient --version"
	  seems to always exits with code 1.
 This works only with emacsclient version >= 22. 
 It's simpler to launch konqueror using kfmclient. 
 strlen("konqueror") == strlen("kfmclient") 
	 We should always put ':' after our path. If there is no
	  old_path, the ':' at the end will let 'man' to try
	  system-wide paths after ours to find the manual page. If
 will return when unable 
 Check that we have a perf documentation directory. 
  If open_html is not defined in a platform-specific way (see for
  example compatmingw.h), we use the script web--browse to display
  HTML.
 it leaks but we exec bellow 
 fall-through 
 SPDX-License-Identifier: GPL-2.0
  builtin-diff.c
  Builtin diff command: Analyze two perf.data input files, look up and read
  DSOs and symbol information, sort them and produce a diff.
 Diff command specific HPP columns. 
 After COMPUTE_MAX to avoid use current compute arrays 
		
		  The str data are not writeable, so we need
		  to use another buffer.
 No option value is longer. 
	
	  The total_period is updated here before going to the output
	  tree since normally only the baseline hists will call
	  hists__output_resort() and precompute needs the total
	  period in order to sort entries by percentage delta.
	
	  We have 2 entries of same kind, let's
	  make the data comparison.
		
		  The delta can be computed without the baseline, but
		  others are not.  Put those entries which have no
		  values below.
 Don't sort callchain for perf diff 
	
	  Stream comparison only supports two data files.
	  perf.data.old and perf.data. data__files[0] is perf.data.old,
	  data__files[1] is perf.data.
	
	  Absolute timestamp for one file has the format: a.b,c.d
	  For multiple files, the format is: a.b,c.d:a.b,c.d
 Set only all files having branch stacks 
	
	  Avoid printing the warning "addr2line_init failed for ..."
		
		  Padding spaces if number of sparks less than NUM_SPARKS
		  otherwise the output is not aligned.
 No point for ratio number if we are dummy.. 
 No point for wdiff number if we are dummy.. 
 baseline is special 
 Only our defined HPP fmts should appear here. 
 TODO more colors 
		
		  Baseline or compute related columns:
		 
		    PERF_HPP_DIFF__BASELINE
		    PERF_HPP_DIFF__DELTA
		    PERF_HPP_DIFF__RATIO
		    PERF_HPP_DIFF__WEIGHTED_DIFF
		    PERF_HPP_DIFF__CYCLES
		
		  And the rest:
		 
		  PERF_HPP_DIFF__FORMULA
		  PERF_HPP_DIFF__PERIOD
		  PERF_HPP_DIFF__PERIOD_BASELINE
	
	  Prepend an fmt to sort on columns at 'sort_compute' first.
	  This fmt is added only to the sort list but not to the
	  output fields list.
	 
	  Note that this column (data) can be compared twice - one
	  for this 'sort_compute' fmt and another for the normal
	  diff_hpp_fmt.  But it shouldn't a problem as most entries
	  will be sorted out by first try or baseline and comparing
	  is not a costly operation.
		
		  Should set since 'fmt->sort' is called without
		  checking valid during sorting
 SPDX-License-Identifier: GPL-2.0-only
  builtin-ftrace.c
  Copyright (c) 2013  LG Electronics,  Namhyung Kim <namhyung@kernel.org>
  Copyright (c) 2020  Changbin Du <changbin.du@gmail.com>, significant enhancement.
  evlist__prepare_workload will send a SIGUSR1 if the fork fails, since
  we asked by setting its exec_error to the function below,
  ftrace__workload_exec_failed_signal.
  XXX We need to handle this more appropriately, emitting an error, etc.
	
	  Copy the original value and append a '\n'. Without this,
	  the kernel can hide possible errors.
 read contents to stdout 
 one more byte for EOS 
 ',' is needed for every 32th cpus 
 old kernels do not have this filter 
 reset ftrace buffer 
 display column headers 
 flush stdout first so below error msg appears at the end. 
 read remaining buffer contents 
 The function_graph has priority over function tracer. 
 Otherwise, the default tracer is used. 
 TODO: Add short option -t after -t--tracer can be removed. 
 SPDX-License-Identifier: GPL-2.0
  builtin-list.c
  Builtin list command: list all event types
  Copyright (C) 2009, Thomas Gleixner <tglx@linutronix.de>
  Copyright (C) 2008-2009, Red Hat Inc, Ingo Molnar <mingo@redhat.com>
  Copyright (C) 2011, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: GPL-2.0-only
  builtin-timechart.c - make an svg timechart of system activity
  (C) Copyright 2009 Intel Corporation
  Authors:
      Arjan van de Ven <arjan@linux.intel.com>
 for struct evsel_str_handler
 Lowest CPU frequency seen 
 Highest CPU frequency seen 
 IO related settings 
  Datastructure layout:
  We keep an list of "pid"s, matching the kernels notion of a task struct.
  Each "pid" entry, has a list of "comm"s.
 	this is because we want to track different programs different, while
 	exec will reuse the original pid (by design).
  Each comm has a list of samples that will be used to draw
  final graph.
 detect invalid data 
				
				  It seems the callchain is corrupted.
				  Discard all.
 SUPPORT_OLD_POWER_EVENTS 
  After the last sample we need to wrap up the current CP state
  and close out each CPU for these.
 C state 
 P state 
		 remove previous event that has been started,
 skip partially captured events 
	 we want to be able to see small and fast transfers, so make them
 try to make errors more visible 
 merge two requests to make svg smaller and render-friendly 
  Sort the pid datastructure
 sort by ppid first, then by pid, lowest to highest 
 must insert before 
	
	  two pass drawing so that the P state bars are on top of the C state blocks
 locate the column of the waker and wakee 
 5 seconds 
 no exit marker, task kept running to the end 
 no exit marker, task kept running to the end 
 no exit marker, task kept running to the end 
	 We'd like to show at least proc_num tasks;
 SPDX-License-Identifier: GPL-2.0
 reset stats for event 
 The begin event is not caught. 
	
	  In some case, the 'begin event' only records the start timestamp,
	  the actual event is recognized in the 'end event' (e.g. mmio-event).
 Both begin and end events did not get the key. 
 seems to happen once in a while during live mode 
 Only kvm_entry records vcpu id. 
 only process events for vcpus user cares about 
 returns left most element of result, and erase it 
 keeping the max events to a modest level to keep
  the processing of samples per mmap smooth.
		
		  FIXME: Here we can't consume the event, as perf_session__queue_event will
		         point to it, and it'll get possibly overwritten by the kernel.
 save time stamp of our first sample for this mmap 
 limit events per mmap handled all at once 
		 flush time is going to be the minimum of all the individual
		  mmap times. Essentially, we flush all the samples queued up
		  from the last pass under our minimal start time -- that leaves
		  a very small race for samples to come in with a lower timestamp.
		  The ioctl to return the perf_clock timestamp should close the
		  race entirely.
 flush queue after each round in which we processed events 
 update display 
 reset counts 
 live flag must be set first 
 add timer fd 
 everything is good - enable the events and process 
	
	  Note: exclude_{guest,host} do not apply here.
	        This command processes KVM tracepoints from host only
 make sure these are set 
 make sure these are not; want as small a sample as possible 
 will enable all once we are ready 
	
	  Do not use 'isa' recorded in kvm_exit tracepoint since it is not
	  traced in the old kernel.
 split tracepoint into subsystem and name 
 event handling 
 set defaults 
 convert usec to nsec 
	
	  target related setups
	
	  generate the event list
	
	  perf session
 HAVE_KVM_STAT_SUPPORT 
 SPDX-License-Identifier: GPL-2.0
  builtin-config.c
  Copyright (C) 2015, Taeung Song <treeze.taeung@gmail.com>
 overwrite configvariables 
	
	  Since "var" actually contains the section name and the real
	  config variable name separated by a dot, we have to know where the dot is.
 excluding a first character '=' 
	
	  At only 'config' sub-command, individually use the config set
	  because of reinitializing with options config file location.
  Copyright (c) 2010 Serge A. Zaitsev
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, andor sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  Slightly modified by AK to not assume 0 terminated input.
  Allocates a fresh unused token from the token pool.
  Fills token type and boundaries.
  Fills next available token with JSON primitive.
		
		  In strict mode primitive must be followed by ","
		  or "}" or "]"
	
	  In strict mode primitive must be followed by a
	  commaobjectarray.
 parent sees closing brackets 
  Fills next token with JSON string.
 Skip starting quote 
 Quote: end of string 
 Backslash: Quoted symbol expected 
 Allowed escaped symbols 
 Allows escaped symbol \uXXXX 
 TODO 
 Unexpected symbol 
  Parse JSON string and fill tokens.
	
	  Keeps track of whether a new objectlistprimitive is expected. New items are only
	  allowed after an opening brace, comma or colon. A closing brace after a comma is not
	  valid JSON.
 Error if unmatched closing bracket 
			
			  In strict mode primitives are:
			  numbers and booleans.
			
			  In non-strict mode every unquoted value
			  is a primitive.
FALL THROUGH 
 Unexpected char in strict mode 
 Unmatched opened object or array 
  Creates a new parser based over a given  buffer with an array of tokens
  available.
 needed for nftw() 
 needed for asprintf() 
 Parse event JSON files 
  Copyright (c) 2014, Intel Corporation
  All rights reserved.
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
  1. Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation andor other materials provided with the distribution.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.
 getrlimit 
 getrlimit 
 Don't add field in this case 
 Remove trailing dots that look ugly in perf list 
 Add escapes for '\' so they are proper C strings. 
 Count the number of '\' in string 
 allocate space for a new string 
 copy over the characters 
 Cut off everything after comma 
 it's not realistic to keep adding these, we need something more scalable ... 
 tp is free'd in process_one_file() 
	
	  TODO: Remove formatting chars after debugging to reduce
	 	 string lengths.
  Handle different fixed counter encodings between JSON and perf.
 try to find matching event from arch standard values 
 Call func with each event in the json file 
 ok 
 ignore unknown fields 
			
			  An arch standard event is referenced, so try to
			  fixup any unassigned values.
	
	  Ensure tablename starts with alphabetic character.
	  Derive rest of table name from basename of the JSON file,
	  replacing hyphens and stripping out .json suffix.
	
	  Print the terminating, NULL entry.
 and finally, the closing curly bracket for the struct 
	
	  Print the terminating, NULL entry.
 Skip first line (header) 
 TODO Deal with lines longer than 16K 
		
		  CHECK: We can't use the type (eg "core") field in the
		  table name. For us to do that, we need to somehow tweak
		  the other caller of file_name_to_table(), process_json()
		  to determine the type. process_json() file has no way
		  of knowing these are "core" events unless file name has
		  core in it. If filename has core in it, we can safely
		  ignore the type field here also.
  If we fail to locateprocess JSON and map files, create a NULL mapping
  table. This would at least allow perf to build even if we can't finduse
  the aliases.
 Truncate file to clear any partial writes to it 
  nftw() doesn't let us pass an argument to the processing function,
  so use a global variables.
		
		  For level 2 directory, bname will include parent name,
		  like vendorplatform. So search back from platform dir
		  to find this.
		  Something similar for level 3 directory, but we're a PMU
		  category folder, like vendorplatformcpu.
 base dir or too deep 
 model directory, reset topic 
		
		  Drop file name suffix. Replace hyphens with underscores.
		  Fail if file name contains any alphanum characters besides
		  underscores.
	
	  Save the mapfile name for now. We will process mapfile
	  after processing all JSON files (so we can write out the
	  mapping table after all PMU events tables).
	 
	
	  If the file name does not have a .json extension,
	  ignore it. It could be a readme.txt for instance.
	
	  Assume all other files are JSON files.
	 
	  If mapfile refers to 'power7_core.json', we create a table
	  named 'power7_core'. Any inconsistencies between the mapfile
	  and directory tree could result in build failure due to table
	  names not being found.
	 
	  At least for now, be strict with processing JSON file names.
	  i.e. if JSON file name cannot be mapped to C-style table name,
	  fail.
  Starting in directory 'start_dirname', find the "mapfile.csv" and
  the set of JSON files for the architecture 'arch'.
  From each JSON file, create a C-style "PMU events table" from the
  JSON file (see struct pmu_event).
  From the mapfile, create a mapping between the CPU revisions and
  PMU event tables (see struct pmu_events_map).
  Write out the PMU events tables and the mapping table to pmu-event.c.
 If architecture does not have any event lists, bail out 
 Include pmu-events.h first 
	
	  The mapfile allows multiple CPUids to point to the same JSON file,
	  so, not sure if there is a need for symlinks within the pmu-events
	  directory.
	 
	  For now, treat symlinks of JSON files as regular files and create
	  separate tables for each symlink (presumably, each symlink refers
	  to specific version of the CPU).
 Make build fail 
 Parse JSON files using the JSMN parser. 
  Copyright (c) 2014, Intel Corporation
  All rights reserved.
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
  1. Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation andor other materials provided with the distribution.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.
  Parse json file using jsmn. Return array of tokens,
  and mapped file. Caller needs to free array.
 Heuristic 
 Return line number of a jsmn token 
 Return type name of a jsmn token 
 Is string t equal to s? 
 SPDX-License-Identifier: GPL-2.0
  mem-memcpy.c
  Simple memcpy() and memset() benchmarks
  Written by Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
 Make sure to always prefault zero pages even if MMAP_THRESH is crossed: 
	
	  We prefault the freshly allocated memory range here,
	  to not measure page fault overhead:
	
	  We prefault the freshly allocated memory range here,
	  to not measure page fault overhead:
	
	  We prefault the freshly allocated memory range here,
	  to not measure page fault overhead:
  syscall.c
  syscall: Benchmark for system call performance
 reaching here is something disaster 
 SPDX-License-Identifier: GPL-2.0
 samples per mmap 
  Helper for collect_dso that adds the given file as a dso to dso_list
  if it contains a build-id.  Stops after collecting 4 times more than
  we need (for MMAP2 events).
 stop if we collected enough DSOs 
 Fake address used by mmap and sample events 
 write mmap2 event first 
 zero-fill sample id header 
 put timestamp in the right position 
 read out data from child 
 signal that we're ready to go 
 wait for child ready 
 this makes the child to run 
 this makes the child to finish 
 each iteration, it processes MMAP2 + BUILD_ID + nr_samples  SAMPLE 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2015 Davidlohr Bueso.
  Block a bunch of threads and let parallel waker threads wakeup an
  equal amount of them. The program output reflects the avg latency
  for each individual thread to service its share of work. Ultimately
  it can be used to measure futex_wake() changes.
 HAVE_PTHREAD_BARRIER 
 For the CLR_() macros 
 all threads will block on the same futex -- hash bucket chaos ;) 
 create and block all threads 
		
		  Thread creation order will impact per-thread latency
		  as it will affect the order to acquire the hb spinlock.
		  For now let the scheduler decide.
 handle spurious wakeups 
 create and block all threads 
 some sanity checks 
	
	  Each thread will wakeup nwakes tasks in
	  a single futex_wait call.
 create, launch & block all threads 
 make sure all threads are already blocked 
 Ok, all threads are patiently blocked, start waking folks up 
 cleanup & report results 
 HAVE_PTHREAD_BARRIER 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2013  Davidlohr Bueso <davidlohr@hp.com>
  futex-requeue: Block a bunch of threads on futex1 and requeue them
                 on futex2, N at a time.
  This program is particularly useful to measure the latency of nthread
  requeues without waking up any tasks (in the non-pi case) -- thus
  mimicking a regular futex_wait.
 For the CLR_() macros 
	
	  How many tasks to requeue at a time.
	  Default to 1 in order to make the kernel work more.
 got the lock at futex2 
 create and block all threads 
 create, launch & block all threads 
 make sure all threads are already blocked 
 Ok, all threads are patiently blocked, start requeueing 
			
			  For the regular non-pi case, do not wakeup any tasks
			  blocked on futex1, allowing us to really measure
			  futex_wait functionality. For the PI case the first
			  waiter is always awoken.
 assume no error 
 everybody should be blocked on futex2, wake'em up 
 cleanup & report results 
 SPDX-License-Identifier: GPL-2.0
  Benchmark synthesis of perf events such as at the start of a 'perf
  record'. Synthesis is done on the current process and the 'dummy' event
  handlers are invoked that support dump_trace but otherwise do nothing.
  Copyright 2019 Google LLC.
	
	  If neither single threaded or multi-threaded are specified, default
	  to running just single threaded.
 SPDX-License-Identifier: GPL-2.0
  Benchmark of prockallsyms parsing.
  Copyright 2020 Google LLC.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 Davidlohr Bueso.
  This program benchmarks concurrent epoll_wait(2) monitoring multiple
  file descriptors under one or two load balancing models. The first,
  and default, is the singlecombined queueing (which refers to a single
  epoll instance for N worker threads):
                           |---> [worker A]
                           |---> [worker B]
         [combined queue]  .---> [worker C]
                           |---> [worker D]
                           |---> [worker E]
  While the second model, enabled via --multiq option, uses multiple
  queueing (which refers to one epoll instance per worker). For example,
  short lived tcp connections in a high throughput httpd server will
  distribute the accept()'ing  connections across CPUs. In this case each
  worker does a limited  amount of processing.
              [queue A]  ---> [worker]
              [queue B]  ---> [worker]
              [queue C]  ---> [worker]
              [queue D]  ---> [worker]
              [queue E]  ---> [worker]
  Naturally, the single queue will enforce more concurrency on the epoll
  instance, and can therefore scale poorly compared to multiple queues.
  However, this is a benchmark raw data and must be taken with a grain of
  salt when choosing how to make use of sys_epoll.
  Each thread has a number of private, nonblocking file descriptors,
  referred to as fdmap. A writer thread will constantly be writing to
  the fdmaps of all threads, minimizing each threads's chances of
  epoll_wait not finding any ready read events and blocking as this
  is not what we want to stress. The size of the fdmap can be adjusted
  by the user; enlarging the value will increase the chances of
  epoll_wait(2) blocking as the lineal writer thread will take "longer",
  at least at a high level.
  Note that because fds are private to each thread, this workload does
  not stress scenarios where multiple tasks are awoken per ready IO; ie:
  EPOLLEXCLUSIVE semantics.
  The end resultmetric is throughput: number of opssecond where an
  operation consists of:
    epoll_wait(2) + [others]
         ... where [others] is the cost of re-adding the fd (EPOLLET),
             or rearming it (EPOLLONESHOT).
  The purpose of this is program is that it be useful for measuring
  kernel related changes to the sys_epoll, and not comparing different
  IO polling methods, for example. Hence everything is very adhoc and
  outputs raw microbenchmark numbers. Also this uses eventfd, similar
  tools tend to use pipes or sockets, but the result is the same.
 For the CLR_() macros 
  epoll related shared variables.
 Maximum number of nesting allowed inside epoll sets 
 edge-trigger 
 use an epoll instance per thread 
 amount of fds to monitor, per thread 
 for --multiq 
 general benchmark options 
 epoll specific options 
  Arrange the N elements of ARRAY in random order.
  Only effective if N is much smaller than RAND_MAX;
  if this may not be the case, use a better random
  number generator. -- Ben Pfaff.
		
		  Block indefinitely waiting for the IN event.
		  In order to stress the epoll_wait(2) syscall,
		  call it event per event, instead of a larger
		  batch (max)limit.
 rearm the file descriptor with a new event mask 
 anything 
 any number 
 inform all threads that we're done for the day 
 a single, main epoll instance 
		
		  Deal with nested epolls, if any.
 default to the number of CPUs and leave one for the writer pthread 
	
	  At this point the workers should be blocked waiting for read events
	  to become ready. Launch the writer which will constantly be writing
	  to each thread's fdmap.
 meh 
 cleanup & report results 
 sort the array back before reporting 
 HAVE_EVENTFD_SUPPORT
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2013  Davidlohr Bueso <davidlohr@hp.com>
  futex-wake: Block a bunch of threads on a futex and wake'em up, N at a time.
  This program is particularly useful to measure the latency of nthread wakeups
  in non-error situations:  all waiters are queued and all wake calls wakeup
  one or more tasks, and thus the waitqueue is never empty.
 For the CLR_() macros 
 all threads will block on the same futex 
	
	  How many wakeups to do at a time.
	  Default to 1 in order to make the kernel work more.
 create and block all threads 
 create, launch & block all threads 
 make sure all threads are already blocked 
 Ok, all threads are patiently blocked, start waking folks up 
 cleanup & report results 
 SPDX-License-Identifier: GPL-2.0
  sched-pipe.c
  pipe: Benchmark for pipe()
  Based on pipe-test-1m.c by Ingo Molnar <mingo@redhat.com>
   http:people.redhat.commingocfs-schedulertoolspipe-test-1m.c
  Ported to perf by Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
 Use processes by default: 
	
	  why does "ret" exist?
	  discarding returned value of read(), write()
	  causes error in building environment for perf
 reaching here is something disaster 
 SPDX-License-Identifier: GPL-2.0
  sched-messaging.c
  messaging: Benchmark for scheduler and IPC mechanisms
  Based on hackbench by Rusty Russell <rusty@rustcorp.com.au>
  Ported to perf by Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
 Test groups of 20 processes spraying to 20 receivers 
 Block until we're ready to go 
 Tell them we're ready. 
 Wait for "GO" signal 
 Sender sprays nr_loops messages down each file descriptor 
 Now pump to every receiver. 
 One receiver per fd 
 Wait for start... 
 Receive them all 
 process mode 
 Fork the receiver. 
 process mode 
 One group of senders and receivers 
 Create the pipe between client and server 
 Now we have all the fds, fork the senders 
 Close the fds we have left 
 Return number of children to reap 
 Wait for everyone to be ready 
 Kick them off 
 Reap them all 
 reaching here is something disaster 
 SPDX-License-Identifier: GPL-2.0
  numa.c
  numa: Simulate NUMA-sensitive workload and measure their NUMA performance
 For the CLR_() macros 
  Regular printout to the terminal, suppressed if -q is specified:
  Debug printf:
 Parameters set by options: 
 Startup synchronization: 
 Task hierarchy: 
 Working set sizes: 
 Access patterns to the working set: 
 Working set initialization: 
 Misc options: 
 Affinity options -C and -N: 
 Global, read-writable area, accessible to all processes and threads: 
 Convergence latency measurement: 
 Special option string parsing callbacks: 
  To get number of numa nodes present.
  To check if given numa node is present.
  To check given numa node has cpus.
 fall back to nocpus 
 Allocate and initialize all memory on CPU#0: 
 Initialize random contents, different in each word: 
 Align to 2MB boundary: 
 Restore affinity: 
  Create a shared memory buffer that can be shared between processes, zeroed:
  Create a shared memory buffer that can be shared between processes:
  Allocate process-local memory - this will either be shared between
  threads of this process, or only be accessed by this thread:
  Return a process-shared (global) mutex:
  Return a process-shared (global) condition variable:
 Single CPU specified: 
 CPU range specified (for example: "5-11"): 
		
		  Mask length.
		  Eg: "--cpus 8_4-16#4" means: '--cpus 8_4,12_4,16_4',
		  where the _4 means the next 4 CPUs are allowed.
 Multiplicator shortcut, "0x8" is a shortcut for: "0,0,0,0,0,0,0,0" 
 Single NODE specified: 
 NODE range specified (for example: "5-11"): 
 Multiplicator shortcut, "0x8" is a shortcut for: "0,0,0,0,0,0,0,0" 
  Make sure there's real data dependency to RAM (when read
  accesses are enabled), so the compiler, the CPU and the
  kernel (KSM, zero page, etc.) cannot optimize away RAM
  accesses:
  The worker process does two types of work, a forwards going
  loop and a backwards going loop.
  We do this so that on multiprocessor systems we do not create
  a 'train' of processing, with highly synchronized processes,
  skewing the whole benchmark.
 Very simple memset() work variant: 
 Spread out by PIDTID nr and by loop nr: 
 Process data forwards: 
 Process data backwards: 
  Count the number of nodes a process's threads
  are spread out on.
  A count of 1 means that the process is compressed
  to a single node. A count of g->p.nr_nodes means it's
  spread out on the whole system.
 curr_cpu was likely still -1  {
  Count the number of distinct process-threads a node contains.
  A count of 1 means that the node contains only a single
  process. If all nodes on the system contain at most one
  process then we are well-converged.
 Strong convergence: all threads compress on a single node: 
 Not all threads have written it yet: 
	
	  Count the number of distinct process groups present
	  on nodes - when we are converged this will decrease
	  to g->p.nr_proc:
 The last thread wakes the main process. 
 Here we will wait for the main process to start us all at once: 
		
		  Amount of work to be done under a process-global lock:
 Check whether our max runtime timed out: 
 Update the summary at most once per second: 
		
		  Perturb the first task's equilibrium every g->p.perturb_secs seconds,
		  by migrating to CPU#0:
			
			  Depending on where we are running, move into
			  the other half of the system, to create some
			  real disturbance:
 Here we are running on the target CPU already 
  A worker process starts a couple of threads:
	
	  Pick up the memory policy and the CPU binding of our first thread,
	  so that we initialize memory accordingly:
 Allow all nodes by default: 
 Allow all CPUs by default: 
 THP , 0);
 Copy over options: 
 char array in count_process_nodes(): 
 Some memory should be specified: 
 Startup serialization: 
  Print a short or long result, depending on the verbosity setting:
 Child process: 
		
		  Wait for all the threads to start up. The last thread will
		  signal this process.
 Wait for all threads to be at the start_work_cond. 
 Start all threads running. 
 Parent process: 
 Initialize nonzero defaults: 
  The built-in test-suite executed by "perf bench numa -a".
  (A minimum of 4 nodes and 16 GB of RAM is recommended.)
 Basic single-stream NUMA bandwidth measurements: 
 2-stream NUMA bandwidth measurements: 
 Cross-stream NUMA bandwidth measurement: 
 Convergence latency measurements: 
 Various NUMA processthread layout bandwidth measurements: 
 SPDX-License-Identifier: GPL-2.0
  Benchmark find_next_bit and related bit operations.
  Copyright 2020 Google LLC.
 Try to avoid compiler tricks. 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2015 Davidlohr Bueso.
 For the CLR_() macros 
 inform all threads that we're done for the day 
 handle lock acquisition 
 account for thread's share of work 
 cleanup & report results 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 Davidlohr Bueso.
  Benchmark the various operations allowed for epoll_ctl(2).
  The idea is to concurrently stress a single epoll instance
 For the CLR_() macros 
  epoll related shared variables.
 Maximum number of nesting allowed inside epoll sets 
 amount of fds to monitor, per thread 
 inform all threads that we're done for the day 
 anything 
 any number 
 Let 'em loose 
 random 
		
		  Lets add 50% of the fdmap to the epoll instance, and
		  do it before any threads are started; otherwise there is
		  an initial bias of the call failing  (mod and del ops).
 a single, main epoll instance 
	
	  Deal with nested epolls, if any.
 default to the number of CPUs 
 cleanup & report results 
 HAVE_EVENTFD_SUPPORT
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2013  Davidlohr Bueso <davidlohr@hp.com>
  futex-hash: Stress the hell out of the Linux kernel futex uaddr hashing.
  This program is particularly useful for measuring the kernel's futex hash
  tablefunction implementation. In order for it to make sense, use with as
  many threads and futexes as possible.
 For the CLR_() macros 
 avoid cacheline bouncing 
			
			  We want the futex calls to fail in order to stress
			  the hashing of uaddr and not measure other steps,
			  such as internal waitqueue handling, thus enlarging
			  the critical region protected by hb->lock.
 inform all threads that we're done for the day 
 default to the number of CPUs 
 cleanup & report results 
 SPDX-License-Identifier: GPL-2.0
 used to print statistics only
 Enable ignoring missing threads when -u-p option is defined. 
 SPDX-License-Identifier: GPL-2.0
 default to TUI 
 fall through 
 fall through 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Here we're updating nr_entries _after_ we started browsing, i.e.  we have to
  forget about any reference to any entry in the underlying data structure,
  that is why we do a SEEK_SET. Think about 'perf top' in the hists browser
  after an output_resort and hist decay.
 same dir for all commands 
 SPDX-License-Identifier: GPL-2.0
  Default error logging functions
  perf_error__register - Register error logging functions
  @eops: The pointer to error logging function struct
  Register UI-specific error logging functions. Before calling this,
  other logging functions should be unregistered, if any.
  perf_error__unregister - Unregister error logging functions
  @eops: The pointer to error logging function struct
  Unregister already registered error logging functions.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 hist period print (hpp) functions 
				
				  zero-fill group members in the middle which
				  have no sample
			
			  zero-fill group members at last which have no sample
	
	  Restore original buf and size as it's where caller expects
	  the result will be saved.
 2 for a space and a % sign 
		
		  Put caller above callee when they have equal period.
	
	  At this point fmt should be completely
	  unhooked, if not it's a bug.
 sort_list may be linked by setup_sorting() 
	
	  If user specified field order, no need to setup default fields.
 append sort keys to output field 
 skip sort-only fields ("sort_compute" in perf diff) 
 append output fields to sort keys 
 reset output fields 
 reset sort keys 
  See hists__fprintf to match the column widths
 Addr + origin 
 hierarchy entries have their own hpp list 
 SPDX-License-Identifier: GPL-2.0
 The scroll bar isn't being used 
 PLT symbols contain external offsets 
	
	  This first was seen with a gcc function, _cpp_lex_token, that
	  has the usual jumps:
	 
	   1159e6c:  jne    115aa32 <_cpp_lex_token@@Base+0xf92>
	 
	  I.e. jumps to a label inside that function (_cpp_lex_token), and
	  those works, but also this kind:
	 
	   1159e8b:  jne    c469be <cpp_named_operator2name@@Base+0xa72>
	 
	   I.e. jumps to another function, outside _cpp_lex_token, which
	   are not being correctly handled generating as a side effect references
	   to ab->offset[] entries that are set to NULL, so to make this code
	   more robust, check that here.
	 
	   A proper fix for will be put in place, looking at the function
	   name right after the '<' token and probably treating this like a
	   'call' instruction.
 find next asm line 
 no asm line found forwards, try backwards 
 There are no asm lines 
 move cursor to next asm line 
  This can be called from external jumps, i.e. jumps from one function
  to another, like from the kernel's entry_SYSCALL_64 function to the
  swapgs_restore_regs_and_return_to_usermode() function.
  So all we check here is that dl->ops.target.sym is set, if it is, just
  go to that function and when exiting from its disassembly, come back
  to the calling function.
			
			  Current line focus got out of the list of most active
			  lines, NULL it so that if TAB|UNTAB is pressed, we
			  move to curr_hot (current hottest line).
 reset abort key so that it can get Ctrl-C as a key 
 for hists__scnprintf_title() 
 Percentage 
 SPDX-License-Identifier: GPL-2.0
 perf_exe()
  Usually the full path for a script is:
 	homeusernamelibexecperf-corescriptspythonxxx.py
 	homeusernamelibexecperf-corescriptsperlxxx.pl
  So 256 should be long enough to contain the full path.
  When success, will copy the full path of the selected script
  into  the buffer pointed by script_name, and return 0.
  Return -1 on failure.
 Preset the script name to SCRIPT_NAMELEN 
	
	  SLang doesn't seem to reset the whole terminal, so be more
	  forceful to get back to the original state.
 SPDX-License-Identifier: GPL-2.0
 Display a menu with individual samples to browse with perf script 
 perf_exe()
 SPDX-License-Identifier: GPL-2.0
	
	  Verify if we were at the last line and that line isn't
	  visible because we now show the header line(s).
 3 == +- toggle symbol before actual hist_entry rendering 
	
 	  FIXME: Just keeping existing behaviour, but this really should be
 	 	  before updating browser->width, as it will invalidate the
 	 	  calculation above. Fix this and the fallout in another
 	 	  changeset.
	
	  The hists__remove_entry_filter() already folds non-filtered
	  entries so we can assume it has 0 callchain rows.
 No children 
 We need this because we may not have children 
 Have children and they're unfolded 
 only check first chain list entry 
 node->parent_val list might be empty 
 skip the level, e.g. '[k] '
 account grand children 
 If it doesn't have children, no toggling performed 
 set folding state even if it's currently folded 
 Go to the start, we may be way after valid entries after a collapse 
 Debug 
 Collapse the whole world. 
 Collapse the selected entry. 
 Expand the whole world. 
 Expand the selected entry. 
 fall thru 
 for hists browser 
 for file dump 
				
				  fmt->color() already used ui_browser to
				  print the non alignment bits, skip it (+ret):
 The scroll bar isn't being used 
 the first hpp_list_node is for overhead columns 
			
			  fmt->color() already used ui_browser to
			  print the non alignment bits, skip it (+ret):
			
			  No need to call hist_entry__snprintf_alignment()
			  since this fmt is always the last column in the
			  hierarchy mode.
 The scroll bar isn't being used 
 the first hpp_list_node is for overhead columns 
 for folded sign 
 space between columns 
 The scroll bar isn't being used 
 the first hpp_list_node is for overhead columns 
 let it move to sibling 
		
		  If it's filtered, its all children also were filtered.
		  So move to sibling node.
	
	  Moves not relative to the first visible entry invalidates its
	  row_offset:
	
	  Here we have to check if nd is expanded (+), if it is we can't go
	  the next top level hist_entry, instead we must compute an offset of
	  what _not_ to show and not change the first visible entry.
	 
	  This offset increments when we are going from top to bottom and
	  decreases when we're going from bottom to top.
	 
	  As we don't have backpointers to the top level in the callchains
	  structure, we need to always print the whole hist_entry callchain,
	  skipping the first ones that are before the first visible entry
	  and stop when we printed enough lines to fill the screen.
				
				  Last unfiltered hist_entry, check if it is
				  unfolded, if it is then we should have
				  row_offset at its last entry.
 the first hpp_list_node is for overhead columns 
		
 		  XXX: Just an arbitrary lazy upper limit
 count overhead columns (in the first node) 
 add a single column for whole hierarchy sort keys
 Check whether the browser is for 'top' or 'report' 
  Only runtime switching of perf data file will make "input_name" point
  to a malloced buffer. So add "is_input_name_malloced" flag to decide
  whether we need to call free() for current "input_name" during the switch.
	
	  offer option to annotate the other branch source or target
	  (if they exists) when returning from annotate
 Display 1ms as fallback 
 force to re-evaluate folding state of callchains 
 help messages are sorted by lexical order of the hotkey 
 reset abort key so that it can get Ctrl-C as a key 
 reset key
 key came straight from options ui__popup_menu()
			
			  Exit the browser, let hists__browser_tree
			  go to the next or previous
 env->arch is NULL for live-mode (i.e. perf top) 
 menu 
				
				  Go back to the perf_evsel_menu__run or other user
				
				  No need to set actions->dso here since
				  it's just to remove the current filter.
				  Ditto for thread below.
				
				  No need to refresh, resortdecay histogram
				  entries if we are not collecting samples:
 Fall thru 
 perf script support 
			
			  Note that browser->selection != NULL
			  when browser->he_selection is not NULL,
			  so we don't need to check browser->selection
			  before fetching browser->selection->sym like what
			  we do before fetching browser->selection->map.
			 
			  See hist_browser__show_entry.
			
			  Give the calling tool a chance to populate the non
			  default evsel resorted hists tree.
 Fall thru 
 reset abort key so that it can get Ctrl-C as a key 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 FIXME uber-kludgy, see comment on cmd_report... 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 only first line can be displayed 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
				
				  Only show the top-most symbol in a callchain
				  if it's not the only callchain.
				
				  Only show the top-most symbol in a callchain
				  if it's not the only callchain.
				
				  Only show the top-most symbol in a callchain
				  if it's not the only callchain.
 Now 'iter' contains info of the last callchain_list 
		
		  XXX no way to determine where symcol column is..
		      Just use last column for now.
 the first hpp_list_node is for overhead columns 
 the first hpp_list_node is for overhead columns 
 construct merged column header since sort keys share single column 
 SPDX-License-Identifier: GPL-2.0
 Only first line can be displayed 
 SPDX-License-Identifier: GPL-2.0
 we didn't call gtk_main yet, so do it manually 
 this will also destroy all of its children 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 XXX more graceful overflow handling needed 
 SPDX-License-Identifier: GPL-2.0
	
	  FIXME: We should have a per UI backend way of showing progress,
	  stdio will just show a percentage as NN%, etc.
 SPDX-License-Identifier: GPL-2.0
		
		  The depth mask manages the output of pipes that show
		  the depth. We don't want to keep the pipes of the current
		  level for the last child of this depth.
		  Except if we have remaining filtered hits. They will
		  supersede the last child
		
		  But we keep the older depth mask for the line separator
		  to keep the level link until we reach the last child
  If have one single callchain root, don't bother printing
  its percentage (100 % in fractal mode and the same percentage
  than the hist in graph mode). This also avoid one level of column.
  However when percent-limit applied, it's possible that single callchain
  node have different (non-100% in fractal mode) percentage.
			
			  If we sort by symbol, the first entry is the same than
			  the symbol. No need to print it otherwise it appears as
			  displayed twice.
 do not add a blank line if it printed nothing 
		
		  If there's no field_sep, we still need
		  to display initial '  '.
 the first hpp_list_node is for overhead columns 
		
		  If there's no field_sep, we still need
		  to display initial '  '.
		
		  No need to call hist_entry__snprintf_alignment() since this
		  fmt is always the last column in the hierarchy mode.
		
		  dynamic entries are right-aligned but we want left-aligned
		  in the hierarchy mode
 preserve max indent depth for column headers 
 the first hpp_list_node is for overhead columns 
 combine sort headers with '  ' 
 preserve max indent depth for initial dots 
 the first hpp_list_node is for overhead columns 
 for '+' sign between column header 
 first # is displayed one level up 
		
		  If all children are filtered out or percent-limited,
		  display "no entry >= x.xx%" message.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Originally done by Vince Weaver <vincent.weaver@maine.edu> for
  perf_event_tests (git:github.comdeaterperf_event_tests)
  Powerpc needs __SANE_USERSPACE_TYPES__ before <linuxtypes.h> to select
  'int-ll64.h' and avoid compile warnings when printing __u64 with %llu.
 setup SIGIO signal handler 
 SPDX-License-Identifier: GPL-2.0
  builtin-test.c
  Builtin regression testing command: ever growing number of sanity tests
 Skip shebang 
 Then installed path. 
			
			  minus 2 to align with normal testcases.
			  For subtest we print additional '.x' in number.
			  for example:
			 
			  35: Test LLVM searching and compiling                        :
			  35.1: Basic BPF llvm compiling test                          : Ok
	
	  Tests that create BPF maps, for instance, need more than the 64K
	  default:
 SPDX-License-Identifier: GPL-2.0
  test__parse_no_sample_id_all - test parsing with no sample_id_all bit set.
  This function tests parsing data produced on kernel's that do not support the
  sample_id_all bit.  Without the sample_id_all bit, non-sample events (such as
  mmap events) do not have an id sample appended, and consequently logic
  designed to determine the id will not work.  That case happens when there is
  more than one selected event, so this test processes three events: 2
  attributes representing the selected events and one mmap event.
  Return: %0 on success, %-1 if the test fails.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Test dlfilter C API. A perf.data file is synthesized and then processed
  by perf script with a dlfilter named dlfilter-test-api-v0.so. Also a C file
  is compiled to provide a dso to match the synthesized perf.data file.
 SPDX-License-Identifier: GPL-2.0
 struct perf_sample
 emulate dso__load() 
 SPDX-License-Identifier: GPL-2.0
  bpf-script-test-relocation.c
  Test BPF loader checking relocation
	
	  Incorrect relocation. Should not allow this program be
	  loaded into kernel.
 SPDX-License-Identifier: GPL-2.0
 thread group 
 other process 
	
	  This test create 2 processes abstractions (struct thread)
	  with several threads and checks they properly share and
	  maintain maps info (struct maps).
	 
	  thread group (pid: 0, tids: 0, 1, 2, 3)
	  other  group (pid: 4, tids: 4, 5)
 create process with 4 threads 
 and create 1 separated process, without thread leader 
 test the maps pointer is shared 
	
	  Verify the other leader was created by previous call.
	  It should have shared maps with no change in
	  refcnt.
	
	  Ok, now that all the rbtree related operations were done,
	  lets remove all of them from there so that we can do the
	  refcounting tests.
 release thread group 
 release other group  
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0
	
	  Generate the event:
 SPDX-License-Identifier: GPL-2.0
  test__keep_tracking - test using a dummy software event to keep tracking.
  This function implements a test that checks that tracking events continue
  when an event is disabled but a dummy software event is not disabled.  If the
  test passes %0 is returned, otherwise %-1 is returned.
	
	  First, test that a 'comm' event can be found when the event is
	  enabled.
	
	  Secondly, test that a 'comm' event can be found when the event is
	  disabled with the dummy event still enabled.
 SPDX-License-Identifier: GPL-2.0
  Except x86_64i386 and Arm64, other archs don't support TSC in perf.  Just
  enable the test for x86_64i386 and Arm64 archs.
  test__perf_time_to_tsc - test converting perf time to TSC.
  This function implements a test that checks that the conversion of perf time
  to and from TSC is consistent with the order of events.  If the test passes
  %0 is returned, otherwise %-1 is returned.  If TSC conversion is not
  supported then then the test passes but " (not supported)" is printed.
	
	  For hybrid "cycles:u", it creates two events.
	  Init the second evsel here.
 SPDX-License-Identifier: GPL-2.0
	
	  We need to prepare evlist for stat mode running on CPU 0
	  because that's where all the stats are going to be created.
 Parse the metric into metric_events list. 
 Load the runtime stats with given numbers for events. 
 And execute the metric 
 ... cleanup. 
  DCache_L2_All_Hits = l2_rqsts.demand_data_rd_hit + l2_rqsts.pf_hit + l2_rqsts.rfo_hi
  DCache_L2_All_Miss = max(l2_rqsts.all_demand_data_rd - l2_rqsts.demand_data_rd_hit, 0) +
                       l2_rqsts.pf_miss + l2_rqsts.rfo_miss
  DCache_L2_All      = dcache_l2_all_hits + dcache_l2_all_miss
  DCache_L2_Hits     = d_ratio(dcache_l2_all_hits, dcache_l2_all)
  DCache_L2_Misses   = d_ratio(dcache_l2_all_miss, dcache_l2_all)
  l2_rqsts.demand_data_rd_hit = 100
  l2_rqsts.pf_hit             = 200
  l2_rqsts.rfo_hi             = 300
  l2_rqsts.all_demand_data_rd = 400
  l2_rqsts.pf_miss            = 500
  l2_rqsts.rfo_miss           = 600
  DCache_L2_All_Hits = 600
  DCache_L2_All_Miss = MAX(400 - 100, 0) + 500 + 600 = 1400
  DCache_L2_All      = 600 + 1400  = 2000
  DCache_L2_Hits     = 600  2000  = 0.3
  DCache_L2_Misses   = 1400  2000 = 0.7
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Generate a segfault, test perf_hooks__recover 
 hook is triggered? 
 the buggy hook is removed? 
 SPDX-License-Identifier: GPL-2.0
 For the numbers, see hists_common.c 
 perf [kernel] schedule() 
 perf [perf]   main() 
 perf [libc]   malloc() 
 perf [perf]   main() 
 will be merged 
 perf [perf]   cmd_record() 
 perf [kernel] page_fault() 
 bash [bash]   main() 
 bash [bash]   xmalloc() 
 bash [libc]   malloc() 
 bash [kernel] page_fault() 
	
	  each evsel will have 10 samples but the 4th sample
	  (perf [perf] main) will be collapsed to an existing entry
	  so total 9 entries will be in the tree.
 make sure it has no filter at first 
 default sort order (comm,dso,sym) will be used 
 setup threadsdsomapsymbols also 
 process sample events 
 now applying thread filter for 'bash' 
 normal stats should be invariant 
 but filter stats are changed 
 remove thread filter first 
 now applying dso filter for 'kernel' 
 normal stats should be invariant 
 but filter stats are changed 
 remove dso filter first 
		
		  now applying symbol filter for 'main'.  Also note that
		  there's 3 samples that have 'main' symbol but the 4th
		  entry of fake_samples was collapsed already so it won't
		  be counted as a separate entry but the sample count and
		  total period will be remained.
 normal stats should be invariant 
 but filter stats are changed 
 remove symbol filter first 
 now applying socket filters 
 normal stats should be invariant 
 but filter stats are changed 
 remove socket filter first 
 now applying all filters at once. 
 normal stats should be invariant 
 but filter stats are changed 
 tear down everything 
 SPDX-License-Identifier: GPL-2.0
 Should fail NR_ITERS times 
 Instead of evlist__new_default, don't add default events 
 SPDX-License-Identifier: GPL-2.0
  Just test if we can load the python binding.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 For the CLR_() macros 
 Fallback for kernels lacking PERF_COUNT_SW_DUMMY 
	
	  Create maps of threads and cpus to monitor. In this case
	  we start with all threads and cpus (-1, -1) but then in
	  evlist__prepare_workload we'll fill in the only thread
	  we're monitoring, the one forked there.
	
	  Prepare the workload in argv[] to run, it'll fork it, and then wait
	  for evlist__start_workload() to exec it. This is done this way
	  so that we have time to open the evlist (calling sys_perf_event_open
	  on all the fds) and then mmap them.
	
	  Config the evsels, setting attr->comm on the first one, etc.
	
	  So that we can check perf_sample.cpu on all the samples.
	
	  Call sys_perf_event_open on all the fds on all the evsels,
	  grouping them if asked to.
	
	  mmap the first fd on a given CPU and ask for events for the other
	  fds in the same CPU to be injected in the same mmap ring buffer
	  (using ioctl(PERF_EVENT_IOC_SET_OUTPUT)).
	
	  Now that all is properly set up, enable the events, they will
	  count just on workload.pid, which will start...
	
	  Now!
 Just ignore samples for now 
		
		  We don't use poll here because at least at 3.1 times the
		  PERF_RECORD_{!SAMPLE} events don't honour
		  perf_event_attr.wakeup_events, just PERF_EVENT_SAMPLE does.
 SPDX-License-Identifier: GPL-2.0
 For the numbers, see hists_common.c 
 perf [kernel] schedule() 
 perf [perf]   main() 
 perf [perf]   cmd_record() 
 bash [bash]   xmalloc() 
 bash [libc]   malloc() 
 perf [perf]   run_command() 
 perf [libc]   malloc() 
 perf [kernel] page_fault() 
 perf [kernel] sys_perf_event_open() 
 bash [libc]   free() 
 perf [libc]   free() 
 bash [libc]   malloc() 
 will be merged 
 bash [bash]   xfee() 
 bash [libc]   realloc() 
 bash [kernel] page_fault() 
	
	  each evsel will have 10 samples - 5 common and 5 distinct.
	  However the second evsel also has a collapsed entry for
	  "bash [libc] malloc" so total 9 entries will be in the tree.
	
	  Only entries from fake_common_samples should have a pair.
	
	  Leader hists (idx = 0) will have dummy entries from other,
	  and some entries will have no pair.  However every entry
	  in other hists should have (dummy) pair.
	
	  Note that we have a entry collapsed in the other (idx = 1) hists.
 default sort order (comm,dso,sym) will be used 
 setup threadsdsomapsymbols also 
 process sample events 
 match common entries 
 link common andor dummy entries 
 tear down everything 
 SPDX-License-Identifier: GPL-2.0
	 On platforms with large numbers of CPUs process_cpu_topology()
	  might issue an error while reading the perf.data file section
	  HEADER_CPU_TOPOLOGY and the cpu_topology_map pointed to by member
	  cpu is a NULL pointer.
	  Example: On s390
	    CPU 0 is on core_id 0 and physical_package_id 6
	    CPU 1 is on core_id 1 and physical_package_id 3
	 
	    Core_id and physical_package_id are platform and architecture
	    dependent and might have higher numbers than the CPU id.
	    This actually depends on the configuration.
	 
	   In this case process_cpu_topology() prints error message:
	   "socket_id number is too big. You may need to upgrade the
	   perf tool."
	 
	   This is the reason why this test might be skipped. aarch64 and
	   s390 always write this part of the header, even when the above
	   condition is true (see do_core_id_test in header.c). So always
	   run this test on those platforms.
 Test that core ID contains socket, die and core
 Test that die ID contains socket and die
 Test that socket ID contains only socket
 Test that node ID contains only node
 SPDX-License-Identifier: GPL-2.0
  The struct perf_event_attr test support.
  This test is embedded inside into perf directly and is governed
  by the PERF_TEST_ATTR environment variable and hook inside
  sys_perf_event_open function.
  The general idea is to store 'struct perf_event_attr' details for
  each event created within single perf command. Each event details
  are stored into separate text file. Once perf command is finished
  these files can be checked for values we expect for command.
  Besides 'struct perf_event_attr' values we also store 'fd' and
  'group_fd' values to allow checking for groups created.
  This all is triggered by setting PERF_TEST_ATTR environment variable.
  It must contain name of existing directory with access and write
  permissions. All the event text files are stored there.
 syscall arguments 
 struct perf_event_attr 
 First try development tree tests. 
 Then installed path. 
 SPDX-License-Identifier: GPL-2.0
 skip invalid cache type 
 skip invalid cache type 
 SPDX-License-Identifier: GPL-2.0
 Simulated format definitions. 
 Simulated users input. 
  Prepare format directory data, exported by kernel
  at sysbusevent_sourcedevices<dev>format.
 Cleanup format directory. 
	snprintf(buf, PATH_MAX, "rm -f %s\n", dir);
	if (system(buf))
		return -1;
	snprintf(buf, PATH_MAX, "rmdir %s\n", dir);
	return system(buf);
}
static struct list_head test_terms_list(void)
{
	static LIST_HEAD(terms);
	unsigned int i;
	for (i = 0; i < ARRAY_SIZE(test_terms); i++)
		list_add_tail(&test_terms[i].list, &terms);
	return &terms;
}
static int test__pmu(struct test_suite test __maybe_unused, int subtest __maybe_unused)
{
	char format = test_format_dir_get();
	LIST_HEAD(formats);
	struct list_head terms = test_terms_list();
	int ret;
	if (!format)
		return -EINVAL;
	do {
		struct perf_event_attr attr;
		memset(&attr, 0, sizeof(attr));
		ret = perf_pmu__format_parse(format, &formats);
		if (ret)
			break;
		ret = perf_pmu__config_terms("perf-pmu-test", &formats, &attr,
					     terms, false, NULL);
		if (ret)
			break;
		ret = -EINVAL;
		if (attr.config  != 0xc00000000002a823)
			break;
		if (attr.config1 != 0x8000400000000145)
			break;
		if (attr.config2 != 0x0400000020041d07)
			break;
		ret = 0;
	} while (0);
	perf_pmu__del_formats(&formats);
	test_format_dir_put(format);
	return ret;
}
DEFINE_SUITE("Parse perf pmu format", pmu);
 SPDX-License-Identifier: GPL-2.0
 For the CPU_ macros 
		
		  XXX eventually lift this restriction in a way that
		  keeps perf building on older glibc installations
		  without CPU_ALLOC. 1024 cpus in 2010 still seems
		  a reasonable upper limit tho :-)
	
	  Here we need to explicitly preallocate the counts, as if
	  we use the auto allocation it will allocate just for 1 cpu,
	  as we start by cpu 0.
 SPDX-License-Identifier: GPL-2.0
 For the numbers, see hists_common.c 
 perf [kernel] schedule() 
 perf [perf]   main() 
 perf [perf]   cmd_record() 
 perf [libc]   malloc() 
 perf [libc]   free() 
 perf [perf]   main() 
 perf [kernel] page_fault() 
 bash [bash]   main() 
 bash [bash]   xmalloc() 
 bash [kernel] page_fault() 
 default sort keys (no field) 
 equivalent to sort_order = "comm,dso,sym" 
	
	  expected output:
	 
	  Overhead  Command  Shared Object          Symbol
	  ========  =======  =============  ==============
	    20.00%     perf  perf           [.] main
	    10.00%     bash  [kernel]       [k] page_fault
	    10.00%     bash  bash           [.] main
	    10.00%     bash  bash           [.] xmalloc
	    10.00%     perf  [kernel]       [k] page_fault
	    10.00%     perf  [kernel]       [k] schedule
	    10.00%     perf  libc           [.] free
	    10.00%     perf  libc           [.] malloc
	    10.00%     perf  perf           [.] cmd_record
 mixed fields and sort keys 
	
	  expected output:
	 
	  Overhead  CPU  Command:  Pid
	  ========  ===  =============
	    30.00%    1  perf   :  100
	    10.00%    0  perf   :  100
	    10.00%    2  perf   :  100
	    20.00%    2  perf   :  200
	    10.00%    0  bash   :  300
	    10.00%    1  bash   :  300
	    10.00%    3  bash   :  300
 fields only (no sort key) 
	
	  expected output:
	 
	  Command  Overhead  Shared Object
	  =======  ========  =============
	     bash    20.00%  bash
	     bash    10.00%  [kernel]
	     perf    30.00%  perf
	     perf    20.00%  [kernel]
	     perf    20.00%  libc
 handle duplicate 'dso' field 
	
	  expected output:
	 
	  Shared Object          Symbol  Command  Overhead
	  =============  ==============  =======  ========
	           perf  [.] cmd_record     perf    10.00%
	           libc  [.] free           perf    10.00%
	           bash  [.] main           bash    10.00%
	           perf  [.] main           perf    20.00%
	           libc  [.] malloc         perf    10.00%
	       [kernel]  [k] page_fault     bash    10.00%
	       [kernel]  [k] page_fault     perf    10.00%
	       [kernel]  [k] schedule       perf    10.00%
	           bash  [.] xmalloc        bash    10.00%
 full sort keys wo overhead field 
	
	  expected output:
	 
	  CPU  Command:  Pid  Command  Shared Object          Symbol
	  ===  =============  =======  =============  ==============
	    0     perf:  100     perf       [kernel]  [k] schedule
	    2     perf:  200     perf       [kernel]  [k] page_fault
	    1     bash:  300     bash       [kernel]  [k] page_fault
	    0     bash:  300     bash           bash  [.] xmalloc
	    3     bash:  300     bash           bash  [.] main
	    1     perf:  100     perf           libc  [.] malloc
	    2     perf:  100     perf           libc  [.] free
	    1     perf:  100     perf           perf  [.] cmd_record
	    1     perf:  100     perf           perf  [.] main
	    2     perf:  200     perf           perf  [.] main
 setup threadsdsomapsymbols also 
 tear down everything 
 SPDX-License-Identifier: GPL-2.0
  Powerpc needs __SANE_USERSPACE_TYPES__ before <linuxtypes.h> to select
  'int-ll64.h' and avoid compile warnings when printing __u64 with %llu.
  PowerPC and S390 do not support creation of instruction breakpoints using the
  perf_event interface.
  Just disable the test for these architectures until these issues are
  resolved.
  This test does following:
    - detects the number of watchbreak-points,
      skip test if any is missing
    - detects PERF_EVENT_IOC_MODIFY_ATTRIBUTES ioctl,
      skip test if it's missing
    - detects if watchpoints and breakpoints share
      same slots
    - create all possible watchpoints on cpu 0
    - change one of it to breakpoint
    - in case wp and bp do not share slots,
      we create another watchpoint to ensure
      the slot accounting is correct
 SPDX-License-Identifier: GPL-2.0
  This test creates software event 'cpu-clock'
  attaches it in several ways (explained below)
  and checks that enabled and running times
  match.
 attach on newly spawned process after exec 
 attach on current process as enabled 
 attach on current process as disabled 
 attach on cpu as disabled 
 attach on cpu as enabled 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 For bsearch. We try to unwind functions in shared object. 
  The test will assert frames are on the stack but tail call optimizations lose
  the frame of the caller. Clang can disable this optimization on a called
  function but GCC currently (112020) lacks this attribute. The barrier is
  used to inhibit tail calls in these cases.
  We need to keep these functions global, despite the
  fact that they are used only locally in this object,
  in order to keep them around even if the binary is
  stripped. If they are gone, the unwind check for
  symbol fails.
	
	  The funcs[MAX_STACK] array index, based on the
	  callchain order setup.
 Any possible value should be 'thread' 
 Call unwinder twice for both callchain orders. 
	
	  make _bsearch a volatile function pointer to
	  prevent potential optimization, which may expand
	  bsearch and call compare directly from this function,
	  instead of libc shared object.
 SPDX-License-Identifier: GPL-2.0
	
	  Skip this test if user's .perfconfig doesn't set [llvm] section
	  and clang is not found in $PATH
	
	  llvm is verbosity when error. Suppress all error output if
	  not 'perf test -v'.
HAVE_LIBBPF_SUPPORT
 SPDX-License-Identifier: GPL-2.0
 page_size
 Symbol names that exactly match to the following are ignored.
		
		  Symbols which vary between passes. Passes 1 and 2 must have
		  identical symbol lists. The kallsyms_ symbols below are
		  only added after pass 1, they would be included in pass 2
		  when --all-symbols is specified so exclude them to get a
		  stable symbol list.
 Exclude linker generated symbols which vary between passes 
 ppc 
 ppc 
 Symbol names that begin with the following are ignored.
 local symbols for ARM, MIPS, etc. 
 s390 kasan local symbols 
 modversions 
 arm64 EFI stub namespace 
 arm64 non-VHE KVM namespace 
 arm64 lld 
 arm lld 
 mips lld 
 Symbol names that end with the following are ignored.
 arm 
 arm 
 arm 
 Symbol names that contain the following are ignored.
 ppc stub 
 ppc stub 
 exclude debugging symbols 
 Keep these useful absolute symbols 
	
	  Step 1:
	 
	  Init the machines that will hold kernel, modules obtained from
	  both vmlinux + .ko files and from prockallsyms split by modules.
	
	  Step 2:
	 
	  Create the kernel maps for kallsyms and the DSO where we will then
	  load prockallsyms. Also create the modules maps from procmodules
	  and find the .ko files that match them in libmodules`uname -r`.
	
	  Step 3:
	 
	  Load and split prockallsyms into multiple maps, one per module.
	  Do not use kcore, as this test was designed before kcore support
	  and has parts that only make sense if using the non-kcore code.
	  XXX: extend it to stress the kcorre code as well, hint: the list
	  of modules extracted from prockcore, in its current form, can't
	  be compacted against the list of modules found in the "vmlinux"
	  code and with the one got from procmodules from the "kallsyms" code.
	
	  Step 4:
	 
	  kallsyms will be internally on demand sorted by name so that we can
	  find the reference relocation  symbol, i.e. the symbol we will use
	  to see if the running kernel was relocated by checking if it has the
	  same value in the vmlinux file we load.
	
	  Step 5:
	 
	  Now repeat step 2, this time for the vmlinux file we'll auto-locate.
	
	  Step 6:
	 
	  Locate a vmlinux file in the vmlinux path that has a buildid that
	  matches the one of the running kernel.
	 
	  While doing that look if we find the ref reloc symbol, if we find it
	  we'll have its ref_reloc_symbol.unrelocated_addr and then
	  maps__reloc_vmlinux will notice and set proper ->[un]map_ip routines
	  to fixup the symbols.
	
	  Step 7:
	 
	  Now look at the symbols in the vmlinux DSO and check if we find all of them
	  in the kallsyms dso. For the ones that are in both, check its names and
	  end addresses too.
				
				  kallsyms don't have the symbol end, so we
				  set that by using the next symbol start - 1,
				  in some cases we get this up to a page
				  wrong, trace_kmalloc when I was developing
				  this code was one such example, 2106 bytes
				  off the real size. More than that and we
				  _really_ have a problem.
				
				  Do not count this as a failure, because we
				  could really find a case where it's not
				  possible to get proper function end from
				  kallsyms.
			
			  Ignore aliases to _etext, i.e. to the end of the kernel text area,
			  such as __indirect_thunk_end.
			
			  Ignore hidden symbols, see scriptskallsyms.c for the details
		
		  If it is the kernel, kallsyms is always "[kernel.kallsyms]", while
		  the kernel will have the path for the vmlinux file being used,
		  so use the short name, less descriptive but the same ("[kernel]" in
		  both cases.
 SPDX-License-Identifier: GPL-2.0
 test map on current pid 
 test dummy pid 
 test map on current pid 
 SPDX-License-Identifier: GPL-2.0
 pe-file.exe and pe-file.exe.debug built with;
 x86_64-w64-mingw32-gcc -o pe-file.exe pe-file.c
   -Wl,--file-alignment,4096 -Wl,--build-id
 x86_64-w64-mingw32-objcopy --only-keep-debug
   --compress-debug-sections pe-file.exe pe-file.exe.debug
 x86_64-w64-mingw32-objcopy --strip-debug
   --add-gnu-debuglink=pe-file.exe.debug pe-file.exe
 SPDX-License-Identifier: GPL-2.0
 For the numbers, see hists_common.c 
 perf [kernel] schedule() 
 perf [perf]   main() 
 perf [perf]   cmd_record() 
 perf [libc]   malloc() 
 perf [libc]   free() 
 perf [perf]   main() 
 perf [kernel] page_fault() 
 bash [bash]   main() 
 bash [bash]   xmalloc() 
 bash [kernel] page_fault() 
  Will be cast to struct ip_callchain which has all 64 bit entries
  of nr and ips[].
   schedule => run_command => main 
   main  
   cmd_record => run_command => main 
   malloc => cmd_record => run_command => main 
   free => cmd_record => run_command => main 
   main 
   page_fault => sys_perf_event_open => run_command => main 
   main 
   xmalloc => malloc => xmalloc => malloc => xmalloc => main 
   page_fault => malloc => main 
	
	  adding and deleting hist entries must be done outside of this
	  function since TEST_ASSERT_VAL() returns in case of failure.
 check callchain entries 
 TODO: handle multiple child nodes properly 
 NO callchain + NO children 
	
	  expected output:
	 
	  Overhead  Command  Shared Object          Symbol
	  ========  =======  =============  ==============
	    20.00%     perf  perf           [.] main
	    10.00%     bash  [kernel]       [k] page_fault
	    10.00%     bash  bash           [.] main
	    10.00%     bash  bash           [.] xmalloc
	    10.00%     perf  [kernel]       [k] page_fault
	    10.00%     perf  [kernel]       [k] schedule
	    10.00%     perf  libc           [.] free
	    10.00%     perf  libc           [.] malloc
	    10.00%     perf  perf           [.] cmd_record
 callchain + NO children 
	
	  expected output:
	 
	  Overhead  Command  Shared Object          Symbol
	  ========  =======  =============  ==============
	    20.00%     perf  perf           [.] main
	               |
	               --- main
	 
	    10.00%     bash  [kernel]       [k] page_fault
	               |
	               --- page_fault
	                   malloc
	                   main
	 
	    10.00%     bash  bash           [.] main
	               |
	               --- main
	 
	    10.00%     bash  bash           [.] xmalloc
	               |
	               --- xmalloc
	                   malloc
	                   xmalloc     <--- NOTE: there's a cycle
	                   malloc
	                   xmalloc
	                   main
	 
	    10.00%     perf  [kernel]       [k] page_fault
	               |
	               --- page_fault
	                   sys_perf_event_open
	                   run_command
	                   main
	 
	    10.00%     perf  [kernel]       [k] schedule
	               |
	               --- schedule
	                   run_command
	                   main
	 
	    10.00%     perf  libc           [.] free
	               |
	               --- free
	                   cmd_record
	                   run_command
	                   main
	 
	    10.00%     perf  libc           [.] malloc
	               |
	               --- malloc
	                   cmd_record
	                   run_command
	                   main
	 
	    10.00%     perf  perf           [.] cmd_record
	               |
	               --- cmd_record
	                   run_command
	                   main
	 
 NO callchain + children 
	
	  expected output:
	 
	  Children      Self  Command  Shared Object                   Symbol
	  ========  ========  =======  =============  =======================
	    70.00%    20.00%     perf  perf           [.] main
	    50.00%     0.00%     perf  perf           [.] run_command
	    30.00%    10.00%     bash  bash           [.] main
	    30.00%    10.00%     perf  perf           [.] cmd_record
	    20.00%     0.00%     bash  libc           [.] malloc
	    10.00%    10.00%     bash  [kernel]       [k] page_fault
	    10.00%    10.00%     bash  bash           [.] xmalloc
	    10.00%    10.00%     perf  [kernel]       [k] page_fault
	    10.00%    10.00%     perf  libc           [.] malloc
	    10.00%    10.00%     perf  [kernel]       [k] schedule
	    10.00%    10.00%     perf  libc           [.] free
	    10.00%     0.00%     perf  [kernel]       [k] sys_perf_event_open
 callchain + children 
	
	  expected output:
	 
	  Children      Self  Command  Shared Object                   Symbol
	  ========  ========  =======  =============  =======================
	    70.00%    20.00%     perf  perf           [.] main
	               |
	               --- main
	 
	    50.00%     0.00%     perf  perf           [.] run_command
	               |
	               --- run_command
	                   main
	 
	    30.00%    10.00%     bash  bash           [.] main
	               |
	               --- main
	 
	    30.00%    10.00%     perf  perf           [.] cmd_record
	               |
	               --- cmd_record
	                   run_command
	                   main
	 
	    20.00%     0.00%     bash  libc           [.] malloc
	               |
	               --- malloc
	                  |
	                  |--50.00%-- xmalloc
	                  |           main
	                   --50.00%-- main
	 
	    10.00%    10.00%     bash  [kernel]       [k] page_fault
	               |
	               --- page_fault
	                   malloc
	                   main
	 
	    10.00%    10.00%     bash  bash           [.] xmalloc
	               |
	               --- xmalloc
	                   malloc
	                   xmalloc     <--- NOTE: there's a cycle
	                   malloc
	                   xmalloc
	                   main
	 
	    10.00%     0.00%     perf  [kernel]       [k] sys_perf_event_open
	               |
	               --- sys_perf_event_open
	                   run_command
	                   main
	 
	    10.00%    10.00%     perf  [kernel]       [k] page_fault
	               |
	               --- page_fault
	                   sys_perf_event_open
	                   run_command
	                   main
	 
	    10.00%    10.00%     perf  [kernel]       [k] schedule
	               |
	               --- schedule
	                   run_command
	                   main
	 
	    10.00%    10.00%     perf  libc           [.] free
	               |
	               --- free
	                   cmd_record
	                   run_command
	                   main
	 
	    10.00%    10.00%     perf  libc           [.] malloc
	               |
	               --- malloc
	                   cmd_record
	                   run_command
	                   main
	 
 setup threadsdsomapsymbols also 
 tear down everything 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 kcore1 map overlaps over all bpf maps 
 kcore2 map hides behind bpf_prog_2 
 kcore3 map hides behind bpf_prog_3, kcore1 and adds new map 
 SPDX-License-Identifier: GPL-2.0
 path                alloc_name  kmod  comp   name   
 path                alloc_name   kmod  comp  name  
 path              alloc_name  kmod   comp  name  
 path   alloc_name  kmod   comp  name   
 path      alloc_name  kmod  comp  name  
 path            alloc_name  kmod  comp   name           
 path            alloc_name  kmod  comp   name           
 path     alloc_name  kmod   comp   name    
 path         alloc_name  kmod   comp   name        
 path                alloc_name  kmod   comp   name      
 SPDX-License-Identifier: GPL-2.0
 used for matching against events from generated pmu-events.c 
 used for matching against event aliases 
 extra events for aliases 
	
	  Note: For when PublicDescription does not exist in the JSON, we
	  will have no long_desc in pmu_event.long_desc, but long_desc may
	  be set in the alias.
 PMU which we should match against 
 An alias was found, ensure everything is in order 
 Verify generated events from pmu-events.c are as expected 
 ignore 3x sentinels 
 Verify aliases are as expected 
 Count how many aliases we generated 
 Count how many aliases we expect from the known table 
 Test that aliases generated are as expected 
 We're not interested in this value, only if it is valid
 Numbers are always valid. 
 The metric key itself needs to go out.. 
 The hashmap has been modified, so restart 
 Don't tolerate errors due to severity 
			
			  Add all ids with a made up value. The value may
			  trigger divide by zero when subtracted and so try to
			  make them unique.
 TODO: fail when not ok 
	
	  Add all ids with a made up value. The value may
	  trigger divide by zero when subtracted and so try to
	  make them unique.
  Parse all the metrics for current architecture,
  or all defined cpus via the 'fake_pmu'
  in parse_events.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 for the first evsel only 
 remember grouping info 
 SPDX-License-Identifier: GPL-2.0
  Hardcode the expected values for branch_entry flags.
  These are based on the input value (213) specified
  in branch_stack variable.
 PERF_FORMAT_ID is forced for PERF_SAMPLE_READ 
 3 ips 
 1 branch_entry 
 Add a bit for overrun checking 
 The data does not contain 0xff so we use that to check the size 
  test__sample_parsing - test sample parsing.
  This function implements a test that synthesizes a sample event, parses it
  and then checks that the parsed sample matches the original sample.  The test
  checks sample format bits separately and together.  If the test passes %0 is
  returned, otherwise %-1 is returned.
	
	  Fail the test if it has not been updated when new sample format bits
	  were added.  Please actually update the test rather than just change
	  the condition below.
 Test each sample format bit separately 
 Test read_format variations 
	
	  Test all sample format bits together
	  Note: PERF_SAMPLE_WEIGHT and PERF_SAMPLE_WEIGHT_STRUCT cannot
	        be set simultaneously.
 shared yb intr and user regs 
 SPDX-License-Identifier: GPL-2.0
 This one is better stores in mask. 
 This one is better stores in cpu values. 
 SPDX-License-Identifier: GPL-2.0-only
 movl $42, %ebx 
 movl $1, %eax 
 int $0x80 
 SPDX-License-Identifier: GPL-2.0
 Fill first cache page. 
 Read first cache page. 
 Fill cache boundary pages. 
 Read cache boundary pages. 
 Fill final cache page. 
 Read final cache page. 
 Read final cache page. 
 move it from utildso.c for compatibility 
 Basic 10 bytes tests. 
 Read cross multiple cache pages. 
 First iteration to fill caches, second one to read them. 
 Rest the internal dso open counter limit. 
 set as system limit 
 and this is now our dso open FDs limit 
		
		  Open dsos via dso__data_fd(), it opens the data
		  file and keep it open (unless open file limit).
 verify the first one is already open 
 open +1 dso to reach the allowed limit 
 should force the first one to be closed 
 cleanup everything 
 Make sure we did not leak any file descriptor. 
 Rest the internal dso open counter limit. 
	
	  Test scenario:
	  - create 3 dso objects
	  - set process file descriptor limit to current
	    files count + 3
	  - test that the first dso gets closed when we
	    reach the files count limit
 Make sure we are able to open 3 fds anyway 
 open dso_0 
 open dso_1 
	
	  open extra file descriptor and we just
	  reached the files count limit
 open dso_2 
	
	  dso_0 should get closed, because we reached
	  the file descriptor limit
 open dso_0 
	
	  dso_1 should get closed, because we reached
	  the file descriptor limit
 cleanup everything 
 Make sure we did not leak any file descriptor. 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 For the CLR_() macros 
  This test will generate random numbers of calls to some getpid syscalls,
  then establish an mmap for a group of events that are created to monitor
  the syscalls.
  It will receive the events, using mmap, use its PERF_SAMPLE_ID generated
  sample.id field to map back to its respective perf_evsel instance.
  Then it checks if the number of syscalls reported as perf events by
  the kernel corresponds to the number of syscalls made.
 SPDX-License-Identifier: GPL-2.0
  bpf-script-example.c
  Test basic LLVM building
 flip flag and store back 
 SPDX-License-Identifier: GPL-2.0
 Read bytes 
 Get 2 hex digits 
 Store byte and advance buf 
 End of chunk? 
	
	  objdump will display raw insn as LE if code endian
	  is LE and bytes_per_chunk > 1. In that case reverse
	  the chunk we just read.
	 
	  see disassemble_bytes() at binutilsobjdump.c for details
	  how objdump chooses display endian)
 Skip to a colon 
 Skip initial spaces 
 return number of successfully read bytes 
 read objdump data into temporary buffer 
		 copy it from temporary buffer to 'buf' according
 len returns number of bytes that could not be read 
 Ignore objdump errors 
 Do not go off the map 
 Read the object code using perf 
	
	  Converting addresses for use by objdump requires more information.
	  map__load() does that.  See map__rip_2objdump() for details.
 objdump struggles with kcore - try each map only once 
 Read the object code using objdump 
		
		  The kernel maps are inaccurate - assume objdump is right in
		  that case.
				
				  objdump cannot handle very large segments
				  that may be found in kcore.
 The results should be identical 
 for get_cpuid()
 Not available 
 Fall through: missing authorization 
 Force the use of kallsyms instead of vmlinux to try kcore 
 Load kernel map 
 2nd time through we just try kcore 
 No point getting kernel events if there is no kernel object 
				
				  Both cpus and threads are now owned by evlist
				  and will be freed by following perf_evlist__set_maps
				  call. Getting reference to keep them alive.
 SPDX-License-Identifier: GPL-2.0
 Return true if kvm module is available and loaded. Test this
  and return success when trace point kvm_s390_create_vm
  exists. Otherwise this test always fails.
	
	  The period value gets configured within evlist__config,
	  while this test executes only parse events method.
	
	  The period value gets configured within evlist__config,
	  while this test executes only parse events method.
 r1 
 syscalls:sys_enter_openat:k 
 1:1:hp 
 cpuconfig=1,name=kravau 
 cpuconfig=2u" 
 cpuconfig=1,call-graph=fp,time,period=100000 
	
	  The period, time and callgraph value gets configured within evlist__config,
	  while this test executes only parse events method.
 cpuconfig=2,call-graph=no,time=0,period=2000 
	
	  The period, time and callgraph value gets configured within evlist__config,
	  while this test executes only parse events method.
 pmu-event:u 
 cpupmu-eventu
 config=10 
 config1 
 config2=3 
 umask=1
	
	  read
	 
	  The perf_pmu__test_parse_init injects 'read' term into
	  perf_pmu_events_list, so 'read' is evaluated as read term
	  and not as raw event with 'ead' hex value.
	
	  r0xead
	 
	  To be still able to pass 'ead' value with 'r' syntax,
	  we added support to parse 'r0xHEX' event.
 instructions:k 
 cycles:upp 
 use of precise requires exclude_guest 
 faults + :ku modifier 
 cache-references + :u modifier 
 cycles:k 
 group1 syscalls:sys_enter_openat:H 
 group1 cycles:kppp 
 use of precise requires exclude_guest 
 group2 cycles + G modifier 
 group2 1:3 + G modifier 
 instructions:u 
 cycles:u + p 
 use of precise requires exclude_guest 
 instructions:kp + p 
 use of precise requires exclude_guest 
 cycles + G 
 instructions + G 
 cycles:G 
 instructions:G 
 cycles 
 cycles + :H group modifier 
 cache-misses:G + :H group modifier 
 cycles + :G group modifier 
 cache-misses:H + :G group modifier 
 cycles:G + :u group modifier 
 cache-misses:H + :u group modifier 
 cycles:G + :uG group modifier 
 cache-misses:H + :uG group modifier 
 cycles - sampling group leader 
 cache-misses - not sampling 
 branch-misses - not sampling 
 instructions - sampling group leader 
 branch-misses - not sampling 
 cycles - group leader 
 cache-misses - can not be pinned, but will go on with the leader 
 branch-misses - ditto 
 cycles - group leader 
 cache-misses - can not be pinned, but will go on with the leader 
 branch-misses - ditto 
u") == 0);
 The type of second event is randome value 
u",
u",
	
	  The perf_pmu__test_parse_init prepares perf_pmu_events_list
	  which gets freed in parse_events_terms.
 Names containing . are special and cannot be used directly 
 Remove the last '\n' 
 SPDX-License-Identifier: GPL-2.0
  evlist__prepare_workload will send a SIGUSR1 if the fork fails, since
  we asked by setting its exec_error to this handler.
  This test will start a workload that does nothing then it checks
  if the number of exit event reported by the kernel is 1 or not
  in order to check the kernel returns correct number of event.
	
	  Create maps of threads and cpus to monitor. In this case
	  we start with all threads and cpus (-1, -1) but then in
	  evlist__prepare_workload we'll fill in the only thread
	  we're monitoring, the one forked there.
 SPDX-License-Identifier: GPL-2.0
  bpf-script-test-kbuild.c
  Test include from kernel header
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  bpf-script-test-prologue.c
  Test BPF prologue
  If CONFIG_PROFILE_ALL_BRANCHES is selected,
  'if' is redefined after include kernel header.
  Recover 'if' for BPF object code.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Test support for libpfm4 event encodings.
  Copyright 2020 Google LLC.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  This test will open software clock events (cpu-clock, task-clock)
  then check their frequency -> period conversion has no artifact of
  setting period to 1 forcefully.
 collect samples 
 SPDX-License-Identifier: GPL-2.0
 Spin for 50ms 
 For checkpatch ))
 Sleep for 50ms 
		
		  Check for no missing sched_switch events i.e. that the
		  evsel->core.system_wide flag has worked.
  test__switch_tracking - test using sched_switch and tracking events.
  This function implements a test that checks that sched_switch events and
  tracking events can be recorded for a workload (current process) using the
  evsel->core.system_wide and evsel->tracking flags (respectively) with other events
  sometimes enabled or disabled.
 First event 
 Second event 
 Third event 
 Test moving an event to the front 
 Fourth event 
 Config events 
 Check moved event is still at the front 
 Check tracking event is tracking 
 Check non-tracking events are not tracking 
 Check all 4 comm events were seen i.e. that evsel->tracking works 
 Check cycles event got enabled 
 Check cycles event got disabled 
 Check cycles event got enabled again 
 SPDX-License-Identifier: GPL-2.0
 Modify watchpoint with disabled = 1 
 Not Counted 
 Enable the event 
 Counted 
 Not Counted 
 SPDX-License-Identifier: GPL-2.0
  Test backward bit in event attribute, read ring buffer from end to
  beginning
	
	  Set backward bit, ring buffer should be writing from end. Record
	  it in aux evlist
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 First try development tree tests. 
 Then installed path. 
 SPDX-License-Identifier: GPL-2.0
  Inspired by breakpoint overflow test done by
  Vince Weaver <vincent.weaver@maine.edu> for perf_event_tests
  (git:github.comdeaterperf_event_tests)
  Powerpc needs __SANE_USERSPACE_TYPES__ before <linuxtypes.h> to select
  'int-ll64.h' and avoid compile warnings when printing __u64 with %llu.
  Use ASM to ensure watchpoint and breakpoint can be triggered
  at one instruction.
		
		  This should be executed only once during
		  this test, if we are here for the 10th
		  time, consider this the recursive issue.
		 
		  We can get out of here by disable events,
		  so no new SIGIO is delivered.
 setup SIGIO signal handler 
	
	  We create following events:
	 
	  fd1 - breakpoint event on __test_function with SIGIO
	        signal configured. We should get signal
	        notification each time the breakpoint is hit
	 
	  fd2 - breakpoint event on sig_handler with SIGUSR1
	        configured. We should get SIGUSR1 each time when
	        breakpoint is hit
	 
	  fd3 - watchpoint event on __test_function with SIGIO
	        configured.
	 
	  Following processing should happen:
	    Exec:               Action:                       Result:
	    incq (%rdi)       - fd1 event breakpoint hit   -> count1 == 1
	                      - SIGIO is delivered
	    sig_handler       - fd2 event breakpoint hit   -> count2 == 1
	                      - SIGUSR1 is delivered
	    sig_handler_2                                  -> overflows_2 == 1  (nested signal)
	    sys_rt_sigreturn  - return from sig_handler_2
	    overflows++                                    -> overflows = 1
	    sys_rt_sigreturn  - return from sig_handler
	    incq (%rdi)       - fd3 event watchpoint hit   -> count3 == 1       (wp and bp in one insn)
	                      - SIGIO is delivered
	    sig_handler       - fd2 event breakpoint hit   -> count2 == 2
	                      - SIGUSR1 is delivered
	    sig_handler_2                                  -> overflows_2 == 2  (nested signal)
	    sys_rt_sigreturn  - return from sig_handler_2
	    overflows++                                    -> overflows = 2
	    sys_rt_sigreturn  - return from sig_handler
	    the_var++         - fd3 event watchpoint hit   -> count3 == 2       (standalone watchpoint)
	                      - SIGIO is delivered
	    sig_handler       - fd2 event breakpoint hit   -> count2 == 3
	                      - SIGUSR1 is delivered
	    sig_handler_2                                  -> overflows_2 == 3  (nested signal)
	    sys_rt_sigreturn  - return from sig_handler_2
	    overflows++                                    -> overflows == 3
	    sys_rt_sigreturn  - return from sig_handler
	 
	  The test case check following error conditions:
	  - we get stuck in signal handler because of debug
	    exception being triggered recursively due to
	    the wrong RF EFLAG management
	 
	  - we never trigger the sig_handler breakpoint due
	    to the wrong RF EFLAG management
	 
	
	  Kick off the test by triggering 'fd1'
	  breakpoint.
 SPDX-License-Identifier: GPL-2.0
 page_size
 Signal thread_create thread is initialized. 
 Waiting for main thread to kill us. 
 Wait for thread initialization. 
 0 is main thread 
 cleanup the main thread 
	
	  The threads_create will not return before all threads
	  are spawned and all created memory map.
	 
	  They will loop until threads_destroy is called, so we
	  can safely run synthesizing function.
	
	  All data is synthesized, try to find map for each
	  thread object.
  This test creates 'THREADS' number of threads (including
  main thread) and each thread creates memory map.
  When threads are created, we synthesize them with both
  (separate tests):
    perf_event__synthesize_thread_map (process based)
    perf_event__synthesize_threads    (global)
  We test we can find all memory maps via:
    thread__find_map
  by using all thread objects.
 perf_event__synthesize_threads synthesize 
 perf_event__synthesize_thread_map synthesize 
 SPDX-License-Identifier: GPL-2.0
 Empty union. 
 Union {foo, bar} against {}. 
 Union {foo, bar} against {foo}. 
 Union {foo, bar} against {bar,baz}. 
 Only EVENT1 or EVENT2 need be measured depending on the value of smt_on. 
 The expression is a constant 1.0 without needing to evaluate EVENT1. 
 Test toplogy constants appear well ordered. 
	
	  Source count returns the number of events aggregating in a leader
	  event including the leader. Check parsing yields an id.
 SPDX-License-Identifier: GPL-2.0
 To test SDT event, we need libelf support to scan elf binary 
 Copied from builtin-buildid-cache.c 
 Note that buildid_dir must be an absolute path 
 At first, scan itself 
 Open a cache and make sure the SDT is stored 
 TBD: probing on the SDT event and collect logs 
 Call the target and get an event 
 Cleanup temporary buildid dir 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-or-later
  This file was generated automatically by ExtUtils::ParseXS version 2.18_02 from the
  contents of Context.xs. Do not edit this file, edit Context.xs instead.
 	ANY CHANGES MADE HERE WILL BE LOST! 
  Context.xs.  XS interfaces for perf script.
  Copyright (C) 2009 Tom Zanussi <tzanussi@gmail.com>
 prototype to pass -Wmissing-prototypes 
 -W 
 prototype to pass -Wmissing-prototypes 
 -W 
 prototype to pass -Wmissing-prototypes 
 -W 
 prototype to pass -Wmissing-prototypes 
 -W 
 -W 
 SPDX-License-Identifier: GPL-2.0-or-later
  Context.c.  Python interfaces for perf script.
  Copyright (C) 2010 Tom Zanussi <tzanussi@gmail.com>
  Use Py_ssize_t for '#' formats to avoid DeprecationWarning: PY_SSIZE_T_CLEAN
  will be required for '#' formats.
 N.B. This is a return statement 
 m_name 
 m_doc 
 m_size 
 m_methods 
 m_reload 
 m_traverse 
 m_clear 
 m_free 
 Add perf_script_context to the module so it can be imported 
 SPDX-License-Identifier: GPL-2.0
 No debug information for this method 
 not yet used 
	
	  Phase 1 -- get the number of lines necessary
	
	  Phase 2 -- allocate big enough line table
                                  c->methods is the stack of inlined method calls
                                  at c->pc. [0] is the leaf method. Caller frames
                                  are ignored at the moment.
 HAVE_JVMTI_CMLR 
 HAVE_JVMTI_CMLR 
	
	 Assume path name is class hierarchy, this is a common practice with Java programs
 drop the 'L' prefix and copy up to the final '' 
		
		 append file name, we use loops and not string ops to avoid modifying
		 class_sign which is used later for the symbol name
 fallback case 
 in line_tab[] 
	
	  write source line info record if we have it
	
	  Request a JVMTI interface version 1 environment
	
	  acquire method_load capability, we require it
	  request line numbers (optional)
  jvmti_agent.c: JVMTI agent interface
  Adapted from the Oprofile code in opagent.c:
  This library is free software; you can redistribute it andor
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.
  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.
  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  Copyright 2007 OProfile authors
  Jens Wilke
  Daniel Hansel
  Copyright IBM Corporation 2007
 for mkdir() 
 for gettid() 
 check ELF signature 
	
	  we mmap the jitdump to create an MMAP RECORD in perf.data file.
	  The mmap is captured either live (perf record running when we mmap)
	  or  in deferred mode, via procPIDmaps
	  the MMAP record is used as a marker of a jitdump file for more meta
	  data info about the jitted code. Perf reportannotate detect this
	  special filename and process the jitdump file.
	 
	  mapping must be PROT_EXEC to ensure it is captured by perf record
	  even when not using -d option
	
	  check if clockid is supported
	
	  jitdump file dir
	
	  jitdump file name
	
	  create perf.data maker for the jitdump file
 don't care about 0 length function, no samples 
	
	  If JVM is multi-threaded, multiple concurrent calls to agent
	  may be possible, so protect file writes
	
	  get code index inside lock to avoid race condition
	
	  no entry to write
	
	  on disk source line info layout:
	  uint64_t : addr
	  int      : line number
	  int      : column discriminator
	  file[]   : source file name
	
	  If JVM is multi-threaded, multiple concurrent calls to agent
	  may be possible, so protect file writes
 SPDX-License-Identifier: GPL-2.0
  Used as the default ->buf value, so that people can always assume
  buf is non NULL and ->buf is NUL terminated even for a freshly
  initialized strbuf.
	
	  Note that sb->buf == strbuf_slopbuf if sb->alloc == 0, and it is
	  a static variable. Thus we have to avoid passing it to realloc.
 SPDX-License-Identifier: GPL-2.0-only
  auxtrace.c: AUX area trace support
  Copyright (c) 2013-2015, Intel Corporation.
  Make a group from 'leader' to 'last', requiring that the events were not
  already grouped to a different leader.
 Limit buffers to 32MiB on 32-bit 
 FIXME: Doesn't work for split buffer 
 PMU-agnostic options 
  Event record size is 16-bit which results in a maximum size of about 64KiB.
  Allow about 4KiB for the rest of the sample record, to give a maximum
  AUX area sample size of 60KiB.
 Arbitrary default size if no other default provided 
 Set aux_sample_size based on --aux-sample option 
 Override with aux_sample_size from config term 
 If possible, group with the AUX event 
 If possible, group with the AUX event 
 Find new leader for the group 
 Update group information 
  Please check toolsperfDocumentationperf-script.txt for information
  about the options parsed here, which is introduced after this cset,
  when support in 'perf script' for these options is introduced.
 Fall through 
 Fall through 
  In the compat mode kernel runs in 64-bit and perf tool runs in 32-bit mode,
  32-bit perf tool cannot access 64-bit value atomically, which might lead to
  the issues caused by the below sequence on multiple CPUs: when perf tool
  accesses either the load operation or the store operation for 64-bit value,
  on some architectures the operation is divided into two instructions, one
  is for accessing the low 32-bit value and another is for the high 32-bit;
  thus these two user operations can give the kernel chances to access the
  64-bit value, and thus leads to the unexpected load values.
    kernel (64-bit)                        user (32-bit)
    if (LOAD ->aux_tail) { --,             LOAD ->aux_head_lo
        STORE $aux_data      |       ,--->
        FLUSH $aux_data      |       |     LOAD ->aux_head_hi
        STORE ->aux_head   --|-------`     smp_rmb()
    }                        |             LOAD $data
                             |             smp_mb()
                             |             STORE ->aux_tail_lo
                             `----------->
                                           STORE ->aux_tail_hi
  For this reason, it's impossible for the perf tool to work correctly when
  the AUX head or tail is bigger than 4GB (more than 32 bits length); and we
  can not simply limit the AUX ring buffer to less than 4GB, the reason is
  the pointers can be increased monotonically, whatever the buffer size it is,
  at the end the head and tail can be bigger than 4GB and carry out to the
  high 32-bit.
  To mitigate the issues and improve the user experience, we can allow the
  perf tool working in certain conditions and bail out with error if detect
  any overflow cannot be handled.
  For reading the AUX head, it reads out the values for three times, and
  compares the high 4 bytes of the values between the first time and the last
  time, if there has no change for high 4 bytes injected by the kernel during
  the user reading sequence, it's safe for use the second value.
  When compat_auxtrace_mmap__write_tail() detects any carrying in the high
  32 bits, it means there have two store operations in user space and it cannot
  promise the atomicity for 64-bit write, so return '-1' in this case to tell
  the caller an overflow error has happened.
 Ensure all reads are done after we read the head 
 Ensure all reads are done after we read the head 
 Ensure all reads are done before we write the tail out 
		
		  When the buffer size is not a power of 2, 'head' wraps at the
		  highest multiple of the buffer size, so we have to subtract
		  the remainder here.
 padding must be written by fn() e.g. record__process_auxtrace() 
  struct auxtrace_cache - hash table to implement a cache
  @hashtable: the hashtable
  @sz: hashtable size (number of hlists)
  @entry_size: size of an entry
  @limit: limit the number of entries to this maximum, when reached the cache
          is dropped and caching begins again with an empty cache
  @cnt: current number of entries
  @bits: hashtable size (@sz = 2^@bits)
 Change 'tracestop' to 'stop' 
 A function with the same name, and global or the n'th found or any 
 Don't know exactly where the kernel ends, so we add a page 
 The very last symbol in kallsyms does not imply a particular size 
 Same name, and global or the n'th found or any 
 SPDX-License-Identifier: GPL-2.0-or-later
  probe-finder.c : C expression to kprobe event converter
  Written by Masami Hiramatsu <mhiramat@redhat.com>
 Kprobe tracer basic type is up to u64 
 Dwarf FL wrappers 
 Currently dummy 
 We use this table for core files too.  
 Get a Dwarf from offline image 
 Try to open distro debuginfo files 
 Set the build id for DSO_BINARY_TYPE__BUILDID_DEBUGINFO 
 if failed to open all distro debuginfo, open given binary 
  Probe finder related functions
  Convert a location into trace_arg.
  If tvar == NULL, this just checks variable can be converted.
  If fentry == true and vr_die is a parameter, do heuristic search
  for the location fuzzed by function entry mcount.
 Constant value 
 TODO: handle more than 1 exprs 
 Broken DIE ? 
		
		  This is fuzzed by fentry mcount. We try to find the
		  parameter location at the earliest address.
 TODO: Support const_value 
 Static variables on memory (not stack), make @varname 
 If this is based on frame buffer, set the offset 
 This should be a bug in DWARF or this tool 
 TODO: check all types 
 Non string type is OK 
 and respect signednesshexadecimal cast 
 This is a bitfield 
 String type 
 Add new reference with offset +0 
 No size ... try to use default type 
 Check the bitwidth 
 Save original type for next field or type 
 Get the type of this array 
 Check the pointer and dereference 
 Get the type pointed by this pointer 
 Verify it is a data structure  
 Verify it is a data structure  
 While processing unnamed field, we don't care about this 
 Get the offset of the field 
 If this member is unnamed, we need to reuse this field 
 Converting next field 
 Show a variables in kprobe event format 
 This can be found in other place. skip it 
 expr will be cached in libdw. Don't free it. 
 Find a variable in a scope DIE 
 Copy raw parameters 
 Change type separator to _ 
 Search child die for local variables and parameters. 
 Search again in global variables 
 Convert subprogram DIE to trace point 
 Verify the address is correct 
 If the DIE has entrypc, use it. 
 Try to get actual symbol name and address from symtab 
 Return probe must be on the head of a subprogram 
 Call probe_finder callback with scope DIE 
 If not a real subprogram, find a real one 
 Get the frame base attributeops from subprogram 
 Call finder's callback handler 
 Since pf->fb_ops can be a part of frame. we should free it here. 
 Skip if declared file name does not match 
 If the function name is given, that's what user expects 
 With the line number, find the nearest declared DIE 
 Keep a candidate and continue 
 Return innermost DIE 
 Find an appropriate scope fits to given conditions 
 Verify line number and address by reverse search 
 Find best match function name and lines 
 Continue if no error, because the line will be in inline function 
 Find probe point from its line number 
 Find lines which match lazy pattern 
	
	  Continue if no error, because the lazy pattern will match
	  to other lines
 Find probe points from lazy pattern  
 Matching lazy line pattern 
 Not uprobe? 
 Compiled with optimization? 
 Don't know entrypc? 
 Only FUNC and FUNC@SRC are eligible. 
 Not interested in func parameter? 
 Get probe address 
 Callback parameter with return value for libdw 
 Search function from function name 
 Check tag and diename 
 Check declared file 
 Function relative line 
 Instances always have the entry address 
 But in some case the entry address is 0 
 Real function 
 TODO: Check the address in this function 
 Inlined function: search instances 
 This could be a non-existed inline definition 
 We need to find other candidates 
 We have to clear the result 
 Exit; no same symbol in this CU. 
 Fastpath: lookup by function name from .debug_pubnames section 
 Loop on CUs (Compilation Unit) 
 Get the DIE(Debugging Information Entry) of this CU 
 Check if target file is included. 
 Find probe points from debuginfo 
 Get the call frame information from this dwarf 
 Collect available variables in this scope 
 var never be NULL 
 Copy normal argument 
 Special local variables 
 Add a found probe point into trace event list 
	
	  For some reason (e.g. different column assigned to same address)
	  This callback can be called with the address which already passed.
	  Ignore it first.
 Check number of tevs 
 Trace point should be converted from subprogram DIE 
 Expand special probe argument if exist 
 Find each argument 
 Variable should be found from scope DIE 
 Note that type can be NULL 
 Find probe_trace_events specified by perf_probe_event from debuginfo 
 Allocate result tevs array 
 Collect available variables in this scope 
 Add a found vars into available variables list 
	
	  For some reason (e.g. different column assigned to same address),
	  this callback can be called with the address which already passed.
	  Ignore it first.
 Check number of tevs 
 Trace point should be converted from subprogram DIE 
 Find local variables 
 Find external variables 
 Don't need to search child DIE for external vars. 
  Find available variables at given probe point
  Return the number of found probe points. Return 0 if there is no
  matched probe point. Return <0 if an error occurs.
 Allocate result vls array 
 Free vlist for error 
 For the kernel module, we need a special code to get a DIE 
 Get the number of relocations 
 Search the relocation related .text section 
 OK, get the section header 
 Reverse search 
 We always need to relocate the address for aranges 
 Find cu die 
 Find a corresponding line (filename and lineno) 
 Don't care whether it failed or not 
 Find a corresponding function (name, baseline and baseaddr) 
 Get function entry information 
 Function entry - Relative line number is 0 
 Track down the inline functions step by step 
 There is an inline function 
				
				  addr is at an inline function entry.
				  In this case, lineno should be the call-site
				  line number. (overwrite lineinfo)
				
				  addr is in an inline function body.
				  Since lineno points one of the lines
				  of the inline function, baseline should
				  be the entry line of the inline function.
 Verify the lineno and baseline are in a same file 
 Make a relative line number or an offset 
 Duplicate strings 
 Found a point 
 Add a line and store the src path 
 Copy source path 
 Make sure this line can be reversible 
 Find line range from its line number 
 Update status 
 Lines are not found 
	
	  We have to check all instances of inlined function, because
	  some execution paths can be optimized out depends on the
	  function argument of instances. However, if an error occurs,
	  it should be handled by the caller.
 Search function definition from function name 
 Check declared file 
 Overflow 
 Overflow 
 Fastpath: lookup by function name from .debug_pubnames section 
 Loop on CUs (Compilation Unit) 
 Get the DIE(Debugging Information Entry) of this CU 
 Check if target file is included. 
 Store comp_dir 
 debuginfod doesn't require the comp_dir but buildid is required 
  Find a src file from a DWARF tag path. Prepend optional source path prefix
  and chop off leading directories that do not exist. Result is passed back as
  a newly allocated path on success.
  Return 0 if file was found and readable, -errno otherwise.
 If not an absolute path, try to use comp_dir 
 In case of searching comp_dir, don't retry 
 SPDX-License-Identifier: GPL-2.0-only
  db-export.c: Support for exporting data suitable for import to a database
  Copyright (c) 2014, Intel Corporation.
  Export the "exec" comm. The "exec" comm is the program  application command
  name at the time it first executes. It is used to group threads for the same
  program. Note that the main thread pid (or thread group id tgid) cannot be
  used because it does not change when a new program is exec'ed.
	
	  Record the main thread for this comm. Note that the main thread can
	  have many "exec" comms because there will be a new one every time it
	  exec's. An "exec" comm however will only ever have 1 main thread.
	  That is different to any other threads for that same program because
	  exec() will effectively kill them, so the relationship between the
	  "exec" comm and non-main threads is 1-to-1. That is why
	  db_export__comm_thread() is called here for the main thread, but it
	  is called for non-main threads when they are exported.
	
	  Since the call path tree must be built starting with the root, we
	  must use ORDER_CALL for call chain resolution, in order to process
	  the callchain starting with the root node and ending with the leaf.
		
		  Handle export of symbol and dso for this node by
		  constructing an addr_location struct and then passing it to
		  db_ids_from_al() to perform the export.
 add node to the call path tree if it doesn't exist 
 Reset the callchain order to its prior value. 
 Bail because the callchain was empty. 
		
		  A thread has a reference to the main thread, so export the
		  main thread first.
		
		  Export comm before exporting the non-main thread because
		  db_export__comm_thread() can be called further below.
		
		  For a non-main thread, db_export__comm_thread() must be
		  called only if thread has not previously been exported.
 Add trace begin  end variants 
	
	  Do not export if both threads are unknown (i.e. not being traced),
	  or one is unknown and the other is the idle task.
			
			  Merge nearby areas, we walk in order
			  through the bitmap, so no need to sort.
 Cut unused entries, due to merging. 
 Print spark lines on outf for numval values in val. 
 SPDX-License-Identifier: GPL-2.0
  Compare and figure out the top N hottest streams
  Copyright (c) 2020, Intel Corporation.
  Author: Jin Yao
  The cnodes with high hit number are hot callchains.
	
	  Considering a few number of hot streams, only use simple
	  way to find the cnode with smallest hit number and replace.
 SPDX-License-Identifier: GPL-2.0
  global trace_event object used by trace_event__tp_format
  TODO There's no cleanup call for this. Add some sort of
  __exit function support and call trace_event__cleanup
  there.
  Returns pointer with encoded error via <linuxerr.h> interface.
  Returns pointer with encoded error via <linuxerr.h> interface.
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (C) 2019, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: GPL-2.0-only
  (c) 2009 Arnaldo Carvalho de Melo <acme@redhat.com>
", 7) == 0)
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
  Helper functions for handling target threadscpus
  Copyright (C) 2012, LG Electronics, Namhyung Kim <namhyung.kim@lge.com>
 CPU and PID are mutually exclusive 
 UID and PID are mutually exclusive 
 UID and CPU are mutually exclusive 
 PID and SYSTEM are mutually exclusive 
 UID and SYSTEM are mutually exclusive 
 BPF and CPU are mutually exclusive 
 BPF and PIDTID are mutually exclusive 
 BPF and UID are mutually exclusive 
 BPF and THREADS are mutually exclusive 
 THREAD and SYSTEMCPU are mutually exclusive 
 Try user name first 
		
		  The user name not found. Maybe it's a UID number.
  This must have a same ordering as the enum target_errno.
 cannot reach here 
 SPDX-License-Identifier: GPL-2.0
 rm_rf_perf_data()
	
	  Directory containing a single regular perf data file which is already
	  open, means there is nothing more to do here.
 The version is provided by DIR_FORMAT feature. 
	
	  So far we open only the header, so we can read the data version and
	  layout.
 Cleanup whatever we managed to create so far. 
 currently it allows stdio for pipe only 
	
	  Only fire a warning, don't return error, continue fill
	  original file.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2011, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
  Parts came from builtin-annotate.c, see those files for further
  copyright notes.
 hex_width()
 FIXME: For the HE_COLORSET 
  FIXME: Using the same values as slang.h,
  but that header may not be available everywhere
		 Indirect call can use a non-rip register and offset: callq  0x8(%rbx).
  Prevents from matching commas in the comment section, e.g.:
  ffff200008446e70:       b.cs    ffff2000084470f4 <generic_exec_single+0x314>   b.hs, b.nlast
  and skip comma as part of function arguments, e.g.:
  1d8b4ac <linemap_lookup(line_maps const, unsigned int)+0xcc>
	
	  Examples of lines to parse for the _cpp_lex_token@@Base
	  function:
	 
	  1159e6c: jne    115aa32 <_cpp_lex_token@@Base+0xf92>
	  1159e8b: jne    c469be <cpp_named_operator2name@@Base+0xa72>
	 
	  The first is a jump to an offset inside the same function,
	  the second is to another function, i.e. that 0xa72 is an
	  offset in the cpp_named_operator2name@@base function.
	
	  skip over possible up to 2 operands to get to address, e.g.:
	  tbnz	 w0, #26, ffff0000083cd190 <security_file_permission+0xd0>
	
	  FIXME: things like this in _cpp_lex_token (gcc's cc1 program):
		cpp_named_operator2name@@Base+0xa72
	  Point to a place that is after the cpp_named_operator2name
	  boundaries, i.e.  in the ELF symbol table for cc1
	  cpp_named_operator2name is marked as being 32-bytes long, but it in
	  fact is much larger than that, so we seem to need a symbols__find()
	  routine that looks for >= current->start and  < next_symbol->start,
	  possibly just for C++ objects?
	 
	  For now lets just make some progress by marking jumps to outside the
	  current function as call like.
	 
	  Actual navigation will come next, with further understanding of how
	  the symbol searching and disassembly should be done.
 check for 3-op insn 
 mirror arch objdump's space-after-comma style 
	
	  Add buffer of one element for zero length symbol.
	  When sample is taken from first instruction of
	  zero length symbol, perf still resolves it and
	  shows symbol name in perf report and allows to
	  annotate it.
 Check for overflow when calculating sizeof_sym_hist 
 Check for overflow in zalloc argument 
 The cycles histogram is lazily allocated. 
	
	  For now we can only account one basic block per
	  final jump. But multiple could be overlapping.
	  Always account the longest one. So when
	  a shorter one has been already seen throw it away.
	 
	  We separately always account the full cycles.
	
	  Only set start when IPC can be computed. We can only
	  compute it when the basic block is completely in a single
	  function.
	  Special case the case when the jump is elsewhere, but
	  it starts on the function start.
 Hide data when there are too many overlaps. 
  Allocating the disasm annotation line data with
  following structure:
     -------------------------------------------
     struct disasm_line | struct annotation_line
     -------------------------------------------
  We have 'struct annotation_line' member as last member
  of 'struct disasm_line' to have an easy access.
 mark red for >75% coverage 
 mark dull for <1% coverage 
 mark dull for <1% coverage 
		
		  Find matching branch to our target.
			
			  The percentage of coverage joined at this target in relation
			  to the next branch.
			
			  The percentage of coverage leaving at this branch, and
			  its prediction ratio.
		
		  Also color the filename and line if needed, with
		  the same color than the percentage. Don't print it
		  twice for close colored addr with the same filename:line
 %s", al->path);
  symbol__parse_objdump_line() parses objdump output (with -d --no-show-raw)
  which looks like following
   0000000000415500 <_init>:
     415500:       sub    $0x8,%rsp
     415504:       mov    0x2f5ad5(%rip),%rax        # 70afe0 <_DYNAMIC+0x2f8>
     41550b:       test   %rax,%rax
     41550e:       je     415515 <_init+0x15>
     415510:       callq  416e70 <__gmon_start__@plt>
     415515:       add    $0x8,%rsp
     415519:       retq
  it will be parsed and saved into struct disasm_line as
   <offset>       <name>  <ops.raw>
  The offset will be a relative offset from the start of the symbol and -1
  means that it's not a disassembly line so should be treated differently.
  The ops.raw part will be parsed further according to type of the instruction.
 filename:linenr ? Save line number and ignore. 
 Process hex address followed by ':'. 
 kcore has no symbols, so add the call target symbol 
	
	  old style build-id cache has name of XXXXXXXXX.. while
	  new style has XXXXXXXXX..{elf,kallsyms,vdso}.
	  extract the build-id part of dirname in the new style only.
		
		  If we don't have build-ids or the build-id file isn't in the
		  cache, or is just a kallsyms file, well, lets hope that this
		  DSO is the same as when 'perf record' ran.
 defined(HAVE_LIBBFD_SUPPORT) && defined(HAVE_LIBBPF_SUPPORT)
 defined(HAVE_LIBBFD_SUPPORT) && defined(HAVE_LIBBPF_SUPPORT)
  Possibly create a new version of line with tabs expanded. Returns the
  existing or new line, storage is updated if a new line is allocated. If
  allocation fails then NULL is returned.
	
	  Space for the line and '\0', less the leading and trailing
	  spaces. Each tab may introduce 7 additional spaces.
	
	  Copy regions starting at src and expand tabs. If there are two
	  adjacent tabs then 'src == i', the memcpy is of size 0 and the spaces
	  are inserted.
 Expand the last region. 
 Will be the objdump command to run. 
 Will be the symfs path. 
 Create a pipe to read from for stdout 
		
		  If we were using debug info should retry with
		  original binary.
 Storage for getline. 
 Skip lines containing "filename:" 
		
		  The source code line number (lineno) needs to be kept in
		  across calls to symbol__parse_objdump_line(), so that it
		  can associate it with the instructions till the next one.
		  See disasm_line__new() and struct disasm_line::line_nr.
	
	  kallsyms does not have symbol sizes so there may a nop at the end.
	  Remove it.
 filtered by max_lines 
			
			  Filtered by min_pcnt or non IP lines when
			  context != 0
 PLT symbols contain external offsets 
		
		  FIXME: Oops, no jump target? Buggy disassembler? Or do we
		  have to adjust to the previous offset?
			
			  FIXME: short term bandaid to cope with assembly
			  routines that comes with labels in the same column
			  as the address in objdump, sigh.
			 
			  E.g. copy_user_generic_unrolled
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 TID 
 PID 
 "Name" 
 "Raw" 
 "Count" 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2011, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
  Parts came from builtin-{top,stat,record}.c, see those files for further
  copyright notes.
 page_size
  evlist__set_id_pos - set the positions of event ids.
  @evlist: selected event list
  Events with compatible sample types all have the same id_pos
  and is_pos.  For convenience, put a copy on evlist.
 Adding a handler for an event not in this evlist, just ignore it.
 to capture ABI version 
	
	  Reset the per evsel cpu_iter. This is needed because
	  each evsel's cpumap may have a different index space,
	  and some operations need the index to modify
	  the FD xyarray (e.g. open, close)
 If at least one event is enabled, evlist is enabled. 
 Disable 'immediate' events last 
	
	  If we disabled only single event, we need to check
	  the enabled state of the evlist manually.
	
	  Even single event sets the 'enabled' for evlist,
	  so the toggle can work properly and toggle to
	  'disabled' state.
 Synthesized events have an id of zero 
		
		  When the perf_mmap() call is made we grab one refcount, plus
		  one extra to let perf_mmap__consume() get the last
		  events after all real references (perf_mmap__get()) are
		  dropped.
		 
		  Each PERF_EVENT_IOC_SET_OUTPUT points to this mmap and
		  thus does perf_mmap__get() on it.
		
		  Pick a once upon a time good value, i.e. things look
		  strange since we can't read a sysctl value, but lets not
		  die yet...
 we got file size value 
 we got pages count value 
 leave number of pages at 0 
 round pages up to next power of 2 
  evlist__mmap_ex - Create mmaps to receive events.
  @evlist: list of events
  @pages: map length in pages
  @overwrite: overwrite older events?
  @auxtrace_pages - auxtrace map length in pages
  @auxtrace_overwrite - overwrite older auxtrace data?
  If @overwrite is %false the user needs to signal event consumption using
  perf_mmap__write_tail().  Using evlist__mmap_read() does this
  automatically.
  Similarly, if @auxtrace_overwrite is %false the user needs to signal data
  consumption using auxtrace_mmap__write_tail().
  Return: %0 on success, negative error code otherwise.
	
	  Delay setting mp.prot: set it before calling perf_mmap__mmap.
	  Its value is decided by evsel's write_backward.
	  So &mp should not be passed through const pointer.
	
	  If specify '-a' and '--per-thread' to perf record, perf record
	  will override '--per-thread'. target->per_thread = false and
	  target->system_wide = true.
	 
	  If specify '--per-thread' only to perf record,
	  target->per_thread = true and target->system_wide = false.
	 
	  So target->per_thread && target->system_wide is false.
	  For perf record, thread_map__new_str doesn't call
	  thread_map__new_all_cpus. That will keep perf record's
	  current behavior.
	 
	  For perf stat, it allows the case that target->per_thread and
	  target->system_wide are all true. It means to collect system-wide
	  per-thread data. thread_map__new_str will call
	  thread_map__new_all_cpus to enumerate all threads.
 as evlist now has references, put count here 
		
		  filters only work for tracepoint event, which doesn't have cpu limit.
		  So evlist and evsel should always be same.
 PERF_SAMPLE_READ implies PERF_FORMAT_ID. 
	
	  With perf record core.cpus is usually NULL.
	  Use the old method to handle this for now.
	
	  Try reading sysdevicessystemcpuonline to get
	  an all cpus map.
	 
	  FIXME: -ENOMEM is the best we can do here, the cpu_map
	  code needs an overhaul to properly forward the
	  error, and we may not want to do that fallback to a
	  default cpu identity map :-\
	
	  Default: one fd per CPU, all threads, aka systemwide
	  as sys_perf_event_open(cpu = -1, thread = -1) is EINVAL
		
		  Change the name of this process not to confuse --exclude-perf users
		  that sees 'perf' in the window up to the execvp() and thinks that
		  perf samples are not being excluded.
		
		  Tell the parent we're ready to go
		
		  Wait until the parent tells us to go.
		
		  The parent will ask for the execvp() to be performed by
		  writing exactly one byte, in workload.cork_fd, usually via
		  evlist__start_workload().
		 
		  For cancelling the workload without actually running it,
		  the parent will just close workload.cork_fd, without writing
		  anything, i.e. read will return zero and we just exit()
		  here.
	
	  wait for child to settle
		
		  Remove the cork, let it rip!
  Events in data file are not collect in groups, but we still want
  the group display. Set the artificial group and set the leader's
  forced_leader flag to notify the display code.
	
	  for_each_group_member doesn't work here because it doesn't
	  include the first entry.
			
			  Set this for all former members of the group
			  to indicate they get reopened.
	
	  O_RDWR avoids POLLHUPs which is necessary to allow the other
	  end of a FIFO to be repeatedly opened and closed.
 O_RDWR | O_NONBLOCK means the other end need not be open 
 no argument 
 there's argument 
 malformed 
	
	  For some platforms, the 'mem-loads' event is required to use
	  together with 'mem-loads-aux' within a group and 'mem-loads-aux'
	  must be the group leader. Now we disable this group before reporting
	  because 'mem-loads-aux' is just an auxiliary event. It doesn't carry
	  any valid memory load information.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
  CTF writing support via babeltrace.
  Copyright (C) 2014, Jiri Olsa <jolsa@redhat.com>
  Copyright (C) 2014, Sebastian Andrzej Siewior <bigeasy@linutronix.de>
 writer primitives 
 data types 
 Ordered events configured queue size. 
 unsigned long are mostly pointers 
	
	  value_mask = (1 << (size  8 - 1)) - 1.
	  Directly set value_mask for code readers.
		
		  For 64 bit value, return it self. There is no need
		  to fill high bit.
 Fall through 
 BUG! 
 If it is a positive value, don't adjust. 
 Fill upper part of value_int with 1 to make it a negative long long. 
	
	  missing:
	    PERF_SAMPLE_TIME         - not needed as we have it in
	                               ctf event header
	    PERF_SAMPLE_READ         - TODO
	    PERF_SAMPLE_RAW          - tracepoint fields are handled separately
	    PERF_SAMPLE_BRANCH_STACK - TODO
	    PERF_SAMPLE_REGS_USER    - TODO
	    PERF_SAMPLE_STACK_USER   - TODO
  Currently we have no other way to determine the
  time for the stream flush other than keep track
  of the number of events and check it against
  threshold.
 update stats 
 If dup < 0, add a prefix. Else, add _dupl_X suffix. 
	
	  Add '_' prefix to potential keywork.  According to
	  Mathieu Desnoyers (https:lore.kernel.orglkml1074266107.40857.1422045946295.JavaMail.zimbra@efficios.com),
	  further CTF spec updating may require us to use '$'.
 alias was already assigned 
 If 'name' is a keywork, add prefix. 
		
		  A string is an array of chars. For this we use the string
		  type and don't care that it is an array. What we don't
		  support is an array of strings.
	
	  missing:
	    PERF_SAMPLE_TIME         - not needed as we have it in
	                               ctf event header
	    PERF_SAMPLE_READ         - TODO
	    PERF_SAMPLE_CALLCHAIN    - TODO
	    PERF_SAMPLE_RAW          - tracepoint fields and BPF output
	                               are handled separately
	    PERF_SAMPLE_BRANCH_STACK - TODO
	    PERF_SAMPLE_REGS_USER    - TODO
	    PERF_SAMPLE_STACK_USER   - TODO
	
	  Try to get the number of cpus used in the data file,
	  if not present fallback to the MAX_CPUS.
 and NULL all the pointers 
 CTF writer 
 CTF clock 
 CTF stream class 
 CTF clock stream setup 
 Add cpu_id for packet context 
 CTF clock writer setup 
 perf.data session 
 CTF writer 
 CTF writer envclock setup  
 CTF events setup 
 SPDX-License-Identifier: GPL-2.0
 class arg 
  demangle Java symbol between str and end positions and stores
  up to maxlen characters into buf. The parser starts in mode.
  Use MODE_PREFIX to process entire prototype till end position
  Use MODE_TYPE to process return type if str starts on return type char
   Return:
 	success: buf
 	error  : NULL
 safe because at least one other char to process 
  Demangle Java function signature (openJDK, not GCJ)
  input:
  	str: string to parse. String is not modified
     flags: combination of JAVA_DEMANGLE_ flags to modify demangling
  return:
 	if input can be demangled, then a newly allocated string is returned.
 	if input cannot be demangled, then NULL is returned
  Note: caller is responsible for freeing demangled string
 find start of return type 
	
	  expansion factor estimated to 3x
		
		  get return type first
 add space between return type and function prototype 
 process function up to return type 
 SPDX-License-Identifier: GPL-2.0
 Thread holds first ref to nsdata. 
		
		  Remove it from the dead threads list, as last reference is
		  gone, if it is in a dead threads list.
		 
		  We may not be there anymore if say, the machine where it was
		  stored was already deleted, so we already removed it from
		  the dead threads and some other piece of code still keeps a
		  reference.
		 
		  This is what 'perf sched' does and finally drops it in
		  perf_sched__lat(), where it calls perf_sched__read_events(),
		  that processes the events by creating a session and deleting
		  it, which ends up destroying the list heads for the dead
		  threads, but before it does that it removes all threads from
		  it using list_del_init().
		 
		  So we need to check here if it is in a dead threads list and
		  if so, remove it before finally deleting the thread, to avoid
		  an use after free situation.
		
		  setns syscall must have changed few or all the namespaces
		  of this thread. Update end time for the namespaces
		  previously used.
	
	  'last' with no start time might be the parent's comm of a synthesized
	  thread (created by processing a synthesized fork event). For a main
	  thread, that is very probably wrong. Prefer a later comm to avoid
	  that case.
 Override the default :tid entry 
 CHECKME: it should probably better return the max comm len from its comm list 
 This is new thread, we share map groups for process. 
 But this one is new process, copy maps. 
 SPDX-License-Identifier: GPL-2.0
	
	  cannot set it twice
 str may be NULL in case no arg is passed to -I 
 because str is read-only 
 just printing available regs 
 default to all possible regs 
 SPDX-License-Identifier: GPL-2.0
 Operators 
 Logical AND 
 Logical OR 
 Logical NOT 
 End search 
 Escape and special case: '!' is also used in glob pattern 
 Exchg last OP->r with AND 
 Exchg the root with OR 
 Add NOT as a leaf node 
 Recursively parses inside the parenthesis 
  Parse filter rule and return new strfilter.
  Return NULL if fail, and ep == NULL if memory allocation failed.
 OR 
 AND 
 NOT 
 Return true if STR matches the filter rules 
 sprint node in parenthesis if needed 
 don't need to check node->l 
 SPDX-License-Identifier: GPL-2.0-or-later
  probe-event.c : perf-probe definition to probe_events format converter
  Written by Masami Hiramatsu <mhiramat@redhat.com>
 For __maybe_unused 
 Dry run flag 
 Initialize symbol maps and path of vmlinuxmodules 
 already initialized 
 ref_reloc_sym is just a label. Need a special fix
 A file path -- this is an offline module 
 short_name is "[module]" 
 Init maps of given executable or kernel 
  @module can be module name of module file path. In case of path,
  inspect elf and find out what is actual module name.
  Caller has to free mod_name after using it.
	
	  NOTE:
	  '.gnu.linkonce.this_module' section of kernel module elf directly
	  maps to 'struct module' from linuxmodule.h. This section contains
	  actual module name which will be used by kernel after loading it.
	  But, we cannot use 'struct module' here since linuxmodule.h is not
	  exposed to user-space. Offset of 'name' has remained same from long
	  time, so hardcoding it here.
 expect ELFCLASS64 by default 
  Some binaries like glibc have special symbols which are on the symbol
  table, but not in the debuginfo. If we can find the address of the
  symbol from map, we can translate the address back to the probe point.
 This can work only for function-name based one 
 Find the address of given function 
 Open new debuginfo of given module 
 For caching the last debuginfo 
 If the module is NULL, it should be the kernel. 
 Copy module path 
  Convert trace point to probe point with debuginfo
 convert the address to dwarf address 
 If the module is given, this returns relative address 
 Adjust symbol name and address 
		
		  If the address is in the inittext section, map can not
		  find it. Ignore it if we are probing offline kernel.
 If we have no realname, use symbol for it 
  Rename DWARF symbols to ELF symbols -- gcc sometimes optimizes functions
  and generate new symbols with suffixes such as .constprop.N or .isra.N
  etc. Since those symbols are not recorded in DWARF, we have to find
  correct generated symbols from offline ELF binary.
  For online kernel or uprobes we don't need this because those are
  rebased on _text, or already a section relative address.
 Prepare a map for offline binary 
 point.address is the address of point.symbol + point.offset 
 Skip post process if the target is an offline kernel 
		
		  If we found a wrong one, mark it by NULL symbol.
		  Since addresses in debuginfo is same as objdump, we need
		  to convert it to addresses on memory.
 If we have no realname, use symbol for it 
 Post processing the probe events 
 Currently ref_reloc_sym based probe is not for drivers 
 Try to find perf_probe_event with debuginfo 
	 Workaround for gcc #98776 issue.
	  Perf failed to add kretprobe event with debuginfo of vmlinux which is
	  compiled by gcc with -fpatchable-function-entry option enabled. The
	  same issue with kernel module. The retprobe doesn`t need debuginfo.
	  This workaround solution use map to query the probe function address
	  for retprobe event.
 Searching trace events corresponding to a probe event 
 Not found, retry with an alternative 
			
			  Write back to the original probe_event for
			  setting appropriate (user given) event name
 Succeeded to find trace events 
 No error but failed to find probe point. 
 Error path : ntevs < 0 
  Show line-range always requires debuginfo to find source file and
  line number.
 Search a line range 
 Not found, retry with an alternative 
 Convert source file path 
 Free old path when new path is assigned 
 Skip to starting line number 
 Not found, retry with an alternative 
 Release the old probe_point 
 Some variables are found 
		
		  A probe point might be converted to
		  several trace points.
 Show available variables on given probe point 
 !HAVE_DWARF_SUPPORT 
 Check the name is good for event, group or function 
  Stuff 'lr' according to the line range described by 'arg'.
  The line range syntax is described by:
          SRC[:SLN[+NUM|-ELN]]
          FNC[@SRC][:SLN[+NUM|-ELN]]
				
				  Adjust the number of lines here.
				  If the number of lines == 1, the
				  the end of line should be equal to
				  the start of line.
 We reuse it for checking funcname 
 Invalid name 
 Parse probepoint definition. 
	
	  <Syntax>
	  perf probe [GRP:][EVENT=]SRC[:LN|;PTN]
	  perf probe [GRP:][EVENT=]FUNC[@SRC][+OFFS|%return|:LN|;PAT]
	  perf probe %[GRP:]SDT_EVENT
 This must be a target file name or build id 
 Event name 
	
	  Check arg is function or file name and copy it.
	 
	  We consider arg to be a file spec if and only if it satisfies
	  all of the below criteria::
	  - it does not include any of "+@%",
	  - it includes one of ":;", and
	  - it has a period '.' in the name.
	 
	  Otherwise, we consider arg to be a function specification.
 This is a file spec if it includes a '.' before ; or : 
		
		  Keep pp->function even if this is absolute address,
		  so it can mark whether abs_address is valid.
		  Which make 'perf probe lib.bin 0x0' possible.
		 
		  Note that checking length of tmp is not needed
		  because when we access tmp[1] we know tmp[0] is '0',
		  so tmp[1] should always valid (but could be '\0').
 Parse other options 
 Lazy pattern must be the last part 
 let leave escapes 
 Line number 
 Byte offset from a symbol 
 File name 
 Probe places 
 Others not supported yet 
 Buggy case 
 Exclusion check 
 Parse perf-probe event argument 
 user attr 
 Type setting 
 A variable, register, symbol or special value 
 Structure fields or array element 
 Array 
 Structure 
 If no name is specified, set the last field name (not array index)
 Parse perf-probe event command 
 Parse probe point 
 Generate event name if needed 
 Copy arguments and ensure return probe has no C argument 
 Returns true if any ARG is either C variable, $params or $vars. 
 Return true if this perf_probe_event requires debuginfo 
 Parse probe_events event into struct probe_point 
 Scan event and group name. 
 Scan module name(if there), function name and offset 
 only the address started with 0x 
		
		  Fix a special case:
		  if address == 0, kernel reports something like:
		  p:probe_libcabs_0 liblibc-2.18.so:0x          (null) arg1=%ax
		  Newer kernel may fix that, but we want to
		  support old kernel also.
 Only the symbol-based probe has offset 
 We don't need which register is assigned. 
 TODO: parse regs and offset 
 Compose only probe arg 
 Compose only probe point (not argument) 
 Argument name or separator 
 Special case: @XXX 
 Dereferencing arguments 
 Print argument value 
 Closing 
 Print argument type 
 Uprobes must have tp->module 
	
	  If tp->address == 0, then this point must be a
	  absolute address uprobe.
	  try_to_find_absolute_address() should have made
	  tp->symbol to "0x0".
 Use the tp->address for uprobes 
 Absolute address. See try_to_find_absolute_address() 
 Convert eventgroup name 
 Convert trace_point to probe_point 
 Convert trace_arg to probe_arg 
 Synthesize only event probe point 
 Show an event 
 At first, check the event name itself 
 Next, check the combination of name and group 
 Cleanup cached debuginfo if needed 
 List up current perf-probe events 
 Cut off the dot suffixes (e.g. .const, .isra) and version suffixes 
 Try no suffix number 
 Try to add suffix 
 Final validation 
 Warn if the current kernel's uprobe implementation is old 
 Old uprobe event doesn't support memory dereference 
 Set new name from original perf_probe_event and namelist 
 If probe_event or trace_event already have the name, reuse it 
 Or generate new one from probe point 
 Get an unused new event name 
	
	  Add new event name to namelist if multiprobe event is NOT
	  supported, since we have to use new event name for following
	  probes in that case.
 Get current event names 
 Open the kprobeuprobe_events 
 Skip if the symbol is out of .text or blacklisted 
 Set new name for tev (and update namelist) 
		
		  Probes after the first probe which comes from same
		  user input are always allowed to add suffix, because
		  there might be several addresses corresponding to
		  one code line.
 Possible permission error to load symbols 
 If user gives a version, don't cut off the version from symbols 
 We don't care about default symbol or not 
  Find probe function addresses from map.
  Return an error or the number of found probe_trace_event
	
	  Load matched symbols: Since the different local symbols may have
	  same name but different addresses, this lists all the symbols.
 Note that the symbols in the kmodule are not relocated 
 Setup result trace-probe-events 
 There can be duplicated symbols in the map 
 Add one probe point 
 Check the kprobe (not in module) is within .text  
 Skip it 
	
	  This is 'perf probe liblibc.so 0xabcd'. Try to probe at
	  absolute address.
	 
	  Only one tev can be generated by this.
	
	  Don't use tp->offset, use address directly, because
	  in synthesize_probe_trace_command() address cannot be
	  zero.
	
	  Give it a '0x' leading symbol name.
	  In __add_probe_trace_events, a NULL symbol is interpreted as
	  invalid.
 For kprobe, check range 
 Concatenate two arrays 
 Concatenate the array of probe_trace_event 
  Try to find probe_trace_event from given probe caches. Return the number
  of cached events found, if an error occurs return the error.
 Return 0 ("not found") if the target has no probe cache. 
 Skip the cache entry which has no name 
 Try to find probe_trace_event from all probe caches 
 Get the buildid list of all valid caches 
 In the case of cnt == 0, we just skip it 
 For SDTcached events, we use special search functions 
 SDT must be in the cache 
 Set the uprobes attribute as same as original 
 Set group name if not given 
 At first, we need to lookup cache entry 
 SDT can be found only in the cache 
 Found in probe cache 
 Convert perf_probe_event with debuginfo 
 Found in debuginfo or got an error 
 Loop 1: convert all events 
 Init kprobe blacklist if needed 
 Convert with or without debuginfo 
 This just release blacklist only if allocated 
 Showing definition always go stdout 
 Skip if the symbol is out of .text or blacklisted 
 Set new name for tev (and update namelist) 
 Skip if the symbol is out of .text or blacklisted 
 Set new name for tev (and update namelist) 
 Loop 2: add all events 
 Loop 3: cleanup and free trace events  
 Get current event names 
 Get a symbol map 
 Show all (filtered) symbols 
 SPDX-License-Identifier: GPL-2.0-only
  intel_pt.c: Intel Processor Trace support
  Copyright (c) 2013-2015, Intel Corporation.
 applicable_counters is 64-bits 
 perf_time__ranges_skip_sample does not work if time is zero 
	
	  In the case of vm_time_correlation, the overlap might contain TSC
	  packets that will not be fixed, and that will then no longer work for
	  overlap detection. Avoid that by zeroing out the overlap.
 Do not drop buffers with references - refer intel_pt_get_trace() 
 Must be serialized with respect to intel_pt_get_trace() 
  This function assumes data is processed sequentially only.
  Must be serialized with respect to intel_pt_lookahead()
 Ignoring cache creation failure 
 Assumes 64-bit kernel 
 No support for non-zero CS base 
 Load maps to ensure dso->is_64_bit has been updated 
	
	  Didn't lookup in the 'to_ip' case, so do it now to prevent duplicate
	  entries.
 Ignore cache errors 
 No support for decoding guest user space 
 Add 1 to callchain_sz for callchain context 
 INTEL_PT_LBR_0, INTEL_PT_LBR_1 and INTEL_PT_LBR_2 
  Cannot count CBR as skipped because it won't go away until cbr == cbr_seen.
  Also ensure CBR is first non-skipped event by allowing for 4 more samples
  from this decoder state.
	
	  perf report cannot handle events without a branch stack when using
	  SORT_MODE__BRANCH so make a dummy one.
	
	  Zero IP is used to mean "trace start" but that is not the case for
	  power or PTWRITE events with no IP, so clear the flags.
  PEBS gp_regs array indexes plus 1 so that 0 means not present. Refer
  intel_pt_add_gp_regs().
 Get the PEBS gp_regs array index 
		
		  Add only registers that were requested (i.e. 'regs_mask') and
		  that were provided (i.e. 'mask'), and update the resulting
		  mask (i.e. 'intr_regs->mask') accordingly.
	
	  If there are any XMM registers, then there should be all of them.
	  Nevertheless, follow the logic to add only registers that were
	  requested (i.e. 'regs_mask') and that were provided (i.e. 'mask'),
	  and update the resulting mask (i.e. 'intr_regs->mask') accordingly.
 Refer kernel's intel_pmu_store_pebs_lbrs() 
 No support for non-zero CS base 
		
		  Refer kernel's setup_pebs_adaptive_sample_data() and
		  intel_hsw_weight().
			
			  Starts from SPR, the mem access latency field
			  contains both cache latency [47:32] and instruction
			  latency [15:0]. The cache latency is the same as the
			  mem access latency on previous platforms.
			 
			  In practice, no memory access could last than 4G
			  cycles. Use latency >> 32 to distinguish the
			  different format of the mem access latency field.
 Cycles last block 
 Refer kernel's intel_hsw_transaction() 
 For RTM XABORTs also log the abort code from AX 
	
	  Do PEBS first to allow for the possibility that the PEBS timestamp
	  precedes the current timestamp.
			
			  perf cannot handle having different machines for ip
			  and addr, so create 2 branches.
  To filter against time ranges, it is only necessary to look at the next start
  or end time.
 Next time is an end time 
 Next time is a start time 
 No next time 
 After start time, so consider next time 
 No end time 
 Check against end time 
 Before start time, so fast forward 
 After end time, so consider next time 
 No next time range, so stop decoding 
 Check against next start time 
 Before end time 
 Use estimated TSC upon return to user space 
 Use estimated TSC in unknown switch state 
	
	  If the current tid has not been updated yet, ensure it is now that
	  a "switch in" event has occurred.
 Invalidate all instruction cache entries that overlap the text poke 
 Assume text poke begins in a basic block no more than 4096 bytes 
			
			  No overlap. Working backwards there cannot be another
			  basic block that overlaps the text poke if there is a
			  branch instruction before the text poke address.
 Dump here now we have copied a piped trace out of the pipe 
		
		  We don't use the hardware index, but the sample generation
		  code uses the new format branch_stack with this field,
		  so the event attributes must indicate that it's present.
 Find least TSC which converts to ns or later 
 Find greatest TSC which converts to ns or earlier 
		
		  Take care to ensure the TSC range matches the perf-time range
		  when converted back to perf-time.
 No kvm support 
 Currently TSC Offset is calculated using MTC packets 
	
	  Since this thread will not be kept in any rbtree not in a
	  list, initialize its list node so that at thread__put() the
	  current thread lifetime assumption is kept and we don't segfault
	  at list_del_init().
 Maximum non-turbo ratio is TSC freq  100 MHz 
		
		  Additional branch stack size to cater for tracing from the
		  actual sample ip to where the sample time is recorded.
		  Measured at about 200 branches, but generously set to 1024.
		  If kernel space is not being traced, then add just 1 for the
		  branch to kernel space.
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 e.g. offset of jited_prog_insns 
 e.g. offset of jited_prog_len 
	int	size_offset;	 > 0: offset of rec size,
				  < 0: fix size of -size_offset
 step 1: get array dimensions 
 step 2: calculate total size of all arrays 
 kernel is too old to support this field 
 clear the bit 
 step 3: allocate continuous memory 
 step 4: fill data to info_linear->info 
 step 5: call syscall again to get required arrays 
 step 6: verify the data 
 step 7: update info_len and data_len 
 SPDX-License-Identifier: GPL-2.0
  Copyright IBM Corp. 2018
  Auxtrace support for s390 CPU-Measurement Sampling Facility
  Author(s):  Thomas Richter <tmricht@linux.ibm.com>
  Auxiliary traces are collected during 'perf record' using rbd000 event.
  Several PERF_RECORD_XXX are generated during recording:
  PERF_RECORD_AUX:
 	Records that new data landed in the AUX buffer part.
  PERF_RECORD_AUXTRACE:
 	Defines auxtrace data. Followed by the actual data. The contents of
 	the auxtrace data is dependent on the event and the CPU.
 	This record is generated by perf record command. For details
 	see Documentationperf.data-file-format.txt.
  PERF_RECORD_AUXTRACE_INFO:
 	Defines a table of contains for PERF_RECORD_AUXTRACE records. This
 	record is generated during 'perf record' command. Each record contains
 	up to 256 entries describing offset and size of the AUXTRACE data in the
 	perf.data file.
  PERF_RECORD_AUXTRACE_ERROR:
 	Indicates an error during AUXTRACE collection such as buffer overflow.
  PERF_RECORD_FINISHED_ROUND:
 	Perf events are not necessarily in time stamp order, as they can be
 	collected in parallel on different CPUs. If the events should be
 	processed in time order they need to be sorted first.
 	Perf report guarantees that there is no reordering over a
 	PERF_RECORD_FINISHED_ROUND boundary event. All perf records with a
 	time stamp lower than this record are processed (and displayed) before
 	the succeeding perf record are processed.
  These records are evaluated during perf report command.
  1. PERF_RECORD_AUXTRACE_INFO is used to set up the infrastructure for
  auxiliary trace data processing. See s390_cpumsf_process_auxtrace_info()
  below.
  Auxiliary trace data is collected per CPU. To merge the data into the report
  an auxtrace_queue is created for each CPU. It is assumed that the auxtrace
  data is in ascending order.
  Each queue has a double linked list of auxtrace_buffers. This list contains
  the offset and size of a CPU's auxtrace data. During auxtrace processing
  the data portion is mmap()'ed.
  To sort the queues in chronological order, all queue access is controlled
  by the auxtrace_heap. This is basically a stack, each stack element has two
  entries, the queue number and a time stamp. However the stack is sorted by
  the time stamps. The highest time stamp is at the bottom the lowest
  (nearest) time stamp is at the top. That sort order is maintained at all
  times!
  After the auxtrace infrastructure has been setup, the auxtrace queues are
  filled with data (offsetsize pairs) and the auxtrace_heap is populated.
  2. PERF_RECORD_XXX processing triggers access to the auxtrace_queues.
  Each record is handled by s390_cpumsf_process_event(). The time stamp of
  the perf record is compared with the time stamp located on the auxtrace_heap
  top element. If that time stamp is lower than the time stamp from the
  record sample, the auxtrace queues will be processed. As auxtrace queues
  control many auxtrace_buffers and each buffer can be quite large, the
  auxtrace buffer might be processed only partially. In this case the
  position in the auxtrace_buffer of that queue is remembered and the time
  stamp of the last processed entry of the auxtrace_buffer replaces the
  current auxtrace_heap top.
  3. Auxtrace_queues might run of out data and are fed by the
  PERF_RECORD_AUXTRACE handling, see s390_cpumsf_process_auxtrace_event().
  Event Generation
  Each sampling-data entry in the auxiliary trace data generates a perf sample.
  This sample is filled
  with data from the auxtrace such as PIDTID, instruction address, CPU state,
  etc. This sample is processed with perf_session__deliver_synth_event() to
  be included into the GUI.
  4. PERF_RECORD_FINISHED_ROUND event is used to process all the remaining
  auxiliary traces entries until the time stamp of this record is reached
  auxtrace_heap top. This is triggered by ordered_event->deliver().
  Perf event processing.
  Event processing of PERF_RECORD_XXX entries relies on time stamp entries.
  This is the function call sequence:
  __cmd_report()
  |
  perf_session__process_events()
  |
  __perf_session__process_events()
  |
  perf_session__process_event()
  |  This functions splits the PERF_RECORD_XXX records.
  |  - Those generated by perf record command (type number equal or higher
  |    than PERF_RECORD_USER_TYPE_START) are handled by
  |    perf_session__process_user_event(see below)
  |  - Those generated by the kernel are handled by
  |    evlist__parse_sample_timestamp()
  |
  evlist__parse_sample_timestamp()
  |  Extract time stamp from sample data.
  |
  perf_session__queue_event()
  |  If timestamp is positive the sample is entered into an ordered_event
  |  list, sort order is the timestamp. The event processing is deferred until
  |  later (see perf_session__process_user_event()).
  |  Other timestamps (0 or -1) are handled immediately by
  |  perf_session__deliver_event(). These are events generated at start up
  |  of command perf record. They create PERF_RECORD_COMM and PERF_RECORD_MMAP
  |  records. They are needed to create a list of running processes and its
  |  memory mappings and layout. They are needed at the beginning to enable
  |  command perf report to create process trees and memory mappings.
  |
  perf_session__deliver_event()
  |  Delivers a PERF_RECORD_XXX entry for handling.
  |
  auxtrace__process_event()
  |  The timestamp of the PERF_RECORD_XXX entry is taken to correlate with
  |  time stamps from the auxiliary trace buffers. This enables
  |  synchronization between auxiliary trace data and the events on the
  |  perf.data file.
  |
  machine__deliver_event()
  |  Handles the PERF_RECORD_XXX event. This depends on the record type.
     It might update the process tree, update a process memory map or enter
     a sample with IP and call back chain data into GUI data pool.
  Deferred processing determined by perf_session__process_user_event() is
  finally processed when a PERF_RECORD_FINISHED_ROUND is encountered. These
  are generated during command perf record.
  The timestamp of PERF_RECORD_FINISHED_ROUND event is taken to process all
  PERF_RECORD_XXX entries stored in the ordered_event list. This list was
  built up while reading the perf.data file.
  Each event is now processed by calling perf_session__deliver_event().
  This enables time synchronization between the data in the perf.data file and
  the data in the auxiliary trace buffers.
 Check if the raw data should be dumped to file. If this is the case and
  the file to dump to has not been opened for writing, do so.
  Return 0 on success and greater zero on error so processing continues.
 Queue not yet allocated 
 See comment above for -4 
 Display s390 CPU measurement facility basic-sampling data entry
  Data written on s390 in big endian byte order and contains bit
  fields across byte boundaries.
 Display s390 CPU measurement facility diagnostic-sampling data entry.
  Data written on s390 in big endian byte order and contains bit
  fields across byte boundaries.
 Return TOD timestamp contained in an trailer entry 
	 te->t set: TOD in STCKE format, bytes 8-15
	  to->t not set: TOD in STCK format, bytes 0-7
 Display s390 CPU measurement facility trailer entry 
 Test a sample data block. It must be 4KB or a multiple thereof in size and
  4KB page aligned. Each sample data page has a trailer entry at the
  end which contains the sample entry data sizes.
  Return true if the sample data block passes the checks and set the
  basic set entry size and diagnostic set entry size.
  Return false on failure.
  Note: Old hardware does not set the basic or diagnostic entry sizes
  in the trailer entry. Use the type number instead.
 Illegal size 
 No basic set entry, must be first 
 Check for trailer entry at end of SDB 
 Very old hardware, use CPUID 
 Illegal trailer entry 
 Return true if there is room for another entry 
 Dump an auxiliary buffer. These buffers are multiple of
  4KB SDB pages.
	 s390 kernel always returns 4KB blocks fully occupied,
	  no partially filled SDBs.
 Handle Basic entry 
 Handle Diagnostic entry 
 Check for trailer entry 
 Show trailer entry 
			 Set descriptor sizes in case of old hardware
			  where these values are not set.
 Native LPAR mode 
 Guest kerneluser space 
 Use heuristics on old hardware 
 TOD_CLOCK_BASE value missing 
	 Correct calculation to convert time stamp in trailer entry to
	  nano seconds (taken from archs390 function tod_to_ns()).
	  TOD_CLOCK_BASE is stored in trailer entry member progusage2.
 Process the data samples of a single queue. The first parameter is a
  pointer to the queue, the second parameter is the time stamp. This
  is the time stamp:
  - of the event that triggered this processing.
  - or the time stamp when the last processing of this queue stopped.
    In this case it stopped at a 4KB page boundary and record the
    position on where to continue processing on the next invocation
    (see buffer->use_data and buffer->use_size).
  When this function returns the second parameter is updated to
  reflect the time stamp of the last processed auxiliary data entry
  (taken from the trailer entry of that page). The caller uses this
  returned time stamp to record the last processed entry in this
  queue.
  The function returns:
  0:  Processing successful. The second parameter returns the
      time stamp from the trailer entry until which position
      processing took place. Subsequent calls resume from this
      position.
  <0: An error occurred during processing. The second parameter
      returns the maximum time stamp.
  >0: Done on this queue. The second parameter returns the
      maximum time stamp.
	 Get trailer entry time stamp and check if entries in
	  this auxiliary page are ready for processing. If the
	  time stamp of the first entry is too high, whole buffer
	  can be skipped. In this case return time stamp.
 Handle Basic entry 
 Skip diagnostic entry 
 Check for trailer entry 
 Check existence of next page 
 Buffer completely scanned or error 
 Run the s390 auxiliary trace decoder.
  Select the queue buffer to operate on, the caller already selected
  the proper queue, depending on second parameter 'ts'.
  This is the time stamp until which the auxiliary entries should
  be processed. This value is updated by called functions and
  returned to the caller.
  Resume processing in the current buffer. If there is no buffer
  get a new buffer from the queue and setup start position for
  processing.
  When a buffer is completely processed remove it from the queue
  before returning.
  This function returns
  1: When the queue is empty. Second parameter will be set to
     maximum time stamp.
  0: Normal processing done.
  <0: Error during queue buffer setup. This causes the caller
      to stop processing completely.
	 Get buffer and last position in buffer to resume
	  decoding the auxiliary entries. One buffer might be large
	  and decoding might stop in between. This depends on the time
	  stamp of the trailer entry in each page of the auxiliary
	  data and the time stamp of the event triggering the decoding.
 Processing done on this queue 
 Start with a new buffer on this queue 
 Write into log file 
 Write into log file 
	 If non-zero, there is either an error (err < 0) or the buffer is
	  completely done (err > 0). The error is unrecoverable, usually
	  some descriptors could not be read successfully, so continue with
	  the next buffer.
	  In both cases the parameter 'ts' has been updated.
 Buffer done, no error 
 Handle event with raw data 
 Dump here after copying piped trace out of the pipe 
 Check itrace options set on perf report command.
  Return true, if none are set or all options specified can be
  handled on s390 (currently only option 'd' for logging.
  Return false otherwise.
 Check for AUXTRACE dump directory if it is needed.
  On failure print an error message but continue.
  Return 0 on wrong keyword in config file and 1 otherwise.
 No kvm support 
 SPDX-License-Identifier: GPL-2.0-only
 Manage a cache of file names' existence 
 No LRU, only use when bounded in some other way. 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2009, Steven Rostedt <srostedt@redhat.com>
 If it fails, the next read will report it 
	
	  Just skip it, now that we configure libtraceevent to use the
	  toolsperf symbol resolver.
	 
	  We need to skip it so that we can continue parsing old perf.data
	  files, that contains this prockallsyms payload.
	 
	  Newer perf.data files will have just the 4-bytes zeros "kallsyms
	  payload", so that older tools can continue reading it and interpret
	  it as "no kallsyms payload is present".
 it can have 0 size 
		
		  The commit field in the page is of type long,
		  use that instead, since it represents the kernel.
 it can have 0 size 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook 
 perf_cpu_map uses sysdevicessystemcpuonline
 BPF_MAP_TYPE_PERCPU_ARRAY uses sysdevicessystemcpupossible
 Sometimes possible > online, like on a Ryzen 3900X that has 24
 threads but its possible showed 0-31 -acme
 someone pinned the map in parallel? 
 determine filter type based on target 
	
	  save leader_skel for install_pe, which is called within
	  following evsel__open_per_cpu call
	
	  Step 1: hold a fd on the leader program and the bpf_link, if
	  the program is not already gone, reload the program.
	  Use flock() to ensure exclusive access to the perf_event_attr
	  map.
	
	  The bpf_link holds reference to the leader program, and the
	  leader program holds reference to the maps. Therefore, if
	  link_id is valid, diff_map_id should also be valid.
	
	  bperf uses BPF_PROG_TEST_RUN to get accurate reading. Check
	  whether the kernel support it
 Step 2: load the follower skeleton 
 attach fexit program to the leader program 
 connect to leader diff_reading map 
 set up reading map 
 set up follower filter based on target 
  trigger the leader prog on each cpu, so the accum_reading map could get
  the latest readings.
  bperf: share hardware PMCs with BPF
  perf uses performance monitoring counters (PMC) to monitor system
  performance. The PMCs are limited hardware resources. For example,
  Intel CPUs have 3x fixed PMCs and 4x programmable PMCs per cpu.
  Modern data center systems use these PMCs in many different ways:
  system level monitoring, (maybe nested) container level monitoring, per
  process monitoring, profiling (in sample mode), etc. In some cases,
  there are more active perf_events than available hardware PMCs. To allow
  all perf_events to have a chance to run, it is necessary to do expensive
  time multiplexing of events.
  On the other hand, many monitoring tools count the common metrics
  (cycles, instructions). It is a waste to have multiple tools create
  multiple perf_events of "cycles" and occupy multiple PMCs.
  bperf tries to reduce such wastes by allowing multiple perf_events of
  "cycles" or "instructions" (at different scopes) to share PMUs. Instead
  of having each perf-stat session to read its own perf_events, bperf uses
  BPF programs to read the perf_events and aggregate readings to BPF maps.
  Then, the perf-stat session(s) reads the values from these BPF maps.
                                 ||
        shared progs and maps <- || -> per session progs and maps
                                 ||
    ---------------              ||
    | perf_events |              ||
    ---------------       fexit  ||      -----------------
           |             --------||----> | follower prog |
        ---------------         || ---  -----------------
  cs -> | leader prog |         ||        |         |
    --> ---------------         ||  --------------  ------------------
          |         |          ||  | filter map |  | accum_readings |
    ------------  ------------  ||  --------------  ------------------
  |  | prev map |  | diff map |  ||                        |
  |  ------------  ------------  ||                        |
   \                             ||                        |
  = \ ==================================================== | ============
     \                                                       user space
      \                                                  
       \                                                
     BPF_PROG_TEST_RUN                    BPF_MAP_LOOKUP_ELEM
         \                                            
          \                                          
           \------  perf-stat ----------------------
  The figure above shows the architecture of bperf. Note that the figure
  is divided into 3 regions: shared progs and maps (top left), per session
  progs and maps (top right), and user space (bottom).
  The leader prog is triggered on each context switch (cs). The leader
  prog reads perf_events and stores the difference (current_reading -
  previous_reading) to the diff map. For the same metric, e.g. "cycles",
  multiple perf-stat sessions share the same leader prog.
  Each perf-stat session creates a follower prog as fexit program to the
  leader prog. It is possible to attach up to BPF_MAX_TRAMP_PROGS (38)
  follower progs to the same leader prog. The follower prog checks current
  task and processor ID to decide whether to add the value from the diff
  map to its accumulated reading map (accum_readings).
  Finally, perf-stat user space reads the value from accum_reading map.
  Besides context switch, it is also necessary to trigger the leader prog
  before perf-stat reads the value. Otherwise, the accum_reading map may
  not have the latest reading from the perf_events. This is achieved by
  triggering the event via sys_bpf(BPF_PROG_TEST_RUN) to each CPU.
  Comment before the definition of struct perf_event_attr_map_entry
  describes how different sessions of perf-stat share information about
  the leader prog.
 SPDX-License-Identifier: LGPL-2.1 
  Bump the memlock so that we can get bpf maps of a reasonable size,
  like the ones used with 'perf trace' and with 'perf test bpf',
  improve this to some specific request if needed.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  dwarf-regs.c : Mapping of DWARF debug register numbers into register names.
  Written by: Masami Hiramatsu <mhiramat@kernel.org>
 ARM 64 bit 
 Define const char  {arch}_register_tbl[] 
 Return architecture dependent register string (for kprobe-tracer) 
 Generic arch - use host arch 
 SPDX-License-Identifier: GPL-2.0
  Replaces all occurrences of a char used with the:
  -t, --field-separator
  option, that uses a special separator character and don't pad with spaces,
  replacing all occurrences of this separator in symbol names (and other
  output) with a '.' character, that thus it's the only non valid separator.
 --sort pid 
 --sort comm 
  We can't use pointer comparison in functions below,
  because it gives different results based on pointer
  values, which could break some sorting assumptions.
 --sort dso 
 --sort symbol 
	
	  comparing symbol address alone is not enough since it's a
	  relative address within a dso.
 --sort srcline 
 --sort srcline_from 
 --sort srcline_to 
 --sort srcfile 
 --sort parent 
 --sort cpu 
 --sort cgroup_id 
 --sort cgroup 
 --sort socket 
 --sort time 
 --sort trace 
	
	  Trim the buffer, it starts at 4KB and we're not going to
	  add anything more to this buffer.
 sort keys for branch stacks 
 --sort daddr_sym 
 group event types together 
 if both are NULL, jump to sort on al_addr instead 
	
	  Addresses with no majorminor numbers are assumed to be
	  anonymous in userspace.  Sort those on pid then address.
	 
	  The kernel and non-zero majorminor mapped areas are
	  assumed to be unity mapped.  Sort those on address.
 userspace anonymous 
 al_addr does all the right addr - start + offset calculations 
 print [s] for shared data mmaps 
 :XX<space> 
 --sort symbol_size 
 --sort dso_size 
		
		  hist entry is filtered if any of sort key in the hpp list
		  is applied.  But it should skip non-matched filter types.
 length for print hex numbers 
 parse pretty print result and update max length 
 record max width for output 
 find match evsel using a given event name.  The event name can be:
    1. '%' + event index (e.g. '%1' for first event)
    2. full event name (e.g. sched:sched_switch)
    3. partial event name (should not contain ':')
 case 1 
 case 2 
 case 3 
	
	  Check to see if there are any arch specific
	  sort dimensions not applicable for the current
	  architecture. If so, Skip that sort key since
	  we don't want to display it in the output fields.
			
			  perf diff displays the performance difference amongst
			  two or more perf.data files. Those files could come
			  from different binaries. So we should not compare
			  their ips, but the name of symbol.
	
	  Append '+'-prefixed sort order to the default sort
	  order string.
	
	  We allocate new sort_order string, but we never free it,
	  because it's checked over the rest of the code.
  Adds 'pre,' prefix into 'str' is 'pre' is
  not already part of 'str'.
			
			  If user specified field order but no sort order,
			  we'll honor it and not add default sort orders.
	
	  Prepend overhead fields for backward compatibility.
	
	  It makes no sense to elide all of sort entries.
	  Just revert them to show up again.
	
	  perf diff doesn't use default hpp output fields.
 copy sort keys to output fields 
 and then copy output fields to sort keys 
 setup hists-specific output fields 
 SPDX-License-Identifier: GPL-2.0
 mangled OCaml symbols start with "caml" followed by an upper-case letter 
  input:
      sym: a symbol which may have been mangled by the OCaml compiler
  return:
      if the input doesn't look like a mangled OCaml symbol, NULL is returned
      otherwise, a newly allocated string containing the demangled symbol is returned
 the demangled symbol is always smaller than the mangled symbol 
 skip "caml" prefix 
 "__" -> "." 
 "$xx" is a hex-encoded character 
 SPDX-License-Identifier: GPL-2.0
  perf_hooks.c
  Copyright (C) 2016 Wang Nan <wangnan0@huawei.com>
  Copyright (C) 2016 Huawei Inc.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2015, Wang Nan <wangnan0@huawei.com>
  Copyright (C) 2015, Huawei Inc.
		
		  Make buf_sz always have obe byte extra space so we
		  can put '\0' there.
	
	  If buf is string, give it terminal '\0' to make our life
	  easier. If buf is not string, that '\0' is out of space
	  indicated by read_sz so caller won't even notice it.
llvm.org\n"
llvm.orggitllvm.git\n"
llvm.orggitclang.git\n\n"
apt.llvm.org\n\n"
 _UTSNAME_LENGTH is 65 
		
		  Don't fall through: it may breaks saved_kbuild_dir and
		  saved_kbuild_include_opts if detect them again when
		  memory is low.
	
	  This is an optional work. Even it fail we can continue our
	  work. Needn't check error return.
	
	  Since we may reset clang's working dir, path of source file
	  should be transferred into absolute path, except we want
	  stdin to be source file (testing).
 SPDX-License-Identifier: GPL-2.0
 Should perhaps be moved to struct machine 
		
		  If we race with comm_str__put, iter->refcnt is 0
		  and it will be removed within comm_str__put call
		  shortly, ignore it in this search.
 SPDX-License-Identifier: GPL-2.0
 env->arch is NULL for live-mode (i.e. perf top) 
 SPDX-License-Identifier: GPL-2.0
 Choose bigger one to alloc 
 This reuses cmdname->len for similarity index 
 SPDX-License-Identifier: GPL-2.0-only
  JSON export.
  Copyright (C) 2021, CodeWeavers Inc. <nfraser@codeweavers.com>
 Outputs a JSON-encoded string surrounded by quotes with characters escaped.
 required escapes with special forms as per RFC 8259
 all other control characters must be escaped by hex code
 Outputs an optional comma, newline and indentation to delimit a new value
 from the previous one in a JSON object or array.
 Outputs a printf format string (with delimiter) as a JSON value.
 Outputs a JSON key-value pair where the value is a string.
 Outputs a JSON key-value pair where the value is a printf format string.
 The opening brace is printed manually because it isn't delimited from a
 previous value (i.e. we don't want a leading newline)
 Version number for future-proofing. Most additions should be able to be
 done in a backwards-compatible way so this should only need to be bumped
 if some major breaking change must be made.
 Output headers
 Output samples
 SPDX-License-Identifier: GPL-2.0
 Skip "." and ".." directories 
 only interested in proper numerical dirents 
 perf-stat expects threads to be generated even if tid not given 
		
		  We're reading 16 bytes, while filename__read_str
		  allocates data per BUFSIZ bytes, so we can safely
		  mark the end of the string.
 dummy pid comm initialization 
	
	  The comm name is like extra bonus ;-),
	  so just warn if we fail for any reason.
	
	  Free the 'idx' item and shift the rest up.
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  Generic non-thread safe hash map implementation.
  Copyright (c) 2019 Facebook
 make sure libbpf doesn't use kernel-only integer typedefs 
 prevent accidental re-addition of reallocarray() 
 start with 4 buckets 
 grow if empty or more than 75% filled 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2017 Hari Bathini, IBM Corporation
	 Check if the mount namespaces differ, if so then indicate that we
	  want to switch as part of looking up dsomap data.
	 If we're dealing with a process that is in a different PID namespace,
	  attempt to work out the innermost tgid for the process.
 Use tgid if CONFIG_PID_NS is not defined. 
			 If innermost tgid is not the first, process is in a different
			  PID namespace.
		 Init may fail if the process exits while we're trying to look
		  at its proc information.  In that case, save the pid but
		  don't try to enter the namespace.
 SPDX-License-Identifier: GPL-2.0-only
	
	  The evsels are created with hybrid pmu's cpus. But now we
	  need to check and adjust the cpus of evsel by cpu_list because
	  cpu_list may cause conflicts with cpus of evsel. For example,
	  cpus of evsel is cpu0-7, but the cpu_list is cpu6-8, we need
	  to adjust the cpus of evsel to cpu6-7. And then propatate maps
	  in evlist__create_maps().
 SPDX-License-Identifier: GPL-2.0
 Missing or explicit false to turn off colorization 
 any normal truth value defaults to 'auto' 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: LGPL-2.1
 Copyright (C) 2018, 2019 Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 Android's 'bionic' library, for one, doesn't have this 
 HAVE_GET_CURRENT_DIR_NAME
 SPDX-License-Identifier: GPL-2.0
  Post mortem Dwarf CFI based unwinding on top of regs and stack dumps.
  Lots of this code have been borrowed or heavily inspired from parts of
  the libunwind 0.99 code which are (amongst other contributors I may have
  forgotten):
  Copyright (C) 2002-2007 Hewlett-Packard Co
 	Contributed by David Mosberger-Tang <davidm@hpl.hp.com>
  And the bugs have been added by:
  Copyright (C) 2010, Frederic Weisbecker <fweisbec@gmail.com>
  Copyright (C) 2012, Jiri Olsa <jolsa@redhat.com>
 format of the encoded value 
 how the value is to be applied 
 Pointer-encoding formats: 
 pointer-sized unsigned value 
 unsigned 32-bit value 
 unsigned 64-bit value 
 signed 32-bit value 
 signed 64-bit value 
 Pointer-encoding application: 
 absolute value 
 rel. to addr. of encoded value 
  The following are not documented by LSB v1.3, yet they are used by
  GCC, presumably they aren't documented by LSB since they aren't
  used on Linux:
 start-of-procedure-relative 
 aligned pointer 
 Flags intentionally not handled, since they're not needed:
  #define DW_EH_PE_indirect      0x80
  #define DW_EH_PE_uleb128       0x01
  #define DW_EH_PE_udata2        0x02
  #define DW_EH_PE_sleb128       0x09
  #define DW_EH_PE_sdata2        0x0a
  #define DW_EH_PE_textrel       0x20
  #define DW_EH_PE_datarel       0x30
	
	  The rest of the header is variable-length and consists of the
	  following members:
	 
	 	encoded_t eh_frame_ptr;
	 	encoded_t fde_count;
 A single encoded pointer should not be more than 8 bytes. 
	
	  struct {
	     encoded_t start_ip;
	     encoded_t fde_addr;
	  } binary_search_table[fde_count];
 We dont need eh_frame_ptr, just skip it. 
 Check the .eh_frame section for unwinding info 
	 debug_frame can reside in:
	   - dso
	   - debug pointed by symsrc_filename
	   - gnu_debuglink, which doesn't necessary
	     has to be pointed by symsrc_filename
 Check the .eh_frame section for unwinding info 
 Check the .debug_frame section for unwinding info 
 Don't support write, probably not needed. 
 Check overflow. 
 Don't support write, I suspect we don't need it. 
	
	  If we need more than one entry, do the DWARF
	  unwind itself.
			
			  Decrement the IP for any non-activation frames.
			  this is required to properly find the srcline
			  for caller frames.
			  See also the documentation for dwfl_frame_pc(),
			  which this code tries to replicate.
	
	  Display what we got based on the order setup.
 SPDX-License-Identifier: GPL-2.0
 fall through 
 SPDX-License-Identifier: GPL-2.0-only
  call-path.h: Manipulate a tree data structure containing function call paths
  Copyright (c) 2014, Intel Corporation.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2011-2017, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
  Parts came from evlist.c builtin-{top,stat,record}.c, see those files for further
  copyright notes.
 sysconf()
 page_size 
 !HAVE_LIBNUMA_SUPPORT 
			
			  Use cblock.aio_fildes value different from -1
			  to denote started aio write operation on the
			  cblock so it requires explicit record__aio_sync()
			  call prior the cblock may be reused again.
			
			  Allocate cblocks with priority delta to have
			  faster aio write system calls because queued requests
			  are kept in separate per-prio queues and adding
			  a new request will iterate thru shorter per-prio
			  list. Blocks with numbers higher than
			   _SC_AIO_PRIO_DELTA_MAX go with priority 0.
 !HAVE_AIO_SUPPORT 
 map c index to online cpu index 
 SPDX-License-Identifier: GPL-2.0
  Add the missing ones, we need to build on many distros...
 available for all events, NMI safe 
 available for some events 
 available for the lazy 
 no arg passed 
 no setting it twice 
 if its a number, we're done 
 allow a "CLOCK_" prefix to the name 
 SPDX-License-Identifier: GPL-2.0
 perf-record, no need to handle bpf-event 
		
		  Do not free bpf_prog_info and btf of the program here,
		  as annotation still need them. They will be freed at
		  the end of the session.
 Insertion failed because of a duplicate. 
 no subprog 
  Synthesize PERF_RECORD_KSYMBOL and PERF_RECORD_BPF_EVENT for one bpf
  program. One PERF_RECORD_BPF_EVENT is generated for the program. And
  one PERF_RECORD_KSYMBOL is generated for each sub program.
  Returns:
     0 for success;
    -1 for failures;
    -2 for lack of kernel support.
	
	  for perf-record and perf-report use header.env;
	  otherwise, use global perf_env.
 number of ksyms, func_lengths, and tags should match 
 check BTF func info support 
 btf func info number should be same as sub_prog_cnt 
 Synthesize PERF_RECORD_KSYMBOL 
 Synthesize PERF_RECORD_BPF_EVENT 
 save bpf_prog_info to env 
		
		  process after saving bpf_prog_info to env, so that
		  required information is ready for look up
 We are going after [bpf] module ... 
 .. and only for trampolines and dispatchers 
 Synthesize all the bpf programs in system. 
 don't report error on old kernel or EPERM  
 do not return error for old kernel 
 Synthesize all the bpf images - trampolinesdispatchers. 
		
		  Do not free bpf_prog_info and btf of the program here,
		  as annotation still need them. They will be freed at
		  the end of the session.
 to capture ABI version 
	
	  Older gcc versions don't support designated initializers, like above,
	  for unnamed union members, such as the following:
 SPDX-License-Identifier: GPL-2.0-only
  thread-stack.c: Synthesize a thread's stack using call  return events
  Copyright (c) 2014, Intel Corporation.
  State of retpoline detection.
  RETPOLINE_NONE: no retpoline detection
  X86_RETPOLINE_POSSIBLE: x86 retpoline possible
  X86_RETPOLINE_DETECTED: x86 retpoline detected
  struct thread_stack_entry - thread stack entry.
  @ret_addr: return address
  @timestamp: timestamp (if known)
  @ref: external reference (e.g. db_id of sample)
  @branch_count: the branch count when the entry was created
  @insn_count: the instruction count when the entry was created
  @cyc_count the cycle count when the entry was created
  @db_id: id used for db-export
  @cp: call path
  @no_call: a 'call' was not seen
  @trace_end: a 'call' but trace ended
  @non_call: a branch but not a 'call' to the start of a different symbol
  struct thread_stack - thread stack constructed from 'call' and 'return'
                        branch samples.
  @stack: array that holds the stack
  @cnt: number of entries in the stack
  @sz: current maximum stack size
  @trace_nr: current trace number
  @branch_count: running branch count
  @insn_count: running  instruction count
  @cyc_count running  cycle count
  @kernel_start: kernel start address
  @last_time: last timestamp
  @crp: callreturn processor
  @comm: current comm
  @arr_sz: size of array if this is the first element of an array
  @rstate: used to detect retpolines
  @br_stack_rb: branch stack (ring buffer)
  @br_stack_sz: maximum branch stack size
  @br_stack_pos: current position in @br_stack_rb
  @mispred_all: mark all branches as mispredicted
  Assume pid == tid == 0 identifies the idle task as defined by
  perf_session__register_idle_thread(). The idle task is really 1 task per cpu,
  and therefore requires a stack for each cpu.
	
	  In some cases there may be functions which are not seen to return.
	  For example when setjmp  longjmp has been used.  Or the perf context
	  switch in the kernel which doesn't stop and start tracing in exactly
	  the same code path.  When that happens the return address will be
	  further down the stack.  If the return address is not found at all,
	  we assume the opposite (i.e. this is a return for a call that wasn't
	  seen for some reason) and leave the stack alone.
	
	  The parent db_id must be assigned before exporting the child. Note
	  it is not possible to export the parent first because its information
	  is not yet complete because its 'return' has not yet been processed.
 No support for mispredict 
	
	  When the trace is discontinuous, the trace_nr changes.  In that case
	  the stack might be completely invalid.  Better to report nothing than
	  to report something misleading, so flush the stack.
	
	  Stop here if thread_stack__process() is in use, or not recording call
	  stack.
 Zero-length calls are excluded 
		
		  If the caller did not change the trace number (which would
		  have flushed the stack) then try to make sense of the stack.
		  Possibly, tracing began after returning to the current
		  address, so try to pop that. Also, do not expect a call made
		  when the trace ended, to return, so pop that.
  Hardware sample records, created some time after the event occurred, need to
  have subsequent addresses removed from the call chain.
	
	  When tracing kernel space, kernel addresses occur at the top of the
	  call chain after the event occurred but before tracing stopped.
	  Skip them.
 Use sample_ip as an invalid context 
 Start of user space branch entries 
  Start of branch entries after the ip fell in between 2 branches, or user
  space branch entries.
  Hardware sample records, created some time after the event occurred, need to
  have subsequent addresses removed from the branch stack.
		
		  User space sample: start copying branch entries when the
		  branch is in user space.
		
		  Kernel space sample: start copying branch entries when the ip
		  falls in between 2 branches (or the branch is in user space
		  because then the start must have been missed).
 Return to userspace, so pop all kernel addresses 
 Return to userspace, so pop all kernel addresses 
 If the stack is empty, push the userspace address 
 Return to userspace, so pop all kernel addresses 
		
		  At the bottom of the stack, assume the missing 'call' was
		  before the trace started. So, pop the current symbol and push
		  the 'to' symbol.
		
		  Otherwise assume the 'return' is being used as a jump (e.g.
		  retpoline) and just push the 'to' symbol.
	
	  Assume 'parent' has not yet returned, so push 'to', and then push and
	  pop 'from'.
 Pop trace end 
 No point having 'trace end' on the bottom of the stack 
  x86 retpoline functions pollute the call graph. This function removes them.
  This does not handle function return thunks, nor is there any improvement
  for the handling of inline thunks or extern thunks.
		
		  This is a x86 retpoline fn. It pollutes the call graph by
		  showing up everywhere there is an indirect branch, but does
		  not itself mean anything. Here the top-of-stack is removed,
		  by decrementing the stack count, and then further down, the
		  resulting top-of-stack is replaced with the actual target.
		  The result is that the retpoline functions will no longer
		  appear in the call graph. Note this only affects the call
		  graph, since all the original branches are left unchanged.
			
			  Target is back to the middle of the symbol we came
			  from so assume it is an indirect jmp and forget it
			  altogether.
		
		  Target is back to the symbol we came from so assume it is an
		  indirect jmp and forget it altogether.
 Replace the top-of-stack with the actual target 
 Supersede thread_stack__event() 
 Flush stack on exec 
 If the stack is empty, put the current symbol on the stack 
 Zero-length calls are excluded 
		
		  A call to the same symbol but not the start of the symbol,
		  may be the start of a x86 retpoline.
 Pop kernel stack 
 x86 retpoline 'return' doesn't match the stack 
		
		  The compiler might optimize a callret combination by making
		  it a jmp. Make that visible by recording on the stack a
		  branch to the start of a different symbol. Note, that means
		  when a ret pops the stack, all jmps must be popped off first.
 SPDX-License-Identifier: GPL-2.0
 We care only about private r-x mappings. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008,2009, Steven Rostedt <srostedt@redhat.com>
 page_size
 unfortunately, you can not stat debugfs or proc files for size 
 put in zeros for file size, then fill true size later 
 ugh, handle big-endian hdr_size == 4 
	
	  Just to keep older perf.data file parsers happy, record a zero
	  sized kallsyms file, i.e. do the same thing that was done when
	  prockallsyms (or something specified via --kallsyms, in a
	  different path) couldn't be read.
 not found 
 not found 
 just guessing this is someone's birthday.. ;) 
 save endian 
 save size of long 
 save page_size 
		
		  Set the temp file the default output, so all the
		  tracing data are stored into it.
	
	  All tracing data are stored by now, we can restore
	  the default output file in case we used temp file.
	
	  We work over the real file, so we can write data
	  directly, no temp file is needed.
 SPDX-License-Identifier: GPL-2.0
  evsel__config_leader_sampling() uses special rules for leader sampling.
  However, if the leader is an AUX area event, then assume the event to sample
  is the next event.
	
	  Disable sampling for all group members except those with explicit
	  config terms or the leader. In the case of an AUX area event, the 2nd
	  event in the group is the one that 'leads' the sampling.
	
	  We don't get a sample for slave events, we make them when delivering
	  the group leader sample. Set the slave event to follow the master
	  sample_type to ease up reporting.
	  An AUX area event also has sample_type requirements, so also include
	  the sample type bits from the leader's sample_type to cover that
	  case.
	
	  Set the evsel leader links before we configure attributes,
	  since some might depend on this info.
 Configure leader sampling here now that the sample type is known 
		
		  Need to be able to synthesize and parse selected events with
		  arbitrary sample types, which requires always being able to
		  match the id.
	
	  User specified count overrides default frequency.
	
	  User specified frequency is over current maximum.
	
	  Default frequency is over current maximum.
 SPDX-License-Identifier: GPL-2.0
	
	  XXX still paranoid for now; see if we can make this depend on
	  DEBUG=1 builds.
 NULL isn't executable 
 single instruction block; jump to a jump 
  block_range__create
  @start: branch target starting this basic block
  @end:   branch ending this basic block
  Create all the required block ranges to precisely span the given range.
	
	  Didn't find anything.. there's a hole at @start, however @end might
	  be insidebehind the next range.
 tree empty 
		
		  If the last node is before, advance one to find the next.
 add head: [start...][n->start...] 
		
		  The whole [start..end] range is non-overlapping.
	
	  We found a range that overlapped with ours, split if needed.
 split: [e->start...][start...] 
	
	  At this point we've got: @iter.start = [@start...] but @end can still be
	  inside or beyond it.
		
		  If @end is inside @entry, split.
 split: [...end][...e->end] 
		
		  If @end matches @entry, done
		
		  If @end is in beyond @entry but not inside @next, add tail.
 add tail: [...e->end][...end] 
		
		  If there is a hole between @entry and @next, fill it.
  Compute coverage as:
     br->coverage  br->sym->max_coverage
  This ensures each symbol has a 100% spot, to reflect that each symbol has a
  most covered section.
  Returns [0-1] for coverage and -1 if we had no data what so ever or the
  symbol does not exist.
 SPDX-License-Identifier: GPL-2.0
 filename__read_build_id
	
	  The second is always dso->id, so zeroes if not set, assume passing
	  NULL for a means a zeroed id
  Find a matching entry andor link current entry to RB tree.
  Either one of the dso or name parameter must be non-NULL or the
  function will not work.
	
	  Find node with the matching name
			
			  In case the new DSO is a duplicate of an existing
			  one, print a one-time warning & put the new entry
			  at the end of the list of duplicates.
 Find matching dso 
			
			  The core kernel DSOs may have duplicated long name.
			  In this case, the short name should be different.
			  Comparing the short names to differentiate the DSOs.
 Add new node and rebalance tree 
	
	  It is now in the linked list, grab a reference, then garbage collect
	  this when needing memory, by looking at LRU dso instances in the
	  list with atomic_read(&dso->refcnt) == 1, i.e. no references
	  anywhere besides the one for the list, do, under a lock for the
	  list: remove it from the list, then a dso__put(), that probably will
	  be the last and will then call dso__delete(), end of life.
	 
	  That, or at the end of the 'struct machine' lifetime, when all
	  'struct dso' instances will be removed from the list, in
	  dsos__exit(), if they have no other reference from some other data
	  structure.
	 
	  E.g.: after processing a 'perf.data' file and storing references
	  to objects instantiated while processing events, we will have
	  references to the 'thread', 'map', 'dso' structs all from 'struct
	  hist_entry' instances, but we may not need anything not referenced,
	  so we might as well call machines__exit()machines__delete() and
	  garbage collect it.
	      
	        basename() may modify path buffer, so we must pass
                a copy.
		
		  basename() may return a pointer to internal
		  storage which is reused in subsequent calls
		  so copy the result.
 Put dso here because __dsos_add already got it 
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2021 Facebook 
 Copyright (c) 2021 Google 
 we need one copy of events per cpu for reading 
 previous result is saved in a per-cpu array 
 cgroup result needs all events (per-cpu) 
	
	  Update cgrp_idx map from cgroup-id to event index.
 open single copy of the events wo cgroup 
	
	  bperf uses BPF_PROG_TEST_RUN to get accurate reading. Check
	  whether the kernel support it
 just to bypass bpf_counter_skip() 
 nothing to do 
  trigger the leader prog on each cpu, so the cgrp_reading map could get
  the latest results.
 it'll destroy on_switch progs too
 SPDX-License-Identifier: GPL-2.0
 for sched_getcpu()
 use 'safest' configuration as used in evsel__fallback() 
	
	  Using -1 for the pid is a workaround to avoid gratuitous jump label
	  changes.
 check cloexec flag 
 not supported, confirm error related to PERF_FLAG_FD_CLOEXEC 
  Just try PT_NOTE header otherwise fails
 for simplicity 
 Assume all sym sources could be a runtime image. 
 SPDX-License-Identifier: GPL-2.0
  This function implements the Damerau-Levenshtein algorithm to
  calculate a distance between strings.
  Basically, it says how many letters need to be swapped, substituted,
  deleted from, or added to string1, at least, to get string2.
  The idea is to build a distance matrix for the substrings of both
  strings.  To avoid a large space complexity, only the last three rows
  are kept in memory (if swaps had the same or higher cost as one deletion
  plus one insertion, only two rows would be needed).
  At any stage, "i + 1" denotes the length of the current substring of
  string1 that the distance is calculated for.
  row2 holds the current row, row1 the previous row (i.e. for the substring
  of string1 of length "i"), and row0 the row before that.
  In other words, at the start of the big loop, row2[j + 1] contains the
  Damerau-Levenshtein distance between the substring of string1 of length
  "i" and the substring of string2 of length "j + 1".
  All the big loop does is determine the partial minimum-cost paths.
  It does so by calculating the costs of the path ending in characters
  i (in string1) and j (in string2), respectively, given that the last
  operation is a substitution, a swap, a deletion, or an insertion.
  This implementation allows the costs to be weighted:
  - w (as in "sWap")
  - s (as in "Substitution")
  - a (for insertion, AKA "Add")
  - d (as in "Deletion")
  Note that this algorithm calculates a distance _iff_ d == a.
 substitution 
 swap 
 deletion 
 insertion 
 SPDX-License-Identifier: GPL-2.0
  Parse & process all the sysfs attributes located under
  the directory specified in 'dir' parameter.
  Readingparsing the default pmu format definition, which should be
  located at:
  sysbusevent_sourcedevices<dev>format as sysfs group attributes.
	
	  save current locale
	
	  The lc string may be allocated in static storage,
	  so get a dynamic copy to make it survive setlocale
	  call below.
	
	  force to C locale to ensure kernel
	  scale string is converted correctly.
	  kernel uses default C locale.
 restore locale 
 Have new string, check with old 
 Nothing new --> keep old string 
 Delete an alias entry. 
 Merge an alias, search in alias list. If this name is already
  present merge both of them to combine all information.
	 Scan event and remove leading zeroes, spaces, newlines, some
	  platforms have terms specified as
	  event=0x0091 (read from files ..<PMU>events<FILE>
	  and terms specified as event=0x91 (read from JSON files).
	 
	  Rebuild string to make alias->str member comparable.
		
		  load unit name and scale if available
 Remove trailing newline from sysfs file 
  Process all the sysfs attributes located under the directory
  specified in 'dir' parameter.
		
		  skip info files parsed in perf_pmu__new_alias()
  Reading the pmu event aliases definition, which should be located at:
  sysbusevent_sourcedevices<dev>events as sysfs group attributes.
		
		  Weak terms don't override command line options,
		  which we don't want for implicit terms in aliases.
  Readingparsing the default pmu type value, which should be
  located at:
  sysbusevent_sourcedevices<dev>type as sysfs attribute.
 Add all pmus in sysfs to pmu list: 
 add to static LIST_HEAD(pmus): 
  Uncore PMUs have a "cpumask" file under sysfs. CPU PMUs (e.g. on armarm64)
  may have a "cpus" file.
 remove line feed 
   PMU CORE devices have different name other than cpu in sysfs on some
   platforms.
   Looking for possible sysfs files to identify the arm core device.
 Look for cpu sysfs (specific to arm) 
	 on some platforms which uses cpus map, cpuid can be NULL for
	  PMUs other than CORE PMUs.
  Suffix must be in form tok_{digits}, or tok{digits}, or same as pmu_name
  to be valid.
 Ensure we end in a number 
	
	  uncore alias may be from different PMU with common prefix
	
	  Match more complex aliases where the alias name is a comma-delimited
	  list of tokens, orderly contained in the matching PMU name.
	 
	  Example: For alias "socket,pmuname" and PMU "socketX_pmunameY", we
	 	    match "socket" in "socketX_pmunameY" and then "pmuname" in
	 	    "pmunameY".
  From the pmu_events_map, find the table of PMU events that corresponds
  to the current running CPU. Then, add all PMU events from that table
  as aliases.
	
	  Found a matching PMU events table. Create aliases
 need type casts to override 'const' 
	
	  Check pmu name for hybrid and the pmu may be invalid in sysfs
	
	  The pmu data we store & need consists of the pmu
	  type value and format definitions. Load both right
	  now.
	
	  Check the type first to avoid unnecessary work.
	
	  pmu iterator: If pmu is NULL, we start at the begin,
	  otherwise return the next pmu. Returns NULL on end.
	
	  Once PMU is loaded it stays in the list,
	  so we keep us from multiple readingparsing
	  the pmu format definitions.
  Sets value based on the format definition (format parameter)
  and unformatted value (value parameter).
  Term is a string term, and might be a param-term. Try to look up it's value
  in the remaining terms.
  - We have a term like "base-or-format-term=param-term",
  - We need to find the value supplied for "param-term" (with param-term named
    in a config string) later on in the term list.
 sysfs exported terms 
  Setup one of config[12] attr members based on the
  user input data - term parameter.
	
	  If this is a parameter we've already used for parameterized-eval,
	  skip it in normal eval.
	
	  Hardcoded terms should be already in, so nothing
	  to be done for them.
	
	  Either directly use a numeric term, or try to translate string terms
	  using event parameters.
		
		  Assume we don't care if !err, in which case the value will be
		  silently truncated.
  Configures event's 'attr' parameter based on the:
  1) users input - specified in terms parameter
  2) pmu format definitions - specified by pmu parameter
	
	  Only one term in event definition can
	  define unit, scale and snapshot, fail
	  if there's more than one.
  Find alias in the terms list and replace it with the terms
  defined for the alias
	
	  Mark unit and scale as not set
	  (different from default values, see below)
	
	  if no unit or scale found in aliases, then
	  set defaults as for evsel
	  unit cannot left to NULL
 Put extra events last 
 Order CPU core events to be first 
", pmu->name) < 0)
 Skip duplicates 
  Readingparsing the given pmu capabilities, which should be located at:
  sysbusevent_sourcedevices<dev>caps as sysfs group attributes.
  Return the number of capabilities
 no error if caps does not exist 
	
	  Kernel doesn't export any valid format bits.
 SPDX-License-Identifier: GPL-2.0
  Capability utilities
 HAVE_LIBCAP_SUPPORT 
 SPDX-License-Identifier: GPL-2.0
 handles cross-endianness 
 The filename format is unspecified, absolute path, relative etc. 
	
	  check that all events use CLOCK_MONOTONIC
	
	  protect from writer modifying the file while we are reading it
	
	  validate event is using the correct clockid
 read extra we do not know about 
	
	  keep dirname for generating files and mmap records
	
	  file is still locked at this point
 skip unknown record (we have read them) 
	
	  The event TIME_CONV was extended for the fields from "time_cycles"
	  when supported cap_user_time_short, for backward compatibility,
	  checks the event size and assigns these extended fields if these
	  fields are contained in the event.
 for \0 
	
	  create pseudo sample to induce dso hit increment
	  use first address as sample address
	
	  mark dso as use to generate buildid in the header
	
	  +16 to account for sample_id_all (hack)
 for \0 
	
	  create pseudo sample to induce dso hit increment
	  use first address as sample address
	
	  we must use nr_entry instead of size here because
	  we cannot distinguish actual entry from padding otherwise
  File must be with pattern ...jit-XXXX.dump
  where XXXX is the PID of the process which did the mmap()
  as captured in the RECORD_MMAP record
	
	  get file name
	
	  match prefix
	
	  skip prefix
	
	  must be followed by a pid
	
	  pid does not match mmap pid
	  pid==0 in system-wide mode (synthesized)
	
	  validate suffix
	
	  first, detect marker mmap (i.e., the jitdump mmap)
 Strip 
anon", 6) == 0))
	
	  track sample_type to compute id_all layout
	  perf sets the same sample type to all events as of now
 SPDX-License-Identifier: GPL-2.0 
  Architectures are expected to know if AUX area sampling is supported by the
  hardware. Here we check for kernel support.
		
		  Non-zero value causes the kernel to calculate the effective
		  attribute size up to that byte.
	
	  If the kernel attribute is big enough to contain aux_sample_size
	  then we assume that it is supported. We are relying on the kernel to
	  validate the attribute size before anything else that could be wrong.
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017, Intel Corporation.
 Manage metrics and groups of metrics from JSON files 
  A node in the list of referenced metrics. metric_expr
  is held as a convenience to avoid a search through the
  metric list.
  The metric under construction. The data held here will be placed in a
  metric_expr.
	
	  The expression parse context importantly holding the IDs contained
	  within the expression.
 The name of the metric such as "IPC". 
 Modifier on the metric such as "u" or NULL for none. 
 The expression to parse, for example, "instructionscycles". 
	
	  The "ScaleUnit" that scales and adds a unit to the metric during
	  output.
 Optional null terminated array of referenced metrics. 
	
	  Is there a constraint on the group of events? In which case the
	  events won't be grouped.
	
	  Parsed events for the metric. Optional as events may be taken from a
	  different metric whose group contains all the IDs necessary for this
	  one.
  setup_metric_events - Find a group of events in metric_evlist that correspond
                        to the IDs from a parsed metric expression.
  @ids: the metric IDs to match.
  @metric_evlist: the list of perf events.
  @out_metric_events: holds the created metric events array.
		
		  Check for duplicate events with the same name. For
		  example, uncore_imccas_count_read will turn into 6
		  events per socket on skylakex. Only the first such
		  event is placed in metric_events.
		
		  Does this event belong to the parse context? For
		  combined or shared groups, this metric may not care
		  about this event.
		
		  The metric leader points to the identically named
		  event in metric_events.
		
		  Mark two events with identical names in the same
		  group (or globally) as being in use as uncore events
		  may be duplicated for each pmu. Set the metric leader
		  of such events to be the event that appears in
		  metric_events.
		
		  If the name is just the parsed event, use the metric-id to
		  give a more friendly display version.
		
		  Duration time maps to a software event and can make
		  groups not count. Always use it outside a
		  group.
 Separate events with commas and open the group if necessary. 
		
		  Encode the ID as an event string. Add a qualifier for
		  metric_id that is the original name except with characters
		  that parse-events can't parse replaced. For example,
		  'msr@tsc@' gets added as msrtsc,metric-id=msr!3tsc!3
 Strange case of a metric of just duration_time. 
  A singly linked list on the stack of the names of metrics being
  processed. Used to identify recursion.
  resolve_metric - Locate metrics within the root metric and recursively add
                     references to them.
  @metric_list: The list the metric is added to.
  @modifier: if non-null event modifiers like "u".
  @metric_no_group: Should events written to events be grouped "{}" or
                    global. Grouping is the default but due to multiplexing the
                    user may override.
  @root_metric: Metrics may reference other metrics to form a tree. In this
                case the root_metric holds all the IDs and a list of referenced
                metrics. When adding a root this argument is NULL.
  @visited: A singly linked list of metric names being added that is used to
            detect recursion.
  @map: The map that is searched for metrics, most commonly the table for the
        architecture perf is running upon.
 The metric to resolve. 
		
		  The key in the IDs map, this may differ from in case,
		  etc. from pe->metric_name.
	
	  Iterate all the parsed IDs and if there's a matching metric and it to
	  the pending array.
 Remove the metric IDs from the context. 
	
	  Recursively add all the metrics, IDs are added to the root metric's
	  context.
  __add_metric - Add a metric to metric_list.
  @metric_list: The list the metric is added to.
  @pe: The pmu_event containing the metric to be added.
  @modifier: if non-null event modifiers like "u".
  @metric_no_group: Should events written to events be grouped "{}" or
                    global. Grouping is the default but due to multiplexing the
                    user may override.
  @runtime: A special argument for the parser only known at runtime.
  @root_metric: Metrics may reference other metrics to form a tree. In this
                case the root_metric holds all the IDs and a list of referenced
                metrics. When adding a root this argument is NULL.
  @visited: A singly linked list of metric names being added that is used to
            detect recursion.
  @map: The map that is searched for metrics, most commonly the table for the
        architecture perf is running upon.
		
		  This metric is the root of a tree and may reference other
		  metrics that are added recursively.
		
		  This metric was referenced in a metric higher in the
		  tree. Check if the same metric is already resolved in the
		  metric_refs list.
 Create reference. Need space for the entry and the terminator. 
		
		  Intentionally passing just const char pointers,
		  from 'pe' object, so they never go away. We don't
		  need to change them, so there's no need to create
		  our own copy.
 Null terminate array. 
	
	  For both the parent and referenced metrics, we parse
	  all the metric's IDs and add it to the root context.
 Broken metric. 
 Resolve referenced metrics. 
		 This loop is added to create multiple
		  events depend on count value and add
		  those events to metric_list.
  metricgroup__add_metric - Find and add a metric, or a metric group.
  @metric_name: The name of the metric or metric group. For example, "IPC"
                could be the name of a metric and "TopDownL1" the name of a
                metric group.
  @modifier: if non-null event modifiers like "u".
  @metric_no_group: Should events written to events be grouped "{}" or
                    global. Grouping is the default but due to multiplexing the
                    user may override.
  @metric_list: The list that the metric or metric group are added to.
  @map: The map that is searched for metrics, most commonly the table for the
        architecture perf is running upon.
	
	  Iterate over all metrics seeing if metric matches either the name or
	  group. When it does add the metric to the list.
root_metric=NULL,
visited_metrics=NULL, map);
 End of pmu events. 
	
	  add to metric_list so that they can be released
	  even if it's failed
  metricgroup__add_metric_list - Find and add metrics, or metric groups,
                                 specified in a list.
  @list: the list of metrics or metric groups. For example, "IPC,CPI,TopDownL1"
         would match the IPC and CPI metrics, and TopDownL1 would match all
         the metrics in the TopDownL1 group.
  @metric_no_group: Should events written to events be grouped "{}" or
                    global. Grouping is the default but due to multiplexing the
                    user may override.
  @metric_list: The list that metrics are added to.
  @map: The map that is searched for metrics, most commonly the table for the
        architecture perf is running upon.
		
		  Warn about nmi_watchdog if any parsed metrics had the
		  NO_NMI_WATCHDOG constraint.
 No metrics. 
  build_combined_expr_ctx - Make an expr_parse_ctx with all has_constraint
                            metric IDs, as the IDs are held in a set,
                            duplicates will be removed.
  @metric_list: List to take metrics from.
  @combined: Out argument for result.
  parse_ids - Build the event string for the ids and parse them creating an
              evlist. The encoded metric_ids are decoded.
  @fake_pmu: used when testing metrics not supported by the current CPU.
  @ids: the event identifiers parsed from a metric.
  @modifier: any modifiers added to the events.
  @has_constraint: false if events should be placed in a weak group.
  @out_evlist: the created list of events.
		
		  No idsevents in the expression parsing context. Events may
		  have been removed because of constant evaluation, e.g.:
		   event1 if #smt_on else 0
		  Add a duration_time event to avoid a parse error on an empty
		  string.
 Sort metrics from largest to smallest. 
modifier=NULL,
has_constraint=true,
			
			  See if the IDs for this metric are a subset of an
			  earlier metric.
 calculate number of metric_events 
 calculate number of metric_events 
 copy evsel in the same position 
 SPDX-License-Identifier: GPL-2.0
 build online CPU map 
 skip over invalid lines 
 SPDX-License-Identifier: GPL-2.0
  Mangled Rust symbols look like this:
      _$LT$std..sys..fd..FileDesc$u20$as$u20$core..ops..Drop$GT$::drop::hc68340e1baa4987a
  The original symbol is:
      <std::sys::fd::FileDesc as core::ops::Drop>::drop
  The last component of the path is a 64-bit hash in lowercase hex, prefixed
  with "h". Rust does not have a global namespace between crates, an illusion
  which Rust maintains by using the hash to distinguish things that would
  otherwise have the same symbol.
  Any path component not starting with a XID_Start character is prefixed with
  "_".
  The following escape sequences are used:
      ","  =>  $C$
      "@"  =>  $SP$
      ""  =>  $BP$
      "&"  =>  $RF$
      "<"  =>  $LT$
      ">"  =>  $GT$
      "("  =>  $LP$
      ")"  =>  $RP$
      " "  =>  $u20$
      "'"  =>  $u27$
      "["  =>  $u5b$
      "]"  =>  $u5d$
      "~"  =>  $u7e$
  A double ".." means "::" and a single "." means "-".
  The only characters allowed in the mangled symbol are a-zA-Z0-9 and _.:$
  INPUT:
      sym: symbol that has been through BFD-demangling
  This function looks for the following indicators:
   1. The hash must consist of "h" followed by 16 lowercase hex digits.
   2. As a sanity check, the hash must use between 5 and 15 of the 16 possible
      hex digits. This is true of 99.9998% of hashes so once in your life you
      may see a false negative. The point is to notice path components that
      could be Rust hashes but are probably not, like "haaaaaaaaaaaaaaaa". In
      this case a false positive (non-Rust symbol has an important path
      component removed because it looks like a Rust hash) is worse than a
      false negative (the rare Rust symbol is not demangled) so this sets the
      balance in favor of false negatives.
   3. There must be no characters other than a-zA-Z0-9 and _.:$
   4. There must be no unrecognized $-sign sequences.
   5. There must be no sequence of three or more dots in a row ("...").
 Not long enough to contain "::h" + hash + something else 
  A hash is the prefix "::h" followed by 16 lowercase hex digits. The hex
  digits must comprise between 5 and 15 (inclusive) distinct digits.
 Count how many distinct digits seen 
 Do not allow three or more consecutive dots 
 Fall through 
  INPUT:
      sym: symbol for which rust_is_mangled(sym) returns true
  The input is demangled in-place because the mangled name is always longer
  than the demangled one.
			
			  If this is the start of a path component and the next
			  character is an escape sequence, ignore the
			  underscore. The mangler inserts an underscore to make
			  sure the path component begins with a XID_Start
			  character.
 ".." becomes "::" 
 "." becomes "-" 
 Filter out some columns that don't work well in metrics only mode 
 In case of iostat, print metric header for first root port only 
 software events can be part of any hardware group 
		
		  When any result is bad, make them all to give
		  consistent output in interval mode.
	
	  With metric_only everything is on a single line.
	  Without each counter has its own line.
		
		  Skip value 0 when enabling --per-thread globally,
		  otherwise too many 0 output.
  Print out the results of a single counter:
  aggregated counts in system-wide mode
  Print out the results of a single counter:
  does not use aggregated count in system-wide
 Print metrics headers only 
		
		  Display at most 2 more significant
		  digits than the stddev inaccuracy.
 SPDX-License-Identifier: GPL-2.0
  perf_atoll()
  Parse (\d+)(b|B|kb|KB|mb|MB|gb|GB|tb|TB) (e.g. "256MB")
  and return its numeric value
 two-letter suffices 
 we want the cases to match 
 Character class matching 
 First character is special 
 Matching 
 Range 
 Searching closing 
 Globlazy pattern matching 
 Ignore spaces for lazy matching 
 Matches any single character 
 Character classesRanges 
 Escaped char match as normal char 
 Check wild card 
 Tail wild card matches all 
  strglobmatch - glob expression pattern matching
  @str: the target string to match
  @pat: the pattern string to match
  This returns true if the @str matches @pat. @pat can includes wildcards
  ('','?') and character classes ([CHARS], complementation and ranges are
  also supported). Also, this supports escape character ('\') to use special
  characters as normal character.
  Note: if @pat syntax is broken, this always returns false.
  strlazymatch - matching pattern strings lazily with glob pattern
  @str: the target string to match
  @pat: the pattern string to match
  This is similar to strglobmatch, except this ignores spaces in
  the target string.
  strtailcmp - Compare the tail of two strings
  @s1: 1st string to be compared
  @s2: 2nd string to be compared
  Return 0 if whole of either string is same as another's tail part.
	
	  FIXME: replace this with an expression using log10() when we
	  find a suitable implementation, maybe the one in the dvb drivers...
	 
	  "%s == %d || " = log10(MAXINT)  2 + 8 chars for the operators
 \0 
 Like strpbrk(), but not break if it is right after a backslash (escaped) 
 Like strdup, but do not copy a single backslash 
 SPDX-License-Identifier: GPL-2.0
	
	  attr.config layout for type PERF_TYPE_HARDWARE and
	  PERF_TYPE_HW_CACHE
	 
	  PERF_TYPE_HARDWARE:                 0xEEEEEEEE000000AA
	                                      AA: hardware event ID
	                                      EEEEEEEE: PMU type ID
	  PERF_TYPE_HW_CACHE:                 0xEEEEEEEE00DDCCBB
	                                      BB: hardware cache ID
	                                      CC: hardware cache op ID
	                                      DD: hardware cache op result ID
	                                      EEEEEEEE: PMU type ID
	  If the PMU type ID is 0, the PERF_TYPE_RAW will be applied.
 SPDX-License-Identifier: GPL-2.0
 Sort by the first fmt 
 SPDX-License-Identifier: GPL-2.0
 Fallback code 
 SPDX-License-Identifier: GPL-2.0
 Manage affinity to optimize IPIs inside the kernel perf API. 
	
	  sched_getaffinity doesn't like masks smaller than the kernel.
	  Hopefully that's big enough.
  perf_event_open does an IPI internally to the target CPU.
  It is more efficient to change perf's affinity to the target
  CPU and then set up all events on that CPU, so we amortize
  CPU communication.
	
	  We ignore errors because affinity is just an optimization.
	  This could happen for example with isolated CPUs or cpusets.
	  In this case the IPIs inside the kernel's perf API still work.
 SPDX-License-Identifier: GPL-2.0
  XXX We need to find a better place for these things...
 to capture ABI version 
  The depth specify how deep the removal will go.
  0       - will remove only files under the 'path' directory
  1 .. x  - will dive in x-level deep under the 'path' directory
  If specified the pat is array of string patterns ended with NULL,
  which are checked upon every filedirectory found. Only matching
  ones are removed.
  The function returns:
     0 on success
    -1 on removal failure with errno set
    -2 on pattern failure
 Do not fail if there's no file. 
 Try to remove any file we get. 
 We have directory in path. 
 We have to check symbolic link itself 
 A filter which removes dot files 
 lsdir reads a directory and store it in strlist 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2011, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
  Refactored from builtin-top.c, see that files for further copyright notes.
 SPDX-License-Identifier: GPL-2.0-or-later
  dwarf-aux.c : libdw auxiliary interfaces
  cu_find_realpath - Find the realpath of the target file
  @cu_die: A DIE(dwarf information entry) of CU(compilation Unit)
  @fname:  The tail filename of the target file
  Find the real(long) path of @fname in @cu_die.
  cu_get_comp_dir - Get the path of compilation directory
  @cu_die: a CU DIE
  Get the path of compilation directory of given @cu_die.
  Since this depends on DW_AT_comp_dir, older gcc will not
  embedded it. In that case, this returns NULL.
 Unlike dwarf_getsrc_die(), cu_getsrc_die() only returns statement line 
 Lines are sorted by address, use binary search 
 Going backward to find the lowest line 
 Going forward to find the statement line 
  cu_find_lineinfo - Get a line number and file name for given address
  @cu_die: a CU DIE
  @addr: An address
  @fname: a pointer which returns the file name string
  @lineno: a pointer which returns the line number
  Find a line number and file name for @addr in @cu_die.
 line number is useless without filename 
  cu_walk_functions_at - Walk on function DIEs at given address
  @cu_die: A CU DIE
  @addr: An address
  @callback: A callback which called with found DIEs
  @data: A user data
  Walk on function DIEs at given @addr in @cu_die. Passed DIEs
  should be subprogram or inlined-subroutines.
 Inlined function could be recursive. Trace it until fail 
  die_get_linkage_name - Get the linkage name of the object
  @dw_die: A DIE of the object
  Get the linkage name attribute of given @dw_die.
  For C++ binary, the linkage name will be the mangled symbol.
  die_compare_name - Compare diename and tname
  @dw_die: a DIE
  @tname: a string of target name
  Compare the name of @dw_die and @tname. Return false if @dw_die has no name.
  die_match_name - Match dienamelinkage name and glob
  @dw_die: a DIE
  @glob: a string of target glob pattern
  Glob matching the name of @dw_die and @glob. Return false if matching fail.
  This also match linkage name.
 fall back to check linkage name 
  die_get_call_lineno - Get callsite line number of inline-function instance
  @in_die: a DIE of an inlined function instance
  Get call-site line number of @in_die. This means from where the inline
  function is called.
  die_get_type - Get type DIE
  @vr_die: a DIE of a variable
  @die_mem: where to store a type DIE
  Get a DIE of the type of given variable (@vr_die), and store
  it to die_mem. Return NULL if fails to get a type DIE.
 Get a type die, but skip qualifiers 
  die_get_real_type - Get a type die, but skip qualifiers and typedef
  @vr_die: a DIE of a variable
  @die_mem: where to store a type DIE
  Get a DIE of the type of given variable (@vr_die), and store
  it to die_mem. Return NULL if fails to get a type DIE.
  If the type is qualifiers (e.g. const) or typedef, this skips it
  and tries to find real type (structure or basic types, e.g. int).
 Get attribute and translate it as a udata 
 Get attribute and translate it as a sdata 
  die_is_signed_type - Check whether a type DIE is signed or not
  @tp_die: a DIE of a type
  Get the encoding of @tp_die and return true if the encoding
  is signed.
  die_is_func_def - Ensure that this DIE is a subprogram and definition
  @dw_die: a DIE
  Ensure that this DIE is a subprogram and NOT a declaration. This
  returns true if @dw_die is a function definition.
	
	  DW_AT_declaration can be lost from function declaration
	  by gcc's bug #97060.
	  So we need to check this subprogram DIE has DW_AT_inline
	  or an entry address.
  die_entrypc - Returns entry PC (the lowest address) of a DIE
  @dw_die: a DIE
  @addr: where to store entry PC
  Since dwarf_entrypc() does not return entry PC if the DIE has only address
  range, we have to use this to retrieve the lowest address from the address
  range attribute.
	
	   Since the dwarf_ranges() will return 0 if there is no
	  DW_AT_ranges attribute, we should check it first.
  die_is_func_instance - Ensure that this DIE is an instance of a subprogram
  @dw_die: a DIE
  Ensure that this DIE is an instance (which has an entry address).
  This returns true if @dw_die is a function instance. If not, the @dw_die
  must be a prototype. You can use die_walk_instances() to find actual
  instances.
  die_get_data_member_location - Get the data-member offset
  @mb_die: a DIE of a member of a data structure
  @offs: The offset of the member in the data structure
  Get the offset of @mb_die in the data structure including @mb_die, and
  stores result offset to @offs. If any error occurs this returns errno.
 DW_AT_data_member_location should be DW_OP_plus_uconst 
 Get the call file index number in CU DIE 
 Get the declared file index number in CU DIE 
  die_get_call_file - Get callsite file name of inlined function instance
  @in_die: a DIE of an inlined function instance
  Get call-site file name of @in_die. This means from which file the inline
  function is called.
  die_find_child - Generic DIE search function in DIE tree
  @rt_die: a root DIE
  @callback: a callback function
  @data: a user data passed to the callback function
  @die_mem: a buffer for result DIE
  Trace DIE tree from @rt_die and call @callback for each child DIE.
  If @callback returns DIE_FIND_CB_END, this stores the DIE into
  @die_mem and returns it. If @callback returns DIE_FIND_CB_CONTINUE,
  this continues to trace the tree. Optionally, @callback can return
  DIE_FIND_CB_CHILD and DIE_FIND_CB_SIBLING, those means trace only
  the children and trace only the siblings respectively.
  Returns NULL if @callback can't find any appropriate DIE.
  die_find_tailfunc - Search for a non-inlined function with tail call at
  given address
  @cu_die: a CU DIE which including @addr
  @addr: target address
  @die_mem: a buffer for result DIE
  Search for a non-inlined function DIE with tail call at @addr. Stores the
  DIE to @die_mem and returns it if found. Returns NULL if failed.
 dwarf_getscopes can't find subprogram. 
 die_find callback for non-inlined function search 
	
	  Since a declaration entry doesn't has given pc, this always returns
	  function definition entry.
  die_find_realfunc - Search a non-inlined function at given address
  @cu_die: a CU DIE which including @addr
  @addr: target address
  @die_mem: a buffer for result DIE
  Search a non-inlined function DIE which includes @addr. Stores the
  DIE to @die_mem and returns it if found. Returns NULL if failed.
 dwarf_getscopes can't find subprogram. 
 die_find callback for inline function search 
  die_find_top_inlinefunc - Search the top inlined function at given address
  @sp_die: a subprogram DIE which including @addr
  @addr: target address
  @die_mem: a buffer for result DIE
  Search an inlined function DIE which includes @addr. Stores the
  DIE to @die_mem and returns it if found. Returns NULL if failed.
  Even if several inlined functions are expanded recursively, this
  doesn't trace it down, and returns the topmost one.
  die_find_inlinefunc - Search an inlined function at given address
  @sp_die: a subprogram DIE which including @addr
  @addr: target address
  @die_mem: a buffer for result DIE
  Search an inlined function DIE which includes @addr. Stores the
  DIE to @die_mem and returns it if found. Returns NULL if failed.
  If several inlined functions are expanded recursively, this trace
  it down and returns deepest one.
 Inlined function could be recursive. Trace it until fail 
 Ignore redundant instances 
  die_walk_instances - Walk on instances of given DIE
  @or_die: an abstract original DIE
  @callback: a callback function which is called with instance DIE
  @data: user data
  Walk on the instances of give @in_die. @in_die must be an inlined function
  declaration. This returns the return value of @callback if it returns
  non-zero value, or -ENOENT if there is no instance.
 Line walker internal parameters 
 Continue to search nested inlined function call-sites 
 Walk on lines of blocks included in given DIE 
 Handle function declaration line 
	
	  Since inlined function can include another inlined function in
	  the same file, we need to walk in it recursively.
  die_walk_lines - Walk on lines inside given DIE
  @rt_die: a root DIE (CU, subprogram or inlined_subroutine)
  @callback: callback routine
  @data: user data
  Walk on all lines inside given @rt_die and call @callback on each line.
  If the @rt_die is a function, walk only on the lines inside the function,
  otherwise @rt_die must be a CU DIE.
  Note that this walks not only dwarf line list, but also function entries
  and inline call-site.
 Get the CU die 
 Get lines list in the CU 
 Walk on the lines on lines list 
 Skip end-of-sequence 
 Skip Non statement line-info 
 Filter lines based on address 
			
			  Address filtering
			  The line is included in given function, and
			  no inline block includes it.
 Call-site check 
 Get source line 
	
	  Dwarf lines doesn't include function declarations and inlined
	  subroutines. We have to check functions list or given function.
		
		  Don't need walk inlined functions recursively, because
		  inner inlined functions don't have the lines of the
		  specified function.
	
	  Does the DIE have location information or const value
	  or external instance?
  die_find_variable_at - Find a given name variable at given address
  @sp_die: a function DIE
  @name: variable name
  @addr: address
  @die_mem: a buffer for result DIE
  Find a variable DIE called @name at @addr in @sp_die.
 Unnamed structure 
  die_find_member - Find a given name member in a data structure
  @st_die: a data structure type DIE
  @name: member name
  @die_mem: a buffer for result DIE
  Find a member DIE called @name in @st_die.
  die_get_typename - Get the name of given variable DIE
  @vr_die: a variable DIE
  @buf: a strbuf for result type name
  Get the name of @vr_die and stores it to @buf. Return 0 if succeeded.
  and Return -ENOENT if failed to find type name.
  Note that the result will stores typedef name if possible, and stores
  "(function_type)" if the type is a function pointer.
 Function pointer 
 Write a base name 
  die_get_varname - Get the name and type of given variable DIE
  @vr_die: a variable DIE
  @buf: a strbuf for type and variable name
  Get the name and type of @vr_die and stores it in @buf as "type\tname".
  die_get_var_innermost_scope - Get innermost scope range of given variable DIE
  @sp_die: a subprogram DIE
  @vr_die: a variable DIE
  @buf: a strbuf for variable byte offset range
  Get the innermost scope range of @vr_die and stores it in @buf as
  "@<function_name+[NN-NN,NN-NN]>".
 (SCOPES)[1] is the DIE for the scope containing that scope 
  die_get_var_range - Get byte offset range of given variable DIE
  @sp_die: a subprogram DIE
  @vr_die: a variable DIE
  @buf: a strbuf for type and variable name and byte offset range
  Get the byte offset range of @vr_die and stores it in @buf as
  "@<function_name+[NN-NN,NN-NN]>".
 Single Location Descriptions 
 Location Lists 
  die_has_loclist - Check if DW_AT_location of @vr_die is a location list
  @vr_die: a variable DIE
  die_is_optimized_target - Check if target program is compiled with
  optimization
  @cu_die: a CU DIE
  For any object in given CU whose DW_AT_location is a location list,
  target program is compiled with optimization. This is applicable to
  clang as well.
  die_search_idx - Search index of given line address
  @lines: Line records of single CU
  @nr_lines: Number of @lines
  @addr: address we are looking for
  @idx: index to be set by this function (return value)
  Search for @addr by looping over every lines of CU. If address
  matches, set index of that line in @idx. Note that single source
  line can have multiple line records. i.e. single source line can
  have multiple index.
  die_get_postprologue_addr - Search next address after function prologue
  @entrypc_idx: entrypc index
  @lines: Line records of single CU
  @nr_lines: Number of @lines
  @hignpc: high PC address of function
  @postprologue_addr: Next address after function prologue (return value)
  Look for prologue-end marker. If there is no explicit marker, return
  address of next line record or next source line.
 entrypc_lno is actual source line number 
 highpc is exclusive. [entrypc,highpc) 
 clang supports prologue-end marker 
 Actual next line in source 
		
		  Single source line can have multiple line records.
		  For Example,
		      void foo() { printf("hello\n"); }
		  contains two line records. One points to declaration and
		  other points to printf() line. Variable 'lno' won't get
		  incremented in this case but 'i' will.
  die_skip_prologue - Use next address after prologue as probe location
  @sp_die: a subprogram DIE
  @cu_die: a CU DIE
  @entrypc: entrypc of the function
  Function prologue prepares stack and registers before executing function
  logic. When target program is compiled without optimization, function
  parameter information is only valid after prologue. When we probe entrypc
  of the function, and try to record function parameter, it contains
  garbage value.
 SPDX-License-Identifier: GPL-2.0
 purge data in bpf_progs.infos tree 
 HAVE_LIBBPF_SUPPORT
 HAVE_LIBBPF_SUPPORT
 do not include NULL termination 
	
	  Must copy argv contents because it gets moved around during option
	  parsing:
 include a NULL character at the end 
  Return architecture name in a normalized form.
  The conversion logic comes from the Makefile.
 Assume local operation 
 Assume local operation 
 Assume local operation 
 Assume local operation 
		
		  We initialize the numa_map array to prepare
		  it for missing cpus, which return node -1
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
	
	  last event might point to some random place in the list as it's
	  the last queued event. We expect that the new event is close to
	  this.
	
	  We maintain the following scheme of buffers for ordered
	  event allocation:
	 
	    to_free list -> buffer1 (64K)
	                    buffer2 (64K)
	                    ...
	 
	  Each buffer keeps an array of ordered events objects:
	     buffer -> event[0]
	               event[1]
	               ...
	 
	  Each allocated ordered event is linked to one of
	  following lists:
	    - time ordered list 'events'
	    - list of currently removed events 'cache'
	 
	  Allocation of the ordered event uses the following order
	  to get the memory:
	    - use recently removed object from 'cache' list
	    - use available object in current allocation buffer
	    - allocate new buffer if the current buffer is full
	 
	  Removal of ordered event object moves it from events to
	  the cache list.
 Warn if we are called before any event got allocated. 
	
	  Current buffer might not have all the events allocated
	  yet, we need to free only allocated ones ...
 ... and continue with the rest 
 SPDX-License-Identifier: GPL-2.0
  Copyright(C) 2015-2018 Linaro Limited.
  Author: Tor Jeremiassen <tor@ti.com>
  Author: Mathieu Poirier <mathieu.poirier@linaro.org>
 Conversion between traceID and index in traceid_queues array 
 RB tree for quick conversion between traceID and metadata pointers 
 PTMs ETMIDR [11:8] set to b0011 
  A struct auxtrace_heap_item only has a queue_nr and a timestamp to
  work with.  One option is to modify to auxtrace_heap_XYZ() API or simply
  encode the etm queue number as the upper 16 bit and the channel as
  the lower 16 bit.
  The returned PID format is presented by two bits:
    Bit ETM_OPT_CTXTID: CONTEXTIDR or CONTEXTIDR_EL1 is traced;
    Bit ETM_OPT_CTXTID2: CONTEXTIDR_EL2 is traced.
  It's possible that the two bits ETM_OPT_CTXTID and ETM_OPT_CTXTID2
  are enabled at the same time when the session runs on an EL2 kernel.
  This means the CONTEXTIDR_EL1 and CONTEXTIDR_EL2 both will be
  recorded in the trace data, the tool will selectively use
  CONTEXTIDR_EL2 as PID.
 CONTEXTIDR is traced 
 CONTEXTIDR_EL2 is traced 
 CONTEXTIDR_EL1 is traced 
	
	  When a timestamp packet is encountered the backend code
	  is stopped so that the front end has time to process packets
	  that were accumulated in the traceID queue.  Since there can
	  be more than one channel per cs_etm_queue, we need to specify
	  what traceID queue needs servicing.
 Acknowledge pending status 
 See function cs_etm_decoder__do_{hard|soft}_timestamp() 
	
	  Check if the traceid_queue exist for this traceID by looking
	  in the queue list.
 We couldn't find a traceid_queue for this traceID, allocate one 
 Get a valid index for the new traceid_queue 
 Memory for the inode is free'ed in cs_etm_free_traceid_queues () 
 Associate this traceID with this index 
 Grow the traceid_queues array by one unit 
	
	  On failure reallocarray() returns NULL and the original block of
	  memory is left untouched.
	
	  Function intlist__remove() removes the inode from the list
	  and delete the memory associated to it.
		
		  Swap PACKET with PREV_PACKET: PACKET becomes PREV_PACKET for
		  the next incoming packet.
 Free this traceid_queue from the array 
		
		  Function intlist__remove() removes the inode from the list
		  and delete the memory associated to it.
 Then the RB tree itself 
 finally free the traceid_queues array 
 First remove all traceIDmetadata nodes for the RB tree 
 Then the RB tree itself 
	
	  Each queue can only contain data from one CPU when unformatted, so only one decoder is
	  needed.
 Use metadata to fill in trace parameters for trace decoder 
 Set decoder parameters to decode trace packets 
	
	  Register a function to handle all memory accesses required by
	  the trace decoder library.
	
	  We are under a CPU-wide trace scenario.  As such we need to know
	  when the code that generated the traces started to execute so that
	  it can be correlated with execution on other CPUs.  So we get a
	  handle on the beginning of traces and decode until we find a
	  timestamp.  The timestamp is then added to the auxtrace min heap
	  in order to know what nibble (of all the etmqs) to decode first.
		
		  Fetch an aux_buffer from this etmq.  Bail if no more
		  blocks or an error has been encountered.
		
		  Run decoder on the trace block.  The decoder will stop when
		  encountering a CS timestamp, a full packet queue or the end of
		  trace for that block.
		
		  Function cs_etm_decoder__do_{hard|soft}_timestamp() does all
		  the timestamp calculation for us.
 We found a timestamp, no need to continue. 
		
		  We didn't find a timestamp so empty all the traceid packet
		  queues before looking for another timestamp packet, either
		  in the current data block or a new one.  Packets that were
		  just decoded are useless since no timestamp has been
		  associated with them.  As such simply discard them.
	
	  We have a timestamp.  Add it to the min heap to reflect when
	  instructions conveyed by the range packets of this traceID queue
	  started to execute.  Once the same has been done for all the traceID
	  queues of each etmq, redenring and decoding can start in
	  chronological order.
	 
	  Note that packets decoded above are still in the traceID's packet
	  queue and will be processed in cs_etm__process_queues().
	
	  Set the number of records before early exit: ->nr is used to
	  determine how many branches to copy from ->entries.
	
	  Early exit when there is nothing to copy.
	
	  As bs_src->entries is a circular buffer, we need to copy from it in
	  two steps.  First, copy the branches from the most recently inserted
	  branch ->last_branch_pos until the end of bs_src->entries buffer.
	
	  If we wrapped around at least once, the branches from the beginning
	  of the bs_src->entries buffer and until the ->last_branch_pos element
	  are older valid branches: copy them over.  The total number of
	  branches copied over will be equal to the number of branches asked by
	  the user in last_branch_sz.
	
	  T32 instruction size is indicated by bits[15:11] of the first
	  16-bit word of the instruction: 0b11101, 0b11110 and 0b11111
	  denote a 32-bit instruction.
 Returns 0 for the CS_ETM_DISCONTINUITY packet 
 Returns 0 for the CS_ETM_DISCONTINUITY packet 
 Assume a 4 byte instruction size (A32A64) 
	
	  The branches are recorded in a circular buffer in reverse
	  chronological order: we start recording from the last element of the
	  buffer down.  After writing the first element of the stack, move the
	  insert position back to the end of the buffer.
 No support for mispredict 
	
	  Increment bs->nr until reaching the number of last branches asked by
	  the user on the command line.
 If no more data, drop the previous auxtrace_buffer and return 
 If the aux_buffer doesn't have data associated, try to load it 
 get the file desc associated with the perf data file 
 If valid, drop the previous buffer 
	
	  It's pointless to read instructions for the CS_ETM_DISCONTINUITY
	  packet, so directly bail out with 'insn_len' = 0.
	
	  T32 instruction size might be 32-bit or 16-bit, decide by calling
	  cs_etm__t32_instr_size().
 Otherwise, A64 and A32 instruction size are always 32-bit. 
  The cs etm packet encodes an instruction range between a branch target
  and the next taken branch. Generate sample accordingly.
	
	  perf report cannot handle events without a branch stack
 create new id val to be a fixed offset from evsel id 
		
		  We don't use the hardware index, but the sample generation
		  code uses the new format branch_stack with this field,
		  so the event attributes must indicate that it's present.
 Get instructions remainder from previous packet 
	
	  Record a branch when the last instruction in
	  PREV_PACKET is a branch.
		
		  Emit instruction sample periodically
		  TODO: allow period to be defined in cycles and clock time
		
		  Below diagram demonstrates the instruction samples
		  generation flows:
		 
		     Instrs     Instrs       Instrs       Instrs
		    Sample(n)  Sample(n+1)  Sample(n+2)  Sample(n+3)
		     |            |            |            |
		     V            V            V            V
		    --------------------------------------------------
		             ^                                  ^
		             |                                  |
		          Period                             Period
		     instructions(Pi)                   instructions(Pi')
		 
		             |                                  |
		             \---------------- -----------------
		                              V
		                  tidq->packet->instr_count
		 
		  Instrs Sample(n...) are the synthesised samples occurring
		  every etm->instructions_sample_period instructions - as
		  defined on the perf command line.  Sample(n) is being the
		  last sample before the current etm packet, n+1 to n+3
		  samples are generated from the current etm packet.
		 
		  tidq->packet->instr_count represents the number of
		  instructions in the current etm packet.
		 
		  Period instructions (Pi) contains the the number of
		  instructions executed after the sample point(n) from the
		  previous etm packet.  This will always be less than
		  etm->instructions_sample_period.
		 
		  When generate new samples, it combines with two parts
		  instructions, one is the tail of the old packet and another
		  is the head of the new coming packet, to generate
		  sample(n+1); sample(n+2) and sample(n+3) consume the
		  instructions with sample period.  After sample(n+3), the rest
		  instructions will be used by later packet and it is assigned
		  to tidq->period_instructions for next round calculation.
		
		  Get the initial offset into the current packet instructions;
		  entry conditions ensure that instrs_prev is less than
		  etm->instructions_sample_period.
 Prepare last branches for instruction sample 
			
			  Calculate the address of the sampled instruction (-1
			  as sample is reported as though instruction has just
			  been executed, but PC has not advanced to next
			  instruction)
 Generate sample for tracing on packet 
 Generate sample for branch taken packet 
	
	  When the exception packet is inserted, whether the last instruction
	  in previous range packet is taken branch or not, we need to force
	  to set 'prev_packet->last_instr_taken_branch' to true.  This ensures
	  to generate branch sample for the instruction range before the
	  exception is trapped to kernel or before the exception returning.
	 
	  The exception packet includes the dummy address values, so don't
	  swap PACKET with PREV_PACKET.  This keeps PREV_PACKET to be useful
	  for generating instruction and branch samples.
 Handle start tracing packet 
 Prepare last branches for instruction sample 
		
		  Generate a last branch event for the branches left in the
		  circular buffer at the end of the trace.
		 
		  Use the address of the end of the last reported execution
		  range
 Reset last branches after flush the trace 
	
	  It has no new packet coming and 'etmq->packet' contains the stale
	  packet which was set at the previous time with packets swapping;
	  so skip to generate branch sample to avoid stale packet.
	 
	  For this case only flush branch stack and generate a last branch
	  event for the branches left in the circular buffer at the end of
	  the trace.
 Prepare last branches for instruction sample 
		
		  Use the address of the end of the last reported execution
		  range.
  cs_etm__get_data_block: Fetch a block from the auxtrace_buffer queue
 			   if need be.
  Returns:	< 0	if error
 		= 0	if no more auxtrace_buffer to read
 		> 0	if the current buffer isn't empty yet
		
		  We cannot assume consecutive blocks in the data file
		  are contiguous, reset the decoder to force re-sync.
 Initialise to keep compiler happy 
		
		  The SVC of T32 is defined in ARM DDI 0487D.a, F5.1.247:
		 
		   b'15         b'8
		  +-----------------+--------+
		  | 1 1 0 1 1 1 1 1 |  imm8  |
		  +-----------------+--------+
		 
		  According to the specification, it only defines SVC for T32
		  with 16 bits instruction and has no definition for 32bits;
		  so below only read 2 bytes as instruction size for T32.
		
		  The SVC of A32 is defined in ARM DDI 0487D.a, F5.1.247:
		 
		   b'31 b'28 b'27 b'24
		  +---------+---------+-------------------------+
		  |  !1111  | 1 1 1 1 |        imm24            |
		  +---------+---------+-------------------------+
		
		  The SVC of A64 is defined in ARM DDI 0487D.a, C6.2.294:
		 
		   b'31               b'21           b'4     b'0
		  +-----------------------+---------+-----------+
		  | 1 1 0 1 0 1 0 0 0 0 0 |  imm16  | 0 0 0 0 1 |
		  +-----------------------+---------+-----------+
	
	  ETMv4 exception type CS_ETMV4_EXC_CALL covers SVC, SMC and
	  HVC cases; need to check if it's SVC instruction based on
	  packet address.
		
		  For CS_ETMV4_EXC_CALL, except SVC other instructions
		  (SMC, HVC) are taken as sync exceptions.
		
		  ETMv4 has 5 bits for exception number; if the numbers
		  are in the range ( CS_ETMV4_EXC_FIQ, CS_ETMV4_EXC_END ]
		  they are implementation defined exceptions.
		 
		  For this case, simply take it as sync exception.
		
		  Immediate branch instruction without neither link nor
		  return flag, it's normal branch instruction within
		  the function.
		
		  Immediate branch instruction with link (e.g. BL), this is
		  branch instruction for function call.
		
		  Indirect branch instruction with link (e.g. BLR), this is
		  branch instruction for function call.
		
		  Indirect branch instruction with subtype of
		  OCSD_S_INSTR_V7_IMPLIED_RET, this is explicit hint for
		  function return for A32T32.
		
		  Indirect branch instruction without link (e.g. BR), usually
		  this is used for function return, especially for functions
		  within dynamic link lib.
 Return instruction for function return. 
		
		  Decoder might insert a discontinuity in the middle of
		  instruction packets, fixup prev_packet with flag
		  PERF_IP_FLAG_TRACE_BEGIN to indicate restarting trace.
		
		  If the previous packet is an exception return packet
		  and the return address just follows SVC instruction,
		  it needs to calibrate the previous packet sample flags
		  as PERF_IP_FLAG_SYSCALLRET.
		
		  The trace is discontinuous, if the previous packet is
		  instruction packet, set flag PERF_IP_FLAG_TRACE_END
		  for previous packet.
 The exception is for system call. 
		
		  The exceptions are triggered by external signals from bus,
		  interrupt controller, debug module, PE reset or halt.
		
		  Otherwise, exception is caused by trap, instruction &
		  data fault, or alignment errors.
		
		  When the exception packet is inserted, since exception
		  packet is not used standalone for generating samples
		  and it's affiliation to the previous instruction range
		  packet; so set previous range packet flags to tell perf
		  it is an exception taken branch.
		
		  When the exception return packet is inserted, since
		  exception return packet is not used standalone for
		  generating samples and it's affiliation to the previous
		  instruction range packet; so set previous range packet
		  flags to tell perf it is an exception return branch.
		 
		  The exception return can be for either system call or
		  other exception types; unfortunately the packet doesn't
		  contain exception type related info so we cannot decide
		  the exception type purely based on exception return packet.
		  If we record the exception number from exception packet and
		  reuse it for exception return packet, this is not reliable
		  due the trace can be discontinuity or the interrupt can
		  be nested, thus the recorded exception number cannot be
		  used for exception return packet for these two cases.
		 
		  For exception return packet, we only need to distinguish the
		  packet is for system call or for other types.  Thus the
		  decision can be deferred when receive the next packet which
		  contains the return address, based on the return address we
		  can read out the previous instruction and check if it's a
		  system call instruction and then calibrate the sample flag
		  as needed.
	
	  Packets are decoded and added to the decoder's packet queue
	  until the decoder packet processing callback has requested that
	  processing stops or there is nothing left in the buffer.  Normal
	  operations that stop processing are a timestamp packet or a full
	  decoder buffer queue.
 Process each packet in this chunk 
			
			  Stop processing this chunk on
			  end of data or error
		
		  Since packet addresses are swapped in packet
		  handling within below switch() statements,
		  thus setting sample flags must be called
		  prior to switch() statement to use address
		  information before packets swapping.
			
			  If the packet contains an instruction
			  range, generate instruction sequence
			  events.
			
			  If the exception packet is coming,
			  make sure the previous instruction
			  range packet to be handled properly.
			
			  Discontinuity in trace, flush
			  previous branch stack
			
			  Should not receive empty packet,
			  report error.
 Ignore return value 
		
		  Generate an instruction sample with the remaining
		  branchstack entries.
 Go through each buffer in the queue and decode them one by one 
 Run trace decoder until buffer consumed or end of trace 
			
			  Process each packet in this chunk, nothing to do if
			  an error occurs other than hoping the next one will
			  be better.
 Flush any remaining branch stack entries 
	
	  Pre-populate the heap with one entry from each queue so that we can
	  start processing in time order across all queues.
 Take the entry at the top of the min heap 
		
		  Remove the top entry from the heap since we are about
		  to process it.
			
			  No traceID queue has been allocated for this traceID,
			  which means something somewhere went very wrong.  No
			  other choice than simply exit.
		
		  Packets associated with this timestamp are already in
		  the etmq's traceID queue, so process them.
		
		  Packets for this timestamp have been processed, time to
		  move on to the next timestamp, fetching a new auxtrace_buffer
		  if need be.
		
		  No more auxtrace_buffers to process in this etmq, simply
		  move on to another entry in the auxtrace_heap.
			
			  Function cs_etm__decode_data_block() returns when
			  there is no more traces to decode in the current
			  auxtrace_buffer OR when a timestamp has been
			  encountered on any of the traceID queues.  Since we
			  did not get a timestamp, there is no more traces to
			  process in this auxtrace_buffer.  As such empty and
			  flush all traceID queues.
 Fetch another auxtrace_buffer for this etmq 
		
		  Add to the min heap the timestamp for packets that have
		  just been decoded.  They will be processed and synthesized
		  during the next call to cs_etm__process_traceid_queue() for
		  this queuetraceID.
	
	  Add the tidpid to the log so that we can get a match when
	  we get a contextID from the decoder.
	
	  Context switch in per-thread mode are irrelevant since perf
	  will startstop tracing as the process is scheduled.
	
	  SWITCH_IN events carry the next process to be switched out while
	  SWITCH_OUT events carry the process to be switched in.  As such
	  we don't care about IN events.
	
	  Add the tidpid to the log so that we can get a match when
	  we get a contextID from the decoder.
	
	  Don't wait for cs_etm__flush_events() in per-threadtimeless mode to start the decode. We
	  need the tid of the PERF_RECORD_EXIT event to assign to the synthesised samples because
	  ETM_OPT_CTXTID is not enabled.
		
		  Record the latest kernel timestamp available in the header
		  for samples so that synthesised samples occur from this point
		  onwards.
	
	  Find all buffers with same reference in the queues and dump them.
	  This is because the queues can contain multiple entries of the same
	  buffer that were split on aux records.
		
		  Knowing if the trace is formatted or not requires a lookup of
		  the aux record so only works in non-piped mode where data is
		  queued in cs_etm__queue_aux_records(). Always assume
		  formatted in piped mode (true).
 Override timeless mode with user input from --itrace=Z 
	
	  Circle through the list of event and complain if we find one
	  with the time bit set.
 check magic value 
 failure - note bad magic value 
 print common header block 
 after common block, offset format index past NR_PARAMS 
 after common block, offset format index past NR_PARAMS 
 total params to print is NR_PARAMS + common block size for v1 
 if newer record - could be excess params 
		
		  ETE and ETMv4 can be printed in the same block because the number of parameters
		  is saved and they share the list of parameter names. ETE is also only supported
		  in V1 files.
 if newer record - could be excess params 
 failure - note bad magic value and error out 
 bail out early on bad header version 
 failure.. return 
  Read a single cpu parameter block from the auxtrace_info priv block.
  For version 1 there is a per cpu nr_params entry. If we are handling
  version 1 file, then there may be less, the same, or more params
  indicated by this value than the compile time number we understand.
  For a version 0 info block, there are a fixed number, and we need to
  fill out the nr_param value in the metadata we create.
 read block current index & version 
 read version 0 info block into a version 1 metadata block  
 remaining block params at offset +1 from source 
 version 0 has 2 common params 
 read version 1 info block - input and output nr_params may differ 
 version 1 has 3 common params 
 if input has more params than output - skip excess 
 record the actual nr params we copied 
 adjust in offset by number of in params used 
  Puts a fragment of an auxtrace buffer into the auxtrace queues based
  on the bounds of aux_event, if it matches with the buffer that's at
  file_offset.
  Normally, whole auxtrace buffers would be added to the queue. But we
  want to reset the decoder for every PERF_RECORD_AUX event, and the decoder
  is reset across each buffer, so splitting the buffers up in advance has
  the same effect.
	
	  There should be a PERF_RECORD_AUXTRACE event at the file_offset that we got
	  from looping through the auxtrace index.
	
	  In per-thread mode, CPU is set to -1, but TID will be set instead. See
	  auxtrace_mmap_params__set_idx(). Return 'not found' if neither CPU nor TID match.
		
		  Clamp size in snapshot mode. The buffer size is clamped in
		  __auxtrace_mmap__read() for snapshots, so the aux record size doesn't reflect
		  the buffer size.
		
		  In this mode, the head also points to the end of the buffer so aux_offset
		  needs to have the size subtracted so it points to the beginning as in normal mode
		
		  If this AUX event was inside this buffer somewhere, create a new auxtrace event
		  based on the sizes of the aux event, and queue that fragment.
 Wasn't inside this buffer, but there were no parse errors. 1 == 'not found' 
 Don't care about any other events, we're only queuing buffers for AUX events 
 Truncated Aux records can have 0 size and shouldn't result in anything being queued. 
	
	  Parse the sample, we need the sample_id_all data that comes after the event so that the
	  CPU or PID can be matched to an AUXTRACE buffer's CPU or PID.
	
	  Loop through the auxtrace index to find the buffer that matches up with this aux event.
			
			  Stop search on error or successful values. Continue search on
			  1 ('not found')
	
	  Couldn't find the buffer corresponding to this aux record, something went wrong. Warn but
	  don't exit with an error because it will still be possible to decode other aux records.
	
	  We would get here if there are no entries in the index (either no auxtrace
	  buffers or no index at all). Fail silently as there is the possibility of
	  queueing them in cs_etm__process_auxtrace_event() if etm->data_queued is still
	  false.
	 
	  In that scenario, buffers will not be split by AUX records.
	
	  sizeof(auxtrace_info_event::type) +
	  sizeof(auxtrace_info_event::reserved) == 8
 First the global part 
 Look for version of the header 
 print routine will print an error on bad version 
 Extract header information - see cs-etm.h for format 
	
	  Create an RB tree for traceID-metadata tuple.  Since the conversion
	  has to be made for each packet that gets decoded, optimizing access
	  in anything other than a sequential array is worth doing.
	
	  The metadata is stored in the auxtrace_info section and encodes
	  the configuration of the ARM embedded trace macrocell which is
	  required by the trace decoder to properly decode the trace due
	  to its highly compressed nature.
 The traceID is our handle 
 The traceID is our handle 
 ETE shares first part of metadata with ETMv4 
 Get an RB node for this CPU 
 Something went wrong, no need to continue 
		
		  The node for that CPU should not be taken.
		  Back out if that's the case.
 All good, associate the traceID with the metadata pointer 
	
	  Each of CS_HEADER_VERSION_MAX, CS_ETM_PRIV_MAX and
	  CS_ETMV4_PRIV_MAX mark how many double words are in the
	  global metadata, and each cpu's metadata respectively.
	  The following tests if the correct number of double words was
	  present in the auxtrace info section.
	
	  Initialize list node so that at thread__zput() we can avoid
	  segmentation fault at list_del_init().
	
	  Print warning in pipe mode, see cs_etm__process_auxtrace_event() and
	  cs_etm__queue_aux_fragment() for details relating to limitations.
 No need to check @metadata[j], free(NULL) is supported 
	
	  At this point, as a minimum we have valid header. Dump the rest of
	  the info section - the print routines will error out on structural
	  issues.
 SPDX-License-Identifier: GPL-2.0
 used to match cgroup name with patterns 
 HAVE_FILE_HANDLE 
	
	  check if cgrp is already defined, if so we reuse it
	
	  find corresponding event
	  if add cgroup N, then need to find event N
 helper function for ftw() in match_cgroups and list_cgroups 
 collect given cgroups only 
 use given name as is - for testing purpose 
 pretend if it's added by ftw() 
 these groups will be used 
 collect all cgroups first and then match with the pattern 
 cgroup_name will have a full path, skip the root directory 
 collect all cgroups in the cgroup_list 
 allow empty cgroups, i.e., skip 
 termination added 
 check cgroup name with the pattern 
 first entry to root cgroup 
 allow empty cgroups, i.e., skip 
 termination added 
 nr_cgroups is increased een for empty cgroups 
 for the case one cgroup combine to multiple events 
 save original events and init evlist 
 cgroup_name might have a full path, skip the prefix 
 cgroup__new() has a refcount, release it here 
 SPDX-License-Identifier: GPL-2.0-only
  System call table mapper
  (C) 2016 Arnaldo Carvalho de Melo <acme@redhat.com>
 HAVE_SYSCALL_TABLE_SUPPORT 
 HAVE_SYSCALL_TABLE_SUPPORT 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  config.c
  Helper functions for parsing config items.
  Originally copied from GIT source.
  Copyright (C) Linus Torvalds, 2005
  Copyright (C) Johannes Schindelin, 2005
 proc_map_timeout 
 perf_hist_config 
 perf_llvm_config 
 perf_stat__set_big_num 
 evsel__hw_names, evsel__use_bpf_counters 
 root dir for buildid, binary cache 
 DOS like systems 
 Some characters escape as themselves 
 Reject unknown escape sequences 
 Get the full name 
 We require the format to be '[base "extension"]' 
 Final ']' 
 U+FEFF Byte Order Mark in UTF8 
			 We are at the file beginning; skip UTF8-encoded BOM
			  if present. Sane editors won't put this in on their
 Do not tolerate partial BOM. 
 No BOM at file beginning. Cool. 
		
		  The get_value function might or might not reach the '\n',
		  so saving the current line number for error reporting.
 same dir for all commands 
 Add other config variables here. 
 Add other config variables here. 
 Add other config variables here. 
 Add other config variables here. 
	
	  Skip reading user config if:
	    - there is no place to read it from (HOME)
	    - we are asked not to (PERF_CONFIG_NOGLOBAL=1)
	 perf_config_set can contain both user and system config items.
	  So we should know where each value is from.
	  The classification would be needed when a particular config file
	  is overwritten by setting feature i.e. set_config().
 Setting $PERF_CONFIG makes perf read _only_ the given config file. 
				
				  Can't be just a 'break', as perf_config_set__for_each_entry()
				  expands to two nested for() loops.
  Call this to report error for your variable that should not
  get a boolean value (i.e. "[my] var" means "true").
 default to $HOME.debug 
 for communicating with external commands 
 SPDX-License-Identifier: GPL-2.0
  http:en.wikipedia.orgwikiAlgorithms_for_calculating_variance
        (\Sum n_i^2) - ((\Sum n_i)^2)n
  s^2 = -------------------------------
                   n - 1
  http:en.wikipedia.orgwikiStddev
  The std dev of the mean is related to the std dev by:
              s
  s_mean = -------
           sqrt(n)
 ps->id is 0 hence PERF_STAT_EVSEL_ID__NONE by default 
	
	  To collect the overall statistics for interval mode,
	  we copy the counts from evsel->prev_raw_counts to
	  evsel->counts. The perf_stat_process_counter creates
	  aggr values from per cpu values, but the per cpu values
	  are 0 for AGGR_GLOBAL. So we use a trick that saves the
	  previous aggr value to the first member of perf_counts,
	  then aggr calculation in process_counter_values can work
	  correctly.
	
	  we do not consider an event that has not run as a good
	  instance to mark a package as used (skip=1). Otherwise
	  we may run into a situation where the first CPU in a package
	  is not running anything, yet the second is, and this function
	  would mark the package as used after the first CPU and would
	  not read the values from the second CPU.
	
	  On multi-die system, die_id > 0. On no-die system, die_id = 0.
	  We use hashmap(socket, die) to check the used socket+die pair.
	
	  Save the full runtime - to allow normalization during printout:
	
	  The event is part of non trivial group, let's enable
	  the group read (for leader) and ID retrieval for all
	  members.
	
	  Some events get initialized with sample_(periodtype) set,
	  like tracepoints. Clear it up for counting.
	
	  Disabling all counters initially, they will be enabled
	  either manually by us or by kernel via enable_on_exec
	  set later.
		
		  In case of initial_delay we enable tracee
		  events manually.
 SPDX-License-Identifier: GPL-2.0
  Provide these two so that we don't have to link against callchain.c and
  start dragging hist.c, etc.
  Add this one here not to drag utilenv.c
  Add this one here not to drag utilstat-shadow.c
  This one is needed not to drag the PMU bandwagon, jevents generated
  pmu_sys_event_tables, etc and evsel__find_pmu() is used so far just for
  doing per PMU perf_event_attr.exclude_guest handling, not really needed, so
  far, for the perf python binding known usecases, revisit if this become
  necessary.
  Add this one here not to drag utilmetricgroup.c
  XXX: All these evsel destructors need some better mechanism, like a linked
  list of destructors registered when the relevant code indeed is used instead
  of having more and more calls in perf_evsel__delete(). -- acme
  For now, add some more:
  Not to drag the BPF bandwagon...
  Support debug printing even though utildebug.c is not linked.  That means
  implementing 'verbose' and 'eprintf'.
 Define PyVarObject_HEAD_INIT for python 2.5 
	
 	  FIXME: return the array of read values,
 	  making this method useful ;-)
 union... 
 FIXME: throw right exception 
 Bitfields 
	
	  This will group just the fds for this single evsel, to group
	  multiple events, use evlist.open().
 Consume the even only after we parsed it out. 
 m_name 
 m_doc 
 m_size 
 m_methods 
 m_reload 
 m_traverse 
 m_clear 
 m_free 
 The page_size is placed in util object. 
  Dummy, to avoid dragging all the test_attr infrastructure in the python
  binding.
 SPDX-License-Identifier: GPL-2.0-only
  svghelper.c - helper functions for outputting svg
  (C) Copyright 2009 Intel Corporation
  Authors:
      Arjan van de Ven <arjan@linux.intel.com>
  Round text sizes so that the svg viewer only needs a discrete
  number of renderings of the font
	
	  if the recording is short, we default to a width of 1000, but
	  for longer recordings we want at least 200 units of width per second
www.w3.orgGraphicsSVG1.1DTDsvg11.dtd\">\n");
www.w3.org2000svg\">\n", svg_page_width, total_height);
 less than 1 usec 
 less than 1 msec 
 10 msec 
 CPU type 
 CPU type 
 default: just put the Number in 
 SPDX-License-Identifier: GPL-2.0
  AMD specific. Provide textual annotation for IBS raw sample data.
		
		  Erratum #1238 workaround is to ignore MSRC001_1030[IbsIcMiss]
		  Erratum #1347 workaround is to use table provided in erratum
	
	  Erratum #1293
	  Ignore L2Miss and OpDcMissOpenMemReqs (and opdata2) if DcMissNoMabAlloc or SwPf set
  IBS OpExecution MSRs always saved, in order, are:
  IBS_OP_CTL, IBS_OP_RIP, IBS_OP_DATA, IBS_OP_DATA2,
  IBS_OP_DATA3, IBS_DC_LINADDR, IBS_DC_PHYSADDR, BP_IBSTGT_RIP
	
	  Erratum #1293: ignore op_data2 if DcMissNoMabAlloc or SwPf are set
  IBS Fetch MSRs always saved, in order, are:
  IBS_FETCH_CTL, IBS_FETCH_LINADDR, IBS_FETCH_PHYSADDR, IC_IBS_EXTD_CTL
  Test for enable and valid bits in captured control MSRs.
 AMD vendor specific raw sample function. Check for PERF_RECORD_SAMPLE events
  and if the event was triggered by IBS, display its raw data with decoded text.
  The function is only invoked when the dump flag -D is set.
	
	  cpuid = "AuthenticAMD,family,model,stepping"
  Find and assign the type number used for ibs_op or ibs_fetch samples.
  Device names can be large - we are only interested in the first 9 characters,
  to match "ibs_fetch".
 '\0' ;
 SPDX-License-Identifier: GPL-2.0-only 
 page_size
 To get things like MAP_HUGETLB even on older libc headers 
  Assumes that the first 4095 bytes of procpidstat contains
  the comm, tgid and ppid.
 strlen("Name:") 
 strlen("Tgid:") 
 strlen("PPid:") 
	
	  for main thread set parent to ppid from status file. For other
	  threads set parent pid to main thread. ie., assume main thread
	  spawns all threads in a process
 map protection and flags bits 
		
		  We raced with a task exiting - just return:
anon";
 ensure null termination since stack will be reused. 
 00400000-0040c000 r-xp 00000000 fd:01 41038  bincat 
		
		  Just like the kernel, see __perf_event_mmap in kernelperf_event.c
 any sane path should be less than PATH_MAX 
 length of mount point in the path 
 make sure the path starts with a slash (after mount point) 
	
	  kernel uses 0 for user space maps, see kernelperf_event.c
	  __perf_event_mmap
 special case: only send one comm event using passed in pid 
		
		  send mmap only for thread group leader
		  see thread__init_maps()
		
		  Send the prepared comm event
 process the parent's maps too 
		
		  comm.pid is set to thread group id by
		  perf_event__synthesize_comm
 is thread group leader in thread_map? 
 if not, generate events for it 
 only interested in proper numerical dirents 
		
		  We may race with exiting thread, so don't stop just because
		  one thread couldn't be synthesized.
	
	  We should get this from syskernelsections.text, but till that is
	  available use this, and after it is use this as a fallback for older
	  kernels.
		
		  kernel uses PERF_RECORD_MISC_USER for user space maps,
		  see kernelperf_event.c __perf_event_mmap
 bit position of the cpu is + 1 
	
	  Both array and mask data have variable size based
	  on the number of cpus and their actual values.
	  The size of the 'struct perf_record_cpu_map_data' is:
	 
	    array = size of 'struct cpu_map_entries' +
	            number of cpus  sizeof(u64)
	 
	    mask  = size of 'struct perf_record_record_cpu_map' +
	            maximum cpu bit converted to size of longs
	 
	  and finally + the size of 'struct perf_record_cpu_map_data'.
 PERF_FORMAT_ID is forced for PERF_SAMPLE_READ 
 nr, hw_idx 
	
	  used for cross-endian analysis. See git commit 65014ab3
	  for why this goofiness is needed.
 PERF_FORMAT_ID is forced for PERF_SAMPLE_READ 
 nr, hw_idx 
 command specified 
	
	  Synthesize other events stuff not carried within
	  attr event - unit, scale, name
		
		  Synthesize unit and scale only if it's defined.
		
		  Name is needed only for pipe output,
		  perf.data carries event names.
	
	  We are going to store the size of the data followed
	  by the data contents. Since the fd descriptor is a pipe,
	  we cannot seek back to store the size of the data once
	  we know it. Instead we:
	 
	  - write the tracing data to the temp file
	  - getwrite the data size to pipe
	  - write the tracing data from the temp file
	    to the pipe
	
	  The put function will copy all the tracing data
	  stored in temp file to the pipe.
 get a nice alignment 
 ff.buf may have changed due to realloc in do_write() 
 Send HEADER_LAST_FEATURE mark. 
	
	  We need to synthesize events first, because some
	  features works on top of them (on report side).
		
		  FIXME err <= 0 here actually means that
		  there were no tracepoints so its not really
		  an error, just that we don't need to
		  synthesize anything.  We really have to
		  return this more properly and also
		  propagate errors that now are calling die()
 SPDX-License-Identifier: GPL-2.0
			
			  Special treatment for -1, which is not real cpu number,
			  and we need to use (int) -1 to initialize map[i],
			  otherwise it would become 65535.
 Reset size as it may only be partially filled 
 ensure we process id in increasing order 
 There is no die_id on legacy system. 
	
	  die_id is relative to socket, so start
	  with the socket ID and then add die to
	  make a unique ID.
 cpu_map__get_die returns a struct with socket and die set
	
	  core_id is relative to socket and die, we need a global id.
	  So we combine the result from cpu_map__get_die with the core id
 setup simple routines to easily access node numbers given a cpu number 
 start on the right, to find highest node num 
 convert from 0-based to 1-based 
 Determine highest possible cpu in the system for sparse allocation 
 set up default 
 get the highest possible cpu number for a sparse allocation 
 get the highest present cpu number for a sparse allocation 
 Determine highest possible node in the system for sparse allocation 
 set up default 
 get the highest possible cpu number for a sparse allocation 
 initialize globals 
 walk tree and setup map 
 thread unsafe 
 from sysdevicessystemcpuonline 
 SPDX-License-Identifier: GPL-2.0
  dlfilter.c: Interface to perf script --dlfilter shared object
  Copyright (c) 2021, Intel Corporation.
 'size' is also used to indicate already initialized 
 'size' is also used to indicate already initialized 
		
		  Prepend "." so that dlopen will find the file in the
		  current directory.
 To indicate d_ip_al is not initialized 
 To indicate d_addr_al is not initialized 
 SPDX-License-Identifier: GPL-2.0-only
  genelf.c
  Copyright (C) 2014, Google, Inc
  Contributed by:
  	Stephane Eranian <eranian@gmail.com>
 different uuid for each run 
 does not seem to work well when linked with Java 
 different uuid for each run 
 Size of entry's owner string 
 Size of the note descriptor 
 Interpretation of the descriptor 
 Start of the name+desc data 
  1 
  7 
 17 
 25 
 33 
 52 
 64 
 76 
 90 
 104 
 descsz: size of build-id, must be multiple of 4 
 GNU\0 
 symbol 0 MUST be the undefined symbol 
 index in sym_string table 
 for now 
 index in sym_string table 
 for now 
 for now 
	
	  setup eh_frame section
	
	  setup eh_frame_hdr section
  fd: file descriptor open for writing for the output file
  load_addr: code load address (could be zero, just used for buildid)
  sym: function name (for native code - used as the symbol)
  code: the native code
  csize: the code size in bytes
	
	  setup ELF header
 shdr index for section name 
	
	  setup text section
	
	  Setup .eh_frame_hdr and .eh_frame
	
	  setup section headers string table
 offset of '.shstrtab' in shd_string_table 
	
	  setup symtab section
 offset of '.symtab' in shd_string_table 
 index of .strtab section 
	
	  setup symbols string table
	  2 = 1 for 0 in 1st entry, 1 for the 0 at end of symbol for 2nd entry
 offset in shd_string_table 
	
	  setup build-id section
	
	  build-id generation
 must include 0 termination 
 offset in shd_string_table 
 SPDX-License-Identifier: GPL-2.0
 Show binary offset for userspace addr 
 Add srccode here too? 
 PYTHON_PERF 
 SPDX-License-Identifier: GPL-2.0-only
	
	  In order to read symbols from other namespaces perf to needs to call
	  setns(2).  This isn't permitted if the struct_fs has multiple users.
	  unshare(2) the fs so that we may continue to setns into namespaces
	  that we're observing when, for instance, reading the build-ids at
	  the end of a 'perf record' session.
 SPDX-License-Identifier: GPL-2.0
 lsdir()
 100ms 
 Avoid "SyS" kernel syscall aliases 
 Prefer a symbol with non zero length 
 Prefer a non weak symbol over a weak one 
 Prefer a global symbol over a non global one 
 Prefer a symbol with less underscores 
 Choose the symbol with the longest name 
 Last entry 
	
	  We still haven't the actual symbols, so guess the
	  last map final address.
		
		  ppc64 uses function descriptors and appends a '.' to the
		  start of every instruction address. Remove it.
 return first symbol that has same name (if any) 
 update the symbol cache if necessary 
   Returns first symbol that matched with @name.
  While we find nice hex chars, build a long_val.
  Return number of chars processed.
 \n 
  These are symbols in the kernel image, so make sure that
  sym is from a kernel DSO.
 Ignore local symbols for ARM modules 
	
	  module symbols are not sorted so we add all
	  symbols, setting length to 0, and rely on
	  symbols__fixup_end() to fix it up.
	
	  We will pass the symbols to the filter later, in
	  map__split_kallsyms, when we have split the maps per module
  Loads the function entries in prockallsyms into kernel_map->dso,
  so that we can in the next step set the symbol ->end address and then
  call kernel_maps__split_kallsyms.
 Symbols have been adjusted 
  Split the symbols into maps, making sure there are no overlaps, i.e. the
  kernel range is broken in several maps, named [kernel].N, as we don't have
  the original ELF section names vmlinux have.
					
					  We assume all symbols of a module are
					  continuous in  kallsyms, so curr_map
					  points to a module and all its
					  symbols are in its kmap. Mark it as
					  loaded.
			
			  So that we look just like we get from .ko files,
			  i.e. not prelinked, relative to initial_map->start.
			
			  These symbols are not needed anymore since the
			  trampoline maps refer to the text section and it's
			  symbols instead. Avoid having to deal with
			  relocations, and the assumption that the first symbol
			  is the start of kernel text, by simply removing the
			  symbols at this point.
 Kernel was relocated at boot time 
 Kernel was relocated at boot time 
 Module must be in memory at the same address 
  If kallsyms is referenced by name then we look for filename in the same
  directory.
  Merges map into maps by splitting the new map within the existing map
  regions.
 no overload with this one 
			
			  |new......
			        |old....
				
				  |new......|     -> |new..|
				        |old....| ->       |old....|
				
				  |new.............| -> |new..|       |new..|
				        |old....|    ->       |old....|
			
			       |new......
			  |old....
				
				       |new..|   -> x
				  |old.........| -> |old.........|
				
				       |new......| ->         |new...|
				  |old....|        -> |old....|
 This function requires that the map is the kernel map 
 Modules and kernel must be present at their original addresses 
 Read new maps into temporary lists 
 Remove old maps 
		
		  We need to preserve eBPF maps even if they are
		  covered by kcore, because we need to access
		  eBPF dso for source data.
 Find the kernel map using the '_stext' symbol 
 Add new maps 
 Ensure maps are correctly ordered 
			
			  Merge kcore map into existing maps,
			  and ensure that current maps (eBPF)
			  stay intact.
		
		  If one of the corresponding symbols is there, assume the
		  entry trampoline maps are too.
	
	  Set the data type and long name so that kcore can be read via
	  dso__data_read_addr().
  If the kernel is relocated at boot time, kallsyms won't match.  Compute the
  delta based on the relocation reference symbol.
 \n 
 PE symbols can only have 4 bytes, so use .text high bits 
		
		  kernel modules know their symtab type - it's set when
		  creating a module dso in machine__addnew_module_map().
 Checks for the existence of the perf-<pid>.map file in two different
  locations.  First, if the process is a separate mount namespace, check in
  that namespace using the pid of the innermost pid namespace.  If's not in a
  namespace, or the file can't be found there, try in the mount namespace of
  the tracing process using our view of its pid.
 check again under the dso->lock 
	
	  Read the build id if possible. This is required for
	  DSO_BINARY_TYPE__BUILDID_DEBUGINFO to work
	
	  Iterate over candidate debug images.
	  Keep track of "interesting" ones (those which have a symtab, dynsym,
	  andor opd section) for processing.
 We'll have to hope for the best 
	
	  If we have maps->maps_by_name, then the name isn't in the rbtree,
	  as maps->maps_by_name mirrors the rbtree when lookups by name are
	  made.
 Fallback to traversing the rbtree... 
  Use open(O_RDONLY) to check readability directly instead of access(R_OK)
  since access(R_OK) only checks with real UIDGID but open() use effective
  UIDGID and actual capabilities (e.g. prockcore requires CAP_SYS_RAWIO).
		
		  Last resort, if we don't have a build-id and couldn't find
		  any vmlinux file, try the running kernel kallsyms table.
 Try a fast path for prockallsyms if possible 
		
		  Do not check the build-id cache, unless we know we cannot use
		  prockcore or module maps don't match to prockallsyms.
		  To check readability of prockcore, do not use access(R_OK)
		  since prockcore requires CAP_SYS_RAWIO to read and access
		  can't check it.
 Find kallsyms in build-id cache with kcore 
 Use current prockallsyms if possible 
 Finally, find a cache of kallsyms 
	
	  Step 1: if the user specified a kallsyms or vmlinux filename, use
	  it and only it, reporting errors to the user if it cannot be used.
	 
	  For instance, try to analyse an ARM perf.data file _without_ a
	  build-id, or if the user specifies the wrong path to the right
	  vmlinux file, obviously we can't fallback to another vmlinux (a
	  x86_86 one, on the machine where analysis is being performed, say),
	  or worse, prockallsyms.
	 
	  If the specified file _has_ a build-id and there is a build-id
	  section in the perf.data file, we will still do the expected
	  validation in dso__load_vmlinux and will bail out if they don't
	  match.
	
	  Before checking on common vmlinux locations, check if it's
	  stored as standard build id binary (not kallsyms) under
	  .debug cache.
 do not try local files if a symfs was given 
		
		  if the user specified a vmlinux filename, use it and only
		  it, reporting errors to the user if it cannot be used.
		  Or use file guest_kallsyms inputted by user on commandline
 only try kernel version if no symfs was given 
	 Per kernelkallsyms.c:
	  we also restrict when perf_event_paranoid > 1 wo CAP_SYSLOG
	
	  A path to symbols of "" is identical to ""
	  reset here for simplicity.
	 skip the locally configured cache if a symfs is given, and
	  config buildid dir to symfs.debug
  Checks that user supplied symbol kernel files are accessible because
  the default mechanism for accessing elf files fails silently. i.e. if
  debug syms for a build ID aren't found perf carries on normally. When
  they are user supplied we should assume that the user doesn't want to
  silently fail.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 We need buffer that we know we can write to. 
		
		  If the event entry isn't valid, skip initialization
		  and "e->supported" will keep false.
 -1 for null termination 
 already taken care of 
	
	  While printing, 'Remote' will be added to represent
	  'Remote core, same node' accesses as remote field need
	  to be set with mem_hops field.
 -1 for null termination 
 already taken care of 
 -1 for null termination 
 -1 for null termination 
	
	  Skylake might report unknown remote level via this
	  bit, consider it when evaluating remote HITMs.
	 
	  Incase of power, remote field can also be used to denote cache
	  accesses from the another core of same node. Hence, setting
	  mrem only when HOPS is zero along with set remote field.
 load 
 store 
 unparsable data_src? 
 SPDX-License-Identifier: GPL-2.0
	
	  Auto-detect:
 Colors are not included in return value 
	
	  Auto-detect:
  This function splits the buffer by newlines and colors the lines individually.
  Returns 0 on success.
	
	  We color high-overhead entries in red, mid-overhead
	  entries in green - and keep the low overhead places
	  normal:
 SPDX-License-Identifier: GPL-2.0-or-later
  trace-event-scripting.  Scripting engine common and initialization code.
  Copyright (C) 2009-2010 Tom Zanussi <tzanussi@gmail.com>
 SPDX-License-Identifier: GPL-2.0
  usage.c
  Various reporting routines.
  Originally copied from GIT source.
  Copyright (C) Linus Torvalds, 2005
 If we are in a dlopen()ed .so write to a global variable would segfault
 SPDX-License-Identifier: GPL-2.0
  bpf-prologue.c
  Copyright (C) 2015 He Kuang <hekuang@huawei.com>
  Copyright (C) 2015 Wang Nan <wangnan0@huawei.com>
  Copyright (C) 2015 Huawei Inc.
  Convert type string (u8u16u32u64s8s16s32s64 ..., see
  Documentationtracekprobetrace.rst) to size field of BPF_LDX_MEM
  instruction (BPF_{B,H,W,DW}).
 Give it a shorter name 
  Give a register name (in 'reg'), generate instruction to
  load register into an eBPF register rd:
    'ldd target_reg, offset(ctx_reg)', where:
  ctx_reg is pre initialized to pointer of 'struct pt_regs'.
  Generate a BPF_FUNC_probe_read function call.
  src_base_addr_reg is a register holding base address,
  dst_addr_reg is a register holding dest address (on stack),
  result is:
   [dst_addr_reg] = ([src_base_addr_reg] + offset)
  Arguments of BPF_FUNC_probe_read:
      ARG1: ptr to stack (dest)
      ARG2: size (8)
      ARG3: unsafe ptr (src)
 mov arg3, src_base_addr_reg 
 add arg3, #offset 
 mov arg2, #reg_size 
 mov arg1, dst_addr_reg 
 Call probe_read  
	
	  Error processing: if read fail, goto error code,
	  will be relocated. Target should be the start of
	  error processing code.
  Each arg should be bare register. Fetch and save them into argument
  registers (r3 - r5).
  BPF_REG_1 should have been initialized with pointer to
  'struct pt_regs'.
  Slow path:
    At least one argument has the form of 'offset($rx)'.
  Following code first stores them into stack, then loads all of then
  to r2 - r5.
  Before final loading, the final result should be:
  low address
  BPF_REG_FP - 24  ARG3
  BPF_REG_FP - 16  ARG2
  BPF_REG_FP - 8   ARG1
  BPF_REG_FP
  high address
  For each argument (described as: offn(...off2(off1(reg)))),
  generates following code:
   r7 <- fp
   r7 <- r7 - stack_offset   Ideal code should initialize r7 using
                             fp before generating args. However,
                             eBPF won't regard r7 as stack pointer
                             if it is generated by minus 8 from
                             another stack pointer except fp.
                             This is why we have to set r7
                             to fp for each variable.
   r3 <- value of 'reg'-> generated using gen_ldx_reg_from_ctx()
   (r7) <- r3        skip following instructions for bare reg
   r3 <- r3 + off1  .  skip if off1 == 0
   r2 <- 8           \
   r1 <- r7           |-> generated by gen_read_mem()
   call probe_read    
   jnei r0, 0, err  .
   r3 <- (r7)
   r3 <- r3 + off2  .  skip if off2 == 0
   r2 <- 8           \   r2 may be broken by probe_read, so set again
   r1 <- r7           |-> generated by gen_read_mem()
   call probe_read    
   jnei r0, 0, err  .
   ...
 value of base register is stored into ARG3 
 Make r7 the stack pointer. 
 r7 += -8 
		
		  Store r3 (base register) onto stack
		  Ensure fp[offset] is set.
		  fp is the only valid base register when storing
		  into stack. We are not allowed to use r7 as base
		  register here.
			
			  Load previous result into ARG3. Use
			  BPF_REG_FP instead of r7 because verifier
			  allows FP based addressing only.
 Final pass: read to registers 
 First pass: validation 
 TODO: fetch global variable 
 fastpath is true if all args has ref == NULL 
			
			  Instruction encodes immediate value using
			  s32, ref->offset is long. On systems which
			  can't fill long in s32, refuse to process if
			  ref->offset too large (or small).
 If all variables are registers... 
 Initialization: move ctx to a callee saved register. 
		
		  start of ERROR_CODE (only slow pass needs error code)
		    mov r2 <- 1   r2 is error number
		    mov r3 <- 0   r3, r4... should be touched or
		                  verifier would complain
		    mov r4 <- 0
		    ...
		    goto usercode
	
	  start of SUCCESS_CODE:
	    mov r2 <- 0
	    goto usercode   skip
	
	  start of USER_CODE:
	    Restore ctx to r1
		
		  Only slow path needs restoring of ctx. In fast path,
		  register are loaded directly from r1.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
  genelf_debug.c
  Copyright (C) 2015, Google, Inc
  Contributed by:
  	Stephane Eranian <eranian@google.com>
  based on GPLv2 source code from Oprofile
  @remark Copyright 2007 OProfile authors
  @author Philippe Elie
 Not counting this field
 version number (2 currently)
 relative offset from next field to
 program statement
 line_base - see DWARF 2 specs
 line_range - see DWARF 2 specs
 number of opcode + 1
 follow the array of opcode args nr: ubytes [nr_opcode_base] 
	 follow the search directories index, zero terminated string
	  terminated by an empty string.
	 follow an array of { filename, LEB128, LEB128, LEB128 }, first is
	  the directory index entry, 0 means current directory, then mtime
	  and filesize, last entry is followed by en empty string.
 follow the first program statement 
 DWARF 2 spec talk only about one possible compilation unit header while
  binutils can handle two flavours of dwarf 2, 32 and 64 bits, this is not
  related to the used arch, an ELF 32 can hold more than 4 Go of debug
  information. For now we handle only DWARF 2 32 bits comp unit. It'll only
  become a problem if we generate more than 4GB of debug information.
 field filled at run time are marked with -1 
 could be better when min instruction size != 1 
 we don't take care about basic block 
 sensible value for line base ... 
 ... and line range are guessed statically 
 field filled at run time are marked with -1 
 we reuse the same abbrev entries for all comp unit 
 LNE field, strlen(filename) + zero termination, 3 bytes for: the dir entry, timestamp, filesize 
 directory index 0=do not know 
 last modification date on file 0=do not know 
 filesize 0=do not know 
	
	  delta from line_base
	
	  delta of addresses
	 This is not sufficient to ensure opcode will be in [0-256] but
	  sufficient to ensure when summing with the delta lineno we will
	
	  Machine state at start of a statement program
	  address = 0
	  file    = 1
	  line    = 1
	  column  = 0
	  is_stmt = default_is_stmt as given in the debug_line_header
	  basic block = 0
	  end sequence = 0
 start state of the state machine we take care of 
		
		  check if filename changed, if so add it
			
			  lines differ, emit line delta
			
			  addresses differ, emit address delta
			
			  add new row to matrix
 empty directory entry
 empty filename directory
	
	  setup .debug_line section
 .debug_line 
 must be zero or == sh_offset -> dynamic object 
	
	  setup .debug_info section
 .debug_info 
 must be zero or == sh_offset -> dynamic object 
	
	  setup .debug_abbrev section
 .debug_info 
 must be zero or == sh_offset -> dynamic object 
	
	  now we update the ELF image with all the sections
 SPDX-License-Identifier: GPL-2.0-or-later
  probe-file.c : operate ftrace kuprobe events files
  Written by Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
 4096 - 2 ('\n' + '\0') 
 Get raw string list of current kprobe_events  or uprobe_events 
 Skip if there is same name multi-probe event in the list 
 Get current perf-probe event names 
 Convert from perf-probe event to trace-probe event 
 Caller must ensure to remove this entry from list 
 For the kernel probe caches, pass target = NULL or DSO__NAME_KALLSYMS 
 This is a cached buildid 
 If we have no buildid cache, make it 
 #perf_probe_event or %sdt_event 
 trace_probe_event 
 Hit if same event name or same command-string 
 Hit if same event name or same command-string 
 Remove old cache entry 
  Isolate the string number and convert it into a decimal value;
  this will be an index to get suffix of the uprobe name (defining
  the type)
	
	  Argument is in N@OP format. N is size of the argument and OP is
	  the actual assembly operand. N can be omitted; in that case
	  argument is just OP(without @).
			
			  FIXUP: Arm64 ELF section '.note.stapsdt' uses string
			  format "-4@[sp, NUM]" if a probe is to access data in
			  the stack, e.g. below is an example for the SDT
			  Arguments:
			 
			    Arguments: -4@[sp, 12] -4@[sp, 8] -4@[sp, 4]
			 
			  Since the string introduces an extra space character
			  in the middle of square brackets, the argument is
			  divided into two items.  Fixup for this case, if an
			  item contains sub string "[sp,", need to concatenate
			  the two items.
 Failed to allocate memory 
 Try to find same-name entry 
 Save stat for rollback 
 Rollback to avoid cache file corruption 
 TBD: if we do not update existing entries, skip it 
 Show all cached probes 
	DEFINE_TYPE(FTRACE_README_MULTIPROBE_EVENT, "Createappend"),
	DEFINE_TYPE(FTRACE_README_IMMEDIATE_VALUE, "\\imm-value,"),
};
static bool scan_ftrace_readme(enum ftrace_readme type)
{
	int fd;
	FILE fp;
	char buf = NULL;
	size_t len = 0;
	bool ret = false;
	static bool scanned = false;
	if (scanned)
		goto result;
	fd = open_trace_file("README", false);
	if (fd < 0)
		return ret;
	fp = fdopen(fd, "r");
	if (!fp) {
		close(fd);
		return ret;
	}
	while (getline(&buf, &len, fp) > 0)
		for (enum ftrace_readme i = 0; i < FTRACE_README_END; i++)
			if (!ftrace_readme_table[i].avail)
				ftrace_readme_table[i].avail =
					strglobmatch(buf, ftrace_readme_table[i].pattern);
	scanned = true;
	fclose(fp);
	free(buf);
result:
	if (type >= FTRACE_README_END)
		return false;
	return ftrace_readme_table[type].avail;
}
bool probe_type_is_available(enum probe_type type)
{
	if (type >= PROBE_TYPE_END)
		return false;
	else if (type == PROBE_TYPE_X)
		return scan_ftrace_readme(FTRACE_README_PROBE_TYPE_X);
	return true;
}
bool kretprobe_offset_is_supported(void)
{
	return scan_ftrace_readme(FTRACE_README_KRETPROBE_OFFSET);
}
bool uprobe_ref_ctr_is_supported(void)
{
	return scan_ftrace_readme(FTRACE_README_UPROBE_REF_CTR);
}
bool user_access_is_supported(void)
{
	return scan_ftrace_readme(FTRACE_README_USER_ACCESS);
}
bool multiprobe_event_is_supported(void)
{
	return scan_ftrace_readme(FTRACE_README_MULTIPROBE_EVENT);
}
bool immediate_value_is_supported(void)
{
	return scan_ftrace_readme(FTRACE_README_IMMEDIATE_VALUE);
}
 SPDX-License-Identifier: GPL-2.0
 extra 'x' at the end is to reserve space for '.' 
 proc? do it slowly... 
 SPDX-License-Identifier: GPL-2.0
 For general debugging purposes 
  If LIBTRACEEVENT_VERSION wasn't computed then set to version 1.1.0 that ships
  with the Linux kernel tools.
  Overloading libtraceevent standard info print
  function, display with -v in perf.
 Allow only verbose value in range (0, 10), otherwise set 0. 
 disable all debug messages 
 Obtain a backtrace and print it to stdout. 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2009, Steven Rostedt <srostedt@redhat.com>
 fmt still has a space, skip it 
 Max comm length in the kernel is 16. 
	
	  Some flags in the format files do not get converted.
	  If the flag is not numeric, see if it is something that
	  we already know about.
 SPDX-License-Identifier: GPL-2.0
 perf_exe()
  magic2 = "PERFILE2"
  must be a numerical value to let the endianness
  determine the memory layout. That way we are able
  to detect endianness when reading the perf.data file
  back.
  we check for legacy (PERFFILE) format.
 struct perf_event_header::size is u16 
 Return: 0 if succeeded, -ERR if failed. 
 Return: 0 if succeeded, -ERR if failed. 
 Return: 0 if succeeded, -ERR if failed. 
 Return: 0 if succeeded, -ERR if failed. 
 write len, incl. \0 
		
		  strings are padded by zeroes
		  thus the actual strlen of buf
		  may be less than len
 Return: 0 if succeeded, -ERR if failed. 
 squash extra space characters (branding string) 
	
	  write number of events
	
	  size of perf_event_attr struct
		
		  write number of unique id per event
		  there is one id per instance of an event
		 
		  copy into an nri to be independent of the
		  type of ids,
		
		  write event string as passed on cmdline
		
		  write unique ids for this event
 actual path to perf binary 
 account for binary path 
  File format:
  struct pmu_mappings {
 	u32	pmu_num;
 	struct pmu_map {
 		u32	type;
 		char	name[];
 	}[pmu_num];
  };
	
	  Do a first pass to count number of pmu to avoid lseek so this
	  works in pipe mode as well.
  File format:
  struct group_descs {
 	u32	nr_groups;
 	struct group_desc {
 		char	name[];
 		u32	leader_idx;
 		u32	nr_members;
 	}[nr_groups];
  };
  Return the CPU id as a raw string.
  Each architecture should provide a more precise id string that
  can be use to match the architecture's "mapfile".
 Return zero when the cpuid from the mapfile.csv matches the
  cpuid string generated on this platform.
  Otherwise return non-zero.
 Warn unable to generate match particular string. 
 Verify the entire string matched. 
  default get_cpuid(): nothing gets recorded
  actual implementation must be in arch$(SRCARCH)utilheader.c
 Not implemented 
 version 
 clockid 
 TOD ref time 
 clockid ref time 
 before writing to file, translate address to offset 
		
		  translate back to address even when do_write() fails,
		  so that this function never changes the data.
 HAVE_LIBBPF_SUPPORT
  The MEM_TOPOLOGY holds physical memory map for every
  node in system. The format of data is as follows:
   0 - version          | for future changes
   8 - block_size_bytes | sysdevicessystemmemoryblock_size_bytes
  16 - count            | number of nodes
  For each node we store map of physical indexes for
  each node:
  32 - node id          | node index
  40 - size             | size of bitmap
  48 - bitmap           | bitmap of memory indexes that belongs to node
 Compute TOD time. 
 Compute clockid time. 
 HAVE_LIBBPF_SUPPORT
 number of events 
 buffer to hold on file attr struct 
 the last event terminates with evsel->core.attr.size == 0: 
		
		  must read entire on-file attr struct to
		  sync up with layout.
		
		  As the pid is the missing value, we need to fill
		  it properly. The header.misc value give us nice hint.
		
		  The a1645ce1 changeset:
		 
		  "perf: 'perf kvm' tool for monitoring guest performance from host"
		 
		  Added a field to struct perf_record_header_build_id that broke the file
		  format.
		 
		  Since the kernel build-id is the first entry, process the
		  table using the old format if the well known
		  '[kernel.kallsyms]' string for the kernel build-id has the
		  first 4 characters chopped off (where the pid_t sits).
 Macro for features that simply need to read and store a string. 
		 Save events for reading later by print_event_desc,
 include a NULL character at the end 
 include a NULL character at the end 
	
	  The header may be from old perf,
	  which doesn't include core id and socket id information.
	 On s390 the socket_id number is not related to the numbers of cpus.
	  The socket_id number might be higher than the numbers of cpus.
	  This depends on the configuration.
	  AArch64 is the same.
	
	  The header may be from old perf,
	  which doesn't include die information.
 include a NULL character at the end 
 nr nodes 
 node number 
 include a NULL character at the end 
	
	  Rebuild group relationship based on the group_desc
 {anon_group} is a dummy name 
 This is a group member 
 version 
 clockid 
 TOD ref time 
 clockid ref time 
 nr nodes 
 after reading from file, translate offset to address 
 HAVE_LIBBPF_SUPPORT
 include a NULL character at the end 
 feature_ops not implemented: 
 Only used in utilsynthetic-events.c
 extended list of headers 
 undo anything written 
	
	  may write more than needed due to dropped feature, but
	  this is okay, reader will skip the missing entries
			
			  We are likely in "perf inject" and have read
			  from an older file. Update attr size so that
			  reader gets the right offset to the ids.
 event_types is ignored, store zeros 
  In the legacy file format, the magic number is not used to encode endianness.
  hdr_sz was used to encode endianness. But given that hdr_sz can vary based
  on ABI revisions, we need to try all combinations for all endianness to
  detect the endianness.
 could not determine endianness 
  In the legacy pipe format, there is an implicit assumption that endianness
  between host recording the samples, and host parsing the samples is the
  same. This is not always the case given that the pipe output may always be
  redirected into a file and analyzed on a different machine with possibly a
  different endianness and perf_event ABI revisions in the perf tool itself.
 check for legacy format 
	
	  the new magic number serves two purposes:
	  - unique number to identify actual perf.data files
	  - encode endianness of file
 check magic number with one endianness 
 check magic number with opposite endianness 
 Support the previous format 
		
		  feature bitmap is declared as an array of unsigned longs --
		  not good since its size can differ between the host that
		  generated the data file and the host analyzing the file.
		 
		  We need to handle endianness, but we don't know the size of
		  the unsigned long where the file was generated. Take a best
		  guess at determining it: try 64-bit swap first (ie., file
		  created on a 64-bit host), and check if the hostname feature
		  bit is set (this feature bit is forced on as of fbe96f2).
		  If the bit is not, undo the 64-bit swap and try a 32-bit
		  swap. If the hostname bit is still not set (e.g., older data
		  file), punt and fallback to the original behavior --
		  clearing all feature bits and setting buildid.
 unswap as u64 
 unswap as u32 
 read minimal guaranteed structure 
 on file perf_event_attr size 
 assume ABI0 
 what we have not yet read and that we know about 
 read perf_file_section, ids are read in caller 
 already prepared 
	
	  We can read 'pipe' data event from regular file,
	  check for the pipe header regardless of source.
	
	  Sanity check that perf.data was written cleanly; data size is
	  initialized to 0 and updated only if the on_exit function is run.
	  If data size is still 0 then the file contains only partial
	  information.  Just warn user and process it as much as it can.
		
		  Do it before so that if perf_evsel__alloc_id fails, this
		  entry gets purged too at evlist__delete().
		
		  We don't have the cpu and thread maps on the header, so
		  for allocating the perf_sample_id table we fake 1 cpu and
		  hattr->ids threads.
	
	  We don't have the cpu and thread maps on the header, so
	  for allocating the perf_sample_id table we fake 1 cpu and
	  hattr->ids threads.
	
	  The pipe fd is already in proper place and in any case
	  we can't move it, and we'd screw the case where we read
	  'pipe' data from regular file. The trace_report reads
	  data from 'fd' so we need to set it directly behind the
	  event, where the tracing data starts.
 setup for reading amidst mmap 
 SPDX-License-Identifier: GPL-2.0
 because str is read-only 
 default to any branch 
	
	  cannot set it twice, -b + --branch-filter for instance
 SPDX-License-Identifier: GPL-2.0
 basename version that takes a const input string 
 reuse the real, existing symbol 
		 ensure that we don't alias an inlined symbol, which could
		  lead to double frees in inline_node__delete
 create a fake symbol for the inline frame 
  Implement addr2line using libbfd.
 found at least one inline frame
 HAVE_LIBBFD_SUPPORT 
 ignore result, we don't care 
 it's not used after start_command; avoid dangling pointers 
	
	  Returns:
	  -1 ==> error
	  0 ==> sentinel (or other ill-formed) record read
	  1 ==> a genuine record read
	
	  Send our request and then deliberately send something that can't be interpreted as
	  a valid address to ask addr2line about (namely, ","). This causes addr2line to first
	  write out the answer to our request, in an unboundedunknown number of records, and
	  then to write out the lines "??" and "??:0", so that we can detect when it has
	  finished giving us anything useful. We have to be careful about the first record,
	  though, because it may be genuinely unknown, in which case we'll get two sets of
	  "??""??:0" lines.
		
		  The first record was invalid, so return failure, but first read another
		  record, since we asked a junk question and have to clear the answer out.
 As expected. 
 We have to read the records even if we don't care about the inline info. 
 found at least one inline frame 
 HAVE_LIBBFD_SUPPORT 
  Number of addr2line failures (without success) before disabling it for that
  dso.
 Returns filename and fills in line number in line 
 only the inlined symbols are owned by the list 
 SPDX-License-Identifier: GPL-2.0
  AGGR_GLOBAL: Use CPU 0
  AGGR_SOCKET: Use first CPU of socket
  AGGR_DIE: Use first CPU of die
  AGGR_CORE: Use first CPU of core
  AGGR_NONE: Use matching CPU
  AGGR_THREAD: Not supported?
	
	  Previously the rbtree was used to link generic metrics.
	  The keys were evselcpu. Now the rbtree is extended to support
	  per-thread shadow stats. For shadow stats case, the keys
	  are cputypectxstat (evsel is NULL). For generic metrics
	  case, the keys are still evselcpu (typectxstat are 0 or NULL).
 don't use context info for clock events 
  Update various tracking values we maintain to print
  more semantic information such as misshit ratios,
  instruction rates, etc:
 used for get_ratio_color() 
 Mark MetricExpr target events and link events using them to them. 
 Search in group 
 Search ignoring groups 
 Deduping one is good enough to handle duplicated PMUs. 
				
				  Adding events automatically would be difficult, because
				  it would risk creating groups that are not schedulable.
				  perf stat doesn't understand all the scheduling constraints
				  of events. So we ask the user instead to add the missing
				  events.
  High level "TopDown" CPU core pipe line bottleneck break down.
  Basic concept following
  Yasin, A Top Down Method for Performance analysis and Counter architecture
  ISPASS14
  The CPU pipeline is divided into 4 areas that can be bottlenecks:
  Frontend -> Backend -> Retiring
  BadSpeculation in addition means out of order execution that is thrown away
  (for example branch mispredictions)
  Frontend is instruction decoding.
  Backend is execution, like computation and accessing data in memory
  Retiring is good execution that is not directly bottlenecked
  The formulas are computed in slots.
  A slot is an entry in the pipeline each for the pipeline width
  (for example a 4-wide pipeline has 4 slots for each cycle)
  Formulas:
  BadSpeculation = ((SlotsIssued - SlotsRetired) + RecoveryBubbles) 
 			TotalSlots
  Retiring = SlotsRetired  TotalSlots
  FrontendBound = FetchBubbles  TotalSlots
  BackendBound = 1.0 - BadSpeculation - Retiring - FrontendBound
  The kernel provides the mapping to the low level CPU events and any scaling
  needed for the CPU pipeline width, for example:
  TotalSlots = Cycles  4
  The scaling factor is communicated in the sysfs unit.
  In some cases the CPU may not be able to measure all the formulas due to
  missing events. In this case multiple formulas are combined, as possible.
  Full TopDown supports more levels to sub-divide each area: for example
  BackendBound into computing bound and memory bound. For now we only
  support Level 1 TopDown.
  Kernel reports metrics multiplied with slots. To get back
  the ratios we need to recreate the sum.
  ... but only if most of the values are actually available.
  We allow two missing.
 In case the CPU does not support topdown-recovery-bubbles 
 SPDX-License-Identifier: GPL-2.0
  The variable indicates the number of supported pmu event symbols.
  0 means not initialized and ready to init
  -1 means failed to init, don't try anymore
  >0 is the number of supported pmu event symbols
list=NULL, &idx, attr, 
config_terms=NULL,
auto_merge_stats=false, 
init_attrtrue, name, metric_id,
pmu=NULL, config_terms,
auto_merge_stats=false, 
init_attr=true, 
metric_id=NULL, 
config_terms=NULL, 
cpu_list="0");
	
	  No fallback - if we cannot get a clear cache type
	  then bail out:
	
	  Fall back to reads:
	
	  Fall back to accesses:
	
	  We get error directly from syscall errno ( > 0),
	  or from encoded pointer's error ( < 0).
	
	  Check if we should add the event, i.e. if it is a TP but starts with a '!',
	  then don't add the tracepoint, this will be used for something else, like
	  adding to a BPF_MAP_TYPE_PROG_ARRAY.
	 
	  See toolsperfexamplesbpfaugmented_raw_syscalls.c
	
	  Register atexit handler before calling bpf__probe() so
	  bpf__probe() don't need to unprobe probe points its already
	  created when failure.
  Split config terms:
  perf record -e bpf.ccall-graph=fp,map:array.value[0]=1 ...
   'call-graph=fp' is 'evt config', should be applied to each
   events in bpf.c.
  'map:array.value[0]=1' is 'obj config', should be processed
  with parse_events_config_bpf.
  Move object config terms from the first list to obj_head_config.
	
	  Currently, all possible user config term
	  belong to bpf object. parse_events__is_hardcoded_term()
	  happens to be a good flag.
	 
	  See parse_events_config_bpf() and
	  config_term_tracepoint().
	
	  Caller doesn't know anything about obj_head_config,
	  so combine them together again before returning.
 HAVE_LIBBPF_SUPPORT
 HAVE_LIBBPF_SUPPORT
 Default 
 Provide some defaults if len is not specified 
name=NULL, 
config_terms=NULL);
  Update according to parse-events.l
 term_type is validated so indexing is safe 
	
	  Check term availability after basic checking so
	  PARSE_EVENTS__TERM_TYPE_USER can be found and filtered.
	 
	  If check availability at the entry of this function,
	  user will see "'<sysfs term>' is not usable in 'perf stat'"
	  if an invalid config term is provided for legacy events
	  (for example, instructionsbadterm...), which is confusing.
		
		  Always succeed for sysfs terms, as we dont know
		  at this point what type they need to have.
  Add EVSEL__CONFIG_TERM_CFG_CHG where cfg_chg will have a bit set for
  each bit of attr->config that the user has changed.
	
	  More than one term in list.
init_attr=true, 
metric_id=NULL, pmu,
config_terms=NULL, auto_merge_stats,
cpu_list=NULL);
	
	  Configure hardcoded terms first, no need to check
	  return value when called with fail == 0 ;)
	
	  When using default config, record which bits of attr->config were
	  changed by the user.
init_attr=true,
cpu_list=NULL);
 Add it for all PMUs that support the alias 
  Check if the two uncore PMUs are from the same uncore block
  The format of the uncore PMU name is uncore_#blockname_#pmuidx
	
	  Going through the whole group and doing sanity check.
	  All members must use alias, and be from the same uncore block.
	  Also, storing the leader events in an array.
 Only split the uncore group which members use alias 
 The events must be from the same uncore block 
		
		  If the event's PMU name starts to repeat, it must be a new
		  event. That can be used to distinguish the leader from
		  other members, even they have the same event name.
 Store the leader event for each PMU 
 only one event alias 
	
	  An uncore event alias is a joint name which means the same event
	  runs on all PMUs of a block.
	  Perf doesn't support mixed events from different PMUs in the same
	  group. The big group has to be split into multiple small groups
	  which only include the events from the same PMU.
	 
	  Here the uncore event aliases must be from the same uncore block.
	  The number of PMUs must be same for each alias. The number of new
	  small groups equals to the number of PMUs.
	  Setting the leader event for corresponding members in each group.
 The number of members and group name are same for each group 
 Take the new small groups into account 
 list_event is assumed to point to malloc'ed memory 
	
	  Called for single event definition. Update the
	  'all event' list, and reinit the 'single event'
	  list, for next event definition.
 use of precise requires exclude_guest 
	
	  precise ip:
	 
	   0 - SAMPLE_IP can have arbitrary skid
	   1 - SAMPLE_IP must have constant skid
	   2 - SAMPLE_IP requested to have 0 skid
	   3 - SAMPLE_IP must have 0 skid
	 
	   See also PERF_RECORD_MISC_EXACT_IP
  Basic modifier sanity check to validate it contains only one
  instance of any modifier (apart from 'p') present.
 The sizeof includes 0 byte as well. 
  Read the pmu events list from sysfs
  Save it into perf_pmu_events_list
  This function injects special term in
  perf_pmu_events_list so the test code
  can check on this functionality.
 scan kernel pmu events from sysfs if needed 
	
	  name "cpu" could be prefix of cpu-cycles or cpu events.
	  cpu-cycles has been handled by hardcode.
	  So it must be cpu events, not kernel pmu event.
  parse event config string, return a list of event terms.
	
	  Add list to the evlist even with errors to allow callers to clean up.
	
	  There are 2 users - builtin-record and builtin-test objects.
	  Both call evlist__delete in case of error, so we dont
	  need to bother.
 -2 for extra '' in the final fprintf 
		
		  Maximum error index indent, we will cut
		  the event string if it's bigger.
		
		  Let's be specific with the message when
		  we have the precise error.
 We're cutting from the beginning. 
 Mark cut parts with '..' on both sides. 
	
	  Don't return when list_empty, give func a chance to report
	  error when it found last == NULL.
	 
	  So no need to WARN here, let func do this.
  Print the events from <debugfs_mount_point>tracingevents
  Check whether event is in <debugfs_mount_point>tracingevents
			
			  This happens if the paranoid value
			  procsyskernelperf_event_paranoid is set to 2
			  Re-run with exclude_kernel set; we don't do that
			  by default as some ARM machines do not support it.
			 
 skip invalid cache type 
		
		  New attr.config still not supported here, the latest
		  example was PERF_COUNT_SW_CGROUP_SWITCHES
  Print the help text for the event symbols:
  Return string contains valid config terms of an event.
  @additional_terms: For terms such as PMU sysfs terms.
 "no-overwrite" is the longest name 
 valid terms 
init_attr=true, name, metric_id,
auto_merge_stats=false,
cpu_list=NULL);
 SPDX-License-Identifier: GPL-2.0
 !HAVE_ZSTD_SUPPORT 
			
			  set session attributes that are present in perf.data
			  but not in pipe-mode.
 Open the directory data. 
		
		  In O_RDONLY mode this will be performed when reading the
		  kernel MMAP event, in perf_event__process_mmap().
	
	  In pipe-mode, evlist is empty until PERF_RECORD_HEADER_ATTR is
	  processed, so evlist__sample_id_all is not meaningful here.
  XXX this is hack in attempt to carry flags bitfield
  through endian village. ABI says:
  Bit-fields are allocated from right to left (least to most significant)
  on little-endian implementations and from left to right (most to least
  significant) on big-endian implementations.
  The above seems to be byte specific, so we need to reverse each
  byte of the bitfield. 'Internet' also says this might be implementation
  specific and we probably need proper fix and carry perf_event_attr
  bitfield flags in separate data file FEAT_ section. Thought this seems
  to work for now.
 exported for swapping attributes in file header 
	
	  After read_format are bitfields. Check read_format because
	  we are unable to use offsetof on bitfield.
 nr item itself 
  When perf record finishes a pass on every buffers, it records this pseudo
  event.
  We record the max timestamp t found in the pass n.
  Assuming these timestamps are monotonic across cpus, we know that if
  a buffer still has events with timestamps below t, they will be all
  available and then read in the pass n + 1.
  Hence when we start to read the pass n + 2, we can safely flush every
  events with timestamps below t.
     ============ PASS n =================
        CPU 0         |   CPU 1
                      |
     cnt1 timestamps  |   cnt2 timestamps
           1          |         2
           2          |         3
           -          |         4  <--- max recorded
     ============ PASS n + 1 ==============
        CPU 0         |   CPU 1
                      |
     cnt1 timestamps  |   cnt2 timestamps
           3          |         5
           4          |         6
           5          |         7 <---- max recorded
       Flush every events below timestamp 4
     ============ PASS n + 2 ==============
        CPU 0         |   CPU 1
                      |
     cnt1 timestamps  |   cnt2 timestamps
           6          |         8
           7          |         9
           -          |         10
       Flush every events below timestamp 7
       etc...
		
		  LBR callstack can only get user call chain,
		  i is kernel call chain number,
		  1 is PERF_CONTEXT_USER.
		 
		  The user call chain is stored in LBR registers.
		  LBR are pair registers. The caller is stored
		  in "from" register, while the callee is stored
		  in "to" register.
		  For example, there is a call stack
		  "A"->"B"->"C"->"D".
		  The LBR registers will be recorded like
		  "C"->"D", "B"->"C", "A"->"B".
		  So only the first "to" register and all "from"
		  registers are needed to construct the whole stack.
	
	  There's no reason to deliver sample
	  for zero period, bail out.
 We know evsel != NULL. 
 Standard sample delivery. 
 For PERF_SAMPLE_READ we have either single or group mode. 
 These events are processed right away 
		
		  Deprecated, but we need to handle it for sake
		  of old data files create in pipe mode.
		
		  Setup for reading amidst mmap, but only when we
		  are in 'file' mode. The 'pipe' fd is in proper
		  place already.
 setup for reading amidst mmap 
 machine__idle_thread() got the thread, so put it 
 do the final flush for ordered samples 
	
	  Ensure we have enough space remaining to read
	  the size of the event in the headers.
 We're not fetching the event so swap back again 
  On 64bit we can mmap the data file in one go. No need for tiny mmap
  slices. On 32bit we use 32MB.
 do the final flush for ordered samples 
	
	  We may switching perf.data output, make ordered_events
	  reusable.
	
	  FIXME: Here we have to actually print all the machines in this
	  session, not just the host...
 SPDX-License-Identifier: GPL-2.0
	
	  +4 accounts for '[x] ' priv level info
	  +2 accounts for 0x prefix on raw addresses
	  +3 accounts for ' y ' symtab origin info
 XXX need decay for weight too? 
  histogram, sorted on item, collects periods
		
		  This branch info is (a part of) allocated from
		  sample__resolve_bstack() and will be freed after
		  adding new entries.  So we need to save a copy.
		
		  Make sure that it receives arguments in a same order as
		  hist_entry__collapse() so that we can use an appropriate
		  function when searching an entry regardless which sort
		  keys were used.
			
			  This mem info was allocated from sample__resolve_mem
			  and will not be used anymore.
			 If the map of an existing hist_entry has
			  become out-of-date due to an exec() or
			  similar, update it.  Otherwise we will
			  mis-adjust symbol addresses when computing
			  the history counter to increment.
	
	  must pass period=weight in order to get the correct
	  sorting from hists__collapse_resort() which is solely
	  based on periods. We want sorting be done on nr_events  weight
	  and this is indirectly achieved by passing period=weight here
	  and the he_stat__add_period() function.
	
	  We don't need to free iter->priv (mem_info) here since the mem info
	  was either already freed in hists__findnew_entry() or passed to a
	  new hist entry by hist_entry__new().
	
	  The report shows the percentage of total branches captured
	  and not events sampled. Thus we use a pseudo period of 1.
	
	  This is for detecting cycles or recursions so that they're
	  cumulated only one time to prevent entries more than 100%
	  overhead.
	
	  We need to re-initialize the cursor since callchain_append()
	  advanced the cursor to the end.
	
	  Check if there's duplicate entries in the callchain.
	  It's possible that it has cycles or recursive calls.
		
		  For most cases, there are no duplicate entries in callchain.
		  The symbols are usually different. Do a quick check for
		  symbols first.
 to avoid calling callback function 
  If this is not the last column, then we need to pad it according to the
  pre-calculated max length for this column, otherwise don't bother adding
  spaces because that would break viewing this with, for instance, 'less',
  that would show tons of trailing spaces when a long C++ demangled method
  names is sampled.
  collapse the histogram
 if it's filtered by own fmt, it has to have filter bits 
		
		  If the filter is for current level entry, propagate
		  filter marker to parents.  The marker bit was
		  already set by default so it only needs to clear
		  non-filtered entries.
		
		  If current entry doesn't have matching formats, set
		  filter marker for upper level entries.  it will be
		  cleared if its lower level entries is not filtered.
		 
		  For lower-level entries, it inherits parent's
		  filter bit so that lower level entries of a
		  non-filtered entry won't set the filter marker.
 save related format list for output 
 some fields are now passed to 'new' 
 skip period (overhead) and elided columns 
 insert copy of 'he' for each fmt into the hierarchy 
 'he' is no longer used 
 return 0 (or -1) since it already applied filters 
			
			  If it wasn't combined with one of the entries already
			  collapsed, we need to apply the filters that may have
			  been set by, say, the hist_browser.
	
	  recalculate total period using top-level entries only
	  since lower level entries only see non-filtered entries
	  but upper level entries have sum of both entries.
 update column width of dynamic entry 
 update column width 
 force fold unfiltered entry for simplicity 
 force fold unfiltered entry for simplicity 
		
		  case 1. non-matching type
		  zero out the period, set filter marker and move to child
		
		  case 2. matched type (filter out)
		  set filter marker and move to next
		
		  case 3. ok (not filtered)
		  add period to hists and parents, erase the filter marker
		  and move to next sibling
	
	  resort output after applying a new filter since filter in a lower
	  hierarchy can change periods in a upper hierarchy.
  Look for pairs to link to the leader buckets (hist_entries):
 hierarchy report always collapses entries 
 do not point parent in the pos 
  Look for entries in the other hists that are not present in the leader, if
  we find them, just add a dummy entry on the leader hists, with period=0,
  nr_events=0, to serve as the list header.
 hierarchy report always collapses entries 
 If we have branch cycles always annotate them. 
			
			  Ignore errors, still want to process the
			  other entries.
			 
			  For non standard branch modes always
			  force no IPC (prev == NULL)
			 
			  Note that perf stores branches reversed from
			  program order!
  XXX We probably need a hists_evsel__exit() to free the hist_entries
  stored in the rbtree...
 SPDX-License-Identifier: GPL-2.0
 page_size
	
	  FIXME:
	  1) We should switch to machine__load_kallsyms(), i.e. not explicitly
	     ask for not using the kcore parsing code, once this one is fixed
	     to create a map per module.
		
		  Forget about the dead, at this point whatever threads were
		  left in the dead lists better have a reference count taken
		  by who is using them, and then, when they drop those references
		  and it finally hits zero, thread__put() will check and see that
		  its not in the dead threads list and will not try to remove it
		  from there, just calling thread__delete() straight away.
 XXX exit guest 
		
		  Maps are created from MMAP events which provide the pid and
		  tid.  Consequently there never should be any maps on a thread
		  with an unknown pid.  Just print an error if there are.
  Front-end cache - TID lookups come in blocks,
  so most of the time we dont have to look up
  the full rbtree:
  Caller must eventually drop thread->refcnt returned with a successful
  lookupnew thread inserted.
		
		  We have to initialize maps separately after rb tree is updated.
		 
		  The reason is that we call machine__findnew_thread
		  within thread__init_maps to find the thread
		  leader and that would screwed the rb tree.
		
		  It is now in the rbtree, get a ref
  Threads are identified by pid and tid, and the idle task has pid == tid == 0.
  So here a single thread is created for that, but actually there is a separate
  idle task per cpu, so there should be one 'struct thread' per cpu, but there
  is only 1. That causes problems for some tools, requiring workarounds. For
  example get_idle_thread() in builtin-sched.c, or thread_stack__per_cpu().
		
		  Kernel maps might be changed when loading symbols so loading
		  must be done prior to using kernel maps.
 Put the map here because maps__insert already got it 
 put the dso here, corresponding to  machine__findnew_module_dso 
 Figure out the start address of kernel map from prockallsyms.
  Returns the name of the start symbol in symbol_name. Pass in NULL as
  symbol_name if it's not that important.
 Duplicates are removed so lookup all aliases 
  These values can be used for kernels that do not have symbols for the entry
  trampolines in kallsyms.
 Map x86_64 PTI entry trampolines 
	
	  In the vmlinux case, pgoff is a virtual address which must now be
	  mapped to a vmlinux offset.
 Add a 1 page map for each CPU's entry trampoline 
 In case of renewal the kernel map, destroy previous one 
 Filter out . and .. 
		
		  Since prockallsyms will have multiple sessions for the
		  kernel, with modules between them, fixup the end of all
		  sections.
	
	  Full name could reveal us kmod compression, so
	  we need to update the symtab_type if needed.
sshfs might return bad dent->d_type, so we have to stat
 Do not follow top-level source and build symlinks 
	
	  Be a bit paranoid here, some perf.data file came with
	  a zero sized synthesized MMAP event for the kernel.
		
		  we have a real start address now, so re-order the kmaps
		  assume it's the last in the kmaps
 update end address of the kernel map using adjacent module address 
 If we have maps from kcore then we do not need or want any others 
		
		  Should be there already, from the build-id table in
		  the header.
			
			  The cpumode passed to is_kernel_module is not the
			  cpumode of this event. If we insist on passing
			  correct cpumode to is_kernel_module, we should
			  record the cpumode when we adding this dso to the
			  linked list.
			 
			  However we don't really need passing correct
			  cpumode.  We know the correct cpumode must be kernel
			  mode (if not, we should not link it onto kernel_dsos
			  list).
			 
			  Therefore, we pass PERF_RECORD_MISC_CPUMODE_UNKNOWN.
			  is_kernel_module() treats it as a kernel cpumode.
		
		  Avoid using a zero address (kptr_restrict) for the ref reloc
		  symbol. Effectively having zero here means that at record
		  time procsyskernelkptr_restrict was non zero.
			
			  preload dso of guest kernel and modules
	
	  Move it first to the dead_threads list, then drop the reference,
	  if this is the last reference, then the thread__delete destructor
	  will be called and we will remove it from the dead_threads list.
	
	  We need to do the put here because if this is the last refcount,
	  then we will be touching the threads->dead head when removing the
	  thread.
	
	  There may be an existing thread that is not actually the parent,
	  either because we are processing events out of order, or because the
	  (fork) event that would have removed the thread was lost. Assume the
	  latter case and continue on as best we can.
 if a thread currently exists for the thread id remove it 
	
	  When synthesizing FORK events, we are trying to create thread
	  objects for the already running tasks on the machine.
	 
	  Normally, for a kernel FORK event, we want to clone the parent's
	  maps because that is what the kernel just did.
	 
	  But when synthesizing, this should not be done.  If we do, we end up
	  with overlapping maps as we process the synthesized MMAP2 events that
	  get delivered shortly thereafter.
	 
	  Use the FORK event misc flags in an internal way to signal this
	  situation, so we can elide the map clone when appropriate.
	
	  We cannot use the header.misc hint to determine whether a
	  branch stack address is user, kernel, guest, hypervisor.
	  Branches may straddle the kerneluserhypervisor boundaries.
	  Thus, we have to try consecutively until we find a match
	  or else, the symbol is unknown
				
				  It seems the callchain is corrupted.
				  Discard all.
			 Treat this symbol as the root,
 Remove loops. 
 no collision handling for now 
 check if it is a real loop 
	
	  The curr and pos are not used in writing session. They are cleared
	  in callchain_cursor_commit() when the writing session is closed.
	  Using curr and pos to track the current cursor node.
 Add LBR ip from first entries.to 
		
		  The number of cursor node increases.
		  Move the current cursor node.
		  But does not need to save current cursor node for entry 0.
		  It's impossible to stitch the whole LBRs of previous sample.
 Add LBR ip from entries.from one by one. 
 Add LBR ip from entries.from one by one. 
 Add LBR ip from first entries.to 
 Find the physical index of the base-of-stack for current sample. 
 Previous sample has shorter stack. Nothing can be stitched. 
	
	  Check if there are identical LBRs between two samples.
	  Identical LBRs must have same from, to and flags values. Also,
	  they have to be saved in the same LBR registers (same physical
	  index).
	 
	  Starts from the base-of-stack of current sample.
	
	  Save the LBRs between the base-of-stack of previous sample
	  and the base-of-stack of current sample into lbr_stitch->lists.
	  These LBRs will be stitched later.
  Resolve LBR callstack chain sample
  Return:
  1 on success get LBR callchain information
  0 no available LBR callchain information, should try fp
  negative error code on other errors.
 LBR only affects the user callchain 
 Add kernel ip 
 Add kernel ip 
	
	  Based on DWARF debug information, some architectures skip
	  a callchain entry saved by the kernel.
	
	  Add branches to call stack for easier browsing. This gives
	  more context for a sample than just the callers.
	 
	  This uses individual histograms of paths compared to the
	  aggregated histograms the normal LBR mode uses.
	 
	  Limitations for now:
	  - No extra filters
	  - No annotations (should annotate somehow)
				
				  Check for overlap into the callchain.
				  The return address is one off compared to
				  the branch entry. To adjust for this
				  assume the calling instruction is not longer
				  than 8 bytes.
	
	  Convert entry->ip from a virtual address to an offset in
	  its corresponding binary.
 Can we do dwarf post unwind? 
 Bail out if nothing was captured. 
  Compares the raw arch string. N.B. see instead perf_env__arch() if a
  normalized arch is needed.
	
	  The only addresses above 2^63 are kernel addresses of a 64-bit
	  kernel.  Note that addresses are unsigned so that on a 32-bit system
	  all addresses including kernel addresses are less than 2^32.  In
	  that case (32-bit system), if the kernel mapping is unknown, all
	  addresses will be assumed to be in user space - see
	  machine__kernel_ip().
		
		  On x86_64, PTI entry trampolines are less than the
		  start of kernel text, but still above 2^63. So leave
		  kernel_start = 1ULL << 63 for x86_64.
 SPDX-License-Identifier: GPL-2.0
 O_CLOEXEC for older systems 
 Check predefined locations where debug file might reside 
		
		  Ubuntu can mixup usrlib with lib, putting debuginfo in
		  usrlibdebuglib when it is expected to be in
		  usrlibdebugusrlib
 Treat PERF_RECORD_MISC_CPUMODE_UNKNOWN as kernel 
	
	  We have proper compression id for DSO and yet the file
	  behind the 'name' can still be plain uncompressed object.
	 
	  The reason is behind the logic we open the DSO object files,
	  when we try all possible 'debug' objects until we find the
	  data. So even if the DSO is represented by 'krava.xz' module,
	  we can end up here opening ~.debug....23432432debug' file
	  which is not compressed.
	 
	  To keep this transparent, we detect this and return the file
	  descriptor to the uncompressed file.
  Parses kernel module specified in @path and updates
  @m argument like:
     @comp - true if @path contains supported compression suffix,
             false otherwise
     @kmod - true if @path contains '.ko' suffix in right position,
             false otherwise
     @name - if (@alloc_name && @kmod) is true, it contains strdup-ed base name
             of the kernel module without suffixes, otherwise strudup-ed
             base name of @path
     @ext  - if (@alloc_ext && @comp) is true, it contains strdup-ed string
             the compression suffix
  Returns 0 if there's no strdup error, -ENOMEM otherwise.
	
	  '.' is also a valid character for module name. For example:
	  [aaa.bbb] is a valid module name. '[' should have higher
	  priority than '.ko' suffix.
	 
	  The kernel names are from machine__mmap_name. Such
	  name should belong to kernel itself, not kernel module.
 No extension, just return name. 
 Check .ko extension only if there's enough name left. 
 _KMODULE_COMP should be next to _KMODULE 
  Global list of open DSOs and the counter.
  dso_close - Open DSO data file
  @dso: dso object
  Open @dso's data file descriptor and updates
  listcount of open DSO objects.
		
		  Check if we crossed the allowed number
		  of opened DSOs and close one if needed.
  dso_close - Close DSO data file
  @dso: dso object
  Close @dso's data file descriptor and updates
  listcount of open DSO objects.
 Allow half of the current open fd limit. 
  Used only by testsdso-data.c to reset the environment
  for tests. I dont expect we should change this during
  standard runtime.
  Check and close LRU dso if we crossed allowed limit
  for opened dso file descriptors. The limit is half
  of the RLIMIT_NOFILE files opened.
  dso__data_close - Close DSO data file
  @dso: dso object
  External interface to close @dso's data file descriptor.
  dso__data_get_fd - Get dso's data file descriptor
  @dso: dso object
  @machine: machine object
  External interface to find dso's file, open it and
  returns file descriptor.  It should be paired with
  dso__data_put_fd() if it returns non-negative value.
 HAVE_LIBBPF_SUPPORT
	
	  dso->data.fd might be closed if other thread opened another
	  file (dso) due to open file limit (RLIMIT_NOFILE).
 we lose the race 
  Reads and caches dso data DSO__DATA_CACHE_SIZE size chunks
  in the rb_tree. Any read to already cached data is served
  by cached data. Writes update the cache only, not the backing file.
 Reached EOF, return what we have. 
	
	  dso->data.fd might be closed if other thread opened another
	  file (dso) due to open file limit (RLIMIT_NOFILE).
  dso__data_size - Return dso data size
  @dso: dso object
  @machine: machine object
  Return: dso data size
 For now just estimate dso data size is close to file size 
 Check the offset sanity. 
  dso__data_read_offset - Read data from dso file offset
  @dso: dso object
  @machine: machine object
  @offset: file offset
  @data: buffer to store data
  @size: size of the @data buffer
  External interface to read data from dso file offset. Open
  dso data file and use cached_read to get the data.
  dso__data_read_addr - Read data from dso address
  @dso: dso object
  @machine: machine object
  @add: virtual memory address
  @data: buffer to store data
  @size: size of the @data buffer
  External interface to read data from dso address.
  dso__data_write_cache_offs - Write data to dso data cache at file offset
  @dso: dso object
  @machine: machine object
  @offset: file offset
  @data: buffer to write
  @size: size of the @data buffer
  Write into the dso file data cache, but do not change the file itself.
 cast away const to use same fns for rw 
  dso__data_write_cache_addr - Write data to dso data cache at dso address
  @dso: dso object
  @machine: machine object
  @add: virtual memory address
  @data: buffer to write
  @size: size of the @data buffer
  External interface to write into the dso file data cache, but do not change
  the file itself.
	
	  The kernel dso could be created by build_id processing.
	
	  We need to run this in all cases, since during the build_id
	  processing we had no idea this was the kernel dso.
		
		  __dsos__findnew_link_by_longname_id() isn't guaranteed to
		  add it back, so a clean removal is required here.
 free inlines first, as they reference symbols 
		
		  For the backward compatibility, it allows a build-id has
		  trailing zeros.
	
	  kernel module short names are of the form "[module]" and
	  we need just "module" here.
	
	  This must have a same ordering as the enum dso_load_errno.
 SPDX-License-Identifier: GPL-2.0
  Copyright IBM Corp. 2019
  Author(s): Thomas Richter <tmricht@linux.ibm.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License (version 2 only)
  as published by the Free Software Foundation.
  Architecture specific trace_event function. Save event's bc000 raw data
  to file. File name is aux.ctr.## where ## stands for the CPU number the
  sample was taken from.
 CPU Measurement Counter Facility raw data is a byte stream. It is 8 byte
  aligned and might have trailing padding bytes.
  Display the raw data on screen.
			 Raw data for counter sets are always multiple of 8
			  bytes. Prepending a 4 bytes size field to the
			  raw data block in the sample causes the perf tool
			  to append 4 padding bytes to make the raw data part
			  of the sample a multiple of eight bytes again.
			 
			  If the last entry (trailer) is 4 bytes off the raw
			  area data end, all is good.
 Dump event bc000 on screen, already tested on correctness. 
 Return starting number of a counter set 
 Basic counter set 
 Problem state counter set 
 Crypto counter set 
 Extended counter set 
 Diagnostic counter set 
 Scan the PMU table and extract the logical name of a counter from the
  PMU events table. Input is the counter set and counter number with in the
  set. Construct the event number and use this as key. If they match return
  the name of this counter.
  If no match is found a NULL pointer is returned.
 Print trailer 
 S390 specific trace event function. Check for PERF_RECORD_SAMPLE events
  and if the event was triggered by a counter set diagnostic event display
  its raw data.
  The function is only invoked when the dump flag -D is set.
 Display raw data on screen 
 To get things like MAP_HUGETLB even on older libc headers 
	
	  Must be a function or at least an alias, as in PARISC64, where "_text" is
	  an 'A' to the same address as "_stext".
		
		  Kernel maps might be changed when loading symbols so loading
		  must be done prior to using kernel maps.
  For branch stacks or branch samples, the sample cpumode might not be correct
  because it applies only to the sample 'ip' and not necessary to 'addr' or
  branch stack addresses. If possible, use a fallback to deal with those cases.
  Callers need to drop the reference to al->thread, obtained in
  machine__findnew_thread()
  The preprocess_sample method will return with reference counts for the
  in it, when done using (and perhaps getting ref counts if needing to
  keep a pointer to one of those entries) it must be paired with
  addr_location__put(), so that the refcounts can be decremented.
 SPDX-License-Identifier: GPL-2.0
  Support for libpfm4 event encoding.
  Copyright 2020 Google LLC.
	
	  force loading of the PMU list
 no event 
metric_id=NULL,
  list all pmu::event:umask, pmu::event
  printed events may not be all valid combinations of umask for an event
 initialize to zero to indicate ABI version 
 only print events that are supported by host HW 
 handled by perf directly 
 SPDX-License-Identifier: GPL-2.0-only
  Based on strlist.c by:
  (c) 2009 Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: GPL-2.0
 To get things like MAP_HUGETLB even on older libc headers 
			 The vdso maps are always on the host and not the
			  container.  Ensure that we don't use setns to look
			  them up.
			
			  Set memory without DSO as loaded. All map__find_
			  functions still return NULL, and we avoid the
			  unnecessary map__load warning.
  Constructor variant for modules (where we know from procmodules where
  they are loaded) and for vmlinux, where only after we load all the
  symbols we'll know where it starts and ends.
		
		  ->end will be filled after we load all the symbols
	
	  If PERF_RECORD_BPF_EVENT is not included, the dso will not have
	  type of DSO_BINARY_TYPE__BPF_PROG_INFO. In such cases, we can
	  guess the type based on name.
	
	  If PERF_RECORD_KSYMBOL is not included, the dso will not have
	  type of DSO_BINARY_TYPE__BPF_IMAGE. In such cases, we can
	  guess the type based on name.
  map__rip_2objdump - convert symbol start address to objdump address.
  @map: memory map
  @rip: symbol start address
  objdump wantsreports absolute IPs for ET_EXEC, and RIPs for ET_DYN.
  map->dso->adjust_symbols==1 for ET_EXEC-like cases except ET_REL which is
  relative to section start.
  Return: Address suitable for passing to "objdump --start-address="
	
	  vmlinux does not have program headers for PTI entry trampolines and
	  kcore may not either. However the trampoline object code is on the
	  main kernel map, so just use that instead.
	
	  kernel modules also have DSO_TYPE_USER in dso->kernel,
	  but all kernel modules are ET_REL, so won't get here.
  map__objdump_2mem - convert objdump address to a memory address.
  @map: memory map
  @ip: objdump address
  Closely related to map__rip_2objdump(), this function takes an address from
  objdump and converts it to a memory address.  Note this assumes that @map
  contains the address.  To be sure the result is valid, check it forwards
  e.g. map__rip_2objdump(map->map_ip(map, map__objdump_2mem(map, ip))) == ip
  Return: Memory address.
	
	  kernel modules also have DSO_TYPE_USER in dso->kernel,
	  but all kernel modules are ET_REL, so won't get here.
	
	  Free everything to try to do it from the rbtree in the next search
	
	  If we already performed some search by name, then we need to add the just
	  inserted map and resort.
 Ensure map is loaded before using map->map_ip 
	
	  Find first map where end > map->start.
	  Same as find_vma() in kernel.
		
		  Stop if current map starts after map->end.
		  Maps are ordered by start: next will not overlap for sure.
		
		  Now check if we need to create new maps for areas not
		  overlapped by the new map:
  XXX This should not really _copy_ te maps, but refcount them.
 SPDX-License-Identifier: GPL-2.0
  Include definition of find_map() also used in perf-read-vdso.c for
  building perf-read-vdso32 and perf-read-vdsox32.
 Put dso here because __dsos_add already got it 
 SPDX-License-Identifier: GPL-2.0
  Simple pointer stack
  (c) 2010 Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: GPL-2.0 
  Check platform the perf data file was created on and perform platform
  specific interpretation.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
	
	  pmu may be not scanned, check the sysfs.
 SPDX-License-Identifier: GPL-2.0
 make it nsec precision 
 copy original string because we need to modify it 
 make sure end time is after start time if it was given 
 Count the commas 
 Split the string and parse each piece, except the last 
 Find next comma, there must be one 
 Skip the value, must not contain space or comma 
 Split and parse 
 Parse the last piece 
 Check there is no overlap 
	
	  Example:
	  10%2: select the second 10% slice and the third 10% slice
 We can modify this string since the original one is copied 
	
	  Example: 0%-10%
	
	  c points to '%'.
	  '%' should be the last character
	
	  Construct a string like "xx%1"
	
	  ostr example:
	  10%2,10%3: select the second 10% slice and the third 10% slice
	  0%-10%,30%-40%: multiple time range
	  50%: just one percent
	
	  At least allocate one time range.
 if time is not set don't drop sample 
 otherwise compare sample time to time window 
	
	  startend of multiple time ranges must be valid.
 SPDX-License-Identifier: GPL-2.0
  I'm tired of doing "vsnprintf()" etc just to open a
  file, so here's a "return static buffer with printf"
  interface for paths.
  It's obviously not thread-safe. Sue me. But it's quite
  useful for doing things like
    f = open(mkpath("%s%s.perf", base, name), O_RDONLY);
  which is what it's designed for.
  One hack:
 Clean it up 
 Helper function for filesystems that return a dent->d_type DT_UNKNOWN 
 parse options like --foo a=<n>,b,c... 
 SPDX-License-Identifier: GPL-2.0-only
  Based on intlist.c by:
  (c) 2009 Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
 SPDX-License-Identifier: GPL-2.0-only
  intel-bts.c: Intel Processor Trace support
  Copyright (c) 2013-2015, Intel Corporation.
 Check for an async branch into the kernel 
 Currently there is no support for split buffers 
 Dump here now we have copied a piped trace out of the pipe 
		
		  We only use sample types from PERF_SAMPLE_MASK so we can use
		  __evsel__sample_size() here.
 No kvm support 
 SPDX-License-Identifier: GPL-2.0
  build-id.c
  build-id support
  Copyright (C) 2009, 2010 Red Hat Inc.
  Copyright (C) 2009, 2010 Arnaldo Carvalho de Melo <acme@redhat.com>
 lsdir(), mkdir_p(), rm_rf()
 asnprintf consolidates asprintf and snprintf 
 Try old style kallsyms cache 
 The caller is responsible to free the returned buffer. 
 == strlen("....") 
 The link should be "....<origpath><sbuild_id>" 
 Cut off the "<sbuild_id>" 
			offs++;	
				  This is a DSO name, like [kernel.kallsyms].
				  Skip the first '', since this is not the
				  cache of a regular file.
 Skip "....[]" 
 Check if the given build_id cache is valid on current running system 
 Should we support other special DSO cache? 
 Check if old style build_id cache 
 for filename__ functions 
 Open the top-level directory 
 If there is no buildid cache, return an empty list 
 Open the lower-level directory 
 Return the valid complete build-id 
 Error: There are more than 2 candidates. 
 retaining reference by realname 
 Remove old style build-id cache 
 Save the allocated buildid dirname 
	 Some binaries are stripped, but have .debug files with their symbol
	  table.  Check to see if we can locate one of those, since the elf
	  file itself may not be very useful to users of our tools without a
	  symtab.
 Update SDT cache : error is just warned 
	
	  Since the link is relative, we must make it absolute:
 SPDX-License-Identifier: GPL-2.0
  bpf-loader.c
  Copyright (C) 2015 Wang Nan <wangnan0@huawei.com>
  Copyright (C) 2015 Huawei Inc.
 for MAX_PROBES
 Is a tracepoint event? 
 parse failed, don't need clear pev. 
 Initialize per-program probing setting 
	
	  Make err static, so if init failed the first, bpf__prepare_probe()
	  fails each time without calling init_probe_symbol_maps multiple
	  times.
 Find a tev belongs to that type 
  compare_tev_args is reflexive, transitive and antisymmetric.
  I can proof it but this margin is too narrow to contain.
  Assign a type number to each tevs in a pev.
  mapping is an array with same slots as tevs in that pev.
  nr_types will be set to number of types.
	
	  Since all tevs don't have argument, we don't need generate
	  prologue.
		
		  After probing, let's consider prologue, which
		  adds program fetcher to BPF programs.
		 
		  hook_load_preprocessor() hooks pre-processor
		  to bpf_program, let it generate prologue
		  dynamically during loading.
	
	  No need to check key_size and value_size:
	  kernel has already checked them.
 key is "map:<mapname>.<config opt>" 
		
		  No need to check map type: type should have been
		  verified by kernel.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2011, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
  Parts came from builtin-{top,stat,record}.c, see those files for further
  copyright notes.
  __perf_evsel__calc_id_pos - calculate id_pos.
  @sample_type: sample type
  This function returns the position of the event id (PERF_SAMPLE_ID or
  PERF_SAMPLE_IDENTIFIER) in a sample event i.e. in the array of struct
  perf_record_sample.
  __perf_evsel__calc_is_pos - calculate is_pos.
  @sample_type: sample type
  This function returns the position (counting backwards) of the event id
  (PERF_SAMPLE_ID or PERF_SAMPLE_IDENTIFIER) in a non-sample event i.e. if
  sample_id_all is used there is an id sample appended to non-sample events.
  evsel__is_function_event - Return whether given evsel is a function
  trace event
  @evsel - evsel selector to be tested
  Return %true if event is function trace event
	
	  Now let the usual logic to set up the perf_event_attr defaults
	  to kick in when we return and before perf_evsel__open() is called.
 use asprintf() because free(evsel) assumes name is allocated 
  evsel__clone - create a new evsel copied from @orig
  @orig: original evsel
  The assumption is that @orig is not configured nor opened yet.
  So we only care about the attributes that can be set while it's parsed.
 cannot handle BPF objects for now 
  Returns pointer with encoded error via <linuxerr.h> interface.
 check name matches a full token in evsel__bpf_counter_events 
  cache operation stat
  L1I : Read and prefetch only
  ITLB and BPU : Read-only
 valid 
 invalid 
  Returns the group details for the specified leader,
  with following rules.
   For record -e '{cycles,instructions}'
     'anon group { cycles:u, instructions:u }'
   For record -e 'cycles,instructions' and report --group
     'cycles:u, instructions:u'
 callgraph default 
			
			  attr->inherit should has already been set by
			  evsel__config. If user explicitly set
			  inherit using config terms, override global
			  opt->no_inherit setting.
 Already applied by auxtrace 
 User explicitly set per-event callgraph, clear the old setting and reset. 
 parse callgraph parameters 
 If global callgraph set, clear it 
 set perf-event callgraph 
  The enable_on_execdisabled value strategy:
   1) For any type of traced program:
     - all independent events and group leaders are disabled
     - all group members are enabled
      Group members are ruled by group leaders. They need to
      be enabled, because the group scheduling relies on that.
   2) For traced programs executed by perf:
      - all independent events and group leaders have
        enable_on_exec set
      - we don't specifically enable or disable any event during
        the record command
      Independent events and group leaders are initially disabled
      and get enabled by exec. Group members are ruled by group
      leaders as stated in 1).
   3) For traced programs attached by perf (pidtid):
      - we specifically enable or disable all events during
        the record command
      When attaching events to already running traced we
      enabledisable events specifically, as there's no
      initial traced exec call.
		
		  We need ID even in case of single event, because
		  PERF_SAMPLE_READ process ID specific data.
		
		  Apply group format only if we belong to group
		  with more than one members.
	
	  We default some events to have a default interval. But keep
	  it a weak assumption overridable by the user.
	
	  If attr->freq was set (here or earlier), ask for period
	  to be sampled.
	
	  We don't allow user space callchains for  function trace
	  event, due to issues with page faults while tracing page
	  fault handler and its overall trickiness nature.
	
	  When the user explicitly disabled time don't force it here.
	
	  ksymbol is tracked separately with text poke because it needs to be
	  system wide and enabled immediately.
	
	  XXX see the function comment above
	 
	  Disabling only independent events or group leaders,
	  keeping group members enabled.
	
	  Setting enable_on_exec for independent events and
	  group leaders for traced executed by perf.
	
	  Apply event specific term settings,
	  it overloads any global configuration.
 The --period option takes the precedence. 
	
	  A dummy event never triggers any actual counter and therefore
	  cannot be used with branch_stack.
	 
	  For initial_delay, a dummy event is added implicitly.
	  The software event will trigger -EOPNOTSUPP error out,
	  if BRANCH_STACK bit is set.
 Caller has to clear disabled after going through all CPUs. 
 Caller has to set disabled after going through all CPUs. 
	
	  We mark it disabled here so that tools that disable a event can
	  ignore events after they disable it. I.e. the ring buffer may have
	  already a few more events queued up before the kernel got the stop
	  request.
	
	  Leader must be already processedopen,
	  if not it's a bug.
		
		  Since fds for next evsel has not been created,
		  there is no need to iterate whole event list.
 The system wide setup does not work with threads. 
 The -ESRCH is perf event syscall errno for pid's not found. 
 If there's only one thread, let it fail. 
	
	  We should remove fd for missing_thread first
	  because thread_map__remove() will decrease threads->nr.
 Do not try less precise if not requested. 
	
	  We tried all the precise_ip values, and it's
	  still failing, so leave it to standard fallback.
 should always work 
	
	  Must probe features in the order they were added to the
	  perf_event_attr interface.
 we cannot find PMU, disable attrs now 
			
			  If we succeeded but had to kill clockid, fail and
			  have evsel__open_strerror() print us a nice error.
 We just removed 1 thread, so lower the upper nthreads limit. 
 ... and pretend like nothing have happened. 
	
	  perf stat needs between 5 and 22 fds per CPU. When we run out
	  of them try to increase the limits.
 undo swap of u64, then swap on individual u32s 
 undo swap of u64, then swap on individual u32s 
	
	  The evsel's sample_size is based on PERF_SAMPLE_MASK which includes
	  up to PERF_SAMPLE_PERIOD.  After that overflow() must be used to
	  check the format does not go past the end of the event.
	
	  branch_flags
	  union {
	  	u64 values;
	  	struct {
	  		mispred:1	target mispredicted
	  		predicted:1	target predicted
	  		in_tx:1		in transaction
	  		abort:1		transaction abort
	  		cycles:16	cycle count to last branch
	  		type:4		branch type
	  		reserved:40
	  	}
	  }
	 
	  Avoid bswap64() the entire branch_flag.value,
	  as it has variable bit-field sizes. Instead the
	  macro takes the bit-field positionsize,
	  swaps it based on the host endianness.
	 
	  tep_is_bigendian() is used here instead of
	  bigendian() to avoid python test fails.
	
	  used for cross-endian analysis. See git commit 65014ab3
	  for why this goofiness is needed.
 undo swap of u64, then swap on individual u32s 
 undo swap of u64, then swap on individual u32s 
 PERF_FORMAT_ID is forced for PERF_SAMPLE_READ 
		
		  Undo swap of u64, then swap on individual u32s,
		  get the size of the raw area and undo all of the
		  swap. The pevent interface handles endianness by
		  itself.
		
		  The raw data is aligned on 64bits including the
		  u32 size, so it's safe to use mem_bswap_64.
			
			  if the PERF_SAMPLE_BRANCH_HW_INDEX is not applied,
			  only nr and entries[] will be output by kernel.
			
			  struct branch_flag does not have endian
			  specific bit field definition. And bswap
			  will not resolve the issue, since these
			  are bit fields.
			 
			  evsel__bitfield_swap_branch_flags() uses a
			  bitfield_swap macro to swap the bit position
			  based on the host endians.
 Undo swap of data 
		
		  If it's cycles then fall back to hrtimer based
		  cpu-clock-tick sw counter, which is always available even if
		  no PMU support.
		 
		  PPC returns ENXIO until 2.6.37 (behavior changed with commit
		  b0a873e).
 If event has exclude user then don't exclude kernel. 
 Is there already the separator in the name. 
 Walk through the directory. 
www.kernel.orgdochtmllatestadmin-guideperf-security.html\n"
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2009-2011, Frederic Weisbecker <fweisbec@gmail.com>
  Handle the callchains from the stream in an ad-hoc radix tree and then
  sort them in an rbtree.
  Using a radix for code path provides a fast retrieval and factorizes
  memory use. Also that lets us use the paths in a hierarchical graph view.
  Are there any events usind DWARF callchains?
  I.e.
  -e cyclescall-graph=dwarf
 parsing ok - move on to the next 
 assume that number followed by 'dwarf' is stack size 
 try to get the min percent 
 try print limit at last 
 We need buffer that we know we can write to. 
 Framepointer style 
 Dwarf style 
 Falldown 
  Once we get every callchains from the stream, we can now
  sort them by hit
  Create a child for a parent. If inherit_children, then the new child
  will become the new parent of it's parent children
 make it the first child 
  Fill the node with callchain values
				
				  branch_from is set with value somewhere else
				  to imply it's "to" of a branch.
				
				  It's "from" of a branch
  We need to always use relative addresses because we're aggregating
  callchains from multiple threads, i.e. different address spaces, so
  comparing absolute addresses make no sense as a symbol in a DSO may end up
  in a different address when used in a different binary or even the same
  binary but with some sort of address randomization technique, thus we need
  to compare just relative addresses. -acme
 otherwise fall-back to symbol-based comparison below 
			
			  Compare inlined frames based on their symbol name
			  because different inlined frames will have the same
			  symbol start. Otherwise do a faster comparison based
			  on the symbol start address.
 otherwise fall-back to IP-based comparison below 
			
			  It's "to" of a branch
			
			  It's "from" of a branch
  Split the parent in two parts (a new child is created) and
  give a part of its callchain to the created child.
  Then create another child to host the given callchain of new branch
 split 
 split the callchain and move a part to the new child 
 split the hits 
 create a new child for the new branch if any 
		
		  This is second child since we moved parent's children
		  to new (first) child above.
 lookup in children 
 If at least first entry matches, rely to children 
 nothing in children, add to the current node 
	
	  Lookup in the current node
	  If we have a symbol, then compare the start to match
	  anywhere inside a function, unless function
	  mode is disabled.
 matches not, relay no the parent 
 we match only a part of the node. Split it and add the new chain 
 we match 100% of the path, increment the hit 
 We match the node and still have a part remaining 
  Initialize a cursor before adding entries inside, but keep
  the previously allocated entries as a cache.
	
	  Say chain1 is ABC, chain2 is ABCD, we consider they are
	  not fully matched.
 Entry is hex, but does not have 0x, so need custom parser 
 SPDX-License-Identifier: GPL-2.0-only
  Manage printing of source lines
  Copyright (c) 2017, Intel Corporation.
  Author: Andi Kleen
 page_size
 Move to front 
 Only prune if there is more than one entry 
 Result is not 0 terminated 
 SPDX-License-Identifier: GPL-2.0
 Holding a double value. 
 Reference to another metric. 
 A reference but the value has been computed. 
 Caller must make sure id is allocated 
 Caller must make sure id is allocated 
source_count=1);
 Caller must make sure id is allocated 
	
	  The jevents tool converts all metric expressions
	  to lowercase, including metric references, hence
	  we need to add lowercase name for metric, so it's
	  properly found.
	
	  Intentionally passing just const char pointers,
	  originally from 'struct pmu_event' object.
	  We don't need to change them, so there's no
	  need to create our own copy.
 Unreachable. 
compute_ids=false) ? -1 : 0;
compute_ids=true);
	
	  Assume that topology strings are consistent, such as CPUs "0-1"
	  wouldn't be listed as "0,1", and so after deduplication the number of
	  these strings gives an indication of the number of packages, dies,
	  etc.
 SPDX-License-Identifier: GPL-2.0
 ARM 64 bit 
 For ELF64 the definitions are the same.  
 How to extract information held in the st_other field.  
 For readability... 
 Include function args 
 Include const, volatile, etc 
  elf_symtab__for_each_symbol - iterate thru all the symbols
  @syms: struct elf_symtab instance to iterate
  @idx: uint32_t idx
  @sym: GElf_Sym iterator
 Elf is corruptedtruncated, avoid calling elf_strptr. 
	
	  We need to figure out if the object was created from C++ sources
	  DWARF DW_compile_unit has this, but we don't always have access
	  to it...
		
		     Input to Rust demangling is the BFD-demangled
		     name which it Rust-demangles in place.
  We need to check if we have a .dynsym, so that we can handle the
  .plt, synthesizing its symbols, that aren't on the symtabs (be it
  .dynsym or .symtab).
  And always look at the original dso, not at debuginfo packages, that
  have the PLT data stripped out (shdr_rel_plt.sh_type == SHT_NOBITS).
	
	  Fetch the relocation section to find the idxes to the GOT
	  and the symbols in the .dynsym they refer to.
 FIXME: s390alphamipspariscpoperpcshxtensa need to be checked 
  Align offset to 4 bytes as needed for note name and descriptor data.
	
	  Check following sections for notes:
	    '.note.gnu.build-id'
	    '.notes'
	    '.note' (VDSO specific)
 HAVE_LIBBFD_BUILDID_SUPPORT
 HAVE_LIBBFD_BUILDID_SUPPORT
 the start of this section is a zero-terminated string 
 We are big endian, DSO is little endian. 
 We are little endian, DSO is big endian. 
	
	  Usually vmlinux is an ELF file with type ET_EXEC for most
	  architectures; except Arm64 kernel is linked with option
	  '-share', so need to check type ET_DYN.
 Always reject images with a mismatched build-id: 
  ref_reloc_sym_not_found - has kernel relocation symbol been found.
  @kmap: kernel maps and relocation reference symbol
  This function returns %true if we are dealing with the kernel maps and the
  relocation reference symbol has not yet been found.  Otherwise %false is
  returned.
  ref_reloc - kernel relocation offset.
  @kmap: kernel maps and relocation reference symbol
  This function returns the offset of kernel addresses as determined by using
  the relocation reference symbol i.e. if the kernel has not been relocated
  then the return value is zero.
 Adjust symbol to map to file offset 
		
		  The initial kernel mapping is based on
		  kallsyms and identity maps.  Overwrite it to
		  map to the kernel dso.
 Ensure maps are correctly ordered 
		
		  The initial module mapping is based on
		  procmodules mapped to offset zero.
		  Overwrite it to map to the module dso.
		
		  Add it before we drop the reference to curr_map, i.e. while
		  we still are sure to have a reference to this DSO via
		  curr_map->dso.
 kmaps already got it 
	
	  The kernel relocation symbol is needed in advance in order to adjust
	  kernel maps correctly.
	
	  Handle any relocation of vdso necessary because older kernels
	  attempted to prelink vdso to its virtual address.
	
	  Initial kernel and module mappings do not map to the dso.
	  Flag the fixups.
		 Reject ARM ELF "mapping symbols": these aren't unique and
		  don't identify functions, so will confuse the profile
		
		  When loading symbols in a data mapping, ABS symbols (which
		  has a value of SHN_ABS in its st_shndx) failed at
		  elf_getscn().  And it marks the loading as a failure so
		  already loaded symbols cannot be fixed up.
		 
		  I'm not sure what should be done. Just ignore them for now.
		  - Namhyung Kim
		
		  We have to fallback to runtime when syms' section header has
		  NOBITS set. NOBITS results in file offset (sh_offset) not
		  being incremented. So sh_offset used below has different
		  values for syms (invalid) and runtime (valid).
		 On ARM, symbols for thumb functions have 1 added to
	
	  For misannotated, zeroed, ASM function sizes.
			
			  We need to fixup this here too because we create new
			  maps here, for things like vsyscall sections.
	
	  Modules may already have symbols from kallsyms, but those symbols
	  have the wrong values for the dso maps, so remove them.
		
		  If the vmlinux is stripped, fail so we will fall back
		  to using kallsyms. The vmlinux runtime symbols aren't
		  of much use.
 Use read because mmap won't work on proc files 
 Find phdr that corresponds to the kernel map (contains stext) 
 Find phdrs that remap the kernel 
 Use read because mmap won't work on proc files 
  kcore_copy - copy kallsyms, modules and kcore from one directory to another.
  @from_dir: from directory
  @to_dir: to directory
  This function copies kallsyms, modules and kcore files from one directory to
  another.  kallsyms and modules are copied entirely.  Only code segments are
  copied from kcore.  It is assumed that two segments suffice: one for the
  kernel proper and one for all the modules.  The code segments are determined
  from kallsyms and modules files.  The kernel map starts at _stext or the
  lowest function symbol, and ends at _etext or the highest function symbol.
  The module map starts at the lowest module address and ends at the highest
  module symbol.  Start addresses are rounded down to the nearest page.  End
  addresses are rounded up to the nearest page.  An extra page is added to the
  highest kernel symbol and highest module symbol to, hopefully, encompass that
  symbol too.  Because it contains only code sections, the resulting kcore is
  unusual.  One significant peculiarity is that the mapping (start -> pgoff)
  is not the same for the kernel map and the modules map.  That happens because
  the data is copied adjacently whereas the original kcore has gaps.  Finally,
  kallsyms and modules files are compared with their copies to check that
  modules have not been loaded or unloaded while the copies were taking place.
  Return: %0 on success, %-1 on failure.
  populate_sdt_note : Parse raw data and identify SDT note
  @elf: elf of the opened file
  @data: raw data of a section with description offset applied
  @len: note description size
  @type: type of the note
  @sdt_notes: List to add the SDT note
  Responsible for parsing the @data in section .note.stapsdt in @elf and
  if its an SDT note, it appends to @sdt_notes list.
 Translation from file representation to memory representation 
 Populate the fields of sdt_note 
	
	  There is no argument if:
	  - We reached the end of the note;
	  - There is not enough room to hold a potential string;
	  - The argument string is empty or just contains ':'.
	 Adjust the prelink effect :
	  Find out the .stapsdt.base section.
	  This scn will help us to handle prelinking (if present).
	  Compare the retrieved file offset of the base section with the
	  base address in the description of the SDT note. If its different,
	  then accordingly, adjust the note location.
 Adjust reference counter offset 
  construct_sdt_notes_list : constructs a list of SDT notes
  @elf : elf to look into
  @sdt_notes : empty list_head
  Scans the sections in 'elf' for the section
  .note.stapsdt. It, then calls populate_sdt_note to find
  out the SDT events and populates the 'sdt_notes'.
 Look for the required section 
 Get the SDT notes 
 Check the type of the note 
  get_sdt_note_list : Wrapper to construct a list of sdt notes
  @head : empty list_head
  @target : file to find SDT notes from
  This opens the file, initializes
  the ELF and then calls construct_sdt_notes_list.
  cleanup_sdt_note_list : free the sdt notes' list
  @sdt_notes: sdt notes' list
  Free up the SDT notes in @sdt_notes.
  Returns the number of SDT notes free'd.
  sdt_notes__get_count: Counts the number of sdt events
  @start: list_head to sdt_notes list
  Returns the number of SDT notes in a list
 SPDX-License-Identifier: GPL-2.0
	
	  The event TIME_CONV was extended for the fields from "time_cycles"
	  when supported cap_user_time_short, for backward compatibility,
	  prints the extended fields only if they are contained in the event.
 SPDX-License-Identifier: GPL-2.0
 .find_elf is not set as we use dwfl_report_elf() instead.
	
	  Some callers will use al->sym, so we can't just use the
	  cheaper thread__find_map() here.
  Store all entries within entries array,
  we will process it after we finish unwind.
 We want only single thread to be processed. 
 Check overflow. 
 report the module before we query for isactivation
	
	  Display what we got based on the order setup.
 SPDX-License-Identifier: GPL-2.0
  Arm Statistical Profiling Extensions (SPE) support
  Copyright (c) 2017-2018, Arm Ltd.
 If no more data, drop the previous auxtrace_buffer and return 
 If the aux_buffer doesn't have data associated, try to load it 
 get the file desc associated with the perf data file 
 params set 
 create new decoder 
		
		  The usual logic is firstly to decode the packets, and then
		  based the record to synthesize sample; but here the flow is
		  reversed: it calls arm_spe_sample() for synthesizing samples
		  prior to arm_spe_decode().
		 
		  Two reasons for this code logic:
		  1. Firstly, when setup queue in arm_spe__setup_queue(), it
		  has decoded trace data and generated a record, but the record
		  is left to generate sample until run to here, so it's correct
		  to synthesize sample for the left record.
		  2. After decoding trace data, it needs to compare the record
		  timestamp with the coming perf event, if the record timestamp
		  is later than the perf event, it needs bail out and pushs the
		  record into auxtrace heap, thus the record can be deferred to
		  synthesize sample until run to here at the next time; so this
		  can correlate samples between Arm SPE trace data and other
		  perf events with correct time ordering.
		
		  Update pidtid info.
		
		  Error is detected when decode SPE trace data, continue to
		  the next trace data and find out more records.
 Update timestamp for the last record 
		
		  If the timestamp of the queue is later than timestamp of the
		  coming perf event, bail out so can allow the perf event to
		  be processed ahead.
	
	  Circle through the list of event and complain if we find one
	  with the time bit set.
		
		  A previous context-switch event has set pidtid in the machine's context, so
		  here we need to update the pidtid in the thread and SPE queue.
 Dump here now we have copied a piped trace out of the pipe 
 create new id val to be a fixed offset from evsel id 
 Level 1 data cache miss 
 Level 1 data cache access 
 Last level cache miss 
 Last level cache access 
 TLB miss 
 TLB access 
 Branch miss 
 Remote access 
 No kvm support 
	
	  The synthesized event PERF_RECORD_TIME_CONV has been handled ahead
	  and the parameters for hardware clock are stored in the session
	  context.  Passes these parameters to the struct perf_tsc_conversion
	  in "spe->tc", which is used for later conversion between clock
	  counter and timestamp.
	 
	  For backward compatibility, copies the fields starting from
	  "time_cycles" only if they are contained in the event.
 SPDX-License-Identifier: GPL-2.0-only
  intel_pt_insn_decoder.c: Intel Processor Trace support
  Copyright (c) 2013-2014, Intel Corporation.
 Based on branch_type() from archx86eventsintellbr.c 
 vmlaunch 
 vmresume 
 syscall 
 sysenter 
 sysret 
 sysexit 
 jcc 
 jcc 
 near ret 
 near ret 
 far ret 
 far ret 
 iret 
 int 
 call near rel 
 call far absolute 
 loop 
 jcc 
 jmp 
 jmp 
 far jmp 
 call near absolute, call far absolute ind 
 near ind call 
 far ind call 
 SPDX-License-Identifier: GPL-2.0-only
  intel_pt_log.c: Intel Processor Trace support
  Copyright (c) 2013-2014, Intel Corporation.
 SPDX-License-Identifier: GPL-2.0-only
  intel_pt_pkt_decoder.c: Intel Processor Trace support
  Copyright (c) 2013-2014, Intel Corporation.
 MNT 
 Long TNT 
 PIP 
 TraceStop 
 CBR 
 VMCS 
 OVF 
 PSB 
 PSBEND 
 TMA 
 3-byte header 
 EXSTOP no IP 
 EXSTOP with IP 
 MWAIT 
 PWRE 
 PWRX 
 BBP 
 BEP no IP 
 BEP with IP 
 SPDX-License-Identifier: GPL-2.0-only
  intel_pt_decoder.c: Intel Processor Trace support
  Copyright (c) 2013-2014, Intel Corporation.
 IA32_RTIT_CTL MSR bits 
  Default maximum number of loops with no packets consumed i.e. stuck in a
  loop.
	
	  A TSC packet can slip past MTC packets so that the timestamp appears
	  to go backwards. One estimate is that can be up to about 40 CPU
	  cycles, which is certainly less than 0x1000 TSC ticks, but accept
	  slippage an order of magnitude more to be on the safe side.
 Sign-extend 6-byte ip 
 Lookahead packets in current buffer 
  MTC provides a 8-bit slice of CTC but the TMA packet only provides the lower
  16 bits of CTC. If mtc_shift > 8 then some of the MTC bits are not in the CTC
  provided by the TMA packet. Fix-up the last_mtc calculated from the TMA
  packet by copying the missing bits from the current MTC assuming the least
  difference between the two, and that the current MTC comes after last_mtc.
		
		  For now, do not support using TSC packets - refer
		  intel_pt_calc_cyc_to_tsc().
 Does not happen 
	
	  For now, do not support using TSC packets for at least the reasons:
	  1) timing might have stopped
	  2) TSC packets within PSB+ can slip against CYC packets
 Zero-length calls are excluded 
		
		  Check for being stuck in a loop.  This can happen if a
		  decoder error results in the decoder erroneously setting the
		  ip to an address that is itself in an infinite loop that
		  consumes no packets.  When that happens, there must be an
		  unconditional branch.
 Unconditional branch leaving filter region 
 Conditional branch leaving filter region 
 Handle deferred TIPs 
 Instruction sample for a non-taken branch 
 For use only when decoder->vm_time_correlation is true 
 Walk PSB+ packets when already in sync. 
 Lookahead and get the PIP, VMCS and TMA packets from PSB+ 
 Lookahead to detect a FUP packet after OVF 
 Lookahead and get the TMA packet after TSC 
 Number of CTC ticks from last_ctc_timestamp to last_mtc 
	
	  Number of CTC ticks from there until current TMA packet. We would
	  expect last_mtc_ctc to be before ctc, but the TSC packet can slip
	  past an MTC, so a sign-extended value is used.
 Total CTC ticks from last_ctc_timestamp to current TMA packet 
	
	  Convert CTC ticks to TSC ticks, add the starting point
	  (last_ctc_timestamp) and the fast counter from the TMA packet.
 VMX adds the TSC Offset, so subtract to get host TSC 
 TSC packet has only 7 bytes 
	
	  The buffer is mmapped from the data file, so this also updates the
	  data file.
 Can't happen 
 Guest 
 Host 
 Host or Guest 
 Assume Host 
 Assume Guest 
 Already have 'data' for the in_psb case 
 Calculations depend on having TMA packets 
 Determine if TSC is from Host or Guest 
 Guest 
 PIP NR=1 without VMCS cannot happen 
 Host 
 Host or Guest 
 HostGuest is a guess, so not reliable 
 Zero TSC Offset, assume Host 
			
			  TSC packet has only 7 bytes of TSC. We have no
			  information about the Guest's 8th byte, but it
			  doesn't matter because we only need 7 bytes.
			  Here, since the 8th byte is unreliable and
			  irrelevant, compare only 7 byes.
 Same TSC Offset as last VMCS, assume Guest 
		
		  Check if the host_tsc is within the expected range.
		  Note, we could narrow the range more by looking ahead for
		  the next host TSC in the same buffer, but we don't bother to
		  do that because this is probably good enough.
 Within expected range for Host TSC, assume Host 
 Assuming Guest 
 Determine whether to assign TSC Offset 
 Continuous tracing, TSC in a PSB is not a time loss 
			
			  Unlikely to be a time loss TSC in a PSB which is not
			  at the start of a buffer.
 Record VMCS TSC Offset 
 Determine what TSC Offset to use 
 Guest 
 PIP NR=1 without VMCS cannot happen 
 Host 
 Host or Guest 
 Within expected range for Host TSC, assume Host 
 Translate Guest TSC to Host TSC 
 Does not happen 
 Hop mode: Ignore TNT, do not walk code, but get ip from FUPs and TIPs 
 Leap from PSB to PSB, getting ip from FUP within PSB+ 
 Lookahead and get the FUP packet from PSB+ 
 Keep going to check for a TIP.PGE 
 Ignore FUP in PSB+ if followed by TIP.PGE 
			
			  In hop mode, resample to get the to_ip as an
			  "instruction" sample.
			
			  Ensure that there has been an instruction since the
			  last MTC.
 Ensure that there is a timestamp 
 MODE_TSX need not be followed by FUP 
 Does not happen 
 Walk PSB+ packets to get in sync. 
 Does not happen 
 Does not happen 
 Do not have a sample 
 In hop mode, resample to get the to_ip as an "instruction" sample 
 Only PSB sample 
		
		  In hop mode, resample to get the PSB FUP ip as an
		  "instruction" sample.
		
		  When using only TSCMTC to compute cycles, IPC can be
		  sampled as soon as the cycle count changes.
 Let PSB event always have TSC timestamp 
  intel_pt_next_psb - move buffer pointer to the start of the next PSB packet.
  @buf: pointer to buffer pointer
  @len: size of buffer
  Updates the buffer pointer to point to the start of the next PSB packet if
  there is one, otherwise the buffer pointer is unchanged.  If @buf is updated,
  @len is adjusted accordingly.
  Return: %true if a PSB packet is found, %false otherwise.
  intel_pt_step_psb - move buffer pointer to the start of the following PSB
                      packet.
  @buf: pointer to buffer pointer
  @len: size of buffer
  Updates the buffer pointer to point to the start of the following PSB packet
  (skipping the PSB at @buf itself) if there is one, otherwise the buffer
  pointer is unchanged.  If @buf is updated, @len is adjusted accordingly.
  Return: %true if a PSB packet is found, %false otherwise.
  intel_pt_last_psb - find the last PSB packet in a buffer.
  @buf: buffer
  @len: size of buffer
  This function finds the last PSB in a buffer.
  Return: A pointer to the last PSB in @buf if found, %NULL otherwise.
  intel_pt_next_tsc - find and return next TSC.
  @buf: buffer
  @len: size of buffer
  @tsc: TSC value returned
  @rem: returns remaining size when TSC is found
  Find a TSC packet in @buf and return the TSC value.  This function assumes
  that @buf starts at a PSB and that PSB+ will contain TSC and so stops if a
  PSBEND packet is found.
  Return: %true if TSC is found, false otherwise.
  intel_pt_tsc_cmp - compare 7-byte TSCs.
  @tsc1: first TSC to compare
  @tsc2: second TSC to compare
  This function compares 7-byte TSC values allowing for the possibility that
  TSC wrapped around.  Generally it is not possible to know if TSC has wrapped
  around so for that purpose this function assumes the absolute difference is
  less than half the maximum difference.
  Return: %-1 if @tsc1 is before @tsc2, %0 if @tsc1 == @tsc2, %1 if @tsc1 is
  after @tsc2.
  adj_for_padding - adjust overlap to account for padding.
  @buf_b: second buffer
  @buf_a: first buffer
  @len_a: size of first buffer
  @buf_a might have up to 7 bytes of padding appended. Adjust the overlap
  accordingly.
  Return: A pointer into @buf_b from where non-overlapped data starts
  intel_pt_find_overlap_tsc - determine start of non-overlapped trace data
                              using TSC.
  @buf_a: first buffer
  @len_a: size of first buffer
  @buf_b: second buffer
  @len_b: size of second buffer
  @consecutive: returns true if there is data in buf_b that is consecutive
                to buf_a
  @ooo_tsc: out-of-order TSC due to VM TSC offset  scaling
  If the trace contains TSC we can look at the last TSC of @buf_a and the
  first TSC of @buf_b in order to determine if the buffers overlap, and then
  walk forward in @buf_b until a later TSC is found.  A precondition is that
  @buf_a and @buf_b are positioned at a PSB.
  Return: A pointer into @buf_b from where non-overlapped data starts, or
  @buf_b + @len_b if there is no non-overlapped data.
 No PSB in buf_a => no overlap 
 The last PSB+ in buf_a is incomplete, so go back one more 
 No full PSB+ => assume no overlap 
 No TSC in buf_a => assume no overlap 
 Ignore PSB+ with no TSC 
 Same TSC, so buffers are consecutive 
 tsc_a < tsc_b => no overlap 
 No PSB in buf_b => no data 
  intel_pt_find_overlap - determine start of non-overlapped trace data.
  @buf_a: first buffer
  @len_a: size of first buffer
  @buf_b: second buffer
  @len_b: size of second buffer
  @have_tsc: can use TSC packets to detect overlap
  @consecutive: returns true if there is data in buf_b that is consecutive
                to buf_a
  @ooo_tsc: out-of-order TSC due to VM TSC offset  scaling
  When trace samples or snapshots are recorded there is the possibility that
  the data overlaps.  Note that, for the purposes of decoding, data is only
  useful if it begins with a PSB packet.
  Return: A pointer into @buf_b from where non-overlapped data starts, or
  @buf_b + @len_b if there is no non-overlapped data.
 Buffer 'b' must start at PSB so throw away everything before that 
 No PSB 
 No overlap 
	
	  Buffer 'b' cannot end within buffer 'a' so, for comparison purposes,
	  we can ignore the first part of buffer 'a'.
 No overlap 
 Now len_b >= len_a 
 Potential overlap so check the bytes 
 Try again at next PSB in buffer 'a' 
 No overlap 
  struct fast_forward_data - data used by intel_pt_ff_cb().
  @timestamp: timestamp to fast forward towards
  @buf_timestamp: buffer timestamp of last buffer with trace data earlier than
                  the fast forward timestamp.
  intel_pt_ff_cb - fast forward lookahead callback.
  @buffer: Intel PT trace buffer
  @data: opaque pointer to fast forward data (struct fast_forward_data)
  Determine if @buffer trace is past the fast forward timestamp.
  Return: 1 (stop lookahead) if @buffer trace is past the fast forward
          timestamp, and 0 otherwise.
	
	  If the buffer contains a timestamp earlier that the fast forward
	  timestamp, then record it, else stop.
  intel_pt_fast_forward - reposition decoder forwards.
  @decoder: Intel PT decoder
  @timestamp: timestamp to fast forward towards
  Reposition decoder at the last PSB with a timestamp earlier than @timestamp.
  Return: 0 on success or negative error code on failure.
 Find buffer timestamp of buffer to fast forward to 
 Walk to buffer with same buffer timestamp 
 -ENOLINK means non-consecutive trace 
	
	  Walk PSBs while the PSB timestamp is less than the fast forward
	  timestamp.
		
		  A TSC packet can slip past MTC packets but, after fast
		  forward, decoding starts at the TSC timestamp. That means
		  the timestamps may not be exactly the same as the timestamps
		  that would have been decoded without fast forward.
 SPDX-License-Identifier: GPL-2.0
  This file setups defines to compile arch specific binary from the
  generic one.
  The function 'LIBUNWIND__ARCH_REG_ID' name is set according to arch
  name and the definition of this function is included directly from
  'archarm64utilunwind-libunwind.c', to make sure that this function
  is defined no matter what arch the host is.
  Finally, the arch specific unwind methods are exported which will
  be assigned to each arm64 thread.
 Define arch specific functions & regs for libunwind, should be
  defined before including "unwind.h"
 NO_LIBUNWIND_DEBUG_FRAME is a feature flag for local libunwind,
  assign NO_LIBUNWIND_DEBUG_FRAME_AARCH64 to it for compiling arm64
  unwind methods.
 SPDX-License-Identifier: GPL-2.0
  This file setups defines to compile arch specific binary from the
  generic one.
  The function 'LIBUNWIND__ARCH_REG_ID' name is set according to arch
  name and the definition of this function is included directly from
  'archx86utilunwind-libunwind.c', to make sure that this function
  is defined no matter what arch the host is.
  Finally, the arch specific unwind methods are exported which will
  be assigned to each x86 thread.
 Define arch specific functions & regs for libunwind, should be
  defined before including "unwind.h"
 HAVE_ARCH_X86_64_SUPPORT is used in'archx86utilunwind-libunwind.c'
  for x86_32, we undef it to compile code for x86_32 only.
 Explicitly define NO_LIBUNWIND_DEBUG_FRAME, because non-ARM has no
  dwarf_find_debug_frame() function.
 SPDX-License-Identifier: GPL-2.0
  Copyright(C) 2015-2018 Linaro Limited.
  Author: Tor Jeremiassen <tor@ti.com>
  Author: Mathieu Poirier <mathieu.poirier@linaro.org>
 use raw logging 
 Nothing to do, might as well just return 
	
	  The queueing process in function cs_etm_decoder__buffer_packet()
	  increments the tail before using it.  This is somewhat counter
	  intuitive but it has the advantage of centralizing tail management
	  at a single location.  Because of that we need to follow the same
	  heuristic with the head, i.e we increment it before using its
	  value.  Otherwise the first element of the packet queue is not
	  used.
	
	  For ETMv4 if the trace minor version is 4 or more then we can assume
	  the architecture is ARCH_AA64 rather than just V8.
	  ARCH_V8 = V8 architecture
	  ARCH_AA64 = Min v8r3 plus additional AA64 PE features
	
	  Set up a library default logger to process any printers
	  (packetraw frame) we add later.
 no stdout  err  file output 
	
	  Set the string CB for the default logger, passes strings to
	  perf print logger.
 Only log these during a --dump operation 
		 set up a library default logger to process the
		   raw frame printer we add later
 no stdout  err  file output 
		 set the string CB for the default logger,
		  passes strings to perf print logger.
 use the built in library printer for the raw frames 
 No timestamp packet has been received, nothing to do 
 Estimate the timestamp for the next range packet 
 Tell the front end which traceid_queue needs attention 
 First get the packet queue for this traceID 
	
	  We've seen a timestamp packet before - simply record the new value.
	  Function do_soft_timestamp() will report the value to the front end,
	  hence asking the decoder to keep decoding rather than stopping.
		
		  Zero timestamps can be seen due to misconfiguration or hardware bugs.
		  Warn once, and don't try to subtract instr_count as it would result in an
		  underflow.
		
		  Sanity check that the elem->timestamp - packet_queue->instr_count would not
		  result in an underflow. Warn and clamp at 0 if it would.
		
		  This is the first timestamp we've seen since the beginning of traces
		  or a discontinuity.  Since timestamps packets are generated after
		  range packets have been generated, we need to estimate the time at
		  which instructions started by subtracting the number of instructions
		  executed to the timestamp.
 Tell the front end which traceid_queue needs attention 
 Halt processing until we are being told to proceed 
 per-thread scenario, no need to generate a timestamp 
	
	  The packet queue is full and we haven't seen a timestamp (had we
	  seen one the packet queue wouldn't be full).  Let the front end
	  deal with it.
 Tell the front end we have a new timestamp to process 
	
	  Something happened and who knows when we'll get new traces so
	  reset time statistics.
	
	  As all the ETMs run at the same exception level, the system should
	  have the same PID format crossing CPUs.  So cache the PID format
	  and reuse it for sequential decoding.
	
	  Process the PE_CONTEXT packets if we have a valid contextID or VMID.
	  If the kernel is running at EL2, the PID is traced in CONTEXTIDR_EL2
	  as VMID, Bit ETM_OPT_CTXTID2 is set in this case.
	
	  A timestamp is generated after a PE_CONTEXT element so make sure
	  to rely on that coming one.
 First get the packet queue for this traceID 
 Unused packet types 
	
	  Drivers may add barrier frames when used with perf, set up to
	  handle this. Barriers const of FSYNC packet repeated 4 times.
 Create decode tree for the data source 
 init library print logging support 
 init raw frame logging if required 
		
		  Return to the input code if the packet buffer is full.
		  Flushing will get done once the packet buffer has been
		  processed.
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (c) 2021 Facebook
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (c) 2020 Facebook
 map of perf event fds, num_cpu  num_metric entries 
 readings at fentry 
 accumulated readings 
 look up before reading, to reduce error 
 only account samples with a valid fentry_reading 
 read all events before updating the maps, to reduce error 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (c) 2021 Facebook
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (c) 2021 Facebook
 Copyright (c) 2021 Google
 max cgroup hierarchy level: arbitrary
 max events per cgroup: arbitrary
 NOTE: many of map and global data will be modified before loading
       from the userspace (perf tool) using the skeleton helpers.
 single set of global perf events to measure
 from cgroup id to event index
 per-cpu event snapshots to calculate delta
 aggregated event values for each cgroup (per-cpu)
 will be read from the user-space
 convert cgroup-id to a map index
 convert cgroup-id to a map index
 to have it in a register to pass BPF verifier
 XXX: do not pass idx directly (for verifier)
 this is per-cpu array for diff
 read from global perf_event array
 aggregate the result by cgroup
 This will be attached to cgroup-switches event for each cpu
  trace-event-python.  Feed trace events to an embedded Python interpreter.
  Copyright (C) 2010 Tom Zanussi <tzanussi@gmail.com>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Py_FatalError does not return
 but we have to make the compiler happy
  Insert val into into the dictionary and decrement the reference counter.
  This is necessary for dictionaries since PyDict_SetItemString() does not
  steal a reference, as opposed to PyTuple_SetItem().
	
	  The attribute for the code object is func_code in Python 2,
	  whereas it is __code__ in Python 3.0+.
 gcc warns for these? 
 we should warn... 
	
	  Here value 28 is a constant size which can be used to print
	  one register value and its corresponds to:
	  16 chars is to specify 64 bit register in hexadecimal.
	  2 chars is for appending "0x" to the hexadecimal value and
	  10 chars is for register name.
 Instructions per cycle (IPC) 
 ip unwinding 
 Need an additional reference for the perf_sample dict 
 FIELD_IS_NUMERIC 
  Databases support only signed 64-bit numbers, so even though we are
  exporting a u64, it must be as s64.
	
	  Use the MAX_FIELDS to make the function expandable, though
	  currently there is only one item for the tuple.
 ip unwinding 
 Reserve for future process_hwswraw APIs 
 handle export calls 
 handle export callchains 
		
		  Attempt to use the call path root from the call return
		  processor, if the call return processor is in use. Otherwise,
		  we allocate a new call path root. This prevents exporting
		  duplicate call path ids when both are in use simultaneously.
	
	  Reserve per symbol space for symbol->db_id via symbol__priv()
	
	  Synthesized events are samples but with architecture-specific data
	  stored in sample->raw_data. They are exported via
	  python_export_sample() and consequently do not need a separate export
	  callback.
  Start trace script
	
	  Use a non-const name variable to cope with python 2.6's
	  PyImport_AppendInittab prototype
  Stop trace script
  trace-event-perl.  Feed perf script events to an embedded Perl interpreter.
  Copyright (C) 2009 Tom Zanussi <tzanussi@gmail.com>
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 perl needs the following define, right after including stdbool.h 
 we should warn... 
 common fields other than pid can be accessed via xsub fns 
 FIELD_IS_NUMERIC 
 access to Perl stack 
  Start trace script
  Stop trace script
 access to Perl stack 
 SPDX-License-Identifier: GPL-2.0
  arm_spe_decoder.c: ARM SPE support
 Instruction virtual address or Branch target address 
 Clean highest byte 
 Fill highest byte for EL1 or EL2 (VHE) mode 
 Data access virtual address 
 Clean tags 
		
		  Armv8 ARM (ARM DDI 0487F.c), chapter "D10.2.1 Address packet"
		  defines the data virtual address payload format, the top byte
		  (bits [63:56]) is assigned as top-byte tag; so we only can
		  retrieve address value from bits [55:0].
		 
		  According to Documentationarm64memory.rst, if detects the
		  specific pattern in bits [55:52] of payload which falls in
		  the kernel space, should fixup the top byte and this allows
		  perf tool to parse DSO symbol for data address correctly.
		 
		  For this reason, if detects the bits [55:52] is 0xf, will
		  fill 0xff into the top byte.
 Data access physical address 
 Clean highest byte 
 Failed to read out trace data 
 Move forward for 1 byte 
 SPDX-License-Identifier: GPL-2.0
  Arm Statistical Profiling Extensions (SPE) support
  Copyright (c) 2017-2018, Arm Ltd.
  Extracts the field "sz" from header bits and converts to bytes:
    00 : byte (1)
    01 : halfword (2)
    10 : word (4)
    11 : doubleword (8)
	 we use index to identify Events with a less number of
	  comparisons in arm_spe_pkt_desc(): E.g., the LLC-ACCESS,
	  LLC-REFILL, and REMOTE-ACCESS events are identified if
	  index > 1.
 no timestamp at end of record 
 16-bit extended format header 
	
	  The short format header's byte 0 or the extended format header's
	  byte 1 has been assigned to 'hdr', which uses the same encoding for
	  address packet and counter packet, so don't need to distinguish if
	  it's short format or extended format and handle in once.
	 put multiple consecutive PADs on the same line, up to
	  the fixed-width output format of 16 bytes per line.
 Bail out if any error occurred 
	
	  A return value of blen or more means that the output was
	  truncated and the buffer is overrun.
		
		  Set err to 'ret' to avoid overflow if tries to
		  fill this buffer sequentially.
 SVE effective vector length 
 SVE effective vector length 
 Unknown index 
 Unknown index 
 Unknown packet type 
 Output raw data if detect any error 
 SPDX-License-Identifier: GPL-2.0
  Augment the raw_syscalls tracepoints with the contents of the pointer arguments.
  Test it with:
  perf trace -e toolsperfexamplesbpfaugmented_raw_syscalls.c cat etcpasswd > devnull
  This exactly matches what is marshalled into the raw_syscall:sys_enter
  payload expected by the 'perf trace' beautifiers.
  For now it just uses the existing tracepoint augmentation code in 'perf
  trace', in the next csets we'll hook up these with the sys_entersys_exit
  code that will combine entryexit in a strace like way.
 bpf-output associated map 
  string_args_len: one per syscall arg, 0 means not a string or don't copy it,
  		    PATH_MAX for copying everything, any other value to limit
  		    it a la 'strace -s strsize'.
  What to augment at entry?
  Pointer arg payloads (filenames, etc) passed from userspace to the kernel
  What to augment at exit?
  Pointer arg payloads returned from the kernel (struct stat, etc) to userspace.
 We need more tmp space than the BPF stack can give us
 If perf_event_output fails, return non-zero so that it gets recorded unaugmented 
	
	  probe_read_str may return < 0, e.g. -EFAULT
	  So we leave that in the augmented_arg->size that userspace will
		
		  So that username notice the error while still being able
		  to skip this augmented arg record
  These will be tail_called from SEC("raw_syscalls:sys_enter"), so will find in
  augmented_args_tmp what was read by that raw_syscalls:sys_enter and go
  on from there, reading the first syscall arg as a string, i.e. open's
  filename.
 Failure: don't filter 
 Failure: don't filter 
 Failure: don't filter 
 Failure: don't filter 
 Failure: don't filter 
 Failure: don't filter 
	
	  We start len, the amount of data that will be in the perf ring
	  buffer, if this is not filtered out by one of pid_filter__has(),
	  syscall->enabled, etc, with the non-augmented raw syscall payload,
	  i.e. sizeof(augmented_args->args).
	 
	  We'll add to this as we add augmented syscalls right after that
	  initial, non-augmented raw_syscalls:sys_enter payload.
	
	  Jump to syscall specific augmenter, even if the default one,
	  "!raw_syscalls:unaugmented" that will just return 1 to return the
	  unaugmented tracepoint payload.
 If not found on the PROG_ARRAY syscalls map, then we're filtering it:
	
	  Jump to syscall specific return augmenter, even if the default one,
	  "!raw_syscalls:unaugmented" that will just return 1 to return the
	  unaugmented tracepoint payload.
	
	  If not found on the PROG_ARRAY syscalls map, then we're filtering it:
 SPDX-License-Identifier: GPL-2.0
    Description:
    . Disable strace like syscall tracing (--no-syscalls), or try tracing
      just some (-e sleep).
    . Attach a filter function to a kernel function, returning when it should
      be considered, i.e. appear on the output.
    . Run it system wide, so that any sleep of >= 5 seconds and < than 6
      seconds gets caught.
    . Ask for callgraphs using DWARF info, so that userspace can be unwound
    . While this is running, run something like "sleep 5s".
    . If we decide to add tv_nsec as well, then it becomes:
      int probe(hrtimer_nanosleep, rqtp->tv_sec rqtp->tv_nsec)(void ctx, int err, long sec, long nsec)
      I.e. add where it comes from (rqtp->tv_nsec) and where it will be
      accessible in the function body (nsec)
    # perf trace --no-syscalls -e toolsperfexamplesbpf5sec.ccall-graph=dwarf
         0.000 perf_bpf_probe:func:(ffffffff9811b5f0) tv_sec=5
                                           hrtimer_nanosleep ([kernel.kallsyms])
                                           __x64_sys_nanosleep ([kernel.kallsyms])
                                           do_syscall_64 ([kernel.kallsyms])
                                           entry_SYSCALL_64 ([kernel.kallsyms])
                                           __GI___nanosleep (usrlib64libc-2.26.so)
                                           rpl_nanosleep (usrbinsleep)
                                           xnanosleep (usrbinsleep)
                                           main (usrbinsleep)
                                           __libc_start_main (usrlib64libc-2.26.so)
                                           _start (usrbinsleep)
    ^C#
   Copyright (C) 2018 Red Hat, Inc., Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: GPL-2.0
  Augment the filename syscalls with the contents of the filename pointer argument
  filtering only those that do not start with etc.
  Test it with:
  perf trace -e toolsperfexamplesbpfaugmented_syscalls.c cat etcpasswd > devnull
  It'll catch some openat syscalls related to the dynamic linked and
  the last one should be the one for 'etcpasswd'.
  This matches what is marshalled into the raw_syscall:sys_enter payload
  expected by the 'perf trace' beautifiers, and can be used by them unmodified,
  which will be done as that feature is implemented in the next csets, for now
  it will appear in a dump done by the default tracepoint handler in 'perf trace',
  that uses bpf_output__fprintf() to just dump those contents, as done with
  the bpf-output event associated with the __bpf_output__ map declared in
  toolsperfincludebpfstdio.h.
 bpf-output associated map 
 If perf_event_output fails, return non-zero so that it gets recorded unaugmented 	\
 SPDX-License-Identifier: GPL-2.0
  Augment syscalls with the contents of the pointer arguments.
  Test it with:
  perf trace -e toolsperfexamplesbpfaugmented_syscalls.c cat etcpasswd > devnull
  It'll catch some openat syscalls related to the dynamic linked and
  the last one should be the one for 'etcpasswd'.
  This matches what is marshalled into the raw_syscall:sys_enter payload
  expected by the 'perf trace' beautifiers, and can be used by them, that will
  check if perf_sample->raw_data is more than what is expected for each
  syscalls:sys_{enter,exit}_SYSCALL tracepoint, uing the extra data as the
  contents of pointer arguments.
 bpf-output associated map 
 If perf_event_output fails, return non-zero so that it gets recorded unaugmented 	\
 0 as soon as we start copying data returned by the kernel, e.g. 'read' 	\
 FIXME_CLANG_OPTIMIZATION_THAT_ACCESSES_USER_CONTROLLED_ADDRLEN_DESPITE_THIS_CHECK 		\
	if (addrlen > augmented_args.args.addrlen)				     		\
		addrlen = augmented_args.args.addrlen;				     		\
										     		\
 If perf_event_output fails, return non-zero so that it gets recorded unaugmented 	\
 0 as soon as we start copying data returned by the kernel, e.g. 'read' 	\
 SPDX-License-Identifier: GPL-2.0
  Hook into 'openat' syscall entry tracepoint
  Test it with:
  perf trace -e toolsperfexamplesbpfsys_enter_openat.c cat etcpasswd > devnull
  It'll catch some openat syscalls related to the dynamic linked and
  the last one should be the one for 'etcpasswd'.
  The syscall_enter_openat_args can be used to get the syscall fields
  and use them for filtering calls, i.e. use in expressions for
  the return value.
 SPDX-License-Identifier: GPL-2.0
	
	  We don't need to try to find objdump path for native system.
	  Just use default binutils path (e.g.: "objdump").
	
	  For live mode, env->arch will be NULL and we can use
	  the native objdump tool.
  Some architectures have a single address space for kernel and user addresses,
  which makes it possible to determine if an address is in kernel space or user
  space.
 SPDX-License-Identifier: GPL-2.0-or-later
  Mapping of DWARF debug register numbers into register names.
  Copyright (C) 2010 Matt Fleming <matt@console-pimps.org>
  Generic dwarf analysis helpers
 Return architecture dependent register string (for kprobe-tracer) 
 SPDX-License-Identifier: GPL-2.0-or-later
  Mapping of DWARF debug register numbers into register names.
  Copyright (c) 2015 Cadence Design Systems Inc.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-or-later
  Use DWARF Debug information to skip unnecessary callchain entries.
  Copyright (C) 2014 Sukadev Bhattiprolu, IBM Corporation.
  Copyright (C) 2014 Ulrich Weigand, IBM Corporation.
 struct ip_callchain
  When saving the callchain on Power, the kernel conservatively saves
  excess entries in the callchain. A few of these entries are needed
  in some cases but not others. If the unnecessary entries are not
  ignored, we end up with duplicate arcs in the call-graphs. Use
  DWARF debug information to skip over any unnecessary callchain
  entries.
  See function header for arch_adjust_callchain() below for more details.
  The libdwfl code in this file is based on code from elfutils
  (libdwflargp-std.c, libdwfltestsaddrcfi.c, etc).
  Use the DWARF expression for the Call-frame-address and determine
  if return address is in LR and if a new frame was allocated.
	
	  Check if return address is on the stack. If return address
	  is in a register (typically R0), it is yet to be saved on
	  the stack.
	
	  Return address is in LR. Check if a frame was allocated
	  but not-yet used.
	
	  If call frame address is in r1, no new frame was allocated.
	
	  A new frame was allocated but has not yet been used.
  Get the DWARF frame from the .eh_frame section.
  Get the DWARF frame from the .debug_frame section.
  Return:
 	0 if return address for the program counter @pc is on stack
 	1 if return address is in LR and no new stack frame was allocated
 	2 if return address is in LR and a new frame was allocated (but not
 		yet used)
 	-1 in case of errors
			
			  We normally cache the DWARF debug info and never
			  call dwfl_end(). But to prevent fd leak, free in
			  case of error.
	
	  To work with split debug info files (eg: glibc), check both
	  .eh_frame and .debug_frame sections of the ELF header.
  The callchain saved by the kernel always includes the link register (LR).
 	0:	PERF_CONTEXT_USER
 	1:	Program counter (Next instruction pointer)
 	2:	LR value
 	3:	Caller's caller
 	4:	...
  The value in LR is only needed when it holds a return address. If the
  return address is on the stack, we should ignore the LR value.
  Further, when the return address is in the LR, if a new frame was just
  allocated but the LR was not saved into it, then the LR contains the
  caller, slot 4: contains the caller's caller and the contents of slot 3:
  (chain->ips[3]) is undefined and must be ignored.
  Use DWARF debug information to determine if any entries need to be skipped.
  Return:
 	index:	of callchain entry that needs to be ignored (if any)
 	-1	if no entry needs to be ignored or in case of errors
		
		  Return address on stack. Ignore LR value in callchain
		
		  New frame allocated but return address still in LR.
		  Ignore the caller's caller entry in callchain.
 SPDX-License-Identifier: GPL-2.0-or-later
  Mapping of DWARF debug register numbers into register names.
  Copyright (C) 2010 Ian Munsie, IBM Corporation.
  Reference:
  http:refspecs.linuxfoundation.orgELFppc64PPC-elf64abi-1.9.html
  get_arch_regstr() - lookup register name from it's DWARF register number
  @n:	the DWARF register number
  get_arch_regstr() returns the name of the register in struct
  regdwarfnum_table from it's DWARF register number. If the register is not
  found in the table, this returns NULL;
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2016 Chandan Kumar, IBM Corporation.
 SPDX-License-Identifier: GPL-2.0
 Tracepoints specific to ppc_book3s_hv 
 1 extra placeholder for NULL 
 Check for book3s_hv tracepoints 
 Wrapper to setup kvm tracepoints 
 Right now, only supported on book3s_hv 
  In case of powerpc architecture, pmu registers are programmable
  by guest kernel. So monitoring guest via host may not provide
  valid samples with default 'cycles' event. It is better to use
  'trace_imctrace_cycles' event for guest profiling, since it
  can track the guest instruction pointer in the trace-record.
  Function to parse the arguments and return appropriate values.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2015 Naveen N. Rao, IBM Corporation
 Skip over any initial dot 
 Avoid "SyS" kernel syscall aliases 
 Allow matching against dot variants 
 Skip over initial dot 
 Skip over initial dot 
 Skip over initial dot 
	
	  When probing at a function entry point, we normally always want the
	  LEP since that catches calls to the function through both the GEP and
	  the LEP. Hence, we would like to probe at an offset of 8 bytes if
	  the user only specified the function entry.
	 
	  However, if the user specifies an offset, we fall back to using the
	  GEP since all userspace applications (objdumpreadelf) show function
	  disassembly with offsets from the GEP.
 For kretprobes, add an offset only if the kernel supports it 
 HAVE_LIBELF_SUPPORT 
 SPDX-License-Identifier: GPL-2.0
 PowerPC does not support 'ldlat' parameter. 
 SPDX-License-Identifier: GPL-2.0
 REG or %rREG 
 -NUM(REG) or NUM(REG) or -NUM(%rREG) or NUM(%rREG) 
  Parse OP and convert it into uprobe format, which is, +-NUM(%gprREG).
  Possible variants of OP are:
 	Format		Example
 	-------------------------
 	NUM(REG)	48(18)
 	-NUM(REG)	-48(18)
 	NUM(%rREG)	48(%r18)
 	-NUM(%rREG)	-48(%r18)
 	REG		18
 	%rREG		%r18
 	iNUM		i0
 	i-NUM		i-1
  SDT marker arguments on Powerpc uses %rREG form with -mregnames flag
  and REG form with -mno-regnames. Here REG is general purpose register,
  which is in 0 to 31 range.
 Constant argument. Uprobe does not support it 
 REG or %rREG --> %gprREG 
 % g p r NULL 
		
		  -NUM(REG) or NUM(REG) or -NUM(%rREG) or NUM(%rREG) -->
		 	+-NUM(%gprREG)
 +- ( % g p r ) NULL 
	
	  Get the PVR value to set the extended
	  mask specific to platform.
	
	  check if the pmu supports perf extended regs, before
	  returning the register mask to sample.
 SPDX-License-Identifier: GPL-2.0
 look for end marker to ensure the entire data fit 
 SPDX-License-Identifier: GPL-2.0
 page_size
 On powerpc kernel text segment start at memory addresses, 0xc000000000000000
  whereas the modules are located at very high memory addresses,
  for example 0xc00800000xxxxxxx. The gap between end of kernel text segment
  and beginning of first module's text segment is very high.
  Therefore do not fill this gap and do not assign it to the kernel dso map.
 Limit the range of last kernel symbol 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 See backendsppc_initreg.c and backendsppc_regs.c in elfutils.  
 SPDX-License-Identifier: GPL-2.0
	
	  - Interested only if instruction starts with 'b'.
	  - Few start with 'b', but aren't branch instructions.
 ignore optional hints at the end of the instructions 
		
		  if the instruction ends up with 'l' or 'la', then
		  those are considered 'calls' since they update LR.
		  ... except for 'bnl' which is branch if not less than
		  and the absolute form of the same.
		
		  instructions ending with 'lr' are considered to be
		  return instructions
 SPDX-License-Identifier: GPL-2.0-or-later
  Mapping of DWARF debug register numbers into register names.
  Copyright (C) 2010 David S. Miller <davem@davemloft.net>
  get_arch_regstr() - lookup register name from it's DWARF register number
  @n:	the DWARF register number
  get_arch_regstr() returns the name of the register in struct
  regdwarfnum_table from it's DWARF register number. If the register is not
  found in the table, this returns NULL;
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Event: Basic-sampling 
 Event: Combined-sampling 
	
	  The AUX buffer size should be set properly to avoid
	  overflow of samples if it is not set explicitly.
	  DEFAULT_AUX_PAGES is an proper size when sampling frequency
	  is DEFAULT_FREQ. It is expected to hold about 12 second
	  of sampling data. The size used for AUX buffer will scale
	  according to the specified frequency and DEFAULT_FREQ.
  auxtrace_record__init is called when perf record
  check if the event really need auxtrace
 sampling in diagnose mode. alloc aux buffer 
 SPDX-License-Identifier: GPL-2.0
  Mapping of DWARF debug register numbers into register names.
  Copyright IBM Corp. 2010, 2017
  Author(s): Heiko Carstens <heiko.carstens@de.ibm.com>,
 	      Hendrik Brueckner <brueckner@linux.vnet.ibm.com>
  Convert the register name into an offset to struct pt_regs (kernel).
  This is required by the BPF prologue generator.  The BPF
  program is called in the BPF overflow handler in the perf
  core.
 SPDX-License-Identifier: GPL-2.0-only
  Arch specific functions for perf kvm stat.
  Copyright 2014 IBM Corp.
  Author(s): Alexander Yarygin <yarygin@linux.vnet.ibm.com>
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
  Implementation of get_cpuid().
  Copyright IBM Corp. 2014, 2018
  Author(s): Alexander Yarygin <yarygin@linux.vnet.ibm.com>
 	      Thomas Richter <tmricht@linux.vnet.ibm.com>
	
	  Scan procsysinfo line by line and read out values for
	  Manufacturer:, Type: and Model:, for example:
	  Manufacturer:    IBM
	  Type:            2964
	  Model:           702              N96
	  The first word is the Model Capacity and the second word is
	  Model (can be omitted). Both words have a maximum size of 16
	  bytes.
 Missing manufacturer, type or model information should not happen 
	
	  Scan procservice_levels and return the CPU-MF counter facility
	  version number and authorization level.
	  Optional, does not exist on zVM guests.
 SPDX-License-Identifier: GPL-2.0
 page_size
		 Successful read of the modules segment text start address.
		  Calculate difference between module start address
		  in memory and module text segment start address.
		  For example module load address is 0x3ff8011b000
		  (from procmodules) and module text segment start
		  address is 0x3ff8011b870 (from file above).
		 
		  Adjust the module size and subtract the GOT table
		  size located at the beginning of the module.
 On s390 kernel text segment start is located at very low memory addresses,
  for example 0x10000. Modules are located at very high memory addresses,
  for example 0x3ff xxxx xxxx. The gap between end of kernel text segment
  and beginning of first module's text segment is very big.
  Therefore do not fill this gap and do not assign it to the kernel dso map.
 Last kernel symbol mapped to end of page 
	
	  For DWARF register mapping details,
	  see also perfarchs390includedwarf-regs-table.h
 SPDX-License-Identifier: GPL-2.0
 catch all kind of jumps 
 override callreturns 
 override loadstore relative to PC 
	
	  cpuid string format:
	  "IBM,family,model-capacity,model[,cpum_cf-version,cpum_cf-authorization]"
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2019 Hangzhou C-SKY Microsystems co.,ltd.
 Mapping of DWARF debug register numbers into register names.
 r0 ~ r8 
 r9 ~ r15 
 r16 ~ r23 
 r24 ~ r31 
 r0 ~ r8 
 r9 ~ r15 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2019 Hangzhou C-SKY Microsystems co.,ltd.
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2019 Hangzhou C-SKY Microsystems co.,ltd.
 catch all kind of jumps 
 catch function call 
 catch function return 
 SPDX-License-Identifier: GPL-2.0
  dwarf-regs.c : Mapping of DWARF debug register numbers into register names.
  Copyright (C) 2013 Cavium, Inc.
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 Hangzhou C-SKY Microsystems co.,ltd.
  Mapping of DWARF debug register numbers into register names.
 for EINVAL 
 for strcmp 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2019 Hangzhou C-SKY Microsystems co.,ltd. 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
  Mapping of DWARF debug register numbers into register names.
  Copyright (C) 2010 Will Deacon, ARM Ltd.
 for struct user_pt_regs 
  Reference:
  http:infocenter.arm.comhelptopiccom.arm.doc.ihi0057bIHI0057B_aadwarf64.pdf
  get_arch_regstr() - lookup register name from it's DWARF register number
  @n:	the DWARF register number
  get_arch_regstr() returns the name of the register in struct
  regdwarfnum_table from it's DWARF register number. If the register is not
  found in the table, this returns NULL;
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
	
	  TRAP exceptions carry exception class info in esr_ec field
	  and, hence, we need to use a different exit_reasons table to
	  properly decode event's est_ec.
 SPDX-License-Identifier: GPL-2.0
		
		  The cpumap should cover all CPUs. Otherwise, some CPUs may
		  not support some events or have different event IDs.
 SPDX-License-Identifier: GPL-2.0
 PERF_MEM_EVENTS__STORE 
 SPDX-License-Identifier: GPL-2.0
 %xNUM 
 [sp], [sp, NUM] 
  SDT marker arguments on Arm64 uses %xREG or [sp, NUM], currently
  support these two formats.
 Extract xNUM 
 % NULL 
 [sp], [sp, NUM] or [sp,NUM] 
 + ( % s p ) NULL 
 If the argument is [sp], need to fill offset '0' 
		 Ignoreclear Variant[23:20] and
		  Revision[3:0] of MIDR
 got midr break loop 
 read midr from list of cpus mapped to this pmu 
 SPDX-License-Identifier: GPL-2.0
 On arm64, kernel text segment starts at high memory address,
  for example 0xffff 0000 8xxx xxxx. Modules start at a low memory
  address, like 0xffff 0000 00ax xxxx. When only small amount of
  memory is used by modules, gap between end of module's text segment
  and start of kernel text segment may reach 2G.
  Therefore do not fill this gap and do not assign it to the kernel dso map.
 4K 
 Limit range of last symbol in module and kernel 
 SPDX-License-Identifier: GPL-2.0
	
	  According to ARM DDI 0487F.c, from Armv8.0 to Armv8.5 inclusive, the
	  system counter is at least 56 bits wide; from Armv8.6, the counter
	  must be 64 bits wide.  So the system counter could be less than 64
	  bits wide and it is attributed with the flag 'cap_user_time_short'
	  is true.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Arm Statistical Profiling Extensions (SPE) support
  Copyright (c) 2017-2018, Arm Ltd.
 page_size
 reallocarray
 Skip if user has set it 
	
	  The default snapshot size is the auxtrace mmap size. If neither auxtrace mmap size nor
	  snapshot size is specified, then the default is 4MiB for privileged users, 128KiB for
	  unprivileged users.
	 
	  The default auxtrace mmap size is 4MiBpage_size for privileged users, 128KiB for
	  unprivileged users. If an unprivileged user does not specify mmap pages, the mmap pages
	  will be reduced from the default 512KiBpage_size to 256KiBpage_size, otherwise the
	  user is likely to get an error as they exceed their mlock limmit.
	
	  No size were given to '-S' or '-m,', so go with the default
	
	  '-m,xyz' was specified but no snapshot size, so make the snapshot size as big as the
	  auxtrace mmap area.
	
	  '-Sxyz' was specified but no auxtrace mmap area, so make the auxtrace mmap area big
	  enough to fit the requested snapshot size.
	
	  we are in snapshot mode.
		
		  Command arguments '-Sxyz' andor '-m,xyz' are missing, so fill those in with
		  default values.
		
		  Snapshot size can't be bigger than the auxtrace area.
		
		  Something went wrong somewhere - this shouldn't happen.
 We are in full trace mode but '-m,xyz' wasn't specified 
 Validate auxtrace_mmap_pages 
	
	  To obtain the auxtrace buffer file descriptor, the auxtrace event
	  must come first.
	
	  In the case of per-cpu mmaps, sample CPU for AUX event;
	  also enable the timestamp tracing for samples correlation.
 Add dummy event to keep tracking 
 In per-cpu case, always need the time of mmap events etc 
 also track task context switch 
	
	  No need to allocate, so return early.
	
	  Make ptr->wrapped as big as idx.
	
	  Free'ed in arm_spe_recording_free().
	
	  init new allocated values.
	
	  Defensively handle the case where head might be continually increasing - if its value is
	  equal or greater than the size of the ring buffer, then we can safely determine it has
	  wrapped around. Otherwise, continue to detect if head might have wrapped.
	
	  We want to look the very last 512 byte (chosen arbitrarily) in the ring buffer.
	
	  The value of head is somewhere within the size of the ring buffer. This can be that there
	  hasn't been enough data to fill the ring buffer yet or the trace time was so long that
	  head has numerically wrapped around.  To find we need to check if we have data at the
	  very end of the ring buffer.  We can reliably do this because mmap'ed pages are zeroed
	  out and there is a fresh mapping with every new session.
	
	  head is less than 512 byte from the end of the ring buffer.
	
	  Speed things up by using 64 bit transactions (see "u64 buf" above)
	
	  If we find trace data at the end of the ring buffer, head has been there and has
	  numerically wrapped around at least once.
	
	  Allocate memory to keep track of wrapping if this is the first
	  time we deal with this mm.
	
	  Check to see if head has wrapped around.  If it hasn't only the
	  amount of data between head and old is snapshot'ed to avoid
	  bloating the perf.data file with zeros.  But as soon as head has
	  wrapped around the entire size of the AUX ring buffer it taken.
	
	  No wrap has occurred, we can just use head and old.
	
	  head has wrapped around - adjust head and old to pickup the
	  entire content of the AUX buffer.
	
	  If kernel driver doesn't advertise a minimum,
	  use max allowable by PMSIDR_EL1.INTERVAL
 SPDX-License-Identifier: GPL-2.0
 bl, blr 
 b, b.cond, br, cbzcbnz, tbztbnz 
 SPDX-License-Identifier: GPL-2.0
 page_size
  If the RDPMC instruction faults then signal this back to the test parent task:
 SPDX-License-Identifier: GPL-2.0
  test__insn_x86 - test x86 instruction decoder - new instructions.
  This function implements a test that decodes a selection of instructions and
  checks the results.  The Intel PT function that further categorizes
  instructions (i.e. intel_pt_get_insn()) is also checked.
  The instructions are originally in insn-x86-dat-src.c which has been
  processed by scripts gen-insn-x86-dat.sh and gen-insn-x86-dat.awk to produce
  insn-x86-dat-32.c and insn-x86-dat-64.c which are included into this program.
  i.e. to add new instructions to the test, edit insn-x86-dat-src.c, run the
  gen-insn-x86-dat.sh script, make perf, and then run the test.
  If the test passes %0 is returned, otherwise %-1 is returned.  Use the
  verbose (-v) option to see all the instructions and whether or not they
  decoded successfully.
 SPDX-License-Identifier: GPL-2.0
  Generated by gen-insn-x86-dat.sh and gen-insn-x86-dat.awk
  from insn-x86-dat-src.c for inclusion by insn-x86.c
  Do not change this code.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 page_size
  Create an event group that contains both a sampled hardware
  (cpu-cycles) and software (intel_cqmllc_occupancy) event. We then
  wait for the hardware perf counter to overflow and generate a PMI,
  which triggers an event read for both of the events in the group.
  Since reading Intel CQM event counters requires sending SMP IPIs, the
  CQM pmu needs to handle the above situation gracefully, and return
  the last read counter value to avoid triggering a WARN_ON_ONCE() in
  smp_call_function_many() caused by sending IPIs from NMI context.
	
	  Pick a power-of-two number of pages + 1 for the meta-data
	  page (struct perf_event_mmap_page). See toolsperfdesign.txt.
 SPDX-License-Identifier: GPL-2.0
	
	  Copying the stack may copy msan poison, avoid false positives in the
	  unwinder by removing the poison here.
	
	  Assignments to buf in the assembly function perf_regs_load aren't
	  seen by memory sanitizer. Zero the memory to convince memory
	  sanitizer the memory is initialized.
 SPDX-License-Identifier: GPL-2.0
  Generated by gen-insn-x86-dat.sh and gen-insn-x86-dat.awk
  from insn-x86-dat-src.c for inclusion by insn-x86.c
  Do not change this code.
 SPDX-License-Identifier: GPL-2.0-only
 Add a bit for overrun checking 
 The data does not contain 0xff so we use that to check the size 
  test__x86_sample_parsing - test X86 specific sample parsing
  This function implements a test that synthesizes a sample event, parses it
  and then checks that the parsed sample matches the original sample. If the
  test passes %0 is returned, otherwise %-1 is returned.
  For now, the PERF_SAMPLE_WEIGHT_STRUCT is the only X86 specific sample type.
  The test only checks the PERF_SAMPLE_WEIGHT_STRUCT type.
 SPDX-License-Identifier: GPL-2.0
		
		  The child sets itself for as tracee and
		  waits in signal for parent to trace it,
		  then it calls bp_1 and quits.
  This tests creates HW breakpoint, tries to
  change it and checks it was properly changed.
	
	  The parent does following steps:
	   - creates a new breakpoint (id 0) for bp_2 function
	   - changes that breakpoint to bp_1 function
	   - waits for the breakpoint to hit and checks
	     it has proper rip of bp_1 function
	   - detaches the child
  This tests creates HW breakpoint, tries to
  change it to bogus value and checks the original
  breakpoint is hit.
	
	  The parent does following steps:
	   - creates a new breakpoint (id 0) for bp_1 function
	   - tries to change that breakpoint to (-1) address
	   - waits for the breakpoint to hit and checks
	     it has proper rip of bp_1 function
	   - detaches the child
 SPDX-License-Identifier: GPL-2.0
  struct test_data - Test data.
  @len: number of bytes to decode
  @bytes: bytes to decode
  @ctx: packet context to decode
  @packet: expected packet
  @new_ctx: expected new packet context
  @ctx_unchanged: the packet context must not change
 Padding Packet 
 Short TakenNot Taken Packet 
 Long TakenNot Taken Packet 
 Target IP Packet 
 Packet Generation Enable 
 Packet Generation Disable 
 Flow Update Packet 
 Paging Information Packet 
 Mode Exec Packet 
 Mode TSX Packet 
 Trace Stop Packet 
 Core:Bus Ratio Packet 
 Timestamp Counter Packet 
 Mini Time Counter Packet 
 TSC  MTC Alignment Packet 
 Cycle Count Packet 
 Virtual-Machine Control Structure Packet 
 Overflow Packet 
 Packet Stream Boundary
 PSB End Packet 
 Maintenance Packet 
 Write Data to PT Packet 
 Execution Stop Packet 
 Monitor Wait Packet 
 Power Entry Packet 
 Power Exit Packet 
 Block Begin Packet 
 4-byte Block Item Packet 
 8-byte Block Item Packet 
 Block End Packet 
 Terminator 
 Decode a packet 
 Some packets must always leave the packet context unchanged 
 Compare to the expected values 
  This test feeds byte sequences to the Intel PT packet decoder and checks the
  results. Changes to the packet context are also checked.
 SPDX-License-Identifier: GPL-2.0
  This file contains instructions for testing by the test titled:
          "Test x86 instruction decoder - new instructions"
  Note that the 'Expecting' comment lines are consumed by the
  gen-insn-x86-dat.awk script and have the format:
          Expecting: <op> <branch> <rel>
  If this file is changed, remember to run the gen-insn-x86-dat.sh
  script and commit the result.
  Refer to insn-x86.c for more details.
 Following line is a marker for the awk script - do not change 
 Start here 
 Test fix for vcvtph2ps in x86-opcode-map.txt 
 AVX-512: Instructions with the same op codes as Mask Instructions  
 AVX-512: Mask Instructions 
 AVX-512: Op code 0f 5b 
 AVX-512: Op code 0f 6f 
 AVX-512: Op code 0f 78 
 AVX-512: Op code 0f 79 
 AVX-512: Op code 0f 7a 
 AVX-512: Op code 0f 7b 
 AVX-512: Op code 0f 7f 
 AVX-512: Op code 0f db 
 AVX-512: Op code 0f df 
 AVX-512: Op code 0f e6 
 AVX-512: Op code 0f eb 
 AVX-512: Op code 0f ef 
 AVX-512: Op code 0f 38 10 
 AVX-512: Op code 0f 38 11 
 AVX-512: Op code 0f 38 12 
 AVX-512: Op code 0f 38 13 
 AVX-512: Op code 0f 38 14 
 AVX-512: Op code 0f 38 15 
 AVX-512: Op code 0f 38 16 
 AVX-512: Op code 0f 38 19 
 AVX-512: Op code 0f 38 1a 
 AVX-512: Op code 0f 38 1b 
 AVX-512: Op code 0f 38 1f 
 AVX-512: Op code 0f 38 20 
 AVX-512: Op code 0f 38 21 
 AVX-512: Op code 0f 38 22 
 AVX-512: Op code 0f 38 23 
 AVX-512: Op code 0f 38 24 
 AVX-512: Op code 0f 38 25 
 AVX-512: Op code 0f 38 26 
 AVX-512: Op code 0f 38 27 
 AVX-512: Op code 0f 38 28 
 AVX-512: Op code 0f 38 29 
 AVX-512: Op code 0f 38 2a 
 AVX-512: Op code 0f 38 2c 
 AVX-512: Op code 0f 38 2d 
 AVX-512: Op code 0f 38 30 
 AVX-512: Op code 0f 38 31 
 AVX-512: Op code 0f 38 32 
 AVX-512: Op code 0f 38 33 
 AVX-512: Op code 0f 38 34 
 AVX-512: Op code 0f 38 35 
 AVX-512: Op code 0f 38 38 
 AVX-512: Op code 0f 38 38 
 AVX-512: Op code 0f 38 39 
 AVX-512: Op code 0f 38 3a 
 AVX-512: Op code 0f 38 3b 
 AVX-512: Op code 0f 38 3d 
 AVX-512: Op code 0f 38 3f 
 AVX-512: Op code 0f 38 42 
 AVX-512: Op code 0f 38 42 
 AVX-512: Op code 0f 38 43 
 AVX-512: Op code 0f 38 44 
 AVX-512: Op code 0f 38 46 
 AVX-512: Op code 0f 38 4c 
 AVX-512: Op code 0f 38 4d 
 AVX-512: Op code 0f 38 4e 
 AVX-512: Op code 0f 38 4f 
 AVX-512: Op code 0f 38 50 
 AVX-512: Op code 0f 38 51 
 AVX-512: Op code 0f 38 52 
 AVX-512: Op code 0f 38 53 
 AVX-512: Op code 0f 38 54 
 AVX-512: Op code 0f 38 55 
 AVX-512: Op code 0f 38 59 
 AVX-512: Op code 0f 38 5a 
 AVX-512: Op code 0f 38 5b 
 AVX-512: Op code 0f 38 62 
 AVX-512: Op code 0f 38 63 
 AVX-512: Op code 0f 38 64 
 AVX-512: Op code 0f 38 65 
 AVX-512: Op code 0f 38 66 
 AVX-512: Op code 0f 38 68 
 AVX-512: Op code 0f 38 70 
 AVX-512: Op code 0f 38 71 
 AVX-512: Op code 0f 38 72 
 AVX-512: Op code 0f 38 73 
 AVX-512: Op code 0f 38 75 
 AVX-512: Op code 0f 38 76 
 AVX-512: Op code 0f 38 77 
 AVX-512: Op code 0f 38 7a 
 AVX-512: Op code 0f 38 7b 
 AVX-512: Op code 0f 38 7c 
 AVX-512: Op code 0f 38 7d 
 AVX-512: Op code 0f 38 7e 
 AVX-512: Op code 0f 38 7f 
 AVX-512: Op code 0f 38 83 
 AVX-512: Op code 0f 38 88 
 AVX-512: Op code 0f 38 89 
 AVX-512: Op code 0f 38 8a 
 AVX-512: Op code 0f 38 8b 
 AVX-512: Op code 0f 38 8d 
 AVX-512: Op code 0f 38 8f 
 AVX-512: Op code 0f 38 90 
 AVX-512: Op code 0f 38 91 
 AVX-512: Op code 0f 38 9a 
 AVX-512: Op code 0f 38 9b 
 AVX-512: Op code 0f 38 a0 
 AVX-512: Op code 0f 38 a1 
 AVX-512: Op code 0f 38 a2 
 AVX-512: Op code 0f 38 a3 
 AVX-512: Op code 0f 38 aa 
 AVX-512: Op code 0f 38 ab 
 AVX-512: Op code 0f 38 b4 
 AVX-512: Op code 0f 38 b5 
 AVX-512: Op code 0f 38 c4 
 AVX-512: Op code 0f 38 c8 
 AVX-512: Op code 0f 38 ca 
 AVX-512: Op code 0f 38 cb 
 AVX-512: Op code 0f 38 cc 
 AVX-512: Op code 0f 38 cd 
 AVX-512: Op code 0f 38 cf 
 AVX-512: Op code 0f 38 dc 
 AVX-512: Op code 0f 38 dd 
 AVX-512: Op code 0f 38 de 
 AVX-512: Op code 0f 38 df 
 AVX-512: Op code 0f 3a 03 
 AVX-512: Op code 0f 3a 08 
 AVX-512: Op code 0f 3a 09 
 AVX-512: Op code 0f 3a 1a 
 AVX-512: Op code 0f 3a 0b 
 AVX-512: Op code 0f 3a 18 
 AVX-512: Op code 0f 3a 19 
 AVX-512: Op code 0f 3a 1a 
 AVX-512: Op code 0f 3a 1b 
 AVX-512: Op code 0f 3a 1e 
 AVX-512: Op code 0f 3a 1f 
 AVX-512: Op code 0f 3a 23 
 AVX-512: Op code 0f 3a 25 
 AVX-512: Op code 0f 3a 26 
 AVX-512: Op code 0f 3a 27 
 AVX-512: Op code 0f 3a 38 
 AVX-512: Op code 0f 3a 39 
 AVX-512: Op code 0f 3a 3a 
 AVX-512: Op code 0f 3a 3b 
 AVX-512: Op code 0f 3a 3e 
 AVX-512: Op code 0f 3a 3f 
 AVX-512: Op code 0f 3a 43 
 AVX-512: Op code 0f 3a 43 
 AVX-512: Op code 0f 3a 44 
 AVX-512: Op code 0f 3a 50 
 AVX-512: Op code 0f 3a 51 
 AVX-512: Op code 0f 3a 54 
 AVX-512: Op code 0f 3a 55 
 AVX-512: Op code 0f 3a 56 
 AVX-512: Op code 0f 3a 57 
 AVX-512: Op code 0f 3a 66 
 AVX-512: Op code 0f 3a 67 
 AVX-512: Op code 0f 3a 70 
 AVX-512: Op code 0f 3a 71 
 AVX-512: Op code 0f 3a 72 
 AVX-512: Op code 0f 3a 73 
 AVX-512: Op code 0f 3a ce 
 AVX-512: Op code 0f 3a cf 
 AVX-512: Op code 0f 72 (Grp13) 
 AVX-512: Op code 0f 38 c6 (Grp18) 
 AVX-512: Op code 0f 38 c7 (Grp19) 
 AVX-512: Examples 
 bndmk m64, bnd 
 bndcl rm64, bnd 
 bndcu rm64, bnd 
 bndcn rm64, bnd 
 bndmov m128, bnd 
 bndmov bnd, m128 
 bndmov bnd2, bnd1 
 bndldx mib, bnd 
 bndstx bnd, mib 
 bnd prefix on call, ret, jmp and all jcc 
 Expecting: call unconditional 0 
 Expecting: call indirect      0 
 Expecting: ret  indirect      0 
 Expecting: jmp  unconditional 0 
 Expecting: jmp  unconditional 0 
 Expecting: jmp  indirect      0 
 Expecting: jcc  conditional   0 
 sha1rnds4 imm8, xmm2m128, xmm1 
 sha1nexte xmm2m128, xmm1 
 sha1msg1 xmm2m128, xmm1 
 sha1msg2 xmm2m128, xmm1 
 sha256rnds2 <XMM0>, xmm2m128, xmm1 
 Note sha256rnds2 has an implicit operand 'xmm0' 
 sha256msg1 xmm2m128, xmm1 
 sha256msg2 xmm2m128, xmm1 
 clflushopt m8 
 Also check instructions in the same group encoding as clflushopt 
 clwb m8 
 Also check instructions in the same group encoding as clwb 
 cldemote m8 
 xsavec mem 
 xsaves mem 
 xrstors mem 
 ptwrite 
 tpause 
 umonitor 
 umwait 
 movdiri 
 movdir64b 
 enqcmd 
 enqcmds 
 incsspdq 
 Also check instructions in the same group encoding as incsspdq 
 rdsspdq 
 saveprevssp 
 rstorssp 
 wrssdq 
 wrussdq 
 setssbsy 
 Also check instructions in the same group encoding as setssbsy 
 clrssbsy 
 endbr3264 
 call withwithout notrack prefix 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 jmp withwithout notrack prefix 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 #ifdef __x86_64__ 
 bound r32, mem (same op code as EVEX prefix) 
 bound r16, mem (same op code as EVEX prefix) 
 AVX-512: Instructions with the same op codes as Mask Instructions  
 AVX-512: Mask Instructions 
 AVX-512: Op code 0f 5b 
 AVX-512: Op code 0f 6f 
 AVX-512: Op code 0f 78 
 AVX-512: Op code 0f 79 
 AVX-512: Op code 0f 7a 
 AVX-512: Op code 0f 7b 
 AVX-512: Op code 0f 7f 
 AVX-512: Op code 0f db 
 AVX-512: Op code 0f df 
 AVX-512: Op code 0f e6 
 AVX-512: Op code 0f eb 
 AVX-512: Op code 0f ef 
 AVX-512: Op code 0f 38 10 
 AVX-512: Op code 0f 38 11 
 AVX-512: Op code 0f 38 12 
 AVX-512: Op code 0f 38 13 
 AVX-512: Op code 0f 38 14 
 AVX-512: Op code 0f 38 15 
 AVX-512: Op code 0f 38 16 
 AVX-512: Op code 0f 38 19 
 AVX-512: Op code 0f 38 1a 
 AVX-512: Op code 0f 38 1b 
 AVX-512: Op code 0f 38 1f 
 AVX-512: Op code 0f 38 20 
 AVX-512: Op code 0f 38 21 
 AVX-512: Op code 0f 38 22 
 AVX-512: Op code 0f 38 23 
 AVX-512: Op code 0f 38 24 
 AVX-512: Op code 0f 38 25 
 AVX-512: Op code 0f 38 26 
 AVX-512: Op code 0f 38 27 
 AVX-512: Op code 0f 38 28 
 AVX-512: Op code 0f 38 29 
 AVX-512: Op code 0f 38 2a 
 AVX-512: Op code 0f 38 2c 
 AVX-512: Op code 0f 38 2d 
 AVX-512: Op code 0f 38 30 
 AVX-512: Op code 0f 38 31 
 AVX-512: Op code 0f 38 32 
 AVX-512: Op code 0f 38 33 
 AVX-512: Op code 0f 38 34 
 AVX-512: Op code 0f 38 35 
 AVX-512: Op code 0f 38 36 
 AVX-512: Op code 0f 38 38 
 AVX-512: Op code 0f 38 39 
 AVX-512: Op code 0f 38 3a 
 AVX-512: Op code 0f 38 3b 
 AVX-512: Op code 0f 38 3d 
 AVX-512: Op code 0f 38 3f 
 AVX-512: Op code 0f 38 40 
 AVX-512: Op code 0f 38 42 
 AVX-512: Op code 0f 38 43 
 AVX-512: Op code 0f 38 44 
 AVX-512: Op code 0f 38 46 
 AVX-512: Op code 0f 38 4c 
 AVX-512: Op code 0f 38 4d 
 AVX-512: Op code 0f 38 4e 
 AVX-512: Op code 0f 38 4f 
 AVX-512: Op code 0f 38 50 
 AVX-512: Op code 0f 38 51 
 AVX-512: Op code 0f 38 52 
 AVX-512: Op code 0f 38 53 
 AVX-512: Op code 0f 38 54 
 AVX-512: Op code 0f 38 55 
 AVX-512: Op code 0f 38 59 
 AVX-512: Op code 0f 38 5a 
 AVX-512: Op code 0f 38 5b 
 AVX-512: Op code 0f 38 62 
 AVX-512: Op code 0f 38 63 
 AVX-512: Op code 0f 38 64 
 AVX-512: Op code 0f 38 65 
 AVX-512: Op code 0f 38 66 
 AVX-512: Op code 0f 38 68 
 AVX-512: Op code 0f 38 70 
 AVX-512: Op code 0f 38 71 
 AVX-512: Op code 0f 38 72 
 AVX-512: Op code 0f 38 73 
 AVX-512: Op code 0f 38 75 
 AVX-512: Op code 0f 38 76 
 AVX-512: Op code 0f 38 77 
 AVX-512: Op code 0f 38 7a 
 AVX-512: Op code 0f 38 7b 
 AVX-512: Op code 0f 38 7c 
 AVX-512: Op code 0f 38 7d 
 AVX-512: Op code 0f 38 7e 
 AVX-512: Op code 0f 38 7f 
 AVX-512: Op code 0f 38 83 
 AVX-512: Op code 0f 38 88 
 AVX-512: Op code 0f 38 89 
 AVX-512: Op code 0f 38 8a 
 AVX-512: Op code 0f 38 8b 
 AVX-512: Op code 0f 38 8d 
 AVX-512: Op code 0f 38 8f 
 AVX-512: Op code 0f 38 90 
 AVX-512: Op code 0f 38 91 
 AVX-512: Op code 0f 38 9a 
 AVX-512: Op code 0f 38 9b 
 AVX-512: Op code 0f 38 a0 
 AVX-512: Op code 0f 38 a1 
 AVX-512: Op code 0f 38 a2 
 AVX-512: Op code 0f 38 a3 
 AVX-512: Op code 0f 38 aa 
 AVX-512: Op code 0f 38 ab 
 AVX-512: Op code 0f 38 b4 
 AVX-512: Op code 0f 38 b5 
 AVX-512: Op code 0f 38 c4 
 AVX-512: Op code 0f 38 c8 
 AVX-512: Op code 0f 38 ca 
 AVX-512: Op code 0f 38 cb 
 AVX-512: Op code 0f 38 cc 
 AVX-512: Op code 0f 38 cd 
 AVX-512: Op code 0f 38 cf 
 AVX-512: Op code 0f 38 dc 
 AVX-512: Op code 0f 38 dd 
 AVX-512: Op code 0f 38 de 
 AVX-512: Op code 0f 38 df 
 AVX-512: Op code 0f 3a 03 
 AVX-512: Op code 0f 3a 08 
 AVX-512: Op code 0f 3a 09 
 AVX-512: Op code 0f 3a 0a 
 AVX-512: Op code 0f 3a 0b 
 AVX-512: Op code 0f 3a 18 
 AVX-512: Op code 0f 3a 19 
 AVX-512: Op code 0f 3a 1a 
 AVX-512: Op code 0f 3a 1b 
 AVX-512: Op code 0f 3a 1e 
 AVX-512: Op code 0f 3a 1f 
 AVX-512: Op code 0f 3a 23 
 AVX-512: Op code 0f 3a 25 
 AVX-512: Op code 0f 3a 26 
 AVX-512: Op code 0f 3a 27 
 AVX-512: Op code 0f 3a 38 
 AVX-512: Op code 0f 3a 39 
 AVX-512: Op code 0f 3a 3a 
 AVX-512: Op code 0f 3a 3b 
 AVX-512: Op code 0f 3a 3e 
 AVX-512: Op code 0f 3a 3f 
 AVX-512: Op code 0f 3a 42 
 AVX-512: Op code 0f 3a 43 
 AVX-512: Op code 0f 3a 44 
 AVX-512: Op code 0f 3a 50 
 AVX-512: Op code 0f 3a 51 
 AVX-512: Op code 0f 3a 54 
 AVX-512: Op code 0f 3a 55 
 AVX-512: Op code 0f 3a 56 
 AVX-512: Op code 0f 3a 57 
 AVX-512: Op code 0f 3a 66 
 AVX-512: Op code 0f 3a 67 
 AVX-512: Op code 0f 3a 70 
 AVX-512: Op code 0f 3a 71 
 AVX-512: Op code 0f 3a 72 
 AVX-512: Op code 0f 3a 73 
 AVX-512: Op code 0f 3a ce 
 AVX-512: Op code 0f 3a cf 
 AVX-512: Op code 0f 72 (Grp13) 
 AVX-512: Op code 0f 38 c6 (Grp18) 
 AVX-512: Op code 0f 38 c7 (Grp19) 
 AVX-512: Examples 
 bndmk m32, bnd 
 bndcl rm32, bnd 
 bndcu rm32, bnd 
 bndcn rm32, bnd 
 bndmov m64, bnd 
 bndmov bnd, m64 
 bndmov bnd2, bnd1 
 bndldx mib, bnd 
 bndstx bnd, mib 
 bnd prefix on call, ret, jmp and all jcc 
 Expecting: call unconditional 0xfffffffc 
 Expecting: call indirect      0 
 Expecting: ret  indirect      0 
 Expecting: jmp  unconditional 0xfffffffc 
 Expecting: jmp  unconditional 0xfffffffc 
 Expecting: jmp  indirect      0 
 Expecting: jcc  conditional   0xfffffffc 
 sha1rnds4 imm8, xmm2m128, xmm1 
 sha1nexte xmm2m128, xmm1 
 sha1msg1 xmm2m128, xmm1 
 sha1msg2 xmm2m128, xmm1 
 sha256rnds2 <XMM0>, xmm2m128, xmm1 
 Note sha256rnds2 has an implicit operand 'xmm0' 
 sha256msg1 xmm2m128, xmm1 
 sha256msg2 xmm2m128, xmm1 
 clflushopt m8 
 Also check instructions in the same group encoding as clflushopt 
 clwb m8 
 Also check instructions in the same group encoding as clwb 
 cldemote m8 
 xsavec mem 
 xsaves mem 
 xrstors mem 
 ptwrite 
 tpause 
 umonitor 
 umwait 
 movdiri 
 movdir64b 
 enqcmd 
 enqcmds 
 incsspd 
 Also check instructions in the same group encoding as incsspd 
 rdsspd 
 saveprevssp 
 rstorssp 
 wrssd 
 wrussd 
 setssbsy 
 Also check instructions in the same group encoding as setssbsy 
 clrssbsy 
 endbr3264 
 call withwithout notrack prefix 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 Expecting: call indirect 0 
 jmp withwithout notrack prefix 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 Expecting: jmp indirect 0 
 #ifndef __x86_64__ 
 SGX 
 pconfig 
 wbnoinvd 
 Following line is a marker for the awk script - do not change 
 Stop here 
 SPDX-License-Identifier: GPL-2.0-only
  auxtrace.c: AUX area tracing support
  Copyright (c) 2013-2014, Intel Corporation.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-only
  intel_pt.c: Intel Processor Trace support
  Copyright (c) 2013-2015, Intel Corporation.
 page_size
	
	  Use capstopa_multiple_entries to indicate early hardware that had
	  extra frequent PSBs.
 Fall through 
	
	  If supported, force pass-through config term (pt=1) even if user
	  sets pt=0, which avoids senseless kernel errors.
 Did user change psb_period 
 Set psb_period to 0 
  Currently, there is not enough information to disambiguate different PEBS
  events, so only allow one.
 Set default sizes for snapshot mode 
 Set default sizes for sample mode 
 Set default sizes for full trace mode 
 Validate auxtrace_mmap_pages 
	
	  Per-cpu recording needs sched_switch events to distinguish different
	  threads.
		
		  To obtain the auxtrace buffer file descriptor, the auxtrace
		  event must come first.
		
		  In the case of per-cpu mmaps, we need the CPU on the
		  AUX event.
 Add dummy event to keep tracking 
 In per-cpu case, always need the time of mmap events etc 
 And the CPU for switch events 
	
	  Warn the user when we do not have enough information to decode i.e.
	  per-cpu with no sched_switch (except workload-only).
  intel_pt_compare_buffers - compare bytes in a buffer to a circular buffer.
  @buf1: first buffer
  @compare_size: number of bytes to compare
  @buf2: second buffer (a circular buffer)
  @offs2: offset in second buffer
  @buf2_size: size of second buffer
  The comparison allows for the possibility that the bytes to compare in the
  circular buffer are not contiguous.  It is assumed that @compare_size <=
  @buf2_size.  This function returns %false if the bytes are identical, %true
  otherwise.
	
	  In full trace mode 'head' continually increases.  However in snapshot
	  mode 'head' is an offset within the buffer.  Here 'old' and 'head'
	  are adjusted to match the full trace case which expects that 'old' is
	  always less than 'head'.
	
	  Decoding starts at a PSB packet. Minimum PSB period is 2K so 4K
	  should give at least 1 PSB per sample.
 SPDX-License-Identifier: GPL-2.0-or-later
  dwarf-regs.c : Mapping of DWARF debug register numbers into register names.
  Extracted from probe-finder.c
  Written by Masami Hiramatsu <mhiramat@redhat.com>
 for EINVAL 
 for strcmp 
 for struct pt_regs 
 for offsetof 
  See archx86kernelptrace.c.
  Different from it:
   - Since struct pt_regs is defined differently for user and kernel,
     but we want to use 'ax, bx' instead of 'rax, rbx' (which is struct
     field name of user's pt_regs), we make REG_OFFSET_NAME to accept
     both string name and reg field name.
   - Since accessing x86_32's pt_regs from x86_64 building is difficult
     and vise versa, we simply fill offset with -1, so
     get_arch_regstr() still works but regs_query_register_offset()
     returns error.
     The only inconvenience caused by it now is that we are not allowed
     to generate BPF prologue for a x86_64 kernel if perf is built for
     x86_32. This is really a rare usecase.
   - Order is different from kernel's ptrace.c for get_arch_regstr(). Use
     the order defined by dwarf.
 TODO: switching by dwarf address size 
 Stack address instead of %sp 
 Minus 1 for the ending REG_OFFSET_END 
 Return architecture dependent register string (for kprobe-tracer) 
 Reuse code from archx86kernelptrace.c 
  regs_query_register_offset() - query register offset from its name
  @name:	the name of a register
  regs_query_register_offset() returns the offset of a register in struct
  pt_regs from its name. If the name is invalid, this returns -EINVAL;
 SPDX-License-Identifier: GPL-2.0
 HAVE_ARCH_X86_64_SUPPORT 
 SPDX-License-Identifier: GPL-2.0
  For the mmio events, we treat:
  the time of MMIO write: kvm_mmio(KVM_TRACE_MMIO_WRITE...) -> kvm_entry
  the time of MMIO read: kvm_exit -> kvm_mmio(KVM_TRACE_MMIO_READ...).
 MMIO read begin event in kernel. 
 MMIO write begin event in kernel. 
 MMIO write end event in kernel. 
 MMIO read end event in kernel.
 The time of emulation pio access is from kvm_pio to kvm_entry. 
 The time of emulation msr is from kvm_msr to kvm_entry. 
 SPDX-License-Identifier: GPL-2.0
 Remove the last '\n' 
 SPDX-License-Identifier: GPL-2.0
  perf iostat
  Copyright (C) 2020, Intel Corporation
  Authors: Alexander Antonov <alexander.antonov@linux.intel.com>
  Each metric requiries one IIO event which increments at every 4B transfer
  in corresponding direction. The formulas to compute metrics are generic:
      #EventCount  4B  (1024  1024)
	
	  Expected format domain:bus:
	  Valid domain range [0:ffff]
	  Valid bus range [0:ff]
	  Example: 0000:af, 0:3d, 01:7
 SPDX-License-Identifier: GPL-2.0
  Check whether we can use a group for top down.
  Without a group may get bad results due to multiplexing.
  Check whether a topdown group supports sample-read.
  Only Topdown metic supports sample-read. The slots
  event must be the leader of the topdown group.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 rNN registers 
  Perf only supports OP which is in  +-NUM(REG)  form.
  Here plus-minus sign, NUM and parenthesis are optional,
  only REG is mandatory.
  SDT events also supports indirect addressing mode with a
  symbol as offset, scaled mode and constants in OP. But
  perf does not support them yet. Below are few examples.
  OP with scaled mode:
      (%rax,%rsi,8)
      10(%ras,%rsi,8)
  OP with indirect addressing mode:
      check_action(%rip)
      mp_+52(%rip)
      44+mp_(%rip)
  OP with constant values:
      $0
      $123
      $-1
  Max x86 register name length is 5(ex: %r15d). So, 6th char
  should always contain NULL. This helps to find register name
  length using strlen, instead of maintaining one more variable.
  The uprobe parser does not support all gas register names;
  so, we have to replace them (ex. for x86_64: %rax -> %ax).
  Note: If register does not require renaming, just copy
  paste as it is, but don't leave it empty.
	
	  rm[0]:  +-NUM(REG)
	  rm[1]:  +-
	  rm[2]:  NUM
	  rm[3]:  (
	  rm[4]:  REG
	  rm[5]:  )
	
	  Max prefix length is 2 as it may contains sign(+-)
	  and displacement 0 (Both sign and displacement 0 are
	  optional so it may be empty). Use one more character
	  to hold last NULL so that strlen can be used to find
	  prefix length, instead of maintaining one more variable.
	
	  If unsupported OR does not match with regex OR
	  register name too long, skip it.
	
	  Prepare prefix.
	  If SDT OP has parenthesis but does not provide
	  displacement, add 0 for displacement.
	      SDT         Uprobe     Prefix
	      -----------------------------
	      +24(%rdi)   +24(%di)   +
	      24(%rdi)    +24(%di)   +
	      %rdi        %di
	      (%rdi)      +0(%di)    +0
	      -80(%rbx)   -80(%bx)   -
 Rename register 
 Prepare final OP which should be valid for uprobe_events 
 NULL 
	
	  In an unnamed union, init it here to build on older gcc versions
 SPDX-License-Identifier: GPL-2.0
 bits 11 - 8 
 Bits  7 - 4 
 extended family 
 extended model 
 look for end marker to ensure the entire data fit 
 Full CPUID format for x86 is vendor-family-model-stepping 
	
	  Full CPUID format is required to identify a platform.
	  Error out if the cpuid string is incomplete.
 Warn unable to generate match particular string. 
		 If the full CPUID format isn't required,
		  ignoring the stepping.
 Verify the entire string matched. 
 SPDX-License-Identifier: GPL-2.0
 page_size
 SPDX-License-Identifier: GPL-2.0
		
		  kernel uses 0 for user space maps, see kernelperf_event.c
		  __perf_event_mmap
 SPDX-License-Identifier: GPL-2.0-only
  intel-bts.c: Intel Processor Trace support
  Copyright (c) 2013-2015, Intel Corporation.
 page_size
 Set default sizes for snapshot mode 
 Set default sizes for full trace mode 
 Validate auxtrace_mmap_pages 
		
		  To obtain the auxtrace buffer file descriptor, the auxtrace event
		  must come first.
		
		  In the case of per-cpu mmaps, we need the CPU on the
		  AUX event.
 Add dummy event to keep tracking 
	
	  In full trace mode 'head' continually increases.  However in snapshot
	  mode 'head' is an offset within the buffer.  Here 'old' and 'head'
	  are adjusted to match the full trace case which expects that 'old' is
	  always less than 'head'.
 SPDX-License-Identifier: GPL-2.0
	
	  On AMD, precise cycles event sampling internally uses IBS pmu.
	  But IBS does not have filtering capabilities and perf by default
	  sets exclude_guest = 1. This makes IBS pmu event init fail and
	  thus perf ends up doing non-precise sampling. Avoid it by clearing
	  exclude_guest.
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 Family >= 15h supports cmptest + branch fusion 
 Family >= 19h supports some ALU + branch fusion 
 Nehalem 
 Newer platform 
	
	  cpuid = "GenuineIntel,family,model,stepping"
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2005-2017 Andes Technology Corporation
 In nds32, we only have one cpu 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Copyright(C) 2015 Linaro Limited. All rights reserved.
  Author: Mathieu Poirier <mathieu.poirier@linaro.org>
 arm_spe_xxxxxxxxx\0 
	
	  Clear 'err' even if we haven't found an event - that way perf
	  record can still be used even if tracers aren't present.  The NULL
	  return value will take care of telling the infrastructure HW tracing
	  isn't available.
 Ensure all reads are done before we write the tail out 
 SPDX-License-Identifier: GPL-2.0-only
  Mapping of DWARF debug register numbers into register names.
  Copyright (C) 2010 Will Deacon, ARM Ltd.
  Reference:
  http:infocenter.arm.comhelptopiccom.arm.doc.ihi0040aIHI0040A_aadwarf.pdf
  get_arch_regstr() - lookup register name from it's DWARF register number
  @n:	the DWARF register number
  get_arch_regstr() returns the name of the register in struct
  regdwarfnum_table from it's DWARF register number. If the register is not
  found in the table, this returns NULL;
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Copyright(C) 2015 Linaro Limited. All rights reserved.
  Author: Mathieu Poirier <mathieu.poirier@linaro.org>
 add ETM default config here 
 SPDX-License-Identifier: GPL-2.0
  Copyright(C) 2015 Linaro Limited. All rights reserved.
  Author: Mathieu Poirier <mathieu.poirier@linaro.org>
 page_size
 Get a handle on TRCIDR2 
 There was a problem reading the file, bailing out 
 User has configured for PID tracing, respects it. 
	
	  If user doesn't configure the contextid format, parse PMU format and
	  enable PID tracing according to the "contextid" format bits:
	 
	    If bit ETM_OPT_CTXTID is set, trace CONTEXTIDR_EL1;
	    If bit ETM_OPT_CTXTID2 is set, trace CONTEXTIDR_EL2.
		
		  TRCIDR2.CIDSIZE, bit [9-5], indicates whether contextID
		  tracing is supported:
		   0b00000 Context ID tracing is not supported.
		   0b00100 Maximum of 32-bit Context ID size.
		   All other values are reserved.
		
		  TRCIDR2.VMIDOPT[30:29] != 0 and
		  TRCIDR2.VMIDSIZE[14:10] == 0b00100 (32bit virtual contextid)
		  We can't support CONTEXTIDR in VMID if the size of the
		  virtual context id is < 32bit.
		  Any value of VMIDSIZE >= 4 (i.e, > 32bit) is fine for us.
 All good, let the kernel know 
 Get a handle on TRCIRD0 
 There was a problem reading the file, bailing out 
	
	  TRCIDR0.TSSIZE, bit [28-24], indicates whether global timestamping
	  is supported:
	   0b00000 Global timestamping is not implemented
	   0b00110 Implementation supports a maximum timestamp of 48bits.
	   0b01000 Implementation supports a maximum timestamp of 64bits.
 All good, let the kernel know 
 Set option of each CPU we have 
 Nothing else is currently supported 
	
	  No sink was provided on the command line - allow the CoreSight
	  system to look for a default
 no need to continue if at least one event of interest was found 
 we are in snapshot mode 
		
		  No size were given to '-S' or '-m,', so go with
		  the default
		
		  '-m,xyz' was specified but no snapshot size, so make the
		  snapshot size as big as the auxtrace mmap area.
		
		  -Sxyz was specified but no auxtrace mmap area, so make the
		  auxtrace mmap area big enough to fit the requested snapshot
		  size.
 Snapshot size can't be bigger than the auxtrace area 
 Something went wrong somewhere - this shouldn't happen 
 We are in full trace mode but '-m,xyz' wasn't specified 
 Validate auxtrace_mmap_pages provided by user 
	
	  To obtain the auxtrace buffer file descriptor, the auxtrace
	  event must come first.
	
	  In the case of per-cpu mmaps, we need the CPU on the
	  AUX event.  We also need the contextID in order to be notified
	  when a context switch happened.
 Add dummy event to keep tracking 
 In per-cpu case, always need the time of mmap events etc 
			
			  Variable perf_event_attr::config is assigned to
			  ETMv3PTM.  The bit fields have been made to match
			  the ETMv3.5 ETRMCR register specification.  See the
			  PMU_FORMAT_ATTR() declarations in
			  drivershwtracingcoresightcoresight-perf.c for
			  details.
	
	  The perf event variable config bits represent both
	  the command line options and register programming
	  bits in ETMv3PTM. For ETMv4 we must remap options
	  to real bits
 cpu map is not empty, we have specific CPUs to work with 
 get configuration for all CPUs in the system 
 Take any of the RO files for ETMv4 and see if it present 
 The file was read successfully, we have a winner 
 Get RO metadata from sysfs 
	
	  ETE if ARCHVER is 5 (ARCHVER is 4 for ETM) and ARCHPART is 0xA13.
	  See ETM_DEVARCH_ETE_ARCH in coresight-etm4x.h
 Get trace configuration register 
 Get traceID from the framework 
 Get read-only information from sysFS 
 first see what kind of tracer this cpu is affined to 
 ETE uses the same registers as ETMv4 plus TRCDEVARCH 
 How much space was used 
 How much space was used 
 Get configuration register 
 Get traceID from the framework 
 Get read-only information from sysFS 
 How much space was used 
 Build generic header portion 
 Where the next CPU entry should start from 
 If the cpu_map is empty all online CPUs are involved 
 Make sure all specified CPUs are online 
 Get PMU type as dynamically assigned by the core 
 First fill out the session header 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  dlfilter-test-api-v0.c: test original (v0) API for perf --dlfilter shared object
  Copyright (c) 2021, Intel Corporation.
  Copy original (v0) API instead of including current API
 Definitions for perf_dlfilter_sample flags 
  perf sample event information (as per perf script and <linuxperf_event.h>)
 Size of this structure (for compatibility checking) 
 Refer PERF_SAMPLE_WEIGHT_TYPE in <linuxperf_event.h> 
 Refer PERF_SAMPLE_WEIGHT_TYPE in <linuxperf_event.h> 
 Refer PERF_SAMPLE_WEIGHT_TYPE in <linuxperf_event.h> 
 Refer PERF_SAMPLE_TRANSACTION in <linuxperf_event.h> 
 For instructions-per-cycle (IPC) 
 For instructions-per-cycle (IPC) 
 Refer PERF_DLFILTER_FLAG_ above 
 Refer PERF_SAMPLE_DATA_SRC in <linuxperf_event.h> 
 Refer PERF_SAMPLE_PHYS_ADDR in <linuxperf_event.h> 
 Refer PERF_SAMPLE_DATA_PAGE_SIZE in <linuxperf_event.h> 
 Refer PERF_SAMPLE_CODE_PAGE_SIZE in <linuxperf_event.h> 
 Refer PERF_SAMPLE_CGROUP in <linuxperf_event.h> 
 Refer CPUMODE_MASK etc in <linuxperf_event.h> 
 True => resolve_addr() can be called 
 Refer perf_event_header in <linuxperf_event.h> 
 Refer PERF_SAMPLE_RAW in <linuxperf_event.h> 
 Refer PERF_SAMPLE_RAW in <linuxperf_event.h> 
 Number of brstack entries 
 Refer <linuxperf_event.h> 
 Number of raw_callchain entries 
 Refer <linuxperf_event.h> 
  Address location (as per perf script)
 Size of this structure (for compatibility checking) 
 Mapped address (from dso) 
 STB_LOCAL, STB_GLOBAL or STB_WEAK, refer <elf.h> 
 Only valid if dso is not NULL 
 True if in kernel space 
 Below members are only populated by resolve_ip() 
 True if this sample event will be filtered out 
 Return information about ip 
 Return information about addr (if addr_correlates_sym) 
 Return arguments from --dlarg option 
	
	  Return information about address (al->size must be set before
	  calling). Returns 0 on success, -1 otherwise.
 Return instruction bytes and length 
 Return source file name and line number 
 Return perf_event_attr, refer <linuxperf_event.h> 
 Read object code, return numbers of bytes read 
 Reserved 
 SPDX-License-Identifier: GPL-2.0
  dlfilter-show-cycles.c: Print the number of cycles at the start of each line
  Copyright (c) 2021, Intel Corporation.
 SPDX-License-Identifier: LGPL-2.1
  tracebeautymove_mount.c
   Copyright (C) 2019, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
  tracebeautyioctl.c
   Copyright (C) 2017, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
  FIXME: to support all arches we have to improve this, for
  now, to build on older systems without things like TIOCGEXCL,
  get it directly from our copy.
  Right now only x86 is being supported for beautifying ioctl args
  in 'perf trace', see toolsperftracebeautyBuild and builtin-trace.c
 Must be ordered by type 
 USB_DEVICE_MAJOR
 SPDX-License-Identifier: LGPL-2.1
 SPDX-License-Identifier: LGPL-2.1
	
	  Can't use a strarray, MIPS may override for ABI reasons.
 SPDX-License-Identifier: LGPL-2.1
  tracebeautymount_flags.c
   Copyright (C) 2018, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 do_mount in fsnamespace.c:
	
	  Pre-0.97 versions of mount() didn't have a flags word.  When the
	  flags word was introduced its top half was required to have the
	  magic value 0xC0ED, and this remained so until 2.4.0-test9.
	  Therefore, if this magic number is present, it carries no
	  information and must be discarded.
 SPDX-License-Identifier: LGPL-2.1
 SPDX-License-Identifier: LGPL-2.1
 SPDX-License-Identifier: LGPL-2.1
  Not defined anywhere else, probably, just to make sure we
  catch future flags
 SPDX-License-Identifier: LGPL-2.1
 Copyright (C) 2018, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
  tracebeautyarch_prctl.c
   Copyright (C) 2018, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
  tracebeautyfspick.c
   Copyright (C) 2019, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
  tracebeautyfcntl.c
   Copyright (C) 2017, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
	
	  Some commands ignore the third fcntl argument, "arg", so mask it
	
	  We still don't grab the contents of pointers on entry or exit,
	  so just print them as hex numbers
 SPDX-License-Identifier: LGPL-2.1
 Mask 4th ('fd') and 5th ('offset') args, ignored 
 Mask 5th ('new_address') args, ignored 
 SPDX-License-Identifier: LGPL-2.1
 SPDX-License-Identifier: LGPL-2.1
  tracebeautycone.c
   Copyright (C) 2017, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
  tracebeautypkey_alloc.c
   Copyright (C) 2017, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
  tracebeautyfsmount.c
   Copyright (C) 2019, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
  tracebeautysync_file_range.c
   Copyright (C) 2019, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
  tracebeautystatx.c
   Copyright (C) 2017, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
  tracebeautykcmp.c
   Copyright (C) 2017, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 idx1 -> pid1, idx2 -> pid2 
 Ignore idx1 and idx2 
 SPDX-License-Identifier: LGPL-2.1
  tracebeautyprctl.c
   Copyright (C) 2017, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
	
	  We still don't grab the contents of pointers on entry or exit,
	  so just print them as hex numbers
 SPDX-License-Identifier: LGPL-2.1
 SPDX-License-Identifier: LGPL-2.1
 SPDX-License-Identifier: LGPL-2.1
 Copyright (C) 2018, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
 From includelinuxstat.h 
 SPDX-License-Identifier: LGPL-2.1
 SPDX-License-Identifier: LGPL-2.1
 Mask the mode parm 
 SPDX-License-Identifier: LGPL-2.1
 SPDX-License-Identifier: LGPL-2.1
 pid=cgroup id, per-cpu mode only 
 O_CLOEXEC 
 SPDX-License-Identifier: LGPL-2.1
 SPDX-License-Identifier: LGPL-2.1
  tracebeautysocket.c
   Copyright (C) 2018, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
  tracebeautyx86_irq_vectors.c
   Copyright (C) 2019, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
  tracebeautyx86_msr.c
   Copyright (C) 2019, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: GPL-2.0
  uledmon.c
  This program creates a new userspace LED class device and monitors it. A
  timestamp and brightness value is printed each time the brightness changes.
  Usage: uledmon <device-name>
  <device-name> is the name of the LED class device to be created. Pressing
  CTRL+C will exit.
 SPDX-License-Identifier: GPL-2.0
  led_hw_brightness_mon.c
  This program monitors LED brightness level changes having its origin
  in hardwarefirmware, i.e. outside of kernel control.
  A timestamp and brightness value is printed each time the brightness changes.
  Usage: led_hw_brightness_mon <device-name>
  <device-name> is the name of the LED class device to be monitored. Pressing
  CTRL+C will exit.
	
	  read may fail if no hw brightness change has occurred so far,
	  but it is required to avoid spurious poll notifications in
	  the opposite case.
 SPDX-License-Identifier: GPL-2.0-or-later
  ffs-test.c -- user mode filesystem api for usb composite function
  Copyright (C) 2010 Samsung Electronics
                     Author: Michal Nazarewicz <mina86@mina86.com>
 $(CROSS_COMPILE)cc -Wall -Wextra -g -o ffs-test ffs-test.c -lpthread 
 for endian.h 
 Little Endian Handling 
  cpu_to_le1632 are used when initializing structures, a context where a
  function call is not allowed. To solve this, we code cpu_to_le1632 in a way
  that allows them to be used when initializing structures.
 Messages and Errors 
 Descriptors and Strings 
 .wMaxPacketSize = autoconfiguration (kernel) 
 .wMaxPacketSize = autoconfiguration (kernel) 
 NAK every 1 uframe 
 NAK every 1 uframe 
 Read v2 header 
	
	  Find the end of FS and HS USB descriptors.  SS descriptors
	  are ignored since legacy format does not support them.
 Allocate legacy descriptors and copy the data. 
 en-us 
 Files and Threads Handling 
 test the FIFO ioctls (non-ep0 code paths) 
 ENODEV reported after disconnect 
 nop 
 EmptyFill buffer routines 
 0 -- stream of zeros, 1 -- i % 63, 2 -- pipe 
 Endpoints routines 
 Main 
 SPDX-License-Identifier: GPL-2.0-or-later
 $(CROSS_COMPILE)cc -Wall -Wextra -g -lpthread -o testusb testusb.c 
  Copyright (c) 2002 by David Brownell
  Copyright (c) 2010 by Samsung Electronics
  Author: Michal Nazarewicz <mina86@mina86.com>
  This program issues ioctls to perform the tests implemented by the
  kernel driver.  It can generate a variety of transfer patterns; you
  should make sure to test both regular streaming and mixes of
  transfer sizes (including short transfers).
  For more information on how this can be used and on USB testing
  refer to <URL:http:www.linux-usb.orgusbtest>.
-------------------------------------------------------------------------
 FIXME make these public somewhere; usbdevfs.h?
 inputs
 0..(TEST_CASES-1) 
 outputs
-------------------------------------------------------------------------
 #include <linuxusb_ch9.h> 
 for DeviceClass 
 enumerating 
 usb 1.1 
 usb 2.0 
-------------------------------------------------------------------------
 FX2 with (tweaked) bulksrc firmware 
----------------------------------------------------
	 devices that start up using the EZ-USB default device and
	  which we can use after loading simple firmware.  hotplug
	  can fxload it, and then run this test driver.
	 
	  we return false positives in two cases:
	  - the device has a "real" driver (maybe usb-serial) that
	    renumerates.  the device should vanish quickly.
	  - the device doesn't have the test firmware installed.
 generic EZ-USB FX controller 
 generic EZ-USB FX2 controller 
 CY3671 development board with EZ-USB FX 
 Keyspan 19Qi uses an21xx (original EZ-USB) 
----------------------------------------------------
 "gadget zero", Linux-USB test software 
 user mode subset of that 
 return 0; 
 iso version of usermode code 
 some GPL'd test firmware uses these IDs 
----------------------------------------------------
 iBOT2 high speed webcam 
----------------------------------------------------
	 the FunctionFS gadget can have the sourcesink interface
	  anywhere.  We look for an interface descriptor that match
 unused 
 FIXME need a "syslog it" option for background testing 
 NOTE: each thread emits complete lines; no fragments! 
 all ;
	 pick defaults that works with all speeds, without short packets.
	 
	  Best per-frame data rates:
	      super speed,bulk      1024  16  8 = 131072
	                  interrupt 1024   3  8 =  24576
	      high speed, bulk       512  13  8 =  53248
	                  interrupt 1024   3  8 =  24576
	      full speed, bulkintr   64  19     =   1216
	                  interrupt   64   1     =     64
	       low speed, interrupt    8   1     =      8
 for easy use when hotplugging 
 device, if only one 
 use all devices with specified USB dir 
 FALL THROUGH 
 use all devices 
 count iterations 
 scattergather entries 
 loop forever 
 no test running! 
 size of packet 
 run just one test 
 vary packet size by ... 
 Find usb device subdirectory 
 collect and list the test devices 
 quit, run single test, or create test threads 
 kernel can recognize test devices we don't 
 wait for tests to complete 
 testing errors discarded! 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
                2005-2007 Takahiro Hirofuchi
 call at unbound state 
 buggy driver may cause dead lock 
 Create libudev context. 
 Get the device. 
 Check what kind of device it is. 
 Get the device driver. 
 No driver bound to this device. 
 Already bound to usbip-host. 
 Unbind device from driver. 
 Check whether the device with this bus ID exists. 
 If the device is already attached to vhci_hcd - bail out 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
                2005-2007 Takahiro Hirofuchi
  Copyright (C) 2015-2016 Samsung Electronics
                Igor Kotrasinski <i.kotrasinsk@samsung.com>
                Krzysztof Opasiak <k.opasiak@samsung.com>
 if VHCI_STATE_PATH exists, then it better be a directory 
 send a request 
 receive a reply 
 check the reply 
 import a device 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
                2005-2007 Takahiro Hirofuchi
 uint8_t members need nothing 
 return error status 
  IPv6 Ready
 get all possible addresses 
 try the addresses 
 should set TCP_NODELAY for usbip 
 TODO: write code for heartbeat 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
                2005-2007 Takahiro Hirofuchi
 SPDX-License-Identifier: GPL-2.0-or-later
  command structure borrowed from udev
  (git:git.kernel.orgpubscmlinuxhotplugudev.git)
  Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
                2005-2007 Takahiro Hirofuchi
 Terminate after printing error 
 FALLTHRU 
 invalid command 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
                2005-2007 Takahiro Hirofuchi
  Copyright (C) 2015-2016 Samsung Electronics
                Igor Kotrasinski <i.kotrasinsk@samsung.com>
                Krzysztof Opasiak <k.opasiak@samsung.com>
 Create libudev context. 
 Create libudev device enumeration. 
	 Take only USB devices that are not hubs and do not have
	  the bInterfaceNumber attribute, i.e. are not interfaces.
 Show information about each device. 
 Ignore devices attached to vhci_hcd 
 Get device information. 
 Get product name. 
 Print information. 
 We only have mechanism to enumerate gadgets bound to vudc 
 Get device information. 
 Get product name. 
 Print information. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
                2005-2007 Takahiro Hirofuchi
  Copyright (C) 2015-2016 Samsung Electronics
                Igor Kotrasinski <i.kotrasinsk@samsung.com>
                Krzysztof Opasiak <k.opasiak@samsung.com>
 should set TCP_NODELAY for usbip 
 export device needs a TCPIP socket descriptor 
	
	  Exclude devices that are already exported to a client from
	  the exportable device list to avoid:
	 	- import requests for devices that are exported only to
	 	  fail the request.
	 	- revealing devices that are imported by a client to
	 	  another client.
 number of exported devices 
		 We use seperate sockets for IPv4 and IPv6
	
	  To suppress warnings on systems with bindv6only disabled
	  (default), we use seperate sockets for IPv6 and IPv4 and set
	  IPV6_V6ONLY on the IPv6 sockets.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
                2005-2007 Takahiro Hirofuchi
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
                2005-2007 Takahiro Hirofuchi
 check for invalid port 
 remove the port state file 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
                2005-2007 Takahiro Hirofuchi
 Create libudev context. 
 Check whether the device with this bus ID exists. 
 Check whether the device is using usbip-host driver. 
 Unbind device from driver. 
 Notify driver of unbind. 
 Trigger new probing. 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005-2007 Takahiro Hirofuchi
 skip a header line 
 if a device is connected, look at it 
 strncmp("ss", hub, 2) == 0 
 go to the next line 
  Read the given port's record.
  To avoid buffer overflow we will read the entire line and
  validate each part's size. The initial buffer is padded by 4 to
  accommodate the 2 spaces, 1 newline and an additional character
  which is needed to properly validate the 3rd part without it being
  truncated to an acceptable length.
 validate the length of each of the 3 parts 
 ---------------------------------------------------------------------- 
 will be freed in usbip_driver_close() 
 what size should be ? 
 will be removed 
 what size should be ? 
%s:%s%s\n", idev->udev.busid,
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2015-2016 Samsung Electronics
                Igor Kotrasinski <i.kotrasinsk@samsung.com>
                Krzysztof Opasiak <k.opasiak@samsung.com>
  Refactored from usbip_host_driver.c, which is:
  Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
                2005-2007 Takahiro Hirofuchi
 reallocate buffer to include usb interface data 
 vudc does not support reading interfaces 
 Check whether device uses usbip driver. 
 only the first interface is true 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2015 Karol Kosik <karo9@interia.eu>
 		 2015 Samsung Electronics
  Author:	 Igor Kotrasinski <i.kotrasinsk@samsung.com>
  Based on toolsusbusbiplibsrcusbip_host_driver.c, which is:
  Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
                2005-2007 Takahiro Hirofuchi
 Only used for user output, little sense to output them in general 
 SPDX-License-Identifier: GPL-2.0-or-later
       names.c  --  USB name database manipulation routines
       Copyright (C) 1999, 2000  Thomas Sailer (sailer@ife.ee.ethz.ch)
 	Copyright (C) 2005 Takahiro Hirofuchi
 		- names_deinit() is added.
 add a cleanup function by takahiro 
 remove line ends 
isspace(buf[7])
isspace(buf[3]) buf[3] == ' ') {
isspace(buf[4]) buf[4] == ' ') {
isspace(buf[1]) buf[1] == ' ') {
			
			  set 1 as pseudo-id to indicate that the parser is
			  in a `L' section.
isspace(buf[1]) buf[1] == ' ') {
 class spec 
 audio terminal type spec 
 HID Descriptor bCountryCode 
 vendor 
 product or subclass spec 
 do not store hut 
 do not store langid 
 protocol spec 
isspace(buf[3]) buf[3] == ' ') {
isspace(buf[3]) buf[3] == ' ') {
			
			  set 1 as pseudo-id to indicate that the parser is
			  in a `HUT' section.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2005-2007 Takahiro Hirofuchi
	 The client chooses the device configuration
	  when attaching it so right after being bound
	  to usbip-host on the server the device will
	  have no configuration.
	  Therefore, attributes such as bConfigurationValue
	  and bNumInterfaces will not exist and sscanf will
	  fail. Check for these cases and don't treat them
	  as errors.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2011 matt mooney <mfm@muteddisk.com>
                2005-2007 Takahiro Hirofuchi
  Copyright (C) 2015-2016 Samsung Electronics
                Igor Kotrasinski <i.kotrasinsk@samsung.com>
                Krzysztof Opasiak <k.opasiak@samsung.com>
  This is free and unencumbered software released into the public domain.
  Anyone is free to copy, modify, publish, use, compile, sell, or
  distribute this software, either in source code form or as a compiled
  binary, for any purpose, commercial or non-commercial, and by any
  means.
  In jurisdictions that recognize copyright laws, the author or authors
  of this software dedicate any and all copyright interest in the
  software to the public domain. We make this dedication for the benefit
  of the public at large and to the detriment of our heirs and
  successors. We intend this dedication to be an overt act of
  relinquishment in perpetuity of all present and future rights to this
  software under copyright law.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
  For more information, please refer to <http:unlicense.org>
  struct test_state - describes test program state
  @list: list of devices returned by libusb_get_device_list function
  @found: pointer to struct describing tested device
  @ctx: context, set to NULL
  @handle: handle of tested device
  @attached: indicates that device was attached to kernel, and has to be
             reattached at the end of test program
  test_init - initialize test program
  test_exit - cleanup test program
  This is free and unencumbered software released into the public domain.
  Anyone is free to copy, modify, publish, use, compile, sell, or
  distribute this software, either in source code form or as a compiled
  binary, for any purpose, commercial or non-commercial, and by any
  means.
  In jurisdictions that recognize copyright laws, the author or authors
  of this software dedicate any and all copyright interest in the
  software to the public domain. We make this dedication for the benefit
  of the public at large and to the detriment of our heirs and
  successors. We intend this dedication to be an overt act of
  relinquishment in perpetuity of all present and future rights to this
  software under copyright law.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
  For more information, please refer to <http:unlicense.org>
 for endian.h 
 Descriptors and Strings 
 en-us 
 Buffer structure 
 Endpoints handling 
 "ep#"  + 1 
 open endpoint files 
 setup aio context to handle up to AIO_MAX requests 
 we are waiting for function ENABLE 
		
		  when we're preparing new data to submit,
		  second buffer being transmitted
 prepare requests 
 enable eventfd notification 
 submit table of requests 
 if event is ready to read 
 we read aio events 
 if we got events 
 if all req's from iocb completed 
 free resources 
  This is free and unencumbered software released into the public domain.
  Anyone is free to copy, modify, publish, use, compile, sell, or
  distribute this software, either in source code form or as a compiled
  binary, for any purpose, commercial or non-commercial, and by any
  means.
  In jurisdictions that recognize copyright laws, the author or authors
  of this software dedicate any and all copyright interest in the
  software to the public domain. We make this dedication for the benefit
  of the public at large and to the detriment of our heirs and
  successors. We intend this dedication to be an overt act of
  relinquishment in perpetuity of all present and future rights to this
  software under copyright law.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
  For more information, please refer to <http:unlicense.org>
  struct test_state - describes test program state
  @list: list of devices returned by libusb_get_device_list function
  @found: pointer to struct describing tested device
  @ctx: context, set to NULL
  @handle: handle of tested device
  @attached: indicates that device was attached to kernel, and has to be
             reattached at the end of test program
  test_init - initialize test program
  test_exit - cleanup test program
  This is free and unencumbered software released into the public domain.
  Anyone is free to copy, modify, publish, use, compile, sell, or
  distribute this software, either in source code form or as a compiled
  binary, for any purpose, commercial or non-commercial, and by any
  means.
  In jurisdictions that recognize copyright laws, the author or authors
  of this software dedicate any and all copyright interest in the
  software to the public domain. We make this dedication for the benefit
  of the public at large and to the detriment of our heirs and
  successors. We intend this dedication to be an overt act of
  relinquishment in perpetuity of all present and future rights to this
  software under copyright law.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
  For more information, please refer to <http:unlicense.org>
 for endian.h 
 Descriptors and Strings 
 en-us 
 Endpoints handling 
 "ep#"  + 1 
 open endpoint files 
 setup aio context to handle up to 2 requests 
 alloc buffers and requests 
 we are waiting for function ENABLE 
 if something was submitted we wait for event 
 we wait for one event 
 if we got event 
 if IN transfer not requested
 prepare write request 
 enable eventfd notification 
 submit table of requests 
 if ret > 0 request is queued 
 if OUT transfer not requested 
 prepare read request 
 enable eventfs notification 
 submit table of requests 
 if ret > 0 request is queued 
 free resources 
 SPDX-License-Identifier: GPL-2.0
  cgroup_event_listener.c - Simple listener of cgroup events
  Copyright (C) Kirill A. Shutemov <kirill@shutemov.name>
  An implementation of key value pair (KVP) functionality for Linux.
  Copyright (C) 2010, Novell, Inc.
  Author : K. Y. Srinivasan <ksrinivasan@novell.com>
  This program is free software; you can redistribute it andor modify it
  under the terms of the GNU General Public License version 2 as published
  by the Free Software Foundation.
  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
  NON INFRINGEMENT.  See the GNU General Public License for more
  details.
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  KVP protocol: The user mode component first registers with the
  the kernel component. Subsequently, the kernel component requests, data
  for the specified keys. In response to this message the user mode component
  fills in the value corresponding to the specified key. We overload the
  sequence field in the cn_msg header to define our KVP message types.
  We use this infrastructure for also supporting queries from user mode
  application for state that may be maintained in the KVP kernel component.
This key is serviced in the kernel
  The location of the interface configuration file.
	
	  We are going to write our in-memory registry out to
	  disk; acquire the lock first.
			
			  We have more data to read.
 rwxr-xr-x )) {
 rw-r--r-- );
	
	  First update the in-memory state.
		
		  Found a match; just move the remaining
		  entries up.
	
	  First update the in-memory state.
		
		  Found a match; just update the value -
		  this is the modify case.
	
	  Need to add a new entry;
 Need to allocate a larger array for reg entries. 
	
	  First update the in-memory state.
		
		  Found a match; just copy the value out.
	
	  First update our in-memory database.
	
	  The current windows host (win7) expects the build
	  string to be of the form: x.y.z
	  Strip additional information we may have.
	
	  Parse the etcos-release file if present:
	  https:www.freedesktop.orgsoftwaresystemdmanos-release.html
 Ignore comments 
 Split into name=value 
 Remove quotes and newline; un-escape 
 Fallback for older RHSUSE releases 
	
	  We don't have information about the os.
 up to three lines 
 second line 
 third line 
  Retrieve an interface name corresponding to the specified guid.
  If there is a match, the function returns a pointer
  to the interface name and if not, a NULL is returned.
  If a match is found, the caller is responsible for
  freeing the memory.
		
		  Set the state for the next pass.
				
				  Found the guid match; return the interface
				  name. The caller will free the memory.
  Retrieve the MAC address given the interface name.
	
	  First execute the command.
	
	  Get the address of default gateway (ipv4).
	
	  Execute the command to gather gateway info.
	
	  Get the address of default gateway (ipv6).
	
	  Execute the command to gather gateway info (ipv6).
	
	  Gather the DNS state.
	  Since there is no standard way to get this information
	  across various distributions of interest; we just invoke
	  an external script that needs to be ported across distros
	  of interest.
	 
	  Following is the expected format of the information from the script:
	 
	  ipaddr1 (nameserver1)
	  ipaddr2 (nameserver2)
	  .
	  .
	
	  Execute the command to gather DNS info.
	
	  Gather the DHCP state.
	  We will gather this state by invoking an external script.
	  The parameter to the script is the interface name.
	  Here is the expected output:
	 
	  Enabled: DHCP enabled.
 xyz 
	
	  On entry into this function, the buffer is capable of holding the
	  maximum key value.
			
			  We want info about a specific interface;
			  just continue.
		
		  We only support two address families: AF_INET and AF_INET6.
		  If a family value of 0 is specified, we collect both
		  supported address families; if not we gather info on
		  the specified address family.
			
			  Gather info other than the IP address.
			  IP address info will be gathered later.
				
				  Get subnet info.
				
				  Get subnet info in CIDR format.
			
			  Collect other ip related configuration info.
  Retrieve the IP given the MAC address.
		
		  Set the state for the next pass.
		
		  Found the MAC match.
		  A NIC (e.g. VF) matching the MAC, but without IP, is skipped.
	
	  in_buf has sequence of characters that are separated by
	  the character ';'. The last sequence does not have the
	  terminating ";" character.
		
		  Get rid of leading spaces.
	
	  Set the configuration for the specified interface with
	  the information provided. Since there is no standard
	  way to configure an interface, we will have an external
	  script that does the job of configuring the interface and
	  flushing the configuration.
	 
	  The parameters passed to this external script are:
	  1. A configuration file that has the specified configuration.
	 
	  We will embed the name of the interface in the configuration
	  file: ifcfg-ethx (where ethx is the interface name).
	 
	  The information provided here may be more than what is needed
	  in a given distro to configure the interface and so are free
	  ignore information that may not be relevant.
	 
	  Here is the format of the ip configuration file:
	 
	  HWADDR=macaddr
	  DEVICE=interface name
	  BOOTPROTO=<protocol> (where <protocol> is "dhcp" if DHCP is configured
	                        or "none" if no boot-time protocol should be used)
	 
	  IPADDR0=ipaddr1
	  IPADDR1=ipaddr2
	  IPADDRx=ipaddry (where y = x + 1)
	 
	  NETMASK0=netmask1
	  NETMASKx=netmasky (where y = x + 1)
	 
	  GATEWAY=ipaddr1
	  GATEWAYx=ipaddry (where y = x + 1)
	 
	  DNSx=ipaddrx (where first DNS address is tagged as DNS1 etc)
	 
	  IPV6 addresses will be tagged as IPV6ADDR, IPV6 gateway will be
	  tagged as IPV6_DEFAULTGW and IPV6 NETMASK will be tagged as
	  IPV6NETMASK.
	 
	  The host can specify multiple ipv4 and ipv6 addresses to be
	  configured for the interface. Furthermore, the configuration
	  needs to be persistent. A subsequent GET call on the interface
	  is expected to return the configuration that is set via the SET
	  call.
	
	  First write out the MAC address.
	
	  The dhcp_enabled flag is only for IPv4. In the case the host only
	  injects an IPv6 address, the flag is true, but we still need to
	  proceed to parse and pass the IPv6 information to the
	  disto-specific script hv_set_ifconfig.
	
	  Write the configuration for ipaddress, netmask, gateway and
	  name servers.
	
	  Now that we have populated the configuration file,
	  invoke the external script to do its magic.
	
	  This is a little overcautious, but it's necessary to suppress some
	  false warnings from gcc 8.0.1.
Get only ipv4 addrinfo. 
	
	  Retrieve OS release information.
	
	  Cache Fully Qualified Domain Name because getaddrinfo takes an
	  unpredictable amount of time to finish.
	
	  Register ourselves with the kernel.
		
		  We will use the KVP header information to pass back
		  the error from this daemon. So, first copy the state
		  and set the error code to success.
			
			  Driver is registering with us; stash away the version
			  information.
				
				  We could not map the guid to an
				  interface name; return error.
		
		  If the pool is KVP_POOL_AUTO, dynamically generate
		  both the key and the value; if not read from the
		  appropriate pool.
		
		  Send the value back to the kernel. Note: the write() may
		  return an error due to hibernation; we can ignore the error
		  by resetting the dev file, i.e. closing and re-opening it.
 SPDX-License-Identifier: GPL-2.0-only
  An implementation of the host initiated guest snapshot for Hyper-V.
  Copyright (C) 2013, Microsoft, Inc.
  Author : K. Y. Srinivasan <kys@microsoft.com>
 Don't use syslog() in the function since that can cause write to disk 
	
	  If a partition is mounted more than once, only the first
	  FREEZETHAW can succeed and the later ones will get
	  EBUSYEINVAL respectively: there could be 2 cases:
	  1) a user may mount the same partition to different directories
	   by mistake or on purpose;
	  2) The subvolume of btrfs appears to have the same partition
	  mounted more than once.
 sysdevblockXXX:XXX 
 Call syslog after we thaw all filesystems 
	
	  Register ourselves with the kernel.
		
		  The write() may return an error due to the faked VSS_OP_THAW
		  message upon hibernation. Ignore the error by resetting the
		  dev file, i.e. closing and re-opening it.
 SPDX-License-Identifier: GPL-2.0-only
  An implementation of host to guest copy functionality for Linux.
  Copyright (C) 2014, Microsoft, Inc.
  Author : K. Y. Srinivasan <kys@microsoft.com>
	
	  Check to see if the path is already in place; if not,
	  create if required.
  Reset target_fname to "" in the two below functions for hibernation: if
  the fcopy operation is aborted by hibernation, the daemon should remove the
  partially-copied file; to achieve this, the hv_utils driver always fakes a
  CANCEL_FCOPY message upon suspend, and later when the VM resumes back,
  the daemon calls hv_copy_cancel() to remove the file; if a file is copied
  successfully before suspend, hv_copy_finished() must reset target_fname to
  avoid that the file can be incorrectly removed upon resume, since the faked
  CANCEL_FCOPY message is spurious in this case.
 Remove any possible partially-copied file on error 
	
	  Register with the kernel.
		
		  In this loop we process fcopy messages after the
		  handshake is complete.
		
		  pwrite() may return an error due to the faked CANCEL_FCOPY
		  message upon hibernation. Ignore the error by resetting the
		  dev file, i.e. closing and re-opening it.
 SPDX-License-Identifier: GPL-2.0
  User-space helper to sort the output of syskerneldebugpage_owner
  Example use:
  cat syskerneldebugpage_owner > page_owner_full.txt
  .page_owner_sort page_owner_full.txt sorted_page_owner.txt
  Or sort by total memory:
  .page_owner_sort -m page_owner_full.txt sorted_page_owner.txt
  See Documentationvmpage_owner.rst
 empty line 
 EOF or no space left in buf. 
 max_order should not exceed 2 digits 
 hack ... 
 SPDX-License-Identifier: GPL-2.0
  Slabinfo: Tool to get reports about slabs
  (C) 2007 sgi, Christoph Lameter
  (C) 2011 Linux Foundation, Christoph Lameter
  Compile with:
  gcc -o slabinfo slabinfo.c
 Debug options 
  Get the contents of an attribute
  Put a size string together
  Find the shortest alias of a slab
  Analyze debug options. Return false if something is amiss.
	
	  We may still have slabs even if there are no objects. Shrinking will
	  remove them.
 Object size 
 Number of partial slabs in a slabcache 
 Number of slabs in a slab cache 
 Size of the whole slab 
 Bytes used for object storage in a slab 
 Waste: Bytes used for alignment and padding 
 Number of objects in a slab 
 Waste per object 
 Memory per object 
 Percentage of partial slabs per slab 
 Number of objects in partial slabs 
 Percentage of partial objects of all objects in a slab 
 Per slab averages 
 Per object object sizes 
 SPDX-License-Identifier: GPL-2.0-only
  page-types: Tool for querying page flags
  Copyright (C) 2009 Intel corporation
  Authors: Wu Fengguang <fengguang.wu@intel.com>
  pagemap kernel ABI bits
  kernel page flags
 [32-] kernel hacking assistances 
 [48-] take some arbitrary free slots for expanding overloaded flags
  not part of kernel API
  data structures
 for kernel developers 
 list pages (in ranges) 
 set accessed bit 
 don't show summary 
 process to walk 
 file or directory path 
 cgroup inode 
 list page cgroup 
 list page map count 
 kpageflags file to parse 
  helper functions
  pagemapkpageflags routines
  page flag names
  page list and summary
  page flag filters
 SLOBSLUB overload several page flags 
 PG_reclaim is overloaded as PG_readahead in the read path 
 hide flags intended only for kernel hacker 
 hide non-hugeTLB compound pages 
  page actions
  page frame walker
	 Explicitly reserve slot 0 for flags 0: the following logic
	  cannot distinguish an unoccupied slot from slot (flags==0).
 search through the remaining (HASH_SIZE-1) slots 
 64k pages 
	
	  kpagecgroup_read() reads only if kpagecgroup were opened, but
	  prockpagecgroup might even not exist, so it's better to fill
	  them with zeros here.
  user interface
 determine cached pages 
 turn off readahead 
 populate ptes 
 turn off harvesting reference bits 
 do not follow symlinks and mountpoints 
 SPDX-License-Identifier: GPL-2.0-or-later
 bit search implementation
  Copied from libfind_bit.c to toolslibfind_bit.c
  Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.
  Written by David Howells (dhowells@redhat.com)
  Copyright (C) 2008 IBM Corporation
  'find_last_bit' is written by Rusty Russell <rusty@rustcorp.com.au>
  (Inspired by David Howell's find_next_bit implementation)
  Rewritten by Yury Norov <yury.norov@gmail.com> to decrease
  size and improve performance, 2015.
  This is a common helper function for find_next_bit, find_next_zero_bit, and
  find_next_and_bit. The differences are:
   - The "invert" argument, which is XORed with each fetched word before
     searching it for one bits.
   - The optional "addr2", which is anded with "addr1" if present.
 Handle 1st word. 
	
	  Due to the lack of swab() in tools, and the fact that it doesn't
	  need little-endian support, just comment it out
  Find the first set bit in a memory region.
  Find the first cleared bit in a memory region.
 SPDX-License-Identifier: GPL-2.0
  The tools so far have been using the strerror_r() GNU variant, that returns
  a string, be it the buffer passed or something else.
  But that, besides being tricky in cases where we expect that the function
  using strerror_r() returns the error formatted in a provided buffer (we have
  to check if it returned something else and copy that instead), breaks the
  build on systems not using glibc, like Alpine Linux, where musl libc is
  used.
  So, introduce yet another wrapper, str_error_r(), that has the GNU
  interface, but uses the portable XSI variant of strerror_r(), so that users
  rest asured that the provided buffer is used and it is what is returned.
 SPDX-License-Identifier: GPL-2.0
   linuxlibctype.c
   Copyright (C) 1991, 1992  Linus Torvalds
 0-7 
 8-15 
 16-23 
 24-31 
 32-39 
 40-47 
 48-55 
 56-63 
 64-71 
 72-79 
 80-87 
 88-95 
 96-103 
 104-111 
 112-119 
 120-127 
 128-143 
 144-159 
 160-175 
 176-191 
 192-207 
 208-223 
 224-239 
 240-255 
 SPDX-License-Identifier: GPL-2.0
  hweightN - returns the hamming weight of a N-bit word
  @x: the word to weigh
  The Hamming Weight of a number is the total number of bits set in it.
 SPDX-License-Identifier: GPL-2.0-or-later
  Red Black Trees
  (C) 1999  Andrea Arcangeli <andrea@suse.de>
  (C) 2002  David Woodhouse <dwmw2@infradead.org>
  (C) 2012  Michel Lespinasse <walken@google.com>
  linuxlibrbtree.c
  red-black trees properties:  https:en.wikipedia.orgwikiRbtree
   1) A node is either red or black
   2) The root is black
   3) All leaves (NULL) are black
   4) Both children of every red node are black
   5) Every simple path from root to leaves contains the same number
      of black nodes.
   4 and 5 give the O(log n) guarantee, since 4 implies you cannot have two
   consecutive red nodes in a path and every red node is therefore followed by
   a black. So if B is the number of black nodes on every simple path (as per
   5), then the longest possible path due to 4 is 2B.
   We shall indicate color with case, where black nodes are uppercase and red
   nodes will be lowercase. Unknown color nodes shall be drawn as red within
   parentheses and have some accompanying text comment.
  Notes on lockless lookups:
  All stores to the tree structure (rb_left and rb_right) must be done using
  WRITE_ONCE(). And we must not inadvertently cause (temporary) loops in the
  tree structure as seen in program order.
  These two requirements will allow lockless iteration of the tree -- not
  correct iteration mind you, tree rotations are not atomic so a lookup might
  miss entire subtrees.
  But they do guarantee that any such traversal will only see valid elements
  and that it will indeed complete -- does not get stuck in a loop.
  It also guarantees that if the lookup returns an element it is the 'correct'
  one. But not returning an element does _NOT_ mean it's not present.
  NOTE:
  Stores to __rb_parent_color are not important for simple lookups so those
  are left undone as of now. Nor did I check for loops involving parent
  pointers.
  Helper function for rotations:
  - old's parent and color get assigned to new
  - old gets assigned new as a parent and 'color' as a color.
		
		  Loop invariant: node is red.
			
			  The inserted node is root. Either this is the
			  first node, or we recursed at Case 1 below and
			  are no longer violating 4).
		
		  If there is a black parent, we are done.
		  Otherwise, take some corrective action as,
		  per 4), we don't want a red root or two
		  consecutive red nodes.
 parent == gparent->rb_left 
				
				  Case 1 - node's uncle is red (color flips).
				 
				        G            g
				        \           \
				      p   u  -->   P   U
				                 
				    n            n
				 
				  However, since g's parent might be red, and
				  4) does not allow this, we need to recurse
				  at g.
				
				  Case 2 - node's uncle is black and node is
				  the parent's right child (left rotate at parent).
				 
				       G             G
				       \            \
				     p   U  -->    n   U
				      \           
				       n         p
				 
				  This still leaves us in violation of 4), the
				  continuation into Case 3 will fix that.
			
			  Case 3 - node's uncle is black and node is
			  the parent's left child (right rotate at gparent).
			 
			         G           P
			         \          \
			       p   U  -->  n   g
			                       \
			     n                   U
 == parent->rb_right 
 Case 1 - color flips 
 Case 2 - right rotate at parent 
 Case 3 - left rotate at gparent 
 == parent->rb_left 
  Inline version for rb_erase() use - we want to be able to inline
  and eliminate the dummy_rotate callback there
		
		  Loop invariants:
		  - node is black (or NULL on first iteration)
		  - node is not the root (parent is not NULL)
		  - All leaf paths going through parent and node have a
		    black node count that is 1 lower than other leaf paths.
 node == parent->rb_left 
				
				  Case 1 - left rotate at parent
				 
				      P               S
				      \              \
				    N   s    -->    p   Sr
				        \          \
				      Sl  Sr      N   Sl
					
					  Case 2 - sibling color flip
					  (p could be either color here)
					 
					     (p)           (p)
					      \            \
					    N   S    -->  N   s
					        \            \
					      Sl  Sr        Sl  Sr
					 
					  This leaves us violating 5) which
					  can be fixed by flipping p to black
					  if it was red, or by recursing at p.
					  p is red when coming from Case 1.
				
				  Case 3 - right rotate at sibling
				  (p could be either color here)
				 
				    (p)           (p)
				     \            \
				   N   S    -->  N   sl
				       \             \
				     sl  Sr            S
				                        \
				                         Sr
				 
				  Note: p might be red, and then both
				  p and sl are red after rotation(which
				  breaks property 4). This is fixed in
				  Case 4 (in __rb_rotate_set_parents()
				          which set sl the color of p
				          and set p RB_BLACK)
				 
				    (p)            (sl)
				     \              \
				   N   sl   -->   P    S
				        \              \
				         S      N        Sr
				          \
				           Sr
			
			  Case 4 - left rotate at parent + color flips
			  (p and sl could be either color here.
			   After rotation, p becomes black, s acquires
			   p's color, and sl keeps its color)
			 
			       (p)             (s)
			        \              \
			      N   S     -->   P   Sr
			          \          \
			       (sl) sr      N  (sl)
 Case 1 - right rotate at parent 
 Case 2 - sibling color flip 
 Case 3 - left rotate at sibling 
 Case 4 - right rotate at parent + color flips 
 Non-inline version for rb_erase_augmented() use 
  Non-augmented rbtree manipulation functions.
  We use dummy augmented callbacks here, and have the compiler optimize them
  out of the rb_insert_color() and rb_erase() function definitions.
  Augmented rbtree manipulation functions.
  This instantiates the same __always_inline functions as in the non-augmented
  case, but this time with user-defined callbacks.
  This function returns the first node (in sort order) of the tree.
	
	  If we have a right-hand child, go down and then left as far
	  as we can.
	
	  No right-hand children. Everything down and left is smaller than us,
	  so any 'next' node must be in the general direction of our parent.
	  Go up the tree; any time the ancestor is a right-hand child of its
	  parent, keep going up. First time it's a left-hand child of its
	  parent, said parent is our 'next' node.
	
	  If we have a left-hand child, go down and then right as far
	  as we can.
	
	  No left-hand children. Go up till we find an ancestor which
	  is a right-hand child of its parent.
 Copy the pointerscolour from the victim to the replacement 
 Set the surrounding nodes to point to the replacement 
 If we're sitting on node, we've already seen our children 
		 If we are the parent's left node, go to the parent's right
		 Otherwise we are the parent's right node, and the parent
 SPDX-License-Identifier: GPL-2.0
   linuxtoolslibstring.c
   Copied from linuxlibstring.c, where it is:
   Copyright (C) 1991, 1992  Linus Torvalds
   More specifically, the first copied function was strtobool, which
   was introduced by:
   d0f1fed29e6e ("Add a strtobool function matching semantics of existing in kernel equivalents")
   Author: Jonathan Cameron <jic23@cam.ac.uk>
  memdup - duplicate region of memory
  @src: memory region to duplicate
  @len: memory region length
  strtobool - convert common user inputs into boolean values
  @s: input string
  @res: result
  This routine returns 0 iff the first character is one of 'Yy1Nn0', or
  [oO][NnFf] for "on" and "off". Otherwise it will return -EINVAL.  Value
  pointed to by res is updated upon finding a match.
  strlcpy - Copy a C-string into a sized buffer
  @dest: Where to copy the string to
  @src: Where to copy the string from
  @size: size of destination buffer
  Compatible with BSD: the result is always a valid
  NUL-terminated string that fits in the buffer (unless,
  of course, the buffer size is zero). It does not pad
  out the result like strncpy() does.
  If libc has strlcpy() then that version will override this
  implementation:
  skip_spaces - Removes leading whitespace from @str.
  @str: The string to be stripped.
  Returns a pointer to the first non-whitespace character in @str.
  strim - Removes leading and trailing whitespace from @s.
  @s: The string to be stripped.
  Note that the first trailing whitespace is replaced with a %NUL-terminator
  in the given string @s. Returns a pointer to the first non-whitespace
  character in @s.
  strreplace - Replace all occurrences of character in string.
  @s: The string to operate on.
  @old: The character being replaced.
  @new: The character @old is replaced with.
  Returns pointer to the nul byte at the end of @s.
  memchr_inv - Find an unmatching character in an area of memory.
  @start: The memory area
  @c: Find a character other than c
  @bytes: The size of the area.
  returns the address of the first character other than @c, or %NULL
  if the whole buffer contains just @c.
 SPDX-License-Identifier: GPL-2.0
  Returns a list organized in an intermediate format suited
  to chaining of merge() calls: null-terminated, no reserved or
  sentinel head node, "prev" links not maintained.
 if equal, take 'a' -- important for sort stability 
  Combine final list merge with restoration of standard doubly-linked
  list structure.  This approach duplicates code from merge(), but
  runs faster than the tidier alternatives of either a separate final
  prev-link restoration pass, or maintaining the prev links
  throughout.
 if equal, take 'a' -- important for sort stability 
 Finish linking remainder of list b on to tail 
		
		  If the merge is highly unbalanced (e.g. the input is
		  already sorted), this loop may run many iterations.
		  Continue callbacks to the client even though no
		  element comparison is needed, so the client's cmp()
		  routine can invoke cond_resched() periodically.
 And the final links to make a circular doubly-linked list 
  list_sort - sort a list
  @priv: private data, opaque to list_sort(), passed to @cmp
  @head: the list to sort
  @cmp: the elements comparison function
  The comparison function @cmp must return > 0 if @a should sort after
  @b ("@a > @b" if you want an ascending sort), and <= 0 if @a should
  sort before @b or their original order should be preserved.  It is
  always called with the element that came first in the input in @a,
  and list_sort is a stable sort, so it is not necessary to distinguish
  the @a < @b and @a == @b cases.
  This is compatible with two styles of @cmp function:
  - The traditional style which returns <0  =0  >0, or
  - Returning a boolean 01.
  The latter offers a chance to save a few cycles in the comparison
  (which is used by e.g. plug_ctx_cmp() in blockblk-mq.c).
  A good way to write a multi-word comparison is::
 	if (a->high != b->high)
 		return a->high > b->high;
 	if (a->middle != b->middle)
 		return a->middle > b->middle;
 	return a->low > b->low;
  This mergesort is as eager as possible while always performing at least
  2:1 balanced merges.  Given two pending sublists of size 2^k, they are
  merged to a size-2^(k+1) list as soon as we have 2^k following elements.
  Thus, it will avoid cache thrashing as long as 32^k elements can
  fit into the cache.  Not quite as good as a fully-eager bottom-up
  mergesort, but it does use 0.2n fewer comparisons, so is faster in
  the common case that everything fits into L1.
  The merging is controlled by "count", the number of elements in the
  pending lists.  This is beautifully simple code, but rather subtle.
  Each time we increment "count", we set one bit (bit k) and clear
  bits k-1 .. 0.  Each time this happens (except the very first time
  for each bit, when count increments to 2^k), we merge two lists of
  size 2^k into one list of size 2^(k+1).
  This merge happens exactly when the count reaches an odd multiple of
  2^k, which is when we have 2^k elements pending in smaller lists,
  so it's safe to merge away two lists of size 2^k.
  After this happens twice, we have created two lists of size 2^(k+1),
  which will be merged into a list of size 2^(k+2) before we create
  a third list of size 2^(k+1), so there are never more than two pending.
  The number of pending lists of size 2^k is determined by the
  state of bit k of "count" plus two extra pieces of information:
  - The state of bit k-1 (when k == 0, consider bit -1 always set), and
  - Whether the higher-order bits are zero or non-zero (i.e.
    is count >= 2^(k+1)).
  There are six states we distinguish.  "x" represents some arbitrary
  bits, and "y" represents some arbitrary non-zero bits:
  0:  00x: 0 pending of size 2^k;           x pending of sizes < 2^k
  1:  01x: 0 pending of size 2^k; 2^(k-1) + x pending of sizes < 2^k
  2: x10x: 0 pending of size 2^k; 2^k     + x pending of sizes < 2^k
  3: x11x: 1 pending of size 2^k; 2^(k-1) + x pending of sizes < 2^k
  4: y00x: 1 pending of size 2^k; 2^k     + x pending of sizes < 2^k
  5: y01x: 2 pending of size 2^k; 2^(k-1) + x pending of sizes < 2^k
  (merge and loop back to state 2)
  We gain lists of size 2^k in the 2->3 and 4->5 transitions (because
  bit k-1 is set while the more significant bits are non-zero) and
  merge them away in the 5->2 transition.  Note in particular that just
  before the 5->2 transition, all lower-order bits are 11 (state 3),
  so there is one list of each smaller size.
  When we reach the end of the input, we merge all the pending
  lists, from smallest to largest.  If you work through cases 2 to
  5 above, you can see that the number of elements we merge with a list
  of size 2^k varies from 2^(k-1) (cases 3 and 5 when x == 0) to
  2^(k+1) - 1 (second merge of case 5 when x == 2^(k-1) - 1).
 Count of pending 
 Zero or one elements 
 Convert to a null-terminated singly-linked list. 
	
	  Data structure invariants:
	  - All lists are singly linked and null-terminated; prev
	    pointers are not maintained.
	  - pending is a prev-linked "list of lists" of sorted
	    sublists awaiting further merging.
	  - Each of the sorted sublists is power-of-two in size.
	  - Sublists are sorted by size and age, smallest & newest at front.
	  - There are zero to two sublists of each size.
	  - A pair of pending sublists are merged as soon as the number
	    of following pending elements equals their size (i.e.
	    each time count reaches an odd multiple of that size).
	    That ensures each later final merge will be at worst 2:1.
	  - Each round consists of:
	    - Merging the two sublists selected by the highest bit
	      which flips when count is incremented, and
	    - Adding an element from the input as a size-1 sublist.
 Find the least-significant clear bit in count 
 Do the indicated merge 
 Install the merged result in place of the inputs 
 Move one element from input list to pending 
 End of input; merge together all the pending lists. 
 The final merge, rebuilding prev links 
 SPDX-License-Identifier: GPL-2.0
  Helper function for splitting a string into an argv-like array.
  argv_free - free an argv
  @argv - the argument vector to be freed
  Frees an argv and the strings it points to.
  argv_split - split a string at whitespace, returning an argv
  @str: the string to be split
  @argcp: returned argument count
  Returns an array of pointers to strings which are split out from
  @str.  This is performed by strictly splitting on white-space; no
  quote processing is performed.  Multiple whitespace characters are
  considered to be a single argument separator.  The returned array
  is always NULL-terminated.  Returns NULL on memory allocation
  failure.
 SPDX-License-Identifier: GPL-2.0-only
  From libbitmap.c
  Helper functions for bitmap.h.
 current bit is 'cur', most recently seen range is [rbot, rtop] 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: LGPL-2.1
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2010 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>
 If token is = or ! check to see if the next char is ~ 
 append it 
 Now remove the '~' from the buffer 
  tep_filter_alloc - create a new event filter
  @tep: The tep that this filter is associated with
 if no name is given, then swap sys and name 
 if it is a number, then convert it 
 Consider this a field 
 If token is 'COMM' or 'CPU' then it is special 
 not a field, Make it false 
 Use NUM and change if necessary 
		
		  The arg must be num, str, or field
		
		  Depending on the type, we may need to
		  convert this to a string or regex.
			
			  A char should be converted to number if
			  the string is 1 byte, and the compare
			  is not a REGEX.
 fall through 
 convert op to a string arg 
 reset the op for the new field 
			
			  If left arg was a field not found then
			  NULL the entire op.
 Left arg must be a field 
 Make sure this is a valid string compare 
			
			  Need a buffer to copy data for tests
 Null terminate this buffer 
 We no longer have left or right args 
 numeric compare 
 left arg of compares must be a field 
 Check for value expressions 
 Check for compares 
 A string conversion is always done 
 field not found, is ok 
 Get the sibling 
 Detach arg from old_child 
 Check for root 
 Free arg without recussion 
 Returns either filter_vals (success) or tep_errno (failfure) 
 bad case 
 good cases: 
 Remove any unknown event fields 
 test_arg() already set the error_str 
 Not's only one one expression 
 A not wants just one expression 
 ')' 
 Make sure everything is finished at this level 
 All expect a left arg except for NOT 
 Logic ops need a left expression 
 fall through 
 logic only processes ops and exp 
 collapse_tree() may free current_op, and updates parg accordingly 
 If parg is NULL, then make it into FALSE 
 just add a TRUE arg 
 clear buffer to reset show error 
  tep_filter_add_filter_str - add a new filter
  @filter: the event filter to add to
  @filter_str: the filter string that contains the filter
  Returns 0 if the filter was successfully added or a
  negative error code.  Use tep_filter_strerror() to see
  actual error message in case of error.
 TEP_ERRNO__SUCCESS 
 This can only happen when events is NULL, but still 
 This can only happen when events is NULL, but still 
 Find this event 
 Skip the ':' 
 filter starts here 
 Failures are returned if a parse error happened 
  tep_filter_strerror - fill error message in a buffer
  @filter: the event filter contains error
  @err: the error code
  @buf: the buffer to be filled in
  @buflen: the size of the buffer
  Returns 0 if message was filled successfully, -1 if error
  tep_filter_remove_event - remove a filter for an event
  @filter: the event filter to remove from
  @event_id: the event to remove a filter for
  Removes the filter saved for an event defined by @event_id
  from the @filter.
  Returns 1: if an event was removed
    0: if the event was not found
 The filter_type points into the event_filters array 
  tep_filter_reset - clear all filters in a filter
  @filter: the event filter to reset
  Removes all filters from a filter and resets it.
 Can't assume that the tep's are the same 
 Add trivial event 
  tep_filter_copy - copy a filter using another filter
  @dest - the filter to copy to
  @source - the filter to copy from
  Returns 0 on success and -1 if not all filters were copied
 Handle our dummy "comm" field 
 Handle our dummy "cpu" field 
		
		  There was an error, no need to process anymore.
		
		  There was an error, no need to process anymore.
 If the field is not a string convert it 
		
		  We need to copy the data since we can't be sure the field
		  is null terminated.
 copy it 
 the buffer is already NULL terminated 
 convert to a kernel symbol 
 just use the hex of the string name 
 Returns zero on match 
		
		  There was an error, no need to process anymore.
 easy case 
		
		  Expressions, fields and values evaluate
		  to true if they return non zero
  tep_event_filtered - return true if event has filter
  @filter: filter struct with filter information
  @event_id: event id to test if filter exists
  Returns 1 if filter found for @event_id
    otherwise 0;
  tep_filter_match - test if a record matches a filter
  @filter: filter struct with filter information
  @record: the record to test against the filter
  Returns: match result or error code (prefixed with TEP_ERRNO__)
  FILTER_MATCH - filter found for event and @record matches
  FILTER_MISS  - filter found for event and @record does not match
  FILTER_NOT_FOUND - no filter found for @record's event
  NO_FILTER - if no filters exist
  otherwise - error occurred during test
 fall through 
 Try to consolidate boolean values 
 Just return left value 
 just evaluate this. 
 Just return right value 
 The right value is meaningless 
 See if we can consolidate 
 just return the opposite 
 ?? 
 fall through 
 fall through 
 fall through 
 fall through 
 fall through 
 ?? 
 fall through 
 fall through 
 fall through 
 ?? 
 ?? 
  tep_filter_make_string - return a string showing the filter
  @filter: filter struct with filter information
  @event_id: the event id to return the filter string with
  Returns a string that displays the filter contents.
   This string must be freed with free(str).
   NULL is returned if no filter is found or allocation failed.
  tep_filter_compare - compare two filters and return if they are the same
  @filter1: Filter to compare with @filter2
  @filter2: Filter to compare with @filter1
  Returns:
   1 if the two filters hold the same content.
   0 if they do not.
 Do the easy checks first 
	
	  Now take a look at each of the events to see if they have the same
	  filters to them.
 The best way to compare complex filters is with strings 
 bail out if allocation fails 
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2009, 2010 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>
   The parts for function graph printing was taken and modified from the
   Linux Kernel that were written by
     - Copyright (C) 2009  Frederic Weisbecker,
   Frederic Weisbecker gave his permission to relicense the code to
   the Lesser General Public License.
  init_input_buf - init buffer for parsing
  @buf: buffer to parse
  @size: the size of the buffer
  Initializes the internal buffer that tep_read_token() will parse.
 Looking for where to place the key 
  tep_is_pid_registered - return if a pid has a cmdline registered
  @tep: a handle to the trace event parser context
  @pid: The pid to check if it has a cmdline registered with.
  Returns true if the pid has a cmdline mapped to it
  false otherwise.
  If the command lines have been converted to an array, then
  we must add this pid. This is much slower than when cmdlines
  are added before the array is initialized.
 avoid duplicates 
 no entries yet 
 Now find where we want to store the new cmdline 
 cmdline points to the one before the spot we want 
 The new entry is either before or after the list 
  tep_register_comm - register a pid  comm mapping
  @tep: a handle to the trace event parser context
  @comm: the command line to register
  @pid: the pid to map the command line to
  This adds a mapping to search for command line names with
  a given pid. The comm is duplicated. If a command with the same pid
  already exist, -1 is returned and errno is set to EEXIST
  tep_override_comm - register a pid  comm mapping
  @tep: a handle to the trace event parser context
  @comm: the command line to register
  @pid: the pid to map the command line to
  This adds a mapping to search for command line names with
  a given pid. The comm is duplicated. If a command with the same pid
  already exist, the command string is udapted with the new one
  We are searching for a record in between, not an exact
  match.
	
	  Add a special record at the end.
  tep_set_function_resolver - set an alternative function resolver
  @tep: a handle to the trace event parser context
  @resolver: function to be used
  @priv: resolver function private state.
  Some tools may have already a way to resolve kernel functions, allow them to
  keep using it instead of duplicating all the entries inside tep->funclist.
  tep_reset_function_resolver - reset alternative function resolver
  @tep: a handle to the trace event parser context
  Stop using whatever alternative resolver was set, use the default
  one instead.
  tep_find_function - find a function by a given address
  @tep: a handle to the trace event parser context
  @addr: the address to find the function with
  Returns a pointer to the function stored that has the given
  address. Note, the address does not have to be exact, it
  will select the function that would contain the address.
  tep_find_function_address - find a function address by a given address
  @tep: a handle to the trace event parser context
  @addr: the address to find the function with
  Returns the address the function starts at. This can be used in
  conjunction with tep_find_function to print both the function
  name and the function offset.
  tep_register_function - register a function with a given address
  @tep: a handle to the trace event parser context
  @function: the function name to register
  @addr: the address the function starts at
  @mod: the kernel module the function may be in (NULL for none)
  This registers a function name with an address and module.
  The @func passed in is duplicated.
  tep_print_funcs - print out the stored functions
  @tep: a handle to the trace event parser context
  This prints out the stored functions.
  tep_register_print_string - register a string by its address
  @tep: a handle to the trace event parser context
  @fmt: the string format to register
  @addr: the address the string was located at
  This registers a string by the address it was stored in the kernel.
  The @fmt passed in is duplicated.
 Strip off quotes and '\n' from the end 
  tep_print_printk - print out the stored strings
  @tep: a handle to the trace event parser context
  This prints the string formats that were stored.
  peek_char - peek at the next character that will be read
  Returns the next character read, or -1 if end of buffer.
 fall through 
 what should we do instead? 
 don't keep quotes 
 the '\' '\' will cancel itself 
 remove the last quote 
		
		  For strings (double quotes) check the next token.
		  If it is another string, concatinate the two.
		
		  Older versions of the kernel has a bug that
		  creates invalid symbols and will break the mac80211
		  parsing. This is a work around to that bug.
		 
		  See Linux kernel commit:
		   811cb50baf63461ce0bdb234927046131fc7fa8b
 save off the current input pointers 
 reset back to original token 
  free_token - free a token returned by tep_read_token
  @token: the token to free
  read_token - access to utilities to use the tep parser
  @tok: The token to return
  This will parse tokens from the string given by
  tep_init_data().
  Returns the token type.
 not reached 
 no newline 
 not reached 
 includes long long 
 This covers all TEP_FIELD_IS_STRING types. 
		
		  The ftrace fields may still use the "special" name.
		  Just ignore it.
 read the rest of the type 
			    
			      Some of the ftrace fields are broken and have
			      an illegal "." in them.
 Handle __attribute__((user)) 
 We only care about the last token 
 add brackets to type 
			
			  If the next token is not an OP, then it is of
			  the format: type [] item;
 newer versions of the kernel have a "signed" type 
  For __print_symbolic() and __print_flags, we need to completely
  evaluate the first argument, which defines what to print next.
 arg will be freed at out_free 
 Handle other operations in the arguments 
 Top may point to itself 
 'tok' is set to top->op.op.  No need to free. 
 '>>' and '<<' are 8 
 '==' and '!=' are 10 
 single ops are the greatest 
 Note, tok does not get freed, but will most likely be saved 
 the op is passed in via tok 
 handle single op 
 make an empty left 
 do not free the token, it belongs to an op 
 copy the top arg to the left 
 it will set arg->op.right 
 copy the top arg to the left 
 arg->op.op (= token) will be freed at out_free 
 could just be a type pointer 
 token was freed in process_arg_token() via tok 
 rotate ops according to the priority 
 it will set arg->op.right 
 the arg is now the left side 
 higher prios need to be closer to the root 
 chop off the " " 
 check if this is a pointer 
 Try to figure out the arg size
 all bets off 
  Try to figure out the type.
 check for negative 
 Handle operations in the first argument 
	
	  The item within the parenthesis is another field that holds
	  the index into where the array starts.
 Find the field 
 Find the field 
	
	  If the next token is an item or another open paren, then
	  this was a typecast.
 make this a typecast and contine 
 prevous must be an atom 
 Handle __builtin_expect( cond, #) 
 We don't care what the second parameter is of the __builtin_expect() 
 test the next token 
		
		  If the next token is a parenthesis, then this
		  is a function.
 this will free atom. 
 atoms can be more than one token long 
 handle single ops 
 On error, the op is freed 
 return error type if errored 
 ok to have no arg 
 Handle concatenation of print lines 
  tep_find_common_field - return a common field by event
  @event: handle for the event
  @name: the name of the common field to return
  Returns a common field from the event by the given @name.
  This only searches the common fields and not all field.
  tep_find_field - find a non-common field
  @event: handle for the event
  @name: the name of the non-common field
  Returns a non-common field by the given @name.
  This does not search common fields.
  tep_find_any_field - find any field by name
  @event: handle for the event
  @name: the name of the field
  Returns a field by the given @name.
  This searches the common field names first, then
  the non-common ones if a common one was not found.
  tep_read_number - read a number from data
  @tep: a handle to the trace event parser context
  @ptr: the raw data
  @size: the size of the data that holds the number
  Returns the number (converted to host) from the
  raw data.
 BUG! 
  tep_read_number_field - read a number from data
  @field: a handle to the field
  @data: the raw data to read
  @value: the value to place the number in
  Reads raw data according to a field offset and size,
  and translates it into @value.
  Returns 0 on success, -1 otherwise.
	
	  All events should have the same common elements.
	  Pick any event to find where the type is;
  tep_find_event - find an event by given id
  @tep: a handle to the trace event parser context
  @id: the id of the event
  Returns an event that has a given @id.
 Check cache first 
  tep_find_event_by_name - find an event by given name
  @tep: a handle to the trace event parser context
  @sys: the system name to search for
  @name: the name of the event to search for
  This returns an event with a given @name and under the system
  @sys. If @sys is NULL the first event with @name is returned.
 ?? 
 must be a number 
			
			  Arrays are special, since we don't want
			  to read the arg as is.
 handle typecasts 
 Default to long size 
				
				  The actual length of the dynamic array is stored
				  in the top half of the field, and the offset
				  is in the bottom half of the 32 bit field.
 oops, all bets off 
		
		  The total allocated length of the dynamic array is
		  stored in the top half of the field, and the offset
		  is in the bottom half of the 32 bit field.
 Without [], we pass the address to the dynamic data 
		
		  The total allocated length of the dynamic array is
		  stored in the top half of the field, and the offset
		  is in the bottom half of the 32 bit field.
 not sure what to do there 
	
	  Some flags in the format files do not get converted.
	  If the flag is not numeric, see if it is something that
	  we already know about.
	
	  The kernel likes to put in commas every 32 bits, we
	  can do the same.
 Start out with -2 for the two chars per byte 
		
		  data points to a bit mask of size bytes.
		  In the kernel, this is an array of long words, thus
		  endianness is very important.
 ?? 
 Zero sized fields, mean the rest of the data 
		
		  Some events pass in pointers. If this is not an array
		  and the size is the same as long_size, assume that it
		  is a pointer.
			 Handle heterogeneous recording and processing
			  architectures
			 
			  CASE I:
			  Traces recorded on 32-bit devices (32-bit
			  addressing) and processed on 64-bit devices:
			  In this case, only 32 bits should be read.
			 
			  CASE II:
			  Traces recorded on 64 bit devices and processed
			  on 32-bit devices:
			  In this case, 64 bits must be read.
 Check if it matches a print format 
		
		  The only op for string should be ? :
 well... 
			
			  Something went totally wrong, this is not
			  an input error, something in this code broke.
 TBD : handle return type here 
	
	  The first arg is the IP pointer.
 skip the first "%ps: " 
 Check for special pointers 
						
						  Pre-5.5 kernels use %pf and
						  %pF for printing symbols
						  while kernels since 5.5 use
						  %pfw for fwnodes. So check
						  %p[fF] isn't followed by 'w'.
 fall through 
						
						  Older kernels do not process
						  dereferenced pointers.
						  Only process if the pointer
						  value is a printable.
 fall through 
 ? 
 fall through 
 the pointers are always 4 bytes aligned 
				
				  The '' case means that an arg is used as the length.
				  We need to continue to figure out for what.
 hnbl 
 fall through 
 find position of longest 0 run 
 don't compress a single 0 
 emit address 
 hex u16 without leading 0s 
  %pi4   print an IPv4 address with leading zeros
  %pI4   print an IPv4 address without leading zeros
  %pi6   print an IPv6 address without colons
  %pI6   print an IPv6 address with colons
  %pI6c  print an IPv6 address in compressed form with colons
  %pISpc print an IP address based on sockaddr; p adds port.
 pI6c 
 pISpc 
 'i' or 'I' 
 IP version 
 fall through 
 fall through 
				
				  If field is long then print it in hex.
				  A long usually stores pointers.
 Use helper trace_seq 
 [mM]R , [mM]F 
[S][pfs]
 fall through 
 [4S][hnbl] 
 fall through 
 [6S]c 
 FIXME: need to handle properly 
 The argument is the length. 
 should never happen 
 should never happen 
 make %l into %ll 
 should never happen 
  This parses out the Latency format (interrupts disabled,
  need rescheduling, in hardsoft interrupt, preempt count
  and lock depth) and places it into the trace_seq.
 lock_depth may not always exist 
 migrate_disable may not always exist 
  tep_data_type - parse out the given event type
  @tep: a handle to the trace event parser context
  @rec: the record to read from
  This returns the event id from the @rec.
  tep_data_pid - parse the PID from record
  @tep: a handle to the trace event parser context
  @rec: the record to parse
  This returns the PID from a record.
  tep_data_preempt_count - parse the preempt count from the record
  @tep: a handle to the trace event parser context
  @rec: the record to parse
  This returns the preempt count from a record.
  tep_data_flags - parse the latency flags from the record
  @tep: a handle to the trace event parser context
  @rec: the record to parse
  This returns the latency flags from a record.
   Use trace_flag_type enum for the flags (see event-parse.h).
  tep_data_comm_from_pid - return the command line from PID
  @tep: a handle to the trace event parser context
  @pid: the PID of the task to search for
  This returns a pointer to the command line that has the given
  @pid.
  tep_data_pid_from_comm - return the pid from a given comm
  @tep: a handle to the trace event parser context
  @comm: the cmdline to find the pid from
  @next: the cmdline structure to find the next comm
  This returns the cmdline structure that holds a pid for a given
  comm, or NULL if none found. As there may be more than one pid for
  a given comm, the result of this call can be passed back into
  a recurring call in the @next parameter, and then it will find the
  next pid.
  Also, it does a linear search, so it may be slow.
	
	  If the cmdlines have not been converted yet, then use
	  the list.
		
		  The next pointer could have been still from
		  a previous call before cmdlines were created
  tep_cmdline_pid - return the pid associated to a given cmdline
  @tep: a handle to the trace event parser context
  @cmdline: The cmdline structure to get the pid from
  Returns the pid for a give cmdline. If @cmdline is NULL, then
  -1 is returned.
	
	  If cmdlines have not been created yet, or cmdline is
	  not part of the array, then treat it as a cmdlist instead.
  This parses the raw @data using the given @event information and
  writes the print format into the trace_seq.
  tep_find_event_by_record - return the event from a given record
  @tep: a handle to the trace event parser context
  @record: The record to get the event from
  Returns the associated event for a given record, or NULL if non is
  is found.
  Writes the timestamp of the record into @s. Time divisor and precision can be
  specified as part of printf @format string. Example:
 	"%3.1000d" - divide the time by 1000 and print the first 3 digits
 	before the dot. Thus, the timestamp "123456000" will be printed as
 	"123.456"
  tep_print_event - Write various event information
  @tep: a handle to the trace event parser context
  @s: the trace_seq to write to
  @record: The record to get the event from
  @format: a printf format string. Supported event fileds:
 	TEP_PRINT_PID, "%d" - event PID
 	TEP_PRINT_CPU, "%d" - event CPU
 	TEP_PRINT_COMM, "%s" - event command string
 	TEP_PRINT_NAME, "%s" - event name
 	TEP_PRINT_LATENCY, "%s" - event latency
 	TEP_PRINT_TIME, %d - event time stamp. A divisor and precision
 			can be specified as part of this format string:
 			"%precision.divisord". Example:
 			"%3.1000d" - divide the time by 1000 and print the first
 			3 digits before the dot. Thus, the time stamp
 			"123456000" will be printed as "123.456"
 	TEP_PRINT_INFO, "%s" - event information. If any width is specified in
 			the format string, the event information will be printed
 			in raw format.
  Writes the specified event information into @s.
  tep_list_events - Get events, sorted by given criteria.
  @tep: a handle to the tep context
  @sort_type: desired sort order of the events in the array
  Returns an array of pointers to all events, sorted by the given
  @sort_type criteria. The last element of the array is NULL. The returned
  memory must not be freed, it is managed by the library.
  The function is not thread safe.
 the internal events are sorted by id 
  tep_list_events_copy - Thread safe version of tep_list_events()
  @tep: a handle to the tep context
  @sort_type: desired sort order of the events in the array
  Returns an array of pointers to all events, sorted by the given
  @sort_type criteria. The last element of the array is NULL. The returned
  array is newly allocated inside the function and must be freed by the caller
 the internal events are sorted by id 
  tep_event_common_fields - return a list of common fields for an event
  @event: the event to return the common fields of.
  Returns an allocated array of fields. The last item in the array is NULL.
  The array must be freed with free().
  tep_event_fields - return a list of event specific fields for an event
  @event: the event to return the fields of.
  Returns an allocated array of fields. The last item in the array is NULL.
  The array must be freed with free().
 for debugging 
 we should warn... 
 type 
	
	  If this is not a mandatory field, then test it first.
 newer versions of the kernel have a "signed" type 
  tep_parse_header_page - parse the data stored in the header page
  @tep: a handle to the trace event parser context
  @buf: the buffer storing the header page format string
  @size: the size of @buf
  @long_size: the long size to use if there is no header
  This parses the header page format for information on the
  ring buffer used. The @buf should be copied from
  syskerneldebugtracingeventsheader_page
		
		  Old kernels did not have header page info.
		  Sorry but we just use what we find here in user space.
  parse_format - parse the event format
  @buf: the buffer storing the event format string
  @size: the size of @buf
  @sys: the system the event belongs to
  This parses the event format and creates an event structure
  to quickly parse raw data for a given event.
  These files currently come from:
  syskerneldebugtracingevents......format
 Bad event? 
		
		  This isn't an allocation error actually.
		  But as the ID is critical, just bail out.
 Add tep to event so that it can be referenced 
	
	  If the event has an override, don't print warnings if the event
	  print format fails to parse.
 old ftrace had no args 
  tep_parse_format - parse the event format
  @tep: a handle to the trace event parser context
  @eventp: returned format
  @buf: the buffer storing the event format string
  @size: the size of @buf
  @sys: the system the event belongs to
  This parses the event format and creates an event structure
  to quickly parse raw data for a given event.
  These files currently come from:
  syskerneldebugtracingevents......format
  tep_parse_event - parse the event format
  @tep: a handle to the trace event parser context
  @buf: the buffer storing the event format string
  @size: the size of @buf
  @sys: the system the event belongs to
  This parses the event format and creates an event structure
  to quickly parse raw data for a given event.
  These files currently come from:
  syskerneldebugtracingevents......format
  tep_get_field_raw - return the raw pointer into the data field
  @s: The seq to print to on error
  @event: the event that the field is for
  @name: The name of the field
  @record: The record with the field name.
  @len: place to store the field length.
  @err: print default error if failed.
  Returns a pointer into record->data of the field and places
  the length of the field in @len.
  On failure, it returns NULL.
 Allow @len to be NULL 
  tep_get_field_val - find a field and return its value
  @s: The seq to print to on error
  @event: the event that the field is for
  @name: The name of the field
  @record: The record with the field name.
  @val: place to store the value of the field.
  @err: print default error if failed.
  Returns 0 on success -1 on field not found.
  tep_get_common_field_val - find a common field and return its value
  @s: The seq to print to on error
  @event: the event that the field is for
  @name: The name of the field
  @record: The record with the field name.
  @val: place to store the value of the field.
  @err: print default error if failed.
  Returns 0 on success -1 on field not found.
  tep_get_any_field_val - find a any field and return its value
  @s: The seq to print to on error
  @event: the event that the field is for
  @name: The name of the field
  @record: The record with the field name.
  @val: place to store the value of the field.
  @err: print default error if failed.
  Returns 0 on success -1 on field not found.
  tep_print_num_field - print a field and a format
  @s: The seq to print to
  @fmt: The printf format to print the field with.
  @event: the event that the field is for
  @name: The name of the field
  @record: The record with the field name.
  @err: print default error if failed.
  Returns positive value on success, negative in case of an error,
  or 0 if buffer is full.
  tep_print_func_field - print a field and a format for function pointers
  @s: The seq to print to
  @fmt: The printf format to print the field with.
  @event: the event that the field is for
  @name: The name of the field
  @record: The record with the field name.
  @err: print default error if failed.
  Returns positive value on success, negative in case of an error,
  or 0 if buffer is full.
  tep_register_print_function - register a helper function
  @tep: a handle to the trace event parser context
  @func: the function to process the helper function
  @ret_type: the return type of the helper function
  @name: the name of the helper function
  @parameters: A list of enum tep_func_arg_type
  Some events may have helper functions in the print format arguments.
  This allows a plugin to dynamically create a way to process one
  of these functions.
  The @parameters is a variable list of tep_func_arg_type enums that
  must end with TEP_FUNC_ARG_VOID.
		
		  This is most like caused by the users own
		  plugins updating the function. This overrides the
		  system defaults.
  tep_unregister_print_function - unregister a helper function
  @tep: a handle to the trace event parser context
  @func: the function to process the helper function
  @name: the name of the helper function
  This function removes existing print handler for function @name.
  Returns 0 if the handler was removed successully, -1 otherwise.
 search by id 
  tep_register_event_handler - register a way to parse an event
  @tep: a handle to the trace event parser context
  @id: the id of the event to register
  @sys_name: the system name the event belongs to
  @event_name: the name of the event
  @func: the function to call to parse the event information
  @context: the data to be passed to @func
  This function allows a developer to override the parsing of
  a given event. If for some reason the default print format
  is not sufficient, this function will register a function
  for an event to be used to parse the data instead.
  If @id is >= 0, then it is used to find the event.
  else @sys_name and @event_name are used.
  Returns:
   TEP_REGISTER_SUCCESS_OVERWRITE if an existing handler is overwritten
   TEP_REGISTER_SUCCESS if a new handler is registered successfully
   negative TEP_ERRNO_... in case of an error
 Save for later use. 
  tep_unregister_event_handler - unregister an existing event handler
  @tep: a handle to the trace event parser context
  @id: the id of the event to unregister
  @sys_name: the system name the handler belongs to
  @event_name: the name of the event handler
  @func: the function to call to parse the event information
  @context: the data to be passed to @func
  This function removes existing event handler (parser).
  If @id is >= 0, then it is used to find the event.
  else @sys_name and @event_name are used.
  Returns 0 if handler was removed successfully, -1 if event was not found.
  tep_alloc - create a tep handle
  tep_free - free a tep handle
  @tep: the tep handle to free
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2009, 2010 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>
 kbuffer
  @timestamp		- timestamp of current event
  @lost_events		- # of lost events between this subbuffer and previous
  @flags		- special flags of the kbuffer
  @subbuffer		- pointer to the sub-buffer page
  @data		- pointer to the start of data on the sub-buffer page
  @index		- index from @data to the @curr event data
  @curr		- offset from @data to the start of current event
 			   (includes metadata)
  @next		- offset from @data to the start of next event
  @size		- The size of data on @data
  @start		- The offset from @subbuffer where @data lives
  @read_4		- Function to read 4 raw bytes (may swap)
  @read_8		- Function to read 8 raw bytes (may swap)
  @read_long		- Function to read a long word (4 or 8 bytes with needed swap)
  kbuffer_alloc - allocat a new kbuffer
  @size;	enum to denote size of word
  @endian:	enum to denote endianness
  Allocates and returns a new kbuffer.
 May be changed by kbuffer_set_old_format() 
 kbuffer_free - free an allocated kbuffer
  @kbuf:	The kbuffer to free
  Can take NULL as a parameter.
  Linux 2.6.30 and earlier (not much ealier) had a different
  ring buffer format. It should be obsolete, but we handle it anyway.
 should never happen! 
  kbuffer_translate_data - read raw data to get a record
  @swap:	Set to 1 if bytes in words need to be swapped when read
  @data:	The raw data to read
  @size:	Address to store the size of the event data.
  Returns a pointer to the event data. To determine the entire
  record size (record metadata + data) just add the difference between
  @data and the returned value to @size.
  kbuffer_next_event - increment the current pointer
  @kbuf:	The kbuffer to read
  @ts:		Address to store the next record's timestamp (may be NULL to ignore)
  Increments the pointers into the subbuffer of the kbuffer to point to the
  next event so that the next kbuffer_read_event() will return a
  new event.
  Returns the data of the next event if a new event exists on the subbuffer,
  NULL otherwise.
  kbuffer_load_subbuffer - load a new subbuffer into the kbuffer
  @kbuf:	The kbuffer to load
  @subbuffer:	The subbuffer to load into @kbuf.
  Load a new subbuffer (page) into @kbuf. This will reset all
  the pointers and update the @kbuf timestamp. The next read will
  return the first event on @subbuffer.
  Returns 0 on succes, -1 otherwise.
  kbuffer_subbuf_timestamp - read the timestamp from a sub buffer
  @kbuf:      The kbuffer to load
  @subbuf:    The subbuffer to read from.
  Return the timestamp from a subbuffer.
  kbuffer_ptr_delta - read the delta field from a record
  @kbuf:      The kbuffer to load
  @ptr:       The record in the buffe.
  Return the timestamp delta from a record
  kbuffer_read_event - read the next event in the kbuffer subbuffer
  @kbuf:	The kbuffer to read from
  @ts:		The address to store the timestamp of the event (may be NULL to ignore)
  Returns a pointer to the data part of the current event.
  NULL if no event is left on the subbuffer.
  kbuffer_timestamp - Return the timestamp of the current event
  @kbuf:	The kbuffer to read from
  Returns the timestamp of the current (next) event.
  kbuffer_read_at_offset - read the event that is at offset
  @kbuf:	The kbuffer to read from
  @offset:	The offset into the subbuffer
  @ts:		The address to store the timestamp of the event (may be NULL to ignore)
  The @offset must be an index from the @kbuf subbuffer beginning.
  If @offset is bigger than the stored subbuffer, NULL will be returned.
  Returns the data of the record that is at @offset. Note, @offset does
  not need to be the start of the record, the offset just needs to be
  in the record (or beginning of it).
  Note, the kbuf timestamp and pointers are updated to the
  returned record. That is, kbuffer_read_event() will return the same
  data and timestamp, and kbuffer_next_event() will increment from
  this record.
 Reset the buffer 
  kbuffer_subbuffer_size - the size of the loaded subbuffer
  @kbuf:	The kbuffer to read from
  Returns the size of the subbuffer. Note, this size is
  where the last event resides. The stored subbuffer may actually be
  bigger due to padding and such.
  kbuffer_curr_index - Return the index of the record
  @kbuf:	The kbuffer to read from
  Returns the index from the start of the data part of
  the subbuffer to the current location. Note this is not
  from the start of the subbuffer. An index of zero will
  point to the first record. Use kbuffer_curr_offset() for
  the actually offset (that can be used by kbuffer_read_at_offset())
  kbuffer_curr_offset - Return the offset of the record
  @kbuf:	The kbuffer to read from
  Returns the offset from the start of the subbuffer to the
  current location.
  kbuffer_event_size - return the size of the event data
  @kbuf:	The kbuffer to read
  Returns the size of the event data (the payload not counting
  the meta data of the record) of the current event.
  kbuffer_curr_size - return the size of the entire record
  @kbuf:	The kbuffer to read
  Returns the size of the entire record (meta data and payload)
  of the current event.
  kbuffer_missed_events - return the # of missed events from last event.
  @kbuf: 	The kbuffer to read from
  Returns the # of missed events (if recorded) before the current
  event. Note, only events on the beginning of a subbuffer can
  have missed events, all other events within the buffer will be
  zero.
 Only the first event can have missed events 
  kbuffer_set_old_forma - set the kbuffer to use the old format parsing
  @kbuf:	The kbuffer to set
  This is obsolete (or should be). The first kernels to use the
  new ring buffer had a slightly different ring buffer format
  (2.6.30 and earlier). It is still somewhat supported by kbuffer,
  but should not be counted on in the future.
  kbuffer_start_of_data - return offset of where data starts on subbuffer
  @kbuf:	The kbuffer
  Returns the location on the subbuffer where the data starts.
  kbuffer_raw_get - get raw buffer info
  @kbuf:	The kbuffer
  @subbuf:	Start of mapped subbuffer
  @info:	Info descriptor to fill in
  For debugging. This can return internals of the ring buffer.
  Expects to have info->next set to what it will read.
  The type, length and timestamp delta will be filled in, and
  @info->next will be updated to the next element.
  The @subbuf is used to know if the info is passed the end of
  data and NULL will be returned if it is.
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2010 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2009 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>
  The TRACE_SEQ_POISON is to catch the use of using
  a trace_seq structure after it was destroyed.
  trace_seq_init - initialize the trace_seq structure
  @s: a pointer to the trace_seq structure to initialize
  trace_seq_reset - re-initialize the trace_seq structure
  @s: a pointer to the trace_seq structure to reset
  trace_seq_destroy - free up memory of a trace_seq
  @s: a pointer to the trace_seq to free the buffer
  Only frees the buffer, not the trace_seq struct itself.
  trace_seq_printf - sequence printing of trace information
  @s: trace sequence descriptor
  @fmt: printf format string
  It returns 0 if the trace oversizes the buffer's free
  space, the number of characters printed, or a negative
  value in case of an error.
  The tracer may use either sequence operations or its own
  copy to user routines. To simplify formating of a trace
  trace_seq_printf is used to store strings into a special
  buffer (@s). Then the output may be either used by
  the sequencer or pulled into another buffer.
  trace_seq_vprintf - sequence printing of trace information
  @s: trace sequence descriptor
  @fmt: printf format string
  It returns 0 if the trace oversizes the buffer's free
  space, the number of characters printed, or a negative
  value in case of an error.
  The tracer may use either sequence operations or its own
  copy to user routines. To simplify formating of a trace
  trace_seq_printf is used to store strings into a special
  buffer (@s). Then the output may be either used by
  the sequencer or pulled into another buffer.
  trace_seq_puts - trace sequence printing of simple string
  @s: trace sequence descriptor
  @str: simple string to record
  The tracer may use either the sequence operations or its own
  copy to user routines. This function records a simple string
  into a special buffer (@s) for later retrieval by a sequencer
  or other mechanism.
 There's always one character left on the buffer 
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2009, 2010 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>
  tep_get_event - returns the event with the given index
  @tep: a handle to the tep_handle
  @index: index of the requested event, in the range 0 .. nr_events
  This returns pointer to the element of the events array with the given index
  If @tep is NULL, or @index is not in the range 0 .. nr_events, NULL is returned.
  tep_get_first_event - returns the first event in the events array
  @tep: a handle to the tep_handle
  This returns pointer to the first element of the events array
  If @tep is NULL, NULL is returned.
  tep_get_events_count - get the number of defined events
  @tep: a handle to the tep_handle
  This returns number of elements in event array
  If @tep is NULL, 0 is returned.
  tep_set_flag - set event parser flag
  @tep: a handle to the tep_handle
  @flag: flag, or combination of flags to be set
  can be any combination from enum tep_flag
  This sets a flag or combination of flags from enum tep_flag
  tep_clear_flag - clear event parser flag
  @tep: a handle to the tep_handle
  @flag: flag to be cleared
  This clears a tep flag
  tep_test_flag - check the state of event parser flag
  @tep: a handle to the tep_handle
  @flag: flag to be checked
  This returns the state of the requested tep flag.
  Returns: true if the flag is set, false otherwise.
  tep_get_header_page_size - get size of the header page
  @tep: a handle to the tep_handle
  This returns size of the header page
  If @tep is NULL, 0 is returned.
  tep_get_header_timestamp_size - get size of the timestamp in the header page
  @tep: a handle to the tep_handle
  This returns size of the timestamp in the header page
  If @tep is NULL, 0 is returned.
  tep_get_cpus - get the number of CPUs
  @tep: a handle to the tep_handle
  This returns the number of CPUs
  If @tep is NULL, 0 is returned.
  tep_set_cpus - set the number of CPUs
  @tep: a handle to the tep_handle
  This sets the number of CPUs
  tep_get_long_size - get the size of a long integer on the traced machine
  @tep: a handle to the tep_handle
  This returns the size of a long integer on the traced machine
  If @tep is NULL, 0 is returned.
  tep_set_long_size - set the size of a long integer on the traced machine
  @tep: a handle to the tep_handle
  @size: size, in bytes, of a long integer
  This sets the size of a long integer on the traced machine
  tep_get_page_size - get the size of a memory page on the traced machine
  @tep: a handle to the tep_handle
  This returns the size of a memory page on the traced machine
  If @tep is NULL, 0 is returned.
  tep_set_page_size - set the size of a memory page on the traced machine
  @tep: a handle to the tep_handle
  @_page_size: size of a memory page, in bytes
  This sets the size of a memory page on the traced machine
  tep_is_file_bigendian - return the endian of the file
  @tep: a handle to the tep_handle
  This returns true if the file is in big endian order
  If @tep is NULL, false is returned.
  tep_set_file_bigendian - set if the file is in big endian order
  @tep: a handle to the tep_handle
  @endian: non zero, if the file is in big endian order
  This sets if the file is in big endian order
  tep_is_local_bigendian - return the endian of the saved local machine
  @tep: a handle to the tep_handle
  This returns true if the saved local machine in @tep is big endian.
  If @tep is NULL, false is returned.
  tep_set_local_bigendian - set the stored local machine endian order
  @tep: a handle to the tep_handle
  @endian: non zero, if the local host has big endian order
  This sets the endian order for the local machine.
  tep_is_old_format - get if an old kernel is used
  @tep: a handle to the tep_handle
  This returns true, if an old kernel is used to generate the tracing events or
  false if a new kernel is used. Old kernels did not have header page info.
  If @tep is NULL, false is returned.
  tep_set_test_filters - set a flag to test a filter string
  @tep: a handle to the tep_handle
  @test_filters: the new value of the test_filters flag
  This sets a flag to test a filter string. If this flag is set, when
  tep_filter_add_filter_str() API as called,it will print the filter string
  instead of adding it.
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2009, 2010 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>
 toggle, only if option is boolean 
 Warn? 
	
	  If the option has a value then it takes a string
	  otherwise the option is a boolean.
 Option is boolean, must be either "1", "0", "true" or "false" 
  tep_plugin_list_options - get list of plugin options
  Returns an array of char strings that list the currently registered
  plugin options in the format of <plugin>:<option>. This list can be
  used by toggling the option.
  Returns NULL if there's no options registered. On error it returns
  INVALID_PLUGIN_LIST_OPTION
  Must be freed with tep_plugin_free_options_list().
 first look for named options 
 first look for unnamed options 
  tep_plugin_add_options - Add a set of options by a plugin
  @name: The name of the plugin adding the options
  @options: The set of options being loaded
  Sets the options with the values that have been added by user.
  tep_plugin_remove_options - remove plugin options that were registered
  @options: Options to removed that were registered with tep_plugin_add_options
  tep_plugin_add_option - add an optionval pair to set plugin options
  @name: The name of the option (format: <plugin>:<option> or just <option>)
  @val: (optional) the value for the option
  Modify a plugin option. If @val is given than the value of the option
  is set (note, some options just take a boolean, so @val must be either
  "1" or "0" or "true" or "false").
 If the option exists, update the val 
 Both must be NULL or not NULL 
 update option 
 plugin and option_str don't get freed at the end 
 If not found, create 
  tep_plugin_print_options - print out the registered plugin options
  @s: The trace_seq descriptor to write the plugin options into
  Writes a list of options into trace_seq @s.
  tep_print_plugins - print out the list of plugins loaded
  @s: the trace_seq descripter to write to
  @prefix: The prefix string to add before listing the option name
  @suffix: The suffix string ot append after the option name
  @list: The list of plugins (usually returned by tep_load_plugins()
  Writes to the trace_seq @s the list of plugins (files) that is
  returned by tep_load_plugins(). Use @prefix and @suffix for formating:
  @prefix = "  ", @suffix = "\n".
 Only load plugins that end in suffix 
  tep_load_plugins_hook - call a user specified callback to load a plugin
  @tep: handler to traceevent context
  @suffix: filter only plugin files with given suffix
  @load_plugin: user specified callback, called for each plugin file
  @data: custom context, passed to @load_plugin
  Searches for traceevent plugin files and calls @load_plugin for each
  The order of plugins search is:
   - Directories, specified in @tep->plugins_dir and priority TEP_PLUGIN_FIRST
   - Directory, specified at compile time with PLUGIN_TRACEEVENT_DIR
   - Directory, specified by environment variable TRACEEVENT_PLUGIN_DIR
   - In user's home: ~.locallibtraceeventplugins
   - Directories, specified in @tep->plugins_dir and priority TEP_PLUGIN_LAST
	
	  If a system plugin directory was defined,
	  check that first.
	
	  Next let the environment-set plugin directory
	  override the system defaults.
	
	  Now let the home directory override the environment
	  or system defaults.
  tep_add_plugin_path - Add a new plugin directory.
  @tep: Trace event handler.
  @path: Path to a directory. All plugin files in that
 	  directory will be loaded.
 @prio: Load priority of the plugins in that directory.
  Returns -1 in case of an error, 0 otherwise.
 SPDX-License-Identifier: LGPL-2.1
  The tools so far have been using the strerror_r() GNU variant, that returns
  a string, be it the buffer passed or something else.
  But that, besides being tricky in cases where we expect that the function
  using strerror_r() returns the error formatted in a provided buffer (we have
  to check if it returned something else and copy that instead), breaks the
  build on systems not using glibc, like Alpine Linux, where musl libc is
  used.
  So, introduce yet another wrapper, str_error_r(), that has the GNU
  interface, but uses the portable XSI variant of strerror_r(), so that users
  rest asured that the provided buffer is used and it is what is returned.
 SPDX-License-Identifier: GPL-2.0
  From glibc endian.h, for older systems where it is not present, e.g.: RHEL5,
  Fedora6.
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2015 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2009 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>
	
	  We can only use the structure if file is of the same
	  endianness.
 SPDX-License-Identifier: GPL-2.0
       SCSI opcodes
 values for service action in 
 values for VARIABLE_LENGTH_CMD service action codes
 values for maintenance in 
 value for MI_REPORT_TARGET_PGS ext header 
 values for maintenance out 
 values for variable length command 
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2009 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2010 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2009, 2010 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>
 make sure the comm has a \0 at the end. 
 Help out the comm to ids. This will handle dups 
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2009 Johannes Berg <johannes@sipsolutions.net>
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2009, 2010 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>
 Account for holes in the cpu count 
 Not found 
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2017 National Instruments Corp.
  Author: Julia Cartwright <julia@ni.com>
 or val2 
 SPDX-License-Identifier: LGPL-2.1
  Copyright (C) 2009 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>
  Copyright (C) 2009 Johannes Berg <johannes@sipsolutions.net>
 SPDX-License-Identifier: GPL-2.0
 x86 only 
 x8664 only 
 Architecture-specific hypercall definitions. 
 Architecture-specific hypercall definitions. 
 SPDX-License-Identifier: GPL-2.0
 buf must be treated as const if !is_read. 
  Read exactly 'n' bytes or return an error.
  Write exactly 'n' bytes or return an error.
 ion does not modify buf. 
 SPDX-License-Identifier: GPL-2.0
	
	  We already have cpus for evsel (via PMU sysfs) so
	  keep it, if there's no target cpu list defined.
 Empty list is noticed here so don't need checking on entry. 
	
	  Allow for the possibility that one or another of the maps isn't being
	  changed i.e. don't put it.  Note we are assuming the maps that are
	  being applied are brand new and evlist is taking ownership of the
	  original reference count of 1.  If that is not the case it is up to
	  the caller to increase the reference count.
 The first entry is the counter value 
 Legacy way to get event id.. All hail to old kernels! 
	
	  This way does not work with group format read, so bail
	  out in that case.
		
		  When the perf_mmap() call is made we grab one refcount, plus
		  one extra to let perf_mmap__consume() get the last
		  events after all real references (perf_mmap__get()) are
		  dropped.
		 
		  Each PERF_EVENT_IOC_SET_OUTPUT points to this mmap and
		  thus does perf_mmap__get() on it.
			
			  The last one will be done at perf_mmap__consume(), so that we
			  make sure we don't prevent tools from consuming every last event in
			  the ring buffer.
			 
			  I.e. we can get the POLLHUP meaning that the fd doesn't exist
			  anymore, but the last events for it are still in the ring buffer,
			  waiting to be consumed.
			 
			  Tools can chose to ignore this at their own discretion, but the
			  evlist layer can't just drop it when filtering events in
			  perf_evlist__filter_pollfd().
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Report the start and end of the available data in ringbuffer
		
		  Backward ring buffer is full. We still have a chance to read
		  most of data from it.
	
	  Check if event was unmapped due to a POLLHUPPOLLERR.
  Mandatory for overwrite mode
  The direction of overwrite mode is backward.
  The last perf_mmap__read() will set tail to map->core.prev.
  Need to correct the map->core.prev to head which is the end of next read.
	
	  Check if event was unmapped due to a POLLHUPPOLLERR.
 When check_messup is true, 'end' must points to a good entry 
		
		  Event straddles the mmap boundary -- header should always
		  be inside due to u64 alignment of output.
  Read event from ring buffer one by one.
  Return one event for each call.
  Usage:
  perf_mmap__read_init()
  while(event = perf_mmap__read_event()) {
 	process the event
 	perf_mmap__consume()
  }
  perf_mmap__read_done()
	
	  Check if event was unmapped due to a POLLHUPPOLLERR.
 non-overwirte doesn't pause the ringbuffer 
 Adjust for cap_usr_time_short, a nop if not 
 SPDX-License-Identifier: GPL-2.0
	
	  We only realloc to add more items, let's reset new items.
 SPDX-License-Identifier: GPL-2.0-only
 Remove dups 
	
	  must handle the case of empty cpumap to cover
	  TOPOLOGY header for NUMA nodes with no CPU
	  ( e.g., because of CPU hotplug)
 check for duplicates 
 cpu_map__trim_new() qsort()s it, cpu_map__default_new() sorts it as well.
  Merge two cpumaps
  orig either gets freed and replaced with a new map, or reused
  with no reference count change (similar to "realloc")
  other has its reference count increased.
 Standard merge algorithm from wikipedia 
 SPDX-License-Identifier: GPL-2.0-only
 SPDX-License-Identifier: GPL-2.0
	
	  Leader must be already processedopen,
	  if not it's a bug.
 value 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 needed for sched.h to get sched_[gs]etaffinity and CPU_(ZERO,SET)
 Generate 100 prctl calls. 
 kick the child and wait for it to finish 
	
	  There's no need to call perf_evlist__disable,
	  monitored process is dead now.
 calls perf_evlist__munmapperf_evlist__close 
	
	  The generated prctl calls should match the
	  number of events in the buffer.
 calls perf_evlist__munmapperf_evlist__close 
	
	  The generated prctl events should match the
	  number of cpus or be bigger (we are system-wide).
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
  Check for "NAME_PATH" environment variable to override fs location (for
  testing). This matches the recommendation in Documentationadmin-guidesysfs-rules.rst
  for SYSFS_PATH.
 name + "_PATH" + '\0' 
	 the mount point was already checked for the mount point
	  but and did not exist, so return NULL to avoid scanning again.
	  This makes the found and not found paths cost equivalent
	  in case of multiple calls.
 "PERF_" + name + "_ENVIRONMENT" + '\0' 
  Parses @value out of @filename with strtoull.
  By using 16 for base to treat the number as hex.
  Parses @value out of @filename with strtoull.
  By using 0 for base, the strtoull detects the
  base automatically (see man strtoull).
 For the buffer size of strerror_r 
 SPDX-License-Identifier: GPL-2.0
 just cache last used one 
	
	  in order to handle split hierarchy, we need to scan procmounts
	  and inspect every cgroupfs mount point to find one that has
	  the given subsystem.  If we found v1, just use it.  If not we can
	  use v2 path as a fallback.
	
	  The procmounts has the follow format:
	 
	    <devname> <mount point> <fs type> <options> ...
	 
 skip devname 
 save the mount point 
 check filesystem type 
 save cgroup v2 path 
 now we have cgroup v1, check the options for subsystem 
 sanity check: it should be separated by a space or a comma 
 SPDX-License-Identifier: GPL-2.0
		
		  We will get here if we can't find the tracepoint, but one of
		  debugfs or tracefs is configured, which means you probably
		  want some tracepoint which wasn't compiled in your kernel.
		  - jirka
 sdt markers 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2014, Red Hat Inc, Arnaldo Carvalho de Melo <acme@redhat.com>
 SPDX-License-Identifier: GPL-2.0
 min 1 SP between words 
 don't print on the edge 
 stat, not lstat 
 SPDX-License-Identifier: GPL-2.0
	
	  In case of errors we must keep the promise to close FDs
	  that have been passed in via ->in and ->out.
 SPDX-License-Identifier: GPL-2.0
  This is split up from the rest of git so that we can do
  something different on Windows.
	
	  Work around bug in "less" by not starting it until we
	  have real input
 signal EOF to pager 
 means we are emitting to terminal 
 spawn the pager 
 original process continues, but writes to the pipe 
 this makes sure that the parent terminates after the pager 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
	
	  Propagate this setting to external programs.
 Returns the highest-priority location to look for subprograms. 
 just counting 
 execvp() can only ever return if it fails 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: GPL-2.0
 FALLTHROUGH 
 PARSE_OPT_NOEMPTY: Allow NULL but disallow empty string. 
 Similar to unset if we are given an empty string. 
				
				  The long name itself starts with "no-", so
				  accept the option without "no-" so that users
				  do not have to enter "no-no-" to get the
				  negation.
 Abbreviated case 
 abbreviated? 
					
					  If this is abbreviated, it is
					  ambiguous. So when there is no
					  exact match later, we need to
					  error out.
 negated and abbreviated very much? 
 negated? 
 abbreviated and negated? 
 we must reset ->opt, unknown short option leave it dangling 
					 fake a short option thing to hide the fact that we may have
					  started to parse aggregated stuff
					 
					  This is leaky, too bad.
 "--" 
 build usage string if it's not provided 
 PARSE_OPT_UNKNOWN 
 FALLTHROUGH 
 OPTION_{BIT,BOOLEAN,SET_UINT,SET_PTR} 
 --no-quiet, --no-verbose 
 SPDX-License-Identifier: GPL-2.0
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 Copyright (c) 2021 Facebook 
 lookup index for each unique string in strings set 
			 hashmap__add() returns EEXIST if string with the same
			  content already is in the hash map
 duplicate 
 Find string offset that corresponds to a given string s.
  Returns:
    - >0 offset into string data, if string is found;
    - -ENOENT, if string is not in the string data;
    - <0, on any other error.
 see strset__add_str() for why we do this 
 Add a string s to the string data. If the string already exists, return its
  offset within string data.
  Returns:
    - > 0 offset into string data, on success;
    - < 0, on error.
	 Hashmap keys are always offsets within set->strs_data, so to even
	  look up some string from the "outside", we need to first append it
	  at the end, so that it can be addressed with an offset. Luckily,
	  until set->strs_data_len is incremented, that string is just a piece
	  of garbage for the rest of the code, so no harm, no foul. On the
	  other hand, if the string is unique, it's already appended and
	  ready to be used, only a simple set->strs_data_len increment away.
	 Now attempt to add the string, but only if the string with the same
	  contents doesn't exist already (HASHMAP_ADD strategy). If such
	  string exists, we'll get its offset in old_off (that's old_key).
 duplicated string, return existing offset 
 new unique string, adjust data length 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 Copyright (c) 2019 Netronome Systems, Inc. 
 Return 0 on failure, and attempt to probe with empty kversion 
 nfp returns -EINVAL on exit(0) with TC offload 
	 struct bpf_spin_lock {
	    int val;
	  };
	  struct val {
	    int cnt;
	    struct bpf_spin_lock l;
	  };
 int 
 [1] 
 struct bpf_spin_lock                       
 int val; 
 struct val                                 
 int cnt; 
 struct bpf_spin_lock l; 
		 TODO: probe for device, once libbpf has a function to create
		  map-in-map for offload
 Note: No other restriction on map type probes for offload 
 Netronome specific 
  Probe for availability of kernel commit (5.3):
  c04c0d2b968a ("bpf: increase complexity limit and maximum program size")
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  AF_XDP user-space access library.
  Copyright(c) 2018 - 2019 Intel Corporation.
  Author(s): Magnus Karlsson <magnus.karlsson@intel.com>
 Up until and including Linux 5.3 
 Up until and including Linux 5.3 
	 getsockopt on a kernel <= 5.3 has no flags fields.
	  Copy over the offsets to the correct places in the >=5.4 format
	  and put the flags where they would have been on that kernel.
	 This is the fallback C-program:
	  SEC("xdp_sock") int xdp_sock_prog(struct xdp_md ctx)
	  {
	      int ret, index = ctx->rx_queue_index;
	 
	       A set entry here means that the correspnding queue_id
	       has an active AF_XDP socket bound to it.
	      ret = bpf_redirect_map(&xsks_map, index, XDP_PASS);
	      if (ret > 0)
	          return ret;
	 
	       Fallback for pre-5.3 kernels, not supporting default
	       action in the flags parameter.
	      if (bpf_map_lookup_elem(&xsks_map, &index))
	          return bpf_redirect_map(&xsks_map, index, 0);
	      return XDP_PASS;
	  }
 r2 = (u32 )(r1 + 16) 
 (u32 )(r10 - 4) = r2 
 r1 = xskmap[] 
 r3 = XDP_PASS 
 call bpf_redirect_map 
 if w0 != 0 goto pc+13 
 r2 = r10 
 r2 += -4 
 r1 = xskmap[] 
 call bpf_map_lookup_elem 
 r1 = r0 
 r0 = XDP_PASS 
 if r1 == 0 goto pc+5 
 r2 = (u32 )(r10 - 4) 
 r1 = xskmap[] 
 r3 = 0 
 call bpf_redirect_map 
 The jumps are to this instruction 
	 This is the post-5.3 kernel C-program:
	  SEC("xdp_sock") int xdp_sock_prog(struct xdp_md ctx)
	  {
	      return bpf_redirect_map(&xsks_map, ctx->rx_queue_index, XDP_PASS);
	  }
 r2 = (u32 )(r1 + 16) 
 r1 = xskmap[] 
 r3 = XDP_PASS 
 call bpf_redirect_map 
	 if there's a netlink-based XDP prog loaded on interface, bail out
	  and ask user to do the removal by himself
		 If the device says it has no channels, then all traffic
		  is sent to a single stream, so max queues = 1.
		 Take the max of rx, tx, combined. Drivers return
		  the number of channels in different ways.
 Copy over rings to new structs. 
		 cached_cons is r->size bigger than the real consumer pointer
		  See xsk_prod_nb_free
	 Do not close an fd that also has an associated umem connected
	  to it.
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  Common eBPF ELF object loading operations.
  Copyright (C) 2013-2015 Alexei Starovoitov <ast@kernel.org>
  Copyright (C) 2015 Wang Nan <wangnan0@huawei.com>
  Copyright (C) 2015 Huawei Inc.
  Copyright (C) 2017 Nicira, Inc.
  Copyright (C) 2019 Isovalent, Inc.
 vsprintf() in __base_pr() uses nonliteral format string. It may break
  compilation if user enables corresponding warning. Disable it explicitly.
 Copied from toolsperfutilutil.h 
 this goes away in libbpf 1.0 
	 __LIBBPF_STRICT_LAST is the last power-of-2 value used + 1, so to
	  get all possible values we compensate last +1, and then (2x - 1)
	  to get the bit mask
 v4.14: kernel support for program & map names. 
 v5.2: kernel support for global data sections. 
 BTF support 
 BTF_KIND_FUNC and BTF_KIND_FUNC_PROTO support 
 BTF_KIND_VAR and BTF_KIND_DATASEC support 
 BTF_FUNC_GLOBAL is supported 
 BPF_F_MMAPABLE is supported for arrays 
 kernel support for expected_attach_type in BPF_PROG_LOAD 
 bpf_probe_read_{kernel,user}[_str] helpers 
 BPF_PROG_BIND_MAP is supported 
 Kernel support for module BTFs 
 BTF_KIND_FLOAT support 
 BPF perf link support 
 BTF_KIND_DECL_TAG support 
 stored as sec_def->cookie for all libbpf-supported SEC()s 
 expected_attach_type is optional, if kernel doesn't support that 
	 legacy, only used by libbpf_get_type_names() and
	  libbpf_attach_type_by_name(), not used by libbpf itself at all.
	  This used to be associated with cgroup (and few other) BPF programs
	  that were attachable through BPF_PROG_ATTACH command. Pretty
	  meaningless nowadays, though.
	 attachment target is specified through BTF ID in either kernel or
 BPF program type allows sleepingblocking in kernel 
 allow non-strict prefix matching 
  bpf_prog should be a better name but it has been used in
  linuxfilter.h.
	 this program's instruction offset (in number of instructions)
	  within its containing ELF section
	 number of original instructions in ELF section belonging to this
	  program, not taking into account subprogram instructions possible
	  appended later during relocation
	 Offset (in number of instructions) of the start of instruction
	  belonging to this BPF program  within its containing main BPF
	  program. For the entry-point (main) BPF program, this is always
	  zero. For a sub-program, this gets reset before each of main BPF
	  programs are processed and relocated and is used to determined
	  whether sub-program was already appended to the main program, and
	  if yes, at which instruction offset.
	 name with  replaced by _; makes recursive pinning
	  in bpf_object__pin_programs easier
	 instructions that belong to BPF program; insns[0] is located at
	  sec_insn_off instruction within its ELF section in ELF file, so
	  when mapping ELF file instruction index to the local instruction,
	  one needs to subtract sec_insn_off; and vice versa.
	 actual number of instruction in this BPF program's image; for
	  entry-point BPF programs this includes the size of main program
	  itself plus all the used sub-programs, appended at the end
 e.g. struct tcp_congestion_ops in bpf_prog's btf format 
	 e.g. struct bpf_struct_ops_tcp_congestion_ops in
	       btf_vmlinux's format.
	  struct bpf_struct_ops_tcp_congestion_ops {
	 	[... some other kernel fields ...]
	 	struct tcp_congestion_ops data;
	  }
	  kern_vdata-size == sizeof(struct bpf_struct_ops_tcp_congestion_ops)
	  bpf_map__init_kern_struct_ops() will populate the "kern_vdata"
	  from "data".
	 real_name is defined for special internal maps (.rodata,
	  .data, .bss, .kconfig) and preserves their original ELF section
	  name. This is important to be be able to find corresponding BTF
	  DATASEC information.
 target btf_id of the corresponding kernel var. 
 local btf_id of the ksym extern's type. 
			 BTF fd index to be patched in for insn->off, this is
			  0 for vmlinux BTF, index in obj->fd_array for module
			  BTF
 section index for section name strings 
 Information when doing ELF related work. Only valid if efile.elf is not NULL 
	
	  All loaded bpf_object are linked in a list, which is
	  hidden to caller. bpf_objects__<func> handlers deal with
	  all objects.
	 Parse and load BTF vmlinux if any of the programs in the object need
	  it at load time.
	 Path to the custom BTF to be used for BPF CO-RE relocations as an
	  override for vmlinux BTF.
 vmlinux BTF override for CO-RE relocations 
 Lazily initialized kernel module BTFs 
	
	  If the object is opened but the program was never loaded,
	  it is possible that prog->instances.nr == -1.
 insns_cnt can later be increased by appending used subprograms 
			
			  In this case the original obj->programs
			  is still valid, so don't need special treat for
			  bpf_close_object().
		 if function is a globalweak symbol, but has restricted
		  (STV_HIDDEN or STV_INTERNAL) visibility, mark its BTF FUNC
		  as static to enable more permissive BPF verification mode
		  with more outside context available to BPF verifier
	 Find the corresponding "map_value" type that will be used
	  in map_update(BPF_MAP_TYPE_STRUCT_OPS).  For example,
	  find "struct bpf_struct_ops_tcp_congestion_ops" from the
	  btf_vmlinux.
	 Find "struct tcp_congestion_ops" from
	  struct bpf_struct_ops_tcp_congestion_ops {
	 	[ ... ]
	 	struct tcp_congestion_ops data;
	  }
 Init the map's fields that depend on kern_btf 
			 mtype->type must be a func_proto which was
			  guaranteed in bpf_object__collect_st_ops_relos(),
			  so only check kern_mtype for func_proto here.
 Using basename() GNU version which doesn't modify arg. 
	
	  Caller of this function should also call
	  bpf_object__elf_finish() after data collection to return
	  obj_buf to user. If not, we should duplicate the buffer to
	  avoid user freeing them before elf finish.
		
		  obj_buf should have been validated by
		  bpf_object__open_buffer().
 Elf is corruptedtruncated, avoid calling elf_strptr. 
 Old LLVM set e_machine to EM_NONE 
 found it 
 zero out new maps 
	
	  fill all fd with -1 so won't close incorrect fd (fd=0 is stdin)
	  when failure (zclose won't close negative fd)).
	 This is one of the more confusing parts of libbpf for various
	  reasons, some of which are historical. The original idea for naming
	  internal names was to include as much of BPF object name prefix as
	  possible, so that it can be distinguished from similar internal
	  maps of a different BPF object.
	  As an example, let's say we have bpf_object named 'my_object_name'
	  and internal map corresponding to '.rodata' ELF section. The final
	  map name advertised to user and to the kernel will be
	  'my_objec.rodata', taking first 8 characters of object name and
	  entire 7 characters of '.rodata'.
	  Somewhat confusingly, if internal map ELF section name is shorter
	  than 7 characters, e.g., '.bss', we still reserve 7 characters
	  for the suffix, even though we only have 4 actual characters, and
	  resulting map will be called 'my_objec.bss', not even using all 15
	  characters allowed by the kernel. Oh well, at least the truncated
	  object name is somewhat consistent in this case. But if the map
	  name is '.kconfig', we'll still have entirety of '.kconfig' added
	  (8 chars) and thus will be left with only first 7 characters of the
	  object name ('my_obje'). Happy guessing, user, that the final map
	  name will be "my_obje.kconfig".
	  Now, with libbpf starting to support arbitrarily named .rodata.
	  and .data. data sections, it's possible that ELF section name is
	  longer than allowed 15 chars, so we now need to be careful to take
	  only up to 15 first characters of ELF name, taking no BPF object
	  name characters at all. So '.rodata.abracadabra' will result in
	  '.rodata.abracad' kernel and user-visible name.
	  We need to keep this convoluted logic intact for .data, .bss and
	  .rodata maps, but for new custom .data.custom and .rodata.custom
	  maps we use their ELF names as is, not prepending bpf_object name
	  in front. We still need to truncate them to 15 characters for the
	  kernel. Full name can be recovered for such maps by using DATASEC
	  BTF type associated with such map's value type, though.
 if there are two or more dots in map name, it's a custom dot map 
 sanitise map name to characters allowed by kernel 
	
	  Populate obj->maps with libbpf internal maps.
 skip 
 value == 'n' 
 strip quotes 
	 Validate that value stored in u64 fits in integer of `ext->sz`
	  bytes size without any loss of information. If the target integer
	  is signed, we rely on the following limits of integer type of
	  Y bits and subsequent transformation:
	 
	      -2^(Y-1) <= X           <= 2^(Y-1) - 1
	             0 <= X + 2^(Y-1) <= 2^Y - 1
	             0 <= X + 2^(Y-1) <  2^Y
	 
	   For unsigned target integer, check that all the (64 - Y) bits are
	   zero.
 Trim ending '\n' 
 Split on '=' and ensure that a value is present. 
 assume integer 
 gzopen also accepts uncompressed files. 
	
	  Count number of maps. Each map has a name.
	  Array of maps is not supported: only the first element is
	  considered.
	 
	  TODO: Detect array of map and report error.
 Assume equally sized map definitions 
 Fill obj->maps using data in "maps" section.  
		
		  If the definition of the map in the object file fits in
		  bpf_map_def, copy it.  Any extra fields in our version
		  of bpf_map_def will default to zero as a result of the
		  calloc above.
			
			  Here the map structure being read is bigger than what
			  we expect, truncate if the excess bits are all zero.
			  If they are not zero, reject this map as
			  incompatible.
  Fetch integer attribute of BTF map definition. Such attributes are
  represented using a pointer to an array, in which dimensionality of array
  encodes specified integer value. E.g., int (type)[BPF_MAP_TYPE_ARRAY];
  encodes `type => BPF_MAP_TYPE_ARRAY` keyvalue pair completely using BTF
  type definition, while using only sizeof(void ) space in ELF data section.
 replace VARDECL_TAG with INT 
			
			  using size = 1 is the safest choice, 4 will be too
			  big and cause kernel BTF validation failure if
			  original variable took less than 4 bytes
 replace DATASEC with STRUCT 
 order of field assignments is important 
 preserve variable name as member name 
 replace FUNC_PROTO with ENUM 
 kernel enforced 
 replace FUNC with TYPEDEF 
 replace BTF_FUNC_GLOBAL with BTF_FUNC_STATIC 
			 replace FLOAT with an equally-sized empty STRUCT;
			  since C compilers do not accept e.g. "float" as a
			  valid struct name, make it anonymous
 enforce 8-byte pointers for BPF-targeted BTFs 
	 .extern datasec size and var offsets were set correctly during
	  extern collection step, so just skip straight to sorting variables
		 Loader needs to fix up some of the things compiler
		  couldn't get its hands on while emitting BTF. This
		  is section size and global variable offset. We use
		  the info from the ELF itself for this purpose.
	 BPF_PROG_TYPE_TRACING programs which do not attach to other programs
	  also need vmlinux BTF
	 CO-RE relocations need kernel BTF, only when btf_custom_path
	  is not specified
 Support for typed ksyms needs kernel BTF 
 btf_vmlinux could be loaded earlier 
	 Even though some subprogs are globalweak, user might prefer more
	  permissive BPF verification process that BPF verifier performs for
	  static functions, taking into account more context from the caller
	  functions. In such case, they need to mark such subprogs with
	  __attribute__((visibility("hidden"))) and libbpf will adjust
	  corresponding FUNC BTF type to be marked as static and trigger more
	  involved BPF verification process.
 clone BTF to sanitize a copy and leave the original intact 
 enforce 8-byte pointers for BPF-targeted BTFs 
		 Pretend to have valid FD to pass various fd >= 0 checks.
		  This fd == 0 will not be used with any syscall and will be reset to -1 eventually.
 move fd to libbpf's BTF 
 approximation, but the actual list is too long 
 no special handling of .strtab 
 ignore .llvm_addrsig section as well 
 no subprograms will lead to an empty .text section, ignore it 
 DWARF sections 
 DWARF section relocations 
 .BTF and .BTF.ext don't need relocations 
 sec_insn_off can't be the same within the section 
	 ELF section indices are 1-based, so allocate +1 element to keep
	  indexing simple. Also include 0th invalid section into sec_cnt for
	  simpler and more traditional iteration logic.
	 a bunch of ELF parsing functionality depends on processing symbols,
	  so do the first pass and find the symbol table
 already processed during the first pass above 
 points to other section 
 Only do relo for section with exec instructions 
	 sort BPF programs by section name and in-section instruction offset
 externs are symbols w type=NOTYPE, bind=GLOBAL|WEAK, section=UND 
 in .text section 
 local function 
 global function 
 descending order by alignment requirements 
 ascending order by size, within same alignment class 
 resolve ties by name 
 No func in ksyms sec.  No need to add dummy var. 
 sort externs by type, for kcfg ones also by (align, size, name) 
	 for .ksyms section, we need to turn all externs into allocated
	  variables in BTF to pass kernel verification; we do this by
	  pretending that each extern is a 8-byte variable
		 find existing 4-byte integer type in BTF to use for fake
		  extern variables in DATASEC
		 For extern function, a dummy_var added earlier
		  will be used to replace the vs->type and
		  its name string will be used to refill
		  the missing param's name.
				 Reuse the dummy_var string if the
				  func proto does not have param name.
 for kcfg externs calculate their offsets within a .kconfig map 
	 For legacy reasons, libbpf supports an entry-point BPF programs
	  without SEC() attribute, i.e., those in the .text section. But if
	  there are 2 or more such programs in the .text section, they all
	  must be subprograms called from entry-point BPF programs in
	  designated SEC()'tions, otherwise there is no way to distinguish
	  which of those programs should be loaded vs which are a subprogram.
	  Similarly, if there is a functionprogram in .text and at least one
	  other BPF program with custom SEC() attribute, then we just assume
	  .text programs are subprograms (even if they are not called from
	  other programs), because libbpf never explicitly supported mixing
	  SEC()-designated BPF programs and .text entry-point BPF programs.
 sym_off stores extern index 
 sub-program call relocation 
 text_shndx can be 0, if no default "main" program exists 
 loading subprog addresses 
		 global_func: sym->st_value = offset in the section, insn->imm = 0.
		  local_func: sym->st_value = 0, insn->imm = offset in the section.
 generic map reference relocation 
 sym->st_value determines map_idx 
 global data map relocation 
	 matching program could be at index l, but it still might be the
	  wrong one, so we need to double check conditions for the last time
		 relocations against static functions are recorded as
		  relocations against the section that contains a function;
		  in such case, symbol will be STT_SECTION and sym.st_name
		  will point to empty string (0), so fetch section name
		  instead
 adjust insn_idx to local BPF program frame of reference 
	 if it's BTF-defined map, we don't need to search for type IDs.
	  For struct_ops map, it does not need btf_key_type_id and
	  btf_value_type_id.
		
		  LLVM annotates global data differently in BTF, that is,
		  only as '.data', '.bss' or '.rodata'.
 make sure basic loading works 
 make sure loading with name works 
 int 
 void x(int a) {} 
 int 
 [1] 
 FUNC_PROTO                                 
 FUNC x                                     
 static void x(int a) {} 
 int 
 [1] 
 FUNC_PROTO                                 
 FUNC x BTF_FUNC_GLOBAL                     
 static int a; 
 int 
 [1] 
 VAR x                                      
 DATASEC val                                
 float 
 int 
 [1] 
 VAR x                                      
 attr 
	 use any valid combination of program type and (optional)
	  non-zero expected attach type (i.e., not a BPF_CGROUP_INET_INGRESS)
	  to see if kernel supports expected_attach_type field for
	  BPF_PROG_LOAD command
 r1 = r10 (fp) 
 r1 += -8 
 r2 = 8 
 r3 = 0 
 int 
 BTF not supported at all 
	 check that BPF_OBJ_GET_INFO_BY_FD supports specifying name pointer;
	  kernel's module BTF support coincides with support for
	  namename_len fields in struct bpf_btf_info.
	 use invalid perf_event FD to get EBADF, if link is supported;
	  otherwise EINVAL should be returned
 close() can clobber errno 
		 To generate loader program assume the latest kernel
		  to avoid doing extra prog_load, map_create syscalls.
 Freeze .rodata and .kconfig map as read-only from syscall side. 
		 Pretend to have valid FD to pass various fd >= 0 checks.
		  This fd == 0 will not be used with any syscall and will be reset to -1 eventually.
 TODO map_update_elem: idx %td key %d value==map_idx %td\n",
 check X___Y name pattern, where X and Y are not underscores 
 X 
 ___ 
 Y 
 Given 'some_struct_name___with_flavor' return the length of a name prefix
  before last triple underscore. Struct name part after last triple
  underscore is ignored by BPF CO-RE relocation during relocation matching.
 don't do this again, even if we find no module BTFs 
 kernel too old to support module BTFs 
 expected race: BTF was unloaded 
 ignore non-module BTFs 
 Attempt to find target candidates in vmlinux BTF first 
 if vmlinux BTF has any candidate, don't got for module BTFs 
 if vmlinux BTF was overridden, don't attempt to load module BTFs 
 now look through module BTFs, trying to still find candidates 
 Check local and target types for compatibility. This check is used for
  type-based CO-RE relocations and follow slightly different rules than
  field-based relocations. This function assumes that root types were already
  checked for name match. Beyond that initial root-level name check, names
  are completely ignored. Compatibility rules are as follows:
    - any two STRUCTsUNIONsFWDsENUMsINTs are considered compatible, but
      kind should match for local and target types (i.e., STRUCT is not
      compatible with UNION);
    - for ENUMs, the size is ignored;
    - for INT, size and signedness are ignored;
    - for ARRAY, dimensionality is ignored, element types are checked for
      compatibility recursively;
    - CONSTVOLATILERESTRICT modifiers are ignored;
    - TYPEDEFsPTRs are compatible if types they pointing to are compatible;
    - FUNC_PROTOs are compatible if they have compatible signature: same
      number of input args and compatible return and argument types.
  These rules are not set in stone and probably will be adjusted as we get
  more experience with using BPF CO-RE relocations.
 max recursion depth 
 caller made sure that names match (ignoring flavor suffix) 
		 just reject deprecated bitfield-like integers; all other
		  integers are by default compatible between each other
 tail recurse for return type check 
	 adjust insn_idx from section frame of reference to the local
	  program's frame of reference; (sub-)program code is not yet
	  relocated, so it's enough to just subtract in-section offset
 TODO core_relo: prog %td insn[%d] %s kind %d\n",
		 bpf_object's ELF is gone by now so it's not easy to find
		  section index by section name, but we can find any
		  bpf_program within desired section name and use it's
		  prog->sec_idx to do a proper search by section index and
		  instruction offset
			 no need to apply CO-RE relocation if the program is
			  not going to be loaded
 obj->btf_vmlinux and module BTFs are freed after object load 
 Relocate data references within program code:
   - map references;
   - global variable references;
   - extern references.
 EXT_KSYM  {
 typed ksyms 
 typeless ksyms or unresolved typed ksyms 
 unresolved weak kfunc 
 handled already 
 handled already 
		 append funcline info of a given (sub-)program to the main
		  program funcline info
		 Kernel instruction offsets are in units of 8-byte
		  instructions, while .BTF.ext instruction offsets generated
		  by Clang are in units of bytes. So convert Clang offsets
		  into kernel offsets and adjust offset according to program
		  relocated position.
	 no .BTF.ext relocation if .BTF.ext is missing or kernel doesn't
	  supprot funcline info
	 only attempt func info relocation if main program's func_info
	  relocation was successful
			
			  Some info has already been found but has problem
			  in the last btf_ext reloc. Must have to error out.
 Have problem loading the very first info. Ignore the rest. 
 don't relocate line info if main program's relocation failed 
			
			  Some info has already been found but has problem
			  in the last btf_ext reloc. Must have to error out.
 Have problem loading the very first info. Ignore the rest. 
	 After insn_idx adjustment the 'relos' array is still sorted
	  by insn_idx and doesn't break bsearch.
			 kfunc relocations will be handled later
			  in bpf_object__relocate_data()
			 sub-program instruction index is a combination of
			  an offset of a symbol pointed to by relocation and
			  call instruction's imm field; for global functions,
			  call always has imm = -1, but for static functions
			  relocation is against STT_SECTION and insn->imm
			  points to a start of a static function
			 
			  for subprog addr relocation, the relo->sym_off + insn->imm is
			  the byte offset in the corresponding section.
			
			  RELO_SUBPROG_ADDR relo is always emitted even if both
			  functions are in the same section, so it shouldn't reach here.
			 if subprogram call is to a static function within
			  the same ELF section, there won't be any relocation
			  emitted, but it also means there is no additional
			  offset necessary, insns->imm is relative to
			  instruction's original position within the section
 we enforce that sub-programs should be in .text section 
		 if it's the first call instruction calling into this
		  subprogram (meaning this subprog hasn't been processed
		  yet) within the context of current main program:
		    - append it at the end of main program's instructions blog;
		    - process is recursively, while current program is put on hold;
		    - if that subprogram calls some other not yet processes
		    subprogram, same thing will happen recursively until
		    there are no more unprocesses subprograms left to append
		    and relocate.
 The subprog insns are now appended. Append its relos too. 
		 main_prog->insns memory could have been re-allocated, so
		  calculate pointer again
		 calculate correct instruction position within current main
		  prog; each main prog can have a different set of
		  subprograms appended (potentially in different order as
		  well), so position of any subprog can be different for
  Relocate sub-program calls.
  Algorithm operates as follows. Each entry-point BPF program (referred to as
  main prog) is processed separately. For each subprog (non-entry functions,
  that can be called from either entry progs or other subprogs) gets their
  sub_insn_off reset to zero. This serves as indicator that this subprogram
  hasn't been yet appended and relocated within current main prog. Once its
  relocated, sub_insn_off will point at the position within current main prog
  where given subprog was appended. This will further be used to relocate all
  the call instructions jumping into this subprog.
  We start with main program and process all call instructions. If the call
  is into a subprog that hasn't been processed (i.e., subprog->sub_insn_off
  is zero), subprog instructions are appended at the end of main program's
  instruction array. Then main program is "put on hold" while we recursively
  process newly appended subprogram. If that subprogram calls into another
  subprogram that hasn't been appended, new subprogram is appended again to
  the main prog's instructions (subprog's instructions are always left
  untouched, as they need to be in unmodified state for subsequent main progs
  and subprog instructions are always sent only as part of a main prog) and
  the process continues recursively. Once all the subprogs called from a main
  prog or any of its subprogs are appended (and relocated), all their
  positions within finalized instructions array are known, so it's easy to
  rewrite call instructions with correct relative offsets, corresponding to
  desired target subprog.
  Its important to realize that some subprogs might not be called from some
  main prog and any of its calledused subprogs. Those will keep their
  subprog->sub_insn_off as zero at all times and won't be appended to current
  main prog and won't be relocated within the context of current main prog.
  They might still be used from other main progs later.
  Visually this process can be shown as below. Suppose we have two main
  programs mainA and mainB and BPF object contains three subprogs: subA,
  subB, and subC. mainA calls only subA, mainB calls only subC, but subA and
  subC both call subB:
         +--------+ +-------+
         |        v v       |
      +--+---+ +--+-+-+ +---+--+
      | subA | | subB | | subC |
      +--+---+ +------+ +---+--+
         ^                  ^
         |                  |
     +---+-------+   +------+----+
     |   mainA   |   |   mainB   |
     +-----------+   +-----------+
  We'll start relocating mainA, will find subA, append it and start
  processing sub A recursively:
     +-----------+------+
     |   mainA   | subA |
     +-----------+------+
  At this point we notice that subB is used from subA, so we append it and
  relocate (there are no further subcalls from subB):
     +-----------+------+------+
     |   mainA   | subA | subB |
     +-----------+------+------+
  At this point, we relocate subA calls, then go one level up and finish with
  relocatin mainA calls. mainA is done.
  For mainB process is similar but results in different order. We start with
  mainB and skip subA and subB, as mainB never calls them (at least
  directly), but we see subC is needed, so we append and start processing it:
     +-----------+------+
     |   mainB   | subC |
     +-----------+------+
  Now we see subC needs subB, so we go back to it, append and relocate it:
     +-----------+------+------+
     |   mainB   | subC | subB |
     +-----------+------+------+
  At this point we unwind recursion, relocate calls in subC, then in mainB.
	 mark all subprogs as not relocated (yet) within the context of
	  current main program
 free up relocation descriptors 
	 Before relocating calls pre-process relocations and mark
	  few ld_imm64 instructions that points to subprogs.
	  Otherwise bpf_object__reloc_code() later would have to consider
	  all ld_imm64 insns as relocation candidates. That would
	  reduce relocation speed, since amount of find_prog_insn_relo()
	  would increase and most of them will fail to find a relo.
 mark the insn, so it's recognized by insn_is_pseudo_func() 
	 relocate subprogram calls and append used subprograms to main
	  programs; each copy of subprogram code needs to be relocated
	  differently for each main program, because its code location might
	  have changed.
	  Append subprog relos to main programs to allow data relos to be
	  processed after text is completely relocated.
		 sub-program's sub-calls are relocated within the context of
		  its main program only
 Process data relos for main programs 
		 here we use BPF pointer size, which is always 64 bit, as we
		  are parsing ELF that was built for BPF target
 no two relocations should have the same insn_idx, but ... 
		 on kernels that don't yet support
		  bpf_probe_read_{kernel,user}[_str] helpers, fall back
		  to bpf_probe_read() which works well for old kernels
 this is called as prog->sec_def->preload_fn for libbpf-supported sec_defs 
 old kernels might not support specifying expected_attach_type 
 cache resolved BTF FD and BTF type ID in the prog 
		 but by now libbpf common logic is not utilizing
		  prog->atach_btf_obj_fdprog->attach_btf_id anymore because
		  this callback is called after attrs were populated by
		  libbpf, so this callback has to update attr explicitly here
		
		  The program type must be set.  Most likely we couldn't find a proper
		  section definition at load time, and thus we didn't infer the type.
 specify func_infoline_info only if kernel supports them 
 adjust load_attr if sec_def provides custom preload callback 
 Don't fail hard if can't bind rodata. 
 Wrong program type? 
 couldn't guess, but user might manually specify 
		 sec_def can have custom callback which should be called
		  after bpf_program is initialized to adjust its properties
 param validation 
 wrong default, but backwards-compatible 
 returning NULL is wrong, but backwards-compatible 
 we assume module_btf's BTF FD is always >0 
 find local type_id 
 find target type_id 
 set index for module BTF fd in fd_array, if unset 
 insn->off is s16 
 Cannot use index 0 for module BTF fd 
 we assume module BTF FD is always >0 
 reset FDs 
 clean up fd_array 
 clean up module BTFs 
 clean up vmlinux BTF 
 doesn't matter if successfully or not 
 unpin any maps that were auto-pinned during load 
 don't create subdirs when pinning single instance 
 don't create subdirs when pinning single instance 
 bpffs disallows periods in path names 
 Empty list is noticed here so don't need checking on entry. 
 Iter from the beginning 
 fill all fd with -1 
 "type" always has to have proper SEC("typeextras") form 
		 "type+" means it can be either exact SEC("type") or
		  well-formed SEC("typeextras") with proper '' separator
 not even a prefix 
 exact match or has '' separator 
		 SEC_SLOPPY_PFX definitions are allowed to be just prefix
		  matches, unless strict section name mode
		  (LIBBPF_STRICT_SEC_NAME) is enabled, in which case the
		  match has to be exact.
		 Definitions not marked SEC_SLOPPY_PFX (e.g.,
		  SEC("syscall")) are exact matches in both modes.
 Forge string buf with all available names 
 Collect the reloc from ELF and populate the st_ops->progs[] 
 prevent the use of BPF prog with invalid type 
		 if we haven't yet processed this BPF program, record proper
		  attach_btf_id and member_idx
		 struct_ops BPF prog can be re-used between multiple
		  .struct_ops as long as it's the same struct_ops struct
		  definition and the same function pointer field
	 snprintf returns the number of characters written excluding the
	  terminating null. So, if >= BTF_MAX_NAME_SIZE are written, it
	  indicates truncation.
 vmlinux BTF 
 BPF program's BTF ID 
 kernelmodule BTF ID 
	 Since libbpf started to support custom .data. and .rodata. maps,
	  their user-visible name differs from kernel-visible name. Users see
	  such map's corresponding ELF section name as a map name.
	  This check distinguishes .data.rodata from .data. and .rodata.
	  maps to know which name has to be returned to the user.
		 if it's a special internal map name (which always starts
		  with dot) then check if that special name matches the
		  real map name (ELF section name)
 otherwise map name has to be an exact match 
	 If ptr == NULL, then errno should be already set by the failing
	  API, because libbpf never returns NULL on success and it now always
	  sets errno on error. So no extra errno handling for ptr == NULL
	  case.
		
		  to preserve backwards compatibility, bpf_prog_load treats
		  attr->prog_type, if specified, as an override to whatever
		  bpf_object__open guessed
			
			  we haven't guessed from section name and user
			  didn't provide a fallback type, too bad...
 NULL, if not pinned 
 hook FD, -1 if not applicable 
 Replace link's underlying BPF program with the new one 
 Release "ownership" of underlying BPF resource (typically, BPF program
  attached to some BPF hook, e.g., tracepoint, kprobe, etc). Disconnected
  link, when destructed through bpf_link__destroy() call won't attempt to
  detachunregisted that BPF resource. This is useful in situations where,
  say, attached BPF program has to outlive userspace program that attached it
  in the system. Depending on type of BPF program, though, there might be
  additional steps (like pinning BPF program in BPF FS) necessary to ensure
  exit of userspace program doesn't trigger automatic detachment and clean up
  inside the kernel.
 legacy kprobe support: keep track of probe identifier and type 
 legacy uprobekprobe needs to be removed after perf event fd closure 
  this function is expected to parse integer in the range of [0, 2^31-1] from
  given file using scanf format string fmt. If actual parsed value is
  negative, the result might be indistinguishable from error
 kprobe_func or uprobe_path 
 kprobe_addr or probe_offset 
 pid filter is meaningful only for uprobes 
 pid ,
 cpu ,
 group_fd , PERF_FLAG_FD_CLOEXEC);
 pid 
 cpu 
 group_fd ,  PERF_FLAG_FD_CLOEXEC);
 uprobe , retprobe,
 pid , 0 
 pid );
 sanitize binary_path in the probe name 
 pid 
 cpu 
 group_fd ,  PERF_FLAG_FD_CLOEXEC);
 uprobe , retprobe, binary_path,
 pid , 0 
 group_fd , PERF_FLAG_FD_CLOEXEC);
 extract "tp<category><name>" or "tracepoint<category><name>" 
 Common logic for all BPF program types that attach to a btf_id 
 target_fdtarget_ifindex use the same field in LINK_CREATE 
		 no target, so use raw_tracepoint_open for compatibility
		  with old kernels
 if event_cb is specified, it takes precendence 
 sample_cb and lost_cb are higher-level common-case callbacks 
 mmap()'ed memory 
 for reconstructing segmented data 
 passed into callbacks 
 number of allocated CPU buffers 
 perf event FD 
 BPF_MAP_TYPE_PERF_EVENT_ARRAY BPF map FD 
 pid , cpu,
 best-effort sanity checks 
		 if BPF_OBJ_GET_INFO_BY_FD is supported, will return
		  -EBADFD, -EFAULT, or -E2BIG on real error
		 in case user didn't explicitly requested particular CPUs to
		  be attached to, skip offlinenot present CPUs
 user wants full control over parsing perf event 
 Return number of PERF_EVENT_ARRAY map slots set up by this perf_buffer
  manager.
  Return perf_event FD of a ring buffer in buf_idx slot of
  PERF_EVENT_ARRAY BPF map. This FD can be polled for new data using
  select()poll()epoll() Linux syscalls.
  Consume data from perf ring buffer corresponding to slot buf_idx in
  PERF_EVENT_ARRAY BPF map without waitingpolling. If there is no data to
  consume, do nothing and return success.
  Returns:
    - 0 on success;
    - <0 on failure.
 e.g. offset of jited_prog_insns 
 e.g. offset of jited_prog_len 
	int	size_offset;	 > 0: offset of rec size,
				  < 0: fix size of -size_offset
 step 1: get array dimensions 
 step 2: calculate total size of all arrays 
 kernel is too old to support this field 
 clear the bit 
 step 3: allocate continuous memory 
 step 4: fill data to info_linear->info 
 step 5: call syscall again to get required arrays 
 step 6: verify the data 
 step 7: update info_len and data_len 
		 remember attach_prog_fd and let bpf_program__load() find
		  BTF ID during the program load
 load btf_vmlinux, if not yet 
 Each sub string separated by ',' has format \d+-\d+ or \d+ 
	 Attempt to preserve opts->object_name, unless overriden by user
	  explicitly. Overwriting object name for skeletons is discouraged,
	  as it breaks global data maps, because they contain object name
	  prefix as their own map name prefix. When skeleton is generated,
	  bpftool is making an assumption that this name will stay the same.
 externs shouldn't be pre-setup from user code 
		 Remap anonymous mmap()-ed "map initialization image" as
		  a BPF map-backed mmap()-ed memory, but preserving the same
		  memory address. This will cause kernel to change process'
		  page table to point to a different piece of kernel memory,
		  but from userspace point of view memory address (and its
		  contents, being identical at this point) will stay the
		  same. This mapping will be released by bpf_object__close()
		  as per normal clean up procedure, so we don't need to worry
		  about it from skeleton's clean up perspective.
 auto-attaching not supported for this program 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  Ring buffer operations.
  Copyright (C) 2020 Facebook, Inc.
 Add extra RINGBUF maps to this ring buffer manager 
 Map writable consumer page 
	 Map read-only producer page and data pages. We map twice as big
	  data size to allow simple reading of samples that wrap around the
	  end of a ring buffer. See kernel implementation for details.
 clear out top 2 bits (discard and busy, if set) 
 add length prefix 
 round up to 8 byte alignment 
 64-bit to avoid overflow in case of extreme application behavior 
 sample not committed yet, bail out for now 
 update consumer pos and bail out 
 Consume available ring buffer(s) data without event polling.
  Returns number of records consumed across all registered ring buffers (or
  INT_MAX, whichever is less), or negative number if any of the callbacks
  return error.
 Poll for available data and consume records, if any are available.
  Returns number of records consumed (or INT_MAX, whichever is less), or
  negative number, if any of the registered callbacks returned error.
 Get an fd that can be used to sleep until data is available in the ring(s) 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 make sure libbpf doesn't use kernel-only integer typedefs 
  Wrapper to allow for building in non-GNU systems such as Alpine Linux's musl
  libc, while checking strerror_r() return to avoid having to check this in
  all places calling it.
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  common eBPF ELF operations.
  Copyright (C) 2013-2015 Alexei Starovoitov <ast@kernel.org>
  Copyright (C) 2015 Wang Nan <wangnan0@huawei.com>
  Copyright (C) 2015 Huawei Inc.
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation;
  version 2.1 of the License (not later!)
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Lesser General Public License for more details.
  You should have received a copy of the GNU Lesser General Public
  License along with this program; if not,  see <http:www.gnu.orglicenses>
  When building perf, unistd.h is overridden. __NR_bpf is
  required to be defined explicitly.
 zero out bytes kernel does not understand 
	 After bpf_prog_load, the kernel may modify certain attributes
	  to give user space a hint how to deal with loading failure.
	  Check to see whether we can make some changes and load again.
 try with corrected func info records 
 Try again with log 
 free() doesn't affect errno, so we don't need to restore it 
 validate we don't have unexpected combinations of non-zero fields 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  Generic non-thread safe hash map implementation.
  Copyright (c) 2019 Facebook
 make sure libbpf doesn't use kernel-only integer typedefs 
 prevent accidental re-addition of reallocarray() 
 start with 4 buckets 
 grow if empty or more than 75% filled 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 Copyright (c) 2021 Facebook 
 The following structure describes the stack layout of the loader program.
  In addition R6 contains the pointer to context.
  R7 contains the result of the last sys_bpf command (typically error or FD).
  R9 contains the result of the last sys_close command.
  Naming convention:
  ctx - bpf program context
  stack - bpf program stack
  blob - bpf_attr-s, strings, insns, map data.
         All the bytes that loader prog will use for readwrite.
 save ctx pointer into R6 
 bzero stack 
 amount of stack actually used, only used to calculate iterations, not stack offset 
 jump over cleanup code 
 size of cleanup code below (including map fd cleanup) 
			       6 insns for emit_sys_close_blob,
			        6 insns for debug_regs in emit_sys_close_blob
 remember the label where all error branches will jump to 
 emit cleanup code: close all temp FDs 
 R7 contains the error code from sys_bpf. Copy it into R0 and exit. 
 Get index for map_fdbtf_fd slot in reserved fd_array, or in data relative
  to start of fd_array. Caller can decide if it is usable or not.
 (u64 )(blob + off) = (u64)(void )(blob + data) 
		 If value in ctx is zero don't update the blob.
		  For example: when ctx->map.max_entries == 0, keep default max_entries from bpf.c
 remember the result in R7 
	 R7 contains result of last sys_bpf command.
	  if (R7 < 0) goto cleanup;
 reg1 and reg2 should not be R1 - R5. They can be R0, R6 - R10 
		 The special case to accommodate common debug_ret():
		  to avoid specifying BPF_REG_7 and adding " r=%%d" to
		  prints explicitly.
			       2 is the number of the following insns
			         6 is additional insns in debug_regs
 populate union bpf_attr with user provided log details 
 populate union bpf_attr with a pointer to the BTF data 
 emit BTF_LOAD command 
 remember btf_fd in the stack, if successful 
 populate union bpf_attr with btf_fd saved in the stack earlier 
 conditionally update max_entries 
 check that max_entries != 0 );
 emit MAP_CREATE command 
 remember map_fd in the stack, if successful 
		 This bpf_gen__map_create() function is called with map_idx >= 0
		  for all maps that libbpf loading logic tracks.
		  It's called with -1 to create an inner map.
 internal bug 
 add_map_fd does gen->nr_maps++ 
	 if successful, btf_id is in lower 32-bit of R7 and
	  btf_obj_fd is in upper 32-bit
 returns existing ksym_desc with ref incremented, or inserts a new one 
 Overwrites BPF_REG_{0, 1, 2, 3, 4, 7}
  Returns result in BPF_REG_7
 Overwrites BPF_REG_{0, 1, 2, 3, 4, 7}
  Returns result in BPF_REG_7
  Returns u64 symbol addr in BPF_REG_9
 res is u64 
 Expects:
  BPF_REG_8 - pointer to instruction
  We need to reuse BTF fd for same symbol otherwise each relocation takes a new
  index, while kernel limits total kfunc BTFs to 256. For duplicate symbols,
  this would mean a new BTF fd index for each entry. By pairing symbol name
  with index, we get the insn->imm, insn->off pairing that kernel uses for
  kfunc_tab, which becomes the effective limit even though all of them may
  share same index in fd_array (such that kfunc_btf_tab has 1 element).
 try to copy from existing bpf_insn 
 remember insn offset, so we can copy BTF ID and FD later 
 get index in fd_array to store BTF FD at 
 set a default value for imm 
 skip success case store if ret < 0 
 store btf_id into insn[insn_idx].imm 
 load fd_array slot pointer 
 skip store of BTF fd if ret < 0 
 store BTF fd in slot 
 set a default value for off 
 skip insn->off store if ret < 0 
 skip if vmlinux BTF 
 store index into insn[insn_idx].off 
 Expects:
  BPF_REG_8 - pointer to instruction
 try to copy from existing ldimm64 insn 
 remember insn offset, so we can copy ksym addr later 
 skip typeless ksym_desc in fd closing loop in cleanup_relos 
 store lower half of addr into insn[insn_idx].imm 
 store upper half of addr into insn[insn_idx + 1].imm 
 src_reg,dst_reg,... 
 dst_reg,src_reg,... 
 Expects:
  BPF_REG_8 - pointer to instruction
 try to copy from existing ldimm64 insn 
 jump over src_reg adjustment if imm is not 0 
 remember insn offset, so we can copy BTF ID and FD later 
 set default values as 0 
 skip success case stores if ret < 0 
 store btf_id into insn[insn_idx].imm 
 store btf_obj_fd into insn[insn_idx + 1].imm 
 clear bpf_object__relocate_data's src_reg assignment, otherwise we get a verifier failure 
 only close fds for typed ksyms and kfuncs 
 close fd recorded in insn[insn_idx + 1].imm 
 add license string to blob of bytes 
 add insns to blob of bytes 
 populate union bpf_attr with a pointer to license 
 populate union bpf_attr with a pointer to instructions 
 populate union bpf_attr with a pointer to func_info 
 populate union bpf_attr with a pointer to line_info 
 populate union bpf_attr fd_array with a pointer to data where map_fds are saved 
 populate union bpf_attr with user provided log details 
 populate union bpf_attr with btf_fd saved in the stack earlier 
 populate union bpf_attr with btf_id and btf_obj_fd found by helper 
 emit PROG_LOAD command 
 successful or not, close btf module FDs used in extern ksyms and attach_btf_obj_fd 
 remember prog_fd in the stack, if successful 
	 if (map_desc[map_idx].initial_value)
	     copy_from_user(value, initial_value, value_size);
 emit MAP_UPDATE_ELEM command 
 emit MAP_FREEZE command 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  BTF-to-C type converter.
  Copyright (c) 2019 Facebook
 per-type auxiliary state 
 topological sorting state 
 emitting state used to determine the need for forward declaration 
 whether forward declaration was already emitted 
 whether unique non-duplicate name was already assigned 
 whether type is referenced from any other type 
 indent string length; one indent string is added for each indent level 
  Common internal data for BTF type data dump operations.
 end of valid data to show 
 base indent level 
 below are used during iteration 
 per-type auxiliary state 
 per-type optional cached unique name, must be freed, if present 
 topo-sorted list of dependent type definitions 
	
	  stack of type declarations (e.g., chain of modifiers, arrays,
	  funcs, etc)
 maps structunionenum name to a number of name occurrences 
	
	  maps typedef identifiers and enum value names to a number of such
	  name occurrences
	
	  data for typed display; allocated if needed.
 VOID is special 
 eagerly determine referenced types for anon enums 
 any set cached name is owned by us and should be freed 
  Dump BTF type in a compilable C syntax, including all the necessary
  dependent types, necessary for compilation. If some of the dependent types
  were already emitted as part of previous btf_dump__dump_type() invocation
  for another type, they won't be emitted again. This API allows callers to
  filter out BTF types according to user-defined criterias and emitted only
  minimal subset of types, necessary to compile everything. Full structunion
  definitions will still be emitted, even if the only usage is through
  pointer and could be satisfied with just a forward declaration.
  Dumping is done in two high-level passes:
    1. Topologically sort type definitions to satisfy C rules of compilation.
    2. Emit type definitions in C syntax.
  Returns 0 on success; <0, otherwise.
top-level);
  Mark all types that are referenced from any other type. This is used to
  determine top-level anonymous enums that need to be emitted as an
  independent type declarations.
  Anonymous enums come in two flavors: either embedded in a struct's field
  definition, in which case they have to be declared inline as part of field
  type declaration; or as a top-level anonymous enum, typically used for
  declaring global constants. It's impossible to distinguish between two
  without knowning whether given enum type was referenced from other type:
  top-level anonymous enum won't be referenced by anything, while embedded
  one will.
  Determine order of emitting dependent types and specified type to satisfy
  C compilation rules.  This is done through topological sorting with an
  additional complication which comes from C rules. The main idea for C is
  that if some type is "embedded" into a structunion, it's size needs to be
  known at the time of definition of containing type. E.g., for:
 	struct A {};
 	struct B { struct A x; }
  struct A HAS to be defined before struct B, because it's "embedded",
  i.e., it is part of struct B layout. But in the following case:
 	struct A;
 	struct B { struct A x; }
 	struct A {};
  it's enough to just have a forward declaration of struct A at the time of
  struct B definition, as struct B has a pointer to struct A, so the size of
  field x is known without knowing struct A size: it's sizeof(void ).
  Unfortunately, there are some trickier cases we need to handle, e.g.:
 	struct A {};  if this was forward-declaration: compilation error
 	struct B {
 		struct {  anonymous struct
 			struct A y;
 		} x;
 	};
  In this case, struct B's field x is a pointer, so it's size is known
  regardless of the size of (anonymous) struct it points to. But because this
  struct is anonymous and thus defined inline inside struct B, and it
  embeds struct A, compiler requires full definition of struct A to be known
  before struct B can be defined. This creates a transitive dependency
  between struct A and struct B. If struct A was forward-declared before
  struct B definition and fully defined after struct B definition, that would
  trigger compilation error.
  All this means that while we are doing topological sorting on BTF type
  graph, we need to determine relationships between different types (graph
  nodes):
    - weak link (relationship) between X and Y, if Y CAN be
    forward-declared at the point of X definition;
    - strong link, if Y HAS to be fully-defined before X can be defined.
  The rule is as follows. Given a chain of BTF types from X to Y, if there is
  BTF_KIND_PTR type in the chain and at least one non-anonymous type
  Z (excluding X, including Y), then link is weak. Otherwise, it's strong.
  Weakstrong relationship is determined recursively during DFS traversal and
  is returned as a result from btf_dump_order_type().
  btf_dump_order_type() is trying to avoid unnecessary forward declarations,
  but it is not guaranteeing that no extraneous forward declarations will be
  emitted.
  To avoid extra work, algorithm marks some of BTF types as ORDERED, when
  it's done with them, but not for all (e.g., VOLATILE, CONST, RESTRICT,
  ARRAY, FUNC_PROTO), as weakstrong semantics for those depends on the
  entire graph path, so depending where from one came to that BTF type, it
  might cause weak or strong ordering. For types like STRUCTUNIONINTENUM,
  once they are processed, there is no need to do it again, so they are
  marked as ORDERED. We can mark PTR as ORDERED as well, as it semi-forces
  weak link, unless subsequent referenced STRUCTUNIONENUM is anonymous. But
  in any case, once those are processed, no need to do it again, as the
  result won't change.
  Returns:
    - 1, if type is part of strong link (so there is strong topological
    ordering requirements);
    - 0, if type is part of weak link (so can be satisfied through forward
    declaration);
    - <0, on error (e.g., unsatisfiable type loop detected).
	
	  Order state is used to detect strong link cycles, but only for BTF
	  kinds that are or could be an independent definition (i.e.,
	  stand-alone fwd decl, enum, typedef, struct, union). Ptrs, arrays,
	  func_protos, modifiers are just means to get to these definitions.
	  Intvoid don't need definitions, they are assumed to be always
	  properly defined.  We also ignore datasec, var, and funcs for now.
	  So for all non-defining kinds, we never even set ordering state,
	  for defining kinds we set ORDERING and subsequently ORDERED if it
	  forms a strong link.
 return true, letting typedefs know that it's ok to be emitted 
 type loop, but resolvable through fwd declaration 
		
		  structunion is part of strong link, only if it's embedded
		  (so no ptr in a path) or it's anonymous (so has to be
		  defined inline, even if declared through ptr)
		
		  non-anonymous or non-referenced enums are top-level
		  declarations and should be emitted. Same logic can be
		  applied to FWDs, it won't hurt anyways.
 typedef is similar to structunion w.r.t. fwd-decls 
 typedef is always a named definition 
 a local view into a shared stack 
	 __builtin_va_list is a compiler built-in, which causes compilation
	  errors, when compiling w different compiler, then used to compile
	  original code (e.g., GCC to compile kernel, Clang to use generated
	  C header from BTF). As it is built-in, it should be already defined
	  properly internally in compiler.
  Emit C-syntax definitions of types from chains of BTF types.
  High-level handling of determining necessary forward declarations are handled
  by btf_dump_emit_type() itself, but all nitty-gritty details of emitting type
  declarationsdefinitions in C syntax  are handled by a combo of
  btf_dump_emit_type_decl()btf_dump_emit_type_chain() w delegation to
  corresponding btf_dump_emit__{def,fwd}() functions.
  We also keep track of "containing structunion type ID" to determine when
  we reference it from inside and thus can avoid emitting unnecessary forward
  declaration.
  This algorithm is designed in such a way, that even if some error occurs
  (either technical, e.g., out of memory, or logical, i.e., malformed BTF
  that doesn't comply to C rules completely), algorithm will try to proceed
  and produce as much meaningful output as possible.
			
			  if we are referencing a structunion that we are
			  part of - then no need for fwd declaration
			
			  for typedef fwd_emitted means typedef definition
			  was emitted, but it can be used only for "weak"
			  references through pointer only, not for embedding
 Emit type alias definitions if necessary 
		
		  typedef can server as both definition and forward
		  declaration; at this stage someone depends on
		  typedef as a forward declaration (refers to it
		  through pointer), so unless we already did it,
		  emit typedef as a forward declaration
		 if it's a top-level structunion definition or structunion
		  is anonymous, then in C we'll be emitting all fields and
		  their types (as opposed to just `struct X`), so we need to
		  make sure that all types, referenced from structunion
		  members have necessary forward-declarations, where
		  applicable
 size of a non-packed struct has to be a multiple of its alignment
 all non-bitfield fields have to be naturally aligned 
	
	  if original struct was marked as packed, but its layout is
	  naturally aligned, we'll detect that it's not packed
 no gap 
 natural padding will take care of a gap 
 pad at the end, if necessary 
	
	  GCC emits typedefs to its internal __PolyX_t types when compiling Arm
	  SIMD intrinsics. Alias them to standard base types.
 enumerators share namespace with typedef idents 
	
	  Old GCC versions are emitting invalid typedef for __gnuc_va_list
	  pointing to VOID. This generates warnings from btf_dump() and
	  results in uncompilable header file, so we are fixing it up here
	  with valid typedef into __builtin_va_list.
  Emit type declaration (e.g., field type declaration in a struct or argument
  declaration in function prototype) in correct C syntax.
  For most types it's trivial, but there are few quirky type declaration
  cases worth mentioning:
    - function prototypes (especially nesting of function prototypes);
    - arrays;
    - constvolatilerestrict for pointers vs other types.
  For a good discussion of PARSING C syntax (as a human), see
  Peter van der Linden's "Expert C Programming: Deep C Secrets",
  Ch.3 "Unscrambling Declarations in C".
  It won't help with BTF to C conversion much, though, as it's an opposite
  problem. So we came up with this algorithm in reverse to van der Linden's
  parsing algorithm. It goes from structured BTF representation of type
  declaration to a valid compilable C syntax.
  For instance, consider this C typedef:
 	typedef const int  const  arr[10] arr_t;
  It will be represented in BTF with this chain of BTF types:
 	[typedef] -> [array] -> [ptr] -> [const] -> [ptr] -> [const] -> [int]
  Notice how [const] modifier always goes before type it modifies in BTF type
  graph, but in C syntax, constvolatilerestrict modifiers are written to
  the right of pointers, but to the left of other types. There are also other
  quirks, like function pointers, arrays of them, functions returning other
  functions, etc.
  We handle that by pushing all the types to a stack, until we hit "terminal"
  type (intenumstructunionfwd). Then depending on the kind of a type on
  top of a stack, modifiers are handled differently. Arrayfunction pointers
  have also wildly different syntax and how nesting of them are done. See
  code for authoritative definition.
  To avoid allocating new stack for each independent chain of BTF types, we
  share one bigger stack, with each chain working only on its own local view
  of a stack frame. Some care is required to "pop" stack frames after
  processing type declaration chain.
			
			  if we don't have enough memory for entire type decl
			  chain, restore stack, emit warning, and try to
			  proceed nevertheless
 VOID 
	
	  We might be inside a chain of declarations (e.g., array of function
	  pointers returning anonymous (so inlined) structs, having another
	  array field). Each of those needs its own "stack frame" to handle
	  emitting of declarations. Those stack frames are non-overlapping
	  portions of shared btf_dump->decl_stack. To make it a bit nicer to
	  handle this set of nested stacks, we create a view corresponding to
	  our own "stack frame" and work with it as an independent stack.
	  We'll need to clean up after emit_type_chain() returns, though.
	
	  emit_type_chain() guarantees that it will pop its entire decl_stack
	  frame before returning. But it works with a read-only view into
	  decl_stack, so it doesn't actually pop anything from the
	  perspective of shared btf_dump->decl_stack, per se. We need to
	  reset decl_stack state to how it was before us to avoid it growing
	  all the time.
	
	  last_was_ptr is used to determine if we need to separate pointer
	  asterisk () from previous part of type signature with space, so
	  that we get `int `, instead of `int   `. We default to true
	  for cases where we have single pointer in a chain. E.g., in ptr ->
	  func_proto case. func_proto will start a new emit_type_chain call
	  with just ptr, which should be emitted as () or (<fname>), so we
	  don't want to prepend space for that last pointer.
 VOID is a special snowflake 
 inline anonymous structunion 
 inline anonymous enum 
			
			  GCC has a bug
			  (https:gcc.gnu.orgbugzillashow_bug.cgi?id=8354)
			  which causes it to emit extra constvolatile
			  modifiers for an array, if array's element type has
			  constvolatile modifiers. Clang doesn't do that.
			  In general, it doesn't seem very meaningful to have
			  a constvolatile modifier for array, so we are
			  going to silently skip them here.
 we need space if we have named non-pointer 
 no parentheses for multi-dimensional array 
			
			  GCC emits extra volatile qualifier for
			  __attribute__((noreturn)) function pointers. Clang
			  doesn't do it. It's a GCC quirk for backwards
			  compatibility with code written for GCC <2.5. So,
			  similarly to extra qualifiers for array, just drop
			  them, instead of handling them.
			
			  Clang for BPF target generates func_proto with no
			  args as a func_proto with a single void arg (e.g.,
			  `int (f)(void)` vs just `int (f)()`). We are
			  going to pretend there are no args for such case.
 last arg of type void is vararg 
 show type name as (type_name) 
	 for array members, we don't bother emitting type name for each
	  member to avoid the redundancy of
	  .name = (char[4])[(char)'f',(char)'o',(char)'o',]
	 avoid type name specification for variablesection; it will be done
	  for the associated variable value(s).
 return number of duplicates (occurrences) of a given name 
 A macro is used here as btf_type_value[s]() appends format specifiers
  to the format specifier passed in; these do the work of appending
  delimiters etc while the caller simply has to specify the type values
  in the format specifier + value(s).
 Maximum supported bitfield size is 64 bits 
	 Bitfield value retrieval is done in two steps; first relevant bytes are
	  stored in num, then we leftright shift num to eliminate irrelevant bits.
 ints, floats and ptrs 
	 For pointer types, pointer size is not defined on a per-type basis.
	  On dump creation however, we store the pointer size.
	 handle packed int data - accesses of integers not aligned on
	  int boundaries can cause problems on some platforms.
		 avoid use of __int128 as some 32-bit platforms do not
		  support it.
 check for null terminator 
 handle unaligned data; copy to local union 
	 format of output here is [linkage] [type] [varname] = (type)value,
	  for example "static int cpu_profile_flip = (int)1"
		
		  BTF_INT_CHAR encoding never seems to be set for
		  char arrays, so if size is 1 and element is
		  printable as a char, we'll do that.
	 note that we increment depth before calling btf_dump_print() below;
	  this is intentional.  btf_dump_data_newline() will not print a
	  newline for depth 0 (since this leaves us with trailing newlines
	  at the end of typed display), so depth is incremented first.
	  For similar reasons, we decrement depth before showing the closing
	  parenthesis.
	 may be a multidimensional array, so store current "is array member"
	  status so we can restore it correctly later.
	 note that we increment depth before calling btf_dump_print() below;
	  this is intentional.  btf_dump_data_newline() will not print a
	  newline for depth 0 (since this leaves us with trailing newlines
	  at the end of typed display), so depth is incremented first.
	  For similar reasons, we decrement depth before showing the closing
	  parenthesis.
 handle unaligned enum value 
 return size of type, or if base type overflows, return -E2BIG. 
	 Only do overflow checking for base types; we do not want to
	  avoid showing part of a struct, union or array, even if we
	  do not have enough data to show the full object.  By
	  restricting overflow checking to base types we can ensure
	  that partial display succeeds, while avoiding overflowing
	  and using bogus data for display.
	 toplevel exceptions; we show zero values if
	  - we ask for them (emit_zeros)
	  - if we are at top-level so we see "struct empty { }"
	  - or if we are an array member and the array is non-empty and
	    not a char array; we don't want to be in a situation where we
	    have an integer array 0, 1, 0, 1 and only show non-zero values.
	    If the array contains zeroes only, or is a char array starting
	    with a '\0', the array-level check_zero() will prevent showing it;
	    we are concerned with determining zero value at the array member
	    level here.
		 check all elements; if _any_ element is nonzero, all
		  of array is displayed.  We make an exception however
		  for char arrays where the first element is 0; these
		  are considered zeroed also, even if later elements are
		  non-zero because the string is terminated.
		 if any structunion member is non-zero, the structunion
		  is considered non-zero and dumped.
			 btf_int_bits() does not store member bitfield size;
			  bitfield size needs to be stored here so int display
			  of member can retrieve it.
 returns size of data dumped, or error. 
		 zeroed data is expected and not an error, so simply skip
		  dumping such data.  Record other errors however.
 handle bitfield and int enum values 
 default indent string is a tab 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  BPF static linker
  Copyright (c) 2021 Facebook
 positional (not necessarily ELF) index in an array of sections 
 positional (not necessarily ELF) index of a matching section in a final object file 
 section data offset in a matching output section 
 whether section is omitted from the final ELF file 
 whether section is an ephemeral section, not mapped to an ELF section 
 ELF info 
 corresponding BTF DATASEC type ID 
 Section header strings section index 
 SYMTAB section index 
 List of sections (including ephemeral). Slot zero is unused. 
 mapping of symbol indices from src to dst ELF 
 mapping from the src BTF type IDs to dst ones 
 single .BTF.ext data section 
 ELF symbol index 
 associated section id for .ksyms, .kconfig, etc, but not .extern 
 extern name offset in STRTAB 
 optional associated BTF type ID 
	 BTF type ID to which VARFUNC type is pointing to; used for
	  rewriting types when extern VARFUNC is resolved to a concrete
	  definition
 sec_var index in the corresponding dst_sec, if exists 
 extern or resolvedglobal symbol 
 weak or strong symbol, never goes back from strong to weak 
 positional (not necessarily ELF) index in an array of sections 
 ELF info 
 final output section size 
 final output contents of the section 
 corresponding STT_SECTION symbol index in SYMTAB 
 section's DATASEC variable info, emitted on BTF finalization 
 section's .BTF.ext data 
 Output sections metadata 
 STRTAB unique strings 
 STRTAB section index 
 SYMTAB section index 
 global (including extern) ELF symbols 
 zero out newly allocated memory 
 ELF header 
 STRTAB 
 initialize strset with an empty string to conform to ELF 
 SYMTAB 
	 sh_info should be one greater than the index of the last local
	  symbol (i.e., binding is STB_LOCAL). But why and who cares?
 .BTF 
 add the special all-zero symbol 
 free up src_obj resources 
 approximation, but the actual list is too long 
 no special handling of .strtab 
 ignore .llvm_addrsig section as well 
 no subprograms will lead to an empty .text section, ignore it 
 DWARF sections 
 DWARF section relocations 
 .BTF and .BTF.ext don't need relocations 
 zero out newly allocated memory 
 Sanity check ELF file high-level properties 
 we'll construct our own string table 
 data & code 
 BSS 
 relocations 
 SHT_REL's sh_link should point to SYMTAB 
 SHT_REL's sh_info points to relocated section 
 .rel<secname> -> <secname> pattern is followed 
 don't further validate relocations for ignored sections 
 relocatable section is data or instructions 
 check sanity of each relocation 
 can't use .BTF.ext without .BTF 
 ephemeral sections are just thin section shells lacking most parts 
	 sh_link and sh_info have different meaning for different types of
	  sections, so we leave it up to the caller code to fill them in, if
	  necessary
	 Ephemeral source section doesn't contribute anything to ELF
	  section data.
	 Some sections (like .maps) can contain both externs (and thus be
	  ephemeral) and non-externs (map definitions). So it's possible that
	  it has to be "upgraded" from ephemeral to non-ephemeral when the
	  first non-ephemeral entity appears. In such case, we add ELF
	  section, data, etc.
 no need to re-align final size 
 pad dst section, if it's alignment forced size increase 
 now copy src data at a properly aligned offset 
 ephemeral sections are data sections, e.g., .kconfig, .ksyms 
 "license" and "version" sections are deduped 
 record mapped section index 
		 We already validated all-zero symbol #0 and we already
		  appended it preventively to the final SYMTAB, so skip it.
 check if only one side is FWD, otherwise handle with common logic 
 validate if FWD kind matches concrete kind 
 void 
 ignore encoding for int and enum values for enum 
		 just validate overall shape of the referenced type, so no
		  contents comparison for structunion, and allowd fwd vs
		  structunion
 ignore index type and array size 
 extern and global linkages are compatible 
 extern and global linkages are compatible 
 ignore func arg names 
 now check return type as well 
 skip_mods_and_typedefs() make this impossible 
 DATASECs are never compared with each other 
 check key typesize match 
exact,
 validate value typesize match 
exact,
strict, &src_def, &src_inner_def);
 re-parse existing map definition 
strict, &dst_def, &dst_inner_def);
 this should not happen, because we already validated it 
	 Currently extern map definition has to be complete and match
	  concrete map definition exactly. This restriction might be lifted
	  in the future.
	 if we are dealing with externs, BTF types describing both global
	  and extern VARsFUNCs should be completely present in all files
 deal with .maps definitions specially 
exact,
		 some global and extern FUNCs and VARs might not be associated with any
		  DATASEC, so try to detect them in the same pass
 remember and still try to find DATASEC 
 free-floating extern or global FUNC 
	 We already made sure that source and destination types (FUNC or
	  VAR) match in terms of types and argument names.
 now onto FUNC_PROTO types 
	 Fill in all the argument names, which for extern FUNCs are missing.
	  We'll end up with two copies of FUNCsVARs for externs, but that
	  will be taken care of by BTF dedup at the very end.
	  It might be that BTF types for extern in one file has lessmore BTF
	  information (e.g., FWD instead of full STRUCTUNION information),
	  but that should be (in most cases, subject to BTF dedup rules)
	  handled and resolved by BTF dedup algorithm as well, so we won't
	  worry about it. Our only job is to make sure that argument names
	  are populated on both sides, otherwise BTF dedup will pedantically
	  consider them different.
 src_btf has more complete info, so add name to dst_btf 
	 libelf doesn't provide setters for ST_VISIBILITY,
	  but it is stored in the lower 2 bits of st_other
 allow only one STT_SECTION symbol per section 
 find matching BTF info 
		 Clang puts unannotated extern vars into
		  '.extern' BTF DATASEC. Treat them the same
		  as unannotated extern funcs (which are
		  currently not put into any DATASECs).
		  Those don't have associated src_secdst_sec.
		 Preventively resolve to existing symbol. This is
		  needed for further relocation symbol remapping in
		  the next step of linking.
		 If both symbols are non-externs, at least one of
		  them has to be STB_WEAK, otherwise they are in
		  a conflict with each other.
		 If new symbol is strong, then force dst_sym to be strong as
		  well; this way a mix of weak and non-weak extern
		  definitions will end up being strong.
			 We still need to preserve type (NOTYPE or
			  OBJECTFUNC, depending on whether the symbol is
			  extern or not)
		 Non-default visibility is "contaminating", with stricter
		  visibility overwriting more permissive ones, even if more
		  permissive visibility comes from just an extern definition.
		  Currently only STV_DEFAULT and STV_HIDDEN are allowed and
		  ensured by ELF symbol sanity checks above.
		 If the new symbol is extern, then regardless if
		  existing symbol is extern or resolved global, just
		  keep the existing one untouched.
		 If existing symbol is a strong resolved symbol, bail out,
		  because we lost resolution battle have nothing to
		  contribute. We already checked abover that there is no
		  strong-strong conflict. We also already tightened binding
		  and visibility, so nothing else to contribute at that point.
		 At this point, new symbol is strong non-extern,
		  so overwrite glob_sym with new symbol information.
		  Preserve binding and visibility.
 see comment below about dst_sec->id vs dst_sec->sec_idx 
 request updating VAR'sFUNC's underlying BTF type when appending BTF type 
		 we use dst_sec->id (and not dst_sec->sec_idx), because
		  ephemeral sections (.kconfig, .ksyms, etc) don't have
		  sec_idx (as they don't have corresponding ELF section), but
		  still have id. .extern doesn't have even ephemeral section
		  associated with it, so dst_sec->id == dst_sec->sec_idx == 0.
 we will fill btf_id in during BTF merging step 
 shdr->sh_info points to relocatable section 
 shdr->sh_link points to SYMTAB 
 shdr->sh_info points to relocated section 
					 calls to the very first static function inside
					  .text section at offset 0 will
					  reference section symbol, not the
					  function symbol. Fix that up,
					  otherwise it won't be possible to
					  relocate calls to two different
					  static functions with the same name
					  (rom two different object files)
 record actual section size, unless ephemeral 
			 BTF can have some sections that are not represented
			  in ELF, e.g., .kconfig, .ksyms, .extern, which are used
			  for special extern variables.
			 
			  For all but one such special (ephemeral)
			  sections, we pre-create "section shells" to be able
			  to keep track of extra per-section metadata later
			  (e.g., those BTF extern variables).
			 
			  .extern is even more special, though, because it
			  contains extern variables that need to be resolved
			  by static linker, not libbpf and kernel. When such
			  externs are resolved, we are going to remove them
			  from .extern BTF section and might end up not
			  needing it at all. Each resolved extern should have
			  matching non-extern VARFUNC in other sections.
			 
			  We do support leaving some of the externs
			  unresolved, though, to support cases of building
			  libraries, which will later be linked against final
			  BPF applications. So if at finalization we still
			  see unresolved externs, we'll create .extern
			  section on our own.
 will match UNDEF shndx in ELF 
 remember ELF section and its BTF type ID match 
 fix up variable offsets 
 no need to patch up static or extern vars 
 Error out if the type wasn't remapped. Ignore VOID which stays VOID. 
 DATASECs are handled specially below 
 there should be glob_sym already 
			 VARs without corresponding glob_sym are those that
			  belong to skippeddeduplicated sections (i.e.,
			  license and version), so just skip them
			 linker_append_elf_sym() might have requested
			  updating underlying type ID, if extern was resolved
			  to strong symbol or weak got upgraded to non-weak
			 globals from previous object files that match our
			  VARFUNC already have a corresponding associated
			  BTF type, so just make sure to use it
 reuse existing BTF type for global varfunc 
 record just appended BTF type for varfunc 
 remap all the types except DATASECs 
	 Rewrite VARFUNC underlying types (i.e., FUNC's FUNC_PROTO and VAR's
	  actual type), if necessary
 append DATASEC info 
		 Mark section as having BTF regardless of the presence of
		  variables. In some cases compiler might generate empty BTF
		  with no variables information. E.g., when promoting local
		  arraystructure variable initial values and BPF object
		  file otherwise has no read-only static variables in
		  .rodata. We need to preserve such empty BTF and just set
		  correct section size.
			 If there is already a member (VAR or FUNC) mapped
			  to the same type, don't add a duplicate entry.
			  This will happen when multiple object files define
			  the same extern VARsFUNCs.
				 Because underlying BTF type might have
				  changed, so might its size have changed, so
				  re-calculate and update it in sec_var.
 dst_rec->line_col is fine 
 dst_rec->kind is fine 
 Finalize strings 
 STRTAB is handled specially above 
 special ephemeral sections (.ksyms, .kconfig, etc) 
 Finalize ELF layout 
 Write out final ELF contents 
 bail out if no BTF data was produced 
 Emit .BTF section 
 Emit .BTF.ext section 
	 validate that all sections have the same .BTF.ext record sizes
	  and calculate total data size for each type of data (func info,
	  line info, core relos)
 record size prefix 
 record size prefix 
 record size prefix 
 All offsets are in bytes relative to the end of this header 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 Copyright (c) 2019 Facebook 
 represents BPF CO-RE field or array element accessor 
 structunion type or array element type 
 field index or array index 
 field name or NULL for array accessor 
 high-level spec: named fields and array indices only 
 original unresolved (no skip_mods_or_typedefs) root type ID 
 CO-RE relocation kind 
 high-level spec length 
 raw, low-level spec: 1-to-1 with accessor spec string 
 raw spec length 
 field bit offset represented by spec 
 not a flexible array, if not inside a struct or has non-zero size 
 has to be the last member of enclosing struct 
  Turn bpf_core_relo into a low- and high-level spec representation,
  validating correctness along the way, as well as calculating resulting
  field bit offset, specified by accessor string. Low-level spec captures
  every single level of nestedness, including traversing anonymous
  structunion members. High-level one only captures semantically meaningful
  "turning points": named fields and array indicies.
  E.g., for this case:
    struct sample {
        int __unimportant;
        struct {
            int __1;
            int __2;
            int a[7];
        };
    };
    struct sample s = ...;
    int x = &s->a[3];  access string = '0:1:2:3'
  Low-level spec has 1:1 mapping with each element of access string (it's
  just a parsed access string representation): [0, 1, 2, 3].
  High-level spec will capture only 3 points:
    - intial zero-index access by pointer (&s->... is the same as &s[0]...);
    - field 'a' access (corresponds to '2' in low-level spec);
    - array element #3 access (corresponds to '3' in low-level spec).
  Type-based relocations (TYPE_EXISTSTYPE_SIZE,
  TYPE_ID_LOCALTYPE_ID_TARGET) don't capture any field information. Their
  spec and raw_spec are kept empty.
  Enum value-based relocations (ENUMVAL_EXISTSENUMVAL_VALUE) use access
  string to specify enumerator's value index that need to be relocated.
 type-based relocations don't have a field access string 
 parse spec_str="0:1:2:3:4" into array raw_spec=[0, 1, 2, 3, 4] 
 record enumerator name in a first accessor 
 Check two types for compatibility for the purpose of field access
  relocation. constvolatilerestrict and typedefs are skipped to ensure we
  are relocating semantically compatible entities:
    - any two STRUCTsUNIONs are compatible and can be mixed;
    - any two FWDs are compatible, if their names match (modulo flavor suffix);
    - any two PTRs are always compatible;
    - for ENUMs, names should be the same (ignoring flavor suffix) or at
      least one of enums should be anonymous;
    - for ENUMs, check sizes, names are ignored;
    - for INT, size and signedness are ignored;
    - any two FLOATs are always compatible;
    - for ARRAY, dimensionality is ignored, element types are checked for
      compatibility recursively;
    - everything else shouldn't be ever a target of relocation.
  These rules are not set in stone and probably will be adjusted as we get
  more experience with using BPF CO-RE relocations.
 one of them is anonymous or both w same flavor-less names 
		 just reject deprecated bitfield-like integers; all other
		  integers are by default compatible between each other
  Given single high-level named field accessor in local type, find
  corresponding high-level accessor for a target type. Along the way,
  maintain low-level spec for target as well. Also keep updating target
  bit offset.
  Searching is performed through recursive exhaustive enumeration of all
  fields of a structunion. If there are any anonymous (embedded)
  structsunions, they are recursively searched as well. If field with
  desired name is found, check compatibility between local and target types,
  before returning result.
  1 is returned, if field is found.
  0 is returned if no compatible field is found.
  <0 is returned on error.
 too deep structunionarray nesting 
 speculate this member will be the good one 
 embedded structunion, we need to go deeper 
 either found or error 
 matching named field 
 pop accessor 
 member turned out not to be what we looked for 
  Try to match local spec to a target type and, if successful, produce full
  target spec (high-level, low-level + bit offset).
 has to resolve to an enum 
			 for i=0, targ_id is already treated as array element
			  type (because it's the original struct), for others
			  we should find array element type first
 too deep structunionarray nesting 
 request instruction poisoning 
 a[n] accessor needs special handling 
 remember field size for loadstore mem size 
 figure out smallest int size necessary for bitfield load 
 bitfield can't be read with 64-bit read 
	 for bitfields, all the relocatable aspects are ambiguous and we
	  might disagree with compiler, so turn off validation of expected
	  value, except for signedness
 enums will be assumed unsigned 
 signedness is never ambiguous 
 right shift is never ambiguous 
 type-based relos return zero when target type is not found 
 BPF_TYPE_ID_LOCAL is handled specially and shouldn't get here 
 request instruction poisoning 
 expected value in the instruction, unless validate == false 
 new value that needs to be patched up to 
 relocation unsuccessful, poison instruction, but don't fail load 
 some relocations can't be validated against orig_val 
	 for field byte offset relocations or the forms:
	      (T )(rX + <off>) = rY
	      rX = (T )(rY + <off>),
	  we remember original and resolved field size to adjust direct
	  memory loads of pointers and integers; this is necessary for 32-bit
	  host kernel architectures, but also allows to automatically
	  relocate fields that were resized from, e.g., u32 to u64, etc.
 Calculate original and target relocation values, given local and target
  specs and relocation kind. These values are calculated for each candidate.
  If there are multiple candidates, resulting values should all be consistent
  with each other. Otherwise, libbpf will refuse to proceed due to ambiguity.
  If instruction has to be poisoned, poison will be set to true.
		 Validate if it's safe to adjust loadstore memory size.
		  Adjustments are performed only if original and new memory
		  sizes differ.
			 There are two use cases in which it's safe to
			  adjust loadstore's mem size:
			    - reading a 32-bit kernel pointer, while on BPF
			    size pointers are always 64-bit; in this case
			    it's safe to "downsize" instruction size due to
			    pointer being treated as unsigned integer with
			    zero-extended upper 32-bits;
			    - reading unsigned integers, again due to
			    zero-extension is preserving the value correctly.
			 
			  In all other cases it's incorrect to attempt to
			  loadstore field because read value will be
			  incorrect, so we poison relocated instruction.
			 mark as invalid mem size adjustment, but this will
			  only be checked for LDXSTXST insns
 EUCLEAN is used to signal instruction poisoning request 
 EOPNOTSUPP means unknownunsupported relocation 
  Turn instruction for which CO_RE relocation failed into invalid one with
  distinct signature.
	 if this instruction is reachable (not a dead code),
	  verifier will complain with the following message:
	  invalid func unknown#195896080
 => 0xbad2310 => "bad relo" 
  Patch relocatable BPF instruction.
  Patched value is determined by relocation kind and target specification.
  For existence relocations target spec will be NULL if fieldtype is not found.
  Expected insn->imm value is determined using relocation kind and local
  spec, and is checked before patching instruction. If actual insn->imm value
  is wrong, bail out with error.
  Currently supported classes of BPF instruction are:
  1. rX = <imm> (assignment with immediate operand);
  2. rX += <imm> (arithmetic operations with immediate operand);
  3. rX = <imm64> (load with 64-bit immediate value);
  4. rX = (T )(rY + <off>), where T is one of {u8, u16, u32, u64};
  5. (T )(rX + <off>) = rY, where T is one of {u8, u16, u32, u64};
  6. (T )(rX + <off>) = <imm>, where T is one of {u8, u16, u32, u64}.
		 poison second part of ldimm64 to avoid confusing error from
		  verifier about "unknown opcode 00"
 currently only 32-bit values are supported 
 Output spec definition in the format:
  [<type-id>] (<type-name>) + <raw-spec> => <offset>@<spec>,
  where <spec> is a C-syntax view of recorded field access, e.g.: x.a[3].b
  CO-RE relocate single instruction.
  The outline and important points of the algorithm:
  1. For given local type, find corresponding candidate target types.
     Candidate type is a type with the same "essential" name, ignoring
     everything after last triple underscore (___). E.g., `sample`,
     `sample___flavor_one`, `sample___flavor_another_one`, are all candidates
     for each other. Names with triple underscore are referred to as
     "flavors" and are useful, among other things, to allow to
     specifysupport incompatible variations of the same kernel struct, which
     might differ between different kernel versions andor build
     configurations.
     N.B. Struct "flavors" could be generated by bpftool's BTF-to-C
     converter, when deduplicated BTF of a kernel still contains more than
     one different types with the same name. In that case, ___2, ___3, etc
     are appended starting from second name conflict. But start flavors are
     also useful to be defined "locally", in BPF program, to extract same
     data from incompatible changes between different kernel
     versionsconfigurations. For instance, to handle field renames between
     kernel versions, one can use two flavors of the struct name with the
     same common name and use conditional relocations to extract that field,
     depending on target kernel version.
  2. For each candidate type, try to match local specification to this
     candidate target type. Matching involves finding corresponding
     high-level spec accessors, meaning that all named fields should match,
     as well as all array accesses should be within the actual bounds. Also,
     types should be compatible (see bpf_core_fields_are_compat for details).
  3. It is supported and expected that there might be multiple flavors
     matching the spec. As long as all the specs resolve to the same set of
     offsets across all candidates, there is no error. If there is any
     ambiguity, CO-RE relocation will fail. This is necessary to accomodate
     imprefection of BTF deduplication, which can cause slight duplication of
     the same BTF type, if some directly or indirectly referenced (by
     pointer) type gets resolved to different actual types in different
     object files. If such situation occurs, deduplicated BTF will end up
     with two (or more) structurally identical types, which differ only in
     types they refer to through pointer. This should be OK in most cases and
     is not an error.
  4. Candidate types search is performed by linearly scanning through all
     types in target BTF. It is anticipated that this is overall more
     efficient memory-wise and not significantly worse (if not better)
     CPU-wise compared to prebuilding a map from all local type names to
     a list of candidate type names. It's also sped up by caching resolved
     list of matching candidates per each local "root" type ID, that has at
     least one bpf_core_relo associated with it. This list is shared
     between multiple relocations for the same type ID and is updated as some
     of the candidates are pruned due to structural incompatibility.
 TYPE_ID_LOCAL relo is special and doesn't need candidate search 
 libbpf doesn't support candidate search for anonymous types 
			 if there are many field relo candidates, they
			  should all resolve to the same bit offset
			 all candidates should result in the same relocation
			  decision and value, otherwise it's dangerous to
			  proceed due to ambiguity
	
	  For BPF_FIELD_EXISTS relo or when used BPF program has field
	  existence checks or kernel versionconfig checks, it's expected
	  that we might not find any candidates. In this case, if field
	  wasn't found in any candidate, the list of candidates shouldn't
	  change at all, we'll just handle relocating appropriately,
	  depending on relo's kind.
	
	  If no candidates were found, it might be both a programmer error,
	  as well as expected case, depending whether instruction w
	  relocation is guarded in some way that makes it unreachable (dead
	  code) if relocation can't be resolved. This is handled in
	  bpf_core_patch_insn() uniformly by replacing that instruction with
	  BPF helper call insn (using invalid helper ID). If that instruction
	  is indeed unreachable, then it will be ignored and eliminated by
	  verifier. If it was an error, then verifier will complain and point
	  to a specific instruction number in its log.
 calculate single target relo result explicitly 
 bpf_core_patch_insn() should know how to handle missing targ_spec 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 Copyright (c) 2018 Facebook 
 raw BTF data in native endianness 
 raw BTF data in non-native endianness 
 whether target endianness differs from the native one 
	
	  When BTF is loaded from an ELF or raw memory it is stored
	  in a contiguous memory block. The hdr, type_data, and, strs_data
	  point inside that memory region to their respective parts of BTF
	  representation:
	 
	  +--------------------------------+
	  |  Header  |  Types  |  Strings  |
	  +--------------------------------+
	  ^          ^         ^
	  |          |         |
	  hdr        |         |
	  types_data-+         |
	  strs_data------------+
	 
	  If BTF data is later modified, e.g., due to types added or
	  removed, BTF deduplication performed, etc, this contiguous
	  representation is broken up into three independently allocated
	  memory regions to be able to modify them independently.
	  raw_data is nulled out at that point, but can be later allocated
	  and cached again if user calls btf__raw_data(), at which point
	  raw_data will contain a contiguous copy of header, types, and
	  strings:
	 
	  +----------+  +---------+  +-----------+
	  |  Header  |  |  Types  |  |  Strings  |
	  +----------+  +---------+  +-----------+
	  ^             ^            ^
	  |             |            |
	  hdr           |            |
	  types_data----+            |
	  strset__data(strs_set)-----+
	 
	                +----------+---------+-----------+
	                |  Header  |  Types  |  Strings  |
	  raw_data----->+----------+---------+-----------+
 used size stored in hdr->type_len 
	 type ID to `struct btf_type ` lookup index
	  type_offs[0] corresponds to the first non-VOID type:
	    - for base BTF it's type [1];
	    - for split BTF it's the first non-base BTF type.
	 number of types in this BTF instance:
	    - doesn't include special [0] void type;
	    - for split BTF counts number of types added on top of base BTF.
	 if not NULL, points to the base BTF on top of which the current
	  split BTF is based
	 BTF type ID of the first type in this BTF instance:
	    - for base BTF it's equal to 1;
	    - for split BTF it's equal to biggest type ID of base BTF plus 1.
	 logical string offset of this BTF instance:
	    - for base BTF it's equal to 0;
	    - for split BTF it's equal to total size of base BTF's string section size.
	 only one of strs_data or strs_set can be non-NULL, depending on
	  whether BTF is in a modifiable state (strs_set is used) or not
	  (strs_data points inside raw_data)
 a set of unique strings 
 whether strings are already deduplicated 
 BTF object FD, if loaded into kernel 
 Pointer size (in bytes) for a target architecture of this BTF 
 Ensure given dynamically allocated memory region pointed to by data with
  capacity of cap_cnt elements each taking elem_sz bytes has enough
  memory to accomodate add_cnt new elements, assuming cur_cnt elements
  are already used. At most max_cnt elements can be ever allocated.
  If necessary, memory is reallocated and all existing data is copied over,
  new pointer to the memory region is stored at data, new memory region
  capacity (in number of elements) is stored in cap.
  On success, memory pointer to the beginning of unused memory is returned.
  On error, NULL is returned.
 requested more than the set limit 
 expand by 25% 
 but at least 16 elements 
 but not exceeding a set limit 
 also ensure we have enough memory 
 zero out newly allocated portion of memory 
 Ensure given dynamically allocated memory region has enough allocated space
  to accommodate need_cnt elements of size elem_sz bytes each
 internal helper returning non-const pointer to a type 
 Return pointer size this BTF instance assumes. The size is heuristically
  determined by looking for 'long' or 'unsigned long' integer type and
  recording its size in bytes. If BTF type information doesn't have any such
  type, this function returns 0. In the latter case, native architecture's
  pointer size is assumed, so will be either 4 or 8, depending on
  architecture that libbpf was compiled for. It's possible to override
  guessed value by using btf__set_pointer_size() API.
 not enough BTF type info to guess 
 Override or set pointer size in bytes. Only values of 4 and 8 are
  supported.
		 if BTF was modified after loading, it will have a split
		  in-memory representation for header, types, and strings
		  sections, so we need to free all of them individually. It
		  might still have a cached contiguous raw data present,
		  which will be unconditionally freed below.
 +1 for empty string at offset 0 
 empty string at offset 0 
 check BTF magic 
 definitely not a raw BTF 
 get file size 
 rewind to the start 
 pre-alloc memory and read all of BTF data 
 finally parse BTF data 
 cache native raw data representation 
			 btf_bswap_type_rest() relies on native t->info, so
			  we swap base type info after we swapped all the
			  additional information
	 we won't know btf_size until we call bpf_obj_get_info_by_fd(). so
	  let's start with a sane default - 4KiB here - and resize it only if
	  bpf_obj_get_info_by_fd() needs a bigger buffer.
 Ensure BTF is ready to be modified (by splitting into a three memory
  regions for header, types, and strings). Also invalidate cached
  raw_data, if any.
 any BTF modification invalidates raw_data 
 split raw data into three memory regions 
 build lookup index for all strings 
 only when everything was successful, update internal state 
	 if BTF was created from scratch, all strings are guaranteed to be
	  unique and deduplicated
 invalidate raw_data representation 
 Find an offset in BTF string section that corresponds to a given string s.
  Returns:
    - >0 offset into string section, if string is found;
    - -ENOENT, if string is not in the string section;
    - <0, on any other error.
 BTF needs to be in a modifiable state to build string lookup index 
 Add a string s to the BTF string section.
  Returns:
    - > 0 offset into string section, on success;
    - < 0, on error.
 nothing to do for empty strings 
 deconstruct BTF, if necessary, and invalidate raw_data 
 nothing to do for VOID references 
	 we haven't updated btf's type count yet, so
	  btf->start_id + btf->nr_types - 1 is the type ID offset we should
	  add to all newly added BTF types
 appending split BTF isn't supported yet 
 deconstruct BTF, if necessary, and invalidate raw_data 
	 remember original strings section size if we have to roll back
	  partial strings section changes
 pre-allocate enough memory for new types 
 pre-allocate enough memory for type offset index for new types 
 bulk copy types data for all types from src_btf 
 unlikely, has to be corrupted src_btf 
 fill out type ID to type offset mapping for lookups by type ID 
 add, dedup, and remap strings referenced by this BTF type 
 remap all type IDs referenced from this BTF type 
 go to next type data and type offset index entry 
	 Up until now any of the copied type data was effectively invisible,
	  so if we exited early before this point due to error, BTF would be
	  effectively unmodified. There would be extra internal memory
	  pre-allocated, but it would not be available for querying.  But now
	  that we've copied and rewritten all the data successfully, we can
	  update type count and various internal offsets and sizes to
	  "commit" the changes and made them visible to the outside world.
 return type ID of the first added BTF type 
	 zero out preallocated memory as if it was just allocated with
	  libbpf_add_mem()
	 and now restore original strings section size; types data size
  Append new BTF_KIND_INT type with:
    - name - non-empty, non-NULL type name;
    - sz - power-of-2 (1, 2, 4, ..) size of the type, in bytes;
    - encoding is a combination of BTF_INT_SIGNED, BTF_INT_CHAR, BTF_INT_BOOL.
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
 non-empty name 
 byte_sz must be power of 2 
 deconstruct BTF, if necessary, and invalidate raw_data 
	 if something goes wrong later, we might end up with an extra string,
	  but that shouldn't be a problem, because BTF can't be constructed
	  completely anyway and will most probably be just discarded
 set INT info, we don't allow setting legacy bit offsetsize 
  Append new BTF_KIND_FLOAT type with:
    - name - non-empty, non-NULL type name;
    - sz - size of the type, in bytes;
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
 non-empty name 
 byte_sz must be one of the explicitly allowed values 
 it's completely legal to append BTF types with type IDs pointing forward to
  types that haven't been appended yet, so we only make sure that id looks
  sane, we can't guarantee that ID will always be valid
 generic append function for PTR, TYPEDEF, CONSTVOLATILERESTRICT 
  Append new BTF_KIND_PTR type with:
    - ref_type_id - referenced type ID, it might not exist yet;
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
  Append new BTF_KIND_ARRAY type with:
    - index_type_id - type ID of the type describing array index;
    - elem_type_id - type ID of the type describing array element;
    - nr_elems - the size of the array;
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
 generic STRUCTUNION append function 
	 start out with vlen=0 and no kflag; this will be adjusted when
	  adding each member
  Append new BTF_KIND_STRUCT type with:
    - name - name of the struct, can be NULL or empty for anonymous structs;
    - byte_sz - size of the struct, in bytes;
  Struct initially has no fields in it. Fields can be added by
  btf__add_field() right after btf__add_struct() succeeds.
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
  Append new BTF_KIND_UNION type with:
    - name - name of the union, can be NULL or empty for anonymous union;
    - byte_sz - size of the union, in bytes;
  Union initially has no fields in it. Fields can be added by
  btf__add_field() right after btf__add_union() succeeds. All fields
  should have bit_offset of 0.
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
  Append new field for the current STRUCTUNION type with:
    - name - name of the field, can be NULL or empty for anonymous field;
    - type_id - type ID for the type describing field type;
    - bit_offset - bit offset of the start of the field within structunion;
    - bit_size - bit size of a bitfield, 0 for non-bitfield fields;
  Returns:
    -  0, on success;
    - <0, on error.
 last type should be unionstruct 
 best-effort bit field offsetsize enforcement 
 only offset 0 is allowed for unions 
 decompose and invalidate raw data 
 btf_add_type_mem can invalidate t pointer 
 update parent type's vlen and kflag 
  Append new BTF_KIND_ENUM type with:
    - name - name of the enum, can be NULL or empty for anonymous enums;
    - byte_sz - size of the enum, in bytes.
  Enum initially has no enum values in it (and corresponds to enum forward
  declaration). Enumerator values can be added by btf__add_enum_value()
  immediately after btf__add_enum() succeeds.
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
 byte_sz must be power of 2 
 start out with vlen=0; it will be adjusted when adding enum values 
  Append new enum value for the current ENUM type with:
    - name - name of the enumerator value, can't be NULL or empty;
    - value - integer value corresponding to enum value name;
  Returns:
    -  0, on success;
    - <0, on error.
 last type should be BTF_KIND_ENUM 
 non-empty name 
 decompose and invalidate raw data 
 update parent type's vlen 
  Append new BTF_KIND_FWD type with:
    - name, non-emptynon-NULL name;
    - fwd_kind, kind of forward declaration, one of BTF_FWD_STRUCT,
      BTF_FWD_UNION, or BTF_FWD_ENUM;
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
		 enum forward in BTF currently is just an enum with no enum
		  values; we also assume a standard 4-byte size for it
  Append new BTF_KING_TYPEDEF type with:
    - name, non-emptynon-NULL name;
    - ref_type_id - referenced type ID, it might not exist yet;
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
  Append new BTF_KIND_VOLATILE type with:
    - ref_type_id - referenced type ID, it might not exist yet;
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
  Append new BTF_KIND_CONST type with:
    - ref_type_id - referenced type ID, it might not exist yet;
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
  Append new BTF_KIND_RESTRICT type with:
    - ref_type_id - referenced type ID, it might not exist yet;
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
  Append new BTF_KIND_FUNC type with:
    - name, non-emptynon-NULL name;
    - proto_type_id - FUNC_PROTO's type ID, it might not exist yet;
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
  Append new BTF_KIND_FUNC_PROTO with:
    - ret_type_id - type ID for return result of a function.
  Function prototype initially has no arguments, but they can be added by
  btf__add_func_param() one by one, immediately after
  btf__add_func_proto() succeeded.
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
	 start out with vlen=0; this will be adjusted when adding enum
	  values, if necessary
  Append new function parameter for current FUNC_PROTO type with:
    - name - parameter name, can be NULL or empty;
    - type_id - type ID describing the type of the parameter.
  Returns:
    -  0, on success;
    - <0, on error.
 last type should be BTF_KIND_FUNC_PROTO 
 decompose and invalidate raw data 
 update parent type's vlen 
  Append new BTF_KIND_VAR type with:
    - name - non-emptynon-NULL name;
    - linkage - variable linkage, one of BTF_VAR_STATIC,
      BTF_VAR_GLOBAL_ALLOCATED, or BTF_VAR_GLOBAL_EXTERN;
    - type_id - type ID of the type describing the type of the variable.
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
 non-empty name 
 deconstruct BTF, if necessary, and invalidate raw_data 
  Append new BTF_KIND_DATASEC type with:
    - name - non-emptynon-NULL name;
    - byte_sz - data section size, in bytes.
  Data section is initially empty. Variables info can be added with
  btf__add_datasec_var_info() calls, after btf__add_datasec() succeeds.
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
 non-empty name 
 start with vlen=0, which will be update as var_secinfos are added 
  Append new data section variable information entry for current DATASEC type:
    - var_type_id - type ID, describing type of the variable;
    - offset - variable offset within data section, in bytes;
    - byte_sz - variable size, in bytes.
  Returns:
    -  0, on success;
    - <0, on error.
 last type should be BTF_KIND_DATASEC 
 decompose and invalidate raw data 
 update parent type's vlen 
  Append new BTF_KIND_DECL_TAG type with:
    - value - non-emptynon-NULL string;
    - ref_type_id - referenced type ID, it might not exist yet;
    - component_idx - -1 for tagging reference type, otherwise structunion
      member or function argument index;
  Returns:
    - >0, type ID of newly added BTF type;
    - <0, on error.
 The start of the info sec (including the __u32 record_size). 
 At least a record size 
 The record size needs to meet the minimum standard 
 If no records, return failure now so .BTF.ext won't be used. 
		 adjust insn_off only, the rest data will be passed
		  to the kernel.
  Deduplicate BTF types and strings.
  BTF dedup algorithm takes as an input `struct btf` representing `.BTF` ELF
  section with all BTF type descriptors and string data. It overwrites that
  memory in-place with deduplicated types and strings without any loss of
  information. If optional `struct btf_ext` representing '.BTF.ext' ELF section
  is provided, all the strings referenced from .BTF.ext section are honored
  and updated to point to the right offsets after deduplication.
  If function returns with error, typestring data might be garbled and should
  be discarded.
  More verbose and detailed description of both problem btf_dedup is solving,
  as well as solution could be found at:
  https:facebookmicrosites.github.iobpfblog20181114btf-enhancement.html
  Problem description and justification
  =====================================
  BTF type information is typically emitted either as a result of conversion
  from DWARF to BTF or directly by compiler. In both cases, each compilation
  unit contains information about a subset of all the types that are used
  in an application. These subsets are frequently overlapping and contain a lot
  of duplicated information when later concatenated together into a single
  binary. This algorithm ensures that each unique type is represented by single
  BTF type descriptor, greatly reducing resulting size of BTF data.
  Compilation unit isolation and subsequent duplication of data is not the only
  problem. The same type hierarchy (e.g., struct and all the type that struct
  references) in different compilation units can be represented in BTF to
  various degrees of completeness (or, rather, incompleteness) due to
  structunion forward declarations.
  Let's take a look at an example, that we'll use to better understand the
  problem (and solution). Suppose we have two compilation units, each using
  same `struct S`, but each of them having incomplete type information about
  struct's fields:
   CU #1:
  struct S;
  struct A {
 	int a;
 	struct A self;
 	struct S parent;
  };
  struct B;
  struct S {
 	struct A a_ptr;
 	struct B b_ptr;
  };
   CU #2:
  struct S;
  struct A;
  struct B {
 	int b;
 	struct B self;
 	struct S parent;
  };
  struct S {
 	struct A a_ptr;
 	struct B b_ptr;
  };
  In case of CU #1, BTF data will know only that `struct B` exist (but no
  more), but will know the complete type information about `struct A`. While
  for CU #2, it will know full type information about `struct B`, but will
  only know about forward declaration of `struct A` (in BTF terms, it will
  have `BTF_KIND_FWD` type descriptor with name `B`).
  This compilation unit isolation means that it's possible that there is no
  single CU with complete type information describing structs `S`, `A`, and
  `B`. Also, we might get tons of duplicated and redundant type information.
  Additional complication we need to keep in mind comes from the fact that
  types, in general, can form graphs containing cycles, not just DAGs.
  While algorithm does deduplication, it also merges and resolves type
  information (unless disabled throught `struct btf_opts`), whenever possible.
  E.g., in the example above with two compilation units having partial type
  information for structs `A` and `B`, the output of algorithm will emit
  a single copy of each BTF type that describes structs `A`, `B`, and `S`
  (as well as type information for `int` and pointers), as if they were defined
  in a single compilation unit as:
  struct A {
 	int a;
 	struct A self;
 	struct S parent;
  };
  struct B {
 	int b;
 	struct B self;
 	struct S parent;
  };
  struct S {
 	struct A a_ptr;
 	struct B b_ptr;
  };
  Algorithm summary
  =================
  Algorithm completes its work in 6 separate passes:
  1. Strings deduplication.
  2. Primitive types deduplication (int, enum, fwd).
  3. Structunion types deduplication.
  4. Reference types deduplication (pointers, typedefs, arrays, funcs, func
     protos, and constvolatilerestrict modifiers).
  5. Types compaction.
  6. Types remapping.
  Algorithm determines canonical type descriptor, which is a single
  representative type for each truly unique type. This canonical type is the
  one that will go into final deduplicated BTF type information. For
  structunions, it is also the type that algorithm will merge additional type
  information into (while resolving FWDs), as it discovers it from data in
  other CUs. Each input BTF type eventually gets either mapped to itself, if
  that type is canonical, or to some other type, if that type is equivalent
  and was chosen as canonical representative. This mapping is stored in
  `btf_dedup->map` array. This map is also used to record STRUCTUNION that
  FWD type got resolved to.
  To facilitate fast discovery of canonical types, we also maintain canonical
  index (`btf_dedup->dedup_table`), which maps type descriptor's signature hash
  (i.e., hashed kind, name, size, fields, etc) into a list of canonical types
  that match that signature. With sufficiently good choice of type signature
  hashing function, we can limit number of canonical types for each unique type
  signature to a very small number, allowing to find canonical type for any
  duplicated type very quickly.
  Structunion deduplication is the most critical part and algorithm for
  deduplicating structsunions is described in greater details in comments for
  `btf_dedup_is_equiv` function.
 .BTF section to be deduped in-place 
	
	  Optional .BTF.ext section. When provided, any strings referenced
	  from it will be taken into account when deduping strings
	
	  This is a map from any type's signature hash to a list of possible
	  canonical representative type candidates. Hash collisions are
	  ignored, so even types of various kinds can share same list of
	  candidates, which is fine because we rely on subsequent
	  btf_xxx_equal() checks to authoritatively verify type equality.
 Canonical types map 
 Hypothetical mapping, used during type graph equivalence checks 
	 Whether hypothetical mapping, if successful, would need to adjust
	  already canonicalized types (due to a new forward declaration to
	  concrete type resolution). In such case, during split BTF dedup
	  candidate type would still be considered as different, because base
	  BTF is considered to be immutable.
 Various option modifying behavior of algorithm 
 temporary strings deduplication state 
 dedup_table_size is now used only to force collisions in tests 
 special BTF "void" type is made canonical immediately 
 VAR and DATASEC are never deduped and are self-canonical 
  Iterate over all possible places in .BTF and .BTF.ext that can reference
  string and pass pointer to it to a provided callback `fn`.
 don't touch empty string or string in main BTF 
  Dedup string and filter out those that are not referenced from either .BTF
  or .BTF.ext (if provided) sections.
  This is done by building index of all strings in BTF's string section,
  then iterating over all entities that can reference strings (e.g., type
  names, struct field names, .BTF.ext line info, etc) and marking corresponding
  strings as used. After that all used strings are deduped and compacted into
  sequential blob of memory and new offsets are calculated. Then all the string
  references are iterated again and rewritten using new offsets.
		 insert empty string; we won't be looking it up during strings
		  dedup, but it's good to have it for generic BTF string lookups
 remap string offsets 
 replace BTF string data and hash with deduped ones 
 Calculate type signature hash of INT or TAG. 
 Check structural equality of two INTs or TAGs. 
 Calculate type signature hash of ENUM. 
 don't hash vlen and enum members to support enum fwd resolving 
 Check structural equality of two ENUMs. 
 ignore vlen when comparing 
  Calculate type signature hash of STRUCTUNION, ignoring referenced type IDs,
  as referenced type IDs equivalence is established separately during type
  graph equivalence check algorithm.
 no hashing of referenced type ID, it can be unresolved yet 
  Check structural compatibility of two FUNC_PROTOs, ignoring referenced type
  IDs. This check is performed during type graph equivalence check and
  referenced types equivalence is checked separately.
  Calculate type signature hash of ARRAY, including referenced type IDs,
  under assumption that they were already resolved to canonical type IDs and
  are not going to change.
  Check exact equality of two ARRAYs, taking into account referenced
  type IDs, under assumption that they were already resolved to canonical
  type IDs and are not going to change.
  This function is called during reference types deduplication to compare
  ARRAY to potential canonical representative.
  Check structural compatibility of two ARRAYs, ignoring referenced type
  IDs. This check is performed during type graph equivalence check and
  referenced types equivalence is checked separately.
  Calculate type signature hash of FUNC_PROTO, including referenced type IDs,
  under assumption that they were already resolved to canonical type IDs and
  are not going to change.
  Check exact equality of two FUNC_PROTOs, taking into account referenced
  type IDs, under assumption that they were already resolved to canonical
  type IDs and are not going to change.
  This function is called during reference types deduplication to compare
  FUNC_PROTO to potential canonical representative.
  Check structural compatibility of two FUNC_PROTOs, ignoring referenced type
  IDs. This check is performed during type graph equivalence check and
  referenced types equivalence is checked separately.
 skip return type ID 
 Prepare split BTF for deduplication by calculating hashes of base BTF's
  types and initializing the rest of the state (canonical type mapping) for
  the fixed base BTF part.
 all base BTF types are self-canonical by definition 
 VAR and DATASEC are never hashdeduplicated 
  Deduplicate primitive types, that can't reference other types, by calculating
  their type signature hash and comparing them with any possible canonical
  candidate. If no canonical candidate matches, type itself is marked as
  canonical and is added into `btf_dedup->dedup_table` as another candidate.
 if we don't find equivalent type, then we are canonical 
 resolve fwd to full enum 
 resolve canonical enum fwd to full enum 
  Check whether type is already mapped into canonical one (could be to itself).
  Resolve type ID into its canonical type ID, if any; otherwise return original
  type ID. If type is FWD and is resolved into STRUCTUNION already, follow
  STRUCTUNION link and resolve it into canonical type ID as well.
  Resolve FWD to underlying STRUCTUNION, if any; otherwise return original
  type ID.
 Check if given two types are identical ARRAY definitions 
  Check equivalence of BTF type graph formed by candidate structunion (we'll
  call it "candidate graph" in this description for brevity) to a type graph
  formed by (potential) canonical structunion ("canonical graph" for brevity
  here, though keep in mind that not all types in canonical graph are
  necessarily canonical representatives themselves, some of them might be
  duplicates or its uniqueness might not have been established yet).
  Returns:
   - >0, if type graphs are equivalent;
   -  0, if not equivalent;
   - <0, on error.
  Algorithm performs side-by-side DFS traversal of both type graphs and checks
  equivalence of BTF types at each step. If at any point BTF types in candidate
  and canonical graphs are not compatible structurally, whole graphs are
  incompatible. If types are structurally equivalent (i.e., all information
  except referenced type IDs is exactly the same), a mapping from `canon_id` to
  a `cand_id` is recored in hypothetical mapping (`btf_dedup->hypot_map`).
  If a type references other types, then those referenced types are checked
  for equivalence recursively.
  During DFS traversal, if we find that for current `canon_id` type we
  already have some mapping in hypothetical map, we check for two possible
  situations:
    - `canon_id` is mapped to exactly the same type as `cand_id`. This will
      happen when type graphs have cycles. In this case we assume those two
      types are equivalent.
    - `canon_id` is mapped to different type. This is contradiction in our
      hypothetical mapping, because same graph in canonical graph corresponds
      to two different types in candidate graph, which for equivalent type
      graphs shouldn't happen. This condition terminates equivalence check
      with negative result.
  If type graphs traversal exhausts types to check and find no contradiction,
  then type graphs are equivalent.
  When checking types for equivalence, there is one special case: FWD types.
  If FWD type resolution is allowed and one of the types (either from canonical
  or candidate graph) is FWD and other is STRUCTUNION (depending on FWD's kind
  flag) and their names match, hypothetical mapping is updated to point from
  FWD to STRUCTUNION. If graphs will be determined as equivalent successfully,
  this mapping will be used to record FWD -> STRUCTUNION mapping permanently.
  Technically, this could lead to incorrect FWD to STRUCTUNION resolution,
  if there are two exactly named (or anonymous) structsunions that are
  compatible structurally, one of which has FWD field, while other is concrete
  STRUCTUNION, but according to C sources they are different structsunions
  that are referencing different types with the same name. This is extremely
  unlikely to happen, but btf_dedup API allows to disable FWD resolution if
  this logic is causing problems.
  Doing FWD resolution means that both candidate andor canonical graphs can
  consists of portions of the graph that come from multiple compilation units.
  This is due to the fact that types within single compilation unit are always
  deduplicated and FWDs are already resolved, if referenced structunion
  definiton is available. So, if we had unresolved FWD and found corresponding
  STRUCTUNION, they will be from different compilation units. This
  consequently means that when we "link" FWD to corresponding STRUCTUNION,
  type graph will likely have at least two different BTF types that describe
  same type (e.g., most probably there will be two different BTF types for the
  same 'int' primitive type) and could even have "overlapping" parts of type
  graph that describe same subset of types.
  This in turn means that our assumption that each type in canonical graph
  must correspond to exactly one type in candidate graph might not hold
  anymore and will make it harder to detect contradictions using hypothetical
  map. To handle this problem, we allow to follow FWD -> STRUCTUNION
  resolution only in canonical graph. FWDs in candidate graphs are never
  resolved. To see why it's OK, let's check all possible situations w.r.t. FWDs
  that can occur:
    - Both types in canonical and candidate graphs are FWDs. If they are
      structurally equivalent, then they can either be both resolved to the
      same STRUCTUNION or not resolved at all. In both cases they are
      equivalent and there is no need to resolve FWD on candidate side.
    - Both types in canonical and candidate graphs are concrete STRUCTUNION,
      so nothing to resolve as well, algorithm will check equivalence anyway.
    - Type in canonical graph is FWD, while type in candidate is concrete
      STRUCTUNION. In this case candidate graph comes from single compilation
      unit, so there is exactly one BTF type for each unique C type. After
      resolving FWD into STRUCTUNION, there might be more than one BTF type
      in canonical graph mapping to single BTF type in candidate graph, but
      because hypothetical mapping maps from canonical to candidate types, it's
      alright, and we still maintain the property of having single `canon_id`
      mapping to single `cand_id` (there could be two different `canon_id`
      mapped to the same `cand_id`, but it's not contradictory).
    - Type in canonical graph is concrete STRUCTUNION, while type in candidate
      graph is FWD. In this case we are just going to check compatibility of
      STRUCTUNION and corresponding FWD, and if they are compatible, we'll
      assume that whatever STRUCTUNION FWD resolves to must be equivalent to
      a concrete STRUCTUNION from canonical graph. If the rest of type graphs
      turn out equivalent, we'll re-resolve FWD to concrete STRUCTUNION from
      canonical graph.
 if both resolve to the same canonical, they must be equivalent 
		 In some cases compiler will generate different DWARF types
		  for identical array type definitions and use them for
		  different fields within the same struct. This breaks type
		  equivalence check, which makes an assumption that candidate
		  types sub-graph has a consistent and deduped-by-compiler
		  types within a single CU. So work around that by explicitly
		  allowing identical array types here.
 FWD <--> STRUCTUNION equivalence check, if enabled 
 we'd need to resolve base FWD to STRUCTUNION 
  Use hypothetical mapping, produced by successful type graph equivalence
  check, to augment existing structunion canonical mapping, where possible.
  If BTF_KIND_FWD resolution is allowed, this mapping is also used to record
  FWD -> STRUCTUNION correspondence as well. FWD resolution is bidirectional:
  it doesn't matter if FWD type was part of canonical graph or candidate one,
  we are recording the mapping anyway. As opposed to carefulness required
  for structunion correspondence mapping (described below), for FWD resolution
  it's not important, as by the time that FWD type (reference type) will be
  deduplicated all structsunions will be deduped already anyway.
  Recording STRUCTUNION mapping is purely a performance optimization and is
  not required for correctness. It needs to be done carefully to ensure that
  structunion from candidate's type graph is not mapped into corresponding
  structunion from canonical type graph that itself hasn't been resolved into
  canonical representative. The only guarantee we have is that canonical
  structunion was determined as canonical and that won't change. But any
  types referenced through that structunion fields could have been not yet
  resolved, so in case like that it's too early to establish any kind of
  correspondence between structsunions.
  No canonical correspondence is derived for primitive types (they are already
  deduplicated completely already anyway) or reference types (they rely on
  stability of structunion canonical relationship for equivalence checks).
		
		  Resolve FWD into STRUCTUNION.
		  It's ok to resolve FWD into STRUCTUNION that's not yet
		  mapped to canonical representative (as opposed to
		  STRUCTUNION <--> STRUCTUNION mapping logic below), because
		  eventually that struct is going to be mapped and all resolved
		  FWDs will automatically resolve to correct canonical
		  representative. This will happen before ref type deduping,
		  which critically depends on stability of these mapping. This
		  stability is not a requirement for STRUCTUNION equivalence
		  checks, though.
		 if it's the split BTF case, we still need to point base FWD
		  to STRUCTUNION in a split BTF, because FWDs from split BTF
		  will be resolved against base FWD. If we don't point base
		  canonical FWD to the resolved STRUCTUNION, then all the
		  FWDs in split BTF won't be correctly resolved to a proper
		  STRUCTUNION.
		 if graph equivalence determined that we'd need to adjust
		  base canonical types, then we need to only point base FWDs
		  to STRUCTsUNIONs and do no more modifications. For all
		  other purposes the type graphs were not equivalent.
			
			  as a perf optimization, we can map structunion
			  that's part of type graph we just verified for
			  equivalence. We can do that for structunion that has
			  canonical representative only, though.
  Deduplicate structunion types.
  For each structunion type its type signature hash is calculated, taking
  into account type's name, size, number, order and names of fields, but
  ignoring type ID's referenced from fields, because they might not be deduped
  completely until after reference types deduplication phase. This type hash
  is used to iterate over all potential canonical types, sharing same hash.
  For each canonical candidate we check whether type graphs that they form
  (through referenced types in fields and so on) are equivalent using algorithm
  implemented in `btf_dedup_is_equiv`. If such equivalence is found and
  BTF_KIND_FWD resolution is allowed, then hypothetical mapping
  (btf_dedup->hypot_map) produced by aforementioned type graph equivalence
  algorithm is used to record FWD -> STRUCTUNION mapping. It's also used to
  potentially map other structsunions to their canonical representatives,
  if such relationship hasn't yet been established. This speeds up algorithm
  by eliminating some of the duplicate work.
  If no matching canonical representative was found, structunion is marked
  as canonical for itself and is added into btf_dedup->dedup_table hash map
  for further look ups.
 if we don't find equivalent type, then we are canonical 
 already deduped or is in process of deduping (loop detected) 
		
		  Even though btf_dedup_is_equiv() checks for
		  btf_shallow_equal_struct() internally when checking two
		  structs (unions) for equivalence, we need to guard here
		  from picking matching FWD type as a dedup candidate.
		  This can happen due to hash collision. In such case just
		  relying on btf_dedup_is_equiv() would lead to potentially
		  creating a loop (FWD -> STRUCT and STRUCT -> FWD), because
		  FWD and compatible STRUCTUNION are considered equivalent.
 not really equivalent 
  Deduplicate reference type.
  Once all primitive and structunion types got deduplicated, we can easily
  deduplicate all other (reference) BTF types. This is done in two steps:
  1. Resolve all referenced type IDs into their canonical type IDs. This
  resolution can be done either immediately for primitive or structunion types
  (because they were deduped in previous two phases) or recursively for
  reference types. Recursion will always terminate at either primitive or
  structunion type, at which point we can "unwind" chain of reference types
  one by one. There is no danger of encountering cycles because in C type
  system the only way to form type cycle is through structunion, so any chain
  of reference types, even those taking part in a type cycle, will inevitably
  reach structunion at some point.
  2. Once all referenced type IDs are resolved into canonical ones, BTF type
  becomes "stable", in the sense that no further deduplication will cause
  any changes to it. With that, it's now possible to calculate type's signature
  hash (this time taking into account referenced type IDs) and loop over all
  potential canonical representatives. If no match was found, current type
  will become canonical representative of itself and will be added into
  btf_dedup->dedup_table as another possible canonical representative.
 if we don't find equivalent type, then we are representative type 
 we won't need d->dedup_table anymore 
  Compact types.
  After we established for each type its corresponding canonical representative
  type, we now can eliminate types that are not canonical and leave only
  canonical ones layed out sequentially in memory by copying them over
  duplicates. During compaction btf_dedup->hypot_map array is reused to store
  a map from original type ID to a new compacted type ID, which will be used
  during next phase to "fix up" type IDs, referenced from structunion and
  reference types.
 we are going to reuse hypot_map to store compaction remapping 
 base BTF types are not renumbered 
 shrink struct btf's internal types index and update btf_header 
  Figure out final (deduplicated and compacted) type ID for provided original
  `type_id` by first resolving it into corresponding canonical type ID and
  then mapping it to a deduplicated type ID, stored in btf_dedup->hypot_map,
  which is populated during compaction phase.
  Remap referenced type IDs into deduped type IDs.
  After BTF types are deduplicated and compacted, their final type IDs may
  differ from original ones. The map from original to a corresponding
  deduped type ID is stored in btf_dedup->hypot_map and is populated during
  compaction phase. During remapping phase we are rewriting all type IDs
  referenced from any BTF type (e.g., struct fields, func proto args, etc) to
  their final deduped type IDs.
  Probe few well-known locations for vmlinux kernel image and try to load BTF
  data out of it to use for target BTF.
 try canonical vmlinux BTF through sysfs first 
 raw BTF  },
 fall back to trying to find vmlinux ELF on disk otherwise 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  Copyright (C) 2013-2015 Alexei Starovoitov <ast@kernel.org>
  Copyright (C) 2015 Wang Nan <wangnan0@huawei.com>
  Copyright (C) 2015 Huawei Inc.
  Copyright (C) 2017 Nicira, Inc.
 make sure libbpf doesn't use kernel-only integer typedefs 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 Copyright (c) 2018 Facebook 
	
	  Index to raw_jited_linfo:
	       i: Index for searching the next ksym_func
	  prev_i: Index to the last found ksym_func
 Index to ksym_func 
 Sanity check 
			
			  The ksym_func[f] is found in jited_linfo.
			  Look for the next one.
 Ensure the addr is increasing _within_ a func 
	
	  The min size that bpf_prog_linfo has to access for
	  searching purpose.
 Copy xlated line_info 
 Not enough info to provide jited_line_info 
 Copy jited_line_info 
 Number of jited_line_info per jited func 
	
	  For each jited func,
	  the start idx to the "linfo" and "jited_linfo" array,
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 Copyright (c) 2018 Facebook 
 Check whether the single {HW,DRV,SKB} mode is set 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  NETLINK      Netlink attributes
  Copyright (c) 2003-2013 Thomas Graf <tgraf@suug.ch>
  Create attribute index based on a stream of attributes.
  @arg tb		Index array to be filled (maxtype+1 elements).
  @arg maxtype		Maximum attribute type expected and accepted.
  @arg head		Head of attribute stream.
  @arg len		Length of attribute stream.
  @arg policy		Attribute validation policy.
  Iterates over the stream of attributes and stores a pointer to each
  attribute in the index array using the attribute type as index to
  the array. Attribute with a type greater than the maximum type
  specified will be silently ignored in order to maintain backwards
  compatibility. If \a policy is not NULL, the attribute will be
  validated using the specified policy.
  @see nla_validate
  @return 0 on success or a negative error code.
  Create attribute index based on nested attribute
  @arg tb              Index array to be filled (maxtype+1 elements).
  @arg maxtype         Maximum attribute type expected and accepted.
  @arg nla             Nested Attribute.
  @arg policy          Attribute validation policy.
  Feeds the stream of attributes nested into the specified attribute
  to libbpf_nla_parse().
  @see libbpf_nla_parse
  @return 0 on success or a negative error code.
 dump netlink extended ack error message 
 no TLVs, nothing to do here 
 if NLM_F_CAPPED is set then the inner err msg was capped 
  Will go away once libc support is there
  alpha is the only exception, all other architectures
  have common numbers for new system calls.
 !__alpha__ 
  For users that want to specify sq_thread_cpu or sq_thread_idle, this
  interface is a convenient helper for mmap()ing the rings.
  Returns -1 on error, or zero on success.  On success, 'ring'
  contains the necessary information to readwrite to the rings.
  Returns -1 on error, or zero on success. On success, 'ring'
  contains the necessary information to readwrite to the rings.
 SPDX-License-Identifier: GPL-2.0
  Simple test program that demonstrates a file copy through io_uring. This
  uses the API exposed by liburing.
  Copyright (C) 2018-2019 Jens Axboe
		
		  Queue up as many reads as we can
		
		  Queue is full at this point. Find at least one completion.
 Short readwrite, adjust and requeue 
			
			  All done. if write, nothing else to do. if read,
			  queue up corresponding write.
 wait out pending writes 
		
		  It's necessary to use a read_barrier() before reading
		  the CQ tail, since the kernel updates it locklessly. The
		  kernel has the matching store barrier for the update. The
		  kernel also ensures that previous stores to CQEs are ordered
		  with the tail update.
  Return an IO completion, if one is readily available. Returns 0 with
  cqe_ptr filled in on success, -errno on failure.
  Return an IO completion, waiting for it if necessary. Returns 0 with
  cqe_ptr filled in on success, -errno on failure.
  Submit sqes acquired from io_uring_get_sqe() to the kernel.
  Returns number of sqes submitted
	
	  If we have pending IO in the kring, submit it first. We need a
	  read barrier here to match the kernels store barrier when updating
	  the SQ head.
	
	  Fill in sqes that we have queued up, adding them to the kernel ring
		
		  First write barrier ensures that the SQE stores are updated
		  with the tail update. This is needed so that the kernel
		  will never see a tail update without the preceeding sQE
		  stores being done.
		
		  The kernel has the matching read barrier for reading the
		  SQ tail.
  Return an sqe to fill. Application must later call io_uring_submit()
  when it's ready to tell the kernel about it. The caller may call this
  function multiple times before calling io_uring_submit().
  Returns a vacant sqe, or NULL if we're full.
	
	  All sqes are used
 SPDX-License-Identifier: GPL-2.0
  Simple benchmark program that uses the various features of io_uring
  to provide fast random access to a devicefile. It has various
  options that are control how we use io_uring, see the OPTIONS section
  below. This uses the raw io_uring interface.
  Copyright (C) 2018-2019 Jens Axboe
  OPTIONS: Set these to test the various features of io_uring.
 use IO polling 
 use fixed user buffers 
 use fixed files 
 use buffered IO, not O_DIRECT 
 use kernel submissionpoller thread 
 pin above thread to this CPU 
 no-op SQ ring commands 
 order tail store with writes to sqes above 
		
		  Only need to call io_uring_enter if we're not using SQ thread
		  poll, or if IORING_SQ_NEED_WAKEUP is set.
		
		  For non SQ thread poll, we already got the events we needed
		  through the io_uring_enter() above. For SQ thread poll, we
		  need to loop here until we find enough events.
 SPDX-License-Identifier: GPL-2.0-only
 Counter - example userspace application
  The userspace application opens devcounter0, configures the
  COUNTER_EVENT_INDEX event channel 0 to gather Count 0 count and Count
  1 count, and prints out the data as it becomes available on the
  character device node.
  Copyright (C) 2021 William Breathitt Gray
 Component data: Count 0 count 
 Event type: Index 
 Device event channel 0 
 Component data: Count 1 count 
 Event type: Index 
 Device event channel 0 
 SPDX-License-Identifier: GPL-2.0
 Simple test of virtio code, entirely in userpsace. 
 We return single byte ranges. 
 We aim for two "distant" cpus. 
 Opencoded version for fast mode 
 Only get avail ring entries after they have been exposed by guest. 
 Create real file to mmap. 
 Extra room at the end for some data, and indirects 
 Parent and child use separate addresses, to check our mapping logic! 
 We are the host: never access guest addresses! 
 Swallow all notifies at once. 
 We simply copy bytes. 
 We pass sg[]s pointing into here, but we need RINGSIZE+1 
 We are the guest. 
 Don't kfree indirects. 
 Consume bufs. 
 Produce a buffer. 
 Nasty three-element sg list. 
			 May allocate an indirect, so force it to allocate
 Swallow all notifies at once. 
 Any extra? 
 Consume bufs. 
 Set up guest side. 
 Set up host side. 
 No descriptor to get yet... 
 Guest puts in a descriptor. 
 May allocate an indirect, so force it to allocate user addr 
 Host retreives it. 
 Host is done. 
 Guest should see used token now. 
 Guest puts in a huge descriptor. 
 Fill contents with recognisable garbage. 
 This will allocate an indirect, so force it to allocate user addr 
 Host picks it up (allocates new iov). 
 Pull data back out (in odd chunks), should be as expected. 
 Complete using multi interface, just because we can. 
 Free up those descriptors. 
 Add lots of descriptors. 
 Now get many, and consume them all at once. 
 Make sure it wraps around ring, to test! 
 Free those buffers. 
 Test weird (but legal!) indirect. 
 Force creation of direct, which we modify. 
 They're used in order, but double-check... 
 First indirect 
 Second indirect 
 Third indirect 
 Host picks it up (allocates new iov). 
 Data should be linear. 
 Don't leak memory... 
 SPDX-License-Identifier: GPL-2.0
 Unused 
 copy used for control 
 TODO: this is pretty bad: we get a cache line bounce
  for the wait queue on poll and another one on read,
  plus the read which is there just to clear the
 Flush out completed bufs if any 
 SPDX-License-Identifier: GPL-2.0-only
  Controller of readwrite threads for virtio-trace
  Copyright (C) 2012 Hitachi, Ltd.
  Created by Yoshihiro Yunomae <yoshihiro.yunomae.ez@hitachi.com>
             Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
 default false 
 default false
 Handle SIGTERMSIGINTSIGQUIT to exit 
 Wakes rw-threads when they are sleeping 
  contol readwrite threads by handling global_run_operation
 Setup signal handlers 
			
			  If host writes '1' to a control path,
			  this controller wakes all readwrite threads.
			
			  If host writes '0' to a control path, readwrite
			  threads will wait for notification from Host.
 SPDX-License-Identifier: GPL-2.0-only
  Guest agent for virtio-trace
  Copyright (C) 2012 Hitachi, Ltd.
  Created by Yoshihiro Yunomae <yoshihiro.yunomae.ez@hitachi.com>
             Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
 readwrite threads init 
 Align buffer size with page unit 
 write(output) path 
 read(input) path 
 init readwrite threads 
 set read(input) path per readwrite thread 
 set write(output) path per readwrite thread
 stdout mode 
 init controller of readwrite threads 
 stdout mode 
 size of pipe 
 Start all readwrite threads 
 Finish all readwrite threads 
 SPDX-License-Identifier: GPL-2.0-only
  Readwrite thread of a guest agent for virtio-trace
  Copyright (C) 2012 Hitachi, Ltd.
  Created by Yoshihiro Yunomae <yoshihiro.yunomae.ez@hitachi.com>
             Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
 set read(input) fd 
 set write(output) fd 
 virtio-serial output mode 
 stdout mode 
	
	  Size of pipe is 64kB in default based on fspipe.c.
	  To readwrite trace data speedy, pipe size is changed.
 Bind a thread to a cpu 
 bind my thread to cpu_num by assigning zero to the first argument 
 Wait for a read order of trace data by Host OS 
		
		  Each thread read trace_pipe_raw of each cpu bounding the
		  thread, so contention of multi-threads does not occur.
			
			  If trace data do not exist or are unreadable not
			  for exceeding the page size, splice_read returns
			  NULL. Then, this waits for being filled the data in a
			  ring-buffer.
				
				  When host reader is not in time for reading
				  trace data, guest will be stopped. This is
				  because char dev in QEMU is not supported
				  non-blocking mode. Then, writer might be
				  sleep in that case.
				  This sleep will be removed by supporting
				  non-blocking mode.
 SPDX-License-Identifier: GPL-2.0
 implemented by ring 
 Hacky way to poke at ring internals. Useful for testing though. 
 guest side 
  ptr_ring API provides no way for producer to find out whether a given
  buffer was consumed.  Our tests merely require that a successful get_buf
  implies that add_inbuf succeed in the past, and that add_inbuf will succeed,
  fake it accordingly.
 host side 
 SPDX-License-Identifier: GPL-2.0
 stub implementation: useful for measuring overhead 
 guest side 
  skb_array API provides no way for producer to find out whether a given
  buffer was consumed.  Our tests merely require that a successful get_buf
  implies that add_inbuf succeed in the past, and that add_inbuf will succeed,
  fake it accordingly.
 host side 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2016 Red Hat, Inc.
  Author: Michael S. Tsirkin <mst@redhat.com>
  Simple descriptor-based ring. virtio 0.9 compatible event index is used for
  signalling, unconditionally.
 Next - Where next entry will be written.
  Prev - "Next" value when event triggered previously.
  Event - Peer requested event after writing this entry.
 Design:
  Guest adds descriptors with unique index values and DESC_HW in flags.
  Host overwrites used descriptors with correct len, index, and DESC_HW clear.
  Flags are always set last.
 how much padding is needed to avoid false cache sharing 
 Mostly read 
 descriptor is writeable, we can't get buf from there 
	 we do not need to track last avail index
	  unless we have more than one in flight.
 implemented by ring 
 guest side 
	 Start with a write. On MESI architectures this helps
	  avoid a shared state with consumer that is polling this descriptor.
	 read below might bypass write above. That is OK because it's just an
	  optimization. If this happens, we will get the cache line in a
	  shared state which is unfortunate, but probably not worth it to
	  add an explicit full barrier to avoid this.
 Barrier A (for pairing) 
 Barrier B (for pairing) 
	 Doing nothing to disable calls might cause
	  extra interrupts, but reduces the number of cache misses.
 Flush call index write 
 Barrier D (for pairing) 
 Flush in previous flags write 
 Barrier C (for pairing) 
 host side 
	 Doing nothing to disable kicks might cause
	  extra interrupts, but reduces the number of cache misses.
 Barrier C (for pairing) 
 make sure length read below is not speculated 
 Barrier A (for pairing) 
	 simple in-order completion: we don't need
	  to touch index at all. This also means we
	  can just modify the descriptor in-place.
	 Make sure len is valid before flags.
	  Note: alternative is to write len and flags in one access -
	  possible on 64 bit architectures but wmb is free on Intel anyway
	  so I have no way to test whether it's a gain.
 Barrier B (for pairing) 
 Flush in previous flags write 
 Barrier D (for pairing) 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2016 Red Hat, Inc.
  Author: Michael S. Tsirkin <mst@redhat.com>
  Partial implementation of virtio 0.9. event index is used for signalling,
  unconditionally. Design roughly follows linux kernel implementation in order
  to be able to judge its performance.
 enabling the below activates experimental ring polling code
  (which skips index reads on consumer in favor of looking at
  high bits of ring id ^ 0x8000).
 #ifdef RING_POLL 
 enabling the below activates experimental in-order code
  (which skips ring updates and reads and writes len in descriptor).
 #ifdef INORDER 
 how much padding is needed to avoid false cache sharing 
	 we do not need to track last avail index
	  unless we have more than one in flight.
 implemented by ring 
 Put everything in free lists. 
 guest side 
	 We do it like this to simulate the way
	  we'd have to flip it if we had multiple
	  descriptors.
 Barrier A (for pairing) 
 Barrier A (for pairing) 
 Barrier A (for pairing) 
 Barrier B (for pairing) 
 Barrier B (for pairing) 
	 Doing nothing to disable calls might cause
	  extra interrupts, but reduces the number of cache misses.
 Flush call index write 
 Barrier D (for pairing) 
 Flush in previous flags write 
 Barrier C (for pairing) 
 host side 
	 Doing nothing to disable kicks might cause
	  extra interrupts, but reduces the number of cache misses.
 Barrier C (for pairing) 
 Barrier A (for pairing) 
 Barrier A (for pairing) 
 now update used ring 
 Barrier B (for pairing) 
 Flush in previous flags write 
 Barrier D (for pairing) 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2016 Red Hat, Inc.
  Author: Michael S. Tsirkin <mst@redhat.com>
  Command line processing and common functions for ring benchmarking.
 Flush out completed bufs if any 
 does nothing here, used to make sure all smp APIs compile 
 SPDX-License-Identifier: GPL-2.0
  Boot config tool for initrd image
			
			  If @cnode has value and subkeys, this
			  should show it as below.
			 
			  key(@node) {
			       key(@cnode) = value;
			       key(@cnode) {
			           subkeys;
			       }
			  }
			
			  If @node has value and subkeys, continue
			  looping on subkeys with same node.
 Return the read size or -errno 
 Check the bootconfig magic bytes 
 Wrong size error  
 Wrong Checksum 
 Wrong data 
 Note that pos starts from 0 but lin and col should start from 1. 
 Assume a bootconfig file if it is enough small 
 Ignore if there is no boot config in initrd 
 Backup the bootconfig data 
 Check the data format 
 TODO: Check the options by schema 
 Remove old boot config if exists 
 Apply new one 
 TODO: Ensure the @path is initramfsinitrd image 
 To align up the total size to BOOTCONFIG_ALIGN, get padding size 
 Add a footer 
 Map the partial write to -ENOSPC 
 SPDX-License-Identifier: GPL-2.0-or-later
  elf.c - ELF access library
  Adapted from kpatch (https:github.comdynupkpatch):
  Copyright (C) 2013-2015 Josh Poimboeuf <jpoimboe@redhat.com>
  Copyright (C) 2014 Seth Jennings <sjenning@redhat.com>
 sanity check, one more call to elf_nextscn() should return NULL 
	
	  Don't store empty STT_NOTYPE symbols in the rbtree.  They
	  can exist within a function, confusing the sorting.
		
		  A missing symbol table is actually possible if it's an empty
		  .o file. This can happen for thunk_64.o. Make sure to at
		  least allocate the symbol hash tables so we can do symbol
		  lookups without crashing.
 Create parentchild links for any cold subfunctions 
			
			  Unfortunately, -fnoreorder-functions puts the child
			  inside the parent.  Remove the overlap so we can
			  have sane assumptions.
			 
			  Note that pfunc->len now no longer matches
			  pfunc->sym.st_size.
		
		  The Clang assembler strips section symbols, so we have to
		  reference the function symbol instead:
			
			  Hack alert.  This happens when we need to reference
			  the NOP pad insn immediately after the function.
 O_WRONLY 
 Add section name to .shstrtab (or .strtab for Clang) 
 Allocate a buffer for relocations 
 Allocate a buffer for relocations with addends 
 Update changed relocation sections and section headers: 
 Make sure the new section header entries get updated properly. 
 Write all changes to the file. 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2015-2017 Josh Poimboeuf <jpoimboe@redhat.com>
  objtool check:
  This command analyzes every .o file and ensures the validity of its stack
  trace metadata.  It enforces a set of rules on asm code and C inline
  assembly code so that stack traces can be reliable.
  For more information, see toolsobjtoolDocumentationstack-validation.txt.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2015-2017 Josh Poimboeuf <jpoimboe@redhat.com>
 Check if we're already in the subfunction: 
 Move to the subfunction: 
 Retpoline alternative for a jump table? 
	
	  Assume only ELF functions can make sibling calls.  This ensures
	  sibling call detection consistency between vmlinux.o and individual
	  objects.
 An indirect jump is either a sibling call or a jump to a table. 
 add_jump_destinations() sets insn->call_dest for sibling calls. 
  This checks to see if the given function is a "noreturn" function.
  For global functions which are outside the scope of this object file, we
  have to keep a manual list of them.
  For local functions, we have to detect them manually by simply looking for
  the lack of a return instruction.
	
	  Unfortunately these have to be hard coded because the noreturn
	  attribute isn't provided in ELF data.
	
	  A function can have a sibling call instead of a return.  In that
	  case, the function's dead-end status depends on whether the target
	  of the sibling call returns.
 sibling call to another file 
 local sibling call 
				
				  Infinite recursion: two functions have
				  sibling calls to each other.  This is a very
				  rare case.  It means they aren't dead ends.
	
	  We need the full vmlinux for noinstr validation, otherwise we can
	  not correctly determine insn->call_dest->sec (external symbols do
	  not have a section).
  Call the arch-specific instruction decoder for all the instructions and add
  them to the global instruction list.
  Read the pv_ops[] .data table to find the static initialized values.
  Allocate and initialize file->pv_ops[].
  Mark "ud2" instructions and manually annotated dead ends.
	
	  By default, "ud2" is a dead end unless otherwise annotated, because
	  GCC 7 inserts it for certain divide-by-zero cases.
	
	  Check for manually annotated dead ends.
	
	  These manually annotated reachable checks are needed for GCC 4.4,
	  where the Linux unreachable() macro isn't supported.  In that case
	  GCC doesn't know the "ud2" is fatal, so it generates code as if it's
	  not a dead end.
 populate reloc for 'addr' 
 find key symbol 
			
			  For modules(), the key might not be exported, which
			  means the module can make static calls but isn't
			  allowed to change them.
			 
			  In that case we temporarily set the key to be the
			  trampoline address.  This is fixed up in
			  static_call_add_module().
 populate reloc for 'key' 
  Warnings shouldn't be reported for ignored functions.
  This is a whitelist of functions that is allowed to be called with AC set.
  The list is meant to be minimal and only contains compiler instrumentation
  ABI and a few functions used to implement _{to,from}_user() functions.
  These functions must not directly change AC, but may PUSHFPOPF.
 KASAN 
 KASAN out-of-line 
 KASAN in-line 
 KCSAN 
 KCSANTSAN 
 KCOV 
 UBSAN 
 misc 
 CONFIG_TRACE_BRANCH_PROFILING 
  FIXME: For now, just ignore any alternatives which add retpolines.  This is
  a temporary hack, as it doesn't allow ORC to unwind from inside a retpoline.
  But it at least allows objtool to understand the control flow around the
  retpoline.
	
	  Alternative replacement code is just template code which is
	  sometimes copied to the original instruction. For now, don't
	  annotate it. (In the future we might consider annotating the
	  original instruction ifwhen it ever makes sense to do so.)
	
	  Many compilers cannot disable KCOV with a function attribute
	  so they need a little help, NOP out any KCOV calls from noinstr
	  text.
	
	  Whatever stack impact regular CALLs have, should be undone
	  by the RETURN of the called function.
	 
	  Annotated intra-function calls retain the stack_ops but
	  are converted to JUMP, see read_intra_function_calls().
	
	  Retpoline callsjumps are really dynamic callsjumps in disguise,
	  so convert them accordingly.
	
	  Whatever stack impact regular CALLs have, should be undone
	  by the RETURN of the called function.
	 
	  Annotated intra-function calls retain the stack_ops but
	  are converted to JUMP, see read_intra_function_calls().
  Find the destination instructions for all jumps.
 internal or external sibling call (with reloc) 
 non-func asm code jumping to another file 
			
			  This is a special case where an alt instruction
			  jumps past the end of the section.  These are
			  handled later in handle_group_alt().
		
		  Cross-function jump.
			
			  For GCC 8+, create parentchild links for any cold
			  subfunctions.  This is _mostly_ redundant with a
			  similar initialization in read_symbols().
			 
			  If a function has aliases, we want the first such
			  function in the symbol table to be the subfunction's
			  parent.  In that case we overwrite the
			  initialization done in read_symbols().
			 
			  However this code can't completely replace the
			  read_symbols() code because this doesn't detect the
			  case where the parent function's only reference to a
			  subfunction is through a jump table.
 internal sibling call (without reloc) 
  Find the destination instructions for all calls.
  The .alternatives section requires some extra special care over and above
  other special sections because alternatives are patched in place.
		
		  Insert a fake nop at the end to make the replacement
		  alt_group the same size as the original.  This is needed to
		  allow propagate_alt_cfi() to do its magic.  When the last
		  instruction affects the stack, the instruction after it (the
		  nop) will propagate the new state to the shared CFI array.
		
		  Since alternative replacement code is copypasted by the
		  kernel after applying relocations, generally such code can't
		  have relative-address relocation references to outside the
		  .altinstr_replacement section, unless the arch's
		  alternatives code can adjust the relative offsets
		  accordingly.
  A jump table entry can either convert a nop to a jump or a jump to a nop.
  If the original instruction is a jump, make the alt entry an effective nop
  by just skipping the original instruction.
  Read all the special sections which have alternate instructions which can be
  patched in or redirected to at runtime.  Each instruction having alternate
  instruction(s) has them added to its insn->alts list, which will be
  traversed in validate_branch().
	
	  Each @reloc is a switch table relocation which points to the target
	  instruction.
 Check for the end of the table: 
 Make sure the table entries are consecutive: 
 Detect function pointers from contiguous objects: 
 Make sure the destination is in the same function: 
  find_jump_table() - Given a dynamic jump, find the switch jump table
  associated with it.
	
	  Backward search using the @first_jump_src links, these help avoid
	  much of the 'in between' code. Which avoids us getting confused by
	  it.
 allow small jumps within the range 
  First pass: Mark the head of each jump table so that in the next pass,
  we know when a given jump table ends and the next one starts.
		
		  Store back-pointers for unconditional forward jumps such
		  that find_jump_table() can back-track using those and
		  avoid some potentially confusing code.
  For some switch statements, gcc generates a jump table in the .rodata
  section which contains a list of addresses within the function to jump to.
  This finds these jump tables and adds them to the insn->alts lists.
		
		  Treat intra-function CALLs as JMPs, but with a stack_op.
		  See add_call_destinations(), which strips stack_ops from
		  normal CALLs.
	
	  Search for the following rodata sections, each of which can
	  potentially contain jump tables:
	 
	  - .rodata: can contain GCC switch tables
	  - .rodata.<func>: same, if -fdata-sections is being used
	  - .rodata..c_jump_table: contains C annotated jump tables
	 
	  .rodata.str1. sections are ignored; they don't contain jump tables.
	
	  Must be before add_{jump_call}_destination.
	
	  Must be before add_special_section_alts() as that depends on
	  jump_dest being set.
	
	  Must be before add_call_destination(); it changes INSN_CALL to
	  INSN_JUMP.
 push 
 pop 
 add immediate to sp 
  A note about DRAP stack alignment:
  GCC has the concept of a DRAP register, which is used to help keep track of
  the stack pointer when aligning the stack.  r10 or r13 is used as the DRAP
  register.  The typical DRAP pattern is:
    4c 8d 54 24 08		lea    0x8(%rsp),%r10
    48 83 e4 c0		and    $0xffffffffffffffc0,%rsp
    41 ff 72 f8		pushq  -0x8(%r10)
    55				push   %rbp
    48 89 e5			mov    %rsp,%rbp
 				(more pushes)
    41 52			push   %r10
 				...
    41 5a			pop    %r10
 				(more pops)
    5d				pop    %rbp
    49 8d 62 f8		lea    -0x8(%r10),%rsp
    c3				retq
  There are some variations in the epilogues, like:
    5b				pop    %rbx
    41 5a			pop    %r10
    41 5c			pop    %r12
    41 5d			pop    %r13
    41 5e			pop    %r14
    c9				leaveq
    49 8d 62 f8		lea    -0x8(%r10),%rsp
    c3				retq
  and:
    4c 8b 55 e8		mov    -0x18(%rbp),%r10
    48 8b 5d e0		mov    -0x20(%rbp),%rbx
    4c 8b 65 f0		mov    -0x10(%rbp),%r12
    4c 8b 6d f8		mov    -0x8(%rbp),%r13
    c9				leaveq
    49 8d 62 f8		lea    -0x8(%r10),%rsp
    c3				retq
  Sometimes r13 is used as the DRAP register, in which case it's saved and
  restored beforehand:
    41 55			push   %r13
    4c 8d 6c 24 10		lea    0x10(%rsp),%r13
    48 83 e4 f0		and    $0xfffffffffffffff0,%rsp
 				...
    49 8d 65 f0		lea    -0x10(%r13),%rsp
    41 5d			pop    %r13
    c3				retq
 stack operations don't make sense with an undefined CFA 
 mov %rsp, %rbp 
 drap: mov %rsp, %rbp 
				
				  mov %rsp, %reg
				 
				  This is needed for the rare case where GCC
				  does:
				 
				    mov    %rsp, %rax
				    ...
				    mov    %rax, %rsp
				
				  mov %rbp, %rsp
				 
				  Restore the original stack pointer (Clang).
 mov %reg, %rsp 
					
					  This is needed for the rare case
					  where GCC does something dumb like:
					 
					    lea    0x8(%rsp), %rcx
					    ...
					    mov    %rcx, %rsp
					
					  Stack swizzle:
					 
					  1: mov %rsp, (%[tos])
					  2: mov %[tos], %rsp
					     ...
					  3: pop %rsp
					 
					  Where:
					 
					  1 - places a pointer to the previous
					      stack at the Top-of-Stack of the
					      new stack.
					 
					  2 - switches to the new stack.
					 
					  3 - pops the Top-of-Stack to restore
					      the original stack.
					 
					  Note: we set base to SP_INDIRECT
					  here and preserve offset. Therefore
					  when the unwinder reaches ToS it
					  will dereference SP and then add the
					  offset to find the next frame, IOW:
					  (%rsp) + offset.
				
				  The same stack swizzle case 2) as above. But
				  because we can't change cfa->base, case 3)
				  will become a regular POP. Pretend we're a
				  PUSH so things don't go unbalanced.
 add imm, %rsp 
 lea disp(%rbp), %rsp 
 lea disp(%rsp), %rbp 
 drap: lea disp(%rsp), %drap 
				
				  lea disp(%rsp), %reg
				 
				  This is needed for the rare case where GCC
				  does something dumb like:
				 
				    lea    0x8(%rsp), %rcx
				    ...
				    mov    %rcx, %rsp
 drap: lea disp(%drap), %rsp 
 drap: and imm, %rsp 
			
			  Older versions of GCC (4.8ish) realign the stack
			  without DRAP, with a frame pointer.
 pop %rsp; # restore from a stack swizzle 
 pop %rbp 
 drap: pop %drap 
 pop %reg 
 mov disp(%rsp), %rbp 
 drap: mov disp(%rbp), %drap 
 drap: mov disp(%rbp), %reg 
 mov disp(%rbp), %reg 
 mov disp(%rsp), %reg 
 mov disp(%rsp), %reg 
 drap: push %drap 
 save drap so we know when to restore it 
 drap: push %rbp 
 drap: push %reg 
 push %reg 
 detect when asm code uses rbp as a scratch register 
 drap: mov %drap, disp(%rbp) 
 save drap offset so we know when to restore it 
 drap: mov reg, disp(%rbp) 
 mov reg, disp(%rbp) 
 mov reg, disp(%rsp) 
 mov reg, disp(%rsp) 
 mov %rsp, (%reg); # setup a stack swizzle. 
 pop mem 
  The stack layouts of alternatives instructions can sometimes diverge when
  they have stack modifications.  That's fine as long as the potential stack
  layouts don't conflict at any given potential instruction boundary.
  Flatten the CFIs of the different alternative code streams (both original
  and replacement) into a single shared CFI array which can be used to detect
  conflicts and nicely feed a linear array of ORC entries to the unwinder.
	
	  We can't deal with indirect function calls at present;
	  assume they're instrumented.
	
	  If the symbol is from a noinstr section; we good.
	
	  The __ubsan_handle_() calls are like WARN(), they only happen when
	  something 'BAD' happened. At the risk of taking the machine down,
	  let them proceed to get the message out.
	
	  Simulate the fact that alternatives are patched in-place.  When the
	  end of a replacement alt_group is reached, redirect objtool flow to
	  the end of the original alt_group.
  Follow the branch starting at the given instruction, and recursively follow
  any other branches (jumps).  Meanwhile, track the frame pointer state at
  each instruction and validate all the rules described in
  toolsobjtoolDocumentationstack-validation.txt.
 XXX track if we actually changed state.cfi 
		
		  .init.text code is ran before userspace and thus doesn't
		  strictly need retpolines, except for modules which are
		  loaded late, they very much do need retpoline in their
		  .init.text
	
	  Ignore any unused exceptions.  This can happen when a whitelisted
	  function has an exception table entry.
	 
	  Also ignore alternative replacement instructions.  This can happen
	  when a whitelisted function uses one of the ALTERNATIVE macros.
	
	  CONFIG_UBSAN_TRAP inserts a UD2 when it sees
	  __builtin_unreachable().  The BUG() macro has an unreachable() after
	  the UD2, which causes GCC's undefined trap logic to emit another UD2
	  (or occasionally a JMP to UD2).
	 
	  It may also insert a UD2 after calling a __noreturn function.
	
	  Check if this (or a subsequent) instruction is related to
	  CONFIG_UBSAN or CONFIG_KASAN.
	 
	  End the search at 5 instructions to avoid going into the weeds.
	
	   For now, don't fail the kernel build on fatal warnings.  These
	   errors are still fairly common due to the growing matrix of
	   supported toolchains and their recent pace of change.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2017 Josh Poimboeuf <jpoimboe@redhat.com>
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2020 Matt Helsley <mhelsley@vmware.com>
  Weak definitions necessary to compile objtool without
  some subcommands (e.g. check, orc).
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2015 Josh Poimboeuf <jpoimboe@redhat.com>
  This file reads all the special sections which have alternate instructions
  which can be patched in or redirected to at runtime.
 group only 
 ALTERNATIVE macro CPU feature 
 jump_label key 
 _ASM_EXTABLE_EX hack 
  Read all the special sections and create a list of special_alt structs which
  describe all the alternate instructions which can be patched in or
  redirected to at runtime.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2017 Josh Poimboeuf <jpoimboe@redhat.com>
 populate ORC data 
 populate reloc for ip 
 Build a deduplicated list of ORC entries: 
			
			  Alternatives can have different stack layout
			  possibilities (but they shouldn't conflict).
			  Instead of traversing the instructions, use the
			  alt_group's flattened byte-offset-addressed CFI
			  array.
 errors are reported on the original insn 
 Skip to the end of the alt_group 
 Add a section terminator 
 Create .orc_unwind, .orc_unwind_ip and .rela.orc_unwind_ip sections: 
 Write ORC entries to sections: 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2015 Josh Poimboeuf <jpoimboe@redhat.com>
  objtool:
  The 'check' subcmd analyzes every .o file and ensures the validity of its
  stack trace metadata.  It enforces a set of rules on asm code and C inline
  assembly code so that stack traces can be reliable.
  For more information, see toolsobjtoolDocumentationstack-validation.txt.
	
	  These functions will be patched into native code,
	  see paravirt_patch().
 libsubcmd init 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2017 Josh Poimboeuf <jpoimboe@redhat.com>
  objtool orc:
  This command analyzes a .o file and adds .orc_unwind and .orc_unwind_ip
  sections to it, which is used by the in-kernel ORC unwinder.
  This command is a superset of "objtool check".
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2015 Josh Poimboeuf <jpoimboe@redhat.com>
  Helpers to decode ModRMSIB:
  rm| AX  CX  DX  BX |  SP |  BP |  SI  DI |
     | R8  R9 R10 R11 | R12 | R13 | R14 R15 |
  Mod+----------------+-----+-----+---------+
  00 |    [rm]       |[SIB]|[IP+]|  [rm]  |
  01 |  [rm + d8]    |[S+d]|   [rm + d8]  |
  10 |  [rm + d32]   |[S+D]|   [rm + d32] |
  11 |                   r m               |
 sib_scale = 0,  sib_index = 0, sib_base = 0;
 sib_scale = X86_SIB_SCALE(sib); 
 addsub reg, %rsp 
 push reg 
 pop reg 
 push immediate 
		
		  1000 00sw : mod OP rm : immediate
		 
		  s - sign extend immediate
		  w - imm8  imm32
		 
		  OP: 000 ADD    100 AND
		      001 OR     101 SUB
		      010 ADC    110 XOR
		      011 SBB    111 CMP
 64bit only 
 %rsp target only 
 sign extend 
 imm32 
 imm8 
 fallthrough 
 addsub imm, %rsp 
 and imm, %rsp 
 WARN ? 
 mov %rsp, reg 
 skip RIP relative displacement 
 skip nontrivial SIB 
 mov %rsp, disp(%reg) 
 mov reg, %rsp 
 fallthrough 
 mov reg, disp(%rbp) 
 mov reg, disp(%rsp) 
 mov disp(%rbp), reg 
 mov disp(%rsp), reg 
 skip non 64bit ops 
 skip RIP relative displacement 
 skip nontrivial SIB 
 lea disp(%src), %dst 
 lea (%src), %dst 
 lea disp(%src), %dst 
 pop to mem 
 pushf 
 popf 
 sysenter, sysret 
 ud2 
 noplnopw 
 push fsgs 
 pop fsgs 
		
		  leave
		 
		  equivalent to:
		  mov bp, sp
		  pop bp
 jecxzjrcxz 
 mov imm, rm 
 iret 
		
		  Handle sync_core(), which has an IRET to self.
		  All other IRET are in STT_NONE entry code.
 add $40, %rsp 
 fallthrough 
 retf 
 retf 
		
		  For the impact on the stack, a CALL behaves like
		  a PUSH of an immediate value (the return address).
 jmpf 
 push from mem 
 initial CFA (call frame address) 
 initial RA (return address) 
 SPDX-License-Identifier: GPL-2.0-or-later
		
		  If UACCESS validation is enabled; force that alternative;
		  otherwise force it the other way.
		 
		  What we want to avoid is having both the original and the
		  alternative code flow at the same time, in that case we can
		  find paths that see the STAC but take the NOP instead of
		  CLAC and the other way around.
		
		  It has been requested that we don't validate the !POPCNT
		  feature path which is a "very very small percentage of
		  machines".
	
	  The x86 alternatives code adjusts the offsets only when it
	  encounters a branch instruction at the very beginning of the
	  replacement group.
  There are 3 basic jump table patterns:
  1. jmpq [rodata addr](,%reg,8)
     This is the most common case by far.  It jumps to an address in a simple
     jump table which is stored in .rodata.
  2. jmpq [rodata addr](%rip)
     This is caused by a rare GCC quirk, currently only seen in three driver
     functions in the kernel, only with certain obscure non-distro configs.
     As part of an optimization, GCC makes a copy of an existing switch jump
     table, modifies it, and then hard-codes the jump (albeit with an indirect
     jump) to use a single entry in the table.  The rest of the jump table and
     some of its jump targets remain as dead code.
     In such a case we can just crudely ignore all unreachable instruction
     warnings for the entire object file.  Ideally we would just ignore them
     for the function, but that would require redesigning the code quite a
     bit.  And honestly that's just not worth doing: unreachable instruction
     warnings are of questionable value anyway, and this is such a rare issue.
  3. mov [rodata addr],%reg1
     ... some instructions ...
     jmpq (%reg1,%reg2,8)
     This is a fairly uncommon pattern which is new for GCC 6.  As of this
     writing, there are 11 occurrences of it in the allmodconfig kernel.
     As of GCC 7 there are quite a few more of these and the 'in between' code
     is significant. Esp. with KASAN enabled some of the code between the mov
     and jmpq uses .rodata itself, which can confuse things.
     TODO: Once we have DWARF CFI and smarter instruction decoding logic,
     ensure the same register is used in the mov and jump instructions.
     NOTE: RETPOLINE made it harder still to decode dynamic jumps.
 look for a relocation which references .rodata 
	
	  Make sure the .rodata address isn't associated with a
	  symbol.  GCC jump tables are anonymous data.
	 
	  Also support C jump tables which are in the same format as
	  switch jump tables.  For objtool to recognize them, they
	  need to be placed in the C_JUMP_TABLE_SECTION section.  They
	  have symbols associated with them.
	
	  Each table entry has a rela associated with it.  The rela
	  should reference text in the same function as the original
	  instruction.
	
	  Use of RIP-relative switch jumps is quite rare, and
	  indicates a rare GCC quirkbug which can leave dead
	  code behind.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2017, 2018, 2019, 2021 BMW Car IT GmbH
  Author: Viktor Rosendahl (viktor.rosendahl@bmw.de)
  The default tracer will be the first on this list that is supported by the
  currently running Linux kernel.
 This is the list of tracers for which random sleep makes sense 
  It's not worth it to call cleanup_exit() from mutex functions because
  cleanup_exit() uses mutexes.
	
	  We try the print_mtx for 1 sec in order to avoid garbled
	  output if possible, but if it cannot be obtained we proceed anyway.
	
	  We do not need to unlock the print_mtx here because we will exit at
	  the end of this function. Unlocking print_mtx causes problems if a
	  print thread happens to be waiting for the mutex because we have
	  just changed the ftrace settings to the original and thus the
	  print thread would output incorrect data from ftrace.
 Should never happen 
 Should never happen...
	
	  If there is only one slot left we will anyway lie and claim that the
	  queue is full because adding an element will make it appear empty
 These prints could happen concurrently 
 Save some space for the final string and final null char 
 Add the reserve space back to the budget for the final string 
 These prints could happen concurrently 
 We may be called from cleanup_exit() via set_trace_opt() 
 Do nothing if we now that the current and new value are equal 
	
	  We only set options if we earlier detected that the option exists in
	  the trace_options file and that the wanted setting is different from
	  the one we saw in save_and_disable_tracer()
		
		  We must disable the tracer before resetting the max_latency
		
		  We must reset the max_latency before the inotify_add_watch()
		  call.
 These prints could happen concurrently 
		
		  Toss a coin to decide if we want to sleep before printing
		  out the backtrace. The reason for this is that opening
		  syskerneldebugtracingtrace will cause a blackout of
		  hundreds of ms, where no latencies will be noted by the
		  latency tracer. Thus by randomly sleeping we try to avoid
		  missing traces systematically due to this. With this option
		  we will sometimes get the first latency, some other times
		  some of the later ones, in case of closely spaced traces.
 A print is ongoing 
				
				  We will do the printout below so we have to
				  mark it as completed while we still have the
				  mutex.
			
			  slept < 0  means that we detected another
			  notification in go_to_sleep() above
				
				  N.B. printstate_cnt_dec(); will be called
				  inside print_tracefile()
 This is needed in show_usage() 
 This is needed in show_usage() 
	
	  We must do this before parsing the arguments because show_usage()
	  needs to display these.
 SPDX-License-Identifier: GPL-2.0-or-later
  x86 instruction attribute tables
  Written by Masami Hiramatsu <mhiramat@redhat.com>
 __ignore_sync_check__ 
 Attribute tables are generated from opcode map 
 Attribute search APIs 
 At first, this checks the master table 
 If this is not a group, get attribute directly 
 SPDX-License-Identifier: GPL-2.0-or-later
  x86 instruction analysis
  Copyright (C) IBM Corporation, 2002, 2004, 2009
 __ignore_sync_check__ 
 __ignore_sync_check__ 
 __ignore_sync_check__ 
 __ignore_sync_check__ 
 Verify next sizeof(t) bytes can be on the same instruction 
  insn_init() - initialize struct insn
  @insn:	&struct insn to be initialized
  @kaddr:	address (in kernel memory) of instruction (or copy thereof)
  @buf_len:	length of the insn buffer at @kaddr
  @x86_64:	!0 for 64-bit kernel or 64-bit app
	
	  Instructions longer than MAX_INSN_SIZE (15 bytes) are invalid
	  even if the input buffer is long enough to hold them.
  insn_get_prefixes - scan x86 instruction prefix bytes
  @insn:	&struct insn containing instruction
  Populates the @insn->prefixes bitmap, and updates @insn->next_byte
  to point to the (first) opcode.  No effect if @insn->prefixes.got
  is already set.
   Returns:
  0:  on success
  < 0: on error
 Skip if same prefix 
 Invalid instruction 
 address size switches 24 or 48 
 oprand size switches 24 
 Set the last prefix 
 Swap the last prefix 
 Decode REX prefix 
 REX.W overrides opnd_size 
 Decode VEX prefix 
			
			  In 32-bits mode, if the [7:6] bits (mod bits of
			  ModRM) on the second byte are not 11b, it is
			  LDS or LES or BOUND.
 VEX.W overrides opnd_size 
 VEX.W overrides opnd_size 
			
			  For VEX2, fake VEX3-like byte#2.
			  Makes it easier to decode vex.W, vex.vvvv,
			  vex.L and vex.pp. Masking with 0x7f sets vex.W == 0.
  insn_get_opcode - collect opcode(s)
  @insn:	&struct insn containing instruction
  Populates @insn->opcode, updates @insn->next_byte to point past the
  opcode byte(s), and set @insn->attr (except for groups).
  If necessary, first collects any preceding (prefix) bytes.
  Sets @insn->opcode.value = opcode1.  No effect if @insn->opcode.got
  is already 1.
  Returns:
  0:  on success
  < 0: on error
 Get first opcode 
 Check if there is VEX prefix or not 
 This instruction is bad 
 VEX has only 1 byte for opcode 
 Get escaped opcode 
 This instruction is bad 
  insn_get_modrm - collect ModRM byte, if any
  @insn:	&struct insn containing instruction
  Populates @insn->modrm and updates @insn->next_byte to point past the
  ModRM byte, if any.  If necessary, first collects the preceding bytes
  (prefixes and opcode(s)).  No effect if @insn->modrm.got is already 1.
  Returns:
  0:  on success
  < 0: on error
 Bad insn 
  insn_rip_relative() - Does instruction use RIP-relative addressing mode?
  @insn:	&struct insn containing instruction
  If necessary, first collects the instruction up to and including the
  ModRM byte.  No effect if @insn->x86_64 is 0.
	
	  For rip-relative instructions, the mod field (top 2 bits)
	  is zero and the rm field (bottom 3 bits) is 0x5.
  insn_get_sib() - Get the SIB byte of instruction
  @insn:	&struct insn containing instruction
  If necessary, first collects the instruction up to and including the
  ModRM byte.
  Returns:
  0: if decoding succeeded
  < 0: otherwise.
  insn_get_displacement() - Get the displacement of instruction
  @insn:	&struct insn containing instruction
  If necessary, first collects the instruction up to and including the
  SIB byte.
  Displacement value is sign-expanded.
   Returns:
  0: if decoding succeeded
  < 0: otherwise.
		
		  Interpreting the modrm byte:
		  mod = 00 - no displacement fields (exceptions below)
		  mod = 01 - 1-byte displacement field
		  mod = 10 - displacement field is 4 bytes, or 2 bytes if
		  	address size = 2 (0x67 prefix in 32-bit mode)
		  mod = 11 - no memory operand
		 
		  If address size = 2...
		  mod = 00, rm = 110 - displacement field is 2 bytes
		 
		  If address size != 2...
		  mod != 11, rm = 100 - SIB byte exists
		  mod = 00, SIB base = 101 - displacement field is 4 bytes
		  mod = 00, rm = 101 - rip-relative addressing, displacement
		  	field is 4 bytes
 Decode moffset163264. Return 0 if failed 
 opnd_bytes must be modified manually 
 Decode imm v32(Iz). Return 0 if failed 
 opnd_bytes must be modified manually 
 Decode imm v64(IvOv), Return 0 if failed 
 opnd_bytes must be modified manually 
 Decode ptr16:1632(Ap) 
 ptr16:64 is not exist (no segment) 
 opnd_bytes must be modified manually 
  insn_get_immediate() - Get the immediate in an instruction
  @insn:	&struct insn containing instruction
  If necessary, first collects the instruction up to and including the
  displacement bytes.
  Basically, most of immediates are sign-expanded. Unsigned-value can be
  computed by bit masking with ((1 << (nbytes  8)) - 1)
  Returns:
  0:  on success
  < 0: on error
 no immediates 
 Here, insn must have an immediate, but failed 
  insn_get_length() - Get the length of instruction
  @insn:	&struct insn containing instruction
  If necessary, first collects the instruction up to and including the
  immediates bytes.
  Returns:
   - 0 on success
   - < 0 on error
 Ensure this instruction is decoded completely 
  insn_decode() - Decode an x86 instruction
  @insn:	&struct insn to be initialized
  @kaddr:	address (in kernel memory) of instruction (or copy thereof)
  @buf_len:	length of the insn buffer at @kaddr
  @m:		insn mode, see enum insn_mode
  Returns:
  0: if decoding succeeded
  < 0: otherwise.
 __ignore_sync_check__ mode is only valid in the kernel 
 SPDX-License-Identifier: GPL-2.0
 Cover both single-bit flag and multiple-bits fields 
 start and end bits 
 0 or 1 for 1-bit flag 
 descriptor info for eaxebxecxedx 
 number of valid entries 
 Represent one leaf (basic or extended) 
	
	  Array of subleafs for this func, if there is no subleafs
	  then the leafs[0] is the main leaf
 array of main leafs 
 number of valid leafs 
  basic:  basic functions range: [0... ]
  ext:    extended functions range: [0x80000000... ]
 ecx is often an input as well as an output. 
 Return true is the input eaxebxecxedx are all zero 
	
	  Cut off vendor-prefix from CPUID function as we're using it as an
	  index into ->funcs.
 Skip leaf without valid items 
 First item is the main leaf, followed by all subleafs 
		
		  Some can provide the exact number of subleafs,
		  others have to be tried (0xf)
  The basic row format for cpuid.csv  is
 	LEAF,SUBLEAF,register_name,bits,short name,long description
  like:
 	0,    0,  EAX,   31:0, max_basic_leafs,  Max input value for supported subleafs
 	1,    0,  ECX,      0, sse3,  Streaming SIMD Extensions 3(SSE3)
	
	  Tokens:
	   1. leaf
	   2. subleaf
	   3. register
	   4. bits
	   5. short name
	   6. long detail
 Skip comments and NULL line 
 indexmain-leaf 
 Skip line parsing for non-existing indexes 
 Return if the index has no valid item on this platform 
 subleaf 
 bit flag or bits field 
 start != NULL means it is bit fields 
 Parse csv file, and construct the array of all leafs and subleafs 
 Fallback to a csv in the same dir 
 Decode every eaxebxecxedx 
 single bit flag 
 bit fields 
 Show all of the raw output of 'cpuid' instr 
 Only show specific leafsubleaf info 
 Dump the raw data also 
 Check vendor 
 "htuA" 
 Setup leafs for the basic and extended range 
 show both bit flags and fields 
 only show bit flags, default on 
 show detail descriptions 
 use user's cpuid file 
 show usage 
 only check a specific leaf 
 show raw CPUID leaf data 
 check a specific subleaf 
 main leaf 
 subleaf 
  Do 4 things in turn:
  1. Parse user options
  2. Parse and store all the CPUID leaf data supported on this platform
  2. Parse the csv file, while skipping leafs which are not available
     on this platform
  3. Print leafs info based on user options
 Setup the cpuid leafs of current platform 
 Read and parse the 'cpuid.csv' 
  dslm.c
  Simple Disk Sleep Monitor
   by Bartek Kania
  Licensed under the GPL
 Check if the disk is in powersave-mode
  Most of the code is stolen from hdparm.
 try again with 0x98 
 "unknown"; 
 "sleeping"; 
 Compensate for SIGINT 
 Parse the simple command-line 
 SPDX-License-Identifier: GPL-2.0-only
 Disk protection for HPDELL machines.
  Copyright 2008 Eric Piel
  Copyright 2009 Pavel Machek <pavel@ucw.cz>
  Copyright 2012 Sonal Santan
  Copyright 2014 Pali Rohr <pali@kernel.org>
 sysclasspower_supplyAC0online 
 procacpibuttonlidLIDstate 
 Alarm expired, time to unpark the heads 
 SPDX-License-Identifier: GPL-2.0-only
 Industrialio event test code.
  Copyright (c) 2011-2012 Lars-Peter Clausen <lars@metafoo.de>
  This program is primarily intended as an example application.
  Reads the current buffer setup from sysfs and starts a short capture
  from the specified device, pretty printing the result after appropriate
  conversion.
  Usage:
 	iio_event_monitor <device_name>
 Enable or disable events in sysfs if the knob is available 
 Look up sysfs dir as well if we can 
		
		  If we can't find an IIO device by name assume device_name is
		  an IIO chrdev
 Disable events after use 
 SPDX-License-Identifier: GPL-2.0-only
  Industrial IO utilities - lsiio.c
  Copyright (c) 2010 Manuel Stahl <manuel.stahl@iis.fraunhofer.de>
 0 gives lspci behaviour 
 1 lists sensors 
 SPDX-License-Identifier: GPL-2.0-only
 IIO - useful set of util functionality
  Copyright (c) 2008 Jonathan Cameron
  iioutils_break_up_name() - extract generic name from full channel name
  @full_name: the full channel name
  @generic_name: the output generic channel name
  Returns 0 on success, or a negative error code if string extraction failed.
  iioutils_get_type() - find and process _type attribute data
  @is_signed: output whether channel is signed
  @bytes: output how many bytes the channel storage occupies
  @bits_used: output number of valid bits of data
  @shift: output amount of bits to shift right data before applying bit mask
  @mask: output a bit mask for the raw data
  @be: output if data in big endian
  @device_dir: the IIO device directory
  @buffer_idx: the IIO buffer index
  @name: the channel name
  @generic_name: the channel type name
  Returns a value >= 0 on success, otherwise a negative error code.
			
			  Avoid having a more generic entry overwriting
			  the settings.
  iioutils_get_param_float() - read a float value from a channel parameter
  @output: output the float value
  @param_name: the parameter name to read
  @device_dir: the IIO device directory in sysfs
  @name: the channel name
  @generic_name: the channel type name
  Returns a value >= 0 on success, otherwise a negative error code.
  bsort_channel_array_by_index() - sort the array in index order
  @ci_array: the iio_channel_info array to be sorted
  @cnt: the amount of array elements
  build_channel_array() - function to figure out what channels are present
  @device_dir: the IIO device directory in sysfs
  @buffer_idx: the IIO buffer for this channel array
  @ci_array: output the resulting array of iio_channel_info
  @counter: output the amount of array elements
  Returns 0 on success, otherwise a negative error code.
 decrement count to avoid freeing name 
 Get the generic and specific name elements 
 Find the scale 
 reorder so that the array is in index order 
  find_type_by_name() - function to match top level types by name
  @name: top level type instance name
  @type: the type of top level instance being searched
  Returns the device number of a matched IIO device on success, otherwise a
  negative error code.
  Typical types this is used for are device and trigger.
 verify the next character is not a colon 
  write_sysfs_int() - write an integer value to a sysfs file
  @filename: name of the file to write to
  @basedir: the sysfs directory in which the file is to be found
  @val: integer value to write to file
  Returns a value >= 0 on success, otherwise a negative error code.
  write_sysfs_int_and_verify() - write an integer value to a sysfs file
 				  and verify
  @filename: name of the file to write to
  @basedir: the sysfs directory in which the file is to be found
  @val: integer value to write to file
  Returns a value >= 0 on success, otherwise a negative error code.
  write_sysfs_string_and_verify() - string write, readback and verify
  @filename: name of file to write to
  @basedir: the sysfs directory in which the file is to be found
  @val: the string to write
  Returns a value >= 0 on success, otherwise a negative error code.
  write_sysfs_string() - write string to a sysfs file
  @filename: name of file to write to
  @basedir: the sysfs directory in which the file is to be found
  @val: the string to write
  Returns a value >= 0 on success, otherwise a negative error code.
  read_sysfs_posint() - read an integer value from file
  @filename: name of file to read from
  @basedir: the sysfs directory in which the file is to be found
  Returns the read integer value >= 0 on success, otherwise a negative error
  code.
  read_sysfs_float() - read a float value from file
  @filename: name of file to read from
  @basedir: the sysfs directory in which the file is to be found
  @val: output the read float value
  Returns a value >= 0 on success, otherwise a negative error code.
  read_sysfs_string() - read a string from file
  @filename: name of file to read from
  @basedir: the sysfs directory in which the file is to be found
  @str: output the read string
  Returns a value >= 0 on success, otherwise a negative error code.
 SPDX-License-Identifier: GPL-2.0-only
 Industrialio buffer test code.
  Copyright (c) 2008 Jonathan Cameron
  This program is primarily intended as an example application.
  Reads the current buffer setup from sysfs and starts a short capture
  from the specified device, pretty printing the result after appropriate
  conversion.
  Command line parameters
  generic_buffer -n <device_name> -t <trigger_name>
  If trigger name is not specified the program assumes you want a dataready
  trigger associated with the device and goes looking for it.
  enum autochan - state for the automatic channel enabling mechanism
  size_from_channelarray() - calculate the storage size of a scan
  @channels:		the channel info array
  @num_channels:	number of channels
  Has the side effect of filling the channels[i].location values used
  in processing the buffer output.
	
	  Shift before conversion to avoid sign extension
	  of left aligned data
 First swap if incorrect endian 
	
	  Shift before conversion to avoid sign extension
	  of left aligned data
 First swap if incorrect endian 
	
	  Shift before conversion to avoid sign extension
	  of left aligned data
 First swap if incorrect endian 
	
	  Shift before conversion to avoid sign extension
	  of left aligned data
 special case for timestamp 
  process_scan() - print out the values in SI units
  @data:		pointer to the start of the scan
  @channels:		information about the channels.
 			Note: size_from_channelarray must have been called first
 			      to fill the location offsets.
  @num_channels:	number of channels
 only a few cases implemented so far 
 Disable trigger 
 Disconnect the trigger - just write a dummy name. 
 Disable buffer 
 Disable channels if auto-enabled 
 Find the device requested 
 Fetch device_name if specified by number 
			
			  Build the trigger name. If it is device associated
			  its name is <device_name>_dev[n] where n matches
			  the device number found above.
 Look for this "-devN" trigger 
 OK try the simpler "-trigger" suffix instead 
	
	  Parse the files in scan_elements to identify what channels are
	  present
 This flags that we need to disable the channels again 
			"_en or pass -a to autoenable channels and "
			"try again.\n", dev_dir_name, buffer_idx);
		ret = -ENOENT;
		goto error;
	}
	 
	ret = asprintf(&buf_dir_name,
		       "%siio:device%dbuffer%d", iio_dir, dev_num, buffer_idx);
	if (ret < 0) {
		ret = -ENOMEM;
		goto error;
	}
	if (stat(buf_dir_name, &st)) {
		fprintf(stderr, "Could not stat() '%s', got error %d: %s\n",
			buf_dir_name, errno, strerror(errno));
		ret = -errno;
		goto error;
	}
	if (!S_ISDIR(st.st_mode)) {
		fprintf(stderr, "File '%s' is not a directory\n", buf_dir_name);
		ret = -EFAULT;
		goto error;
	}
	if (!notrigger) {
		printf("%s %s\n", dev_dir_name, trigger_name);
		 
		ret = write_sysfs_string_and_verify("triggercurrent_trigger",
						    dev_dir_name,
						    trigger_name);
		if (ret < 0) {
			fprintf(stderr,
				"Failed to write current_trigger file\n");
			goto error;
		}
	}
	ret = asprintf(&buffer_access, "deviio:device%d", dev_num);
	if (ret < 0) {
		ret = -ENOMEM;
		goto error;
	}
	 Attempt to open non blocking the access dev 
	fd = open(buffer_access, O_RDONLY | O_NONBLOCK);
	if (fd == -1) {  TODO: If it isn't there make the node 
		ret = -errno;
		fprintf(stderr, "Failed to open %s\n", buffer_access);
		goto error;
	}
	 specify for which buffer index we want an FD 
	buf_fd = buffer_idx;
	ret = ioctl(fd, IIO_BUFFER_GET_FD_IOCTL, &buf_fd);
	if (ret == -1 || buf_fd == -1) {
		ret = -errno;
		if (ret == -ENODEV || ret == -EINVAL)
			fprintf(stderr,
				"Device does not have this many buffers\n");
		else
			fprintf(stderr, "Failed to retrieve buffer fd\n");
		goto error;
	}
	 Setup ring buffer parameters 
	ret = write_sysfs_int("length", buf_dir_name, buf_len);
	if (ret < 0)
		goto error;
	 Enable the buffer 
	ret = write_sysfs_int("enable", buf_dir_name, 1);
	if (ret < 0) {
		fprintf(stderr,
			"Failed to enable buffer '%s': %s\n",
			buf_dir_name, strerror(-ret));
		goto error;
	}
	scan_size = size_from_channelarray(channels, num_channels);
	data = malloc(scan_size  buf_len);
	if (!data) {
		ret = -ENOMEM;
		goto error;
	}
	 
	if (buffer_idx == 0) {
		errno = 0;
		read_size = read(fd, data, 1);
		if (read_size > -1 || errno != EBUSY) {
			ret = -EFAULT;
			perror("Reading from '%s' should not be possible after ioctl()");
			goto error;
		}
	}
	 close now the main chardev FD and let the buffer FD work 
	if (close(fd) == -1)
		perror("Failed to close character device file");
	fd = -1;
	for (j = 0; j < num_loops || num_loops < 0; j++) {
		if (!noevents) {
			struct pollfd pfd = {
				.fd = buf_fd,
				.events = POLLIN,
			};
			ret = poll(&pfd, 1, -1);
			if (ret < 0) {
				ret = -errno;
				goto error;
			} else if (ret == 0) {
				continue;
			}
			toread = buf_len;
		} else {
			usleep(timedelay);
			toread = 64;
		}
		read_size = read(buf_fd, data, toread  scan_size);
		if (read_size < 0) {
			if (errno == EAGAIN) {
				fprintf(stderr, "nothing available\n");
				continue;
			} else {
				break;
			}
		}
		for (i = 0; i < read_size  scan_size; i++)
			process_scan(data + scan_size  i, channels,
				     num_channels);
	}
error:
	cleanup();
	if (fd >= 0 && close(fd) == -1)
		perror("Failed to close character device");
	if (buf_fd >= 0 && close(buf_fd) == -1)
		perror("Failed to close buffer");
	free(buffer_access);
	free(data);
	free(buf_dir_name);
	for (i = num_channels - 1; i >= 0; i--) {
		free(channels[i].name);
		free(channels[i].generic_name);
	}
	free(channels);
	free(trigger_name);
	free(device_name);
	free(dev_dir_name);
	return ret;
}
 SPDX-License-Identifier: GPL-2.0
 Short name for field. 
 Location of field, specified in bits; 
 negative means from end of packet.    
 Width of field, 0 means use data_length. 
 TA Document 1999026 
 AVC Digital Interface Command Set General Specification 4.0 
 TA Document 1999025 
 AVC Descriptor Mechanism Specification Version 1.0 
 TA Document 1999015 
 AVC Command Set for Rate Control of Isochronous Data Flow 1.0 
 TA Document 1999008 
 AVC Audio Subunit Specification 1.0 
 TA Document 2001001 
 AVC Panel Subunit Specification 1.1 
 SPDX-License-Identifier: GPL-2.0-or-later
  nosy-dump - Interface to snoop mode driver for TI PCILynx 1394 controllers
  Copyright (C) 2002-2006 Kristian Hgsberg
 Marks the fields we print in transaction view. 
 Allow all ^C except the first to interrupt the program in the usual way. 
 we put the ack in the subaction struct for easy access. 
 HACK: decode only fcp right now. 
 print unfinished transactions 
 Short name for field. 
 Location of field, specified in bits; 
 negative means from end of packet.    
 Width of field, 0 means use data_length. 
 Show options. 
			
			  error, we should only see ack_busy_ before the
			  ack_pendingack_complete -- this is an ack_pending
			  instead (ack_complete would have finished the
			  transaction).
 memcmp() ? 
 error, these should match for retries. 
 error, unified transactions only allowed for write ;
 request subaction phase over, wait for response. 
 ok, wait for retry. 
 check that retry protocol is respected. 
 unsolicited response 
			
			  error, we should only see ack_busy_ before the
			  ack_pendingack_complete
 use memcmp() instead? 
 error, these should match for retries. 
			
			  error, should not get response unless last request got
			  ack_pending.
 error, tcode mismatch 
 transaction complete, remove t from pending list. 
 error for responses. 
 no problem, wait for next retry 
 Bit field spans quadlet boundary. 
		 phy packet are 3 quadlets: the 1 quadlet payload,
		  the bitwise inverse of the payload and the snoop
 Make sure stdin is a terminal. 
 Save the terminal attributes so we can restore them later. 
 Set the funny terminal modes. 
 Clear ICANON and ECHO. 
 SPDX-License-Identifier: GPL-2.0
 read at least 2 bytes, no more than 32 
 SPDX-License-Identifier: GPL-2.0-only
  SPI testing utility (using spidev driver)
  Copyright (c) 2007  MontaVista Software, Inc.
  Copyright (c) 2007  Anton Vorontsov <avorontsov@ru.mvista.com>
  Cross-compile with cross-gcc -Ipathtocross-kernelinclude
 interval in seconds for showing transfer rate 
   Unescape - process hexadecimal escape character
       converts shell input "\x23" -> 0x23
	
	  spi mode
	
	  bits per word
	
	  max speed hz
 SPDX-License-Identifier: GPL-2.0-or-later
  cpufreq-bench CPUFreq microbenchmark
   Copyright (C) 2008 Christian Kornacker <ckornacker@suse.de>
  returns time since epoch in s
  @retval time
  sets the cpufreq governor
  @param governor cpufreq governor name
  @param cpu cpu for which the governor should be set
  @retval 0 on success
  @retval -1 when failed
  sets cpu affinity for the process
  @param cpu cpu# to which the affinity should be set
  @retval 0 on success
  @retval -1 when setting the affinity failed
  sets the process priority parameter
  @param priority priority value
  @retval 0 on success
  @retval -1 when setting the priority failed
  notifies the user that the benchmark may run some time
  @param config benchmark config values
  sets up the cpu affinity and scheduler priority
  @param config benchmark config values
 SPDX-License-Identifier: GPL-2.0-or-later
  cpufreq-bench CPUFreq microbenchmark
   Copyright (C) 2008 Christian Kornacker <ckornacker@suse.de>
 Print out progress if we log into a file 
  compute how many rounds of calculation we should do
  to get the given load time
  @param load aimed load time in s
  @retval rounds of calculation
 get the initial calculation time for a specific number of rounds 
	 approximation of the wanted load time by comparing with the
  benchmark
  generates a specific sleep an load time with the performance
  governor and compares the used time for same calculations done
  with the configured powersave governor
  @param config config values for the benchmark
 For the progress bar 
 powersave and performance cycles 
		 set the cpufreq governor to "performance" which disables
		 calibrate the calculation time. the resulting calculation
		  _rounds should produce a load which matches the configured
 do some sleepload cycles with the performance governor 
		 set the powersave governor which activates P-State switching
		 again, do some sleepload cycles with the
 compare the average sleepload cycles  
 SPDX-License-Identifier: GPL-2.0-or-later
  cpufreq-bench CPUFreq microbenchmark
   Copyright (C) 2008 Christian Kornacker <ckornacker@suse.de>
  converts priority string to priority
  @param str string that represents a scheduler priority
  @retval priority
  @retval SCHED_ERR when the priority doesn't exit
  create and open logfile
  @param dir directory in which the logfile should be created
  @retval logfile on success
  @retval NULL when the file can't be created
  returns the default config
  @retval default config on success
  @retval NULL when the output file can't be created
  parses config file and returns the config to the caller
  @param path config file name
  @retval 1 on error
  @retval 0 on success
 SPDX-License-Identifier: GPL-2.0-or-later
  cpufreq-bench CPUFreq microbenchmark
   Copyright (C) 2008 Christian Kornacker <ckornacker@suse.de>
 usage
 main
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2004-2009  Dominik Brodowski <linux@dominikbrodowski.de>
  Detect whether a CPU is online
  Returns:
      1 -> if CPU is online
      0 -> if CPU is offline
      negative errno values in error case
	
	  kernel without CONFIG_HOTPLUG_CPU
	  -> cpuX directory exists, but not cpuXonline file
 returns -1 on failure, 0 on success 
  Returns amount of cpus, negative on error, cpu_top must be
  passed to cpu_topology_release to free resources
  Array is sorted after ->pkg, ->core, then ->cpu
	 Count the number of distinct pkgs values. This works
	   because the primary sort of the core_info struct was just
	 Intel's cores count is not consecutively numbered, there may
	  be a core_id of 3, but none of 2. Assume there always is 0
	  Get amount of cores by counting duplicates in a package
	for (cpu = 0; cpu_top->core_info[cpu].pkg = 0 && cpu < cpus; cpu++) {
		if (cpu_top->core_info[cpu].core == 0)
	cpu_top->cores++;
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2004-2009  Dominik Brodowski <linux@dominikbrodowski.de>
   (C) 2011       Thomas Renninger <trenn@novell.com> Novell Inc.
  helper function to check whether a file under "..cpuXcpuidlestateX" dir
  exists.
  For example the functionality to disable c-states was introduced in later
  kernel versions, this function can be used to explicitly check for this
  feature.
  returns 1 if the file exists, 0 otherwise.
  helper function to read file from sys into given buffer
  fname is a relative path under "cpuXcpuidlestateX" dir
  cstates starting with 0, C0 is not counted as cstate.
  This means if you want C1 info, pass 0 as idlestate param
  helper function to write a new value to a sys file
  fname is a relative path under "..cpuXcpuidlecstateY" dir
  Returns the number of bytes written or 0 on error
 read access to files which contain one numeric value 
 read access to files which contain one string 
  Returns:
     1  if disabled
     0  if enabled
     -1 if idlestate is not available
     -2 if disabling is not supported by the kernel
  Pass 1 as last argument to disable or 0 to enable the state
  Returns:
     0  on success
     negative values on error, for example:
       -1 if idlestate is not available
       -2 if disabling is not supported by the kernel
       -3 No write access to disableenable C-states
  Returns number of supported C-states of CPU core cpu
  Negativ in error case
  Zero if cpuidle does not export any C-states
 CPUidle general sysdevicessystemcpucpuidle sysfs access 
  helper function to read file from sys into given buffer
  fname is a relative path under "cpucpuidle" dir
 read access to files which contain one string 
 CPUidle idlestate specific sysdevicessystemcpucpuXcpuidle access 
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2004-2009  Dominik Brodowski <linux@dominikbrodowski.de>
 CPUFREQ sysfs access 
 helper function to read file from sys into given buffer 
 fname is a relative path under "cpuXcpufreq" dir 
 helper function to write a new value to a sys file 
 fname is a relative path under "cpuXcpufreq" dir 
 read access to files which contain one numeric value 
 read access to files which contain one string 
 write access 
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2004-2009  Dominik Brodowski <linux@dominikbrodowski.de>
 default 
 count the number of digits to be copied 
 not enough => pad 
 too much => strip 
 check bounds 
 copy digits 
 and pad 
 round up, down ? 
 and drop the decimal part 
 cp > 0 && pad >= 0 ==> i > 0 
 final conversion (and applying rounding) 
		 if only one value of a policy is to be changed, we can
		  use a "fast path".
 slow path 
 parameter parsing 
 parameter checking 
 Default is: set all CPUs 
 Also set frequency settings for related CPUs if -r is passed 
 Set the last cpu in related cpus list 
 loop over CPUs 
 SPDX-License-Identifier: GPL-2.0
 Default is: set all CPUs 
 Not reachable with proper args checking 
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2004-2009  Dominik Brodowski <linux@dominikbrodowski.de>
   (C) 2010       Thomas Renninger <trenn@suse.de>
 Disabled interface not supported on older kernels 
 Default is: show output of CPU 0 only 
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2010,2011       Thomas Renninger <trenn@suse.de>, Novell Inc.
   Ideas taken over from the perf userspace tool (included in the Linus
   kernel git repo): subcommand builtins and param parsing.
 Global cpu_info object available for all binaries
  Info only retrieved from CPU 0
  Values will be zerounknown on non X86 archs
 Affected cpus chosen by -c--cpu param 
	{ "bench",	cmd_bench,	1	}, 
 enough for "cpupower-" 
 should not be reached 
 exits within execlp() 
 Cut out param: cpupower -c 1 info -> cpupower info 
 Turn "perf cmd --help" into "perf help cmd" 
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2004-2009  Dominik Brodowski <linux@dominikbrodowski.de>
 cpu count starts from 0, on error return 1 (UP) 
 ToDo: Make this more global 
	 P state changes via MSR are identified via cpuid 80000007
	   on Intel and AMD, but we assume boost capable machines can do that
	   if (cpuid_eax(0x80000000) >= 0x80000007
	   && (cpuid_edx(0x80000007) & (1 << 7)))
 Any way to autodetect this ? 
 --boost  -b 
 --freq  -f 
 --hwfreq  -w 
 --hwlimits  -l 
 --driver  -d 
 --policy  -p 
 --governors  -g 
 --affected-cpus   -a 
 --related-cpus   -r 
 --stats  -s 
 --latency  -y 
 Default is: show output of CPU 0 only 
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2011 Thomas Renninger <trenn@suse.de>, Novell Inc.
 parameter parsing 
 Default is: show output of CPU 0 only 
 Add more per cpu options here 
 loop over CPUs 
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2011 Thomas Renninger <trenn@suse.de>, Novell Inc.
 parameter parsing 
 Default is: set all CPUs 
 loop over CPUs 
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2010,2011       Thomas Renninger <trenn@suse.de>, Novell Inc.
   Based on SandyBridge monitor. Implements the new package C-states
   (PC8, PC9, PC10) coming with a specific Haswell (family 0x45) CPU.
 valid flag for all CPUs. If a MSR read failed it will be zero 
 HSW 
	.overflow_s		= 922000000  922337203 seconds TSC overflow
 defined(__i386__) || defined(__x86_64__) 
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2010,2011       Thomas Renninger <trenn@suse.de>, Novell Inc
 fix up cpuidle name for intel idle driver 
 Assume idle state count is the same for all CPUs 
 Free this at program termination 
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2010,2011       Thomas Renninger <trenn@suse.de>, Novell Inc.
   Based on Len Brown's <lenb@kernel.org> turbostat tool.
 valid flag for all CPUs. If a MSR read failed it will be zero 
 Free this at program termination 
	.overflow_s		= 922000000  922337203 seconds TSC overflow
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2010,2011       Thomas Renninger <trenn@suse.de>, Novell Inc.
  The max frequency mperf is ticking at (in C0), either retrieved via:
    1) calculated after measurements if we know TSC ticks at mperfP0 frequency
    2) cpufreq sysdevices...cpu0cpufreqcpuinfo_max_freq at init time
  1. Is preferred as it also works without cpufreq subsystem (e.g. on Xen)
 valid flag for all CPUs. If a MSR read failed it will be zero 
	
	  Running on the cpu from which we read the registers will
	  prevent APERFMPERF from going out of sync because of IPI
	  latency introduced by read_msr()s.
 Calculate max_freq from TSC count 
  Mperf register is defined to tick at P0 (maximum) frequency
  Instead of reading out P0 which can be tricky to read out from HW,
  we use TSC counter if it reliably ticks at P0mperf frequency.
  Still try to fall back to:
  sysdevicessystemcpucpu0cpufreqcpuinfo_max_freq
  on older Intel HW without invariant TSC feature.
  Or on AMD machines where TSC does not tick at P0 (do not exist yet, but
  it's still double checked (MSR_AMD_HWCR)).
  On these machines the user would still get useful mperf
  stats when acpi-cpufreq driver is loaded.
		 MSR_AMD_HWCR tells us whether TSC runs at P0mperf
		  freq.
		  A test whether hwcr is accessableavailable would be:
		  (cpupower_cpu_info.family > 0x10 ||
		    cpupower_cpu_info.family == 0x10 &&
		    cpupower_cpu_info.model >= 0x2))
		  This should be the case for all aperfmperf
		  capable AMD machines and is therefore safe to test here.
		  Compare with Linus kernel git commit: acf01734b1747b1ec4
		
		  If the MSR read failed, assume a Xen system that did
		  not explicitly provide access to it and assume TSC works
 Use sysfs max frequency if available  }
		
		  On Intel we assume mperf (in C0) is ticking at same
		  rate than TSC
 Default automatically to MHz value 
  This monitor provides:
  1) Average frequency a CPU resided in
     This always works if the CPU has aperfmperf capabilities
  2) C0 and Cx (any sleep state) time a CPU resided in
     Works if mperf timer stops ticking in sleep states which
     seem to be the case on all current HW.
  Both is directly retrieved from HW registers and is independent
  from kernel statistics.
 Free this at program termination 
	.overflow_s		= 922000000  922337203 seconds TSC overflow
 #if defined(__i386__) || defined(__x86_64__) 
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2010,2011      Thomas Renninger <trenn@suse.de>, Novell Inc.
   PCI initialization based on example code from:
   Andreas Herrmann <andreas.herrmann3@amd.com>
#define OVERFLOW_MS		343597  32 bit register filled at 12500 HZ
 NBP1 needs extra treating -> write 1 to D18F6x98 bit 1 for init 
 Enable monitor 
 Set counter to zero 
 was the bit whether NBP1 got entered set? 
 residency count in 80ns -> divide through 12.5 to get us residency 
 We do not alloc for nbp1 machine wide counter 
	 We need PCI device: Slot 18, Func 6, compare with BKDG
 #if defined(__i386__) || defined(__x86_64__) 
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2010,2011       Thomas Renninger <trenn@suse.de>, Novell Inc.
   Output format inspired by Len Brown's <lenb@kernel.org> turbostat tool.
 Define pointers to all monitors.  
 ToDo: Document this in the manpage 
s is filled with left and right spaces
 to make its length atleast n+1
 Be careful CPUs may got resorted for pkg value do not just use cpu 
	
	  The monitor could still provide useful data, for example
	  AMD HW counters partly sit in PCI config space.
	  It's up to the monitor plug-in to check .is_online, this one
	  is just for additional info.
 param: string passed by -m param (The list of monitors to show)
  Monitors must have been registered already, matching monitors
  are picked out and available monitors array is overridden
  with matching ones
  Monitors get sorted in the same order the user passes them
 Override detectedregisterd monitors array with requested one 
			
			  ToDo show more state capabilities:
			  percent, time (granlarity)
 child 
 parent 
 only allow -i with -m or no option 
 Default is: monitor all CPUs 
	
	  if any params left, it must be a command to fork
	 ToDo: Topology parsing needs fixing first to do
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2010,2011       Thomas Renninger <trenn@suse.de>, Novell Inc.
   Based on Len Brown's <lenb@kernel.org> turbostat tool.
 valid flag for all CPUs. If a MSR read failed it will be zero 
 SNB 
 SNB Xeon 
 IVB 
 IVB Xeon 
 HSW 
 HSW 
 HSW 
 HSW 
	.overflow_s		= 922000000  922337203 seconds TSC overflow
 defined(__i386__) || defined(__x86_64__) 
 SPDX-License-Identifier: GPL-2.0
 Intel specific MSRs 
  read_msr
  Will return 0 on success and -1 on failure.
  Possible errno values could be:
  EFAULT -If the readwrite did not fully complete
  EIO    -If the CPU does not support MSRs
  ENXIO  -If the CPU does not exist
  write_msr
  Will return 0 on success and -1 on failure.
  Possible errno values could be:
  EFAULT -If the readwrite did not fully complete
  EIO    -If the CPU does not support MSRs
  ENXIO  -If the CPU does not exist
 SPDX-License-Identifier: GPL-2.0
 from gcc 
  CPUID functions returning a single datum
  Define unsigned int cpuid_e[abcd]x(unsigned int op)
 defined(__i386__) || defined(__x86_64__) 
 get_cpu_info
  Extract CPU vendor, family, model, stepping info from proccpuinfo
  Returns 0 on success or a negativ error code
  TBD: Should there be a cpuid alternative for this if proc is not mounted?
 Get CPU vendor 
 Get CPU family, etc. 
 Exit -> all values must have been set 
 Get some useful CPU capabilities from cpuid 
 Invariant TSC 
 AperfMperf registers support 
 AMD or Hygon Boost state enabledisable register 
 HW pstate was not implemented in family 0x14 
 Intel's perf-bias MSR support 
 Intel's Turbo Ratio Limit support 
			case 0x1A:	 Core i7, Xeon 5500 series
					  Bloomfield, Gainstown NHM-EP
			case 0x1E:	 Core i7 and i5 Processor
					  Clarksfield, Lynnfield, Jasper Forest
 Core i7 and i5 Processor - Nehalem 
			case 0x25:	 Westmere Client
					  Clarkdale, Arrandale
 Westmere EP - Gulftown 
 SNB 
 SNB Xeon 
 IVB 
 IVB Xeon 
 Nehalem-EX Xeon - Beckton 
 Westmere-EX Xeon - Eagleton 
		printf("ID: %u - Extid: 0x%x - Caps: 0x%llx\n",
		cpuid_level, ext_cpuid_level, cpu_info->caps);
 SPDX-License-Identifier: GPL-2.0
 How many bits in an unsigned long 
 howmany(a,b) : how many elements of size b needed to hold all of a 
 How many longs in mask of n bits 
  Allocate and free `struct bitmask `
 Allocate a new `struct bitmask` with a size of n bits 
 Free `struct bitmask` 
 double free tripwire 
  The routines _getbit() and _setbit() are the only
  routines that actually understand the layout of bmp->maskp[].
  On little endian architectures, this could simply be an array of
  bytes.  But the kernel layout of bitmasks _is_ visible to userspace
  via the sched_(setget)affinity calls in Linux 2.6, and on big
  endian architectures, it is painfully obvious that this is an
  array of unsigned longs.
 Return the value (0 or 1) of bit n in bitmask bmp 
 Set bit n in bitmask bmp to value v (0 or 1) 
  When parsing bitmask lists, only allow numbers, separated by one
  of the allowed next characters.
  The parameter 'sret' is the return from a sscanf "%u%c".  It is
  -1 if the sscanf input string was empty.  It is 0 if the first
  character in the sscanf input string was not a decimal number.
  It is 1 if the unsigned number matching the "%u" was the end of the
  input string.  It is 2 if one or more additional characters followed
  the matched unsigned number.  If it is 2, then 'nextc' is the first
  character following the number.  The parameter 'ok_next_chars'
  is the nul-terminated list of allowed next characters.
  The mask term just scanned was ok if and only if either the numbers
  matching the %u were all of the input or if the next character in
  the input past the numbers was one of the allowed next characters.
 Set a single bit i in bitmask 
 Set all bits in bitmask: bmp = ~0 
 Clear all bits in bitmask: bmp = 0 
 True if all bits are clear 
 True if specified bit i is set 
 Number of lowest set bit (min) 
 Number of highest set bit (max) 
 Number of next set bit at or above given bit i 
  Parses a comma-separated list of numbers and ranges of numbers,
  with optional ':%u' strides modifying ranges, into provided bitmask.
  Some examples of input lists and their equivalent simple list:
 	Input		Equivalent to
 	0-3		0,1,2,3
 	0-7:2		0,2,4,6
 	1,3,5-7		1,3,5,6,7
 	0-3:2,8-15:4	0,2,8,12
 begin of range 
 end of range 
 stride 
 next tokens after '-' or ',' 
 char after sscanf %u match 
 sscanf return (number of matches) 
  emit(buf, buflen, rbot, rtop, len)
  Helper routine for bitmask_displaylist().  Write decimal number
  or range to buf+len, suppressing output past buf+buflen, with optional
  comma-prefix.  Return len of what would be written to buf, if it
  all fit.
  Write decimal list representation of bmp to buf.
  Output format is a comma-separated list of decimal numbers and
  ranges.  Consecutively set bits are shown as two hyphen-separated
  decimal numbers, the smallest and largest bit numbers set in
  the range.  Output format is compatible with the format
  accepted as input by bitmap_parselist().
  The return value is the number of characters which would be
  generated for the given input, excluding the trailing '\0', as
  per ISO C99.
 current bit is 'cur', most recently seen range is [rbot, rtop] 
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2010,2011       Thomas Renninger <trenn@suse.de>, Novell Inc.
  ToDo: Needs to be done more properly for AMDIntel specifics
 Helper struct for qsort, must be in sync with cpupower_topology.cpu_info 
 Be careful: Need to pass unsigned to the sort, so that offlined cores are
 CPU topologyhierarchy parsing 
 SPDX-License-Identifier: GPL-2.0
		 AMD Family 0x17 does not utilize PCI D18F4 like prior
		  families and has no fixed discrete boost states but
		  has Hardware determined variable increments instead.
 #if defined(__i386__) || defined(__x86_64__) 
 get_cpustate
  Gather the information of all online CPUs into bitmask struct
 print_online_cpus
  Print the CPU numbers of all CPUs that are online currently
 print_offline_cpus
  Print the CPU numbers of all CPUs that are offline currently
 SPDX-License-Identifier: GPL-2.0
  pci_acc_init
  PCI access helper function depending on libpci
  pacc : if a valid pci_dev is returned
          pacc must be passed to pci_acc_cleanup to free it
  domain: domain
  bus:    bus
  slot:   slot
  func:   func
  vendor: vendor
  device: device
  Pass -1 for one of the six above to match any
  Returns :
  struct pci_dev which can be used with pci_{read,write}_ functions
                 to access the PCI config space of matching pci devices
 Typically one wants to get a specific slot(device)func of the root domain
 defined(__i386__) || defined(__x86_64__) 
 SPDX-License-Identifier: GPL-2.0
 pre fam 17h: 
 since fam 17h: 
 Needs:
  cpu          -> the cpu that gets evaluated
  boost_states -> how much boost states the machines support
  Fills up:
  pstates -> a pointer to an array of size MAX_HW_PSTATES
             must be initialized with zeros.
             All available  HW pstates (including boost states)
  no      -> amount of pstates above array got filled up with
  returns zero on success, -1 on failure
	 Only read out frequencies from HW if HW Pstate is supported,
	  otherwise frequencies are exported via ACPI tables.
 The enabled bit (bit 63) is common for all families 
 defined(__i386__) || defined(__x86_64__) 
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2004-2009  Dominik Brodowski <linux@dominikbrodowski.de>
   (C) 2011       Thomas Renninger <trenn@novell.com> Novell Inc.
  Detect whether a CPU is online
  Returns:
      1 -> if CPU is online
      0 -> if CPU is offline
      negative errno values in error case
	
	  kernel without CONFIG_HOTPLUG_CPU
	  -> cpuX directory exists, but not cpuXonline file
 CPUidle idlestate specific sysdevicessystemcpucpuXcpuidle access 
 CPUidle idlestate specific sysdevicessystemcpucpuXcpuidle access 
  helper function to check whether a file under "..cpuXcpuidlestateX" dir
  exists.
  For example the functionality to disable c-states was introduced in later
  kernel versions, this function can be used to explicitly check for this
  feature.
  returns 1 if the file exists, 0 otherwise.
  helper function to read file from sys into given buffer
  fname is a relative path under "cpuXcpuidlestateX" dir
  cstates starting with 0, C0 is not counted as cstate.
  This means if you want C1 info, pass 0 as idlestate param
  helper function to write a new value to a sys file
  fname is a relative path under "..cpuXcpuidlecstateY" dir
  Returns the number of bytes written or 0 on error
 read access to files which contain one numeric value 
 read access to files which contain one string 
  Returns:
     1  if disabled
     0  if enabled
     -1 if idlestate is not available
     -2 if disabling is not supported by the kernel
  Pass 1 as last argument to disable or 0 to enable the state
  Returns:
     0  on success
     negative values on error, for example:
       -1 if idlestate is not available
       -2 if disabling is not supported by the kernel
       -3 No write access to disableenable C-states
  Returns number of supported C-states of CPU core cpu
  Negativ in error case
  Zero if cpuidle does not export any C-states
 CPUidle general sysdevicessystemcpucpuidle sysfs access 
  helper function to read file from sys into given buffer
  fname is a relative path under "cpucpuidle" dir
 read access to files which contain one string 
 CPUidle idlestate specific sysdevicessystemcpucpuXcpuidle access 
  Get sched_mc or sched_smt settings
  Pass "mc" or "smt" as argument
  Returns negative value on failure
  Get sched_mc or sched_smt settings
  Pass "mc" or "smt" as argument
  Returns negative value on failure
 SPDX-License-Identifier: GPL-2.0-only
  test module to check whether the TSC-based delay routine continues
  to work properly after cpufreq transitions. Needs ACPI to work
  properly.
  Based partly on the Power Management Timer (PMTMR) code to be found
  in archi386kerneltimerstimer_pm.c on recent 2.6. kernels, especially
  code written by John Stultz. The read_pmtmr function was copied verbatim
  from that file.
  (C) 2004 Dominik Brodowski
  To use:
  1.) pass clock=tsc to the kernel on your bootloader
  2.) modprobe this module (it'll fail)
  3.) change CPU frequency
  4.) modprobe this module again
  5.) if the third value, "diff_pmtmr", changes between 2. and 4., the
      TSC-based delay routine on the Linux kernel does not correctly
      handle the cpufreq transition. Please report this to
      linux-pm@vger.kernel.org
helper function to safely read acpi pm timesource
	 It has been reported that because of various broken
	  chipsets (ICH4, PIIX4 and PIIX4E) where the ACPI PM time
	  source is not latched, so you must read it multiple
	  times to insure a safe value is read.
 mask the output to 24 bits 
	 the following code snipped is copied from archx86kernelacpiboot.c
 detect the location of the ACPI PM Timer 
 FADT rev. 2 
		
		  "X" fields are optional extensions to the original V1.0
		  fields, so we must selectively expand V1.0 fields if the
		  corresponding X field is zero.
 FADT rev. 1 
  dump_psb. (c) 2004, Dave Jones, Red Hat Inc.
  Licensed under the GPL v2.
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2003 - 2004  Dominik Brodowski <linux@dominikbrodowski.de>
  Based on code found in
  linuxarchi386kernelcpucpufreqspeedstep-centrino.c
  and originally developed by Jeremy Fitzhardinge.
  USAGE: simply run it to decode the current settings on CPU 0,
 	  or pass the CPU number as argument, or pass the MSR content
 	  as argument.
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2004 Bruno Ducrot <ducrot@poupinou.org>
  Based on code found in
  linuxarchi386kernelcpucpufreqpowernow-k8.c
  and originally developed by Paul Devriendt
 Return a frequency in MHz, given an input fid 
 Return a voltage in miliVolts, given an input vid 
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2003  Bruno Ducrot
   (C) 2004  Dominik Brodowski <linux@dominikbrodowski.de>
  Based on code found in
  linuxincludeasm-i386ist.h and linuxarchi386kernelsetup.c
  and originally developed by Andy Grover <andrew.grover@intel.com>
 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
  Module Name: cmfsize - Common get file size function
  Copyright (C) 2000 - 2021, Intel Corp.
  FUNCTION:    cm_get_file_size
  PARAMETERS:  file                    - Open file descriptor
  RETURN:      File Size. On error, -1 (ACPI_UINT32_MAX)
  DESCRIPTION: Get the size of a file. Uses seek-to-EOF. File must be open.
               Does not disturb the current file pointer.
 Save the current file pointer, seek to EOF to obtain file size 
 Restore original file pointer 
 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
  Module Name: getopt
  Copyright (C) 2000 - 2021, Intel Corp.
  ACPICA getopt() implementation
  Option strings:
     "f"       - Option has no arguments
     "f:"      - Option requires an argument
     "f+"      - Option has an optional argument
     "f^"      - Option has optional single-char sub-options
     "f|"      - Option has required single-char sub-options
  FUNCTION:    acpi_getopt_argument
  PARAMETERS:  argc, argv          - from main
  RETURN:      0 if an argument was found, -1 otherwise. Sets acpi_gbl_Optarg
               to point to the next argument.
  DESCRIPTION: Get the next argument. Used to obtain arguments for the
               two-character options after the original call to acpi_getopt.
               Note: Either the argument starts at the next character after
               the option, or it is pointed to by the next argv entry.
               (After call to acpi_getopt, we need to backup to the previous
               argv entry).
  FUNCTION:    acpi_getopt
  PARAMETERS:  argc, argv          - from main
               opts                - options info list
  RETURN:      Option character or ACPI_OPT_END
  DESCRIPTION: Get the next option
 Get the option 
 Make sure that the option is legal 
 Option requires an argument? 
 Option has an optional argument? 
 Option has optional single-char arguments? 
 Option has a required single-char argument? 
 Option with no arguments 
 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
  Module Name: osunixdir - Unix directory access interfaces
  Copyright (C) 2000 - 2021, Intel Corp.
  Allocated structure returned from os_open_directory
  FUNCTION:    acpi_os_open_directory
  PARAMETERS:  dir_pathname        - Full pathname to the directory
               wildcard_spec       - string of the form ".c", etc.
  RETURN:      A directory "handle" to be used in subsequent search operations.
               NULL returned on failure.
  DESCRIPTION: Open a directory in preparation for a wildcard search
 Allocate the info struct that will be returned to the caller 
 Get the directory stream 
 Save the info in the return structure 
  FUNCTION:    acpi_os_get_next_filename
  PARAMETERS:  dir_handle          - Created via acpi_os_open_directory
  RETURN:      Next filename matched. NULL if no more matches.
  DESCRIPTION: Get the next file in the directory that matches the wildcard
               specification.
 copy to a temp buffer because dir_entry struct is on the stack 
  FUNCTION:    acpi_os_close_directory
  PARAMETERS:  dir_handle          - Created via acpi_os_open_directory
  RETURN:      None.
  DESCRIPTION: Close the open directory and cleanup.
 Close the directory and free allocations 
 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
  Module Name: osunixmap - Unix OSL for file mappings
  Copyright (C) 2000 - 2021, Intel Corp.
  FUNCTION:    acpi_os_get_page_size
  PARAMETERS:  None
  RETURN:      Page size of the platform.
  DESCRIPTION: Obtain page size of the platform.
  FUNCTION:    acpi_os_map_memory
  PARAMETERS:  where               - Physical address of memory to be mapped
               length              - How much memory to map
  RETURN:      Pointer to mapped memory. Null on error.
  DESCRIPTION: Map physical memory into local address space.
 Align the offset to use mmap 
 Map the table header to get the length of the full table 
  FUNCTION:    acpi_os_unmap_memory
  PARAMETERS:  where               - Logical address of memory to be unmapped
               length              - How much memory to unmap
  RETURN:      None.
  DESCRIPTION: Delete a previously created mapping. Where and Length must
               correspond to a previous mapping exactly.
 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
  Module Name: oslinuxtbl - Linux OSL for obtaining ACPI tables
  Copyright (C) 2000 - 2021, Intel Corp.
 List of information about obtained ACPI tables 
 Local prototypes 
 File locations 
 Should we get dynamically loaded SSDTs from DYNAMIC_TABLE_DIR? 
 Initialization flags 
 Local copies of main ACPI tables 
 Table addresses 
 Revision of RSD PTR 
  FUNCTION:    osl_get_last_status
  PARAMETERS:  default_status  - Default error status to return
  RETURN:      Status; Converted from errno.
  DESCRIPTION: Get last errno and convert it to acpi_status.
  FUNCTION:    acpi_os_get_table_by_address
  PARAMETERS:  address         - Physical address of the ACPI table
               table           - Where a pointer to the table is returned
  RETURN:      Status; Table buffer is returned if AE_OK.
               AE_NOT_FOUND: A valid table was not found at the address
  DESCRIPTION: Get an ACPI table via a physical memory address.
 Get main ACPI tables from memory on first invocation of this function 
 Map the table and validate it 
 Copy table to local buffer and return it 
  FUNCTION:    acpi_os_get_table_by_name
  PARAMETERS:  signature       - ACPI Signature for desired table. Must be
                                 a null terminated 4-character string.
               instance        - Multiple table support for SSDTUEFI (0...n)
                                 Must be 0 for other tables.
               table           - Where a pointer to the table is returned
               address         - Where the table physical address is returned
  RETURN:      Status; Table buffer and physical address returned if AE_OK.
               AE_LIMIT: Instance is beyond valid limit
               AE_NOT_FOUND: A table with the signature was not found
  NOTE:        Assumes the input signature is uppercase.
 Get main ACPI tables from memory on first invocation of this function 
 Not a main ACPI table, attempt to extract it from the RSDTXSDT 
 Attempt to get the table from the memory 
 Attempt to get the table from the static directory 
 Attempt to get a dynamic table 
  FUNCTION:    osl_add_table_to_list
  PARAMETERS:  signature       - Table signature
               instance        - Table instance
  RETURN:      Status; Successfully added if AE_OK.
               AE_NO_MEMORY: Memory allocation error
  DESCRIPTION: Insert a table structure into OSL table list.
  FUNCTION:    acpi_os_get_table_by_index
  PARAMETERS:  index           - Which table to get
               table           - Where a pointer to the table is returned
               instance        - Where a pointer to the table instance no. is
                                 returned
               address         - Where the table physical address is returned
  RETURN:      Status; Table buffer and physical address returned if AE_OK.
               AE_LIMIT: Index is beyond valid limit
  DESCRIPTION: Get an ACPI table via an index value (0 through n). Returns
               AE_LIMIT when an invalid index is reached. Index is not
               necessarily an index into the RSDTXSDT.
 Get main ACPI tables from memory on first invocation of this function 
 Validate Index 
 Point to the table list entry specified by the Index argument 
 Now we can just get the table via the signature 
  FUNCTION:    osl_find_rsdp_via_efi_by_keyword
  PARAMETERS:  keyword         - Character string indicating ACPI GUID version
                                 in the EFI table
  RETURN:      RSDP address if found
  DESCRIPTION: Find RSDP address via EFI using keyword indicating the ACPI
               GUID version.
  FUNCTION:    osl_find_rsdp_via_efi
  PARAMETERS:  None
  RETURN:      RSDP address if found
  DESCRIPTION: Find RSDP address via EFI.
  FUNCTION:    osl_load_rsdp
  PARAMETERS:  None
  RETURN:      Status
  DESCRIPTION: Scan and load RSDP.
 Get RSDP from memory 
 Search low memory for the RSDP 
  FUNCTION:    osl_can_use_xsdt
  PARAMETERS:  None
  RETURN:      TRUE if XSDT is allowed to be used.
  DESCRIPTION: This function collects logic that can be used to determine if
               XSDT should be used instead of RSDT.
  FUNCTION:    osl_table_initialize
  PARAMETERS:  None
  RETURN:      Status
  DESCRIPTION: Initialize ACPI table data. Get and store main ACPI tables to
               local variables. Main ACPI tables include RSDT, FADT, RSDT,
               andor XSDT.
 Get RSDP from memory 
 Get XSDT from memory 
 Get RSDT from memory 
 Get FADT from memory 
 Add mandatory tables to global table list first 
 Add all tables found in the memory 
 Add all tables found in the static directory 
 Add all dynamically loaded tables in the dynamic directory 
  FUNCTION:    osl_list_bios_tables
  PARAMETERS:  None
  RETURN:      Status; Table list is initialized if AE_OK.
  DESCRIPTION: Add ACPI tables to the table list from memory.
  NOTE:        This works on Linux as table customization does not modify the
               addresses stored in RSDPRSDTXSDTFADT.
 Use RSDT if XSDT is not available 
 Search RSDTXSDT for the requested table 
 Skip NULL entries in RSDTXSDT 
  FUNCTION:    osl_get_bios_table
  PARAMETERS:  signature       - ACPI Signature for common table. Must be
                                 a null terminated 4-character string.
               instance        - Multiple table support for SSDTUEFI (0...n)
                                 Must be 0 for other tables.
               table           - Where a pointer to the table is returned
               address         - Where the table physical address is returned
  RETURN:      Status; Table buffer and physical address returned if AE_OK.
               AE_LIMIT: Instance is beyond valid limit
               AE_NOT_FOUND: A table with the signature was not found
  DESCRIPTION: Get a BIOS provided ACPI table
  NOTE:        Assumes the input signature is uppercase.
 Handle special tables whose addresses are not in RSDTXSDT 
		
		  Get the appropriate address, either 32-bit or 64-bit. Be very
		  careful about the FADT length and validate table addresses.
		  Note: The 64-bit addresses have priority.
 Now we can get the requested special table 
 Match table instance 
 Case for a normal ACPI table 
 Use RSDT if XSDT is not available 
 Search RSDTXSDT for the requested table 
 Skip NULL entries in RSDTXSDT 
 Does this table match the requested signature? 
 Match table instance (for SSDTUEFI tables) 
 Copy table to local buffer and return it 
  FUNCTION:    osl_list_customized_tables
  PARAMETERS:  directory           - Directory that contains the tables
  RETURN:      Status; Table list is initialized if AE_OK.
  DESCRIPTION: Add ACPI tables to the table list from a directory.
 Open the requested directory 
 Examine all entries in this directory 
 Extract table name and instance number 
 Ignore meaningless files 
 Add new info node to global table list 
  FUNCTION:    osl_map_table
  PARAMETERS:  address             - Address of the table in memory
               signature           - Optional ACPI Signature for desired table.
                                     Null terminated 4-character string.
               table               - Where a pointer to the mapped table is
                                     returned
  RETURN:      Status; Mapped table is returned if AE_OK.
               AE_NOT_FOUND: A valid table was not found at the address
  DESCRIPTION: Map entire ACPI table into caller's address space.
	
	  Map the header so we can get the table length.
	  Use sizeof (struct acpi_table_header) as:
	  1. it is bigger than 24 to include RSDP->Length
	  2. it is smaller than sizeof (struct acpi_table_rsdp)
 If specified, signature must match 
 Map the entire table 
  FUNCTION:    osl_unmap_table
  PARAMETERS:  table               - A pointer to the mapped table
  RETURN:      None
  DESCRIPTION: Unmap entire ACPI table.
  FUNCTION:    osl_table_name_from_file
  PARAMETERS:  filename            - File that contains the desired table
               signature           - Pointer to 4-character buffer to store
                                     extracted table signature.
               instance            - Pointer to integer to store extracted
                                     table instance number.
  RETURN:      Status; Table name is extracted if AE_OK.
  DESCRIPTION: Extract table signature and instance number from a table file
               name.
 Ignore meaningless files 
 Extract instance number 
 Extract signature 
  FUNCTION:    osl_read_table_from_file
  PARAMETERS:  filename            - File that contains the desired table
               file_offset         - Offset of the table in file
               table               - Where a pointer to the table is returned
  RETURN:      Status; Table buffer is returned if AE_OK.
  DESCRIPTION: Read a ACPI table from a file.
 Open the file 
 Read the Table header to get the table length 
 If signature is specified, it must match the table 
 Read the entire table into a local buffer 
 Validate checksum 
  FUNCTION:    osl_get_customized_table
  PARAMETERS:  pathname        - Directory to find Linux customized table
               signature       - ACPI Signature for desired table. Must be
                                 a null terminated 4-character string.
               instance        - Multiple table support for SSDTUEFI (0...n)
                                 Must be 0 for other tables.
               table           - Where a pointer to the table is returned
               address         - Where the table physical address is returned
  RETURN:      Status; Table buffer is returned if AE_OK.
               AE_LIMIT: Instance is beyond valid limit
               AE_NOT_FOUND: A table with the signature was not found
  DESCRIPTION: Get an OS customized table.
 Open the directory for customized tables 
 Attempt to find the table in the directory 
 Ignore meaningless files 
 Extract table name and instance number 
 Ignore meaningless files 
 Create the table pathname 
 There is no physical address saved for customized tables, use zero 
 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
  Module Name: osunixxf - UNIX OSL interfaces
  Copyright (C) 2000 - 2021, Intel Corp.
  These interfaces are required in order to compile the ASL compiler and the
  various ACPICA tools under Linux or other Unix-like system.
 Upcalls to acpi_exec 
 Buffer used by acpi_os_vprintf 
 Terminal support for acpi_exec only 
  FUNCTION:    os_enter_line_edit_mode, os_exit_line_edit_mode
  PARAMETERS:  None
  RETURN:      None
  DESCRIPTION: EnterExit the raw character input mode for the terminal.
  Interactive line-editing support for the AML debugger. Used with the
  commonacgetline module.
  readline() is not used because of non-portability. It is not available
  on all systems, and if it is, often the package must be manually installed.
  Therefore, we use the POSIX tcgetattrtcsetattr and do the minimal line
  editing that we need in acpi_os_get_line.
  If the POSIX tcgetattrtcsetattr interfaces are unavailable, these
  calls will also work:
      For os_enter_line_edit_mode: system ("stty cbreak -echo")
      For os_exit_line_edit_mode: system ("stty cooked echo")
 STDIN must be a terminal 
 Get and keep the original attributes 
 Set the new attributes to enable raw character input 
 Set terminal attributes back to the original values 
 These functions are not needed for other ACPICA utilities 
  FUNCTION:    acpi_os_initialize, acpi_os_terminate
  PARAMETERS:  None
  RETURN:      Status
  DESCRIPTION: Initialize and terminate this module.
  FUNCTION:    acpi_os_get_root_pointer
  PARAMETERS:  None
  RETURN:      RSDP physical address
  DESCRIPTION: Gets the ACPI root pointer (RSDP)
  FUNCTION:    acpi_os_predefined_override
  PARAMETERS:  init_val            - Initial value of the predefined object
               new_val             - The new value for the object
  RETURN:      Status, pointer to value. Null pointer returned if not
               overriding.
  DESCRIPTION: Allow the OS to override predefined names
  FUNCTION:    acpi_os_table_override
  PARAMETERS:  existing_table      - Header of current table (probably
                                     firmware)
               new_table           - Where an entire new table is returned.
  RETURN:      Status, pointer to new table. Null pointer returned if no
               table is available to override
  DESCRIPTION: Return a different version of a table if one is available
  FUNCTION:    acpi_os_physical_table_override
  PARAMETERS:  existing_table      - Header of current table (probably firmware)
               new_address         - Where new table address is returned
                                     (Physical address)
               new_table_length    - Where new table length is returned
  RETURN:      Status, addresslength of new table. Null pointer returned
               if no table is available to override.
  DESCRIPTION: Returns AE_SUPPORT, function not used in user space.
  FUNCTION:    acpi_os_enter_sleep
  PARAMETERS:  sleep_state         - Which sleep state to enter
               rega_value          - Register A value
               regb_value          - Register B value
  RETURN:      Status
  DESCRIPTION: A hook before writing sleep registers to enter the sleep
               state. Return AE_CTRL_TERMINATE to skip further sleep register
               writes.
  FUNCTION:    acpi_os_redirect_output
  PARAMETERS:  destination         - An open file handlepointer
  RETURN:      None
  DESCRIPTION: Causes redirect of acpi_os_printf and acpi_os_vprintf
  FUNCTION:    acpi_os_printf
  PARAMETERS:  fmt, ...            - Standard printf format
  RETURN:      None
  DESCRIPTION: Formatted output. Note: very similar to acpi_os_vprintf
               (performance), changes should be tracked in both functions.
 Output is directable to either a file (if open) or the console 
 Output file is open, send the output there 
 No redirection, send output to console (once only!) 
  FUNCTION:    acpi_os_vprintf
  PARAMETERS:  fmt                 - Standard printf format
               args                - Argument list
  RETURN:      None
  DESCRIPTION: Formatted output with argument list pointer. Note: very
               similar to acpi_os_printf, changes should be tracked in both
               functions.
	
	  We build the output string in a local buffer because we may be
	  outputting the buffer twice. Using vfprintf is problematic because
	  some implementations modify the args pointerstructure during
	  execution. Thus, we use the local buffer for portability.
	 
	  Note: Since this module is intended for use by the various ACPICA
	  utilitiesapplications, we can safely declare the buffer on the stack.
	  Also, This function is used for relatively small error messages only.
 Output is directable to either a file (if open) or the console 
 Output file is open, send the output there 
 No redirection, send output to console (once only!) 
  FUNCTION:    acpi_os_get_line
  PARAMETERS:  buffer              - Where to return the command line
               buffer_length       - Maximum length of Buffer
               bytes_read          - Where the actual byte count is returned
  RETURN:      Status and actual bytes read
  DESCRIPTION: Get the next input line from the terminal. NOTE: For the
               acpi_exec utility, we use the acgetline module instead to
               provide line-editing and history support.
 Standard acpi_os_get_line for all utilities except acpi_exec 
 Null terminate the buffer 
 Return the number of bytes in the string 
  FUNCTION:    acpi_os_map_memory
  PARAMETERS:  where               - Physical address of memory to be mapped
               length              - How much memory to map
  RETURN:      Pointer to mapped memory. Null on error.
  DESCRIPTION: Map physical memory into caller's address space
  FUNCTION:    acpi_os_unmap_memory
  PARAMETERS:  where               - Logical address of memory to be unmapped
               length              - How much memory to unmap
  RETURN:      None.
  DESCRIPTION: Delete a previously created mapping. Where and Length must
               correspond to a previous mapping exactly.
  FUNCTION:    acpi_os_allocate
  PARAMETERS:  size                - Amount to allocate, in bytes
  RETURN:      Pointer to the new allocation. Null on error.
  DESCRIPTION: Allocate memory. Algorithm is dependent on the OS.
  FUNCTION:    acpi_os_allocate_zeroed
  PARAMETERS:  size                - Amount to allocate, in bytes
  RETURN:      Pointer to the new allocation. Null on error.
  DESCRIPTION: Allocate and zero memory. Algorithm is dependent on the OS.
  FUNCTION:    acpi_os_free
  PARAMETERS:  mem                 - Pointer to previously allocated memory
  RETURN:      None.
  DESCRIPTION: Free memory allocated via acpi_os_allocate
  FUNCTION:    Semaphore stub functions
  DESCRIPTION: Stub functions used for single-thread applications that do
               not require semaphore synchronization. Full implementations
               of these functions appear after the stubs.
  FUNCTION:    acpi_os_create_semaphore
  PARAMETERS:  initial_units       - Units to be assigned to the new semaphore
               out_handle          - Where a handle will be returned
  RETURN:      Status
  DESCRIPTION: Create an OS semaphore
 This just deletes the name 
  FUNCTION:    acpi_os_delete_semaphore
  PARAMETERS:  handle              - Handle returned by acpi_os_create_semaphore
  RETURN:      Status
  DESCRIPTION: Delete an OS semaphore
  FUNCTION:    acpi_os_wait_semaphore
  PARAMETERS:  handle              - Handle returned by acpi_os_create_semaphore
               units               - How many units to wait for
               msec_timeout        - How long to wait (milliseconds)
  RETURN:      Status
  DESCRIPTION: Wait for units
		
		  No Wait:
		  --------
		  A zero timeout value indicates that we shouldn't wait - just
		  acquire the semaphore if available otherwise return AE_TIME
		  (a.k.a. 'would block').
 Wait Indefinitely 
 Restart if interrupted 
 Wait with msec_timeout 
		
		  Alternate timeout mechanism for environments where
		  sem_timedwait is not available or does not work properly.
 Got the semaphore 
 ten milliseconds 
 one millisecond 
		
		  The interface to sem_timedwait is an absolute time, so we need to
		  get the current time, then add in the millisecond Timeout value.
 Handle nanosecond overflow (field must be less than one second) 
 Restart if interrupted 
  FUNCTION:    acpi_os_signal_semaphore
  PARAMETERS:  handle              - Handle returned by acpi_os_create_semaphore
               units               - Number of units to send
  RETURN:      Status
  DESCRIPTION: Send units
 ACPI_SINGLE_THREADED 
  FUNCTION:    Spinlock interfaces
  DESCRIPTION: Map these interfaces to semaphore interfaces
  FUNCTION:    acpi_os_install_interrupt_handler
  PARAMETERS:  interrupt_number    - Level handler should respond to.
               isr                 - Address of the ACPI interrupt handler
               except_ptr          - Where status is returned
  RETURN:      Handle to the newly installed handler.
  DESCRIPTION: Install an interrupt handler. Used to install the ACPI
               OS-independent handler.
  FUNCTION:    acpi_os_remove_interrupt_handler
  PARAMETERS:  handle              - Returned when handler was installed
  RETURN:      Status
  DESCRIPTION: Uninstalls an interrupt handler.
  FUNCTION:    acpi_os_stall
  PARAMETERS:  microseconds        - Time to sleep
  RETURN:      Blocks until sleep is completed.
  DESCRIPTION: Sleep at microsecond granularity
  FUNCTION:    acpi_os_sleep
  PARAMETERS:  milliseconds        - Time to sleep
  RETURN:      Blocks until sleep is completed.
  DESCRIPTION: Sleep at millisecond granularity
 Sleep for whole seconds 
	
	  Sleep for remaining microseconds.
	  Arg to usleep() is in usecs and must be less than 1,000,000 (1 second).
  FUNCTION:    acpi_os_get_timer
  PARAMETERS:  None
  RETURN:      Current time in 100 nanosecond units
  DESCRIPTION: Get the current system time
 This timer has sufficient resolution for user-space application code 
 (Seconds  10^7 = 100ns(10^-7)) + (Microseconds(10^-6)  10^1 = 100ns) 
  FUNCTION:    acpi_os_read_pci_configuration
  PARAMETERS:  pci_id              - SegBusDev
               pci_register        - Device Register
               value               - Buffer where value is placed
               width               - Number of bits
  RETURN:      Status
  DESCRIPTION: Read data from PCI configuration space
  FUNCTION:    acpi_os_write_pci_configuration
  PARAMETERS:  pci_id              - SegBusDev
               pci_register        - Device Register
               value               - Value to be written
               width               - Number of bits
  RETURN:      Status.
  DESCRIPTION: Write data to PCI configuration space
  FUNCTION:    acpi_os_read_port
  PARAMETERS:  address             - Address of IO portregister to read
               value               - Where value is placed
               width               - Number of bits
  RETURN:      Value read from port
  DESCRIPTION: Read data from an IO port or register
  FUNCTION:    acpi_os_write_port
  PARAMETERS:  address             - Address of IO portregister to write
               value               - Value to write
               width               - Number of bits
  RETURN:      None
  DESCRIPTION: Write data to an IO port or register
  FUNCTION:    acpi_os_read_memory
  PARAMETERS:  address             - Physical Memory Address to read
               value               - Where value is placed
               width               - Number of bits (8,16,32, or 64)
  RETURN:      Value read from physical memory address. Always returned
               as a 64-bit integer, regardless of the read width.
  DESCRIPTION: Read data from a physical memory address
  FUNCTION:    acpi_os_write_memory
  PARAMETERS:  address             - Physical Memory Address to write
               value               - Value to write
               width               - Number of bits (8,16,32, or 64)
  RETURN:      None
  DESCRIPTION: Write data to a physical memory address
  FUNCTION:    acpi_os_readable
  PARAMETERS:  pointer             - Area to be verified
               length              - Size of area
  RETURN:      TRUE if readable for entire length
  DESCRIPTION: Verify that a pointer is valid for reading
  FUNCTION:    acpi_os_writable
  PARAMETERS:  pointer             - Area to be verified
               length              - Size of area
  RETURN:      TRUE if writable for entire length
  DESCRIPTION: Verify that a pointer is valid for writing
  FUNCTION:    acpi_os_signal
  PARAMETERS:  function            - ACPI A signal function code
               info                - Pointer to function-dependent structure
  RETURN:      Status
  DESCRIPTION: Miscellaneous functions. Example implementation only.
 Optional multi-thread support 
  FUNCTION:    acpi_os_get_thread_id
  PARAMETERS:  None
  RETURN:      Id of the running thread
  DESCRIPTION: Get the ID of the current (running) thread
  FUNCTION:    acpi_os_execute
  PARAMETERS:  type                - Type of execution
               function            - Address of the function to execute
               context             - Passed as a parameter to the function
  RETURN:      Status.
  DESCRIPTION: Execute a new thread
 ACPI_SINGLE_THREADED 
 ACPI_SINGLE_THREADED 
  FUNCTION:    acpi_os_wait_events_complete
  PARAMETERS:  None
  RETURN:      None
  DESCRIPTION: Wait for all asynchronous events to complete. This
               implementation does nothing.
 SPDX-License-Identifier: GPL-2.0-only
  ec_access.c
  Copyright (C) 2010 SUSE Linux Products GmbH
  Author:
       Thomas Renninger <trenn@suse.de>
 TBDEnhancements:
   - Provide param for accessing different ECs (not supported by kernel yet)
 Add additional parameter checks here 
 SPDX-License-Identifier: GPL-2.0-only
  ACPI AML interfacing userspace utility
  Copyright (C) 2015, Intel Corporation
  Authors: Lv Zheng <lv.zheng@intel.com>
 Headers not included by includeacpiplatformaclinux.h 
 Write command to kernel 
 Read log from kernel 
 Write log to console 
 Roll back 
  This is a userspace IO flush implementation, replying on the prompt
  characters and can be turned into a flush() call after kernel implements
  .flush() filesystem operation.
 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
  Module Name: apfiles - File-related functions for acpidump utility
  Copyright (C) 2000 - 2021, Intel Corp.
 Local prototypes 
  FUNCTION:    ap_is_existing_file
  PARAMETERS:  pathname            - Output filename
  RETURN:      0 on success
  DESCRIPTION: Query for file overwrite if it already exists.
  FUNCTION:    ap_open_output_file
  PARAMETERS:  pathname            - Output filename
  RETURN:      Open file handle
  DESCRIPTION: Open a text output file for acpidump. Checks if file already
               exists.
 If file exists, prompt for overwrite 
 Point stdout to the file 
 Save the file and path 
  FUNCTION:    ap_write_to_binary_file
  PARAMETERS:  table               - ACPI table to be written
               instance            - ACPI table instance no. to be written
  RETURN:      Status
  DESCRIPTION: Write an ACPI table to a binary file. Builds the output
               filename from the table signature.
 Obtain table length 
 Construct lower-case filename from the table local signature 
 Handle multiple SSDts - create different filenames for each 
 Open the file and dump the entire table in binary mode 
  FUNCTION:    ap_get_table_from_file
  PARAMETERS:  pathname            - File containing the binary ACPI table
               out_file_size       - Where the file size is returned
  RETURN:      Buffer containing the ACPI table. NULL on error.
  DESCRIPTION: Open a file and read it entirely into a new buffer
 Must use binary mode 
 Need file size to allocate a buffer 
 Allocate a buffer for the entire file 
 Read the entire file 
 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
  Module Name: apdump - Dump routines for ACPI tables (acpidump)
  Copyright (C) 2000 - 2021, Intel Corp.
 Local prototypes 
  FUNCTION:    ap_is_valid_header
  PARAMETERS:  table               - Pointer to table to be validated
  RETURN:      TRUE if the header appears to be valid. FALSE otherwise
  DESCRIPTION: Check for a valid ACPI table header
 Make sure signature is all ASCII and a valid ACPI name 
 Check for minimum table length 
  FUNCTION:    ap_is_valid_checksum
  PARAMETERS:  table               - Pointer to table to be validated
  RETURN:      TRUE if the checksum appears to be valid. FALSE otherwise.
  DESCRIPTION: Check for a valid ACPI table checksum.
		
		  Checksum for RSDP.
		  Note: Other checksums are computed during the table dump.
  FUNCTION:    ap_get_table_length
  PARAMETERS:  table               - Pointer to the table
  RETURN:      Table length
  DESCRIPTION: Obtain table length according to table signature.
 Check if table is valid 
 Normal ACPI table 
  FUNCTION:    ap_dump_table_buffer
  PARAMETERS:  table               - ACPI table to be dumped
               instance            - ACPI table instance no. to be dumped
               address             - Physical address of the table
  RETURN:      None
  DESCRIPTION: Dump an ACPI table in standard ASCII hex format, with a
               header that is compatible with the acpi_xtract utility.
 Print only the header if requested 
 Dump to binary file if requested 
	
	  Dump the table with header for use with acpixtract utility.
	  Note: simplest to just always emit a 64-bit address. acpi_xtract
	  utility can handle this.
  FUNCTION:    ap_dump_all_tables
  PARAMETERS:  None
  RETURN:      Status
  DESCRIPTION: Get all tables from the RSDTXSDT (or at least all of the
               tables that we can possibly get).
 Get and dump all available ACPI tables 
 AE_LIMIT means that no more tables are available 
 Something seriously bad happened if the loop terminates here 
  FUNCTION:    ap_dump_table_by_address
  PARAMETERS:  ascii_address       - Address for requested ACPI table
  RETURN:      Status
  DESCRIPTION: Get an ACPI table via a physical address and dump it.
 Convert argument to an integer physical address 
  FUNCTION:    ap_dump_table_by_name
  PARAMETERS:  signature           - Requested ACPI table signature
  RETURN:      Status
  DESCRIPTION: Get an ACPI table via a signature and dump it. Handles
               multiple tables with the same signature (SSDTs).
 Table signatures are expected to be uppercase 
 To be friendly, handle tables whose signatures do not match the name 
 Dump all instances of this signature (to handle multiple SSDTs) 
 AE_LIMIT means that no more tables are available 
 Something seriously bad happened if the loop terminates here 
  FUNCTION:    ap_dump_table_from_file
  PARAMETERS:  pathname            - File containing the binary ACPI table
  RETURN:      Status
  DESCRIPTION: Dump an ACPI table from a binary file
 Get the entire ACPI table from the file 
 File must be at least as long as the table length 
 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
  Module Name: apmain - Main module for the acpidump utility
  Copyright (C) 2000 - 2021, Intel Corp.
  acpidump - A portable utility for obtaining system ACPI tables and dumping
  them in an ASCII hex format suitable for binary extraction via acpixtract.
  Obtaining the system ACPI tables is an OS-specific operation.
  This utility can be ported to any host operating system by providing a
  module containing system-specific versions of these interfaces:
       acpi_os_get_table_by_address
       acpi_os_get_table_by_index
       acpi_os_get_table_by_name
  See the ACPICA Reference Guide for the exact definitions of these
  interfaces. Also, see these ACPICA source code modules for example
  implementations:
       sourceos_specificservice_layersoswintbl.c
       sourceos_specificservice_layersoslinuxtbl.c
 Local prototypes 
 Table for deferred actions from command line options 
  FUNCTION:    ap_display_usage
  DESCRIPTION: Usage message for the acpi_dump utility
  FUNCTION:    ap_insert_action
  PARAMETERS:  argument            - Pointer to the argument for this action
               to_be_done          - What to do to process this action
  RETURN:      Status
  DESCRIPTION: Add an action item to the action table
 Insert action and check for table overflow 
  FUNCTION:    ap_do_options
  PARAMETERS:  argcargv           - Standard argcargv
  RETURN:      Status
  DESCRIPTION: Command line option processing. The main actions for getting
               and dumping tables are deferred via the action table.
 Command line options 
			
			  Global options
 Dump all input tables to binary files 
 Dump customized tables 
 Redirect output to a single file 
 Dump tables from specified RSDP 
 Print table summaries only 
 Do not use XSDT 
 -v: (Version): signon already emitted, just exit 
 -v: (Version) 
 Verbose mode 
			
			  Table options
 Get table by physical address 
 Get table from a file 
 Get table by input name (signature) 
 If there are no actions, this means "getdump all tables" 
  FUNCTION:    main
  PARAMETERS:  argcargv           - Standard argcargv
  RETURN:      Status
  DESCRIPTION: C main function for acpidump utility
 For debug version only 
 Process command line options 
 Getdump ACPI table(s) as requested 
 Summary for the output file 
 SPDX-License-Identifier: GPL-2.0-only
  x86_energy_perf_policy -- set the energy versus performance
  policy preference bias on recent X86 processors.
  Copyright (c) 2010 - 2017 Intel Corporation.
  Len Brown <len.brown@intel.com>
 MSR_IA32_ENERGY_PERF_BIAS 
 IA32_PM_ENABLE, IA32_HWP_CAPABILITIES 
 IA32_HWP_REQUEST, IA32_HWP_STATUS 
 IA32_HWP_INTERRUPT 
 IA32_HWP_REQUEST[bits 41:32] 
 IA32_HWP_REQUEST[bits 31:24] 
 IA32_HWP_REQUEST_PKG 
  maintain compatibility with original implementation, but don't document it:
  If bdx_highest_ratio is set,
  then we must translate between MSR format and simple ratio
  used on the cmdline.
 round 
  "performance" changes hwp_min to cap.highest
  All others leave it at cap.lowest
  "power" changes hwp_max to cap.lowest
  All others leave it at cap.highest
  for --hwp-des, all strings leave it in autonomous mode
  If you want to change it, you need to explicitly pick a value
 autonomous 
 "--cpu even" is not documented 
 "--cpu odd" is not documented 
 v1 used -r to specify read-only mode, now the default 
	
	  v1 allowed "performance"|"normal"|"power" with no policy specifier
	  to update BIAS.  Continue to support that, even though no longer documented.
  Open a file, and exit on failure
 On VMs proccpuinfo contains a "flags" entry for hypervisor 
msr, or run as root", pathname);
msr, or run as root", pathname);
  Assumption: All HWP systems have 100 MHz bus clock
 100,000 KHz = 100 MHz 
  If HWP is enabled and cpufreq sysfs attribtes are present,
  then update sysfs, so that it will not become
  stale when we write to MSRs.
  (intel_pstate's max_perf_pct and min_perf_pct will follow cpufreq,
   so we don't have to touch that.)
  We update all sysfs before updating any MSRs because of
  bugs in cpufreqintel_pstate where the sysfs writes
  for a CPU may change the minmax values on other CPUS.
 fail if min > max requested 
 fail if desired > max requestd 
 fail if desired < min requestd 
			
			  if "turbo_is_enabled" were known to be describe this cpu
			  then we could use it here to skip redundant disable requests.
			  but cpu may be in a different package, so we always write.
  run func(cpu) on every cpu in procstat
  return max_cpu number
 clear has_hwp if it is not enable (or being enabled) 
 set in early_cpuid() 
 MSR_PM_ENABLE[1] == 1 if HWP is enabled and MSRs visible 
 fail if min > max requested 
 fail if desired > max requestd 
 fail if desired < min requestd 
  early_cpuid()
  initialize turbo_is_enabled, has_hwp, has_epb
  before cmdline is parsed
  parse_cpuid()
  set
  has_hwp, has_hwp_notify, has_hwp_activity_window, has_hwp_epp, has_hwp_request_pkg, has_epb
 turbo_is_enabled already set 
 has_hwp already set 
 has_epb already set 
 success 
 initial cpuid parse before cmdline 
 If CPU-set and PKG-set are not initialized, default to all CPUs 
	
	  If HWP is being enabled, do it now, so that subsequent operations
	  that access HWP registers can work.
 If HWP present, but disabled, warn and ignore from here forward 
 display information only, no updates to settings 
 update CPU set 
 SPDX-License-Identifier: GPL-2.0
  Intel dynamic_speed_select -- Enumerate and control features
  Copyright (c) 2019 Intel Corporation.
 SPDX-License-Identifier: GPL-2.0
  Intel Speed Select -- Enumerate and control features
  Copyright (c) 2019 Intel Corporation.
 invalid value 
 Return 1 if locked 
 SPDX-License-Identifier: GPL-2.0
  Intel Speed Select -- Enumerate and control features
  Copyright (c) 2019 Intel Corporation.
 clos related 
 only three CascadeLake-N models are supported 
 Open a file, and exit on failure 
 Parse a file containing a single int 
 Mapping already exists 
 online entry for CPU 0 needs some special configs 
 Create an unique id for package, die combination to store 
 online entry for CPU 0 needs some special configs 
 shift to get core id
 this is true for CascadeLake-N 
 find the frequency base ratio 
 find the high and low priority frequencies 
 convert frequencies back to ratios 
 create high priority cpu mask 
 extra ctdp & pbf struct parameters 
 PBF is always supported and enabled 
 FACT is never supported 
 Wait for updated base frequencies 
 Set TRL 
 Since we modified TRL during Fact enable, restore it 
		
		  When we adjust CLOS param, we have to set for siblings also.
		  So for the each user specified CPU, also add the sibling
		  in the present_cpu_mask.
 online entry for CPU 0 needs some special configs 
  parse cpuset with following syntax
  1,2,4..6,8-10 and set bits in cpu_subset
 no negative cpu numbers 
 start range 
 start range 
 CLOS related 
 SPDX-License-Identifier: GPL-2.0-only
  turbostat -- show CPU frequency and C-state residency
  on modern Intel and AMD processors.
  Copyright (c) 2021 Intel Corporation.
  Len Brown <len.brown@intel.com>
 Save original CPU model 
 MHz etc 
 IA32_PM_ENABLE, IA32_HWP_CAPABILITIES 
 IA32_HWP_REQUEST, IA32_HWP_STATUS 
 IA32_HWP_INTERRUPT 
 IA32_HWP_REQUEST[bits 41:32] 
 IA32_HWP_REQUEST[bits 31:24] 
 IA32_HWP_REQUEST_PKG 
 0x610 MSR_PKG_POWER_LIMIT 
 0x611 MSR_PKG_ENERGY_STATUS 
 0x613 MSR_PKG_PERF_STATUS 
 0x614 MSR_PKG_POWER_INFO 
 0x618 MSR_DRAM_POWER_LIMIT 
 0x619 MSR_DRAM_ENERGY_STATUS 
 0x61b MSR_DRAM_PERF_STATUS 
 0x61c MSR_DRAM_POWER_INFO 
 0x638 MSR_PP0_POWER_LIMIT 
 0x63a MSR_PP0_POLICY 
 0x640 MSR_PP1_POWER_LIMIT 
 0x641 MSR_PP1_ENERGY_STATUS 
 0x642 MSR_PP1_POLICY 
 0x639 MSR_PP0_ENERGY_STATUS 
					 Indicates cores energy collection is per-core,
 0xc0010299 MSR_RAPL_PWR_UNIT 
 0xc001029a MSR_CORE_ENERGY_STAT 
 0xc001029b MSR_PKG_ENERGY_STAT 
 MSRs that are not yet in the kernel-provided header. 
  buffer size used by sscanf() for added column names
  Usually truncated to 7 characters, but also handles 18 columns for raw 64-bit counters
 need to use before probe... 
 duplicate as per-core for now, even though per module 
 MSR_CORE_ENERGY_STAT 
 MSR_PKG_ENERGY_STATUS 
 MSR_DRAM_ENERGY_STATUS 
 MSR_PP0_ENERGY_STATUS 
 MSR_PP1_ENERGY_STATUS 
 MSR_PKG_PERF_STATUS 
 MSR_DRAM_PERF_STATUS 
  The accumulated sum of MSR is defined as a monotonic
  increasing MSR, it will be accumulated periodically,
  despite its register's bit width.
 get_msr_sum() = sum + (get_msr() - last) 
The accumulated MSR value is updated by the timer 
The MSR footprint recorded in last timer 
 The percpu MSR sum array.
 0-based count within the package 
 Processing UnitThread IDs 
 procinterrupts column numbers 
 indexed by cpu_num 
  run func(thread, core, package) in topology order
  skip non-present cpus
msr, or run as root", pathname);
 counter for cpu_num, including user + kernel and all processes 
  This list matches the column headers, except
  1. built-in only, the sysfs counters are not here -- we learn of those at run-time
  2. Core and CPU are moved to the end, we can't have strings that contain them
     matching on them for --show and --hide.
  HIDE_LIST - hide this list of counters, show the rest [default]
  SHOW_LIST - show this list of counters, hide the rest
  bic_lookup
  for all the strings in comma separate name_list,
  set the approprate bit in return value.
  column formatting convention & formats
 if showing only 1st thread in core and this isn't one, bail out 
 if showing only 1st thread in pkg and this isn't one, bail out 
if not summary line and --cpu is used 
 on each row, print how many usec each timestamp took to gather 
 Time_Of_Day_Seconds: on each row, print sec.usec last timestamp taken 
 topo columns, print blanks on 1st (average) line 
 IRQ 
 SMI 
 Added counters 
 C1 
 print per-core data only for 1st thread in core 
 Mod%c6 
 print per-package data only for 1st core in package 
 PkgTmp 
 GFXrc6 
 detect GFX counter reset 
 GFXMHz 
 GFXACTMHz 
 Totl%C0, Any%C0 GFX%C0 CPUGFX% 
 flag an error when rc6 counter resetswraps 
  old = new - old
 we run cpuid just the 1st time, copy the results 
	
	  the timestamps from start of measurement interval are in "old"
	  the timestamp from end of measurement interval are in "new"
	  over-write old w new so we can print end of interval values
 check for TSC < 1 Mcycles over interval 
		
		  Some models have a dedicated C1 residency MSR,
		  which should be more accurate than the derivation below.
		
		  As counter collection is not atomic,
		  it is possible for mperf's non-halted cycles + idle states
		  to exceed TSC's all cycles: show c1 = 0% in that case.
 normal case, derive c1 
 divide by 0 protection 
 calculate core delta only for 1st thread in core 
 always calculate thread delta 
 c2 is core delta 
 calculate package delta only for 1st core in package 
 tells format_counters to dump all fields from this set 
 copy un-changing apic_id's 
 remember first tv_begin 
 remember last tv_end 
 sum per-core values only for 1st thread in core 
 sum per-pkg values only for 1st core in pkg 
  sum the counters for all cpus in the system
  compute the weighted average
 Use the global time delta for the average. 
  Open a file, and exit on failure
  snapshot_sysfs_counter()
  return snapshot of given counter
  get_counters(...)
  migrate to cpu
  acquire and record local counters for that cpu
 we are running on local CPU of interest 
		
		  The TSC, APERF and MPERF must be read together for
		  APERFMPERF and MPERFTSC to give accurate results.
		 
		  Unfortunately, APERF and MPERF are read by
		  individual system call, so delays may occur
		  between them.  If the time to read them
		  varies by a large amount, we re-read them.
		
		  This initial dummy APERF read has been seen to
		  reduce jitter in the subsequent reads.
 re-read close to APERF 
		
		  If the system call latency to read APERF and MPERF
		  differ by more than 2x, then try again.
 collect core counters only for 1st thread in core 
			
			  For Atom CPUs that has core cstate deeper than c6,
			  MSR_CORE_C6_RESIDENCY returns residency of cc6 and deeper.
			  Minus CC7 (and deeper cstates) residency to get
			  accturate cc6 residency.
 collect package counters only for 1st core in package 
  MSR_PKG_CST_CONFIG_CONTROL decoding for pkg_cstate_limit:
  If you change the values, note they are used both in comparisons
  (>= PCL__7) and to index pkg_cstate_limit_strings[].
 Unknown 
 Reserved 
 PC0 
 PC1 
 PC2 
 PC3 
 PC4 
 PC6 
 PC6 No Retention 
 PC6 Retention 
 PC7 
 PC7 Shrink 
 PC8 
 PC9 
 PC10 
 Unlimited 
 C-state Pre-wake Disable (CSTATE_PREWAKE_DISABLE) 
	
	  Turbo encoding in KNL is as follows:
	  [0] -- Reserved
	  [7:1] -- Base value of number of active cores of bucket 1.
	  [15:8] -- Base value of freq ratio of bucket 1.
	  [20:16] -- +ve delta of number of active cores of bucket 2.
	  i.e. active cores of bucket 2 =
	  active cores of bucket 1 + delta
	  [23:21] -- Negative delta of freq ratio of bucket 2.
	  i.e. freq ratio of bucket 2 =
	  freq ratio of bucket 1 - delta
	  [28:24]-- +ve delta of number of active cores of bucket 3.
	  [31:29]-- -ve delta of freq ratio of bucket 3.
	  [36:32]-- +ve delta of number of active cores of bucket 4.
	  [39:37]-- -ve delta of freq ratio of bucket 4.
	  [44:40]-- +ve delta of number of active cores of bucket 5.
	  [47:45]-- -ve delta of freq ratio of bucket 5.
	  [52:48]-- +ve delta of number of active cores of bucket 6.
	  [55:53]-- -ve delta of freq ratio of bucket 6.
	  [60:56]-- +ve delta of number of active cores of bucket 7.
	  [63:61]-- -ve delta of freq ratio of bucket 7.
  Parse a file containing a single int.
  Return 0 if file can not be opened
  Exit if file can be opened, but can not be parsed
  cpu_is_first_core_in_package(cpu)
  return 1 if given CPU is 1st core in package
 initialize logical_node_id 
 find a cpu with an unset logical_node_id 
			
			  find all matching cpus on this pkg and set
			  the logical_node_id
  run func(thread, core, package) in topology order
  skip non-present cpus
  run func(cpu) on every cpu in procstat
  return max_cpu number
 0 based 
  count_cpus()
  remember the last one seen, it will be the max
  snapshot_proc_interrupts()
  read and record summary of procinterrupts
  return 1 if config change requires a restart, else return 0
 read 1st line of procinterrupts to get cpu name for each column 
 read procinterrupt count lines and sum up irqs per cpu 
 flush irq# "N:" 
 read the count per cpu 
 flush interrupt description 
  snapshot_gfx_rc6_ms()
  record snapshot of
  sysclassdrmcard0powerrc6_residency_ms
  return 1 if config change requires a restart, else return 0
  snapshot_gfx_mhz()
  record snapshot of
  sysclassgraphicsfb0devicedrmcard0gt_cur_freq_mhz
  return 1 if config change requires a restart, else return 0
  snapshot_gfx_cur_mhz()
  record snapshot of
  sysclassgraphicsfb0devicedrmcard0gt_act_freq_mhz
  return 1 if config change requires a restart, else return 0
  snapshot_cpu_lpi()
  record snapshot of
  sysdevicessystemcpucpuidlelow_power_idle_cpu_residency_us
  snapshot_sys_lpi()
  record snapshot of sys_lpi_file
  snapshot proc and sys files
  return 1 if configuration restart needed, else return 0
			
			  'stdin' is a pipe closed on the other end. There
			  won't be any further input.
 Sleep the rest of the time 
 get_msr_sum() = sum + (get_msr() - last) 
 Timer callback, update the sum of MSRs periodically. 
	
	  Signal handler might be restricted, so use thread notifier instead.
	
	  A wraparound time has been calculated early.
	  Some sources state that the peak power for a
	  microprocessor is usually 1.5 times the TDP rating,
	  use 2  TDP for safety.
  set_my_sched_priority(pri)
  return previous
	
	  elevate own priority for interval mode
  check for CAP_SYS_RAWIO
  return 0 on success
  return 1 on fail
 check for CAP_SYS_RAWIO 
 test file permissions 
msr");
 if all else fails, thell them to be root 
  NHM adds support for additional MSRs:
  MSR_SMI_COUNT                   0x00000034
  MSR_PLATFORM_INFO               0x000000ce
  MSR_PKG_CST_CONFIG_CONTROL     0x000000e2
  MSR_MISC_PWR_MGMT               0x000001aa
  MSR_PKG_C3_RESIDENCY            0x000003f8
  MSR_PKG_C6_RESIDENCY            0x000003f9
  MSR_CORE_C3_RESIDENCY           0x000003fc
  MSR_CORE_C6_RESIDENCY           0x000003fd
  Side effect:
  sets global pkg_cstate_limit to decode MSR_PKG_CST_CONFIG_CONTROL
  sets has_misc_feature_control
 Core i7 and i5 Processor - Clarksfield, Lynnfield, Jasper Forest 
 Nehalem-EX Xeon - Beckton 
 SNB 
 SNB Xeon 
 IVB 
 IVB Xeon 
 HSW 
 HSW 
 HSX 
 HSW 
 BDW 
 BDW 
 BDX 
 SKL 
 CNL 
 SKX 
 ICX 
 BYT 
 AVN 
 AMT 
 PHI 
 BXT 
 DNV 
 EHL 
 JVL 
  SLV client has support for unique MSRs:
  MSR_CC6_DEMOTION_POLICY_CONFIG
  MSR_MC6_DEMOTION_POLICY_CONFIG
 Nehalem compatible, but do not include turbo-ratio limit support 
 Nehalem-EX Xeon - Beckton 
 PHI - Knights Landing (different MSR definition) 
 IVB Xeon 
 HSW Xeon 
 HSW Xeon 
 Knights Landing 
 IVB 
 HSW 
 HSX 
 HSW 
 HSW 
 BDW 
 BDW 
 BDX 
 SKL 
 CNL 
 SKX 
 ICX 
 Knights Landing 
  tcc_offset_bits:
  0: Tcc Offset not supported (Default)
  6: Bit 29:24 of MSR_PLATFORM_INFO
  4: Bit 27:24 of MSR_PLATFORM_INFO
 truncate "C1-HSW\n" to "C1", or truncate "C1\n" to "C1" 
  print_epb()
  Decode the ENERGY_PERF_BIAS MSR
 EPB is per-package 
  print_hwp()
  Decode the MSR_HWP_CAPABILITIES
 MSR_HWP_CAPABILITIES is per-package 
 MSR_PM_ENABLE[1] == 1 if HWP is enabled and MSRs visible 
  print_perf_limit()
 per-package 
 15 bit power granularity 
 6 bit time granularity 
 This is the max stock TDP of HEDTServer Fam17h+ chips 
  rapl_dram_energy_units_probe()
  Energy units are either hard-coded, or come from RAPL Energy Unit MSR.
 only called for genuine_intel, family 6 
 HSX 
 BDX 
 SKX 
 KNL 
 HSW 
 HSW 
 HSW 
 BDW 
 BDW 
 BXT 
 EHL 
 JVL 
 SKL 
 CNL 
 HSX 
 BDX 
 SKX 
 ICX 
 KNL 
 BYT 
 AVN 
 DNV 
 units on package 0, verify later other packages match 
 RAPL (Fam 17h+) 
  rapl_probe()
  sets do_rapl, rapl_power_units, rapl_energy_units, rapl_time_units
 HSW 
 HSW 
 HSW 
 HSX 
 DTS is per-core, no need to print for each thread 
 RAPL counters are per package, so print only for 1st threadpackage 
  SNB adds support for additional MSRs:
  MSR_PKG_C7_RESIDENCY            0x000003fa
  MSR_CORE_C7_RESIDENCY           0x000003fe
  MSR_PKG_C2_RESIDENCY            0x0000060d
 IVB 
 IVB Xeon 
 HSW 
 HSW 
 HSW 
 HSW 
 BDW 
 BDW 
 BDX 
 SKL 
 CNL 
 SKX 
 ICX 
 BXT 
 DNV 
 EHL 
 JVL 
  HSW ULT added support for C8C9C10 MSRs:
  MSR_PKG_C8_RESIDENCY		0x00000630
  MSR_PKG_C9_RESIDENCY		0x00000631
  MSR_PKG_C10_RESIDENCY	0x00000632
  MSR_PKGC8_IRTL		0x00000633
  MSR_PKGC9_IRTL		0x00000634
  MSR_PKGC10_IRTL		0x00000635
 HSW 
 BDW 
 SKL 
 CNL 
 BXT 
 EHL 
  SKL adds support for additional MSRS:
  MSR_PKG_WEIGHTED_CORE_C0_RES    0x00000658
  MSR_PKG_ANY_CORE_C0_RES         0x00000659
  MSR_PKG_ANY_GFXE_C0_RES         0x0000065A
  MSR_PKG_BOTH_CORE_GFXE_C0_RES   0x0000065B
 SKL 
 CNL 
 BYT 
 AVN 
 KNL 
 CNL 
  MSR_IA32_TEMPERATURE_TARGET indicates the temperature where
  the Thermal Control Circuit (TCC) activates.
  This is usually equal to tjMax.
  Older processors do not have this MSR, so there we guess,
  but also allow cmdline over-ride with -T.
  Several MSR temperature values are in units of degrees-C
  below this value, including the Digital Thermal Sensor (DTS),
  Package Thermal Management Sensor (PTM), and thermal event thresholds.
 tj_max is used only for dts or ptm 
 this is a per-package concept 
 Temperature Target MSR is Nehalem and newer only 
  Decode MSR_MISC_PWR_MGMT
  Decode the bits according to the Nehalem documentation
  bit[0] seems to continue to have same meaning going forward
  bit[1] less so...
  Decode MSR_CC6_DEMOTION_POLICY_CONFIG, MSR_MC6_DEMOTION_POLICY_CONFIG
  This MSRs are present on Silvermont processors,
  Intel Atom processor E3000 series (Baytrail), and friends.
  When models are the same, for the purpose of turbostat, reuse
 Core i7, Xeon 5500 series - Bloomfield, Gainstown NHM-EP 
 Core i7 and i5 Processor - Clarksfield, Lynnfield, Jasper Forest 
 Core i7 and i5 Processor - Nehalem 
 Westmere Client - Clarkdale, Arrandale 
 Westmere EP - Gulftown 
 Nehalem-EX Xeon - Beckton 
 Westmere-EX Xeon - Eagleton 
 BDX-DE 
  Linux-perf manages the the HW instructions-retired counter
  by enabling when requested, and hiding rollover
	
	  check max extended function levels of CPUID.
	  This is needed to check for invariant TSC.
	  This check is valid for both Intel and AMD.
		
		  Non-Stop TSC is advertised by CPUID.EAX=0x80000007: EDX.bit8
		  this check is valid for both Intel and AMD
	
	  APERFMPERF is advertised by CPUID.EAX=0x6: ECX.bit0
	  this check is valid for both Intel and AMD
		
		  CPUID 15H TSCCrystal ratio, possibly Crystal Hz
 SKL 
 24.0 MHz 
 DNV 
 25.0 MHz 
 BXT 
 19.2 MHz 
		
		  CPUID 16H Base MHz, Max MHz, Bus MHz
  in devcpu return success for names that are numbers
  ie. filter out ".", "..", "microcode".
 Initialize num_cpus, max_cpu_num 
	
	  Allocate and initialize cpu_present_set
	
	  Validate that all cpus in cpu_subset are also in cpu_present_set
	
	  Allocate and initialize cpu_affinity_set
	
	  For online cpus
	  find max_core_id, max_package_id
 get package information 
 get die information 
 get numa node information 
 get core information 
 get thread information 
  init_counter()
  set FIRST_THREAD_IN_CORE and FIRST_CORE_IN_PACKAGE
	 Workaround for systems where physical_node_id==-1
	  and logical_node_id==(-1 - topo.num_cpus)
 clear affinity side-effect of get_counters() 
 child 
 parent 
	
	  n.b. fork_it() does not check for errors from for_all_cpus()
	  because re-starting is problematic when forking
 18 < NAME_BYTES 
 generate default column header 
 truncate "C1-HSW\n" to "C1", or truncate "C1\n" to "C1" 
 truncate "C1-HSW\n" to "C1", or truncate "C1\n" to "C1" 
  parse cpuset with following syntax
  1,2,4..6,8-10 and set bits in cpu_subset
 no negative cpu numbers 
 start range 
 start range 
 internal, not documented 
 meh, -h taken by --help
 --enable specified counter 
			
			  --hide: do not show those specified
			   multiple invocations simply clear more bits in enabled mask
			
			  --show: show only those specified
			   The 1st invocation will clear and replace the enabled mask
			   subsequent invocations can add to it.
 dump counters and exit 
 list header and exit 
	
	  if any params left, it must be a command to fork
 SPDX-License-Identifier: GPL-2.0-only
  Userspace PCI Endpoint Test Module
  Copyright (C) 2017 Texas Instruments
  Author: Kishon Vijay Abraham I <kishon@ti.com>
 return 0 if test succeeded 
 since '0' is a valid BAR number, initialize it to -1 
 set default size as 100KB 
 set default endpoint device 
 SPDX-License-Identifier: GPL-2.0-only
  Minimal BPF debugger
  Minimal BPF debugger that mimics the kernel's engine (wo extensions)
  and allows for single stepping through selected packets from a pcap
  with a provided user filter in order to facilitate verification of a
  BPF program. Besides others, this is useful to verify BPF programs
  before attaching to a live system, and can be used in socket filters,
  cls_bpf, xt_bpf, team driver and e.g. PTP code; in particular when a
  single more complex BPF program is being used. Reasons for a more
  complex BPF program are likely primarily to optimize execution time
  for making a verdict when multiple simple BPF programs are combined
  into one in order to prevent parsing same headers multiple times.
  More on how to debug BPF opcodes see Documentationnetworkingfilter.rst
  which is the main document on BPF. Mini howto for getting started:
   1) `.bpf_dbg` to enter the shell (shell cmds denoted with '>'):
   2) > load bpf 6,40 0 0 12,21 0 3 20... (output from `bpf_asm` or
      `tcpdump -iem1 -ddd port 22 | tr '\n' ','` to load as filter)
   3) > load pcap foo.pcap
   4) > run <n>disassembledumpquit (self-explanatory)
   5) > breakpoint 2 (sets bp at loaded BPF insns 2, do `run` then;
        multiple bps can be set, of course, a call to `breakpoint`
        wo args shows currently loaded bps, `breakpoint reset` for
        resetting all breakpoints)
   6) > select 3 (`run` etc will start from the 3rd packet in the pcap)
   7) > step [-<n>, +<n>] (performs single stepping through the BPF)
  Copyright 2013 Daniel Borkmann <borkmann@redhat.com>
 { op, jt, jf, k }, \n");
 noop ;
 SPDX-License-Identifier: GPL-2.0-only
  Minimal BPF assembler
  Instead of libpcap high-level filter expressions, it can be quite
  useful to define filters in low-level BPF assembler (that is kept
  close to Steven McCanne and Van Jacobson's original BPF paper).
  In particular for BPF JIT implementors, JIT security auditors, or
  just for defining BPF expressions that contain extensions which are
  not supported by compilers.
  How to get into it:
  1) read Documentationnetworkingfilter.rst
  2) Run `bpf_asm [-c] <filter-prog file>` to translate into binary
     blob that is loadable with xt_bpf, cls_bpf et al. Note: -c will
     pretty print a C-like construct.
  Copyright 2013 Daniel Borkmann <borkmann@redhat.com>
 SPDX-License-Identifier: GPL-2.0-only
  Minimal BPF JIT image disassembler
  Disassembles BPF JIT compiler emitted opcodes back to asm insn's for
  debugging or verification purposes.
  To get the disassembly of the JIT code, do the following:
   1) `echo 2 > procsysnetcorebpf_jit_enable`
   2) Load a BPF filter (e.g. `tcpdump -p -n -s 0 -i eth1 host 192.168.20.024`)
   3) Run e.g. `bpf_jit_disasm -o` to read out the last JIT code
  Copyright 2013 Daniel Borkmann <borkmann@redhat.com>
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2020 Facebook 
 BPFTOOL_WITHOUT_SKELETONS 
 new ref 
	 we don't want output polluted with libbpf errors if bpf_iter is not
	  supported
 too bad, kernel doesn't support BPF iterators yet 
 if we loaded above successfully, attach has to succeed 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2018 Facebook
 Author: Yonghong Song <yhs@fb.com>
 0: undecided, 1: supported, 2: not supported 
	 the following query will fail as no bpf attachment,
	  the expected errno is ENOTSUPP
 ENOTSUPP ) {
 prefix always proc 
 pid should be all numbers 
 check proc<pid>fd directory 
 check proc<pid>fd<fd_num> 
 query (pid, fd) for potential perf events 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2018 Facebook
 skip clsact qdisc 
 root, ingress and egress handle 
			 Older kernel's don't support querying
			  flow dissector programs.
 parse attach args 
 attach xdp prog 
 parse detach args 
 detach xdp prog 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2019 Facebook 
 Using basename() GNU version which doesn't modify arg. 
 static variables are not exposed through BPF skeleton 
		 Assume 32-bit architectures when generating data section
		  struct memory layout. Given bpftool can't know which target
		  host architecture it's emitting skeleton for, we need to be
		  conservative and assume 32-bit one to ensure enough padding
		  bytes are generated for pointer and long types. This will
		  still work correctly for 64-bit architectures, because in
		  the worst case we'll generate unnecessary padding field,
		  which on 64-bit architectures is not strictly necessary and
		  would be handled by natural 8-byte alignment. But it still
		  will be a correct memory layout, based on recorded offsets
		  in BTF.
		 sanitize variable name, e.g., for static vars inside
		  a function, it's name is '<function name>.<variable name>',
		  which we'll turn into a '<function name>_<variable name>'
 only generate definitions for memory-mapped internal maps 
		 In some cases (e.g., sections like .rodata.cst16 containing
		  compiler allocated string constants only) there will be
		  special internal maps with no corresponding DATASEC BTF
		  type. In such case, generate empty structs for each such
		  map. It will still be memory-mapped and its contents
		  accessible from user-space through BPF skeleton.
 find out "baseline" indentation to skip 
 skip baseline indentation tabs 
 trim trailing whitespace 
 print out using adjusted template 
 auto-attach not supported \n");
 log_level1 + log_level2 + stats, but not stable UAPI 
	 If there was no error during load then gen_loader_opts
	  are populated with the loader program.
 finish generating 'struct skel' 
 %s 						    \n\
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)    \n\
 THIS FILE IS AUTOGENERATED! 			    \n\
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)    \n\
 THIS FILE IS AUTOGENERATED! 			    \n\
 maps 				    \n\
 memory-mapped internal maps 
 programs 				    \n\
 embed contents of BPF object file 
 %s 						    \n\
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2018 Facebook
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (c) 2018 Facebook 
 for (FILE ) used by json_writer 
 Get the ptr's func_proto 
 Get the bpf_prog's name.  Obtain from func_info. 
	 Not skipping typedef.  typedef to char does not count as
	  a string now.
 '\0' is not found 
	 data points to a __int128 number.
	  Suppose
	      int128_num = (__int128 )data;
	  The below formulas shows what upper_num and lower_num represents:
	      upper_num = int128_num >> 64;
	      lower_num = int128_num & 0xffffffffFFFFFFFFULL;
 shake out un-needed bits by shiftor operations 
	 bits_offset is at most 7.
	  BTF_INT_OFFSET() cannot exceed 128 bits.
 if this is bit field 
 shouldn't happen 
 map key or value can't be forward 
				 Remove unnecessary space for
				  FUNC_PROTO that does not have
				  arg->name_off
		 More forgiving on file because linum option is
		  expected to provide more info than the already
		  available src line.
 SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-2-Clause)
  Simple streaming JSON writer
  This takes care of the annoying bits of JSON syntax like the commas
  after elements
  Authors:	Stephen Hemminger <stephen@networkplumber.org>
 output file 
 nesting 
 optional whitepace 
 either nul or comma 
 indentation for pretty print 
 end current line and indent if pretty printing 
 If current object is not empty print a comma 
 Output JSON encoded string 
 Handles C escapes, does not do Unicode 
 Create a new JSON stream 
 End output to JSON stream 
 Basic blocks 
 Add a JSON property name 
 Collections 
 JSON value types 
 Basic namevalue objects 
vyatta.com");
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2018 Netronome Systems, Inc. 
 sysctl kernel.kptr_restrict was set 
 Align each instruction dump row left. 
 Output multiline concatenation. 
 Escape special character. 
 Do not show address for interpreted programs 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
  Based on:
  Minimal BPF JIT image disassembler
  Disassembles BPF JIT compiler emitted opcodes back to asm insn's for
  debugging or verification purposes.
  Copyright 2013 Daniel Borkmann <daniel@iogearbox.net>
  Licensed under the GNU General Public License, version 2.0 (GPLv2)
 Strip trailing spaces 
 Skip 
 Update architecture info for offload. 
			 Operand array, was started in fprintf_json. Before
			  that, make sure we have a _null_ value if no operand
			  other than operation code was present.
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2017-2018 Netronome Systems, Inc. 
	 We don't proceed to check the kinds of the elements of the DATASEC.
	  The verifier enforces them to be BTF_KIND_VAR.
 Piggy back on load_time, since 0 uid is a valid one 
 Piggy back on load_time, since 0 uid is a valid one 
 root array 
 root array 
 DUMP_XLATED 
 root array 
 prog object 
 prog object 
 root array 
 No space for fread()-ing next chunk; realloc() 
 Row offset 
 Hexadecimal values 
 ASCII values (if relevant), '.' otherwise 
 root 
	 Do not exit on errors occurring when printing output datacontext,
	  we still want to print return value and duration for program run.
 root 
 libbpf_prog_type_by_name() failed, let's re-run with debug level 
 Put a '' at the end of type to appease libbpf 
	 After the sort maps by name will be first on the list, because they
	  have idx == -1.  Resolve them.
 Resort if any names were resolved 
 Set ifindex and name reuse 
 Next reuse wants to apply to the same map 
 log_level1 + log_level2 + stats, but not stable UAPI 
 log_level1 + log_level2 + stats, but not stable UAPI 
 BPFTOOL_WITHOUT_SKELETONS 
 calculate ratios like instructions per cycle 
 0 for NA, 1 for index 0 (cycles) 
pid, cpu, -1
 we at least need two args for the prog and one metric 
 parse target fd 
 parse profiling optional duration 
 adjust map sizes 
 change target name 
 BPFTOOL_WITHOUT_SKELETONS 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2020 Facebook 
 Ensure map_info_alloc() has at least what the bpftool needs 
 If the subcmd needs to print out the bpf_map_info,
  it should always call map_info_alloc to allocate
  a bpf_map_info object instead of allocating it
  on the stack.
  map_info_alloc() will take the running kernel's btf
  into account.  i.e. it will consider the
  sizeof(struct bpf_map_info) of the running kernel.
  It will enable the "struct_ops" cmd to print the latest
  "struct bpf_map_info".
  [ Recall that "struct_ops" requires the kernel's btf to
    be available ]
 It iterates all struct_ops maps of the system.
  It returns the fd in "res_fd" and map_info in "info".
  In the very first iteration, info->id should be 0.
  An optional map "name" filter can be specified.
  The filter can be made more flexible in the future.
  e.g. filter by kernel-struct-ops-name, regex-name, glob-name, ...etc.
  Return value:
      1: A struct_ops map found.  It is returned in "res_fd" and "info".
 	  The caller can continue to call get_next in the future.
      0: No struct_ops map is returned.
         All struct_ops map has been found.
     -1: Error and the caller should abort the iteration.
 "data" is the work_func private storage 
 Find all struct_ops map in the system.
  Filter out by "name" (if specified).
  Then call "func(fd, info, data, wtr)" on each struct_ops map found.
		 It is not printing empty [].
		  Thus, needs to specifically say nothing found
		  for "name" here.
		 The "func()" above is not writing any json (i.e. !wtr
		  test here).
		 
		  However, "-j" is enabled and there is no errs here,
		  so call json_null() as the current convention of
		  other cmds.
		 The "func()" above is not writing any json (i.e. !wtr
		  test here).
		 
		  However, "-j" is enabled and there is no errs here,
		  so call json_null() as the current convention of
		  other cmds.
 note: d->jw == wtr 
	 The kernel supporting BPF_MAP_TYPE_STRUCT_OPS must have
	  btf_vmlinux_value_type_id.
 log_level1 + log_level2 + stats, but not stable UAPI 
			 Not p_err.  The struct_ops was attached
			  successfully.
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (c) 2015-2017 Daniel Borkmann 
 Copyright (c) 2018 Netronome Systems, Inc. 
 Allow room for NULL terminating byte and pipe file name 
 The string from fscanf() might be truncated, check mnt is valid 
	 Most of the time, tracefs is automatically mounted by debugfs at
	  syskerneldebugtracing when we try to access it. If we could not
	  find it, it is likely that debugfs is not mounted. Let's give one
	  attempt at mounting just tracefs at syskerneltracing.
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2019 Facebook 
 __VMLINUX_H__ \n");
 btf object 
 prog_ids 
 prog_ids 
 map_ids 
 map_ids 
 pids 
 btf object 
 if kernel support emitting BTF object name, pass name pointer 
 root array 
 root array 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (c) 2019 Netronome Systems, Inc. 
 Miscellaneous utility functions 
 Printing utility functions 
 %s%s is not set \n", define_prefix, name);
 Probing functions 
 No support for C-style ouptut 
 No support for C-style ouptut 
 No support for C-style ouptut 
 No support for C-style ouptut 
 No support for C-style ouptut 
 Trim ending '\n' 
 Split on '=' and ensure that a value is present. 
 Enable BPF 
 Enable bpf() syscall 
 Does selected architecture support eBPF JIT compiler 
 Compile eBPF JIT compiler 
 Avoid compiling eBPF interpreter (use JIT only) 
 Kernel BTF debug information available 
 Kernel module BTF debug information available 
 cgroups 
 BPF programs attached to cgroups 
 bpf_get_cgroup_classid() helper 
 bpf_skb_{,ancestor_}cgroup_id() helpers 
 Tracing: attach BPF to kprobes, tracepoints, etc. 
 Kprobes 
 Uprobes 
 Tracepoints 
 Syscall tracepoints 
 bpf_override_return() helper support for selected arch 
 bpf_override_return() helper 
 Network 
 AF_XDP sockets 
 BPF_PROG_TYPE_LWT_ and related helpers 
 BPF_PROG_TYPE_SCHED_ACT, TC (traffic control) actions 
 BPF_PROG_TYPE_SCHED_CLS, TC filters 
 TC clsact qdisc 
 Ingress filtering with TC 
 bpf_skb_get_xfrm_state() helper 
 bpf_get_route_realm() helper 
 BPF_PROG_TYPE_LWT_SEG6_LOCAL and related helpers 
 BPF_PROG_TYPE_LIRC_MODE2 and related helpers 
 BPF stream parser and BPF socket maps 
 xt_bpf module for passing BPF programs to netfilter  
 bpfilter back-end for iptables 
 bpftilter module with "user mode helper" 
 test_bpf module for BPF tests 
 Misc configs useful in BPF C programs 
 jiffies <-> sec conversion for bpf_jiffies64() helper 
 gzopen also accepts uncompressed files. 
		 Some distributions build with CONFIG_IKCONFIG=y and put the
		  config file at procconfig.gz.
 Sanity checks 
 Only test offload-able program types 
	 Probe may succeed even if program load fails, for unprivileged users
	  check that we did not fail because of insufficient permissions
	 Probe result depends on the success of map creation, no additional
	  check required for unprivileged users
		 Probe may succeed even if program load fails, for
		  unprivileged users check that we did not fail because of
		  insufficient permissions
 Only test helpers for offload-able program types 
		 Skip helper functions which emit dmesg messages when not in
		  the full mode.
 fallthrough 
 Misc kernel config items ",
 procfs not mounted, skipping related probes ");
 System call availability ",
 eBPF program types ",
 eBPF map types ",
 eBPF helper functions ",
		printf("\n"
		       "  Use %sHAVE_PROG_TYPE_HELPER(prog_type_name, helper_name)\n"
		       "  to determine if <helper_name> is available for <prog_type_name>,\n"
		       "  e.g.\n"
		       " 	#if %sHAVE_PROG_TYPE_HELPER(xdp, bpf_redirect)\n"
		       " 		 do stuff with this helper\n"
		       " 	#elif\n"
		       " 		 use a workaround\n"
		       " 	#endif\n"
 eBPF misc features ",
 strlen("CAP_SYS_ADMIN") 
			 System does not know about CAP_BPF, meaning that
			  CAP_SYS_ADMIN is the only capability required. We
			  just checked it, break.
 We are all good, exit now 
 CAP_BPF 
 if (run_as_unprivileged && nb_bpf_caps > 0), drop capabilities. 
	 Detection assumes user has specific privileges.
	  We do not use libpcap so let's approximate, and restrict usage to
	  root user only.
 USE_LIBCAP 
	 Full feature detection requires specific privileges.
	  Let's approximate, and warn if user is not root.
 bpf() syscall unavailable, don't probe other BPF features 
 End root object 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2017 Facebook
 Author: Roman Gushchin <guro@fb.com>
		
		  Not all attach types may be supported, so it's expected,
		  that some requests will fail.
		  If we were able to get the show for at least one
		  attach type, let's return 0.
  To distinguish nftw() errors and do_show_tree_fn() errors
  and avoid duplicating error messages, let's return -2
  from do_show_tree_fn() in case of error.
		 Last attach type does not support query.
		  Do not report an error for this, especially because batch
		  mode would stop processing commands.
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2018 Netronome Systems, Inc. 
	 Add an invisible edge from ENTRY to EXIT, this is to
	  improve the graph layout.
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2017-2018 Netronome Systems, Inc. 
 libbpf_num_possible_cpus 
 nothing to do if already mounted 
 extra params for nftw cb 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2017-2018 Netronome Systems, Inc. 
 Don't allow prefixing in case of possible future shadowing 
 start of key-value pair 
 end of key-value pair 
	 For prog_array maps or arrays of maps, failure to lookup the value
	  means there is no entry for that key. Do not print an error message
	  in that case.
 entry 
 error 
 error 
 entry 
 on per cpu maps we must copy the provided value on all value instances 
 root array 
 root array 
 map object 
 elements 
 elements 
 map object 
 root array 
 root array 
		 if here json_wtr wouldn't have been initialised,
		  so let's create separate writer for btf
 here means bpf_map_lookup_elem() succeeded 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2020 Facebook
 optional arguments 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2020 Facebook 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2018 Netronome Systems, Inc. 
 This program is free software; you can redistribute it andor
  modify it under the terms of version 2 of the GNU General Public
  License as published by the Free Software Foundation.
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (C) 2017-2018 Netronome Systems, Inc. 
 root object 
 features 
 features 
 root object 
 Last argument MUST be NULL pointer 
 nothing ;
 Split command line into argument vector. 
 Skip leading whitespace. 
 Word begins with quote. 
 Find ending quote. 
 Find end of word. 
 Separate words. 
		 Append continuation lines if any (coming after a line ending
		  with '\' in the batch file).
 fall through 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (c) 2020 Facebook 
 keep in sync with the definition in main.h 
 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
 Copyright (c) 2020 Facebook
 map of perf event fds, num_cpu  num_metric entries 
 readings at fentry 
 accumulated readings 
 sample counts, one per cpu 
 look up before reading, to reduce error 
 only account samples with a valid fentry_reading 
 read all events before updating the maps, to reduce error 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
  resolve_btfids scans Elf object for .BTF_ids section and resolves
  its symbols with BTF ID values.
  Each symbol points to 4 bytes data and is expected to have
  following name syntax:
  __BTF_ID__<type>__<symbol>[__<id>]
  type is:
    func    - lookup BTF_KIND_FUNC symbol with <symbol> name
              and store its ID into the data:
              __BTF_ID__func__vfs_close__1:
              .zero 4
    struct  - lookup BTF_KIND_STRUCT symbol with <symbol> name
              and store its ID into the data:
              __BTF_ID__struct__sk_buff__1:
              .zero 4
    union   - lookup BTF_KIND_UNION symbol with <symbol> name
              and store its ID into the data:
              __BTF_ID__union__thread_union__1:
              .zero 4
    typedef - lookup BTF_KIND_TYPEDEF symbol with <symbol> name
              and store its ID into the data:
              __BTF_ID__typedef__pid_t__1:
              .zero 4
    set     - store symbol size into first 4 bytes and sort following
              ID list
              __BTF_ID__set__list:
              .zero 4
              list:
              __BTF_ID__func__vfs_getattr__3:
              .zero 4
              __BTF_ID__func__vfs_fallocate__4:
              .zero 4
	
	  __BTF_ID__func__vfs_truncate__0
	  prefix_end =  ^
	  pos        =    ^
		
		  __BTF_ID__func__vfs_truncate__0
		  id =            ^
		 
		  cut the unique id part
	
	  __BTF_ID__set__name
	  name =    ^
	  id   =         ^
 Older libelf.h and glibc elf.h might not yet define the ELF compression types. 
 Section with compressed data. 
  The data of compressed section should be aligned to 4
  (for 32bit) or 8 (for 64 bit) bytes. The binutils ld
  sets sh_addralign to 1, which makes libelf fail with
  misaligned section error during the update:
     FAILED elf_update(WRITE): invalid section alignment
  While waiting for ld fix, we fix the compressed sections
  sh_addralign value manualy.
	
	  Scan all the elf sections and look for save data
	  from .BTF_ids section and symbols.
	
	  Scan symbols and look for the ones starting with
	  __BTF_ID__ over .BTF_ids section.
		
		  __BTF_ID__TYPE__vfs_truncate__0
		  prefix =  ^
 struct 
 union  
 typedef 
 func 
 set 
			
			  SET objects store list's count, which is encoded
			  in symbol's size, together with 'cnt' field hence
			  that - 1.
	
	  Iterate all the BTF types and search for collected symbol IDs.
 sets are unique 
 Set type to ensure endian translation occurs. 
	
	  We did not find .BTF_ids section or symbols section,
	  nothing to do..
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019 Facebook
 record enqueue timestamp 
 TP_PROTO(struct task_struct p) 
 TP_PROTO(struct task_struct p) 
	 TP_PROTO(bool preempt, struct task_struct prev,
	 	    struct task_struct next)
 ivcsw: treat like an enqueue event and store timestamp 
 For pid mismatch, save a bpf_task_storage_get 
 fetch timestamp and calculate delta 
 missed enqueue 
 output 
 SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)
 Copyright (c) 2019 Facebook
 initialize global data (filtering options) 
 SPDX-License-Identifier: GPL-2.0
  Original work by Jeff Garzik
  External file lists, symlink, pipe and fifo support by Thayne Harbaugh
  Hard link support by Luciano Rocha
 magic 
 ino 
 mode 
 uid 
 gid 
 nlink 
 mtime 
 filesize 
 major 
 minor 
 rmajor 
 rminor 
 namesize 
 chksum 
 magic 
 ino 
 mode 
 uid 
 gid 
 nlink 
 mtime 
 filesize 
 major 
 minor 
 rmajor 
 rminor 
 namesize 
 chksum 
 magic 
 ino 
 mode 
 uid 
 gid 
 nlink 
 mtime 
 filesize 
 major 
 minor 
 rmajor 
 rminor 
 namesize 
 chksum 
 magic 
 ino 
 mode 
 uid 
 gid 
 nlink 
 mtime 
 filesize 
 major 
 minor 
 rmajor 
 rminor 
 namesize 
 chksum 
 data goes on last link 
 magic 
 ino 
 mode 
 uid 
 gid 
 nlink 
 mtime 
 filesize 
 major 
 minor 
 rmajor 
 rminor 
 namesize 
 chksum 
 malloc'ed buffer for hard links 
	
	  Timestamps after 2106-02-07 06:28:15 UTC have an ascii hex time_t
	  representation that exceeds 8 chars and breaks the cpio header
	  specification.
 comment - skip to next line 
 a blank line 
 must be an empty line 
 SPDX-License-Identifier: GPL-2.0-only
  regmap based generic GPIO driver
  Copyright 2020 Michael Walle <michael@walle.cc>
 we might not have an output register if we are input only 
  gpio_regmap_register() - Register a generic regmap GPIO controller
  @config: configuration for gpio_regmap
  Return: A pointer to the registered gpio_regmap or ERR_PTR error value.
 we need at least one 
 if we have a direction register we need both input and output 
 we don't support having both registers simultaneously for now 
 if not set, assume there is only one register 
 if not set, assume they are consecutive 
 gpiolib will use of_node of the parent if chip->of_node is NULL 
 CONFIG_OF_GPIO 
	
	  If our regmap is fast_io we should probably set can_sleep to false.
	  Right now, the regmap doesn't save this property, nor is there any
	  access function for it.
	  The only regmap type which uses fast_io is regmap-mmio. For now,
	  assume a safe default of true here.
  gpio_regmap_unregister() - Unregister a generic regmap GPIO controller
  @gpio: gpio_regmap device to unregister
  devm_gpio_regmap_register() - resource managed gpio_regmap_register()
  @dev: device that is registering this GPIO device
  @config: configuration for gpio_regmap
  Managed gpio_regmap_register(). For generic regmap GPIO device registered by
  this function, gpio_regmap_unregister() is automatically called on driver
  detach. See gpio_regmap_register() for more information.
  Return: A pointer to the registered gpio_regmap or ERR_PTR error value.
 SPDX-License-Identifier: GPL-2.0+
   Nano River Technologies viperboard GPIO lib driver
   (C) 2012 by Lemonage GmbH
   Author: Lars Poeschel <poeschel@lemonage.de>
   All rights reserved.
 gpio a related things 
 gpio b related things 
 gpioa sampling clock module parameter 
 ----- begin of gipo a chip -------------------------------------------- 
 if io is set to output, just return the saved value 
 ----- end of gpio a chip ---------------------------------------------- 
 ----- begin of gipo b chip -------------------------------------------- 
 if io is set to output, just return the saved value 
 cache the read values 
 ----- end of gpio b chip ---------------------------------------------- 
 registering gpio a 
 registering gpio b 
 SPDX-License-Identifier: GPL-2.0-only
  MC33880 high-sidelow-side switch GPIO driver
  Copyright (c) 2009 Intel Corporation
 Supports:
  Freescale MC33880 high-sidelow-side switch
  Pin configurations, see MAX7301 datasheet page 6
  Some registers must be read back to modify.
  To save time we cache them here in memory
 protect from simultaneous accesses 
	
	  bits_per_word cannot be configured in platform data
	 write twice, because during initialisation the first setting
	  is just for testing SPI communication, and the second is the
	  "real" configuration
 register after spi postcore initcall and before
  subsys initcalls that may rely on these GPIOs
 SPDX-License-Identifier: GPL-2.0-only
  ROHM BD9571MWV-M and BD9574MWF-M GPIO driver
  Copyright (C) 2017 Marek Vasut <marek.vasut+renesas@gmail.com>
  Based on the TPS65086 driver
  NOTE: Interrupts are not supported yet.
 Set the initial value 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  Support functions for OMAP GPIO
  Copyright (C) 2003-2005 Nokia Corporation
  Written by Juha Yrjl <juha.yrjola@nokia.com>
  Copyright (C) 2009 Texas Instruments
  Added OMAP4 support - Santosh Shilimkar <santosh.shilimkar@ti.com>
 set data out value using dedicate setclear register 
 set data out value using mask register 
		
		  Disable debounce before cutting it's clock. If debounce is
		  enabled but the clock is not, GPIO module seems to be unable
		  to detect events and generate interrupts at least on OMAP3.
  omap2_set_gpio_debounce - low level gpio debounce time
  @bank: the gpio bank we're acting upon
  @offset: the gpio number on this @bank
  @debounce: debounce time to use
  OMAP's debounce time is in 31us steps
    <debounce time> = (GPIO_DEBOUNCINGTIME[7:0].DEBOUNCETIME + 1) x 31
  so we need to convert and round up to the closest unit.
  Return: 0 on success, negative error otherwise.
	
	  Enable debounce clock per module.
	  This call is mandatory because in omap_gpio_request() when
	  _runtime_get_sync() is called,  _gpio_dbck_enable() within
	  runtime callbck fails to turn on dbck because dbck_enable_mask
	  used within _gpio_dbck_enable() is still not initialized at
	  that point. Therefore we have to enable dbck here.
  omap_clear_gpio_debounce - clear debounce settings for a gpio
  @bank: the gpio bank we're acting upon
  @offset: the gpio number on this @bank
  If a gpio is using debounce, then clear the debounce enable bit and if
  this is the only gpio in this bank using debounce, then clear the debounce
  time too. The debounce clock will also be disabled when calling this function
  if this is the only gpio in the bank using debounce.
  Off mode wake-up capable GPIOs in bank(s) that are in the wakeup domain.
  See TRM section for GPIO for "Wake-Up Generation" for the list of GPIOs
  in wakeup domain. If bank->non_wakeup_gpios is not configured, assume none
  are capable waking up the system from off mode.
	
	  We need the edge detection enabled for to allow the GPIO block
	  to be woken from idle state.  Set the appropriate edge detection
	  in addition to the level detection.
 This part needs to be executed always for OMAP{34xx, 44xx} 
		
		  Log the edge gpio and manually trigger the IRQ
		  after resume if the input level changes
		  to avoid irq lost during PER RETOFF mode
		  Applies for omap2 non-wakeup gpio and all omap3 gpios
  This only applies to chips that can't do both rising and falling edge
  detection at once.  For all other chips, this function is a noop.
 Claim the pin for MPU 
 Module is enabled, clocks are not gated 
 Module is disabled, clocks are gated 
		
		  Edge IRQs are already clearedacked in irq_handler and
		  not need to be masked, as result handle_edge_irq()
		  logic is excessed here and may cause lose of interrupts.
		  So just use handle_simple_irq.
 Workaround for clearing DSP GPIO interrupts to allow retention 
 Flush posted write for the irq status to avoid spurious interrupts 
	
	  Program GPIO wakeup along with IRQ enable to satisfy OMAP4430 TRM
	  note requiring correlation between the IRQ enable registers and
	  the wakeup registers.  In any case, we want wakeup from idle
	  enabled for the GPIOs which support this feature.
 Use disable_irq_wake() and enable_irq_wake() functions from drivers 
  We need to unmask the GPIO bank interrupt as soon as possible to
  avoid missing GPIO interrupts for other lines in the bank.
  Then we need to mask-read-clear-unmask the triggered GPIO lines
  in the bank to avoid missing nested interrupts for a GPIO line.
  If we wait to unmask individual GPIO lines in the bank after the
  line's interrupt handler has been run, we may miss some nested
  interrupts.
		
		  Clear edge sensitive interrupts before calling handler(s)
		  so subsequent edge transitions are not missed while the
		  handlers are running.
			
			  Some chips can't respond to both rising and falling
			  at the same time.  If this irq was requested with
			  both flags, we need to flip the ICR data for the IRQ
			  to respond to the IRQ for the opposite direction.
			  This will be indicated in the bank toggle_mask.
	
	  For level-triggered GPIOs, clearing must be done after the source
	  is cleared, thus after the handler has run. OMAP4 needs this done
	  after enabing the interrupt to clear the wakeup status.
---------------------------------------------------------------------
 use platform_driver for this. 
 could list the prociomem resources 
---------------------------------------------------------------------
---------------------------------------------------------------------
 Save OE default value (0xffffffff) in the context 
 Initialize interface clk ungated, module enabled 
	
	  REVISIT eventually switch from OMAP-specific gpio structs
	  over to the generic ones
	
	  REVISIT: Once we have OMAP1 supporting SPARSE_IRQ, we can drop
	  irq_alloc_descs() since a base IRQ offset will no longer be needed.
 MPUIO is a bit different, reading IRQ status clears it 
 Save syconfig, it's runtime value can be different from init value 
 Check for pending EDGE_FALLING, ignore EDGE_BOTH 
 Check for pending EDGE_RISING, ignore EDGE_BOTH 
	
	  If going to OFF, remove triggering for all wkup domain
	  non-wakeup GPIOs.  Otherwise spurious IRQs will be
	  generated.  See OMAP2420 Errata item 1.101.
	
	  On the first resume during the probe, the context has not
	  been initialised and so initialise it now. Also initialise
	  the context loss count.
 Restore changes done for OMAP2420 errata 1.101 
	
	  Check if any of the non-wakeup interrupt GPIOs have changed
	  state.  If so, generate an IRQ by software.  This is
	  horribly racy, but it's the best we can do to work around
	  this silicon bug.
	
	  No need to generate IRQs for the rising edge for gpio IRQs
	  configured with falling edge only; and vice versa.
 FIXME: Consider GPIO IRQs with level detections properly! 
 Consider all GPIO IRQs needed to be updated 
 Static mapping, never released 
  gpio driver register needs to be done before
  machine_init functions access gpio APIs.
  Hence omap_gpio_drv_reg() is a postcore_initcall.
 SPDX-License-Identifier: GPL-2.0-only
   Copyright Intel Corporation (C) 2014-2016. All Rights Reserved
  GPIO driver for  Altera Arria10 MAX5 System Resource Chip
  Adapted from gpio-tps65910.c
  struct altr_a10sr_gpio - Altera Max5 GPIO device private data structure
  @gp:   : instance of the gpio_chip
  @regmap: the regmap from the parent device.
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (c) 2020 HiSilicon Limited. 
	
	  The dual-edge interrupt and other interrupt's registers do not
	  take effect at the same time. The registers of the two-edge
	  interrupts have higher priorities, the configuration of
	  the dual-edge interrupts must be disabled before the configuration
	  of other kind of interrupts.
 Set hooks for irq_chip 
 Clear Mask of GPIO controller combine IRQ 
 Cycle for once, no need for an array to save line_num 
	
	  One GPIO controller own one port currently,
	  if we get more from ACPI table, return error.
 SPDX-License-Identifier: GPL-2.0-only
  GPIO support for Cirrus Logic Madera codecs
  Copyright (C) 2015-2018 Cirrus Logic
 storage space for the gpio_chip we're using 
 set() doesn't return an error so log a warning 
 Construct suitable gpio_chip from the template in madera_gpio_chip 
 We want to be usable on systems that don't use devicetree or acpi 
	
	  This is part of a composite MFD device which can only be used with
	  the corresponding pinctrl driver. On all supported silicon the GPIO
	  to pinctrl mapping is fixed in the silicon, so we register it
	  explicitly instead of requiring a redundant gpio-ranges in the
	  devicetree.
	  In any case we also want to work on systems that don't use devicetree
	  or acpi.
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for Aeroflex Gaisler GRGPIO General Purpose IO cores.
  2013 (c) Aeroflex Gaisler AB
  This driver supports the GRGPIO GPIO core available in the GRLIB VHDL
  IP core library.
  Full documentation of the GRGPIO core can be found here:
  http:www.gaisler.comproductsgrlibgrip.pdf
  See "Documentationdevicetreebindingsgpiogpio-grgpio.txt" for
  information on open firmware properties.
  Contributors: Andreas Larsson <andreas@gaisler.com>
 Structure for an irq of the core - called an underlying irq 
 Reference counter to manage requestingfreeing of uirq 
 Underlying irq of the gpio driver 
  Structure for an irq of a gpio line handed out by this driver. The index is
  used to map to the corresponding underlying irq.
 Index into struct grgpio_priv's uirqs, or -1 
 irq for the gpio line 
 irq mask shadow register 
	
	  The grgpio core can have multiple "underlying" irqs. The gpio lines
	  can be mapped to any one or none of these underlying irqs
	  independently of each other. This driver sets up an irq domain and
	  hands out separate irqs to each gpio line
	
	  This array contains information on each underlying irq, each
	  irq of the grgpio core itself.
	
	  This array contains information for each gpio line on the irqs
	  obtains from this driver. An index value of -1 for a certain gpio
	  line indicates that the line has no irq. Otherwise the index connects
	  the irq to the underlying irq by pointing into the uirqs array.
 -------------------- IRQ chip functions -------------------- 
	
	  For each gpio line, call its interrupt handler if it its underlying
	  irq matches the current irq that is handled.
  This function will be called as a consequence of the call to
  irq_create_mapping in grgpio_to_irq
 Request underlying irq if not already requested 
 Setup irq  
 Free underlying irq if last user unmapped 
 ------------------------------------------------------------ 
	
	  The irqmap contains the index values indicating which underlying irq,
	  if anyone, is connected to that line
				
				  Continue without irq functionality for that
				  gpio line
 SPDX-License-Identifier: GPL-2.0
  TI TPS6586x GPIO driver
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
  Author: Laxman dewangan <ldewangan@nvidia.com>
  Based on tps6586x.c
  Copyright (c) 2010 CompuLab Ltd.
  Mike Rapoport <mike@compulab.co.il>
 GPIO control registers 
 FIXME: add handling of GPIOs as dedicated inputs 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2020 Daniel Palmer<daniel@thingy.jp> 
  These bits need to be saved to correctly restore the
  gpio state when resuming from suspend to memory.
 pad names for fuart, same for all SoCs so far 
 pad names for sr, mercury5 is different 
 pad names for sd, same for all SoCs so far 
 pad names for i2c1, same for all SoCs so for 
 pad names for spi0, same for all SoCs so far 
  The interrupt handling happens in the parent interrupt controller,
  we don't do anything here.
  The parent interrupt controller needs the GIC interrupt type set to GIC_SPI
  so we need to provide the fwspec. Essentially gpiochip_populate_parent_fwspec_twocell
  that puts GIC_SPI into the first cell.
	
	  only the spi0 pins have interrupts on the parent
	  on all of the known chips and so far they are all
	  mapped to the same place
  The GPIO controller loses the state of the registers when the
  SoC goes into suspend to memory mode so we need to save some
  of the register bits before suspending and put it back when resuming
  Digital IO driver for Technologic Systems I2C FPGA Core
  Copyright (C) 2015 Technologic Systems
  Copyright (C) 2016 Savoir-Faire Linux
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether expressed or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License version 2 for more details.
  Register bits used by the GPIO device
  Some boards, such as TS-7970 do not have a separate input bit
	
	  This will clear the output enable bit, the other bits are
	  dontcare when this is cleared
 sentinel  },
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  gpio-max3191x.c - GPIO driver for Maxim MAX3191x industrial serializer
  Copyright (C) 2017 KUNBUS GmbH
  The MAX3191x makes 8 digital 24V inputs available via SPI.
  Multiple chips can be daisy-chained, the spec does not impose
  a limit on the number of chips and neither does this driver.
  Either of two modes is selectable: In 8-bit mode, only the state
  of the inputs is clocked out to achieve high readout speeds;
  In 16-bit mode, an additional status byte is clocked out with
  a CRC and indicator bits for undervoltage and overtemperature.
  The driver returns an error instead of potentially bogus data
  if any of these fault conditions occur.  However it does allow
  readout of non-faulting chips in the same daisy-chain.
  MAX3191x supports four debounce settings and the driver is
  capable of configuring these differently for each chip in the
  daisy-chain.
  If the chips are hardwired to 8-bit mode ("modesel" pulled high),
  gpio-pisosr.c can be used alternatively to this driver.
  https:datasheets.maximintegrated.comendsMAX31910.pdf
  https:datasheets.maximintegrated.comendsMAX31911.pdf
  https:datasheets.maximintegrated.comendsMAX31912.pdf
  https:datasheets.maximintegrated.comendsMAX31913.pdf
  https:datasheets.maximintegrated.comendsMAX31953-MAX31963.pdf
  struct max3191x_chip - max3191x daisy-chain
  @gpio: GPIO controller struct
  @lock: protects read sequences
  @nchips: number of chips in the daisy-chain
  @mode: current mode, 0 for 16-bit, 1 for 8-bit;
 	for simplicity, all chips in the daisy-chain are assumed
 	to use the same mode
  @modesel_pins: GPIO pins to configure modesel of each chip
  @fault_pins: GPIO pins to detect fault of each chip
  @db0_pins: GPIO pins to configure debounce of each chip
  @db1_pins: GPIO pins to configure debounce of each chip
  @mesg: SPI message to perform a readout
  @xfer: SPI transfer used by @mesg
  @crc_error: bitmap signaling CRC error for each chip
  @overtemp: bitmap signaling overtemperature alarm for each chip
  @undervolt1: bitmap signaling undervoltage alarm for each chip
  @undervolt2: bitmap signaling undervoltage warning for each chip
  @fault: bitmap signaling assertion of @fault_pins for each chip
  @ignore_uv: whether to ignore undervoltage alarms;
 	set by a device property if the chips are powered through
 	5VOUT instead of VCC24V, in which case they will constantly
 	signal undervoltage;
 	for simplicity, all chips in the daisy-chain are assumed
 	to be powered the same way
 (x^5) + x^4 + x^2 + x^0 
 always in 
 fault pin shared by all chips or per chip 
 without status byte the only diagnostic is the fault pin 
 all chips use the same pair of debounce pins 
 per chip debounce pins 
 SPDX-License-Identifier: GPL-2.0-only
  GPIO driver for RICOH583 power management chip.
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
  Author: Laxman dewangan <ldewangan@nvidia.com>
  Based on code
 	Copyright (C) 2011 RICOH COMPANY,LTD
 Set pin to gpio mode 
 Set pin to gpio mode 
 SPDX-License-Identifier: GPL-2.0-or-later
  GPIO driver for LPC32xx SoC
  Author: Kevin Wells <kevin.wells@nxp.com>
  Copyright (C) 2010 NXP Semiconductors
  GPIO names
	
	  P3 GPIO pin input mapping is not contiguous, GPIOP3-0..4 is mapped
	  to bits 10..14, while GPIOP3-5 is mapped to bit 24.
  GPIO primitives.
 Is this the correct bank? 
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (C) 2012 John Crispin <john@phrozen.org>
  By attaching hardware latches to the EBU it is possible to create output
  only gpios. This driver configures a special memory address, which when
  written to outputs 16 bit to the latches.
 16 bit access, slowest timing 
 write protect bit 
 shadow the latches state 
  ltq_mm_apply() - write the shadow value to the ebu address.
  @chip:     Pointer to our private data structure.
  Write the shadow value to the EBU to set the gpios. We need to set the
  global EBU lock to make sure that PCIMTD don't break.
  ltq_mm_set() - gpio_chip->set - set gpios.
  @gc:     Pointer to gpio_chip device structure.
  @gpio:   GPIO signal number.
  @val:    Value to be written to specified signal.
  Set the shadow value and call ltq_mm_apply.
  ltq_mm_dir_out() - gpio_chip->dir_out - set gpio direction.
  @gc:     Pointer to gpio_chip device structure.
  @gpio:   GPIO signal number.
  @val:    Value to be written to specified signal.
  Same as ltq_mm_set, always returns 0.
  ltq_mm_save_regs() - Set initial values of GPIO pins
  @mm_gc: pointer to memory mapped GPIO chip structure
 tell the ebu controller which memory address we will be using 
 store the shadow value if one was passed by the devicetree 
 SPDX-License-Identifier: GPL-2.0-only
  STMicroelectronics ConneXt (STA2X11) GPIO driver
  Copyright 2012 ST Microelectronics (Alessandro Rubini)
  Based on gpio-ml-ioh.c, Copyright 2010 OKI Semiconductors Ltd.
  Also based on previous sta2x11 work, Copyright 2011 Wind River Systems, Inc.
 0x00 
 0x10 
 0x20 
 0x40 
 FIXME: save the whole config here (AF, ...) 
  gpio methods
 Data register after direction, otherwise pullupdown is selected 
 called from probe 
	
	  ARCH_NR_GPIOS is currently 256 and dynamic allocation starts
	  from the end. However, for compatibility, we need the first
	  ConneXt device to start from gpio 0: it's the main chipset
	  on most boards so documents and drivers assume gpio0..gpio127
	
	  After the first device, turn to dynamic gpio numbers.
	  For example, with ARCH_NR_GPIOS = 256 we can fit two cards
  Special method: alternate functions and pulluppulldown. This is only
  invoked on startup to configure gpio's according to platform data.
  FIXME : this functionality shall be managed (and exported to other drivers)
  via the pin control subsystem.
 Alternate function or not? 
 not alternate function: set details 
  Irq methods
 We only support edge interrupts 
 used for enabledisable 
 FIXME: this makes at most 32 interrupts. Request 0 by now 
 IRQ_MSK(GSTA_GPIO_PER_BLOCK) ,
 Set up all all 128 interrupts: code from setup_generic_chip 
 The platform device used here is instantiated by the MFD device 
 disable all irqs 
 384 was used in previous code: be compatible for other drivers 
 SPDX-License-Identifier: GPL-2.0
 Driver for IDTRenesas 79RC3243x Interrupt Controller  
 hardware only supports level triggered 
 Mask interrupts. 
  Copyright (C) 2015 Texas Instruments Incorporated - http:www.ti.com
 	Andrew F. Davis <afd@ti.com>
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether expressed or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License version 2 for more details.
  struct tpic2810 - GPIO driver data
  @chip: GPIO controller chip
  @client: I2C device pointer
  @buffer: Buffer for device register
  @lock: Protects write sequences
 This device always output 
 This device is output only 
 This device always output 
 sentinel  }
 sentinel  }
  Driver for GE FPGA based GPIO
  Author: Martyn Welch <martyn.welch@ge.com>
  2008 (c) GE Intelligent Platforms Embedded Systems, Inc.
  This file is licensed under the terms of the GNU General Public License
  version 2.  This program is licensed "as is" without any warranty of any
  kind, whether express or implied.
 TODO
  Configuration of output modes (totem-poleopen-drain)
  Interrupt configuration - interrupts are always generated the FPGA relies on
  the IO interrupt controllers mask to stop them propergating
 Setup pointers to chip functions 
 This function adds a memory mapped GPIO chip 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2006 Juergen Beisert, Pengutronix
  Copyright (C) 2008 Guennadi Liakhovetski, Pengutronix
  Copyright (C) 2009 Wolfram Sang, Pengutronix
  Check max730x.c for further details.
 A write to the MAX7301 means one message with one transfer 
 A read from the MAX7301 means two transfers; here, one message each 
 bits_per_word cannot be configured in platform data 
 register after spi postcore initcall and before
  subsys initcalls that may rely on these GPIOs
 SPDX-License-Identifier: GPL-2.0
  Faraday Technolog FTGPIO010 gpiochip and interrupt routines
  Copyright (C) 2017 Linus Walleij <linus.walleij@linaro.org>
  Based on archarmmach-geminigpio.c:
  Copyright (C) 2008-2009 Paulius Zaleckas <paulius.zaleckas@teltonika.lt>
  Based on plat-mxcgpio.c:
  MXC GPIO support. (c) 2008 Daniel Mack <daniel@caiaq.de>
  Copyright 2008 Juergen Beisert, kernel@pengutronix.de
 GPIO registers definition 
  struct ftgpio_gpio - Gemini GPIO state container
  @dev: containing device for this instance
  @gc: gpiochip for this instance
  @irq: irqchip for this instance
  @base: remapped IO-memory base
  @clk: silicon clock
	
	  Debounce only works if interrupts are enabled. The manual
	  states that if PCLK is 66 MHz, and this is set to 0x7D0, then
	  PCLK is divided down to 33 kHz for the debounce timer. 0x7D0 is
	  2000 decimal, so what they mean is simply that the PCLK is
	  divided by this value.
	 
	  As we get a debounce setting in microseconds, we calculate the
	  desired period time and see if we can get a suitable debounce
	  time.
 This register is only 24 bits wide 
		
		  The debounce timer happens to already be set to the
		  desirable value, what a coincidence! We can just enable
		  debounce on this GPIO line and return. This happens more
		  often than you think, for example when all GPIO keys
		  on a system are requesting the same debounce interval.
		
		  Oh no! Someone is already using the debounce with
		  another setting than what we need. Bummer.
 First come, first serve 
 Enable debounce 
		
		  Percolate deferrals, for anything else,
		  just live without the clocking.
 ngpio is set by bgpio_init() 
 We need a silicon clock to do debounce 
 Disable, unmask and clear all interrupts 
 Clear any use of debounce 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) ST-Ericsson SA 2010
  Author: Rabin Vincent <rabin.vincent@stericsson.com> for ST-Ericsson
  These registers are modified under the irq bus lock and cached to avoid
  unnecessary writes in bus_sync_unlock.
 No variant has more than 24 GPIOs 
 Caches of interrupt control registers for bus_lock 
	
	  Some variants have single register for gpio setclear functionality.
	  For them we need to write 0 to clear and 1 to set.
 STMPE801 and STMPE 1600 don't have RE and FE registers 
	
	  STMPE1600: to be able to get IRQ from pins,
	  a read must be done on GPMR register, or a write in
	  GPSR or GPCR registers
 STMPE801 and STMPE1600 don't have RE and FE registers 
	
	  the stmpe_block_read() call below, imposes to set statmsbreg
	  with the register located at the lowest address. As STMPE1600
	  variant is the only one which respect registers address's order
	  (LSB regs located at lowest address than MSB ones) whereas all
	  the others have a registers layout with MSB located before the
	  LSB regs.
		
		  interrupt status register write has no effect on
		  80118011600, bits are cleared when read.
		  Edge detect register is not present on 80116001801
 Forbid unused lines to be mapped as IRQs 
 This will let us handle the parent IRQ in the driver 
 SPDX-License-Identifier: GPL-2.0-only
 Abilis Systems MODULE DESCRIPTION
  Copyright (C) Abilis Systems 2013
  Authors: Sascha Leuenberger <sascha.leuenberger@abilis.com>
           Christian Ruppert <christian.ruppert@abilis.com>
  @base: register base address
  @domain: IRQ domain of GPIO generated interrupts managed by this controller
  @irq: Interrupt line of parent interrupt controller
  @gc: gpio_chip structure associated to this GPIO controller
	
	  Initialize generic GPIO with one single register for reading and setting
	  the lines, no special set or clear registers and a data direction register
	  wher 1 means "output".
	
	  ngpio is set by bgpio_init() but we override it, this .request()
	  callback also overrides the one set up by generic GPIO.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 Spreadtrum Communications Inc.
  Copyright (C) 2018 Linaro Ltd.
 EIC registers definition 
  The digital-chip EIC controller can support maximum 3 banks, and each bank
  contains 8 EICs.
  The Spreadtrum EIC (external interrupt controller) can be used only in
  input mode to generate interrupts if detecting input signals.
  The Spreadtrum digital-chip EIC controller contains 4 sub-modules:
  debounce EIC, latch EIC, async EIC and sync EIC,
  The debounce EIC is used to capture the input signals' stable status
  (millisecond resolution) and a single-trigger mechanism is introduced
  into this sub-module to enhance the input event detection reliability.
  The debounce range is from 1ms to 4s with a step size of 1ms.
  The latch EIC is used to latch some special power down signals and
  generate interrupts, since the latch EIC does not depend on the APB clock
  to capture signals.
  The async EIC uses a 32k clock to capture the short signals (microsecond
  resolution) to generate interrupts by level or edge trigger.
  The EIC-sync is similar with GPIO's input function, which is a synchronized
  signal input register.
 EICs are always input, nothing need to do here. 
 EICs are always input, nothing need to do here. 
	
	  The debounce EIC and latch EIC can only support level trigger, so we
	  can toggle the level trigger to emulate the edge trigger.
	
	  Since the digital-chip EIC 4 sub-modules (debounce, latch, async
	  and sync) share one same interrupt line, we should iterate each
	  EIC module to check if there are EIC interrupts were triggered.
		
		  We can have maximum 3 banks EICs, and each EIC has
		  its own base address. But some platform maybe only
		  have one bank EIC, thus base[1] and base[2] can be
		  optional.
 end of list 
 SPDX-License-Identifier: GPL-2.0-only
  Emma Mobile GPIO Support - GIO
   Copyright (C) 2012 Magnus Damm
 8 x 4 bit fields in 4 IDT registers 
 disable the interrupt in IIA 
 change the sense setting in IDT 
 clear pending interrupts 
 enable the interrupt in IIA 
 upper 16 bits contains mask and lower 16 actual value 
 output is split into two registers 
 write GPIO value to output before selecting output mode of pin 
	 Set the GPIO as an input to ensure that the next GPIO request won't
	 drive the GPIO pin as an output.
 SPDX-License-Identifier: GPL-2.0-or-later
  Driver for pcf857x, pca857x, and pca967x I2C GPIO expanders
  Copyright (C) 2007 David Brownell
  The pcf857x, pca857x, and pca967x chips only expose one read and one
  write register.  Writing a "one" bit (to match the reset state) lets
  that pin be used as an input; it's not an open-drain model, but acts
  a bit like one.  This is described as "quasi-bidirectional"; read the
  chip documentation for details.
  Many other I2C GPIO expander chips (like the pca953x models) have
  more complex register models and more conventional circuitry using
  pushpull drivers.  They often use the same 0x20..0x27 addresses as
  pcf857x parts, making the "legacy" I2C driver model problematic.
 protect 'out' 
 software latch 
 current status 
 enabled irqs 
-------------------------------------------------------------------------
 Talk to 8-bit IO expander 
 Talk to 16-bit IO expander 
-------------------------------------------------------------------------
-------------------------------------------------------------------------
	
	  call the interrupt handler iff gpio is used as
	  interrupt source, just to avoid bad irqs
  NOP functions
-------------------------------------------------------------------------
 Allocate, initialize, and register this gpio_chip. 
	 NOTE:  the OnSemi jlc1562b is also largely compatible with
	  these parts, notably for output.  It has a low-resolution
	  DAC instead of pin change IRQs; and its inputs can be the
	  result of comparators.
	 8574 addresses are 0x20..0x27; 8574a uses 0x38..0x3f;
	  9670, 9672, 9764, and 9764a use quite a variety.
	 
	  NOTE: we don't distinguish here between 4 and 4a parts.
 fail if there's no chip present 
	 '75'75c addresses are 0x20..0x27, just like the '74;
	  the '75c doesn't have a current source pulling high.
	  9671, 9673, and 9765 use quite a variety of addresses.
	 
	  NOTE: we don't distinguish here between '75 and '75c parts.
 fail if there's no chip present 
	 NOTE:  these chips have strange "quasi-bidirectional" IO pins.
	  We can't actually know whether a pin is configured (a) as output
	  and driving the signal low, or (b) as input and reporting a low
	  value ... without knowing the last value written since the chip
	  came out of reset (if any).  We can't read the latched output.
	 
	  In short, the only reliable solution for setting up pin direction
	  is to do it explicitly.  The setup() method can do that, but it
	  may cause transient glitching since it can't know the last value
	  written (some pins may need to be driven low).
	 
	  Using n_latch avoids that trouble.  When left initialized to zero,
	  our software copy of the "latch" then matches the chip's all-ones
	  reset state.  Otherwise it flags pins to be driven low.
 Enable irqchip if we have an interrupt 
 This will let us handle the parent IRQ in the driver 
	 Let platform code set up the GPIOs and their users.
	  Now is the first time anyone could use them.
 Drive all the IO lines high 
 register after i2c postcore initcall and before
  subsys initcalls that may rely on these GPIOs
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2009 Wolfram Sang, Pengutronix
  Check max730x.c for further details.
 SPDX-License-Identifier: GPL-2.0
  Intel Whiskey Cove PMIC GPIO Driver
  This driver is written based on gpio-crystalcove.c
  Copyright (C) 2016 Intel Corporation. All rights reserved.
  Whiskey Cove PMIC has 13 physical GPIO pins divided into 3 banks:
  Bank 0: Pin  0 - 6
  Bank 1: Pin  7 - 10
  Bank 2: Pin 11 - 12
  Each pin has one output control register and one input control register.
 GPIO output control registers (one per pin): 0x4e44 - 0x4e50 
 GPIO input control registers (one per pin): 0x4e51 - 0x4e5d 
  GPIO interrupts are organized in two groups:
  Group 0: Bank 0 pins (Pin 0 - 6)
  Group 1: Bank 1 and Bank 2 pins (Pin 7 - 12)
  Each group has two registers (one bit per pin): status and mask.
  struct wcove_gpio - Whiskey Cove GPIO controller
  @buslock: for bus locksync and unlock.
  @chip: the abstract gpio_chip structure.
  @dev: the gpio device
  @regmap: the regmap from the parent device.
  @regmap_irq_chip: the regmap of the gpio irq chip.
  @update: pending IRQ setting update, to be written to the chip upon unlock.
  @intcnt: the Interrupt Detect value to be written.
  @set_irq_mask: true if the IRQ mask needs to be set, false to clear.
 Iterate until no interrupt is pending 
 One iteration is for all pending bits 
 Next iteration 
	
	  This gpio platform device is created by a mfd device (see
	  driversmfdintel_soc_pmic_bxtwc.c for details). Information
	  shared by all sub-devices created by the mfd device, the regmap
	  pointer for instance, is stored as driver data of the mfd device
	  driver.
 This will let us handle the parent IRQ in the driver 
 Enable GPIO0 interrupts 
 Enable GPIO1 interrupts 
  Whiskey Cove PMIC itself is a analog device(but with digital control
  interface) providing power management support for other devices in
  the accompanied SoC, so we have no .pm for Whiskey Cove GPIO driver.
 SPDX-License-Identifier: GPL-2.0
  Intel Crystal Cove GPIO Driver
  Copyright (C) 2012, 2014 Intel Corporation. All rights reserved.
  Author: Yang, Bin <bin.yang@intel.com>
  struct crystalcove_gpio - Crystal Cove GPIO controller
  @buslock: for bus locksync and unlock.
  @chip: the abstract gpio_chip structure.
  @regmap: the regmap from the parent device.
  @update: pending IRQ setting update, to be written to the chip upon unlock.
  @intcnt_value: the Interrupt Detect value to be written.
  @set_irq_mask: true if the IRQ mask needs to be set, false to clear.
 irq_bus_lock 
		
		  Virtual GPIO called from ACPI, for now we only support
		  the panel ctl.
 This will let us handle the parent IRQ in the driver 
 SPDX-License-Identifier: GPL-2.0-or-later
  Janz MODULbus VMOD-TTL GPIO Driver
  Copyright (c) 2010 Ira W. Snyder <iws@ovro.caltech.edu>
 base address of registers 
 reset the device to a known state 
 put all ports in open-drain mode 
 set all ports as outputs 
 set all ports to drive zeroes 
 enable all ports 
 get access to the MODULbus registers for this module 
 Initialize the GPIO data structures 
 request dynamic allocation 
 SPDX-License-Identifier: GPL-2.0+
  Access to GPOs on TWL6040 chip
  Copyright (C) 2012 Texas Instruments, Inc.
  Authors:
 	Sergio Aguirre <saaguirre@ti.com>
 	Peter Ujfalusi <peter.ujfalusi@ti.com>
 This only drives GPOs, and can't change direction 
----------------------------------------------------------------------
 twl6040 have 3 GPO 
 twl6041 have 1 GPO 
 Note:  this hardware lives inside an I2C-based multi-function device. 
 SPDX-License-Identifier: GPL-2.0-or-later
   CLPS711X GPIO driver
   Copyright (C) 2012,2013 Alexander Shiyan <shc_work@mail.ru>
 PORTD is inverted logic for direction register 
 PORTE is 3 lines only 
 SPDX-License-Identifier: GPL-2.0+
  GPIO driver for virtio-based virtual GPIO controllers
  Copyright (C) 2021 metux IT consult
  Enrico Weigelt, metux IT consult <info@metux.net>
  Copyright (C) 2021 Linaro.
  Viresh Kumar <viresh.kumar@linaro.org>
 Protects line operation 
 Protects virtqueue operation 
 irq support 
 Protects irq operation 
 Protects queuing of the buffer 
	
	  Prevent concurrent requests for the same line since we have
	  pre-allocated requestresponse buffers for each GPIO line. Moreover
	  Linux always accesses a GPIO line sequentially, so this locking shall
	  always go through without any delays.
	
	  Virtqueue callers need to ensure they don't call its APIs with other
	  virtqueue operations at the same time.
 Interrupt handling 
 Queue the buffer unconditionally on unmask 
 Queue the buffer only after interrupt is enabled 
 These are required to implement irqchip for slow busses 
 Interrupt is disabled currently 
	
	  Buffer is returned as the interrupt was disabled earlier, but is
	  enabled again now. Requeue the buffers.
		
		  Find GPIO line number from the offset of irq_line within the
		  irq_lines block. We can also get GPIO number from
		  irq-request, but better not to rely on a buffer returned by
		  remote.
 NULL terminate the string instead of checking it 
 zero-length strings are allowed 
 Read configuration 
 Allocate base dynamically 
 Interrupt support 
 The event comes from the outside so no parent handler 
 Mark the device ready to perform operations from within probe() 
 SPDX-License-Identifier: GPL-2.0-only
  TI Palma series PMIC's GPIO driver.
  Copyright (c) 2012, NVIDIA CORPORATION.  All rights reserved.
  Author: Laxman Dewangan <ldewangan@nvidia.com>
 Set the initial value 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2016-2017 NVIDIA Corporation
  Author: Thierry Reding <treding@nvidia.com>
 security registers 
 control registers 
 configure output level first 
 set the direction 
	
	  The Tegra186 GPIO controller supports a maximum of 255 ms debounce
	  time.
 skip ports that are not associated with this bank 
 sentinel  }
		
		  For controllers that haven't been locked down yet, make
		  sure to program the default interrupt route mapping.
			
			  On Tegra194 and later, each pin can be routed to one or more
			  interrupts.
				
				  By default we only want to route GPIO pins to IRQ 0. This works
				  only under the assumption that we're running as the host kernel
				  and hence all GPIO pins are owned by Linux.
				 
				  For cases where Linux is the guest OS, the hypervisor will have
				  to configure the interrupt routing and pass only the valid
				  interrupts via device tree.
 count the number of banks in the controller 
 get register apertures 
 CONFIG_OF_GPIO 
	
	  To simplify things, use a single interrupt per bank for now. Some
	  chips support up to 8 interrupts per bank, which can be useful to
	  distribute the load and decrease the processing latency for GPIOs
	  but it also requires a more complicated interrupt routing than we
	  currently program.
 sentinel 
 SPDX-License-Identifier: GPL-2.0-or-later
  GPIO Testing Device Driver
  Copyright (C) 2014  Kamlakant Patel <kamlakant.patel@broadcom.com>
  Copyright (C) 2015-2016  Bamvor Jian Zhang <bamv2005@gmail.com>
  Copyright (C) 2017 Bartosz Golaszewski <brgl@bgdev.pl>
  We're storing two values per chip: the GPIO base and the number
  of GPIO lines.
 Maximum of four properties + the sentinel. 
  struct gpio_pin_status - structure describing a GPIO status
  @dir:       Configures direction of gpio as "in" or "out"
  @value:     Configures status of the gpio as 0(low) or 1(high)
			
			  This is fine - it just means, nobody is listening
			  for interrupts on this line, otherwise
			  irq_create_mapping() would have been called from
			  the to_irq() callback.
 Change the value unless we're actively driving the line. 
  Each mockup chip is represented by a directory named after the chip's device
  name under syskerneldebuggpio-mockup. Each line is represented by
  a file using the line's offset as the name under the chip's directory.
  Reading from the line's file yields the current value, writing to the
  line's file changes the current pull. Default pull for mockup lines is
  down.
  Examples:
  - when a line pulled down is requested in output mode and driven high, its
    value will return to 0 once it's released
  - when the line is requested in output mode and driven high, writing 0 to
    the corresponding debugfs file will change the pull to down but the
    reported value will still be 1 until the line is released
  - line requested in input mode always reports the same value as its pull
    configuration
  - when the line is requested in input mode and monitored for events, writing
    the same value to the debugfs file will be a noop, while writing the
    opposite value will generate a dummy interrupt with an appropriate edge
 Each chip is described by two values. 
	
	  The second value in the <base GPIO - number of GPIOS> pair must
	  always be greater than 0.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2013 MundoReader S.L.
  Author: Heiko Stuebner <heiko@sntech.de>
  Copyright (c) 2021 Rockchip Electronics Co. Ltd.
 GPIO Version ID reserved 
 GPIO Version ID 0x01000C2B 
 Only the v1 needs to configure div_en and div_con for dbclk 
 Configure the max debounce from consumers 
 Enable or disable dbclk at last 
  gpiolib set_config callback function. The setting of the pin
  mux function as 'gpio output' will be handled by the pinctrl subsystem
  interface.
		
		  Rockchip's gpio could only support up to one period
		  of the debounce clock(pclk), which is far away from
		  satisftying the requirement, as pclk is usually near
		  100MHz shared by all peripherals. So the fact is it
		  has crippled debounce capability could only be useful
		  to prevent any spurious glitches from waking up the system
		  if the gpio is conguired as wakeup interrupt source. Let's
		  still return -ENOTSUPP as before, to make sure the caller
		  of gpiod_set_debounce won't change its behaviour.
  gpiolib gpio_to_irq callback function. Creates a mapping between a GPIO pin
  and a virtual IRQ, if not already present.
		
		  Triggering IRQ on both rising and falling edge
		  needs manual intervention.
			
			  Determine gpio state. If 1 next interrupt should be
			  falling otherwise rising.
	
	  Linux assumes that all interrupts start out disabledmasked.
	  Our driver only uses the concept of masked and always keeps
	  things enabled, so for us that's all masked and all enabled.
	
	  For DeviceTree-supported systems, the gpio core checks the
	  pinctrl's device node for the "gpio-ranges" property.
	  If it is present, it takes care of adding the pin ranges
	  for the driver. In this case the driver can skip ahead.
	 
	  In order to remain compatible with older, existing DeviceTree
	  files which don't set the "gpio-ranges" property or systems that
	  utilize ACPI the driver has to call gpiochip_add_pin_range().
 If not gpio v2, that is default to v1. 
	
	  Prevent clashes with a deferred output setting
	  being added right at this moment.
 SPDX-License-Identifier: GPL-2.0+
  Generic driver for memory-mapped GPIO controllers.
  Copyright 2008 MontaVista Software, Inc.
  Copyright 2008,2010 Anton Vorontsov <cbouatmailru@gmail.com>
  ....``.```~~~~````.`.`.`.`.```````'',,,.........`````......`.......
  ...``                                                         ```````..
  ..The simplest form of a GPIO controller that the driver supports is``
   `.just a single "data" register, where GPIO state can be read andor `
     `,..written. ,,..``~~~~ .....``.`.`.~~.```.`.........``````.```````
         `````````
                                    ___
_~~|___~|   . ```~~~~~~       ______\___     ,~.`.`.`.`````.~~...,,,,...
__________|~$@~~~        %~    oooooo\   .. Implementing such a GPIO .
o        `                     ~~~~\___~~~~    ` controller in FPGA is ,.`
                                                 `....trivial..'~`.```.```
                                                     ```````
   .```````~~~~`..`.``.``.
  .  The driver supports  `...       ,..```.`~~~```````````````....````.``,,
  .   big-endian notation, just`.  .. A bit more sophisticated controllers ,
   . register the device with -be`. .with a pair of setclear-bit registers ,
    `.. suffix.  ```~~`````....`.`   . affecting the data register and the .`
      ``.`.``...```                  ```.. output pins are also supported.`
                         ^^             `````.`````````.,``~``~``~~``````
                                                    .                  ^^
    ,..`.`.`...````````````......`.`.`.`.`.`..`.`.`..
  .. The expectation is that in at least some cases .    ,-~~~-,
   .this will be used with roll-your-own ASICFPGA .`     \   
   .logic in Verilog or VHDL. ~~~`````````..`````~~`       \ 
   ..````````......```````````                             \o_
                                                            |
                               ^^                           \
            ...`````~~`.....``.`..........``````.`.``.```........``.
             `  8, 16, 32 and 64 bits registers are supported, and``.
             . the number of GPIOs is determined by the width of   ~
              .. the registers. ,............```.`.`..`.`.~~~.`.`.`~
                `.......````.```
 BITS_PER_LONG >= 64 
  This assumes that the bits in the GPIO register are in native endianness.
  We only assign the function pointer if we have that.
 Make sure we first clear any bits that are zero when we read the register 
  This only works if the bits in the GPIO register are in native endianness.
 Make sure we first clear any bits that are zero when we read the register 
  With big endian mirrored bit order it becomes more tedious.
 Make sure we first clear any bits that are zero when we read the register 
 Create a mirrored mask 
 Read the register 
	
	  Mirror the result into the "bits" result, this will give line 0
	  in bit 0 ... line 31 in bit 31 for a 32bit register.
 Return 0 if output, 1 if input 
 BITS_PER_LONG >= 64 
  Create the device and allocate the resources.  For setting GPIO's there are
  three supported configurations:
 	- single inputoutput register resource (named "dat").
 	- setclear pair (named "set" and "clr").
 	- single output register resource and single input resource ("set" and
 	dat").
  For the single output register, this drives a 1 by setting a bit and a zero
  by clearing a bit.  For the set clr pair, this drives a 1 by setting a bit
  in the set register and clears it by setting a bit in the clear register.
  The configuration is detected by which resources are present.
  For setting the GPIO direction, there are three supported configurations:
 	- simple bidirection GPIO that requires no configuration.
 	- an output direction register (named "dirout") where a 1 bit
 	indicates the GPIO is an output.
 	- an input direction register (named "dirin") where a 1 bit indicates
 	the GPIO is an input.
		
		  We deliberately avoid assigning the ->get_multiple() call
		  for big endian mirrored registers which are ALSO reflecting
		  their value in the set register when used as output. It is
		  simply too much complexity, let the GPIO core fall back to
		  reading each line individually in that fringe case.
  bgpio_init() - Initialize generic GPIO accessor functions
  @gc: the GPIO chip to set up
  @dev: the parent device of the new GPIO chip (compulsory)
  @sz: the size (width) of the MMIO registers in bytes, typically 1, 2 or 4
  @dat: MMIO address for the register to READ the value of the GPIO lines, it
 	is expected that a 1 in the corresponding bit in this register means the
 	line is asserted
  @set: MMIO address for the register to SET the value of the GPIO lines, it is
 	expected that we write the line with 1 in this register to drive the GPIO line
 	high.
  @clr: MMIO address for the register to CLEAR the value of the GPIO lines, it is
 	expected that we write the line with 1 in this register to drive the GPIO line
 	low. It is allowed to leave this address as NULL, in that case the SET register
 	will be assumed to also clear the GPIO lines, by actively writing the line
 	with 0.
  @dirout: MMIO address for the register to set the line as OUTPUT. It is assumed
 	that setting a line to 1 in this register will turn that line into an
 	output line. Conversely, setting the line to 0 will turn that line into
 	an input.
  @dirin: MMIO address for the register to set this line as INPUT. It is assumed
 	that setting a line to 1 in this register will turn that line into an
 	input line. Conversely, setting the line to 0 will turn that line into
 	an output.
  @flags: Different flags that will affect the behaviour of the device, such as
 	endianness etc.
	
	  Inspect hardware to find initial direction setting.
		
		  If we have two direction registers, synchronise
		  input setting to output setting, the library
		  can not handle a line being input and output at
		  the same time.
 CONFIG_OF 
 CONFIG_GPIO_GENERIC_PLATFORM 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020-2021 NVIDIA CORPORATION & AFFILIATES
  There are 3 YU GPIO blocks:
  gpio[0]: HOST_GPIO0->HOST_GPIO31
  gpio[1]: HOST_GPIO32->HOST_GPIO63
  gpio[2]: HOST_GPIO64->HOST_GPIO69
  arm_gpio_lock register:
  bit[31]	lock status: active if set
  bit[15:0]	set lock
  The lock is enabled only if 0xd42f is written to this field
  gpio[x] block registers and their offset
 BlueField-2 gpio block context structure. 
 YU GPIO blocks address 
 BlueField-2 gpio shared structure. 
 Request memory region and map yu_arm_gpio_lock resource 
 Check if the memory map already exists 
  Acquire the YU arm_gpio_lock to be able to change the direction
  mode. If the lock_active bit is already set, return an error.
	
	  When lock active bit[31] is set, ModeX is write enabled
  Release the YU arm_gpio_lock after changing the direction mode.
  mode0 and mode1 are both locked by the gpio_lock field.
  Together, mode0 and mode1 define the gpio Mode dependeing also
  on Reg_DataOut.
  {mode1,mode0}:{Reg_DataOut=0,Reg_DataOut=1}->{DataOut=0,DataOut=1}
  {0,0}:Reg_DataOut{0,1}->{Z,Z} Input PAD
  {0,1}:Reg_DataOut{0,1}->{0,1} Full drive Output PAD
  {1,0}:Reg_DataOut{0,1}->{0,Z} 0-set PAD to low, 1-float
  {1,1}:Reg_DataOut{0,1}->{Z,1} 0-float, 1-set PAD to high
  Set input direction:
  {mode1,mode0} = {0,0}
	
	  Although the arm_gpio_lock was set in the probe function, check again
	  if it is still enabled to be able to write to the ModeX registers.
  Set output direction:
  {mode1,mode0} = {0,1}
	
	  Although the arm_gpio_lock was set in the probe function,
	  check again it is still enabled to be able to write to the
	  ModeX registers.
 BlueField-2 GPIO driver initialization routine. 
 YU GPIO block address 
 This will let us handle the parent IRQ in the driver 
		
		  Directly request the irq here instead of passing
		  a flow-handler because the irq is shared.
 SPDX-License-Identifier: GPL-2.0-only
  GPIO driver for the Diamond Systems GPIO-MM
  Copyright (C) 2016 William Breathitt Gray
  This driver supports the following Diamond Systems devices: GPIO-MM and
  GPIO-MM-12.
  struct gpiomm_gpio - GPIO device private data structure
  @chip:	instance of the gpio_chip
  @io_state:	bit IO state (whether bit is set to input or output)
  @out_state:	output bits state
  @control:	Control registers state
  @lock:	synchronization lock to prevent IO race conditions
  @base:	base port address of the GPIO device
 Check if configuring Port C 
 Port C can be configured by nibble 
 Check if configuring Port C 
 Port C can be configured by nibble 
 ensure that GPIO is set for input 
 clear bits array to a clean slate 
 update output state data and set device gpio register 
 initialize all GPIO as output 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2011-2012 Avionic Design GmbH
 determine pins that changed levels 
 compute edge-triggered interrupts 
 add in level-triggered interrupts 
 mask out non-pending and disabled interrupts 
	
	  Allocate memory to keep track of the current level and trigger
	  modes of the interrupts. To avoid multiple allocations, a single
	  large buffer is allocated and pointers are setup to point at the
	  corresponding offsets. For consistency, the layout of the buffer
	  is chosen to match the register layout of the hardware in that
	  each segment contains the corresponding bits for all interrupts.
		
		  Read the initial level of all pins to allow the emulation
		  of edge triggered interrupts.
 disable all interrupts 
 This will let us handle the parent IRQ in the driver 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2013 Altera Corporation
  Based on gpio-mpc8xxx.c
 For of_mm_gpio_chip 
 struct altera_gpio_chip
 @mmchip		: memory mapped chip structure.
 @gpio_lock		: synchronization lock so that new irqsetget requests
			  will be blocked until the current one completes.
 @interrupt_trigger	: specifies the hardware configured IRQ trigger type
			  (rising, falling, both, high)
 @mapped_irq		: kernel mapped irq number.
 @irq_chip		: IRQ chip configuration
 Set ALTERA_GPIO_IRQ_MASK bit to unmask 
 Clear ALTERA_GPIO_IRQ_MASK bit to mask 
  This controller's IRQ type is synthesized in hardware, so this function
  just checks if the requested set_type matches the synthesized IRQ type
 Set pin as input, assumes software controlled IP 
 Sets the GPIO value 
 Set pin as output, assumes software controlled IP 
 By default assume maximum ngpio 
 SPDX-License-Identifier: GPL-2.0+
  Copyright (C) 2019 Bootlin
  Author: Paul Kocialkowski <paul.kocialkowski@bootlin.com>
 To the (virtual) power ctrl offset. 
 To the actual bit offset in reg. 
 To the actual bit offset in reg. 
 Pins are always configured as output, so just set the value. 
 Try to get regmap from parent first. 
 Grab our own regmap if that fails. 
 SPDX-License-Identifier: GPL-2.0-only
   PCA953x 48162440 bit IO ports
   Copyright (C) 2005 Ben Gardner <bgardner@wabtec.com>
   Copyright (C) 2007 Marvell International Ltd.
   Derived from driversi2cchipspca9539.c
		
		  On Intel Galileo Gen 2 board the IRQ pin of one of
		  the IC GPIO expanders, which has GpioInt() resource,
		  is provided as an absolute number instead of being
		  relative. Since first controller (gpio-sch.c) and
		  second (gpio-dwapb.c) are at the fixed bases, we may
		  safely refer to the number in the global space to get
		  an IRQ out of it.
  We care about the following registers:
  - Standard set, below 0x40, each port can be replicated up to 8 times
    - PCA953x standard
      Input port			0x00 + 0  bank_size	R
      Output port			0x00 + 1  bank_size	RW
      Polarity Inversion port		0x00 + 2  bank_size	RW
      Configuration port		0x00 + 3  bank_size	RW
    - PCA957x with mixed up registers
      Input port			0x00 + 0  bank_size	R
      Polarity Inversion port		0x00 + 1  bank_size	RW
      Bus hold port			0x00 + 2  bank_size	RW
      Configuration port		0x00 + 4  bank_size	RW
      Output port			0x00 + 5  bank_size	RW
  - Extended set, above 0x40, often chip specific.
    - PCAL6524PCAL9555A with custom PCAL IRQ handling:
      Input latch register		0x40 + 2  bank_size	RW
      Pull-uppull-down enable reg	0x40 + 3  bank_size    RW
      Pull-uppull-down select reg	0x40 + 4  bank_size    RW
      Interrupt mask register		0x40 + 5  bank_size	RW
      Interrupt status register	0x40 + 6  bank_size	R
  - Registers with bit 0x80 set, the AI bit
    The bit is cleared and the registers fall into one of the
    categories above.
 Special PCAL extended register check. 
 Register is not in the matching bank. 
 Register is not within allowed range of bank. 
 set output level 
 then direction 
	
	  pull-uppull-down configuration requires PCAL extended
	  registers
 Configure pull-uppull-down 
 DisableEnable pull-uppull-down 
 Enable latch on interrupt-enabled inputs 
 Unmask enabled interrupts 
 Switch direction to input if needed 
 Look for any newly setup interrupt 
 Read the current interrupt status from the device 
 Check latched inputs and clear interrupt status 
 Apply filter for risingfalling edge selection 
 Remove output pins from the equation 
	
	  There is no way to know which GPIO line generated the
	  interrupt.  We have to rely on the previous read for
	  this purpose.
 This will let us handle the parent IRQ in the driver 
 FIXME: get rid of this 
 CONFIG_GPIO_PCA953X_IRQ 
 set platform specific polarity inversion 
 To enable register 6, 7 to control pull up and pull down 
		
		  See if we need to de-assert a reset pin.
		 
		  There is no known ACPI-enabled platforms that are
		  using "reset" GPIO. Otherwise any of those platform
		  must use _DSD method with corresponding property.
	
	  In case we have an i2c-mux controlled by a GPIO provided by an
	  expander using the same driver higher on the device tree, read the
	  i2c adapter nesting depth and use the retrieved value as lockdep
	  subclass for chip->i2c_lock.
	 
	  REVISIT: This solution is not complete. It protects us from lockdep
	  false positives when the expander controlling the i2c-mux is on
	  a different level on the device tree, but not when it's on the same
	  level on a different branch (in which case the subclass number
	  would be the same).
	 
	  TODO: Once a correct solution is developed, a similar fix should be
	  applied to all other i2c-controlled GPIO expanders (and potentially
	  regmap-i2c).
	 initialize cached registers from their original values.
	  we can't share this chip with another i2c master.
	
	  The ordering between direction and output is important,
	  sync these registers first and only then sync the rest.
 convenience to stop overlong match-table lines 
 register after i2c postcore initcall and before
  subsys initcalls that may rely on these GPIOs
 SPDX-License-Identifier: GPL-2.0+
  Intel ICH6-10, Series 5 and 6, Atom C2000 (AvotonRangeley) GPIO driver
  Copyright (C) 2010 Extreme Engineering Solutions.
  GPIO register offsets in GPIO IO space.
  Each chunk of 32 GPIOs is manipulated via its own USE_SELx, IO_SELx, and
  LVLx registers.  Logic in the readwrite functions takes a register and
  an absolute bit number and determines the proper register offset and bit
  number in that register.  For example, to read the value of GPIO bit 50
  the code would access offset ichx_regs[2(=GPIO_LVL)][1(=5032)],
  bit 18 (50%32).
 USE_SEL[1-3] offsets 
 IO_SEL[1-3] offsets 
 LVL[1-3] offsets 
 BLINK offset 
 Max GPIO pins the chipset can have 
 chipset registers 
 GPO_BLINK is available on this chipset 
 Whether the chipset has GPIO in GPE0_STS in the PM IO region 
 USE_SEL is bogus on some chipsets, eg 3100 
 Some chipsets have quirks, let these use their own requestget 
	
	  Some chipsets don't let reading output values on GPIO_LVL register
	  this option allows driver caching written output values
 GPIO IO base 
 Power Management IO base 
 Pointer to chipset-specific description 
 Orig CTRL value, used to restore on exit 
 Which GPIO groups are usable 
 cached output values 
 dynamic 
	
	  Try setting pin as an input and verify it worked since many pins
	  are output-only.
 Disable blink hardware which is available for GPIOs from 0 to 31. 
 Set GPIO output value. 
	
	  Try setting pin as an output and verify it worked since many pins
	  are input-only.
	
	  GPI 0 - 15 need to be read from the power management registers on
	  a ICH63100 bridge.
 GPI 0 - 15 are latched, write 1 to clear
	
	  Note we assume the BIOS properly set a bridge's USE value.  Some
	  chips (eg Intel 3100) have bogus USE values though, so first see if
	  the chipset's USE value can be trusted for this specific bit.
	  If it can't be trusted, assume that the pin can be used as a GPIO.
	
	  Fixups for bits 16 and 17 are necessary on the Intel ICH63100
	  bridge as they are controlled by USE register bits 0 and 1.  See
	  "Table 704 GPIO_USE_SEL1 register" in the i3100 datasheet for
	  additional info.
 Allow chip-specific overrides of request()get() 
 ICH6-based, 631xesb-based 
 Bridges using the ICH6 controller need fixups for GPIO 0 - 17 
 GPIO 0-15 are read in the GPE0_STS PM register 
 Intel 3100 
	
	  Bits 16,17, 20 of USE_SEL and bit 16 of USE_SEL2 always read 0 on
	  the Intel 3100.  See "Table 712. GPIO Summary Table" of 3100
	  Datasheet for more info.
 The 3100 needs fixups for GPIO 0 - 17 
 GPIO 0-15 are read in the GPE0_STS PM register 
 ICH7 and ICH8-based 
 ICH9-based 
 ICH10-based - Consumercorporate versions have different amount of GPIO 
 Intel 5 series, 6 series, 3400 series, and C200 series 
 Avoton 
	 Avoton has only 59 GPIOs, but we assume the first set of register
	  (Core) has 32 instead of 31 to keep gpio-ich compliance
	
	  If necessary, determine the IO address of ACPIpower management
	  registers which are needed to read the GPE0 register for GPI pins
	  0 - 15 on some chipsets.
 SPDX-License-Identifier: GPL-2.0
  GPIO driver for TI TPS65912x PMICs
  Copyright (C) 2015 Texas Instruments Incorporated - http:www.ti.com
 	Andrew F. Davis <afd@ti.com>
  Based on the Arizona GPIO driver and the previous TPS65912 driver by
  Margarita Olaya Cabrera <magi@slimlogic.co.uk>
 Set the initial value 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0+
  GPIO driver for the AMD G series FCH (eg. GX-412TC)
  Copyright (C) 2018 metux IT consult
  Author: Enrico Weigelt, metux IT consult <info@metux.net>
 SPDX-License-Identifier: GPL-2.0
  Generic EP93xx GPIO handling
  Copyright (c) 2008 Ryan Mallon
  Copyright (c) 2011 H Hartley Sweeten <hsweeten@visionengravers.com>
  Based on code originally from:
   linuxarcharmmach-ep93xxcore.c
 Maximum value for gpio line identifiers 
 Number of GPIO chips in EP93XX 
 Maximum value for irq capable line identifiers 
  Static mapping of GPIO bank F IRQS:
  F0..F7 (16..24) to irq 80..87.
  Interrupt handling for EP93xx on-chip GPIOs
	
	  Dispatch the IRQs to the irqdomain of each A and B
	  gpiochip irqdomains depending on what has fired.
	  The tricky part is that the IRQ line is shared
	  between bank A and B and each has their own gpiochip.
	
	  map discontiguous hw irq range to continuous sw irq range:
	 
	   IRQ_EP93XX_GPIO{0..7}MUX -> EP93XX_GPIO_LINE_F{0..7}
 {19..22,47..50} -> {0..7} 
 switch edge direction 
 switch edge direction 
  gpio_int_type1 controls whether the interrupt is level (0) or
  edge (1) triggered, while gpio_int_type2 controls whether it
  triggers on lowfalling (0) or highrising (1).
 set initial polarity based on current input level 
 falling 
 rising 
  gpiolib interface for EP93xx on-chip GPIOs
 Bank A has 8 IRQs 
 Bank B has 8 IRQs 
 Bank F has 8 IRQs 
 Only bank F has especially funky IRQ handling 
		
		  FIXME: convert this to use hierarchical IRQ support!
		  this requires fixing the root irqchip to be hierarchical.
 Pick resources 1..8 for these IRQs 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015 Verifone Int.
  Author: Nicolas Saenz Julienne <nicolassaenzj@gmail.com>
  This driver is based on the gpio-tps65912 implementation.
 Only drives GPOs 
 Disable sequencer for GPO1 
 Setup GPO1 
 Setup GPO2 
 Disable sequencer for GPO3 
 Setup GPO3 
 GPO1 is hardwired to be open drain 
 GPO2 is push-pull by default, can be set as open drain. 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0+
 Synopsys CREG (Control REGisters) GPIO driver
 Copyright (C) 2018 Synopsys
 Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
 Check that on value fits its placeholder 
 Check that off value fits its placeholder 
 Check that we fit in 32 bit register 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  archarmmach-tegragpio.c
  Copyright (c) 2010 Google, Inc
  Copyright (c) 2011-2016, NVIDIA CORPORATION.  All rights reserved.
  Author:
 	Erik Gilling <konkers@google.com>
	
	  IRQ-core code uses raw locking, and thus, nested locking also
	  should be raw in order not to trip spinlock debug warnings.
 Lock for updating debounce count register 
 If gpio is in output mode then read from the out value 
	 There is only one debounce count register per port and hence
	  set the maximum of current and requested debounce time.
			 if gpio is edge triggered, clear condition
			  before executing the handler so that we don't
			  miss edges
 Enable gpio irq for wake up source 
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-or-later
  RDC321x GPIO driver
  Copyright (C) 2008, Volker Weiss <dev@tintuc.de>
  Copyright (C) 2007-2010 Florian Fainelli <florian@openwrt.org>
 read GPIO pin 
 set GPIO pin to value 
 configure GPIO pin as input 
  Cache the initial value of both GPIO data registers
	 This might not be, what others (BIOS, bootloader, etc.)
	   wrote to these registers before, but it's a good guess. Still
 SPDX-License-Identifier: GPL-2.0-or-later
  archarmplat-iopgpio.c
  GPIO handling for Intel IOP3xx processors.
  Copyright (C) 2006 Lennert Buytenhek <buytenh@wantstofly.org>
 SPDX-License-Identifier: GPL-2.0-only
  sl28cpld GPIO driver
  Copyright 2020 Michael Walle <michael@walle.cc>
 GPIO flavor 
 input-only flavor 
 output-only flavor 
 reg_dir_out_base might be zero 
 This type supports interrupts 
  SPEAr platform SPI chipselect abstraction over gpiolib
  Copyright (C) 2012 ST Microelectronics
  Shiraz Hashim <shiraz.linux.kernel@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 maximum chipselects 
  Provision is available on some SPEAr SoCs to control ARM PL022 spi cs
  through system registers. This register lies outside spi (pl022)
  address space into system registers.
  It provides control for spi chip select lines so that any chipselect
  (out of 4 possible chipselects in pl022) can be made low to select
  the particular slave.
  struct spear_spics - represents spi chip select control
  @base: base address
  @perip_cfg: configuration register
  @sw_enable_bit: bit to enable sw control over chipselects
  @cs_value_bit: bit to program high or low chipselect
  @cs_enable_mask: mask to select bits required to select chipselect
  @cs_enable_shift: bit pos of cs_enable_mask
  @use_count: use count of a spi controller cs lines
  @last_off: stores last offset caller of set_value()
  @chip: gpio_chip abstraction
 gpio framework specific routines 
 select chip select from register 
 toggle chip select line 
 SPDX-License-Identifier: GPL-2.0
  GPIO interface for Intel Poulsbo SCH
   Copyright (c) 2010 CompuLab Ltd
   Author: Denis Turischev <denis@compulab.co.il>
  iLB datasheet describes GPE0BLK registers, in particular GPE0E.GPIO bit.
  Document Number: 328195-001
 GPE handling 
	
	  according to the datasheet, writing to the level register has no
	  effect when GPIO is programmed as input.
	  Actually the the level register is read-only when configured as input.
	  Thus presetting the output level before switching to output is _NOT_ possible.
	  Hence we set the level after configuring the GPIO as output.
	  But we cannot prevent a short low pulse if direction is set to high
	  and an external pull-up is connected.
 Set returning value depending on whether we handled an interrupt 
 Acknowledge GPE to ACPICA 
		
		  GPIO[6:0] enabled by default
		  GPIO7 is configured by the CMC as SLPIOVR
		  Enable GPIO[9:8] core powered gpios explicitly
		
		  SUS_GPIO[2:0] enabled by default
		  Enable SUS_GPIO3 resume powered gpio explicitly
 GPE setup is optional 
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  Copyright (C) 2011, 2012 Cavium Inc.
  The address offset of the GPIO configuration register for a given
  line.
	
	  The register stride is 8, with a discontinuity after the
	  first 16.
 SPDX-License-Identifier: GPL-2.0-only
  AMD CS5535CS5536 GPIO driver
  Copyright (C) 2006  Advanced Micro Devices, Inc.
  Copyright (C) 2007-2009  Andres Salomon <dilinger@collabora.co.uk>
  Some GPIO pins
   31-29,23 : reserved (always mask out)
   28       : Power Button
   26       : PME#
   22-16    : LPC
   14,15    : SMBus
   9,8      : UART1
   7        : PCI INTB
   3,4      : UART2DDC
   2        : IDE_IRQ0
   1        : AC_BEEP
   0        : PCI INTA
  If a mask was not specified, allow all except
  reserved and Power Button
  FIXME: convert this singleton driver to use the state container
  design pattern, see Documentationdriver-apidriver-modeldesign-patterns.rst
  The CS5535CS5536 GPIOs support a number of extra features not defined
  by the gpio_chip API, so these are exported.  For a full list of the
  registers, see includelinuxcs5535.h.
	
	  According to the CS5536 errata (#36), after suspend
	  a write to the high bank GPIO register will clear all
	  non-selected bits; the recommended workaround is a
	  read-modify-write operation.
	 
	  Don't apply this errata to the edge status GPIOs, as writing
	  to their lower bits will clear them.
 ignore the high bits 
 low bank register 
 high bank register 
 low bank register 
 high bank register 
 low bank register 
 high bank register 
 Clear whatever was there before 
 Set the new value 
 Set the PME bit if this is a PME event 
  Generic gpio_chip API support.
 check if this pin is available 
 disable output aux 1 & 2 on this pin 
 disable input aux 1 on this pin 
	 There are two ways to get the GPIO base address; one is by
	  fetching it from MSR_LBAR_GPIO, the other is by reading the
	  PCI BAR info.  The latter method is easier (especially across
	  different architectures), so we'll stick with that for now.  If
	  it turns out to be unreliable in the face of crappy BIOSes, we
 set up the driver-specific struct 
 mask out reserved pins 
	 do not allow pin 28, Power Button, as there's special handling
 finally, register with the generic GPIO API 
 SPDX-License-Identifier: GPL-2.0-only
  RDA Micro GPIO driver
  Copyright (C) 2012 RDA Micro Inc.
  Copyright (C) 2019 Manivannan Sadhasivam
 Each bank consists of 32 GPIOs 
 Set rising edge trigger 
 Switch to edge trigger interrupt 
 Set falling edge trigger 
 Switch to edge trigger interrupt 
 Set both edge trigger 
 Switch to edge trigger interrupt 
 Set high level trigger 
 Switch to level trigger interrupt 
 Set low level trigger 
 Switch to level trigger interrupt 
 Only lower 8 bits are capable of generating interrupts 
	
	  Not all ports have interrupt capability. For instance, on
	  RDA8810PL, GPIOC doesn't support interrupt. So we must handle
	  those also.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  Timberdale FPGA GPIO driver
  Author: Mocean Laboratories
  Copyright (c) 2009 Intel Corporation
 Supports:
  Timberdale FPGA GPIO
 mutual exclusion 
  GPIO IRQ
	
	  Some versions of the hardware trash the IER register if more than
	  one interrupt is received simultaneously.
 make sure to disable interrupts 
--------------------------------------------------------------------------
 SPDX-License-Identifier: GPL-2.0-only
  GPIO driver for the ACCES PCIe-IDIO-24 family
  Copyright (C) 2018 William Breathitt Gray
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License, version 2, as
  published by the Free Software Foundation.
  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.
  This driver supports the following ACCES devices: PCIe-IDIO-24,
  PCIe-IDI-24, PCIe-IDO-24, and PCIe-IDIO-12.
  PLX PEX8311 PCI LCS_INTCSR Interrupt ControlStatus
  Bit: Description
    0: Enable Interrupt Sources (Bit 0)
    1: Enable Interrupt Sources (Bit 1)
    2: Generate Internal PCI Bus Internal SERR# Interrupt
    3: Mailbox Interrupt Enable
    4: Power Management Interrupt Enable
    5: Power Management Interrupt
    6: Slave Read Local Data Parity Check Error Enable
    7: Slave Read Local Data Parity Check Error Status
    8: Internal PCI Wire Interrupt Enable
    9: PCI Express Doorbell Interrupt Enable
   10: PCI Abort Interrupt Enable
   11: Local Interrupt Input Enable
   12: Retry Abort Enable
   13: PCI Express Doorbell Interrupt Active
   14: PCI Abort Interrupt Active
   15: Local Interrupt Input Active
   16: Local Interrupt Output Enable
   17: Local Doorbell Interrupt Enable
   18: DMA Channel 0 Interrupt Enable
   19: DMA Channel 1 Interrupt Enable
   20: Local Doorbell Interrupt Active
   21: DMA Channel 0 Interrupt Active
   22: DMA Channel 1 Interrupt Active
   23: Built-In Self-Test (BIST) Interrupt Active
   24: Direct Master was the Bus Master during a Master or Target Abort
   25: DMA Channel 0 was the Bus Master during a Master or Target Abort
   26: DMA Channel 1 was the Bus Master during a Master or Target Abort
   27: Target Abort after internal 256 consecutive Master Retrys
   28: PCI Bus wrote data to LCS_MBOX0
   29: PCI Bus wrote data to LCS_MBOX1
   30: PCI Bus wrote data to LCS_MBOX2
   31: PCI Bus wrote data to LCS_MBOX3
  struct idio_24_gpio_reg - GPIO device registers structure
  @out0_7:	Read: FET Outputs 0-7
 		Write: FET Outputs 0-7
  @out8_15:	Read: FET Outputs 8-15
 		Write: FET Outputs 8-15
  @out16_23:	Read: FET Outputs 16-23
 		Write: FET Outputs 16-23
  @ttl_out0_7:	Read: TTLCMOS Outputs 0-7
 		Write: TTLCMOS Outputs 0-7
  @in0_7:	Read: Isolated Inputs 0-7
 		Write: Reserved
  @in8_15:	Read: Isolated Inputs 8-15
 		Write: Reserved
  @in16_23:	Read: Isolated Inputs 16-23
 		Write: Reserved
  @ttl_in0_7:	Read: TTLCMOS Inputs 0-7
 		Write: Reserved
  @cos0_7:	Read: COS Status Inputs 0-7
 		Write: COS Clear Inputs 0-7
  @cos8_15:	Read: COS Status Inputs 8-15
 		Write: COS Clear Inputs 8-15
  @cos16_23:	Read: COS Status Inputs 16-23
 		Write: COS Clear Inputs 16-23
  @cos_ttl0_7:	Read: COS Status TTLCMOS 0-7
 		Write: COS Clear TTLCMOS 0-7
  @ctl:	Read: Control Register
 		Write: Control Register
  @reserved:	Read: Reserved
 		Write: Reserved
  @cos_enable:	Read: COS Enable
 		Write: COS Enable
  @soft_reset:	Read: IRQ Output Pin Status
 		Write: Software Board Reset
  struct idio_24_gpio - GPIO device private data structure
  @chip:	instance of the gpio_chip
  @lock:	synchronization lock to prevent IO race conditions
  @reg:	IO address offset for the GPIO device registers
  @irq_mask:	IO bits affected by interrupts
 FET Outputs 
 Isolated Inputs 
 TTLCMOS IO 
 OUT MODE = 1 when TTLCMOS Output Mode is set 
 TTLCMOS IO 
 Clear TTLCMOS Output Mode 
 TTLCMOS IO 
 Set TTLCMOS Output Mode 
 FET Outputs 
 Isolated Inputs 
 TTLCMOS Outputs 
 TTLCMOS Inputs 
 clear bits array to a clean slate 
 read bits from current gpio port (port 6 is TTL GPIO) 
 Isolated Inputs 
 TTLCMOS Inputs 
 TTLCMOS Outputs 
 FET Outputs 
 read bits from current gpio port (port 6 is TTL GPIO) 
 skip TTL GPIO if set for input 
 set requested bit states 
 write bits for current gpio port (port 6 is TTL GPIO) 
 Disable Rising Edge detection 
 Disable Falling Edge detection 
 Enable Rising Edge detection 
 Enable Falling Edge detection 
 The only valid irq types are none and both-edges 
 Read Change-Of-State status 
 Make sure our device generated IRQ 
 Handle only unmasked IRQ 
 Clear Change-Of-State status 
 This will let us handle the parent IRQ in the driver 
 Software board reset 
	
	  enable PLX PEX8311 internal PCI wire interrupt and local interrupt
	  input
 SPDX-License-Identifier: GPL-2.0-only
   74Hx164 - Generic serial-inparallel-out 8-bits shift register GPIO driver
   Copyright (C) 2010 Gabor Juhos <juhosg@openwrt.org>
   Copyright (C) 2010 Miguel Gaio <miguel.gaio@efixo.com>
	
	  Since the registers are chained, every byte sent will make
	  the previous byte shift to the next register in the
	  chain. Thus, the first byte sent will end up in the last
	  register at the end of the transfer. So, to have a logical
	  numbering, store the bytes in reverse order.
	
	  bits_per_word cannot be configured in platform data
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2015-2018 Pengutronix, Uwe Kleine-Knig <kernel@pengutronix.de>
  Note that this callback only sets the value that is clocked out in the next
  cycle.
			
			  Conceptually handle_nested_irq should call the flow
			  handler of the irq chip. But it doesn't, so we have
			  to clean the irq_status here.
 SPDX-License-Identifier: GPL-2.0-only
   GPIO interface for IT87xx Super IO chips
   Author: Diego Elio Petten <flameeyes@flameeyes.eu>
   Copyright (c) 2017 Google, Inc.
   Based on it87_wdt.c     by Oliver Schuster
            gpio-it8761e.c by Denis Turischev
            gpio-stmpe.c   by Rabin Vincent
 Chip Id numbers 
 IO Ports 
 Logical device Numbers LDN 
 Configuration Registers and Functions 
  struct it87_gpio - it87-specific GPIO chip
  @chip: the underlying gpio_chip structure
  @lock: a lock to avoid races between operations
  @io_base: base address for gpio ports
  @io_size: size of the port rage starting from io_base.
  @output_base: Super IO register address for Output Enable register
  @simple_base: Super IO 'Simple IO' Enable register
  @simple_size: Super IO 'Simple IO' Enable register size; this is
 	required because IT87xx chips might only provide Simple IO
 	switches on a subset of lines, whereas the others keep the
 	same status all time.
 Superio chip access functions; copied from wdt_it87 
	
	  Try to reserve REG and REG + 1 for exclusive access.
	 not all the IT87xx chips support Simple IO and not all of
	  them allow all the lines to be setunset to Simple IO.
	 clear output enable, setting the pin to input, as all the
	  newly-exported GPIO interfaces are set to input.
 clear the output enable bit 
 set the output enable bit 
 it8613 only needs 6, use 8 for alignment 
 has 48, use 64 for convenient calc 
 fetch GPIO base address 
	 Set up aliases for the GPIO connection.
	 
	  ITE documentation for recent chips such as the IT8728F
	  refers to the GPIO lines as GPxy, with a coordinates system
	  where x is the GPIO group (starting from 1) and y is the
	  bit within the group.
	 
	  By creating these aliases, we make it easier to understand
	  to which GPIO pin we're referring to.
 SPDX-License-Identifier: GPL-2.0+
  Linux GPIOlib driver for the VIA VX855 integrated southbridge GPIO
  Copyright (C) 2009 VIA Technologies, Inc.
  Copyright (C) 2010 One Laptop per Child
  Author: Harald Welte <HaraldWelte@viatech.com>
  All rights reserved.
 The VX855 south bridge has the following GPIO pins:
 	GPI 0...13	General Purpose Input
 	GPO 0...12	General Purpose Output
 	GPIO 0...14	General Purpose IO (Open-Drain)
 resolve a GPIx into the corresponding bit position 
 Mapping between numeric GPIO ID and the actual GPIO hardware numbering:
  0..13	GPI 0..13
  14..26	GPO 0..12
  27..41	GPIO 0..14
 Real GPI bits are always in input direction 
 Real GPO bits cannot be put in output direction 
 Open Drain GPIO have to be set to one 
		 GPO don't have an input bit, we need to read it
 True GPI cannot be switched to output mode 
 True GPI cannot be switched to output mode 
	 True GPO don't need to be switched to output mode,
	  and GPIO are open-drain, i.e. also need no switching,
 The GPI cannot be single-ended 
 The GPO's are push-pull 
 The GPIO's are open drain 
 This platform device is ordinarily registered by the vx855 mfd driver 
	
	  A single byte is used to control various GPIO ports on the VX855,
	  and in the case of the OLPC XO-1.5, some of those ports are used
	  for switches that are interpreted and exposed through ACPI. ACPI
	  will have reserved the region, so our own reservation will not
	  succeed. Ignore and continue.
 SPDX-License-Identifier: GPL-2.0-or-later
   SYSCON GPIO driver
   Copyright (C) 2014 Alexander Shiyan <shc_work@mail.ru>
 SYSCON driver is designed to use 32-bit wide registers 
  struct syscon_gpio_data - Configuration for the device.
  @compatible:		SYSCON driver compatible string.
  @flags:		Set of GPIO_SYSCON_FEAT_ flags:
 			GPIO_SYSCON_FEAT_IN:	GPIOs supports input,
 			GPIO_SYSCON_FEAT_OUT:	GPIOs supports output,
 			GPIO_SYSCON_FEAT_DIR:	GPIOs supports switch direction.
  @bit_count:		Number of bits used as GPIOs.
  @dat_bit_offset:	Offset (in bits) to the first GPIO bit.
  @dir_bit_offset:	Optional offset (in bits) to the first bit to switch
 			GPIO direction (Used with GPIO_SYSCON_FEAT_DIR flag).
  @set:		HW specific callback to assigns output value
 			for signal "offset"
 ARM CLPS711X SYSFLG1 Bits 8-10 
 RK3328 GPIO_MUTE is an output only pin at GRF_SOC_CON10[1] 
 ARM Keystone 2 
 SPDX-License-Identifier: GPL-2.0-only
  Xilinx gpio driver for xpsaxi_gpio IP.
  Copyright 2008 - 2013 Xilinx, Inc.
 Register Offset Definitions 
 Data register  
 IO direction register  
 Global Interrupt Enable 
 IP Interrupt Status 
 IP Interrupt Enable 
 ReadWrite access to the GPIO registers 
  struct xgpio_instance - Stores information about GPIO device
  @gc: GPIO chip
  @regs: register block
  @hw_map: GPIO pin mapping on hardware side
  @sw_map: GPIO pin mapping on software side
  @state: GPIO write state shadow register
  @last_irq_read: GPIO read state register from last interrupt
  @dir: GPIO direction shadow register
  @gpio_lock: Lock used for synchronization
  @irq: IRQ used by GPIO device
  @irqchip: IRQ chip
  @enable: GPIO IRQ enabledisable bitfield
  @rising_edge: GPIO IRQ rising edge enabledisable bitfield
  @falling_edge: GPIO IRQ falling edge enabledisable bitfield
  @clk: clock resource for this driver
 For serializing operations 
  xgpio_get - Read the specified signal of the GPIO device.
  @gc:     Pointer to gpio_chip device structure.
  @gpio:   GPIO signal number.
  This function reads the specified signal of the GPIO device.
  Return:
  0 if direction of GPIO signals is set as input otherwise it
  returns negative error value.
  xgpio_set - Write the specified signal of the GPIO device.
  @gc:     Pointer to gpio_chip device structure.
  @gpio:   GPIO signal number.
  @val:    Value to be written to specified signal.
  This function writes the specified value in to the specified signal of the
  GPIO device.
 Write to GPIO signal and set its direction to output 
  xgpio_set_multiple - Write the specified signals of the GPIO device.
  @gc:     Pointer to gpio_chip device structure.
  @mask:   Mask of the GPIOS to modify.
  @bits:   Value to be wrote on each GPIO
  This function writes the specified values into the specified signals of the
  GPIO devices.
  xgpio_dir_in - Set the direction of the specified GPIO signal as input.
  @gc:     Pointer to gpio_chip device structure.
  @gpio:   GPIO signal number.
  Return:
  0 - if direction of GPIO signals is set as input
  otherwise it returns negative error value.
 Set the GPIO bit in shadow register and set direction as input 
  xgpio_dir_out - Set the direction of the specified GPIO signal as output.
  @gc:     Pointer to gpio_chip device structure.
  @gpio:   GPIO signal number.
  @val:    Value to be written to specified signal.
  This function sets the direction of specified GPIO signal as output.
  Return:
  If all GPIO signals of GPIO chip is configured as input then it returns
  error otherwise it returns 0.
 Write state of GPIO signal 
 Clear the GPIO bit in shadow register and set direction as output 
  xgpio_save_regs - Set initial values of GPIO pins
  @chip: Pointer to GPIO instance
	
	  If the device is already active pm_runtime_get() will return 1 on
	  success, but gpio_request still needs to return 0.
  xgpio_remove - Remove method for the GPIO device.
  @pdev: pointer to the platform device
  This function remove gpiochips and frees all the allocated resources.
  Return: 0 always
  xgpio_irq_ack - Acknowledge a child GPIO interrupt.
  @irq_data: per IRQ and chip data passed down to chip functions
  This currently does nothing, but irq_ack is unconditionally called by
  handle_edge_irq and therefore must be defined.
  xgpio_irq_mask - Write the specified signal of the GPIO device.
  @irq_data: per IRQ and chip data passed down to chip functions
 Disable per channel interrupt 
  xgpio_irq_unmask - Write the specified signal of the GPIO device.
  @irq_data: per IRQ and chip data passed down to chip functions
 Clear any existing per-channel interrupts 
 Update GPIO IRQ read data before enabling interrupt
 Enable per channel interrupt 
  xgpio_set_irq_type - Write the specified signal of the GPIO device.
  @irq_data: Per IRQ and chip data passed down to chip functions
  @type: Interrupt type that is to be set for the gpio pin
  Return:
  0 if interrupt type is supported otherwise -EINVAL
	
	  The Xilinx GPIO hardware provides a single interrupt status
	  indication for any state change in a given GPIO channel (bank).
	  Therefore, only rising edge or falling edge triggers are
	  supported.
  xgpio_irqhandler - Gpio interrupt service routine
  @desc: Pointer to interrupt description
  xgpio_probe - Probe method for the GPIO device.
  @pdev: pointer to the platform device
  Return:
  It returns 0, if the driver is bound to the GPIO device, or
  a negative value if there is an error.
 First, check if the device is dual-channel 
 Setup defaults 
 Update GPIO state shadow register with default value 
 Update GPIO direction shadow register with default value 
 Update cells with gpio-cells value 
	
	  Check device node and parent device node for device width
	  and assume default width of 32
 Setup software pin mapping 
 Setup hardware pin mapping 
 Disable per-channel interrupts 
 Clear any existing per-channel interrupts 
 Enable global interrupts 
 end of list  },
 SPDX-License-Identifier: GPL-2.0
  GPIO driver for NXP LPC18xx43xx.
  Copyright (C) 2018 Vladimir Zapolskiy <vz@mleia.com>
  Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>
 LPC18xx GPIO register offsets 
 LPC18xx GPIO pin interrupt controller register offsets 
	
	  All LPC18xxLPC43xx GPIO pin hardware interrupts are translated
	  into edge interrupts 32...39 on parent Cortex-M3M4 NVIC
 To support backward compatibility take the first resource 
 On error GPIO pin interrupt controller just won't be registered 
 SPDX-License-Identifier: GPL-2.0
  Toshiba Visconti GPIO Support
  (C) Copyright 2020 Toshiba Electronic Devices & Storage Corporation
  (C) Copyright 2020 TOSHIBA CORPORATION
  Nobuhiro Iwamatsu <nobuhiro1.iwamatsu@toshiba.co.jp>
 register offset 
 protect gpio register 
 Interrupts 0..15 mapped to interrupts 24..39 on the GIC 
 All these interrupts are level high in the CPU 
 end of table  }
 SPDX-License-Identifier: GPL-2.0
 Copyright (c) 2019, Linaro Limited
 SPDX-License-Identifier: GPL-2.0-only
   MAX732x I2C Port Expander with 816 IO
   Copyright (C) 2007 Marvell International Ltd.
   Copyright (C) 2008 Jack Ren <jack.ren@marvell.com>
   Copyright (C) 2008 Eric Miao <eric.miao@marvell.com>
   Copyright (C) 2015 Linus Walleij <linus.walleij@linaro.org>
   Derived from driversgpiopca953x.c
  Each port of MAX732x (including MAX7319) falls into one of the
  following three types:
    - Push Pull Output
    - Input
    - Open Drain IO
  designated by 'O', 'I' and 'P' individually according to MAXIM's
  datasheets. 'I' and 'P' ports are interrupt capables, some with
  a dedicated interrupt mask.
  There are two groups of IO ports, each group usually includes
  up to 8 IO ports, and is accessed by a specific I2C address:
    - Group A : by I2C address 0b'110xxxx
    - Group B : by I2C address 0b'101xxxx
  where 'xxxx' is decided by the connections of pin AD2AD0.  The
  address used also affects the initial state of output signals.
  Within each group of ports, there are five known combinations of
  IO ports: 4I4O, 4P4O, 8I, 8P, 8O, see the definitions below for
  the detailed organization of these ports. Only Goup A is interrupt
  capable.
  GPIO numbers start from 'gpio_base + 0' to 'gpio_base + 816',
  and GPIOs from GROUP_A are numbered before those from GROUP_B
  (if there are two groups).
  NOTE: MAX7328MAX7329 are drop-in replacements for PCF8574a, so
  they are not supported by this driver.
 '' No Port 
 'O' Push-Pull, Output Only 
 'I' Input Only 
 'P' Open-Drain, IO 
 O7 O6 I5 I4 I3 I2 O1 O0 
 O7 O6 P5 P4 P3 P2 O1 O0 
 I7 I6 I5 I4 I3 I2 I1 I0 
 P7 P6 P5 P4 P3 P2 P1 P0 
 O7 O6 O5 O4 O3 O2 O1 O0 
 I2C Addr: 0b'110xxxx 
 I2C Addr: 0b'101xxxx 
 No interrupt capability 
 Has interrupts, no mask 
 Has interrupts, independent mask 
 Has interrupts, merged mask 
 "main" client 
 update the shadow register then 
	
	  Open-drain pins must be set to high impedance (which is
	  equivalent to output-high) to be turned into an input.
 This will let us handle the parent IRQ in the driver 
 FIXME: get rid of this 
 CONFIG_GPIO_MAX732X_IRQ 
 register after i2c postcore initcall and before
  subsys initcalls that may rely on these GPIOs
 SPDX-License-Identifier: GPL-2.0-only
  Total register block size is 0x1C for one bank of four ports (A, B, C, D).
  An optional second bank, with ports E, F, G, and H, may be present, starting
  at register offset 0x1C.
  Pin select: (0) "normal", (1) "dedicate peripheral"
  Not used on RTL8380RTL8390, peripheral selection is managed by control bits
  in the peripheral registers.
 Clear bit (0) for input, set bit (1) for output 
 Read bit for IRQ status, write 1 to clear IRQ 
 Two bits per GPIO in IMR registers 
  realtek_gpio_ctrl - Realtek Otto GPIO driver data
  @gc: Associated gpio_chip instance
  @base: Base address of the register block for a GPIO bank
  @lock: Lock for accessing the IRQ registers and values
  @intr_mask: Mask for interrupts lines
  @intr_type: Interrupt type selection
  Because the interrupt mask register (IMR) combines the function of IRQ type
  selection and masking, two extra values are stored. @intr_mask is used to
  maskunmask the interrupts for a GPIO port, and @intr_type is used to store
  the selected interrupt types. The logical AND of these values is written to
  IMR on changes.
 Expand with more flags as devices with other quirks are added 
	
	  Allow disabling interrupts, for cases where the port order is
	  unknown. This may result in a port mismatch between ISR and IMR.
	  An interrupt would appear to come from a different line than the
	  line the IRQ handler was assigned to, causing uncaught interrupts.
  Normal port order register access
  Port information is stored with the first port at offset 0, followed by the
  second, etc. Most registers store one bit per GPIO and use a u8 value per
  port. The two interrupt mask registers store two bits per GPIO, so use u16
  values.
 Set the rising and falling edge mask bits for a GPIO port pin 
 SPDX-License-Identifier: GPL-2.0-or-later
  GPIO driver for the SMSC SCH311x Super-IO chips
  Copyright (C) 2013 Bruno Randolf <br1@einfach.org>
  SuperIO functions and chip detection:
  (c) Copyright 2008 Wim Van Sebroeck <wim@iguana.be>.
 platform device data 
 runtime register base address 
 one GPIO block runtime data 
 from definition below 
 pointer to definition below 
 runtime register 
 lock for this GPIO block 
 driver private data 
 register address definitions 
 Note: some GPIOs are not available, these are marked with 0x00 
 GP1 
 GP2 
 GP3 
 GP4 
 GP5 
 GP6 
 	Super-IO functions
 Don't step on other drivers' IO space by accident. 
 	GPIO functions
 GPIO is not available 
 GPIO is not available 
 we can register all GPIO data registers at once 
 release already registered chips 
 	Init & exit routines
 Check device ID. 
 SCH3112 
 SCH3114 
 SCH3116 
 Select logical device A (runtime registers) 
 Check if Logical Device Register is currently active 
 Get the base address of the runtime registers 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2011 Jamie Iles
  All enquiries to support@picochip.com
 register stride 32 bits 
 register stride 332 bits 
 register stride 332 bits 
 Store GPIO context across system-wide suspendresume transitions 
 Just read the current value right out of the data register 
 Group all available IRQs into an array of parental IRQs. 
	
	  Intel ACPI-based platforms mostly have the DesignWare APB GPIO
	  IRQ lane shared between several devices. In that case the parental
	  IRQ has to be handled in the shared way so to be properly delivered
	  to all the connected devices.
 This registers 32 GPIO lines per port 
 Only port A support debounce 
 Only port A can provide interrupts in all configurations of the IP 
 For internal use only, new platforms mustn't exercise this 
		
		  Only port A can provide interrupts in all configurations of
		  the IP.
 Optional bus and debounce clocks 
 Sentinel  }
 Only port A can provide interrupts 
 Mask out interrupts 
 Only port A can provide interrupts 
 Clear out spurious interrupts 
 SPDX-License-Identifier: GPL-2.0+
  gpiolib support for Wolfson WM835x PMICs
  Copyright 2009 Wolfson Microelectronics PLC.
  Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 Don't have an atomic directionvalue setup 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2013 TangoTec Ltd.
  Author: Baruch Siach <baruch@tkos.co.il>
  Driver for the Xtensa LX4 GPIO32 Option
  Documentation: Xtensa LX4 Microprocessor Data Book, Section 2.22
  GPIO32 is a standard optional extension to the Xtensa architecture core that
  provides preconfigured output and input ports for intra SoC signaling. The
  GPIO32 option is implemented as 32bit Tensilica Instruction Extension (TIE)
  output state called EXPSTATE, and 32bit input wire called IMPWIRE. This
  driver treats input and output states as two distinct devices.
  Access to GPIO32 specific instructions is controlled by the CPENABLE
  (Coprocessor Enable Bits) register. By default Xtensa Linux startup code
  disables access to all coprocessors. This driver sets the CPENABLE bit
  corresponding to GPIO32 before any GPIO32 specific instruction, and restores
  CPENABLE state after that.
  This driver is currently incompatible with SMP. The GPIO32 extension is not
  guaranteed to be available in all cores. Moreover, each core controls a
  different set of IO wires. A theoretical SMP aware version of this driver
  would need to have a per core workqueue to do the actual GPIO manipulation.
 CPENABLE readwrite macros 
 avoid uninitialized value warning 
 XCHAL_HAVE_CP 
 input only 
 output only; should never be called 
 output only 
 SPDX-License-Identifier: GPL-2.0-or-later
  GPIO Driver for Dialog DA9052 PMICs.
  Copyright(c) 2011 Dialog Semiconductor Ltd.
  Author: David Dajun Chen <dchen@diasemi.com>
 Format: function - 2 bits type - 1 bit mode - 1 bit 
 Format: Function - 2 bits Type - 1 bit Mode - 1 bit 
 SPDX-License-Identifier: GPL-2.0-or-later
  GPIO Driver for Dialog DA9055 PMICs.
  Copyright(c) 2012 Dialog Semiconductor Ltd.
  Author: David Dajun Chen <dchen@diasemi.com>
 Get GPIO direction 
 SPDX-License-Identifier: GPL-2.0-only
  GPIO driver for the ACCES 104-DIO-48E series
  Copyright (C) 2016 William Breathitt Gray
  This driver supports the following ACCES devices: 104-DIO-48E and
  104-DIO-24E.
  struct dio48e_gpio - GPIO device private data structure
  @chip:	instance of the gpio_chip
  @io_state:	bit IO state (whether bit is set to input or output)
  @out_state:	output bits state
  @control:	Control registers state
  @lock:	synchronization lock to prevent IO race conditions
  @base:	base port address of the GPIO device
  @irq_mask:	IO bits affected by interrupts
 Check if configuring Port C 
 Port C can be configured by nibble 
 Check if configuring Port C 
 Port C can be configured by nibble 
 ensure that GPIO is set for input 
 clear bits array to a clean slate 
 update output state data and set device gpio register 
 only bit 3 on each respective Port C supports interrupts 
 disable interrupts 
 only bit 3 on each respective Port C supports interrupts 
 enable interrupts 
 only bit 3 on each respective Port C supports interrupts 
 Disable IRQ by default 
 This will let us handle the parent IRQ in the driver 
 initialize all GPIO as output 
 SPDX-License-Identifier: GPL-2.0+
 Gateworks I2C PLD GPIO expander
 Copyright (C) 2019 Linus Walleij <linus.walleij@linaro.org>
 Based on code and know-how from the OpenWrt driver:
 Copyright (C) 2009 Gateworks Corporation
 Authors: Chris Lang, Imre Kaloz
  struct gw_pld - State container for Gateworks PLD
  @chip: GPIO chip instance
  @client: I2C client
  @out: shadow register for the output bute
  The Gateworks I2C PLD chip only expose one read and one write register.
  Writing a "one" bit (to match the reset state) lets that pin be used as an
  input. It is an open-drain model.
	
	  The Gateworks I2C PLD chip does not properly send the acknowledge
	  bit at all times, but we can still use the standard i2c_smbus
	  functions by simply ignoring this bit.
 SPDX-License-Identifier: GPL-2.0-only
  gpio-reg: single register individually fixed-direction GPIOs
  Copyright (C) 2016 Russell King
		
		  double-read the value, some registers latch after the
		  first read.
  gpio_reg_init - add a fixed inout register as gpio
  @dev: optional struct device associated with this register
  @base: start gpio number, or -1 to allocate
  @num: number of GPIOs, maximum 32
  @label: GPIO chip label
  @direction: bitmask of fixed direction, one per GPIO signal, 1 = in
  @def_out: initial GPIO output value
  @names: array of %num strings describing each GPIO signal or %NULL
  @irqdom: irq domain or %NULL
  @irqs: array of %num ints describing the interrupt mapping for each
         GPIO signal, or %NULL.  If @irqdom is %NULL, then this
         describes the Linux interrupt number, otherwise it describes
         the hardware interrupt number in the specified irq domain.
  Add a single-register GPIO device containing up to 32 GPIO signals,
  where each GPIO has a fixed input or output configuration.  Only
  input GPIOs are assumed to be readable from the register, and only
  then after a double-read.  Output values are assumed not to be
  readable.
 SPDX-License-Identifier: GPL-2.0-only
   linuxarcharmplat-pxagpio.c
   Generic PXA GPIO handling
   Author:	Nicolas Pitre
   Created:	Jun 15, 2001
   Copyright:	MontaVista Software Inc.
  We handle the GPIOs by banks, each bank covers up to 32 GPIOs with
  one set of registers. The register offsets are organized below:
            GPLR    GPDR    GPSR    GPCR    GRER    GFER    GEDR
  BANK 0 - 0x0000  0x000C  0x0018  0x0024  0x0030  0x003C  0x0048
  BANK 1 - 0x0004  0x0010  0x001C  0x0028  0x0034  0x0040  0x004C
  BANK 2 - 0x0008  0x0014  0x0020  0x002C  0x0038  0x0044  0x0050
  BANK 3 - 0x0100  0x010C  0x0118  0x0124  0x0130  0x013C  0x0148
  BANK 4 - 0x0104  0x0110  0x011C  0x0128  0x0134  0x0140  0x014C
  BANK 5 - 0x0108  0x0114  0x0120  0x012C  0x0138  0x0144  0x0150
  BANK 6 - 0x0200  0x020C  0x0218  0x0224  0x0230  0x023C  0x0248
  NOTE:
    BANK 3 is only available on PXA27x and later processors.
    BANK 4 and 5 are only available on PXA935, PXA1928
    BANK 6 is only available on PXA1928
 GPIO edge detection for AP side 
 GPIO86878889 on PXA26x have their direction bits in PXA_GPDR(2 inverted,
  as well as their Alternate Function value being '1' for GPIO in GAFRx.
  On PXA25x and PXA27x, GAFRx and GPDRx together decide the alternate
  function of a GPIO, and GPDRx cannot be altered once configured. It
  is attributed as "occupied" here (I know this terminology isn't
  accurate, you are welcome to propose a better one :-)
 Update only those GRERx and GFERx edge detection register bits if those
  bits are set in c->irq_mask
		 Don't mess with enabled GPIOs using preconfigured edges or
		  GPIOs set to alternate function or to output during probe
 Initialize GPIO chips 
 clear all GPIO edge detects 
 unmask GPIO edge detect for AP side 
 Clear GPIO transition detect bits 
 restore level with setclear 
  Broadcom Kona GPIO Driver
  Author: Broadcom Corporation <bcm-kernel-feedback-list@broadcom.com>
  Copyright (C) 2012-2014 Broadcom Corporation
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 There is a GPIO control register for each GPIO 
 The remaining registers are per GPIO bank 
 Used in the interrupt handler 
 this function only applies to output pin 
 read the GPIO bank status 
 return the specified bit status 
 debounce must be 1-128ms (or 0) 
 calculate debounce bit value 
 Convert to ms 
 find the MSB 
 Check if MSB-1 is set (round up or down) 
 spin lock for read-modify-write of the GPIO register 
 disable debounce 
 BCM GPIO doesn't support level triggering 
	
	  For bank interrupts, we can't use chip_data to store the kona_gpio
	  pointer, since GIC needs it for its own purposes. Therefore, we get
	  our pointer from the bank structure.
			
			  Clear interrupt before handler is called so we don't
			  miss any interrupt occurred during executing them.
 Invoke interrupt handler 
  This lock class tells lockdep that GPIO irqs are in a different
  category than their parents, so it won't report false recursion.
 disable interrupts and clear status 
 Unlock the entire bank first 
 Now re-lock the bank 
  Support for the GPIOIRQ expander chips present on several HTC phones.
  These are implemented in CPLD chips present on the board.
  Copyright (c) 2007 Kevin O'Connor <kevin@koconnor.net>
  Copyright (c) 2007 Philipp Zabel <philipp.zabel@gmail.com>
  This file may be distributed under the terms of the GNU GPL license.
 iomem info 
 byte shift 
 bit shift 
 irq info 
 egpio info 
  IRQs
 There does not appear to be a way to proactively mask interrupts
  on the egpio chip itself.  So, we simply ignore interrupts that
 Read current pins. 
 Ackunmask interrupts. 
 Process all set pins. 
 Run irq handler 
  Input pins
  Output pins
  Setup
 Initialize ei data structure. 
 Find chained irq 
 Map egpio chip into virtual address space. 
 Set initial pin values 
 Setup irq handlers 
	 Update registers from the cache, in case
 start early for dependencies 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2006 Juergen Beisert, Pengutronix
  Copyright (C) 2008 Guennadi Liakhovetski, Pengutronix
  Copyright (C) 2009 Wolfram Sang, Pengutronix
  The Maxim MAX73001 device is an I2CSPI driven GPIO expander. There are
  28 GPIOs. 8 of them can trigger an interrupt. See datasheet for more
  details
  Note:
  - DIN must be stable at the rising edge of clock.
  - when writing:
    - always clock in 16 clocks at once
    - at DIN: D15 first, D0 last
    - D0..D7 = databyte, D8..D14 = commandbyte
    - D15 = low -> write command
  - when reading
    - always clock in 16 clocks at once
    - at DIN: D15 first, D0 last
    - D0..D7 = dummy, D8..D14 = register address
    - D15 = high -> read command
    - raise CS and assert it again
    - always clock in 16 clocks at once
    - at DOUT: D15 first, D0 last
    - D0..D7 contains the data from the first cycle
  The driver exports a standard gpiochip interface
  Pin configurations, see MAX7301 datasheet page 6
 First 4 pins are unused in the controller 
 First 4 pins are unused in the controller 
 First 4 pins are unused in the controller 
 Output: return cached level 
 Input: read out 
 First 4 pins are unused in the controller 
 Power up the chip and disable IRQ output 
	
	  initialize pullups according to platform data and cache the
	  register values for later use.
		
		  initialize port_config with "0xAA", which means
		  input with internal pullup disabled. This is needed
		  to avoid writing zeros (in the inner for loop),
		  which is not allowed according to the datasheet.
 Power down the chip and disable IRQ output 
 SPDX-License-Identifier: GPL-2.0-or-later
  AppliedMicro X-Gene SoC GPIO-Standby Driver
  Copyright (c) 2014, Applied Micro Circuits Corporation
  Author:	Tin Huynh <tnhuynh@apm.com>.
 		Y Vo <yvo@apm.com>.
 		Quan Nguyen <qnguyen@apm.com>.
 Common property names 
  struct xgene_gpio_sb - GPIO-Standby private data structure.
  @gc:				memory-mapped GPIO controllers.
  @regs:			GPIO register base offset
  @irq_domain:			GPIO interrupt domain
  @irq_start:			GPIO pin that start support interrupt
  @nirq:			Number of GPIO pins that supports interrupt
  @parent_irq_base:		Start parent HWIRQ
 Propagate IRQ type setting to parent 
 SPI 
 Skip SGIs and PPIs
 Retrieve start irq pin, use default if property not found 
 Retrieve number irqs, use default if property not found 
 Retrieve number gpio, use default if property not found 
 Register interrupt handlers for GPIO signaled ACPI Events 
 SPDX-License-Identifier: GPL-2.0-only
  GPIO driver for Exar XR17V35X chip
  Copyright (C) 2015 Sudip Mukherjee <sudip.mukherjee@codethink.co.uk>
	
	  The UART driver must have mapped region 0 prior to registering this
	  device - use it.
	
	  We don't need to check the return values of mmio regmap operations (unless
	  the regmap has a clock attached which is not the case here).
 SPDX-License-Identifier: GPL-2.0-only
  MPC52xx gpio driver
  Copyright (c) 2008 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
  GPIO LIB API implementation for wakeup GPIOs.
  There's a maximum of 8 wakeup GPIOs. Which of these are available
  for use depends on your board setup.
  0 -> GPIO_WKUP_7
  1 -> GPIO_WKUP_6
  2 -> PSC6_1
  3 -> PSC6_0
  4 -> ETH_17
  5 -> PSC3_9
  6 -> PSC2_4
  7 -> PSC1_4
 set the direction 
 and enable the pin 
 Then set direction 
 Finally enable the pin 
  GPIO LIB API implementation for simple GPIOs
  There's a maximum of 32 simple GPIOs. Which of these are available
  for use depends on your board setup.
  The numbering reflects the bit numbering in the port registers:
   0..1  > reserved
   2..3  > IRDA
   4..7  > ETHR
   8..11 > reserved
  12..15 > USB
  16..17 > reserved
  18..23 > PSC3
  24..27 > PSC2
  28..31 > PSC1
 set the direction 
 and enable the pin 
 First set initial value 
 Then set direction 
 Finally enable the pin 
 Make sure we get initialised before anyone else tries to use us 
 SPDX-License-Identifier: GPL-2.0
   Turris Mox Moxtet GPIO expander
   Copyright (C) 2018 Marek Behn <kabel@kernel.org>
 All lines are hard wired to be either input or output, not both. 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2017 Socionext Inc.
   Author: Masahiro Yamada <yamada.masahiro@socionext.com>
 data 
 direction (1:in, 0:out) 
 irq enable 
 irq mode (1: both edge) 
 noise filter enable 
 noise filter clock cycle 
	
	  Unfortunately, the GPIO port registers are not contiguous because
	  offset 0x90-0x9f is used for IRQ.  Add 0x10 when crossing the region.
	
	  IRQ_TYPE_NONE is rejected by the parent irq domain. Set LEVEL_HIGH
	  temporarily. Anyway, ->irq_set_type() will override it later.
 To enable both edge detection, the noise filter must be enabled. 
 parent is UniPhier AIDET 
	
	  Due to the hardware design, the noise filter must be enabled to
	  detect both edge interrupts.  This filter is intended to remove the
	  noise from the irq lines.  It does not work for GPIO input, so GPIO
	  debounce is not supported.  Unfortunately, the filter period is
	  shared among all irq lines.  Just choose a sensible period here.
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  GPIO driver for the ACCES 104-IDIO-16 family
  Copyright (C) 2015 William Breathitt Gray
  This driver supports the following ACCES devices: 104-IDIO-16,
  104-IDIO-16E, 104-IDO-16, 104-IDIO-8, 104-IDIO-8E, and 104-IDO-8.
  struct idio_16_gpio - GPIO device private data structure
  @chip:	instance of the gpio_chip
  @lock:	synchronization lock to prevent IO race conditions
  @irq_mask:	IO bits affected by interrupts
  @base:	base port address of the GPIO device
  @out_state:	output bits state
 The only valid irq types are none and both-edges 
 Disable IRQ by default 
 This will let us handle the parent IRQ in the driver 
 SPDX-License-Identifier: GPL-2.0-or-later
  TI DaVinci GPIO Support
  Copyright (c) 2006-2007 David Brownell
  Copyright (c) 2007, MontaVista Software, Inc. <source@mvista.com>
 GPIO Interrupt Per-Bank Enable Register 
 Serialize access to GPIO registers 
--------------------------------------------------------------------------
 board setup code MUST setup pinmux and enable the GPIO clock. 
  Read the pin's value (works even if it's set up as output);
  returns zerononzero.
  Note that changes are synched to the GPIO clock, so reading values back
  right after you've set them may give old values.
  Assuming the pin is muxed as a gpio output, set its output value.
	
	  The gpio banks conceptually expose a segmented bitmap,
	  and "ngpio" is one more than the largest zero-based
	  bit index that's valid.
	
	  If there are unbanked interrupts then the number of
	  interrupts is equal to number of gpios else all are banked so
	  number of interrupts is equal to number of banks(each with 16 gpios)
--------------------------------------------------------------------------
  We expect irqs will normally be set up as input pins, but they can also be
  used as output pins ... which is convenient for testing.
  NOTE:  The first few GPIOs also have direct INTC hookups in addition
  to their GPIOBNK0 irq, with a bit less overhead.
  All those INTC hookups (direct, plus several IRQ banks) can also
  serve as EDMA event triggers.
 we only care about one bank 
 temporarily mask (level sensitive) parent IRQ 
 ack any irqs 
 now demux them to the right lowlevel handler 
			 Max number of gpios per controller is 144 so
			  hw_irq will be in [0..143]
 now it may re-trigger 
	
	  NOTE:  we assume for now that only irqs in the first gpio_chip
	  can provide direct-mapped IRQs to AINTC (up to 32 GPIOs).
  NOTE:  for suspendresume, probably best to make a platform_device with
  suspend_lateresume_resume calls hooking into results of the set_wake()
  calls ... so if no gpios are wakeup events the clock can be disabled,
  with outputs left at previously set levels, and so that VDD3P3V.IOPWDN0
  (dm6446) can be set appropriately for GPIOV33 pins.
	
	  Use davinci_gpio_get_irq_chip by default to handle non DT cases
	
	  Arrange gpio_to_irq() support, handling either direct IRQs or
	  banked IRQs.  Having GPIOs in the first GPIO bank use direct
	  IRQs, while the others use banked IRQs, would need some setup
	  tweaks to recognize hardware which can do that.
	
	  AINTC can handle directunbanked IRQs for GPIOs, with the GPIO
	  controller only handling trigger modes.  We currently assume no
	  IRQ mux conflicts; gpio_irq_type_unbanked() is only for GPIOs.
 pass "bank 0" GPIO IRQs to AINTC 
 AINTC handles maskunmask; GPIO handles triggering 
 default trigger: both edges 
 set the direct IRQs up to use that irqchip 
	
	  Or, AINTC can handle IRQs for banks of 16 GPIO IRQs, which we
	  then chain through our own handler.
		 disabled by default, enabled only as needed
		  There are register sets for 32 GPIOs. 2 banks of 16
		  GPIOs are covered by each set of registers hence divide by 2
		
		  Each chip handles 32 gpios, and each irq bank consists of 16
		  gpio irqs. Pass the irq bank's corresponding controller to
		  the chained irq handler.
	
	  BINTEN -- per-bank interrupt enable. genirq would also let these
	  bits be setcleared dynamically.
 sentinel  },
  GPIO driver registration needs to be done before machine_init functions
  access GPIO. Hence davinci_gpio_drv_reg() is a postcore_initcall.
 SPDX-License-Identifier: GPL-2.0-only
  Driver for the Diolan DLN-2 USB-GPIO adapter
  Copyright (c) 2014 Intel Corporation
	
	  Cache pin direction to save us one transfer, since the hardware has
	  separate commands to read the in and out values.
 active IRQs - not synced to hardware 
 active IRQS - synced to hardware 
 cache the pin direction 
 The event comes from the outside so no parent handler 
 SPDX-License-Identifier: GPL-2.0-only
  Kontron PLD GPIO driver
  Copyright (c) 2010-2013 Kontron Europe GmbH
  Author: Michael Brunner <michael.brunner@kontron.com>
  Set or clear GPIO bit
  kempld_get_mutex must be called prior to calling this function.
 Backup event register as it might be already initialized 
 Clear event register 
 Read back event register 
 Restore event register 
 SPDX-License-Identifier: GPL-2.0+
 MXC GPIO support. (c) 2008 Daniel Mack <daniel@caiaq.de>
 Copyright 2008 Juergen Beisert, kernel@pengutronix.de
 Based on code from Freescale Semiconductor,
 Authors: Daniel Mack, Juergen Beisert.
 Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
 device type dependent stuff 
 sentinel  }
  MX2 has one interrupt for all gpio ports. The list is used
  to save the references to all ports, so that mx2_gpio_irq_handler
  can walk through all interrupt status registers.
 Note: This driver assumes 32 GPIOs are handled in one register 
 lower or upper register 
 lower or upper register 
 handle 32 interrupts in one status register 
 MX1 and MX3 has one interrupt per gpio port 
 MX2 has one interrupt for all gpio ports 
 walk through all interrupt status registers 
  Set interrupt number "irq" in the GPIO as a wake-up source.
  While system is running, all registered GPIO interrupts need to have
  wake-up enabled. When system is suspended, only selected GPIO interrupts
  need to have wake-up enabled.
  @param  irq          interrupt source number
  @param  enable       enable as wake-up if equal to non-zero
  @return       This function returns 0 on success.
 the controller clock is optional 
 disable the interrupt and clear the status 
		
		  Setup one handler for all GPIO interrupts. Actually setting
		  the handler is needed only once, but doing it for every port
		  is more robust and easier.
 setup one handler for each entry 
 setup handler for GPIO 16 to 31 
 gpio-mxc can be a generic irq chip 
 walk through all ports 
 walk through all ports 
 SPDX-License-Identifier: GPL-2.0
  SAMA5D2 PIOBU GPIO controller
  Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries
  Author: Andrei Stefanescu <andrei.stefanescu@microchip.com>
  backup mode protection register for tamper detection
  normal mode protection register for tamper detection
  wakeup signal generation
 PIOBU offset from SECUMOD base register address. 
 In the datasheet this bit is called OUTPUT 
  sama5d2_piobu_setup_pin() - prepares a pin for set_direction call
  Do not consider pin for tamper detection (normal and backup modes)
  Do not consider pin as tamper wakeup interrupt source
  sama5d2_piobu_write_value() - writes value & mask at the pin's PIOBU register
  sama5d2_piobu_read_value() - read the value with masking from the pin's PIOBU
 			      register
  sama5d2_piobu_get_direction() - gpiochip get_direction
  sama5d2_piobu_direction_input() - gpiochip direction_input
  sama5d2_piobu_direction_output() - gpiochip direction_output
  sama5d2_piobu_get() - gpiochip get
 if pin is input, read value from PDS else read from SOD 
  sama5d2_piobu_set() - gpiochip set
 SPDX-License-Identifier: GPL-2.0-or-later
  GPIO driver for Fintek Super-IO F71869, F71869A, F71882, F71889 and F81866
  Copyright (C) 2010-2013 LaCie
  Author: Simon Guinot <simon.guinot@sequanux.org>
  Super-IO registers
 Logical device select 
 Device ID (2 bytes) 
 Device revision 
 Fintek ID (2 bytes) 
 GPIO logical device 
 Key to enable Super-IO 
 Key to disable Super-IO 
 Manufacturer ID 
 F71869 chipset ID 
 F71869A chipset ID 
 F71882 chipset ID 
 F71889 chipset ID 
 F71889A chipset ID 
 F81866 chipset ID 
 F81804 chipset ID, same for f81966 
 F81865 chipset ID 
  Super-IO functions.
 Don't step on other drivers' IO space by accident. 
 According to the datasheet the key must be send twice. 
  GPIO chip.
 Output mode register (0:open drain 1:push-pull). 
  Platform device and driver.
 For each GPIO bank, register a GPIO chip. 
  Try to match a supported Fintek device by reading the (hard-wired)
  configuration IO ports. If available, then register both the platform
  device and driver to support the GPIOs.
 SPDX-License-Identifier: GPL-2.0-or-later
  Xilinx Zynq GPIO device driver
  Copyright (C) 2009 - 2014 Xilinx, Inc.
 Maximum banks 
 Register offsets for the GPIO device 
 LSW Mask & Data -WO 
 MSW Mask & Data -WO 
 Data Register-RW 
 Direction mode reg-RW 
 Output enable reg-RW 
 Interrupt mask reg-RO 
 Interrupt enable reg-WO 
 Interrupt disable reg-WO 
 Interrupt status reg-RO 
 Interrupt type reg-RW 
 Interrupt polarity reg-RW 
 Interrupt on any, reg-RW 
 Disable all interrupts mask 
 Mid pin number of a bank 
 GPIO upper 16 bit mask 
 set to differentiate zynq from zynqmp, 0=zynqmp, 1=zynq 
  struct zynq_gpio - gpio device private data structure
  @chip:	instance of the gpio_chip
  @base_addr:	base address of the GPIO device
  @clk:	clock resource for this controller
  @irq:	interrupt for the GPIO device
  @p_data:	pointer to platform data
  @context:	context registers
  @dirlock:	lock used for direction inout synchronization
 lock 
  struct zynq_platform_data -  zynq gpio platform data structure
  @label:	string to store in gpio->label
  @quirks:	Flags is used to identify the platform
  @ngpio:	max number of gpio pins
  @max_bank:	maximum number of gpio banks
  @bank_min:	this array represents bank's min pin
  @bank_max:	this array represents bank's max pin
  zynq_gpio_is_zynq - test if HW is zynq or zynqmp
  @gpio:	Pointer to driver data struct
  Return: 0 if zynqmp, 1 if zynq.
  gpio_data_ro_bug - test if HW bug exists or not
  @gpio:       Pointer to driver data struct
  Return: 0 if bug doesnot exist, 1 if bug exists.
  zynq_gpio_get_bank_pin - Get the bank number and pin number within that bank
  for a given pin in the GPIO device
  @pin_num:	gpio pin number within the device
  @bank_num:	an output parameter used to return the bank number of the gpio
 		pin
  @bank_pin_num: an output parameter used to return pin number within a bank
 		  for the given gpio pin
  @gpio:	gpio device data structure
  Returns the bank number and pin offset within the bank.
 default 
  zynq_gpio_get_value - Get the state of the specified pin of GPIO device
  @chip:	gpio_chip instance to be worked on
  @pin:	gpio pin number within the device
  This function reads the state of the specified pin of the GPIO device.
  Return: 0 if the pin is low, 1 if pin is high.
  zynq_gpio_set_value - Modify the state of the pin with specified value
  @chip:	gpio_chip instance to be worked on
  @pin:	gpio pin number within the device
  @state:	value used to modify the state of the specified pin
  This function calculates the register offset (i.e to lower 16 bits or
  upper 16 bits) based on the given pin number and sets the state of a
  gpio pin to the specified value. The state is either 0 or non-zero.
 only 16 data bits in bit maskable reg 
	
	  get the 32 bit value to be written to the maskdata register where
	  the upper 16 bits is the mask and lower 16 bits is the data
  zynq_gpio_dir_in - Set the direction of the specified GPIO pin as input
  @chip:	gpio_chip instance to be worked on
  @pin:	gpio pin number within the device
  This function uses the read-modify-write sequence to set the direction of
  the gpio pin as input.
  Return: 0 always
	
	  On zynq bank 0 pins 7 and 8 are special and cannot be used
	  as inputs.
 clear the bit in direction mode reg to set the pin as input 
  zynq_gpio_dir_out - Set the direction of the specified GPIO pin as output
  @chip:	gpio_chip instance to be worked on
  @pin:	gpio pin number within the device
  @state:	value to be written to specified pin
  This function sets the direction of specified GPIO pin as output, configures
  the Output Enable register for the pin and uses zynq_gpio_set to set
  the state of the pin to the value specified.
  Return: 0 always
 set the GPIO pin as output 
 configure the output enable reg for the pin 
 set the state of the pin 
  zynq_gpio_get_direction - Read the direction of the specified GPIO pin
  @chip:	gpio_chip instance to be worked on
  @pin:	gpio pin number within the device
  This function returns the direction of the specified GPIO.
  Return: GPIO_LINE_DIRECTION_OUT or GPIO_LINE_DIRECTION_IN
  zynq_gpio_irq_mask - Disable the interrupts for a gpio pin
  @irq_data:	per irq and chip data passed down to chip functions
  This function calculates gpio pin number from irq number and sets the
  bit in the Interrupt Disable register of the corresponding bank to disable
  interrupts for that pin.
  zynq_gpio_irq_unmask - Enable the interrupts for a gpio pin
  @irq_data:	irq data containing irq number of gpio pin for the interrupt
 		to enable
  This function calculates the gpio pin number from irq number and sets the
  bit in the Interrupt Enable register of the corresponding bank to enable
  interrupts for that pin.
  zynq_gpio_irq_ack - Acknowledge the interrupt of a gpio pin
  @irq_data:	irq data containing irq number of gpio pin for the interrupt
 		to ack
  This function calculates gpio pin number from irq number and sets the bit
  in the Interrupt Status Register of the corresponding bank, to ACK the irq.
  zynq_gpio_irq_enable - Enable the interrupts for a gpio pin
  @irq_data:	irq data containing irq number of gpio pin for the interrupt
 		to enable
  Clears the INTSTS bit and unmasks the given interrupt.
	
	  The Zynq GPIO controller does not disable interrupt detection when
	  the interrupt is masked and only disables the propagation of the
	  interrupt. This means when the controller detects an interrupt
	  condition while the interrupt is logically disabled it will propagate
	  that interrupt event once the interrupt is enabled. This will cause
	  the interrupt consumer to see spurious interrupts to prevent this
	  first make sure that the interrupt is not asserted and then enable
	  it.
  zynq_gpio_set_irq_type - Set the irq type for a gpio pin
  @irq_data:	irq data containing irq number of gpio pin
  @type:	interrupt type that is to be set for the gpio pin
  This function gets the gpio pin number and its bank from the gpio pin number
  and configures the INT_TYPE, INT_POLARITY and INT_ANY registers.
  Return: 0, negative error otherwise.
  TYPE-EDGE_RISING,  INT_TYPE - 1, INT_POLARITY - 1,  INT_ANY - 0;
  TYPE-EDGE_FALLING, INT_TYPE - 1, INT_POLARITY - 0,  INT_ANY - 0;
  TYPE-EDGE_BOTH,    INT_TYPE - 1, INT_POLARITY - NA, INT_ANY - 1;
  TYPE-LEVEL_HIGH,   INT_TYPE - 0, INT_POLARITY - 1,  INT_ANY - NA;
  TYPE-LEVEL_LOW,    INT_TYPE - 0, INT_POLARITY - 0,  INT_ANY - NA
	
	  based on the type requested, configure the INT_TYPE, INT_POLARITY
	  and INT_ANY registers
 irq chip descriptor 
  zynq_gpio_irqhandler - IRQ handler for the gpio banks of a gpio device
  @desc:	irq descriptor instance of the 'irq'
  This function reads the Interrupt Status Register of each bank to get the
  gpio pin number which has triggered an interrupt. It then acks the triggered
  interrupt and calls the pin specific handler set by the higher layer
  application for that pin.
  Note: A bug is reported if no handler is set for the gpio pin.
	
	  If the device is already active pm_runtime_get() will return 1 on
	  success, but gpio_request still needs to return 0.
 0 to 25 are connected to MIOs (26 pins) 
 Bank 3 is connected to FMIOs (32 pins) 
 0 to 25 are connected to MIOs (26 pins) 
 Bank 1 are connected to MIOs (26 pins) 
 Bank 3 is connected to EMIOs (32 pins) 
 Bank 4 is connected to EMIOs (32 pins) 
 end of table  }
  zynq_gpio_probe - Initialization method for a zynq_gpio device
  @pdev:	platform device instance
  This function allocates memory resources for the gpio device and registers
  all the banks of the device. It will also set up interrupts for the gpio
  pins.
  Note: Interrupts are disabled for all the banks during initialization.
  Return: 0 on success, negative error otherwise.
 configure the gpio chip 
 Retrieve GPIO clock 
 disable interrupts for all banks 
 Set up the GPIO irqchip 
 report a bug if gpio chip registration fails 
  zynq_gpio_remove - Driver removal function
  @pdev:	platform device instance
  Return: 0 always
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) ST-Ericsson SA 2010
  Author: Hanumath Prasad <hanumath.prasad@stericsson.com> for ST-Ericsson
  Author: Rabin Vincent <rabin.vincent@stericsson.com> for ST-Ericsson
  These registers are modified under the irq bus lock and cached to avoid
  unnecessary writes in bus_sync_unlock.
 Caches of interrupt control registers for bus_lock 
	
	  These registers are alterated at each second address
	  ODM bit 0 = drive to GND or Hi-Z (open drain)
	  ODM bit 1 = drive to VDD or Hi-Z (open source)
 Set open drain mode 
 Enable open drainsource mode 
 Set open source mode 
 Enable open drainsource mode 
 Disable open drainsource mode 
 This will let us handle the parent IRQ in the driver 
 Bring the GPIO module out of reset 
	  For tc35894, have to disable Direct KBD interrupts,
	   else IRQST will always be 0x20, IRQN low level, can't
	   clear the irq status.
	   TODO: need more test on other tc3589x chip.
	  
  Copyright (C) 2015 Texas Instruments Incorporated - http:www.ti.com
 	Andrew F. Davis <afd@ti.com>
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether expressed or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License version 2 for more details.
  struct pisosr_gpio - GPIO driver data
  @chip: GPIO controller chip
  @spi: SPI device pointer
  @buffer: Buffer for device reads
  @buffer_size: Size of buffer
  @load_gpio: GPIO pin used to load input into device
  @lock: Protects read sequences
 registers load time (~10ns) 
 registers recovery time (~5ns) 
 This device always input 
 This device always input 
 This device is input only 
 Refresh may not always be needed 
 sentinel  }
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-only
  Philips UCB1400 GPIO driver
  Author: Marek Vasut <marek.vasut@gmail.com>
  Copyright (C) 2015-2017 Broadcom
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 Don't save and restore GIO_REG_STAT 
 assumes MAX_GPIO_PER_BANK is a multiple of 2 
 gc_offset is relative to this gpio_chip; want real offset 
 -------------------- IRQ chip functions -------------------- 
 don't care, but want known value 
	
	  Do not do anything specific for now, suspendresume callbacks will
	  configure the interrupt mask appropriately
 Nothing to do 
 Each UPG GIO block has one IRQ for all banks 
 Interrupts weren't properly cleared during probe 
 banks are in descending order 
  This lock class tells lockdep that GPIO irqs are in a different
  category than their parents, so it won't report false recursion.
 Make sure that the number of banks matches up between properties 
 Remove all IRQ mappings and delete the domain 
	
	  You can lose return values below, but we report all errors, and it's
	  more important to actually perform all of the steps.
 priv->parent_irq and priv->num_gpios must be set before calling 
			
			  Set wakeup capability so we can process boot-time
			  "wakeups" (e.g., from S5 cold boot)
 disable non-wake interrupt 
 Unmask GPIOs which have been flagged as wake-up sources 
 Enable GPIO for S5 cold boot 
 enable non-wake interrupt 
 CONFIG_PM_SLEEP 
	
	  MIPS endianness is configured by boot strap, which also reverses all
	  bus endianness (i.e., big-endian CPU + big endian bus ==> native
	  endian IO).
	 
	  Other architectures (e.g., ARM) either do not support big endian, or
	  else leave IO in little endian mode.
		
		  If bank_width is 0, then there is an empty bank in the
		  register block. Special handling for this case.
		
		  Regs are 4 bytes wide, have data reg, no setclear regs,
		  and direction bits have 0 = output and 1 = input
 not all ngpio lines are valid, will use bank width later 
		
		  Mask all interrupts by default, since wakeup interrupts may
		  be retained from S5 cold boot
 Everything looks good, so add bank to list 
 SPDX-License-Identifier: GPL-2.0
  GPIO driver for AMD 8111 south bridges
  Copyright (c) 2012 Dmitry Eremin-Solenikov
  Based on the AMD RNG driver:
  Copyright 2005 (c) MontaVista Software, Inc.
  with the majority of the code coming from:
  Hardware driver for the IntelAMDVIA Random Number Generators (RNG)
  (c) Copyright 2003 Red Hat Inc <jgarzik@redhat.com>
  derived from
  Hardware driver for the AMD 768 Random Number Generator (RNG)
  (c) Copyright 2001 Red Hat Inc
  derived from
  Hardware driver for Intel i810 Random Number Generator (RNG)
  Copyright 2000,2001 Jeff Garzik <jgarzik@pobox.com>
  Copyright 2000,2001 Philipp Rumpf <prumpf@mandrakesoft.com>
 Latch status, w1 
 Real Time in, ro 
 Debounce, rw 
 Pin Mode Select, rw 
 Enable alternative (e.g. clkout, IRQ, etc) function of the pin 
 Or 0x09 
 InOut specific, rw 
 Active High 
 Latched version is selected 
  Data for PCI driver interface
  This data only exists for exporting the supported
  PCI ids via MODULE_DEVICE_TABLE.  We do not actually
  register a pci_driver, because someone else might one day
  want to register another driver on the same PCI id.
 terminate list 
 guards hw registers and orig table 
	 We look for our device - AMD South Bridge
	  I don't know about a system with two such bridges,
	  so we can assume that there is max. one device.
	 
	  We can't use plain pci_driver mechanism,
	  as the device is really a multiple function device,
	  main driver that binds to the pci_device is an smbus
	  driver and have to find & bind to the device this way.
 Device not found. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2008, 2009 Provigent Ltd.
  Author: Baruch Siach <baruch@tkos.co.il>
  Driver for the ARM PrimeCell(tm) General Purpose InputOutput (PL061)
  Data sheet: ARM DDI 0190B, September 2000
	
	  gpio value is set again, because pl061 doesn't allow to set value of
	  a gpio pin before configuring it in OUT mode.
 Disable edge detection 
 Enable level detection 
 Select polarity 
 Disable level detection 
 Select both edges, setting this makes GPIOEV be ignored 
 Disable level detection 
 Clear detection on both edges 
 Select edge 
 No trigger: disable everything 
  pl061_irq_ack() - ACK an edge IRQ
  @d: IRQ data for this IRQ
  This gets called from the edge IRQ handler to ACK the edge IRQ
  in the GPIOIC (interrupt-clear) register. For level IRQs this is
  not needed: these go away when the level signal goes away.
	
	  irq_chip support
 disable irqs 
 SPDX-License-Identifier: GPL-2.0+
  Access to GPIOs on TWL4030TPS659x0 chips
  Copyright (C) 2006-2007 Texas Instruments, Inc.
  Copyright (C) 2006 MontaVista Software, Inc.
  Code re-arranged and cleaned up by:
 	Syed Mohammed Khasim <x0khasim@ti.com>
  Initial Code:
 	Andy Lowe  Nishanth Menon
  The GPIO "subchip" supports 18 GPIOs which can be configured as
  inputs or outputs, with pullups or pulldowns on each pin.  Each
  GPIO can trigger interrupts on either or both edges.
  GPIO interrupts can be fed to either of two IRQ lines; this is
  intended to support multiple hosts.
  There are also two LED pins used sometimes as output-only GPIOs.
 genirq interfaces are not available to modules 
 GPIO_CTRL Fields 
 Mask for GPIO registers when aggregated into a 32-bit integer 
 Bitfields for state caching 
----------------------------------------------------------------------
  To configure TWL4030 GPIO module registers
----------------------------------------------------------------------
  LED register offsets from TWL_MODULE_LED base
  PWMs A and B are dedicated to LEDs A and B, respectively.
 LEDEN bits 
----------------------------------------------------------------------
  To read a TWL4030 GPIO module register
----------------------------------------------------------------------
 The LED lines are open drain outputs ... a FET pulls to GND, so an
  external pullup is needed.  We could also expose the integrated PWM
  as a LED brightness control; we initialize it as "always on".
----------------------------------------------------------------------
 Support the two LED outputs as output-only GPIOs. 
 initialize PWM to always-drive 
 Configure PWM OFF register first 
 Followed by PWM ON register 
 init LED to not-driven (high) 
 on first use, turn GPIO module "on" 
		 optionally have the first two GPIOs switch vMMC1
		  and vMMC2 power supplies based on card presence.
 on last use, switch off GPIO module 
 LED outputs can't be set as input 
	
	   LED gpios i.e. offset >= TWL4030_GPIO_MAX are always output
	
	  Default GPIO_LINE_DIRECTION_OUT
	  LED GPIOs >= TWL4030_GPIO_MAX are always output
----------------------------------------------------------------------
	 For most pins, a pulldown was enabled by default.
	  We should have data that's specific to this board.
	 30 msec of debouncing is always used for MMC card detect,
	  and is optional for everything else.
 maybe setup IRQs 
	
	  NOTE:  boards may waste power if they don't set pullups
	  and pulldowns correctly ... default for non-ULPI pins is
	  pulldown, and some other pins may have external pullups
	  or pulldowns.  Careful!
	
	  NOTE: we assume VIBRA_CTL.VIBRA_EN, in MODULE_AUDIO_VOICE,
	  is (still) clear if use_leds is set.
 Cannot use as gpio_twl4030_probe() calls us 
 REVISIT no support yet for deregistering all the IRQs 
 Note:  this hardware lives inside an I2C-based multi-function device. 
 SPDX-License-Identifier: GPL-2.0
  ACPI helpers for GPIO API
  Copyright (C) 2012, Intel Corporation
  Authors: Mathias Nyman <mathias.nyman@linux.intel.com>
           Mika Westerberg <mika.westerberg@linux.intel.com>
  struct acpi_gpio_event - ACPI GPIO event handler data
  @node:	  list-entry of the events list of the struct acpi_gpio_chip
  @handle:	  handle of ACPI method to execute when the IRQ triggers
  @handler:	  handler function to pass to request_irq() when requesting the IRQ
  @pin:	  GPIO pin number on the struct gpio_chip
  @irq:	  Linux IRQ number for the event, for request_irq()  free_irq()
  @irqflags:	  flags to pass to request_irq() when requesting the IRQ
  @irq_is_wake:  If the ACPI flags indicate the IRQ is a wakeup source
  @irq_requested:True if request_irq() has been done
  @desc:	  struct gpio_desc for the GPIO pin for this event
	
	  ACPICA requires that the first field of the context parameter
	  passed to acpi_install_address_space_handler() is large enough
	  to hold struct acpi_connection_info.
  For GPIO chips which call acpi_gpiochip_request_interrupts() before late_init
  (so builtin drivers) we register the ACPI GpioInt IRQ handlers from a
  late_initcall_sync() handler, so that other builtin drivers can register their
  OpRegions before the event handlers can run. This list contains GPIO chips
  for which the acpi_gpiochip_request_irqs() call has been deferred.
  acpi_get_gpiod() - Translate ACPI GPIO pin to GPIO descriptor usable with GPIO API
  @path:	ACPI GPIO controller full path name, (e.g. "\\_SB.GPO1")
  @pin:	ACPI GPIO pin number (0-based, controller-relative)
  Return: GPIO descriptor to use with Linux generic GPIO API, or ERR_PTR
  error value. Specifically returns %-EPROBE_DEFER if the referenced GPIO
  controller does not have GPIO chip registered at the moment. This is to
  support probe deferral.
  acpi_get_and_request_gpiod - Translate ACPI GPIO pin to GPIO descriptor and
                               hold a refcount to the GPIO device.
  @path:      ACPI GPIO controller full path name, (e.g. "\\_SB.GPO1")
  @pin:       ACPI GPIO pin number (0-based, controller-relative)
  @label:     Label to pass to gpiod_request()
  This function is a simple pass-through to acpi_get_gpiod(), except that
  as it is intended for use outside of the GPIO layer (in a similar fashion to
  gpiod_get_index() for example) it also holds a reference to the GPIO device.
 The address of this function is used as a key. 
  acpi_gpio_get_io_resource - Fetch details of an ACPI resource if it is a GPIO
 			       IO resource or return False if not.
  @ares:	Pointer to the ACPI resource to fetch
  @agpio:	Pointer to a &struct acpi_resource_gpio to store the output pointer
 Make sure we trigger the initial state of edge-triggered IRQs 
 GpioInt() implies input configuration 
		
		  ACPI GPIO resources don't contain an initial value for the
		  GPIO. Therefore we deduce that value from the pull field
		  and the polarity instead. If the pin is pulled up we assume
		  default to be high, if it is pulled down we assume default
		  to be low, otherwise we leave pin untouched. For active low
		  polarity values will be switched. See also
		  Documentationfirmware-guideacpigpio-properties.rst.
	
	  Assume that the BIOS has configured the direction and pull
	  accordingly.
 Always returns AE_OK so that we keep looping over the resources 
  acpi_gpiochip_request_interrupts() - Register isr for gpio chip ACPI events
  @chip:      GPIO chip
  ACPI5 platforms can use GPIO signaled ACPI events. These GPIO interrupts are
  handled by ACPI event methods which need to be called from the GPIO
  chip's interrupt handler. acpi_gpiochip_request_interrupts() finds out which
  GPIO pins have ACPI event methods and assigns interrupt handlers that calls
  the ACPI event methods for those pins.
  acpi_gpiochip_free_interrupts() - Free GPIO ACPI event interrupts.
  @chip:      GPIO chip
  Free interrupts associated with GPIO ACPI event method for the given
  GPIO chip.
	
	  Check if the BIOS has IoRestriction with explicitly set direction
	  and update @flags accordingly. Otherwise use whatever caller asked
	  for.
		
		  Check if caller supplied incompatible GPIO initialization
		  flags.
		 
		  Return %-EINVAL to notify that firmware has different
		  settings and we are going to use them.
		
		  Polarity and triggering are only specified for GpioInt
		  resource.
		  Note: we expect here:
		  - ACPI_ACTIVE_LOW == GPIO_ACTIVE_LOW
		  - ACPI_ACTIVE_HIGH == GPIO_ACTIVE_HIGH
	
	  The property was found and resolved, so need to lookup the GPIO based
	  on returned args.
  acpi_get_gpiod_by_index() - get a GPIO descriptor from device resources
  @adev: pointer to a ACPI device to get GPIO from
  @propname: Property name of the GPIO (optional)
  @index: index of GpioIoGpioInt resource (starting from %0)
  @info: info pointer to fill in (optional)
  Function goes through ACPI resources for @adev and based on @index looks
  up a GpioIoGpioInt resource, translates it to the Linux GPIO descriptor,
  and returns it. @index matches GpioIoGpioInt resources only so if there
  are total %3 GPIO resources, the index goes from %0 to %2.
  If @propname is specified the GPIO is looked using device property. In
  that case @index is used to select the GPIO entry in the property value
  (in case of multiple).
  If the GPIO cannot be translated or there is an error, an ERR_PTR is
  returned.
  Note: if the GPIO resource has multiple entries in the pin list, this
  function only returns the first.
 Never allow fallback if the device has properties 
 Try first from _DSD 
 Then from plain _CRS GPIOs 
  acpi_node_get_gpiod() - get a GPIO descriptor from ACPI resources
  @fwnode: pointer to an ACPI firmware node to get the GPIO information from
  @propname: Property name of the GPIO
  @index: index of GpioIoGpioInt resource (starting from %0)
  @info: info pointer to fill in (optional)
  If @fwnode is an ACPI device object, call acpi_get_gpiod_by_index() for it.
  Otherwise (i.e. it is a data-only non-device object), use the property-based
  GPIO lookup to get to the GPIO resource with the relevant information and use
  that to obtain the GPIO descriptor to return.
  If the GPIO cannot be translated or there is an error an ERR_PTR is
  returned.
  acpi_dev_gpio_irq_get_by() - Find GpioInt and translate it to Linux IRQ number
  @adev: pointer to a ACPI device to get IRQ from
  @name: optional name of GpioInt resource
  @index: index of GpioInt resource (starting from %0)
  If the device has one or more GpioInt resources, this function can be
  used to translate from the GPIO offset in the resource to the Linux IRQ
  number.
  The function is idempotent, though each time it runs it will configure GPIO
  pin direction according to the flags in GpioInt resource.
  The function takes optional @name parameter. If the resource has a property
  name, then only those will be taken into account.
  Return: Linux IRQ number (> %0) on success, negative errno on failure.
 Ignore -EPROBE_DEFER, it only matters if idx matches 
 Set type if specified and different than the current one 
		
		  The same GPIO can be shared between operation region and
		  event but only if the access here is ACPI_READ. In that
		  case we "borrow" the event GPIO instead.
 Set default fwnode to parent's one if present 
  acpi_gpio_count - count the GPIOs associated with a device  function
  @dev:	GPIO consumer, can be %NULL for system-global GPIOs
  @con_id:	function within the GPIO consumer
  Return:
  The number of GPIOs associated with a device  function or %-ENOENT,
  if no GPIO has been assigned to the requested function.
 Try first from _DSD 
 Then from plain _CRS GPIOs 
 Run deferred acpi_gpiochip_request_irqs() 
 We must use _sync so that this runs after the first deferred_probe run 
		
		  The Minix Neo Z83-4 has a micro-USB-B id-pin handler for
		  a non existing micro-USB-B connector which puts the HDMI
		  DDC pins in GPIO mode, breaking HDMI support.
		
		  The Terra Pad 1061 has a micro-USB-B id-pin handler, which
		  instead of controlling the actual micro-USB-B turns the 5V
		  boost for its USB-A connector off. The actual micro-USB-B
		  connector is wired for charging only.
		
		  The Dell Venue 10 Pro 5055, with Bay Trail SoC + TI PMIC uses an
		  external embedded-controller connected via I2C + an ACPI GPIO
		  event handler on INT33FFC:02 pin 12, causing spurious wakeups.
		
		  HP X2 10 models with Cherry Trail SoC + TI PMIC use an
		  external embedded-controller connected via I2C + an ACPI GPIO
		  event handler on INT33FF:01 pin 0, causing spurious wakeups.
		  When suspending by closing the LID, the power to the USB
		  keyboard is turned off, causing INT0002 ACPI events to
		  trigger once the XHCI controller notices the keyboard is
		  gone. So INT0002 events cause spurious wakeups too. Ignoring
		  EC wakes breaks wakeup when opening the lid, the user needs
		  to press the power-button to wakeup the system. The
		  alternative is suspend simply not working, which is worse.
		
		  HP X2 10 models with Bay Trail SoC + AXP288 PMIC use an
		  external embedded-controller connected via I2C + an ACPI GPIO
		  event handler on INT33FC:02 pin 28, causing spurious wakeups.
		
		  HP X2 10 models with Cherry Trail SoC + AXP288 PMIC use an
		  external embedded-controller connected via I2C + an ACPI GPIO
		  event handler on INT33FF:01 pin 0, causing spurious wakeups.
 Terminating entry 
 Directly after dmi_setup() which runs as core_initcall() 
 SPDX-License-Identifier: GPL-2.0
  Array sizes must ensure 64-bit alignment and not create holes in the
  struct packing.
  Check that uAPI structs are 64-bit aligned for 3264-bit compatibility
 Character device interface to GPIO.
  The GPIO character device, devgpiochipN, provides userspace an
  interface to gpiolib GPIOs via ioctl()s.
  GPIO line handle management
  struct linehandle_state - contains the state of a userspace handle
  @gdev: the GPIO device the handle pertains to
  @label: consumer label used to tag descriptors
  @descs: the GPIO descriptors held by this handle
  @num_descs: the number of descriptors held in the descs array
 Return an error if an unknown flag is set 
	
	  Do not allow both INPUT & OUTPUT flags to be set as they are
	  contradictory.
	
	  Do not allow OPEN_SOURCE & OPEN_DRAIN flags in a single request. If
	  the hardware actually supports enabling both at the same time the
	  electrical result would be disastrous.
 OPEN_DRAIN and OPEN_SOURCE flags only make sense for output mode. 
 Bias flags only allowed for input or output mode. 
 Only one bias flag can be set. 
		
		  Lines have to be requested explicitly for input
		  or output, else the line will be treated "as is".
 NOTE: It's ok to read values of output lines. 
		
		  All line descriptors were created at once with the same
		  flags so just check if the first one is really output.
 Clamp all values to [0,1] 
 Reuse the array setting function 
 label is only initialized if consumer_label is set 
 Request each GPIO 
		
		  Lines have to be requested explicitly for input
		  or output, else the line will be treated "as is".
		
		  fput() will trigger the release() callback, so do not go onto
		  the regular error cleanup path here.
 CONFIG_GPIO_CDEV_V1 
  struct line - contains the state of a requested line
  @desc: the GPIO descriptor for this line.
  @req: the corresponding line request
  @irq: the interrupt triggered in response to events on this GPIO
  @eflags: the edge flags, GPIO_V2_LINE_FLAG_EDGE_RISING andor
  GPIO_V2_LINE_FLAG_EDGE_FALLING, indicating the edge detection applied
  @timestamp_ns: cache for the timestamp storing it between hardirq and
  IRQ thread, used to bring the timestamp close to the actual event
  @req_seqno: the seqno for the current edge event in the sequence of
  events for the corresponding line request. This is drawn from the @req.
  @line_seqno: the seqno for the current edge event in the sequence of
  events for this line.
  @work: the worker that implements software debouncing
  @sw_debounced: flag indicating if the software debouncer is active
  @level: the current debounced physical level of the line
	
	  -- edge detector specific fields --
	
	  eflags is set by edge_detector_setup(), edge_detector_stop() and
	  edge_detector_update(), which are themselves mutually exclusive,
	  and is accessed by edge_irq_thread() and debounce_work_func(),
	  which can both live with a slightly stale value.
	
	  timestamp_ns and req_seqno are accessed only by
	  edge_irq_handler() and edge_irq_thread(), which are themselves
	  mutually exclusive, so no additional protection is necessary.
	
	  line_seqno is accessed by either edge_irq_thread() or
	  debounce_work_func(), which are themselves mutually exclusive,
	  so no additional protection is necessary.
	
	  -- debouncer specific fields --
	
	  sw_debounce is accessed by linereq_set_config(), which is the
	  only setter, and linereq_get_values(), which can live with a
	  slightly stale value.
	
	  level is accessed by debounce_work_func(), which is the only
	  setter, and linereq_get_values() which can live with a slightly
	  stale value.
  struct linereq - contains the state of a userspace line request
  @gdev: the GPIO device the line request pertains to
  @label: consumer label used to tag GPIO descriptors
  @num_lines: the number of lines in the lines array
  @wait: wait queue that handles blocking reads of events
  @event_buffer_size: the number of elements allocated in @events
  @events: KFIFO for the GPIO events
  @seqno: the sequence number for edge events generated on all lines in
  this line request.  Note that this is not used when @num_lines is 1, as
  the line_seqno is then the same and is cheaper to calculate.
  @config_mutex: mutex for serializing ioctl() calls to ensure consistency
  of configuration, particularly multi-step accesses to desc flags.
  @lines: the lines held by this line request, with @num_lines elements.
 Do not leak kernel stack to userspace 
		
		  We may be running from a nested threaded interrupt in
		  which case we didn't get the timestamp from
		  edge_irq_handler().
 Emit low-to-high event 
 Emit high-to-low event 
 Emit low-to-high event 
 Emit high-to-low event 
	
	  Just store the timestamp in hardirq context so we get it as
	  close in time as possible to the actual event.
  returns the current debounced logical value.
	
	  minor race - debouncer may be stopped here, so edge_detector_stop()
	  must leave the value unchanged so the following will read the level
	  from when the debouncer was last running.
 -- edge detection -- 
 switch from physical level to logical - if they differ 
 ignore edges that are not being monitored 
 Do not leak kernel stack to userspace 
 Emit low-to-high event 
 Emit high-to-low event 
 try hardware 
 setup software debounce 
 do not change line->level - see comment in debounced_value() 
 detection disabled or sw debouncer will provide edge detection 
 Request a thread to read the events 
 sw debounced and still will be...
 reconfiguring edge detection or sw debounce being disabled 
 Return an error if an unknown flag is set 
	
	  Do not allow both INPUT and OUTPUT flags to be set as they are
	  contradictory.
 Edge detection requires explicit input. 
	
	  Do not allow OPEN_SOURCE and OPEN_DRAIN flags in a single
	  request. If the hardware actually supports enabling both at the
	  same time the electrical result would be disastrous.
 Drive requires explicit output direction. 
 Bias requires explicit direction. 
 Only one bias flag can be set. 
 debounce requires explicit input 
 NOTE: It's ok to read values of output lines. 
 build compacted desc array and values 
		
		  Lines have to be requested explicitly for input
		  or output, else the line will be treated "as is".
			
			  This should never happen - we were holding the
			  lock from the moment we learned the fifo is no
			  longer empty until now.
 label is only initialized if consumer is set 
 Request each GPIO 
		
		  Lines have to be requested explicitly for input
		  or output, else the line will be treated "as is".
		
		  fput() will trigger the release() callback, so do not go onto
		  the regular error cleanup path here.
  GPIO line event management
  struct lineevent_state - contains the state of a userspace event
  @gdev: the GPIO device the event pertains to
  @label: consumer label used to tag descriptors
  @desc: the GPIO descriptor held by this event
  @eflags: the event flags this line was requested with
  @irq: the interrupt that trigger in response to events on this GPIO
  @wait: wait queue that handles blocking reads of events
  @events: KFIFO for the GPIO events
  @timestamp: cache for the timestamp storing it between hardirq
  and IRQ thread, used to bring the timestamp close to the actual
  event
	
	  When compatible system call is being used the struct gpioevent_data,
	  in case of at least ia32, has different size due to the alignment
	  differences. Because we have first member 64 bits followed by one of
	  32 bits there is no gap between them. The only difference is the
	  padding at the end of the data structure. Hence, we calculate the
	  actual sizeof() and pass this as an argument to copy_to_user() to
	  drop unneeded bytes from the output.
			
			  This should never happen - we were holding the lock
			  from the moment we learned the fifo is no longer
			  empty until now.
	
	  We can get the value for an event line but not set it,
	  because it is input by definition.
 Do not leak kernel stack to userspace 
	
	  We may be running from a nested threaded interrupt in which case
	  we didn't get the timestamp from lineevent_irq_handler().
 Emit low-to-high event 
 Emit high-to-low event 
 Emit low-to-high event 
 Emit high-to-low event 
	
	  Just store the timestamp in hardirq context so we get it as
	  close in time as possible to the actual event.
 Return an error if a unknown flag is set 
 This is just wrong: we don't look for events on output lines 
 Only one bias flag can be set. 
 label is only initialized if consumer_label is set 
 Request a thread to read the events 
		
		  fput() will trigger the release() callback, so do not go onto
		  the regular error cleanup path here.
 CONFIG_GPIO_CDEV_V1 
	
	  This function takes a mutex so we must check this before taking
	  the spinlock.
	 
	  FIXME: find a non-racy way to retrieve this information. Maybe a
	  lock common to both frameworks?
	
	  Userspace only need to know that the kernel is using this GPIO so
	  it can't use it.
  returns 0 if the versions match, else the previously selected ABI version
 this doubles as a range check on line_offset 
  gpio_ioctl() - ioctl handler for the GPIO chardev
 We fail any subsequent ioctl():s when the chip is gone 
 Fill in the struct and pass to userspace 
 CONFIG_GPIO_CDEV_V1 
 must be after kfifo check so watch_abi_version is set 
 We should never get here. See lineevent_read(). 
  gpio_chrdev_open() - open the chardev for ioctl operations
  @inode: inode for this chardev
  @file: file struct for storing private data
  Returns 0 on success
 Fail on open if the backing gpiochip is gone 
  gpio_chrdev_release() - close chardev after ioctl operations
  @inode: inode for this chardev
  @file: file struct for storing private data
  Returns 0 on success
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (C) 2012 John Crispin <john@phrozen.org>
  The Serial To Parallel (STP) is found on MIPS based Lantiq socs. It is a
  peripheral controller used to drive external shift register cascades. At most
  3 groups of 8 bits can be driven. The hardware is able to allow the DSL modem
  to drive the 2 LSBs of the cascade automatically.
 control register 0 
 control register 1 
 data register 0 
 data register 1 
 access register 
 software or hardware update select bit 
 automatic update rates 
 clock source for automatic update 
 let the adsl core drive the 2 LSBs 
 2 groups of 3 bits can be driven by the phys 
 STP has 3 groups of 8 bits 
 Edge configuration bits 
 rising or falling edge triggered shift register 
 shadow the shift registers state 
 we can drive 1-3 groups of 8bit each 
 the 2 LSBs can be driven by the dsl core 
 3 bits can be driven by phy1 
 3 bits can be driven by phy2 
 3 bits can be driven by phy3 
 3 bits can be driven by phy4 
 mask out the hw driven bits in gpio_request 
  xway_stp_get() - gpio_chip->get - get gpios.
  @gc:     Pointer to gpio_chip device structure.
  @gpio:   GPIO signal number.
  Gets the shadow value.
  xway_stp_set() - gpio_chip->set - set gpios.
  @gc:     Pointer to gpio_chip device structure.
  @gpio:   GPIO signal number.
  @val:    Value to be written to specified signal.
  Set the shadow value and call ltq_ebu_apply.
  xway_stp_dir_out() - gpio_chip->dir_out - set gpio direction.
  @gc:     Pointer to gpio_chip device structure.
  @gpio:   GPIO signal number.
  @val:    Value to be written to specified signal.
  Same as xway_stp_set, always returns 0.
  xway_stp_request() - gpio_chip->request
  @gc:     Pointer to gpio_chip device structure.
  @gpio:   GPIO signal number.
  We mask out the HW driven pins
  xway_stp_hw_init() - Configure the STP unit and enable the clock gate
  @chip: Pointer to the xway_stp chip structure
 sane defaults 
 apply edge trigger settings for the shift register 
 apply led group settings 
 tell the hardware which pins are controlled by the dsl modem 
 tell the hardware which pins are controlled by the phys 
 mask out the hw driven bits in gpio_request 
	
	  if we have pins that are driven by hw, we need to tell the stp what
	  clock to use as a timer.
 store the shadow value if one was passed by the devicetree 
 find out which gpio groups should be enabled 
 find out which gpios are controlled by the dsl core 
 find out which gpios are controlled by the phys 
 check which edge trigger we should use, default to a falling edge 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2009-2011 Gabor Juhos <juhosg@openwrt.org>
  Copyright (C) 2013 John Crispin <blogic@openwrt.org>
  struct mtk - state container for
  data of the platform driver. It is 3
  separate gpio-chip each one with its
  own irq_chip.
  @dev: device instance
  @base: memory base address
  @gpio_irq: irq number from the device tree
  @gc_map: array of the gpio chips
		
		  Directly request the irq here instead of passing
		  a flow-handler because the irq is shared.
 This will let us handle the parent IRQ in the driver 
 set polarity to low for all gpios 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2019 American Megatrends International LLC.
  Author: Karthikeyan Mani <karthikeyanm@amiindia.co.in>
  Note: The "value" register returns the input value when the GPIO is
 	 configured as an input.
 	 The "rdata" register returns the output value when the GPIO is
 	 configured as an output.
 acturally if code runs to here, it's an error case 
 input GPIOs are even bits 
	 Since this is an output, read the cached value from rdata, then
	 No special action is required for setting the direction; we'll
 Disable IRQ and clear Interrupt status registers for all SGPIO Pins. 
 disable irq enable bits 
 clear status bits 
 Apply default IRQ settings 
 set falling or level-low irq 
 trigger type is edge 
 single edge trigger 
	
	  From the datasheet,
	 	SGPIO period = 1PCLK  2  (GPIO254[31:16] + 1)
	 	period = 2  (GPIO254[31:16] + 1)  PCLK
	 	frequency = 1  (2  (GPIO254[31:16] + 1)  PCLK)
	 	frequency = PCLK  (2  (GPIO254[31:16] + 1))
	 	frequency  2  (GPIO254[31:16] + 1) = PCLK
	 	GPIO254[31:16] = PCLK  (frequency  2) - 1
 SPDX-License-Identifier: GPL-2.0-only
 GPIO Aggregator
 Copyright (C) 2019-2020 Glider bv
  GPIO Aggregator sysfs interface
 protects idr 
 Named GPIO line 
 GPIO chip + offset(s) 
 kernfs guarantees string termination, so count + 1 is safe 
   GPIO Forwarder
 protects tmp[] if can_sleep 
 protects tmp[] if !can_sleep 
 values and descs for multiple ops 
  gpiochip_fwd_create() - Create a new GPIO forwarder
  @dev: Parent device pointer
  @ngpios: Number of GPIOs in the forwarder.
  @descs: Array containing the GPIO descriptors to forward to.
          This array must contain @ngpios entries, and must not be deallocated
          before the forwarder has been destroyed again.
  This function creates a new gpiochip, which forwards all GPIO operations to
  the passed GPIO descriptors.
  Return: An opaque object pointer, or an ERR_PTR()-encoded negative error
          code on failure.
	
	  If any of the GPIO lines are sleeping, then the entire forwarder
	  will be sleeping.
	  If any of the chips support .set_config(), then the forwarder will
	  support setting configs.
   GPIO Aggregator platform device
	
	  Add GPIO-operated devices controlled from userspace below,
	  or use "driver_override" in sysfs
 SPDX-License-Identifier: GPL-2.0-only
  TINational Semiconductor LP3943 GPIO driver
  Copyright 2013 Texas Instruments
  Author: Milo Kim <milo.kim@ti.com>
 1 = GPIO is input direction, 0 = output 
 Return an error if the pin is already assigned 
	
	  Limitation:
	    LP3943 doesn't have the GPIO direction register. It provides
	    only input and output status registers.
	    So, direction info is required to handle the 'get' operation.
	    This variable is updated whenever the direction is changed and
	    it is used here.
 SPDX-License-Identifier: GPL-2.0-only
  Driver for PCA9570 I2C GPO expander
  Copyright (C) 2020 Sungbo Eo <mans0n@gorani.run>
  Based on gpio-tpic2810.c
  Copyright (C) 2015 Texas Instruments Incorporated - http:www.ti.com
 	Andrew F. Davis <afd@ti.com>
  struct pca9570 - GPIO driver data
  @chip: GPIO controller chip
  @lock: Protects write sequences
  @out: Buffer for device register
 This device always output 
 Read the current output level 
 sentinel  }
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2019 SiFive
 Switch to input 
 Clear any sticky pending interrupts 
 Enable interrupts 
 Clear all pending interrupts 
 Disable all GPIO interrupts before enabling parent interrupts 
 SPDX-License-Identifier: GPL-2.0-or-later
  GPIO driver for Analog Devices ADP5520 MFD PMICs
  Copyright 2009 Analog Devices Inc.
	
	  There are dedicated registers for GPIO INOUT.
	  Make sure we return the right value, even when configured as output
  GPIOs on MPC512x834985728610QorIQ and compatible
  Copyright (C) 2008 Peter Korsgaard <jacmet@sunsite.dk>
  Copyright (C) 2016 Freescale Semiconductor Inc.
  This file is licensed under the terms of the GNU General Public License
  version 2.  This program is licensed "as is" without any warranty of any
  kind, whether express or implied.
  This hardware has a big endian bit assignment such that GPIO line 0 is
  connected to bit 31, line 1 to bit 30 ... line 31 to bit 0.
  This inline helper give the right bitmask for a certain line.
 Workaround GPIO 1 errata on MPC8572MPC8536. The status of GPIOs
  defined as output cannot be determined by reading GPDAT register,
  so we use shadow data register instead. The status of input pins
  is determined by reading GPDAT register.
 GPIO 28..31 are input only on MPC5121 
 GPIO 0..3 are input only on MPC5125 
 this might get overwritten in mpc8xxx_probe() 
	
	  It's assumed that only a single type of gpio controller is available
	  on the current machine, so overwriting global data is fine.
	
	  The GPIO Input Buffer Enable register(GPIO_IBE) is used to control
	  the input enable of each individual GPIO port.  When an individual
	  GPIO ports direction is set to input (GPIO_GPDIR[DRn=0]), the
	  associated input enable must be set (GPIOxGPIE[IEn]=1) to propagate
	  the port value to the GPIO Data Register.
 ack and mask all irqs 
 SPDX-License-Identifier: GPL-2.0-or-later
  GPIO Chip driver for Analog Devices
  ADP5588ADP5587 IO Expander and QWERTY Keypad Controller
  Copyright 2009-2010 Analog Devices Inc.
  Early pre 4.0 Silicon required to delay readout by at least 25ms,
  since the Event Counter Register updated 25ms after the interrupt
  asserted.
 protect cached dir, dat_out 
 protect serialized access to the interrupt controller bus 
   genirq core code can issue chip->maskunmask from atomic context.
   This doesn't work for slow busses where an access needs to sleep.
   bus_sync_unlock() is therefore called outside the atomic context,
   syncs the current irq mask state with the slow external controller
   and unlocks the bus.
				 GPIN events begin at 97,
				  bit 7 indicates logic level
 Status is W1C 
 Enable IRQs after registering chip 
 status is W1C 
 This will be registered in the call to devm_gpiochip_add_data() 
 This will let us handle the parent IRQ in the driver 
 CONFIG_GPIO_ADP5588_IRQ 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2015 Texas Instruments Incorporated - http:www.ti.com
 	Andrew F. Davis <afd@ti.com>
  Based on the TPS65912 driver
 This device is output only 
 This device is output only 
 Set the initial value 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 ROHM Semiconductors
 gpio-bd70528.c ROHM BD70528MWV gpio driver
 Do we need to do something to IRQs here? 
 Do we need to do something to IRQs here? 
	
	  There is a race condition where someone might be changing the
	  GPIO direction after we get it but before we read the value. But
	  application design where GPIO direction may be changed just when
	  we read GPIO value would be pointless as reader could not know
	  whether the returned highlow state is caused by input or output.
	  Or then there must be other ways to mitigate the issue. Thus
	  locking would make no sense.
 SPDX-License-Identifier: GPL-2.0
  Intel Merrifield SoC GPIO driver
  Copyright (c) 2016 Intel Corporation.
  Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
 controller configuration 
 pin level ro 
 pin direction 
 pin set wo 
 pin clear wo 
 rising edge detect 
 falling edge detect 
 glitch filter bypass 
 interrupt mask 
 interrupt source 
 input type 
 level input polarity 
 wake mask 
 wake source 
 secure input 
 Intel Merrifield has 192 GPIO pins 
	
	  To prevent glitches from triggering an unintended level interrupt,
	  configure GLPR register first and then configure GITR.
 Clear the existing wake status 
 Check GPIO controller to check which pin triggered the interrupt 
 Only interrupts that are enabled 
 Clear the rising-edge detect register 
 Clear the falling-edge detect register 
 Release the IO mapping, since we already get the info from BAR1 
 SPDX-License-Identifier: GPL-2.0 
  devres.c - managed gpio resources
  This file is based on kernelirqdevres.c
  Copyright (c) 2011 John Crispin <john@phrozen.org>
  devm_gpiod_get - Resource-managed gpiod_get()
  @dev:	GPIO consumer
  @con_id:	function within the GPIO consumer
  @flags:	optional GPIO initialization flags
  Managed gpiod_get(). GPIO descriptors returned from this function are
  automatically disposed on driver detach. See gpiod_get() for detailed
  information about behavior and return values.
  devm_gpiod_get_optional - Resource-managed gpiod_get_optional()
  @dev: GPIO consumer
  @con_id: function within the GPIO consumer
  @flags: optional GPIO initialization flags
  Managed gpiod_get_optional(). GPIO descriptors returned from this function
  are automatically disposed on driver detach. See gpiod_get_optional() for
  detailed information about behavior and return values.
  devm_gpiod_get_index - Resource-managed gpiod_get_index()
  @dev:	GPIO consumer
  @con_id:	function within the GPIO consumer
  @idx:	index of the GPIO to obtain in the consumer
  @flags:	optional GPIO initialization flags
  Managed gpiod_get_index(). GPIO descriptors returned from this function are
  automatically disposed on driver detach. See gpiod_get_index() for detailed
  information about behavior and return values.
	
	  For non-exclusive GPIO descriptors, check if this descriptor is
	  already under resource management by this device.
  devm_gpiod_get_from_of_node() - obtain a GPIO from an OF node
  @dev:	device for lifecycle management
  @node:	handle of the OF node
  @propname:	name of the DT property representing the GPIO
  @index:	index of the GPIO to obtain for the consumer
  @dflags:	GPIO initialization flags
  @label:	label to attach to the requested GPIO
  Returns:
  On successful request the GPIO pin is configured in accordance with
  provided @dflags.
  In case of error an ERR_PTR() is returned.
	
	  For non-exclusive GPIO descriptors, check if this descriptor is
	  already under resource management by this device.
  devm_fwnode_gpiod_get_index - get a GPIO descriptor from a given node
  @dev:	GPIO consumer
  @fwnode:	firmware node containing GPIO reference
  @con_id:	function within the GPIO consumer
  @index:	index of the GPIO to obtain in the consumer
  @flags:	GPIO initialization flags
  @label:	label to attach to the requested GPIO
  GPIO descriptors returned from this function are automatically disposed on
  driver detach.
  On successful request the GPIO pin is configured in accordance with
  provided @flags.
  devm_gpiod_get_index_optional - Resource-managed gpiod_get_index_optional()
  @dev: GPIO consumer
  @con_id: function within the GPIO consumer
  @index: index of the GPIO to obtain in the consumer
  @flags: optional GPIO initialization flags
  Managed gpiod_get_index_optional(). GPIO descriptors returned from this
  function are automatically disposed on driver detach. See
  gpiod_get_index_optional() for detailed information about behavior and
  return values.
  devm_gpiod_get_array - Resource-managed gpiod_get_array()
  @dev:	GPIO consumer
  @con_id:	function within the GPIO consumer
  @flags:	optional GPIO initialization flags
  Managed gpiod_get_array(). GPIO descriptors returned from this function are
  automatically disposed on driver detach. See gpiod_get_array() for detailed
  information about behavior and return values.
  devm_gpiod_get_array_optional - Resource-managed gpiod_get_array_optional()
  @dev:	GPIO consumer
  @con_id:	function within the GPIO consumer
  @flags:	optional GPIO initialization flags
  Managed gpiod_get_array_optional(). GPIO descriptors returned from this
  function are automatically disposed on driver detach.
  See gpiod_get_array_optional() for detailed information about behavior and
  return values.
  devm_gpiod_put - Resource-managed gpiod_put()
  @dev:	GPIO consumer
  @desc:	GPIO descriptor to dispose of
  Dispose of a GPIO descriptor obtained with devm_gpiod_get() or
  devm_gpiod_get_index(). Normally this function will not be called as the GPIO
  will be disposed of by the resource management code.
  devm_gpiod_unhinge - Remove resource management from a gpio descriptor
  @dev:	GPIO consumer
  @desc:	GPIO descriptor to remove resource management from
  Remove resource management from a GPIO descriptor. This is needed when
  you want to hand over lifecycle management of a descriptor to another
  mechanism.
	
	  If the GPIO descriptor is requested as nonexclusive, we
	  may call this function several times on the same descriptor
	  so it is OK if devres_destroy() returns -ENOENT.
 Anything else we should warn about 
  devm_gpiod_put_array - Resource-managed gpiod_put_array()
  @dev:	GPIO consumer
  @descs:	GPIO descriptor array to dispose of
  Dispose of an array of GPIO descriptors obtained with devm_gpiod_get_array().
  Normally this function will not be called as the GPIOs will be disposed of
  by the resource management code.
       devm_gpio_request - request a GPIO for a managed device
       @dev: device to request the GPIO for
       @gpio: GPIO to allocate
       @label: the name of the requested GPIO
       Except for the extra @dev argument, this function takes the
       same arguments and performs the same function as
       gpio_request().  GPIOs requested with this function will be
       automatically freed on driver detach.
       If an GPIO allocated with this function needs to be freed
       separately, devm_gpio_free() must be used.
 	devm_gpio_request_one - request a single GPIO with initial setup
 	@dev:   device to request for
 	@gpio:	the GPIO number
 	@flags:	GPIO configuration as specified by GPIOF_
 	@label:	a literal description string of this GPIO
       devm_gpio_free - free a GPIO
       @dev: device to free GPIO for
       @gpio: GPIO to free
       Except for the extra @dev argument, this function takes the
       same arguments and performs the same function as gpio_free().
       This function instead of gpio_free() should be used to manually
       free GPIOs allocated with devm_gpio_request().
  devm_gpiochip_add_data_with_key() - Resource managed gpiochip_add_data_with_key()
  @dev: pointer to the device that gpio_chip belongs to.
  @gc: the GPIO chip to register
  @data: driver-private data associated with this chip
  @lock_key: lockdep class for IRQ lock
  @request_key: lockdep class for IRQ request
  Context: potentially before irqs will work
  The gpio chip automatically be released when the device is unbound.
  Returns:
  A negative errno if the chip can't be registered, such as because the
  gc->base is invalid or already associated with a different chip.
  Otherwise it returns zero as a success code.
 SPDX-License-Identifier: GPL-2.0-only
 Copyright (C) 2018 ROHM Semiconductors
	
	  The HALL input pin can only be used as input. If this is the pin
	  we are dealing with - then we are done
	
	  Pin usage is selected by OTP data. We can't read it runtime. Hence
	  we trust that if the pin is not excluded by "gpio-reserved-ranges"
	  the OTP configuration is set to OUT. (Other pins but HALL input pin
	  on BD71828 can't really be used for general purpose input - input
	  states are used for specific cases like regulator control or
	  PMIC_ON_REQ.
	
	  See if we need some implementation to mark some PINs as
	  not controllable based on DT info or if core can handle
	  "gpio-reserved-ranges" and exclude them from control
  Copyright (C) 2017 Texas Instruments Incorporated - http:www.ti.com
 	Keerthy <j-keerthy@ti.com>
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether expressed or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License version 2 for more details.
  Based on the LP873X driver
		
		  MUX can program the pin to be in EN123 pin mode
		  Or GPIO123 mode.
		  Setup the GPIO_SEL MUX to GPIO mode
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Copyright 2017-2018 Cadence
  Authors:
   Jan Kotas <jank@cadence.com>
   Boris Brezillon <boris.brezillon@free-electrons.com>
	
	  The GPIO controller doesn't have an ACK register.
	  All interrupt statuses are cleared on a status register read.
	  Don't support edge interrupts for now.
	
	  Set all pins as inputs by default, otherwise:
	  gpiochip_lock_as_irq:
	  tried to flag a GPIO set as output for IRQ
	  Generic GPIO driver stores the direction value internally,
	  so it needs to be changed before bgpio_init() is called.
	
	  Optional irq_chip support
	
	  Enable gpio outputs, ignored for input direction
 sentinel  },
 SPDX-License-Identifier: GPL-2.0-or-later
  gpiolib support for Wolfson Arizona class devices
  Copyright 2012 Wolfson Microelectronics PLC.
  Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 Resume to read actual registers for input pins 
 Register is cached, drop it to ensure a physical read 
 SPDX-License-Identifier: GPL-2.0+
  GPIO interface for Winbond Super IO chips
  Currently, only W83627UHG (Nuvoton NCT6627UD) is supported.
  Author: Maciej S. Szmigiero <mail@maciej.szmigiero.name>
 global chip registers 
 not an actual device number, just a value meaning 'no device' 
 registers with offsets >= 0x30 are specific for a particular device 
 UART B logical device 
 UART C logical device 
 GPIO3, GPIO4 logical device 
 WDTO, PLED, GPIO5, GPIO6 logical device 
 GPIO1, GPIO2, SUSLED logical device 
 UART D logical device 
 UART E logical device 
  for a description what a particular field of this struct means please see
  a description of the relevant module parameter at the bottom of this file
	
	  datasheet says two successive writes of the "key" value are needed
	  in order for chip to enter the "Extended Function Mode"
  struct winbond_gpio_port_conflict - possibly conflicting device information
  @name:	device name (NULL means no conflicting device defined)
  @dev:	Super IO logical device number where the testreg register
 		is located (or WB_SIO_DEV_NONE - don't select any
 		logical device)
  @testreg:	register number where the testbit bit is located
  @testbit:	index of a bit to check whether an actual conflict exists
  @warnonly:	if set then a conflict isn't fatal (just warn about it),
 		otherwise disable the particular GPIO port if a conflict
 		is detected
  struct winbond_gpio_info - information about a particular GPIO port (device)
  @dev:		Super IO logical device number of the registers
 			specified below
  @enablereg:		port enable bit register number
  @enablebit:		index of a port enable bit
  @outputreg:		output driver mode bit register number
  @outputppbit:	index of a push-pull output driver mode bit
  @ioreg:		data direction register number
  @invreg:		pin data inversion register number
  @datareg:		pin data register number
  @conflict:		description of a device that possibly conflicts with
 			this port
 0 
 1 
 special conflict handling so doesn't use conflict data 
 2 
 3 
 4 
 5 
 returns whether changing a pin is allowed 
	
	  GPIO2 (the second port) shares some pins with a basic PC
	  functionality, which is very likely controlled by the firmware.
	  Don't allow changing these pins by default.
 is there a possible conflicting device defined? 
 GPIO1 and GPIO2 need some (additional) special handling 
	
	  if the 'base' module parameter is unset probe two chip default
	  IO port bases
	
	  Add 8 gpios for every GPIO port that was enabled in gpios
	  module parameter (that wasn't disabled earlier in
	  winbond_gpio_configure() & co. due to, for example, a pin conflict).
	
	  GPIO6 port has only 5 pins, so if it is enabled we have to adjust
	  the total count appropriately
 This parameter sets which GPIO devices (ports) we enable 
  These two parameters below set how we configure GPIO ports output drivers.
  It can't be a one bitmask since we need three values per port: push-pull,
  open-drain and keep as-is (this is the default).
  GPIO2.0 and GPIO2.1 control a basic PC functionality that we
  don't allow tinkering with by default (it is very likely that the
  firmware owns these pins).
  These two parameters below allow overriding these prohibitions.
 SPDX-License-Identifier: GPL-2.0-only
  linuxarcharmmach-sa1100gpio.c
  Generic SA-1100 GPIO handling
  SA1100 GPIO edge detection for IRQs:
  IRQs are generated on Falling-Edge, Rising-Edge, or both.
  Use this instead of directly setting GRERGFER.
  GPIO IRQs must be acknowledged.
  This is for GPIO IRQs
  IRQ 0-11 (GPIO) handler.  We enter here with the
  irq_controller_lock held, and IRQs disabled.  Decode the IRQ
  and call the handler.
		
		  clear down all currently active IRQ sources.
		  We will be processing them all.
	
	  Set the appropriate edges for wakeup.
	
	  Clear any pending GPIO interrupts.
 Install handlers for GPIO 0-10 edge detect interrupts 
 Install handler for GPIO 11-27 edge detect interrupts 
 clear all GPIO edge detects 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 Spreadtrum Communications Inc.
  Copyright (C) 2018 Linaro Ltd.
 EIC registers definition 
  The PMIC EIC controller only has one bank, and each bank now can contain
  16 EICs.
  These registers are modified under the irq bus lock and cached to avoid
  unnecessary writes in bus_sync_unlock.
  struct sprd_pmic_eic - PMIC EIC controller
  @chip: the gpio_chip structure.
  @intc: the irq_chip structure.
  @map:  the regmap from the parent device.
  @offset: the EIC controller's offset address of the PMIC.
  @reg: the array to cache the EIC registers.
  @buslock: for bus locksync and unlock.
  @irq: the interrupt number of the PMIC EIC conteroller.
 EICs are always input, nothing need to do here. 
 EICs are always input, nothing need to do here. 
		
		  Will set the trigger level according to current EIC level
		  in irq_bus_sync_unlock() interface, so here nothing to do.
 Set irq type 
 Set irq unmask 
 Generate trigger start pulse for debounce EIC 
 Set irq unmask 
 Generate trigger start pulse for debounce EIC 
 Clear the interrupt 
		
		  The PMIC EIC can only support level trigger, so we can
		  toggle the level trigger to emulate the edge trigger.
 end of list  }
 SPDX-License-Identifier: GPL-2.0+
   Driver for NEC VR4100 series General-purpose IO Unit.
   Copyright (C) 2002 MontaVista Software Inc.
 	Author: Yoichi Yuasa <source@mvista.com>
   Copyright (C) 2003-2009  Yoichi Yuasa <yuasa@linux-mips.org>
 Satisfy the .enable semantics by unmasking the line 
 SPDX-License-Identifier: GPL-2.0
   GPIO interface for Intel Sodaville SoCs.
   Copyright (c) 2010, 2011 Intel Corporation
   Author: Hans J. Koch <hjk@linutronix.de>
 mask + ACK all interrupt sources 
	
	  This gpio irq controller latches level irqs. Testing shows that if
	  we unmask & ACK the IRQ before the source of the interrupt is gone
	  then the interrupt is active again.
 SPDX-License-Identifier: GPL-2.0
  Lock to serialise gpiod export and unexport, and prevent re-export of
  gpiod whose chip is being unregistered.
  sysclassgpiogpioN... only for GPIOs that are exported
    direction
        MAY BE OMITTED if kernel won't allow direction changes
        is readwrite as "in" or "out"
        may also be written as "high" or "low", initializing
         output value as specified ("out" implies "low")
    value
        always readable, subject to hardware behavior
        may be writable, as zerononzero
    edge
        configures behavior of poll(2) on value
        available only if pin can generate IRQs on input
        is readwrite as "none", "falling", "rising", or "both"
    active_low
        configures polarity of value
        is readwrite as zerononzero
        also affects existing and subsequent "falling" and "rising"
         edge configuration
 Caller holds gpiod-data mutex. 
	
	  FIXME: This should be done in the irq_request_resources callback
	         when the irq is requested, but a few drivers currently fail
	         to do so.
	 
	         Remove this redundant call (along with the corresponding
	         unlock) when those drivers have been fixed.
  Caller holds gpiod-data mutex (unless called after class-device
  deregistration).
 Caller holds gpiod-data mutex. 
 reconfigure poll(2) support if enabled on one edge only 
  sysclassgpiogpiochipN
    base ... matching gpio_chip.base (N)
    label ... matching gpio_chip.label
    ngpio ... matching gpio_chip.ngpio
  sysclassgpioexport ... write-only
 	integer N ... number of GPIO to export (full access)
  sysclassgpiounexport ... write-only
 	integer N ... number of GPIO to unexport
 reject invalid GPIOs 
	 No extra locking here; FLAG_SYSFS just signifies that the
	  request and export were done by on behalf of userspace, so
	  they may be undone on its behalf too.
 reject bogus commands (gpio_unexport ignores them) 
	 No extra locking here; FLAG_SYSFS just signifies that the
	  request and export were done by on behalf of userspace, so
	  they may be undone on its behalf too.
  gpiod_export - export a GPIO through sysfs
  @desc: GPIO to make available, already requested
  @direction_may_change: true if userspace may change GPIO direction
  Context: arch_initcall or later
  When drivers want to make a GPIO accessible to userspace after they
  have requested it -- perhaps while debugging, or as part of their
  public interface -- they may use this routine.  If the GPIO can
  change direction (some can't) and the caller allows it, userspace
  will see "direction" sysfs attribute which may be used to change
  the gpio's direction.  A "value" attribute will always be provided.
  Returns zero on success, else an error.
 can't export until sysfs is available ... 
 check if chip is being removed 
  gpiod_export_link - create a sysfs link to an exported GPIO node
  @dev: device under which to create symlink
  @name: name of the symlink
  @desc: GPIO to create symlink to, already exported
  Set up a symlink from sys...devname to sysclassgpiogpioN
  node. Caller is responsible for unlinking.
  Returns zero on success, else an error.
  gpiod_unexport - reverse effect of gpiod_export()
  @desc: GPIO to make unavailable
  This is implicit on gpiod_free().
	
	  Release irq after deregistration to prevent race with edge_store.
	
	  Many systems add gpio chips for SOC support very early,
	  before driver model support is available.  In those cases we
	  register later, in gpiolib_sysfs_init() ... here we just
	  verify that _some_ field of gpio_class got initialized.
	
	  For sysfs backward compatibility we need to preserve this
	  preferred parenting to the gpio_chip parent field, if set.
 use chip->base for the ID; it's already known to be unique 
 prevent further gpiod exports 
 unregister gpiod class devices owned by sysfs 
	 Scan and register the gpio_chips which registered very
	  early (e.g. before the class_register above was called).
	 
	  We run before arch_initcall() so chip->dev nodes can have
	  registered, and so arch_initcall() can always gpio_export().
		
		  TODO we yield gpio_lock here because
		  gpiochip_sysfs_register() acquires a mutex. This is unsafe
		  and needs to be fixed.
		 
		  Also it would be nice to use gpiochip_find() here so we
		  can keep gpio_chips local to gpiolib.c, but the yield of
		  gpio_lock prevents us from doing this.
  GPIO driver for Marvell SoCs
  Copyright (C) 2012 Marvell
  Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  Andrew Lunn <andrew@lunn.ch>
  Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2.  This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
  This driver is a fairly straightforward GPIO driver for the
  complete family of Marvell EBU SoC platforms (Orion, Dove,
  Kirkwood, Discovery, Armada 370XP). The only complexity of this
  driver is the different register layout that exists between the
  non-SMP platforms (Orion, Dove, Kirkwood, Armada 370) and the SMP
  platforms (MV78200 from the Discovery family and the Armada
  XP). Therefore, this driver handles three variants of the GPIO
  block:
  - the basic variant, called "orion-gpio", with the simplest
    register set. Used on Orion, Dove, Kirkwoord, Armada 370 and
    non-SMP Discovery systems
  - the mv78200 variant for MV78200 Discovery systems. This variant
    turns the edge mask and level mask registers into CPU0 edge
    masklevel mask registers, and adds CPU1 edge masklevel mask
    registers.
  - the armadaxp variant for Armada XP systems. This variant keeps
    the normal causeedge masklevel mask registers when the global
    interrupts are used, but adds per-CPU causeedge masklevel mask
    registers n a separate memory area for the per-CPU GPIO
    interrupts.
  GPIO unit register offsets.
  PWM register offsets.
 Armada 8k variant gpios register offsets 
 The MV78200 has per-CPU registers for edge mask and level mask 
  The Armada XP has per-CPU registers for interrupt cause, interrupt
  mask and interrupt level mask. Those are in percpu_regs range.
 Used to preserve GPIOPWM registers across suspendresume 
 Used for PWM support 
 Used to preserve GPIO registers across suspendresume 
  Functions returning addresses of individual registers for a given
  GPIO controller.
  Functions returning offsets of individual registers for a given
  PWM controller.
  Functions implementing the gpio_chip methods
	
	  Check with the pinctrl driver whether this pin is usable as
	  an input GPIO
	
	  Check with the pinctrl driver whether this pin is usable as
	  an output GPIO
  Functions implementing the irq_chip methods
  MVEBU GPIO IRQ
  GPIO_IN_POL register controls whether GPIO_DATA_IN will hold the same
  value of the line or the opposite value.
  Level IRQ handlers: DATA_IN is used directly as cause register.
 		       Interrupt are masked by LEVEL_MASK registers.
  Edge IRQ handlers:  Change in DATA_IN are latched in EDGE_CAUSE.
 		       Interrupt are masked by EDGE_MASK registers.
  Both-edge handlers: Similar to regular Edge handlers, but also swaps
 		       the polarity to catch the next line transaction.
 		       This is a race condition that might not perfectly
 		       work on some use cases.
  Every eight GPIO lines are grouped (OR'ed) before going up to main
  cause register.
 		      EDGE  cause    mask
 	  data-in   --------| |-----| |----\
      -----| |-----			     ---- to main cause reg
 	     X	    \----------------| |----
 	  polarity    LEVEL	     mask
 Check if we need to change chip and handler 
	
	  Configure interrupt polarity.
		
		  set initial polarity based on current input level
 falling 
 raising 
 Swap polarity (race with GPIO line) 
  Functions implementing the pwm_chip methods
 Hardware treats zero as 2^32. See mvebu_pwm_apply(). 
 period = on + off duration 
	
	  Zero onoff values don't work as expected. Experimentation shows
	  that zero value is treated as 2^32. This behavior is not documented.
		
		  There are only two sets of PWM configuration registers for
		  all the GPIO lines on those SoCs which this driver reserves
		  for the first two GPIO chips. So if the resource is missing
		  we can't treat it as an error.
 Blink counter A 
 Blink counter B 
		
		  Use set A for lines of GPIO chip with id 0, B for GPIO chip
		  with id 1. Don't allow further GPIO chips to be used for PWM.
	
	  There may already be some PWM allocated, so we can't force
	  mvpwm->chip.base to a fixed point like mvchip->chip.base.
	  So, we let pwmchip_add() do the numbering and take the next free
	  region.
 sentinel 
	
	  For the legacy SoCs, the regmap directly maps to the GPIO
	  registers, so no offset is needed.
	
	  The Armada XP has a second range of registers for the
	  per-CPU registers
 Some gpio controllers do not provide irq support 
 Not all SoCs require a clock.
	
	  Mask and clear GPIO interrupts.
 Some MVEBU SoCs have simple PWM support for GPIO lines 
 Some gpio controllers do not provide irq support 
	
	  NOTE: The common accessors cannot be used because of the percpu
	  access to the mask registers
	
	  Setup the interrupt handlers. Each chip can have up to 4
	  interrupt handlers, with each handler dealing with 8 GPIO
	  pins.
 SPDX-License-Identifier: GPL-2.0-only
  GPIO driver for the ACCES 104-IDI-48 family
  Copyright (C) 2015 William Breathitt Gray
  This driver supports the following ACCES devices: 104-IDI-48A,
  104-IDI-48AC, 104-IDI-48B, and 104-IDI-48BC.
  struct idi_48_gpio - GPIO device private data structure
  @chip:	instance of the gpio_chip
  @lock:	synchronization lock to prevent IO race conditions
  @ack_lock:	synchronization lock to prevent IRQ handler race conditions
  @irq_mask:	input bits affected by interrupts
  @base:	base port address of the GPIO device
  @cos_enb:	Change-Of-State IRQ enable boundaries mask
 The following line should never execute since offset < 48 
 clear bits array to a clean slate 
 The only valid irq types are none and both-edges 
 IRQ Status (bit 6) is active low (0 = IRQ generated by device) 
 Bit 0-5 indicate which Change-Of-State boundary triggered the IRQ 
 Disable IRQ by default 
 This will let us handle the parent IRQ in the driver 
 SPDX-License-Identifier: GPL-2.0
 IXP4 GPIO driver
 Copyright (C) 2019 Linus Walleij <linus.walleij@linaro.org>
 based on previous work and know-how from:
 Deepak Saxena <dsaxena@plexity.net>
 Include that go away with DT transition 
  The hardware uses 3 bits to indicate interrupt "style".
  we clear and set these three bits accordingly. The lower 24
  bits in two registers (GPIT1 and GPIT2) are used to set up
  the style for 8 lines each for a total of 16 GPIO lines.
  struct ixp4xx_gpio - IXP4 GPIO state container
  @dev: containing device for this instance
  @fwnode: the fwnode for this GPIO chip
  @gc: gpiochip for this instance
  @base: remapped IO-memory base
  @irq_edge: Each bit represents an IRQ: 1: edge-triggered,
  0: level triggered
 ACK when unmasking if not edge-triggered 
 pins 8-15 
 pins 0-7 
 Clear the style for the appropriate pin 
 Set the new style 
 Force-configure this line as an input 
 This parent only accept level high (asserted) 
 All these interrupts are level high in the CPU 
 GPIO lines 0..12 have dedicated IRQs 
	
	  When we convert to device tree we will simply look up the
	  parent irqdomain using irq_find_host(parent) as parent comes
	  from IRQCHIP_DECLARE(), then use of_node_to_fwnode() to get
	  the fwnode. For now we need this boardfile style code.
	
	  Make sure GPIO 14 and 15 are NOT used as clocks but GPIO on
	  specific machines.
	
	  This is a very special big-endian ARM issue: when the IXP4xx is
	  run in big endian mode, all registers in the machine are switched
	  around to the CPU-native endianness. As you see mostly in the
	  driver we use __raw_readl()__raw_writel() to access the registers
	  in the appropriate order. With the GPIO library we need to specify
	  byte order explicitly, so this flag needs to be set when compiling
	  for big endian.
 Populate and register gpio chip 
	
	  TODO: when we have migrated to device tree and all GPIOs
	  are fetched using phandles, set this to -1 to get rid of
	  the fixed gpiochip base.
 SPDX-License-Identifier: GPL-2.0-only
  GPIO controller in LSI ZEVIO SoCs.
  Author: Fabian Vogt <fabian@ritter-vogt.de>
  Memory layout:
  This chip has four gpio sections, each controls 8 GPIOs.
  Bit 0 in section 0 is GPIO 0, bit 2 in section 1 is GPIO 10.
  Disclaimer: Reverse engineered!
  For more information refer to:
  http:hackspire.unsads.comwikiindex.phpMemory-mapped_IO_ports#90000000_-_General_Purpose_I.2FO_.28GPIO.29
  0x00-0x3F: Section 0
      +0x00: Masked interrupt status (read-only)
      +0x04: R: Interrupt status W: Reset interrupt status
      +0x08: R: Interrupt mask W: Mask interrupt
      +0x0C: W: Unmask interrupt (write-only)
      +0x10: Direction: IO=10
      +0x14: Output
      +0x18: Input (read-only)
      +0x20: R: Level interrupt W: Set as level interrupt
  0x40-0x7F: Section 1
  0x80-0xBF: Section 2
  0xC0-0xFF: Section 3
 Offsets to various registers 
 Bit number of GPIO in its section 
 Functions for struct gpio_chip 
	
	  TODO: Implement IRQs.
	  Not implemented yet due to weird lockups
 Initialization 
 Copy our reference 
 Disable interrupts, they only cause errors 
 SPDX-License-Identifier: GPL-2.0
  gpio_request_one - request a single GPIO with initial configuration
  @gpio:	the GPIO number
  @flags:	GPIO configuration as specified by GPIOF_
  @label:	a literal description string of this GPIO
 Compatibility: assume unavailable "valid" GPIOs will appear later 
 Compatibility: assume unavailable "valid" GPIOs will appear later 
  gpio_request_array - request multiple GPIOs in a single call
  @array:	array of the 'struct gpio'
  @num:	how many GPIOs in the array
  gpio_free_array - release multiple GPIOs in a single call
  @array:	array of the 'struct gpio'
  @num:	how many GPIOs in the array
 SPDX-License-Identifier: GPL-2.0-only
  GPIO driver for the WinSystems WS16C48
  Copyright (C) 2016 William Breathitt Gray
  struct ws16c48_gpio - GPIO device private data structure
  @chip:	instance of the gpio_chip
  @io_state:	bit IO state (whether bit is set to input or output)
  @out_state:	output bits state
  @lock:	synchronization lock to prevent IO race conditions
  @irq_mask:	IO bits affected by interrupts
  @flow_mask:	IRQ flow type mask for the respective IO bits
  @base:	base port address of the GPIO device
 ensure that GPIO is set for input 
 clear bits array to a clean slate 
 ensure that GPIO is set for output 
 mask out GPIO configured for input 
 update output state data and set device gpio register 
 only the first 3 ports support interrupts 
 only the first 3 ports support interrupts 
 only the first 3 ports support interrupts 
 only the first 3 ports support interrupts 
 loop until all pending interrupts are handled 
 Disable IRQ by default 
 This will let us handle the parent IRQ in the driver 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2003-2015 Broadcom Corporation
  All Rights Reserved
  XLP GPIO has multiple 32 bit registers for each feature where each register
  controls 32 pins. So, pins up to 64 require 2 32-bit registers and up to 96
  require 3 32-bit registers for each feature.
  Here we only define offset of the first register for each feature. Offset of
  the registers for pins greater than 32 can be calculated as following(Use
  GPIO_INT_STAT as example):
  offset = (gpio  XLP_GPIO_REGSZ)  4;
  reg_addr = addr + offset;
  where addr is base address of the that feature register and gpio is the pin.
  Only for 4 interrupt enable reg are defined for now,
  total reg available are 12.
 Interrupt type register mask 
 Interrupt polarity register mask 
 XLP variants supported by this driver 
 pointer to first intr enable reg 
 pointer to first intr status reg 
 pointer to first intr type reg 
 pointer to first intr polarity reg 
 pointer to first output enable reg 
 pointer to first pad drive reg 
 sentinel  },
 XLP(MIPS) has fixed range for GPIO IRQs, Vulcan(ARM64) does not 
 SPDX-License-Identifier: GPL-2.0-only
  AMD Promontory GPIO driver
  Copyright (C) 2015 ASMedia Technology Inc.
  Author: YD Tseng <yd_tseng@asmedia.com.tw>
 PCI-E MMIO register offsets 
 initialize register setting 
 SPDX-License-Identifier: GPL-2.0-only
  MAXIM MAX77620 GPIO driver
  Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.
 irq_bus_lock 
	
	  GPIO interrupts may be left ON after bootloader, hence let's
	  pre-initialize hardware to the expected state by disabling all
	  the interrupts.
 This will let us handle the parent IRQ in the driver 
 SPDX-License-Identifier: GPL-2.0
  Driver for the ps-mode pin configuration.
  Copyright (c) 2021 Xilinx, Inc.
 4-bit boot mode pins 
  modepin_gpio_get_value - Get the state of the specified pin of GPIO device
  @chip:	gpio_chip instance to be worked on
  @pin:	gpio pin number within the device
  This function reads the state of the specified pin of the GPIO device.
  Return: 0 if the pin is low, 1 if pin is high, -EINVAL wrong pin configured
          or error value.
	 When [0:3] corresponding bit is set, then read output bit [8:11],
	  if the bit is clear then read input bit [4:7] for status or value.
  modepin_gpio_set_value - Modify the state of the pin with specified value
  @chip:	gpio_chip instance to be worked on
  @pin:	gpio pin number within the device
  @state:	value used to modify the state of the specified pin
  This function reads the state of the specified pin of the GPIO device, mask
  with the capture state of GPIO pin, and update pin of GPIO device.
  Return:	None.
 Configure pin as an output by set bit [0:3] 
 Configure bootpin value 
  modepin_gpio_dir_in - Set the direction of the specified GPIO pin as input
  @chip:	gpio_chip instance to be worked on
  @pin:	gpio pin number within the device
  Return: 0 always
  modepin_gpio_dir_out - Set the direction of the specified GPIO pin as output
  @chip:	gpio_chip instance to be worked on
  @pin:	gpio pin number within the device
  @state:	value to be written to specified pin
  Return: 0 always
  modepin_gpio_probe - Initialization method for modepin_gpio
  @pdev:		platform device instance
  Return: 0 on success, negative error otherwise.
 configure the gpio chip 
 modepin gpio registration 
 SPDX-License-Identifier: GPL-2.0-only
  GPIO driver for the ACCES PCI-IDIO-16
  Copyright (C) 2017 William Breathitt Gray
  struct idio_16_gpio_reg - GPIO device registers structure
  @out0_7:	Read: FET Drive Outputs 0-7
 		Write: FET Drive Outputs 0-7
  @in0_7:	Read: Isolated Inputs 0-7
 		Write: Clear Interrupt
  @irq_ctl:	Read: Enable IRQ
 		Write: Disable IRQ
  @filter_ctl:	Read: Activate Input Filters 0-15
 		Write: Deactivate Input Filters 0-15
  @out8_15:	Read: FET Drive Outputs 8-15
 		Write: FET Drive Outputs 8-15
  @in8_15:	Read: Isolated Inputs 8-15
 		Write: Unused
  @irq_status:	Read: Interrupt status
 		Write: Unused
  struct idio_16_gpio - GPIO device private data structure
  @chip:	instance of the gpio_chip
  @lock:	synchronization lock to prevent IO race conditions
  @reg:	IO address offset for the GPIO device registers
  @irq_mask:	IO bits affected by interrupts
 clear bits array to a clean slate 
 The only valid irq types are none and both-edges 
 Make sure our device generated IRQ 
 Clear interrupt 
 Disable IRQ by default and clear any pending interrupt 
 Deactivate input filters 
 This will let us handle the parent IRQ in the driver 
 SPDX-License-Identifier: GPL-2.0
  GPIO driver for TPS68470 PMIC
  Copyright (C) 2017 Intel Corporation
  Authors:
 	Antti Laakso <antti.laakso@intel.com>
 	Tianshu Qiu <tian.shu.qiu@intel.com>
 	Jian Xu Zheng <jian.xu.zheng@intel.com>
 	Yuning Pu <yuning.pu@intel.com>
 rest are always outputs 
 rest are always outputs 
 Set the initial value 
 rest are always outputs 
 SPDX-License-Identifier: GPL-2.0+
   Raspberry Pi 3 expander GPIO driver
   Uses the firmware mailbox service to communicate with the
   GPIO expander on the VPU.
   Copyright (C) 2017 Raspberry Pi Trading Ltd.
 VC4 firmware mailbox interface data structures 
 GPIO to update 
 GPIO to update 
 termination disabled 
 na as termination disabled 
 na as configured as an input 
 Retain existing setting 
 GPIO to update 
 na as an output 
 na as termination disabled 
 Output state 
 Retain existing setting 
 GPIO to update 
 GPIO to update 
 storage for returned value 
 GPIO to update 
 Output state 
 SPDX-License-Identifier: GPL-2.0-only
  GPIO driver for EXAR XRA1403 16-bit GPIO expander
  Copyright (c) 2017, General Electric Company
 XRA1403 registers 
 GPIO State 
 Output Control 
 Input Polarity Inversion 
 GPIO Configuration 
 Input Internal Pull-up Resistor EnableDisable 
 Input Interrupt Enable 
 Output Three-State Control 
 Input Interrupt Status 
 Input Rising Edge Interrupt Enable 
 Input Falling Edge Interrupt Enable 
 Input Filter EnableDisable 
 Bounds 
 bring the chip out of reset if reset pin is provided
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2011 LAPIS Semiconductor Co., Ltd.
 LAPIS Semiconductor ML7223 IOH PCIe Bus-m 
 LAPIS Semiconductor ML7223 IOH PCIe Bus-n 
 Specifies number of GPIO PINS 
  struct pch_gpio_reg_data - The register store data.
  @ien_reg:	To store contents of IEN register.
  @imask_reg:	To store contents of IMASK register.
  @po_reg:	To store contents of PO register.
  @pm_reg:	To store contents of PM register.
  @im0_reg:	To store contents of IM0 register.
  @im1_reg:	To store contents of IM1 register.
  @gpio_use_sel_reg : To store contents of GPIO_USE_SEL register.
 		       (Only ML7223 Bus-n)
  struct pch_gpio - GPIO private data structure.
  @base:			PCI base address of Memory mapped IO register.
  @reg:			Memory mapped PCH GPIO register list.
  @dev:			Pointer to device structure.
  @gpio:			Data for GPIO infrastructure.
  @pch_gpio_reg:		Memory mapped Register data is saved here
 				when suspend.
  @lock:			Used for register access protection
  @irq_base:		Save base of IRQ number for interrupt
  @ioh:		IOH ID
  @spinlock:		Used for register access protection
  Save register configuration and disable interrupts.
  This function restores the register configuration of the GPIO device.
 to store contents of PO register 
 to store contents of PM register 
 Set interrupt mode 
 And the handler 
 Mask all interrupts, but enable them 
 SPDX-License-Identifier: GPL-2.0
  Support to GPOs on ROHM BD71815
  Copyright 2021 ROHM Semiconductors.
  Author: Matti Vaittinen <matti.vaittinen@fi.rohmeurope.com>
  Copyright 2014 Embest Technology Co. Ltd. Inc.
  Author: yanglsh@embest-tech.com
 For the BD71815 register definitions 
 chip.parent points the MFD which provides DT node and regmap 
 dev points to the platform device for devm and prints 
 BD71815 GPIO is actually GPO 
 Template for GPIO chip 
  Sigh. The BD71815 and BD71817 were originally designed to support two GPO
  pins. At some point it was noticed the second GPO pin which is the E5 pin
  located at the center of IC is hard to use on PCB (due to the location). It
  was decided to not promote this second GPO and the pin is marked as GND in
  the datasheet. The functionality is still there though! I guess driving a GPO
  connected to the ground is a bad idea. Thus we do not support it by default.
  OTOH - the original driver written by colleagues at Embest did support
  controlling this second GPO. It is thus possible this is used in some of the
  products.
  This driver does not by default support configuring this second GPO
  but allows using it by providing the DT property
  "rohm,enable-hidden-gpo".
	
	  Bind devm lifetime to this platform device => use dev for devm.
	  also the prints should originate from this device.
 The device-tree and regmap come from MFD => use parent for that 
	
	  FIXME: As writing of this the sysfs interface for GPIO control does
	  not respect the valid_mask. Do not trust it but rather set the ngpios
	  to 1 if "rohm,enable-hidden-gpo" is not given.
	 
	  This check can be removed later if the sysfs export is fixed and
	  if the fix is backported.
	 
	  For now it is safest to just set the ngpios though.
 SPDX-License-Identifier: GPL-2.0-or-later
   Loongson-2F3A3B GPIO Support
   Copyright (c) 2008 Richard Liu,  STMicroelectronics	 <richard.liu@st.com>
   Copyright (c) 2008-2010 Arnaud Patard <apatard@mandriva.com>
   Copyright (c) 2013 Hongbing Hu <huhb@lemote.com>
   Copyright (c) 2014 Huacai Chen <chenhc@lemote.com>
  Offset into the register where we read lines, we write them from offset 0.
  This offset is the only thing that stand between us and using
  GPIO_GENERIC.
  Copyright (C) 2016 Texas Instruments Incorporated - http:www.ti.com
 	Keerthy <j-keerthy@ti.com>
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether expressed or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License version 2 for more details.
  Based on the TPS65218 driver
 This device is output only 
 This device is output only 
 Set the initial value 
 No MUX Set up Needed for GPO 
 Setup the CLKIN_PIN_SEL MUX to GPO2 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0+
  gpiolib support for Wolfson WM8994
  Copyright 2009 Wolfson Microelectronics PLC.
  Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
		 We report the GPIO even if it's not requested since
		  we're also reporting things like alternate
		  functions which apply even when the GPIO is not in
		  use as a GPIO.
 SPDX-License-Identifier: GPL-2.0-or-later
  74xx MMIO GPIO driver
   Copyright (C) 2014 Alexander Shiyan <shc_work@mail.ru>
 SPDX-License-Identifier: GPL-2.0-only
  MEN 16Z127 GPIO driver
  Copyright (C) 2016 MEN Mikroelektronik GmbH (www.men.de)
 16 bit compare register. Each bit represents 50us 
 round up or down depending on MSB-1 
 50us per register unit 
 Implicitly PIN_CONFIG_DRIVE_PUSH_PULL 
 SPDX-License-Identifier: GPL-2.0+
  TI TPS6591x GPIO driver
  Copyright 2010 Texas Instruments Inc.
  Author: Graeme Gregory <gg@slimlogic.co.uk>
  Author: Jorge Eduardo Candelaria <jedu@slimlogic.co.uk>
 Set the initial value 
 Configure sleep control for gpios if provided 
 SPDX-License-Identifier: GPL-2.0-only
   Atheros AR71XXAR724XAR913X GPIO API support
   Copyright (C) 2015 Alban Bedel <albeu@free.fr>
   Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
   Copyright (C) 2008-2011 Gabor Juhos <juhosg@openwrt.org>
   Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
	 As the IRQ configuration can't be loaded atomically we
	  have to disable the interrupt while the configuration state
	  is invalid.
 Update the polarity of the both edges irqs 
 Use base 0 to stay compatible with legacy platforms 
 Optional interrupt setup 
  GPIO Driver for Loongson 1 SoC
  Copyright (C) 2015-2016 Zhang, Keguang <keguang.zhang@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 Loongson 1 GPIO Register Definitions 
 SPDX-License-Identifier: GPL-2.0+
 MXC GPIO support. (c) 2008 Daniel Mack <daniel@caiaq.de>
 Copyright 2008 Juergen Beisert, kernel@pengutronix.de
 Based on code from Freescale,
 Copyright (C) 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
 Note: This driver assumes 32 GPIOs are handled in one register 
 set level or edge 
 set polarity 
 MXS has one interrupt per gpio port 
  Set interrupt number "irq" in the GPIO as a wake-up source.
  While system is running, all registered GPIO interrupts need to have
  wake-up enabled. When system is suspended, only selected GPIO interrupts
  need to have wake-up enabled.
  @param  irq          interrupt source number
  @param  enable       enable as wake-up if equal to non-zero
  @return       This function returns 0 on success.
 sentinel  }
	
	  map memory region only once, as all the gpio ports
	  share the same one
 initially disable the interrupts 
 clear address has to be used to clear IRQSTAT bits 
 gpio-mxs can be a generic irq chip 
 setup one handler for each entry 
 SPDX-License-Identifier: GPL-2.0+
  Freescale vf610 GPIO support through PORT and GPIO
  Copyright (c) 2014 Toradex AG.
  Author: Stefan Agner <stefan@agner.ch>.
 SoCs has a Port Data Direction Register (PDDR) 
 sentinel  }
		
		  Percolate deferrals, for anything else,
		  just live without the clocking.
 Mask all GPIO interrupts 
 Clear the interrupt status register for all GPIO's 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright 2015 IBM Corp.
  Joel Stanley <joel@jms.id.au>
  These two headers aren't meant to be used by GPIO drivers. We need
  them in order to access gpio_chip_hwgpio() which we need to implement
  the aspeed specific API which allows the coprocessor to request
  access to some GPIOs and to arbitrate between coprocessor and ARM.
  @offset_timer: Maps an offset to an @timer_users index, or zero if disabled
  @timer_users: Tracks the number of users for each timer
  The @timer_users has four elements but the first element is unused. This is
  to simplify accounting and indexing, as a zero value in @offset_timer
  represents disabled debouncing for the GPIO. Any other value for an element
  of @offset_timer is used as an index into @timer_users. This behaviour of
  the zero value aligns with the behaviour of zero built from the timer
  configuration registers (i.e. debouncing is disabled).
	uint16_t	val_regs;	 +0: Rd: read input value, Wr: set write latch
					  +4: RdWr: Direction (0=in, 1=out)
     Rd: read write latch, Wr: <none>  
  Note: The "value" register returns the input value sampled on the
        line even when the GPIO is configured as an output. Since
        that input goes through synchronizers, writing, then reading
        back may not return the written value right away.
        The "rdata" register returns the content of the write latch
        and thus can be used to read back what was last written
        reliably.
 This will be resolved at compile time 
	
	  Each register controls 4 banks, so take the bottom 2
	  bits of the bank index, and use them to select the
	  right control bit (0, 8, 16 or 24).
 Source 1 first to avoid illegal 11 combination 
 Then Source 0 
 Pause the coprocessor 
 Change command source back to ARM 
 Update cache 
 Change command source back to ColdFire 
 Restart the coprocessor 
 This might be a bit of a questionable place to check 
 Pretty crummy approach, but similar to GPIO core 
 At least as long as the requested time 
 Call under gpio->lock 
 Call under gpio->lock 
 Call under gpio->lock 
 Call under gpio->lock 
	 Note: Debounce timer isn't under control of the command
	  source registers, so no need to sync with the coprocessor
 Try to find a timer already configured for the debounce period 
		
		  As there are no timers configured for the requested debounce
		  period, find an unused timer instead
			
			  We already adjusted the accounting to remove @offset
			  as a user of its previous timer, so also configure
			  the hardware so @offset has timers disabled for
			  consistency.
 Return -ENOTSUPP to trigger emulation, as per datasheet 
  aspeed_gpio_copro_set_ops - Sets the callbacks used for handshaking with
                              the coprocessor for shared GPIO banks
  @ops: The callbacks
  @data: Pointer passed back to the callbacks
  aspeed_gpio_copro_grab_gpio - Mark a GPIO used by the coprocessor. The entire
                                bank gets marked and any access from the ARM will
                                result in handshaking via callbacks.
  @desc: The GPIO to be marked
  @vreg_offset: If non-NULL, returns the value register offset in the GPIO space
  @dreg_offset: If non-NULL, returns the data latch register offset in the GPIO space
  @bit: If non-NULL, returns the bit number of the GPIO in the registers
 Sanity check, this shouldn't happen 
 Switch command source 
  aspeed_gpio_copro_release_gpio - Unmark a GPIO used by the coprocessor.
  @desc: The GPIO to be marked
 Sanity check, this shouldn't happen 
 Switch command source 
  Any banks not specified in a struct aspeed_bank_props array are assumed to
  have the properties:
      { .input = 0xffffffff, .output = 0xffffffff }
     input	  output   
 UVWX 
 YZAAAB, two 4-GPIO holes 
 220 for simplicity, really 216 with two 4-GPIO holes, four at end 
     input	  output   
 UVWX 
 YZAAAB, 4-GPIO hole 
 AC 
 232 for simplicity, actual number is 228 (4-GPIO hole in GPIOAB) 
     input	  output   
 QRST 
 UVWX 
 YZ 
	
	  ast2600 has two controllers one with 208 GPIOs and one with 36 GPIOs.
	  We expect ngpio being set in the device tree and this is a fallback
	  option.
 Allocate a cache of the output registers 
	
	  Populate it with initial values read from the HW and switch
	  all command sources to the ARM by default
 Optionally set up an irqchip if there is an IRQ 
 SPDX-License-Identifier: GPL-2.0
  Renesas R-Car GPIO Support
   Copyright (C) 2014 Renesas Electronics Corporation
   Copyright (C) 2013 Magnus Damm
 General IOInterrupt Switching Register 
 General InputOutput Switching Register 
 General Output Register 
 General Input Register 
 Interrupt Display Register 
 Interrupt Clear Register 
 Interrupt Mask Register 
 Interrupt Mask Clear Register 
 PositiveNegative Logic Select Register 
 Edgelevel Select Register 
 Chattering Prevention OnOff Register 
 Output Data Select Register 
 One EdgeBoth Edge Select Register 
 General Input Enable Register 
	 follow steps in the GPIO documentation for
	  "Setting Edge-Sensitive Interrupt Input Mode" and
	  "Setting Level-Sensitive Interrupt Input Mode"
 Configure positive or negative logic in POSNEG 
 Configure edge or level trigger in EDGLEVEL 
 Select one edge or both edges in BOTHEDGE 
 Select "Interrupt Input Mode" in IOINTSEL 
 Write INTCLR in case of edge trigger 
	 follow steps in the GPIO documentation for
	  "Setting General Output Mode" and
	  "Setting General Input Mode"
 Configure positive logic in POSNEG 
 Select "General InputOutput Mode" in IOINTSEL 
 Select Input Mode or Output Mode in INOUTSEL 
 Select General Output Register to output data in OUTDTSEL 
	
	  Set the GPIO as an input to ensure that the next GPIO request won't
	  drive the GPIO pin as an output.
	
	  Before R-Car Gen3, INDT does not show correct pin state when
	  configured as output, so use OUTDT in case of output pins
 write GPIO value to output before selecting output mode of pin 
 Terminator 
 Select "Input Enable" in INEN 
 Get device configuration from DT node 
 This will let us handle the parent IRQ in the driver 
 IO pin 
 Interrupt pin 
 CONFIG_PM_SLEEP
 SPDX-License-Identifier: GPL-2.0+
  OF helpers for the GPIO API
  Copyright (c) 2007-2008  MontaVista Software, Inc.
  Author: Anton Vorontsov <avorontsov@ru.mvista.com>
  of_gpio_spi_cs_get_count() - special GPIO counting for SPI
  @dev:    Consuming device
  @con_id: Function within the GPIO consumer
  Some elder GPIO controllers need special quirks. Currently we handle
  the Freescale and PPC GPIO controller with bindings that doesn't use the
  established "cs-gpios" for chip selects but instead rely on
  "gpios" for the chip select lines. If we detect this, we redirect
  the counting of "cs-gpios" to count "gpios" transparent to the
  driver.
  This is used by external users of of_gpio_count() from <linuxof_gpio.h>
  FIXME: get rid of those external users by converting them to GPIO
  descriptors and let them all use gpiod_count()
  of_gpio_need_valid_mask() - figure out if the OF GPIO driver needs
  to set the .valid_mask
  @gc: the target gpio_chip
  Return: true if the valid mask needs to be set
	
	  Some GPIO fixed regulator quirks.
	  Note that active low is the default.
		
		  The regulator GPIO handles are specified such that the
		  presence or absence of "enable-active-high" solely controls
		  the polarity of the GPIO line. Any phandle flags must
		  be actively ignored.
	
	  Legacy open drain handling for fixed voltage regulators.
	
	  Legacy handling of SPI active high chip select. If we have a
	  property named "cs-gpios" we need to inspect the child node
	  to determine if the flags should have inverted semantics.
				
				  SPI children have active low chip selects
				  by default. This can be specified negatively
				  by just omitting "spi-cs-high" in the
				  device node, or actively by tagging on
				  GPIO_ACTIVE_LOW as flag in the device
				  tree. If the line is simultaneously
				  tagged as active low in the device tree
				  and has the "spi-cs-high" set, we get a
				  conflict and the "spi-cs-high" flag will
				  take precedence.
 Legacy handling of stmmac's active-low PHY reset line 
  of_get_named_gpiod_flags() - Get a GPIO descriptor and flags for GPIO API
  @np:		device node to get GPIO from
  @propname:	property name containing gpio specifier(s)
  @index:	index of the GPIO
  @flags:	a flags pointer to fill in
  Returns GPIO descriptor to use with Linux GPIO API, or one of the errno
  value on the error condition. If @flags is not NULL the function also fills
  in flags for the GPIO.
  gpiod_get_from_of_node() - obtain a GPIO from an OF node
  @node:	handle of the OF node
  @propname:	name of the DT property representing the GPIO
  @index:	index of the GPIO to obtain for the consumer
  @dflags:	GPIO initialization flags
  @label:	label to attach to the requested GPIO
  Returns:
  On successful request the GPIO pin is configured in accordance with
  provided @dflags.
  In case of error an ERR_PTR() is returned.
  The SPI GPIO bindings happened before we managed to establish that GPIO
  properties should be named "foo-gpios" so we have this special kludge for
  them.
 32 is max size of property name 
	
	  Hopefully the compiler stubs the rest of the function if this
	  is false.
 Allow this specifically for "spi-gpio" devices 
 Will be "gpio-sck", "gpio-mosi" or "gpio-miso" 
  The old Freescale bindings use simply "gpios" as name for the chip select
  lines rather than "cs-gpios" like all other SPI hardware. Account for this
  with a special quirk.
 Allow this specifically for Freescale and PPC devices 
 Allow only if asking for "cs-gpios" 
	
	  While all other SPI controllers use "cs-gpios" the Freescale
	  uses just "gpios" so translate to that when "cs-gpios" is
	  requested.
  Some regulator bindings happened before we managed to establish that GPIO
  properties should be named "foo-gpios" so we have this special kludge for
  them.
 These are the connection IDs we accept as legacy GPIO phandles 
 Arizona 
 WM8994 
 WM8994 
	
	  Currently this USB quirk is only for the Fairchild FUSB302 host which is using
	  an undocumented DT GPIO line named "fcs,int_n" without the compulsory "-gpios"
	  suffix.
 32 is max size of property name 
 Try GPIO property "foo-gpios" and "foo-gpio" 
 Special handling for SPI GPIOs if used 
 This quirk looks up flags and all 
 Special handling for regulator GPIOs if used 
  of_parse_own_gpio() - Get a GPIO hog descriptor, names and flags for GPIO API
  @np:		device node to get GPIO from
  @chip:	GPIO chip whose hog is parsed
  @idx:	Index of the GPIO to parse
  @name:	GPIO line name
  @lflags:	bitmask of gpio_lookup_flags GPIO_ values - returned from
 		of_find_gpio() or of_parse_own_gpio()
  @dflags:	gpiod_flags - optional GPIO initialization flags
  Returns GPIO descriptor to use with Linux GPIO API, or one of the errno
  value on the error condition.
  of_gpiochip_add_hog - Add all hogs in a hog device node
  @chip:	gpio chip to act on
  @hog:	device node describing the hogs
  Returns error if it fails otherwise 0 on success.
  of_gpiochip_scan_gpios - Scan gpio-controller for gpio definitions
  @chip:	gpio chip to act on
  This is only used by of_gpiochip_add to requestset GPIO initial
  configuration.
  It returns error if it fails otherwise 0 on success.
  of_gpiochip_remove_hog - Remove all hogs in a hog device node
  @chip:	gpio chip to act on
  @hog:	device node describing the hogs
	
	  This only supports adding and removing complete gpio-hog nodes.
	  Modifying an existing gpio-hog node is not supported (except for
	  changing its "status" property, which is treated the same as
	  additionremoval).
 not for us 
 not for us 
 already depopulated 
 not for us 
 CONFIG_OF_DYNAMIC 
  of_gpio_simple_xlate - translate gpiospec to the GPIO number and flags
  @gc:		pointer to the gpio_chip structure
  @gpiospec:	GPIO specifier as found in the device tree
  @flags:	a flags pointer to fill in
  This is simple translation function, suitable for the most 1:1 mapped
  GPIO chips. This function performs only one sanity check: whether GPIO
  is less than ngpios (that is specified in the gpio_chip).
	
	  We're discouraging gpio_cells < 2, since that way you'll have to
	  write your own xlate function (that will have to retrieve the GPIO
	  number and the flags from a single gpio cell -- this is possible,
	  but not recommended).
  of_mm_gpiochip_add_data - Add memory mapped GPIO chip (bank)
  @np:		device node of the GPIO chip
  @mm_gc:	pointer to the of_mm_gpio_chip allocated structure
  @data:	driver data to store in the struct gpio_chip
  To use this function you should allocate and fill mm_gc with:
  1) In the gpio_chip structure:
     - all the callbacks
     - of_gpio_n_cells
     - of_xlate callback (optional)
  3) In the of_mm_gpio_chip structure:
     - save_regs callback (optional)
  If succeeded, this function will map bank's memory and will
  do all necessary work for you. Then you'll able to use .regs
  to manage GPIOs from the callbacks.
  of_mm_gpiochip_remove - Remove memory mapped GPIO chip (bank)
  @mm_gc:	pointer to the of_mm_gpio_chip allocated structure
 npins != 0: linear range 
 npins == 0: special range 
 Set default OF node to parent's one if present 
 If the gpiochip has an assigned OF node this takes precedence 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2017 Broadcom
 should not come here 
 go through the entire GPIOs and handle all interrupts 
 Get level and edge interrupts 
 Enable GPIO interrupts for CCA GPIO 
		
		  Directly request the irq here instead of passing
		  a flow-handler because the irq is shared.
 This will let us handle the parent IRQ in the driver 
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  Copyright (C) 2016, 2017 Cavium Inc.
 per line MSI-X 
 per line irq info 
  Check (and WARN) that the pin is available for GPIO.  We will not
  allow modification of the state of non-GPIO pins from this driver.
		
		  Say it is input for now to avoid WARNing on
		  gpiochip_add_data().  We will WARN if someone
		  requests it or tries to use it.
		
		  Weird, setting open-drain mode causes signal
		  inversion.  Note this so we can compensate in the
		  dir_out function.
 15  2^15  2.5nS maximum 
 scale to 2.5nS clocks. 
 always round up 
	
	  If currently output and OPEN_DRAIN changed, install the new
	  settings
  Interrupts are chained from underlying MSI-X vectors.  We have
  these irq_chip functions to be able to handle level triggering
  semantics and other acknowledgment tasks associated with the GPIO
  mechanism.
 CN88XX has no GPIO_CONST register
		
		  If something has already programmed the pin, use
		  the existing glitch filter settings, otherwise go
		  to 400nS.
 Enable all MSI-X for interrupts on all possible lines. 
 System allocated 
 Push on irq_data and the domain for each line. 
 end of table 
 SPDX-License-Identifier: GPL-2.0
 Copyright (C) 2018 BayLibre SAS
 Author: Bartosz Golaszewski <bgolaszewski@baylibre.com>
 GPIO driver for MAXIM 7765077651 chargerpower-supply.
 SPDX-License-Identifier: GPL-2.0
 Number of pins on BlueField 
 Pad Electrical Controls. 
 Device state structure. 
 Memory Address 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2018 Spreadtrum Communications Inc.
  Copyright (C) 2018 Linaro Ltd.
 GPIO registers definition 
 We have 16 banks GPIOs and each bank contain 16 GPIOs 
 end of list  }
  GPIO driver for the TS-4800 board
  Copyright (c) 2016 - Savoir-faire Linux
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 SPDX-License-Identifier: GPL-2.0+
 Copyright (C) 2008-2009 The GameCube Linux Team
 Copyright (C) 2008,2009 Albert Herranz
 Copyright (C) 2017-2018 Jonathan Neuschfer
 Nintendo Wii (Hollywood) GPIO driver
  Register names and offsets courtesy of WiiBrew:
  https:wiibrew.orgwikiHardwareHollywood_GPIOs
  Note that for most registers, there are two versions:
  - HW_GPIOB_ Is always accessible by the Broadway PowerPC core, but does
    always give access to all GPIO lines
  - HW_GPIO_ Is only accessible by the Broadway PowerPC code if the memory
    firewall (AHBPROT) in the Hollywood chipset has been configured to allow
    such access.
  The ownership of each GPIO line can be configured in the HW_GPIO_OWNER
  register: A one bit configures the line for access via the HW_GPIOB_
  registers, a zero bit indicates access via HW_GPIO_. This driver uses
  HW_GPIOB_.
 Treat interrupts due to edge trigger emulation separately 
 Invert the levels 
 Ack all emulated-edge interrupts 
 Signal interrupts only on the correct edge 
 Mark emulated interrupts as pending 
 Set the trigger level to the inactive level 
	
	  Claim all GPIOs using the OWNER register. This will not work on
	  systems where the AHBPROT memory firewall hasn't been configured to
	  permit PPC access to HW_GPIO_.
	 
	  Note that this has to happen before bgpio_init reads the
	  HW_GPIOB_OUT and HW_GPIOB_DIR, because otherwise it reads the wrong
	  values.
 Mask and ack all interrupts 
	
	  If this GPIO controller is not marked as an interrupt controller in
	  the DT, skip interrupt support.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.
  struct ioh_gpio_reg_data - The register store data.
  @ien_reg:	To store contents of interrupt enable register.
  @imask_reg:	To store contents of interrupt mask regist
  @po_reg:	To store contents of PO register.
  @pm_reg:	To store contents of PM register.
  @im0_reg:	To store contents of interrupt mode regist0
  @im1_reg:	To store contents of interrupt mode regist1
  @use_sel_reg: To store contents of GPIO_USE_SEL0~3
  struct ioh_gpio - GPIO private data structure.
  @base:			PCI base address of Memory mapped IO register.
  @reg:			Memory mapped IOH GPIO register list.
  @dev:			Pointer to device structure.
  @gpio:			Data for GPIO infrastructure.
  @ioh_gpio_reg:		Memory mapped Register data is saved here
 				when suspend.
  @gpio_use_sel:		Save GPIO_USE_SEL1~4 register for PM
  @ch:				Indicate GPIO channel
  @irq_base:		Save base of IRQ number for interrupt
  @spinlock:		Used for register access protection
  Save register configuration and disable interrupts.
  This function restores the register configuration of the GPIO device.
 Set interrupt mode 
 iclr 
 IMASKCLR 
 Enable interrupt 
 SPDX-License-Identifier: GPL-2.0+
  gpiolib support for Wolfson WM831x PMICs
  Copyright 2009 Wolfson Microelectronics PLC.
  Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 Can only set GPIO state once it's in output mode 
 Not in GPIO mode 
		 We report the GPIO even if it's not requested since
		  we're also reporting things like alternate
		  functions which apply even when the GPIO is not in
		  use as a GPIO.
 SPDX-License-Identifier: GPL-2.0
  TQ-Systems TQMx86 PLD GPIO driver
  Based on vendor driver by:
    Vadim V.Vlasov <vvlasov@dev.rtsoft.ru>
 0-3 - output 
 4-7 - input 
 0-3 - output, 4-7 - input 
 GPIO Data Direction Register 
 GPIO Data Register 
 GPI Interrupt Configuration Register 
 GPI Interrupt Status Register 
 Direction cannot be changed. Validate is an input. 
 Direction cannot be changed, validate is an output 
 not supported 
 Minimal runtime PM is needed by the IRQ subsystem 
 Only GPIOs 4-7 are valid for interrupts. Clear the others 
 Mask all interrupts 
 Clear all pending interrupts 
 SPDX-License-Identifier: GPL-2.0
 Implementation infrastructure for GPIO interfaces.
  The GPIO programming interface allows for inlining speed-critical
  getset operations for common cases, so that access to SOC-integrated
  GPIOs can sometimes cost only an instruction or two per bit.
 When debugging, extend minimal trust to callers and platform code.
  Also emit diagnostic messages that may help initial bringup, when
  board setup or driver bugs are most common.
  Otherwise, minimize overhead in what may be bitbanging codepaths.
 Device and char device-related information 
 256 GPIO chip devices supported 
  Number of GPIOs to use for the fast path in set array
 gpio_lock prevents conflicts during gpio_desc[] table updates.
  While any GPIO is requested, its gpio_chip is not removable;
  each GPIO's "requested" flag serves as a lock and refcount.
  gpio_to_desc - Convert a GPIO number to its descriptor
  @gpio: global GPIO number
  Returns:
  The GPIO descriptor associated with the given GPIO, or %NULL if no GPIO
  with the given number exists in the system.
  gpiochip_get_desc - get the GPIO descriptor corresponding to the given
                      hardware number for this chip
  @gc: GPIO chip
  @hwnum: hardware number of the GPIO for this chip
  Returns:
  A pointer to the GPIO descriptor or ``ERR_PTR(-EINVAL)`` if no GPIO exists
  in the given chip for the specified hardware number.
  desc_to_gpio - convert a GPIO descriptor to the integer namespace
  @desc: GPIO descriptor
  This should disappear in the future but is needed since we still
  use GPIO numbers for error messages and sysfs nodes.
  Returns:
  The global GPIO number for the GPIO specified by its descriptor.
  gpiod_to_chip - Return the GPIO chip to which a GPIO descriptor belongs
  @desc:	descriptor to return the chip of
 dynamic allocation of GPIOs, e.g. on a hotplugged device 
 found a free space? 
 nope, check the space right before the chip 
  gpiod_get_direction - return the current direction of a GPIO
  @desc:	GPIO to get the direction of
  Returns 0 for output, 1 for input, or an error code in case of error.
  This function may sleep if gpiod_cansleep() is true.
	
	  Open drain emulation using input mode may incorrectly report
	  input here, fix that up.
 GPIOF_DIR_IN or other positive, otherwise GPIOF_DIR_OUT 
  Add a new chip to the global chips list, keeping the list of chips sorted
  by range(means [base, base + ngpio - 1]) order.
  Return -EBUSY if the new chip overlaps with some other chip's integer
  space.
 initial entry in list 
 add before first entry 
 add behind last entry 
 at the end of the list 
 add between prev and next 
  Convert a GPIO name to its descriptor
  Note that there is no guarantee that GPIO names are globally unique!
  Hence this function will return, if it exists, a reference to the first GPIO
  line found that matches the given name.
  Take the names from gc->names and assign them to their GPIO descriptors.
  Warn if a name is already used for a GPIO line on a different GPIO chip.
  Note that:
    1. Non-unique names are still accepted,
    2. Name collisions within the same GPIO chip are not reported.
 First check all names if they are unique 
 Then add all names to the GPIO descriptors 
  devprop_gpiochip_set_names - Set GPIO line names using device properties
  @chip: GPIO chip whose lines should be named, if possible
  Looks for device property "gpio-line-names" and if it exists assigns
  GPIO line names for the chip. The memory allocated for the assigned
  names belong to the underlying firmware node and should not be released
  by the caller.
	
	  When offset is set in the driver side we assume the driver internally
	  is using more than one gpiochip per the same device. We have to stop
	  setting friendly names if the specified ones with 'gpio-line-names'
	  are less than the offset in the device itself. This means all the
	  lines are not present for every single pin within all the internal
	  gpiochips.
	
	  When more that one gpiochip per device is used, 'count' can
	  contain at most number gpiochips x chip->ngpio. We have to
	  correctly distribute all defined lines taking into account
	  chip->offset as starting point from where we will assign
	  the names to pins from the 'names' array. Since property
	  'gpio-line-names' cannot contains gaps, we have to be sure
	  we only assign those pins that really exists since chip->ngpio
	  can be different of the chip->offset.
 Assume by default all GPIOs are valid 
 No mask means all valid 
  gpiolib_cdev_register() indirectly calls device_add(), which is still
  required even when cdev is not selected.
 From this point, the .release() function cleans up gpio_device 
	
	  First: allocate and populate the internal stat container, and
	  set up the struct device.
	
	  Assign fwnode depending on the result of the previous calls,
	  if none of them succeed, assign it to the parent's one.
 TODO: remove chip->owner 
	
	  TODO: this allocates a Linux GPIO number base in the global
	  GPIO numberspace for this chip. In the long run we want to
	  get rid of this numberspace and use only descriptors, but
	  it may be a pipe dream. It will not happen before we get rid
	  of the sysfs interface anyways.
		
		  TODO: it should not be necessary to reflect the assigned
		  base outside of the GPIO subsystem. Go over drivers and
		  see if anyone makes use of this, else drop this and assign
		  a poison instead.
	
	  By first adding the chardev, and then adding the device,
	  we get a device node entry in sysfs under
	  sysbusgpiodevicesgpiochipNdev that can be used for
	  coldplug of device nodes and other udev business.
	  We can do this only if gpiolib has been initialized.
	  Otherwise, defer until later.
 failures here can mean systems won't boot... 
  gpiochip_get_data() - get per-subdriver data for the chip
  @gc: GPIO chip
  Returns:
  The per-subdriver data for the chip.
  gpiochip_remove() - unregister a gpio_chip
  @gc: the chip to unregister
  A gpio_chip with any GPIOs still requested may not be removed.
 FIXME: should the legacy sysfs handling be moved to gpio_device? 
 Numb the device, cancelling all outstanding operations 
	
	  We accept no more calls into the driver from this point, so
	  NULL the driver data pointer
	
	  The gpiochip side puts its use of the device to rest here:
	  if there are no userspace clients, the chardev and device will
	  be removed, else it will be dangling until the last user is
	  gone.
  gpiochip_find() - iterator for locating a specific gpio_chip
  @data: data to pass to match function
  @match: Callback function to check gpio_chip
  Similar to bus_find_device.  It returns a reference to a gpio_chip as
  determined by a user supplied @match callback.  The callback should return
  0 if the device doesn't match and non-zero if it does.  If the callback is
  non-zero, this function will return to the caller and not iterate over any
  more gpio_chips.
  The following is irqchip helper code for gpiochips.
 No mask means all valid 
  gpiochip_set_hierarchical_irqchip() - connects a hierarchical irqchip
  to a gpiochip
  @gc: the gpiochip to set the irqchip hierarchical handler to
  @irqchip: the irqchip to handle this level of the hierarchy, the interrupt
  will then percolate up to the parent
 DT will deal with mapping each IRQ as we go along 
	
	  This is for legacy and boardfile "irqchip" fwnodes: allocate
	  irqs upfront instead of dynamically since we don't have the
	  dynamic type of allocation that hardware description languages
	  provide. Once all GPIO drivers using board files are gone from
	  the kernel we can delete this code, but for a transitional period
	  it is necessary to keep this around.
			
			  We call the child to parent translation function
			  only to check if the child IRQ is valid or not.
			  Just pick the rising edge type here as that is what
			  we likely need to support.
 This is the hwirq for the GPIO line side of things 
 Just pick something 
 just pick something 
 We support standard DT translation 
 This is for board files and others not using DT 
	
	  The nr_irqs parameter is always one except for PCI multi-MSI
	  so this should not happen.
	
	  We set handle_bad_irq because the .set_type() should
	  always be invoked and set the right type of handler.
 This parent only handles asserted level IRQs 
	
	  If the parent irqdomain is msi, the interrupts have already
	  been allocated, so the EEXIST is good.
	
	  We only allow overriding the translate() function for
	  hierarchical chips, and this should only be done if the user
	  really need something other than 1:1 translation.
 CONFIG_IRQ_DOMAIN_HIERARCHY 
  gpiochip_irq_map() - maps an IRQ into a GPIO irqchip
  @d: the irqdomain used by this irqchip
  @irq: the global irq number used by this GPIO irqchip irq
  @hwirq: the local IRQGPIO line offset on this gpiochip
  This function will set up the mapping for a certain IRQ line on a
  gpiochip by assigning the gpiochip as chip data, and using the irqchip
  stored inside the gpiochip.
	
	  This lock class tells lockdep that GPIO irqs are in a different
	  category than their parents, so it won't report false recursion.
 Chips that use nested thread handlers have them marked 
	
	  No set-up of the hardware will happen if IRQ_TYPE_NONE
	  is passed as default type.
 Virtually all GPIO irqchips are twocell:ed 
  TODO: move these activatedeactivate in under the hierarchicial
  irqchip implementation as static once SPMI and SSBI (all external
  users) are phased over.
  gpiochip_irq_domain_activate() - Lock a GPIO to be used as an IRQ
  @domain: The IRQ domain used by this IRQ chip
  @data: Outermost irq_data associated with the IRQ
  @reserve: If set, only reserve an interrupt vector instead of assigning one
  This function is a wrapper that calls gpiochip_lock_as_irq() and is to be
  used as the activate function for the &struct irq_domain_ops. The host_data
  for the IRQ domain must be the &struct gpio_chip.
  gpiochip_irq_domain_deactivate() - Unlock a GPIO used as an IRQ
  @domain: The IRQ domain used by this IRQ chip
  @data: Outermost irq_data associated with the IRQ
  This function is a wrapper that will call gpiochip_unlock_as_irq() and is to
  be used as the deactivate function for the &struct irq_domain_ops. The
  host_data for the IRQ domain must be the &struct gpio_chip.
 Check if the irqchip already has this hook... 
		
		  ...and if so, give a gentle warning that this is bad
		  practice.
  gpiochip_add_irqchip() - adds an IRQ chip to a GPIO chip
  @gc: the GPIO chip to add the IRQ chip to
  @lock_key: lockdep class for IRQ lock
  @request_key: lockdep class for IRQ request
	
	  Specifying a default trigger is a terrible idea if DT or ACPI is
	  used to configure the interrupts, as you may end up with
	  conflicting triggers. Tell the user, and reset to NONE.
 If a parent irqdomain is provided, let's build a hierarchy 
 Some drivers provide custom irqdomain ops 
			
			  The parent IRQ chip is already using the chip_data
			  for this IRQ chip, so our callbacks simply use the
			  handler_data.
  gpiochip_irqchip_remove() - removes an irqchip added to a gpiochip
  @gc: the gpiochip to remove the irqchip from
  This is called only from gpiochip_remove()
 Remove all IRQ mappings and delete the domain 
  gpiochip_irqchip_add_domain() - adds an irqdomain to a gpiochip
  @gc: the gpiochip to add the irqchip to
  @domain: the irqdomain to add to the gpiochip
  This function adds an IRQ domain to the gpiochip.
 CONFIG_GPIOLIB_IRQCHIP 
 CONFIG_GPIOLIB_IRQCHIP 
  gpiochip_generic_request() - request the gpio function for a pin
  @gc: the gpiochip owning the GPIO
  @offset: the offset of the GPIO to request for GPIO function
  gpiochip_generic_free() - free the gpio function from a pin
  @gc: the gpiochip to request the gpio function for
  @offset: the offset of the GPIO to free from GPIO function
  gpiochip_generic_config() - apply configuration for a pin
  @gc: the gpiochip owning the GPIO
  @offset: the offset of the GPIO to apply the configuration
  @config: the configuration to be applied
  gpiochip_add_pingroup_range() - add a range for GPIO <-> pin mapping
  @gc: the gpiochip to add the range for
  @pctldev: the pin controller to map to
  @gpio_offset: the start offset in the current gpio_chip number space
  @pin_group: name of the pin group inside the pin controller
  Calling this function directly from a DeviceTree-supported
  pinctrl driver is DEPRECATED. Please see Section 2.1 of
  Documentationdevicetreebindingsgpiogpio.txt on how to
  bind pinctrl and gpio drivers via the "gpio-ranges" property.
 Use local offset as range ID 
  gpiochip_add_pin_range() - add a range for GPIO <-> pin mapping
  @gc: the gpiochip to add the range for
  @pinctl_name: the dev_name() of the pin controller to map to
  @gpio_offset: the start offset in the current gpio_chip number space
  @pin_offset: the start offset in the pin controller number space
  @npins: the number of pins from the offset of each pin space (GPIO and
 	pin controller) to accumulate in this range
  Returns:
  0 on success, or a negative error-code on failure.
  Calling this function directly from a DeviceTree-supported
  pinctrl driver is DEPRECATED. Please see Section 2.1 of
  Documentationdevicetreebindingsgpiogpio.txt on how to
  bind pinctrl and gpio drivers via the "gpio-ranges" property.
 Use local offset as range ID 
  gpiochip_remove_pin_ranges() - remove all the GPIO <-> pin mappings
  @gc: the chip to remove all the mappings for
 CONFIG_PINCTRL 
 These "optional" allocation calls help prevent drivers from stomping
  on each other, and help provide better diagnostics in debugfs.
  They're called even less than the "set direction" calls.
	 NOTE:  gpio_request() can be called in early boot,
	  before IRQs are enabled, for non-sleeping (SOC) GPIOs.
 gc->request may sleep 
 gc->get_direction may sleep 
  This descriptor validation needs to be inserted verbatim into each
  function taking a descriptor, so we need to use a preprocessor
  macro to avoid endless duplication. If the desc is NULL it is an
  optional GPIO and calls should just bail out.
  gpiochip_is_requested - return string iff signal was requested
  @gc: controller managing the signal
  @offset: of signal within controller's 0..(ngpio - 1) range
  Returns NULL if the GPIO is not currently requested, else a string.
  The string returned is the label passed to gpio_request(); if none has been
  passed it is a meaningless, non-NULL constant.
  This function is for use by GPIO controller drivers.  The label can
  help with diagnostics, and knowing that the signal is used as a GPIO
  can help avoid accidentally multiplexing it to another controller.
  gpiochip_request_own_desc - Allow GPIO chip to request its own descriptor
  @gc: GPIO chip
  @hwnum: hardware number of the GPIO for which to request the descriptor
  @label: label for the GPIO
  @lflags: lookup flags for this GPIO or 0 if default, this can be used to
  specify things like line inversion semantics with the machine flags
  such as GPIO_OUT_LOW
  @dflags: descriptor request flags for this GPIO or 0 if default, this
  can be used to specify consumer semantics such as open drain
  Function allows GPIO chip drivers to request and use their own GPIO
  descriptors via gpiolib API. Difference to gpiod_request() is that this
  function will not increase reference count of the GPIO chip module. This
  allows the GPIO chip module to be unloaded as needed (we assume that the
  GPIO chip driver handles freeing the GPIOs it has requested).
  Returns:
  A pointer to the GPIO descriptor, or an ERR_PTR()-encoded negative error
  code on failure.
  gpiochip_free_own_desc - Free GPIO requested by the chip driver
  @desc: GPIO descriptor to free
  Function frees the given GPIO requested previously with
  gpiochip_request_own_desc().
  Drivers MUST set GPIO direction before making getset calls.  In
  some cases this is done in early boot, before IRQs are enabled.
  As a rule these aren't called more than once (except for drivers
  using the open-drain emulation idiom) so these are natural places
  to accumulate extra debugging checks.  Note that we can't (yet)
  rely on gpio_request() having been called beforehand.
  gpiod_direction_input - set the GPIO direction to input
  @desc:	GPIO to set to input
  Set the direction of the passed GPIO to input, such as gpiod_get_value() can
  be called safely on it.
  Return 0 in case of success, else an error code.
	
	  It is legal to have no .get() and .direction_input() specified if
	  the chip is output-only, but you can't specify .direction_input()
	  and not support the .get() operation, that doesn't make sense.
	
	  If we have a .direction_input() callback, things are simple,
	  just call it. Else we are some input-only chip so try to check the
	  direction (if .get_direction() is supported) else we silently
	  assume we are in input mode after this.
	
	  It's OK not to specify .direction_output() if the gpiochip is
	  output-only, but if there is then not even a .set() operation it
	  is pretty tricky to drive the output line.
 Check that we are in output mode if we can 
		
		  If we can't actively set the direction, we are some
		  output-only chip, so just drive the output as desired.
  gpiod_direction_output_raw - set the GPIO direction to output
  @desc:	GPIO to set to output
  @value:	initial output value of the GPIO
  Set the direction of the passed GPIO to output, such as gpiod_set_value() can
  be called safely on it. The initial value of the output must be specified
  as raw value on the physical line without regard for the ACTIVE_LOW status.
  Return 0 in case of success, else an error code.
  gpiod_direction_output - set the GPIO direction to output
  @desc:	GPIO to set to output
  @value:	initial output value of the GPIO
  Set the direction of the passed GPIO to output, such as gpiod_set_value() can
  be called safely on it. The initial value of the output must be specified
  as the logical value of the GPIO, i.e. taking its ACTIVE_LOW status into
  account.
  Return 0 in case of success, else an error code.
 GPIOs used for enabled IRQs shall not be set as output 
 First see if we can enable open drain in hardware 
 Emulate open drain by not actively driving the line high 
 Emulate open source by not actively driving the line low 
	
	  When emulating open-source or open-drain functionalities by not
	  actively driving the line (setting mode to input) we still need to
	  set the IS_OUT flag or otherwise we won't be able to set the line
	  value anymore.
  gpiod_set_config - sets @config for a GPIO
  @desc: descriptor of the GPIO for which to set the configuration
  @config: Same packed config format as generic pinconf
  Returns:
  0 on success, %-ENOTSUPP if the controller doesn't support setting the
  configuration.
  gpiod_set_debounce - sets @debounce time for a GPIO
  @desc: descriptor of the GPIO for which to set debounce time
  @debounce: debounce time in microseconds
  Returns:
  0 on success, %-ENOTSUPP if the controller doesn't support setting the
  debounce time.
  gpiod_set_transitory - Lose or retain GPIO state on suspend or reset
  @desc: descriptor of the GPIO for which to configure persistence
  @transitory: True to lose state on suspend or reset, false for persistence
  Returns:
  0 on success, otherwise a negative error code.
	
	  Handle FLAG_TRANSITORY first, enabling queries to gpiolib for
	  persistence state.
 If the driver supports it, set the persistence state now 
  gpiod_is_active_low - test whether a GPIO is active-low or not
  @desc: the gpio descriptor to test
  Returns 1 if the GPIO is active-low, 0 otherwise.
  gpiod_toggle_active_low - toggle whether a GPIO is active-low or not
  @desc: the gpio descriptor to change
 IO calls are only valid after configuration completed; the relevant
  "is this a valid GPIO" error checks should already have been done.
  "Get" operations are often inlinable as reading a pin value register,
  and masking the relevant bit in that register.
  When "set" operations are inlinable, they involve writing that mask to
  one register to set a low value, or a different register to set it high.
  Otherwise locking is needed, so there may be little value to inlining.
 ------------------------------------------------------------------------
  IMPORTANT!!!  The hot paths -- getset value -- assume that callers
  have requested the GPIO.  That can include implicit requesting by
  a direction setting call.  Marking a gpio as requested locks its chip
  in memory, guaranteeing that these table lookups need no more locking
  and that gpiochip_remove() will fail.
  REVISIT when debugging, consider adding some instrumentation to ensure
  that the GPIO was actually requested.
	
	  Validate array_info against desc_array and its size.
	  It should immediately follow desc_array if both
	  have been obtained from the same gpiod_get_array() call.
 collect all inputs belonging to the same chip 
  gpiod_get_raw_value() - return a gpio's raw value
  @desc: gpio whose value will be returned
  Return the GPIO's raw value, i.e. the value of the physical line disregarding
  its ACTIVE_LOW status, or negative errno on failure.
  This function can be called from contexts where we cannot sleep, and will
  complain if the GPIO chip functions potentially sleep.
 Should be using gpiod_get_raw_value_cansleep() 
  gpiod_get_value() - return a gpio's value
  @desc: gpio whose value will be returned
  Return the GPIO's logical value, i.e. taking the ACTIVE_LOW status into
  account, or negative errno on failure.
  This function can be called from contexts where we cannot sleep, and will
  complain if the GPIO chip functions potentially sleep.
 Should be using gpiod_get_value_cansleep() 
  gpiod_get_raw_array_value() - read raw values from an array of GPIOs
  @array_size: number of elements in the descriptor array  value bitmap
  @desc_array: array of GPIO descriptors whose values will be read
  @array_info: information on applicability of fast bitmap processing path
  @value_bitmap: bitmap to store the read values
  Read the raw values of the GPIOs, i.e. the values of the physical lines
  without regard for their ACTIVE_LOW status.  Return 0 in case of success,
  else an error code.
  This function can be called from contexts where we cannot sleep,
  and it will complain if the GPIO chip functions potentially sleep.
  gpiod_get_array_value() - read values from an array of GPIOs
  @array_size: number of elements in the descriptor array  value bitmap
  @desc_array: array of GPIO descriptors whose values will be read
  @array_info: information on applicability of fast bitmap processing path
  @value_bitmap: bitmap to store the read values
  Read the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
  into account.  Return 0 in case of success, else an error code.
  This function can be called from contexts where we cannot sleep,
  and it will complain if the GPIO chip functions potentially sleep.
   gpio_set_open_drain_value_commit() - Set the open drain gpio's value.
  @desc: gpio descriptor whose state need to be set.
  @value: Non-zero for setting it HIGH otherwise it will set to LOW.
   _gpio_set_open_source_value() - Set the open source gpio's value.
  @desc: gpio descriptor whose state need to be set.
  @value: Non-zero for setting it HIGH otherwise it will set to LOW.
  set multiple outputs on the same chip;
  use the chip's set_multiple function if available;
  otherwise set the outputs sequentially;
  @chip: the GPIO chip we operate on
  @mask: bit mask array; one bit per output; BITS_PER_LONG bits per word
         defines which outputs are to be changed
  @bits: bit value array; one bit per output; BITS_PER_LONG bits per word
         defines the values the outputs specified by mask are to be set to
 set outputs if the corresponding mask bit is set 
	
	  Validate array_info against desc_array and its size.
	  It should immediately follow desc_array if both
	  have been obtained from the same gpiod_get_array() call.
			
			  Pins applicable for fast input but not for
			  fast output processing may have been already
			  inverted inside the fast path, skip them.
			
			  collect all normal outputs belonging to the same chip
			  open drain and open source outputs are set individually
 push collected bits to outputs 
  gpiod_set_raw_value() - assign a gpio's raw value
  @desc: gpio whose value will be assigned
  @value: value to assign
  Set the raw value of the GPIO, i.e. the value of its physical line without
  regard for its ACTIVE_LOW status.
  This function can be called from contexts where we cannot sleep, and will
  complain if the GPIO chip functions potentially sleep.
 Should be using gpiod_set_raw_value_cansleep() 
  gpiod_set_value_nocheck() - set a GPIO line value without checking
  @desc: the descriptor to set the value on
  @value: value to set
  This sets the value of a GPIO line backing a descriptor, applying
  different semantic quirks like active low and open drainsource
  handling.
  gpiod_set_value() - assign a gpio's value
  @desc: gpio whose value will be assigned
  @value: value to assign
  Set the logical value of the GPIO, i.e. taking its ACTIVE_LOW,
  OPEN_DRAIN and OPEN_SOURCE flags into account.
  This function can be called from contexts where we cannot sleep, and will
  complain if the GPIO chip functions potentially sleep.
 Should be using gpiod_set_value_cansleep() 
  gpiod_set_raw_array_value() - assign values to an array of GPIOs
  @array_size: number of elements in the descriptor array  value bitmap
  @desc_array: array of GPIO descriptors whose values will be assigned
  @array_info: information on applicability of fast bitmap processing path
  @value_bitmap: bitmap of values to assign
  Set the raw values of the GPIOs, i.e. the values of the physical lines
  without regard for their ACTIVE_LOW status.
  This function can be called from contexts where we cannot sleep, and will
  complain if the GPIO chip functions potentially sleep.
  gpiod_set_array_value() - assign values to an array of GPIOs
  @array_size: number of elements in the descriptor array  value bitmap
  @desc_array: array of GPIO descriptors whose values will be assigned
  @array_info: information on applicability of fast bitmap processing path
  @value_bitmap: bitmap of values to assign
  Set the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
  into account.
  This function can be called from contexts where we cannot sleep, and will
  complain if the GPIO chip functions potentially sleep.
  gpiod_cansleep() - report whether gpio value access may sleep
  @desc: gpio to check
  gpiod_set_consumer_name() - set the consumer name for the descriptor
  @desc: gpio to set the consumer name on
  @name: the new consumer name
  gpiod_to_irq() - return the IRQ corresponding to a GPIO
  @desc: gpio whose IRQ will be returned (already requested)
  Return the IRQ corresponding to the passed GPIO, or an error code in case of
  error.
	
	  Cannot VALIDATE_DESC() here as gpiod_to_irq() consumer semantics
	  requires this function to not return zero on an invalid descriptor
	  but rather a negative error number.
 Zero means NO_IRQ 
  gpiochip_lock_as_irq() - lock a GPIO to be used as IRQ
  @gc: the chip the GPIO to lock belongs to
  @offset: the offset of the GPIO to lock as IRQ
  This is used directly by GPIO drivers that want to lock down
  a certain GPIO line to be used for IRQs.
	
	  If it's fast: flush the direction setting if something changed
	  behind our back
 To be valid for IRQ the line needs to be input or open drain 
	
	  If the consumer has not set up a label (such as when the
	  IRQ is referenced from .to_irq()) we set up a label here
	  so it is clear this is used as an interrupt.
  gpiochip_unlock_as_irq() - unlock a GPIO used as IRQ
  @gc: the chip the GPIO to lock belongs to
  @offset: the offset of the GPIO to lock as IRQ
  This is used directly by GPIO drivers that want to indicate
  that a certain GPIO is no longer used exclusively for IRQ.
 If we only had this marking, erase it 
		
		  We must not be output when using IRQ UNLESS we are
		  open drain.
  gpiod_get_raw_value_cansleep() - return a gpio's raw value
  @desc: gpio whose value will be returned
  Return the GPIO's raw value, i.e. the value of the physical line disregarding
  its ACTIVE_LOW status, or negative errno on failure.
  This function is to be called from contexts that can sleep.
  gpiod_get_value_cansleep() - return a gpio's value
  @desc: gpio whose value will be returned
  Return the GPIO's logical value, i.e. taking the ACTIVE_LOW status into
  account, or negative errno on failure.
  This function is to be called from contexts that can sleep.
  gpiod_get_raw_array_value_cansleep() - read raw values from an array of GPIOs
  @array_size: number of elements in the descriptor array  value bitmap
  @desc_array: array of GPIO descriptors whose values will be read
  @array_info: information on applicability of fast bitmap processing path
  @value_bitmap: bitmap to store the read values
  Read the raw values of the GPIOs, i.e. the values of the physical lines
  without regard for their ACTIVE_LOW status.  Return 0 in case of success,
  else an error code.
  This function is to be called from contexts that can sleep.
  gpiod_get_array_value_cansleep() - read values from an array of GPIOs
  @array_size: number of elements in the descriptor array  value bitmap
  @desc_array: array of GPIO descriptors whose values will be read
  @array_info: information on applicability of fast bitmap processing path
  @value_bitmap: bitmap to store the read values
  Read the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
  into account.  Return 0 in case of success, else an error code.
  This function is to be called from contexts that can sleep.
  gpiod_set_raw_value_cansleep() - assign a gpio's raw value
  @desc: gpio whose value will be assigned
  @value: value to assign
  Set the raw value of the GPIO, i.e. the value of its physical line without
  regard for its ACTIVE_LOW status.
  This function is to be called from contexts that can sleep.
  gpiod_set_value_cansleep() - assign a gpio's value
  @desc: gpio whose value will be assigned
  @value: value to assign
  Set the logical value of the GPIO, i.e. taking its ACTIVE_LOW status into
  account
  This function is to be called from contexts that can sleep.
  gpiod_set_raw_array_value_cansleep() - assign values to an array of GPIOs
  @array_size: number of elements in the descriptor array  value bitmap
  @desc_array: array of GPIO descriptors whose values will be assigned
  @array_info: information on applicability of fast bitmap processing path
  @value_bitmap: bitmap of values to assign
  Set the raw values of the GPIOs, i.e. the values of the physical lines
  without regard for their ACTIVE_LOW status.
  This function is to be called from contexts that can sleep.
  gpiod_add_lookup_tables() - register GPIO device consumers
  @tables: list of tables of consumers to register
  @n: number of tables in the list
  gpiod_set_array_value_cansleep() - assign values to an array of GPIOs
  @array_size: number of elements in the descriptor array  value bitmap
  @desc_array: array of GPIO descriptors whose values will be assigned
  @array_info: information on applicability of fast bitmap processing path
  @value_bitmap: bitmap of values to assign
  Set the logical values of the GPIOs, i.e. taking their ACTIVE_LOW status
  into account.
  This function is to be called from contexts that can sleep.
  gpiod_add_lookup_table() - register GPIO device consumers
  @table: table of consumers to register
  gpiod_remove_lookup_table() - unregister GPIO device consumers
  @table: table of consumers to unregister
 Nothing to remove 
  gpiod_add_hogs() - register a set of GPIO hogs from machine code
  @hogs: table of gpio hog entries with a zeroed sentinel at the end
		
		  The chip may have been registered earlier, so check if it
		  exists and, if so, try to hog the line now.
			
			  Valid strings on both ends, must be identical to have
			  a match
			
			  One of the pointers is NULL, so both must be to have
			  a match
 idx must always match exactly 
 If the lookup entry has a con_id, require exact match 
			
			  As the lookup table indicates a chip with
			  p->key should exist, assume it may
			  still appear later and let the interested
			  consumer be probed again or let the Deferred
			  Probe infrastructure handle the error.
  fwnode_gpiod_get_index - obtain a GPIO from firmware node
  @fwnode:	handle of the firmware node
  @con_id:	function within the GPIO consumer
  @index:	index of the GPIO to obtain for the consumer
  @flags:	GPIO initialization flags
  @label:	label to attach to the requested GPIO
  This function can be used for drivers that get their configuration
  from opaque firmware.
  The function properly finds the corresponding GPIO using whatever is the
  underlying firmware interface and then makes sure that the GPIO
  descriptor is requested before it is returned to the caller.
  Returns:
  On successful request the GPIO pin is configured in accordance with
  provided @flags.
  In case of error an ERR_PTR() is returned.
 32 is max size of property name 
  gpiod_count - return the number of GPIOs associated with a device  function
 		or -ENOENT if no GPIO has been assigned to the requested function
  @dev:	GPIO consumer, can be NULL for system-global GPIOs
  @con_id:	function within the GPIO consumer
  gpiod_get - obtain a GPIO for a given GPIO function
  @dev:	GPIO consumer, can be NULL for system-global GPIOs
  @con_id:	function within the GPIO consumer
  @flags:	optional GPIO initialization flags
  Return the GPIO descriptor corresponding to the function con_id of device
  dev, -ENOENT if no GPIO has been assigned to the requested function, or
  another IS_ERR() code if an error occurred while trying to acquire the GPIO.
  gpiod_get_optional - obtain an optional GPIO for a given GPIO function
  @dev: GPIO consumer, can be NULL for system-global GPIOs
  @con_id: function within the GPIO consumer
  @flags: optional GPIO initialization flags
  This is equivalent to gpiod_get(), except that when no GPIO was assigned to
  the requested function it will return NULL. This is convenient for drivers
  that need to handle optional GPIOs.
  gpiod_configure_flags - helper function to configure a given GPIO
  @desc:	gpio whose value will be assigned
  @con_id:	function within the GPIO consumer
  @lflags:	bitmask of gpio_lookup_flags GPIO_ values - returned from
 		of_find_gpio() or of_get_gpio_hog()
  @dflags:	gpiod_flags - optional GPIO initialization flags
  Return 0 on success, -ENOENT if no GPIO has been assigned to the
  requested function andor index, or another IS_ERR() code if an error
  occurred while trying to acquire the GPIO.
		
		  This enforces open drain mode from the consumer side.
		  This is necessary for some busses like I2C, but the lookup
		  should REALLY have specified them as open drain in the
		  first place, so print a little warning here.
 No particular flag request, return here... 
 Process flags 
  gpiod_get_index - obtain a GPIO from a multi-index GPIO function
  @dev:	GPIO consumer, can be NULL for system-global GPIOs
  @con_id:	function within the GPIO consumer
  @idx:	index of the GPIO to obtain in the consumer
  @flags:	optional GPIO initialization flags
  This variant of gpiod_get() allows to access GPIOs other than the first
  defined one for functions that define several GPIOs.
  Return a valid GPIO descriptor, -ENOENT if no GPIO has been assigned to the
  requested function andor index, or another IS_ERR() code if an error
  occurred while trying to acquire the GPIO.
 Maybe we have a device name, maybe not 
 Using device tree? 
	
	  Either we are not using DT or ACPI, or their lookup did not return
	  a result. In that case, use platform lookup as a fallback.
	
	  If a connection label was passed use that, else attempt to use
	  the device name as label
			
			  This happens when there are several consumers for
			  the same GPIO line: we just return here without
			  further initialization. It is a bit if a hack.
			  This is necessary to support fixed regulators.
			 
			  FIXME: Make this more sane and safe.
  fwnode_get_named_gpiod - obtain a GPIO from firmware node
  @fwnode:	handle of the firmware node
  @propname:	name of the firmware property representing the GPIO
  @index:	index of the GPIO to obtain for the consumer
  @dflags:	GPIO initialization flags
  @label:	label to attach to the requested GPIO
  This function can be used for drivers that get their configuration
  from opaque firmware.
  The function properly finds the corresponding GPIO using whatever is the
  underlying firmware interface and then makes sure that the GPIO
  descriptor is requested before it is returned to the caller.
  Returns:
  On successful request the GPIO pin is configured in accordance with
  provided @dflags.
  In case of error an ERR_PTR() is returned.
 Currently only ACPI takes this path 
  gpiod_get_index_optional - obtain an optional GPIO from a multi-index GPIO
                             function
  @dev: GPIO consumer, can be NULL for system-global GPIOs
  @con_id: function within the GPIO consumer
  @index: index of the GPIO to obtain in the consumer
  @flags: optional GPIO initialization flags
  This is equivalent to gpiod_get_index(), except that when no GPIO with the
  specified index was assigned to the requested function it will return NULL.
  This is convenient for drivers that need to handle optional GPIOs.
  gpiod_hog - Hog the specified GPIO desc given the provided flags
  @desc:	gpio whose value will be assigned
  @name:	gpio line name
  @lflags:	bitmask of gpio_lookup_flags GPIO_ values - returned from
 		of_find_gpio() or of_get_gpio_hog()
  @dflags:	gpiod_flags - optional GPIO initialization flags
 Mark GPIO as hogged so it can be identified and removed later 
  gpiochip_free_hogs - Scan gpio-controller chip and release GPIO hog
  @gc:	gpio chip to act on
  gpiod_get_array - obtain multiple GPIOs from a multi-index GPIO function
  @dev:	GPIO consumer, can be NULL for system-global GPIOs
  @con_id:	function within the GPIO consumer
  @flags:	optional GPIO initialization flags
  This function acquires all the GPIOs defined under a given function.
  Return a struct gpio_descs containing an array of descriptors, -ENOENT if
  no GPIO has been assigned to the requested function, or another IS_ERR()
  code if an error occurred while trying to acquire the GPIOs.
		
		  If pin hardware number of array member 0 is also 0, select
		  its chip as a candidate for fast bitmap processing path.
 Unmark array members which don't belong to the 'fast' chip 
		
		  Detect array members which belong to the 'fast' chip
		  but their pins are not in hardware order.
			
			  Don't use fast path if all array members processed so
			  far belong to the same chip as this one but its pin
			  hardware number is different from its array index.
 Exclude open drain or open source from fast output 
 Identify 'fast' pins which require invertion 
  gpiod_get_array_optional - obtain multiple GPIOs from a multi-index GPIO
                             function
  @dev:	GPIO consumer, can be NULL for system-global GPIOs
  @con_id:	function within the GPIO consumer
  @flags:	optional GPIO initialization flags
  This is equivalent to gpiod_get_array(), except that when no GPIO was
  assigned to the requested function it will return NULL.
  gpiod_put - dispose of a GPIO descriptor
  @desc:	GPIO descriptor to dispose of
  No descriptor can be used after gpiod_put() has been called on it.
  gpiod_put_array - dispose of multiple GPIO descriptors
  @descs:	struct gpio_descs containing an array of descriptors
	
	  Only match if the fwnode doesn't already have a proper struct device
	  created for it.
	
	  The DT node of some GPIO chips have a "compatible" property, but
	  never have a struct device added and probed by a driver to register
	  the GPIO chip with gpiolib. In such cases, fw_devlink=on will cause
	  the consumers of the GPIO chip to get probe deferred forever because
	  they will be waiting for a device associated with the GPIO chip
	  firmware node to get added and bound to a driver.
	 
	  To allow these consumers to probe, we associate the struct
	  gpio_device of the GPIO chip with the firmware node and then simply
	  bind it to this stub driver.
 Register GPIO sysfs bus 
 CONFIG_OF_DYNAMIC && CONFIG_OF_GPIO 
 syskerneldebuggpio 
 DEBUG_FS 
 SPDX-License-Identifier: GPL-2.0-or-later
    bt8xx GPIO abuser
    Copyright (C) 2008 Michael Buesch <m@bues.ch>
    Please do _only_ contact the people listed _above_ with issues related to this driver.
    All the other people listed below are not related to this driver. Their names
    are only here, because this driver is derived from the bt848 driver.
    Derived from the bt848 driver:
    Copyright (C) 1996,97,98 Ralph  Metzler
			   & Marcus Metzler
    (c) 1999-2002 Gerd Knorr
    some v4l2 code lines are taken from Justin's bttv2 driver which is
    (c) 2000 Justin Schoeman
    V4L1 removal from:
    (c) 2005-2006 Nickolay V. Shmyrev
    Fixes to be fully V4L2 compliant by
    (c) 2006 Mauro Carvalho Chehab
    Cropping and overscan support
    Copyright (C) 2005, 2006 Michael H. Schimek
    Sponsored by OPQ Systems AB
 Steal the hardware definitions from the bttv driver. 
 We have 24 GPIO pins 
 dynamic ;
 Disable interrupts 
 gpio init 
 CONFIG_PM 
 SPDX-License-Identifier: GPL-2.0
  Digital IO driver for Technologic Systems TS-5500
  Copyright (c) 2012 Savoir-faire Linux Inc.
 	Vivien Didelot <vivien.didelot@savoirfairelinux.com>
  Technologic Systems platforms have pin blocks, exposing several Digital
  InputOutput lines (DIO). This driver aims to support single pin blocks.
  In that sense, the support is not limited to the TS-5500 blocks.
  Actually, the following platforms have DIO support:
  TS-5500:
    Documentation: http:wiki.embeddedarm.comwikiTS-5500
    Blocks: DIO1, DIO2 and LCD port.
  TS-5600:
    Documentation: http:wiki.embeddedarm.comwikiTS-5600
    Blocks: LCD port (identical to TS-5500 LCD).
 List of supported Technologic Systems platforms DIO blocks 
  Hex 7D is used to control several blocks (e.g. DIO2 and LCD port).
  This flag ensures that the region has been requested by this driver.
  This structure is used to describe capabilities of DIO lines,
  such as available directions and connected interrupt (if any).
  InputOutput DIO lines are programmed in groups of 4. Their values are
  available through 4 consecutive bits in a value port, whereas the direction
  of these 4 lines is driven by only 1 bit in a control port.
  TS-5500 DIO1 block
   value    control  dir    hw
   addr bit addr bit in out irq name     pin offset
   0x7b  0  0x7a  0  x   x      DIO1_0   1   0
   0x7b  1  0x7a  0  x   x      DIO1_1   3   1
   0x7b  2  0x7a  0  x   x      DIO1_2   5   2
   0x7b  3  0x7a  0  x   x      DIO1_3   7   3
   0x7b  4  0x7a  1  x   x      DIO1_4   9   4
   0x7b  5  0x7a  1  x   x      DIO1_5   11  5
   0x7b  6  0x7a  1  x   x      DIO1_6   13  6
   0x7b  7  0x7a  1  x   x      DIO1_7   15  7
   0x7c  0  0x7a  5  x   x      DIO1_8   4   8
   0x7c  1  0x7a  5  x   x      DIO1_9   6   9
   0x7c  2  0x7a  5  x   x      DIO1_10  8   10
   0x7c  3  0x7a  5  x   x      DIO1_11  10  11
   0x7c  4           x          DIO1_12  12  12
   0x7c  5           x      7   DIO1_13  14  13
  TS-5500 DIO2 block
   value    control  dir    hw
   addr bit addr bit in out irq name     pin offset
   0x7e  0  0x7d  0  x   x      DIO2_0   1   0
   0x7e  1  0x7d  0  x   x      DIO2_1   3   1
   0x7e  2  0x7d  0  x   x      DIO2_2   5   2
   0x7e  3  0x7d  0  x   x      DIO2_3   7   3
   0x7e  4  0x7d  1  x   x      DIO2_4   9   4
   0x7e  5  0x7d  1  x   x      DIO2_5   11  5
   0x7e  6  0x7d  1  x   x      DIO2_6   13  6
   0x7e  7  0x7d  1  x   x      DIO2_7   15  7
   0x7f  0  0x7d  5  x   x      DIO2_8   4   8
   0x7f  1  0x7d  5  x   x      DIO2_9   6   9
   0x7f  2  0x7d  5  x   x      DIO2_10  8   10
   0x7f  3  0x7d  5  x   x      DIO2_11  10  11
   0x7f  4           x      6   DIO2_13  14  12
  TS-5500 LCD port used as DIO block
  TS-5600 LCD port is identical
   value    control  dir    hw
   addr bit addr bit in out irq name    pin offset
   0x72  0  0x7d  2  x   x      LCD_0   8   0
   0x72  1  0x7d  2  x   x      LCD_1   7   1
   0x72  2  0x7d  2  x   x      LCD_2   10  2
   0x72  3  0x7d  2  x   x      LCD_3   9   3
   0x72  4  0x7d  3  x   x      LCD_4   12  4
   0x72  5  0x7d  3  x   x      LCD_5   11  5
   0x72  6  0x7d  3  x   x      LCD_6   14  6
   0x72  7  0x7d  3  x   x      LCD_7   13  7
   0x73  0               x      LCD_EN  5   8
   0x73  6           x          LCD_WR  6   9
   0x73  7           x      1   LCD_RS  3   10
 Only one pin is connected to an interrupt 
 As this pin is input-only, we may strap it to another inout pin 
 DIO1_13 on IRQ7 
 DIO2_13 on IRQ6 
 LCD_RS on IRQ1 
 DIO1_13 on IRQ7 
 DIO2_13 on IRQ6 
 LCD_RS on IRQ1 
 Ensure usage of LCD port as DIO 
 SPDX-License-Identifier: GPL-2.0-only
  AppliedMicro X-Gene SoC GPIO Driver
  Copyright (c) 2014, Applied Micro Circuits Corporation
  Author: Feng Kan <fkan@apm.com>.
 SPDX-License-Identifier: GPL-2.0-only
   linuxdriversgpiogpio-mb86s7x.c
   Copyright (C) 2015 Fujitsu Semiconductor Limited
   Copyright (C) 2015 Linaro Ltd.
  Only first 8bits of a register correspond to each pin,
  so there are 4 registers for 32 pins.
 sentinel  }
 sentinel  }
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2010 - 2015 UNISYS CORPORATION
  All rights reserved.
 {72120008-4AAB-11DC-8530-444553544200} 
 The s-Par leaf ID returns "UnisysSpar64" encoded across ebx, ecx, edx 
  When the controlvm channel is idle for at least MIN_IDLE_SECONDS, we switch
  to slow polling mode. As soon as we get a controlvm message, we switch back
  to fast polling mode.
 VMCALL_CONTROLVM_ADDR: Used by all guests, not just IO. 
  struct vmcall_io_controlvm_addr_params - Structure for IO VMCALLS. Has
 					    parameters to VMCALL_CONTROLVM_ADDR
 					    interface.
  @address:	   The Guest-relative physical address of the ControlVm channel.
 		   This VMCall fills this in with the appropriate address.
 		   Contents provided by this VMCALL (OUT).
  @channel_bytes: The size of the ControlVm channel in bytes This VMCall fills
 		   this in with the appropriate address. Contents provided by
 		   this VMCALL (OUT).
  @unused:	   Unused Bytes in the 64-Bit Aligned Struct.
 when we got our last controlvm message 
	
	  The following variables are used to handle the scenario where we are
	  unable to offload the payload from a controlvm message due to memory
	  requirements. In this scenario, we simply stash the controlvm
	  message, then attempt to process it again the next time
	  controlvm_periodic_work() runs.
 prototypes for attributes 
	
	  Set features to indicate we support parahotplug (if Command also
	  supports it). Set the "reply" bit so Command knows this is a
	  features-aware driver.
 Response will be handled by visorbus_create_instance on success 
 only non-NULL if dev is still waiting on a response 
 Response will be handled by visorbus_remove_instance 
 create_visor_device will send response 
 only non-NULL if dev is still waiting on a response 
 Response will be sent from visorchipset_device_resume 
 ServerNotReady  ServerLost  SegmentStateStandby 
		
		  technically this is standby case where server is lost.
		  Response will be sent from visorchipset_device_pause.
 only non-NULL if dev is still waiting on a response 
  The general parahotplug flow works as follows. The visorchipset receives
  a DEVICE_CHANGESTATE message from Command specifying a physical device
  to enable or disable. The CONTROLVM message handler calls
  parahotplug_process_message, which then adds the message to a global list
  and kicks off a udev event which causes a user level script to enable or
  disable the specified device. The udev script then writes to
  sysdevicesplatformvisorchipsetparahotplug, which causes the
  parahotplug store functions to get called, at which point the
  appropriate CONTROLVM message is retrieved from the list and responded to.
  parahotplug_next_id() - generate unique int to match an outstanding
                          CONTROLVM message with a udev script sys
                          response
  Return: a unique integer value
  parahotplug_next_expiration() - returns the time (in jiffies) when a
                                  CONTROLVM message on the list should expire
                                  -- PARAHOTPLUG_TIMEOUT_MS in the future
  Return: expected expiration time (in jiffies)
  parahotplug_request_create() - create a parahotplug_request, which is
                                 basically a wrapper for a CONTROLVM_MESSAGE
                                 that we can stick on a list
  @msg: the message to insert in the request
  Return: the request containing the provided message
  parahotplug_request_destroy() - free a parahotplug_request
  @req: the request to deallocate
 lock for above 
  parahotplug_request_complete() - mark request as complete
  @id:     the id of the request
  @active: indicates whether the request is assigned to active partition
  Called from the sys handler, which means the user script has
  finished the enabledisable. Find the matching identifier, and
  respond to the CONTROLVM message with success.
  Return: 0 on success or -EINVAL on failure
 Look for a request matching "id". 
			
			  Found a match. Remove it from the list and
			  respond.
  devicedisabled_store() - disables the hotplug device
  @dev:   sysfs interface variable not utilized in this function
  @attr:  sysfs interface variable not utilized in this function
  @buf:   buffer containing the device id
  @count: the size of the buffer
  The parahotplugdevicedisabled interface gets called by our support script
  when an SR-IOV device has been shut down. The ID is passed to the script
  and then passed back when the device has been removed.
  Return: the size of the buffer for success or negative for error
  deviceenabled_store() - enables the hotplug device
  @dev:   sysfs interface variable not utilized in this function
  @attr:  sysfs interface variable not utilized in this function
  @buf:   buffer containing the device id
  @count: the size of the buffer
  The parahotplugdeviceenabled interface gets called by our support script
  when an SR-IOV device has been recovered. The ID is passed to the script
  and then passed back when the device has been brought back up.
  Return: the size of the buffer for success or negative for error
  parahotplug_request_kickoff() - initiate parahotplug request
  @req: the request to initiate
  Cause uevent to run the user level script to do the disableenable specified
  in the parahotplug_request.
  parahotplug_process_message() - enables or disables a PCI device by kicking
                                  off a udev script
  @inmsg: the message indicating whether to enable or disable
	
	  For enable messages, just respond with success right away, we don't
	  need to wait to see if the enable was successful.
	
	  For disable messages, add the request to the request list before
	  kicking off the udev script. It won't get responded to until the
	  script has indicated it's done.
  chipset_ready_uevent() - sends chipset_ready action
  Send ACTION=online for DEVPATH=sysdevicesplatformvisorchipset.
  Return: 0 on success, negative on failure
  chipset_selftest_uevent() - sends chipset_selftest action
  Send ACTION=online for DEVPATH=sysdevicesplatformvisorchipset.
  Return: 0 on success, negative on failure
  chipset_notready_uevent() - sends chipset_notready action
  Send ACTION=offline for DEVPATH=sysdevicesplatformvisorchipset.
  Return: 0 on success, negative on failure
 Need to convert from VMCALL error codes to Linux 
 send init chipset msg 
 get saved message count 
 get saved crash message offset 
 read create device message for storage bus offset 
 read create device message for storage device 
 reuse IOVM create bus message 
 reuse create device message for storage device 
 alloc an extra byte to ensure payload is \0 terminated 
  handle_command() - process a controlvm message
  @inmsg:        the message to process
  @channel_addr: address of the controlvm channel
  Return:
 	0	- Successfully processed the message
 	-EAGAIN - ControlVM message was not processed and should be retried
 		  reading the next controlvm message; a scenario where this can
 		  occur is when we need to throttle the allocation of memory in
 		  which to copy out controlvm payload data.
 	< 0	- error: ControlVM message was processed but an error occurred.
 create parsing context if necessary 
	
	  Parameter and channel addresses within test messages actually lie
	  within our OS-controlled memory. We need to know that, because it
	  makes a difference in how we compute the virtual address.
			
			  save the hdr and cmd structures for later use when
			  sending back the response to Command
 no op just send a respond that we passed 
  read_controlvm_event() - retreives the next message from the
                           CONTROLVM_QUEUE_EVENT queue in the controlvm
                           channel
  @msg: pointer to the retrieved message
  Return: 0 if valid message was retrieved or -error
 got a message 
  parahotplug_process_list() - remove any request from the list that's been on
                               there too long and respond with an error
 Drain the RESPONSE queue make it empty 
		
		  we throttled processing of a prior msg, so try to process
		  it again rather than reading a new one
 parahotplug_worker 
  The controlvm messages are sent in a bulk. If we start receiving messages, we
  want the polling to be fast. If we do not receive any message for
  MIN_IDLE_SECONDS, we can slow down the polling.
		
		  it's been longer than MIN_IDLE_SECONDS since we processed
		  our last controlvm message; slow down the polling
 if booting in a crash kernel 
 check the ID 
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2010 - 2015 UNISYS CORPORATION
  All rights reserved.
   This provides s-Par channel communication primitives, which are
   independent of the mechanism used to access the channel data.
	
	  channel creator knows if more than one thread will be inserting or
	  removing
 protect head writes in chan_hdr 
 protect tail writes in chan_hdr 
  visorchannel_get_guid() - queries the GUID of the designated channel
  @channel: the channel to query
  Return: the GUID of the provided channel
  Return offset of a specific SIGNAL_QUEUE_HEADER from the beginning of a
  channel header
  Return offset of a specific queue entry (data) from the beginning of a
  channel header
  Write the contents of a specific field within a SIGNAL_QUEUE_HEADER back into
  host memory
 Read the appropriate SIGNAL_QUEUE_HEADER into local memory. 
 No signals to remove; have caller try again. 
	
	  For each data field in SIGNAL_QUEUE_HEADER that was modified, update
	  host memory. Required for channel sync.
  visorchannel_signalremove() - removes a message from the designated
                                channelqueue
  @channel: the channel the message will be removed from
  @queue:   the queue the message will be removed from
  @msg:     the message to remove
  Return: integer error code indicating the status of the removal
  visorchannel_signalempty() - checks if the designated channelqueue contains
 				any messages
  @channel: the channel to query
  @queue:   the queue in the channel to query
  Return: boolean indicating whether any messages in the designated
          channelqueue are present
	
	  For each data field in SIGNAL_QUEUE_HEADER that was modified, update
	  host memory. Required for channel sync.
  visorchannel_create() - creates the struct visorchannel abstraction for a
                          data area in memory, but does NOT modify this data
                          area
  @physaddr:      physical address of start of channel
  @gfp:           gfp_t to use when allocating memory for the data struct
  @guid:          GUID that identifies channel type;
  @needs_lock:    must specify true if you have multiple threads of execution
                  that will be calling visorchannel methods of this
                  visorchannel at the same time
  Return: pointer to visorchannel that was created if successful,
          otherwise NULL
	
	  Video driver constains the efi framebuffer so it will get a conflict
	  resource when requesting its full mem region. Since we are only
	  using the efi framebuffer for video we can ignore this. Remember that
	  we haven't requested it so we don't try to release later on.
 we only care about errors if this is not the video channel 
 we only care about errors if this is not the video channel 
  visorchannel_signalinsert() - inserts a message into the designated
                                channelqueue
  @channel: the channel the message will be added to
  @queue:   the queue the message will be added to
  @msg:     the message to insert
  Return: integer error code indicating the status of the insertion
 SPDX-License-Identifier: GPL-2.0
  Copyright  2010 - 2015 UNISYS CORPORATION
  All rights reserved.
 Display string that is guaranteed to be no longer the 99 characters 
 stores whether bus_registration was successful 
  DEVICE type attributes
  The modalias file will contain the guid of the device.
 filled in with info about parent chipset driver when we register with it 
 filled in with info about this driver, wrt it servicing client busses 
 list of visor_device structs, linked via .list_all 
 list of visor_device structs, linked via .list_all 
  Generic function useful for validating any type of channel when it is
  received by the client that will be accessing the channel.
  Note that <logCtx> is only needed for callers in the EFI environment, and
  is used to pass the EFI_DIAG_CAPTURE_PROTOCOL needed to log messages.
 caller wants us to verify type GUID 
 verify channel size 
 verify channel version 
 verify channel signature 
  visorbus_match() - called automatically upon adding a visor_device
                     (device_add), or adding a visor_driver
                     (visorbus_register_visor_driver)
  @xdev: struct device for the device being matched
  @xdrv: struct device_driver for driver to match device against
  Return: 1 iff the provided driver can control the specified device
  This describes the TYPE of bus.
  (Don't confuse this with an INSTANCE of the bus.)
  visorbus_release_busdevice() - called when device_unregister() is called for
                                 the bus device instance, after all other tasks
                                 involved with destroying the dev are complete
  @xdev: struct device for the bus being released
  visorbus_release_device() - called when device_unregister() is called for
                              each child device instance
  @xdev: struct device for the visor device being released
  BUS specific channel attributes to appear under
  sysbusvisorbus<x>dev<y>channel
   BUS instance attributes
   define & implement display of bus attributes under
   sysbusvisorbusdevicesvisorbus<n>.
   BUS debugfs entries
   define & implement display of debugfs attributes under
   syskerneldebugvisorbusvisorbus<n>.
  vbuschannel_print_devinfo() - format a struct visor_vbus_deviceinfo
                                and write it to a seq_file
  @devinfo: the struct visor_vbus_deviceinfo to format
  @seq: seq_file to write to
  @devix: the device index to be included in the output data, or -1 if no
          device index is to be included
  Reads @devInfo, and writes it in human-readable notation to @seq.
 uninitialized vbus device entry 
 vbus device entry is for bus or chipset 
	
	  Note: because the s-Par back-end is free to scribble in this area,
	  we never assume '\0'-termination.
 now up by at least 2 
  visordriver_remove_device() - handle visor device going away
  @xdev: struct device for the visor device being removed
  This is called when device_unregister() is called for each child device
  instance, to notify the appropriate visorbus function driver that the device
  is going away, and to decrease the reference count of the device.
  Return: 0 iff successful
  visorbus_unregister_visor_driver() - unregisters the provided driver
  @drv: the driver to unregister
  A visor function driver calls this function to unregister the driver,
  i.e., within its module_exit function.
  visorbus_read_channel() - reads from the designated channel into
                            the provided buffer
  @dev:    the device whose channel is read from
  @offset: the offset into the channel at which reading starts
  @dest:   the destination buffer that is written into from the channel
  @nbytes: the number of bytes to read from the channel
  If receiving a message, use the visorchannel_signalremove() function instead.
  Return: integer indicating success (zero) or failure (non-zero)
  visorbus_write_channel() - writes the provided buffer into the designated
                             channel
  @dev:    the device whose channel is written to
  @offset: the offset into the channel at which writing starts
  @src:    the source buffer that is written into the channel
  @nbytes: the number of bytes to write into the channel
  If sending a message, use the visorchannel_signalinsert() function instead.
  Return: integer indicating success (zero) or failure (non-zero)
  visorbus_enable_channel_interrupts() - enables interrupts on the
                                         designated device
  @dev: the device on which to enable interrupts
  Currently we don't yet have a real interrupt, so for now we just call the
  interrupt function periodically via a timer.
  visorbus_disable_channel_interrupts() - disables interrupts on the
                                          designated device
  @dev: the device on which to disable interrupts
  create_visor_device() - create visor device as a result of receiving the
                          controlvm device_create message for a new device
  @dev: a freshly-zeroed struct visor_device, containing only filled-in values
        for chipset_bus_no and chipset_dev_no, that will be initialized
  This is how everything starts from the device end.
  This function is called when a channel first appears via a ControlVM
  message.  In response, this function allocates a visor_device to correspond
  to the new channel, and attempts to connect it the appropriate  driver. If
  the appropriate driver is found, the visor_driver.probe() function for that
  driver will be called, and will be passed the new  visor_device that we
  just created.
  It's ok if the appropriate driver is not yet loaded, because in that case
  the new device struct will just stick around in the bus' list of devices.
  When the appropriate driver calls visorbus_register_visor_driver(), the
  visor_driver.probe() for the new driver will be called with the new device.
  Return: 0 if successful, otherwise the negative value returned by
          device_add() indicating the reason for failure
 keep a reference just for us (now 2) 
	
	  bus_id must be a unique name with respect to this bus TYPE (NOT bus
	  instance).  That's why we need to include the bus number within the
	  name.
	
	  device_add does this:
	     bus_add_device(dev)
	     ->device_attach(dev)
	       ->for each driver drv registered on the bus that dev is on
	           if (dev.drv)    device already has a driver 
	              not sure we could ever get here... 
	           else
	             if (bus.match(dev,drv)) [visorbus_match]
	               dev.drv = drv
	               if (!drv.probe(dev))  [visordriver_probe_device]
	                 dev.drv = NULL
	 
	  Note that device_add does NOT fail if no driver failed to claim the
	  device.  The device will be linked onto bus_type.klist_devices
	  regardless (use bus_for_each_dev).
 success: reference kept via unmatched get_device() 
  write_vbus_chp_info() - write the contents of <info> to the struct
                          visor_vbus_channel.chp_info
  @chan:     indentifies the s-Par channel that will be updated
  @hdr_info: used to find appropriate channel offset to write data
  @info:     contains the information to write
  Writes chipset info into the channel memory to be used for diagnostic
  purposes.
  Returns no value since this is debug information and not needed for
  device functionality.
  write_vbus_bus_info() - write the contents of <info> to the struct
                          visor_vbus_channel.bus_info
  @chan:     indentifies the s-Par channel that will be updated
  @hdr_info: used to find appropriate channel offset to write data
  @info:     contains the information to write
  Writes bus info into the channel memory to be used for diagnostic
  purposes.
  Returns no value since this is debug information and not needed for
  device functionality.
  write_vbus_dev_info() - write the contents of <info> to the struct
                          visor_vbus_channel.dev_info[<devix>]
  @chan:     indentifies the s-Par channel that will be updated
  @hdr_info: used to find appropriate channel offset to write data
  @info:     contains the information to write
  @devix:    the relative device number (0..n-1) of the device on the bus
  Writes device info into the channel memory to be used for diagnostic
  purposes.
  Returns no value since this is debug information and not needed for
  device functionality.
  publish_vbus_dev_info() - for a child device just created on a client bus,
 			     fill in information about the driver that is
 			     controlling this device into the appropriate slot
 			     within the vbus channel of the bus instance
  @visordev: struct visor_device for the desired device
	
	  Within the list of device types (by GUID) that the driver
	  says it supports, find out which one of those types matches
	  the type of this device, so that we can include the device
	  type name
  visordriver_probe_device() - handle new visor device coming online
  @xdev: struct device for the visor device being probed
  This is called automatically upon adding a visor_device (device_add), or
  adding a visor_driver (visorbus_register_visor_driver), but only after
  visorbus_match() has returned 1 to indicate a successful match between
  driver and device.
  If successful, a reference to the device will be held onto via get_device().
  Return: 0 if successful, meaning the function driver's probe() function
          was successful with this device, otherwise a negative errno
          value indicating failure reason
 success: reference kept via unmatched get_device() 
  visorbus_register_visor_driver() - registers the provided visor driver for
 				      handling one or more visor device
                                     types (channel_types)
  @drv: the driver to register
  A visor function driver calls this function to register the driver. The
  caller MUST fill in the following fields within the #drv structure:
      name, version, owner, channel_types, probe, remove
  Here's how the whole Linux bus  driver  device model works.
  At system start-up, the visorbus kernel module is loaded, which registers
  visorbus_type as a bus type, using bus_register().
  All kernel modules that support particular device types on a
  visorbus bus are loaded.  Each of these kernel modules calls
  visorbus_register_visor_driver() in their init functions, passing a
  visor_driver struct.  visorbus_register_visor_driver() in turn calls
  register_driver(&visor_driver.driver).  This .driver member is
  initialized with generic methods (like probe), whose sole responsibility
  is to act as a broker for the real methods, which are within the
  visor_driver struct.  (This is the way the subclass behavior is
  implemented, since visor_driver is essentially a subclass of the
  generic driver.)  Whenever a driver_register() happens, core bus code in
  the kernel does (see device_attach() in driversbasedd.c):
      for each dev associated with the bus (the bus that driver is on) that
      does not yet have a driver
          if bus.match(dev,newdriver) == yes_matched   .match specified
                                                  during bus_register().
              newdriver.probe(dev)   for visor drivers, this will call
                     the generic driver.probe implemented in visorbus.c,
                     which in turn calls the probe specified within the
                     struct visor_driver (which was specified by the
                     actual device driver as part of
                     visorbus_register_visor_driver()).
  The above dance also happens when a new device appears.
  So the question is, how are devices created within the system?
  Basically, just call device_add(dev).  See pci_bus_add_devices().
  pci_scan_device() shows an example of how to build a device struct.  It
  returns the newly-created struct to pci_scan_single_device(), who adds it
  to the list of devices at PCIBUS.devices.  That list of devices is what
  is traversed by pci_bus_add_devices().
  Return: integer indicating success (zero) or failure (non-zero)
 can't register on a nonexistent bus 
	
	  driver_register does this:
	    bus_add_driver(drv)
	    ->if (drv.bus)   (bus_type) 
	        driver_attach(drv)
	          for each dev with bus type of drv.bus
	            if (!dev.drv)   no driver assigned yet 
	              if (bus.match(dev,drv))  [visorbus_match]
	                dev.drv = drv
	                if (!drv.probe(dev))   [visordriver_probe_device]
	                  dev.drv = NULL
  visorbus_create_instance() - create a device instance for the visorbus itself
  @dev: struct visor_device indicating the bus instance
  Return: 0 for success, otherwise negative errno value indicating reason for
          failure
  visorbus_remove_instance() - remove a device instance for the visorbus itself
  @dev: struct visor_device indentifying the bus to remove
	
	  Note that this will result in the release method for
	  dev->dev being called, which will call
	  visorbus_release_busdevice().  This has something to do with
	  the put_device() done in device_unregister(), but I have never
	  successfully been able to trace thru the code to see wherehow
	  release() gets called.  But I know it does.
  remove_all_visor_devices() - remove all child visorbus device instances
  pause_state_change_complete() - the callback function to be called by a
                                  visorbus function driver when a
                                  pending "pause device" operation has
                                  completed
  @dev: struct visor_device identifying the paused device
  @status: 0 iff the pause state change completed successfully, otherwise
           a negative errno value indicating the reason for failure
  resume_state_change_complete() - the callback function to be called by a
                                   visorbus function driver when a
                                   pending "resume device" operation has
                                   completed
  @dev: struct visor_device identifying the resumed device
  @status: 0 iff the resume state change completed successfully, otherwise
           a negative errno value indicating the reason for failure
	
	  Notify the chipset driver that the resume is complete,
	  which will presumably want to send some sort of response to
	  the initiator.
  visorchipset_initiate_device_pause_resume() - start a pause or resume
                                                operation for a visor device
  @dev: struct visor_device identifying the device being paused or resumed
  @is_pause: true to indicate pause operation, false to indicate resume
  Tell the subordinate function driver for a specific device to pause
  or resume that device.  Successfailure result is returned asynchronously
  via a callback function; see pause_state_change_complete() and
  resume_state_change_complete().
 If no driver associated with the device nothing to pauseresume 
		
		  The vbus_dev_info structure in the channel was been cleared,
		  make sure it is valid.
  visorchipset_device_pause() - start a pause operation for a visor device
  @dev_info: struct visor_device identifying the device being paused
  Tell the subordinate function driver for a specific device to pause
  that device.  Successfailure result is returned asynchronously
  via a callback function; see pause_state_change_complete().
  visorchipset_device_resume() - start a resume operation for a visor device
  @dev_info: struct visor_device identifying the device being resumed
  Tell the subordinate function driver for a specific device to resume
  that device.  Successfailure result is returned asynchronously
  via a callback function; see resume_state_change_complete().
 SPDX-License-Identifier: GPL-2.0-only
 Copyright(c) 2021 Intel Corporation. All rights reserved. 
  Ordered workqueue for cxl nvdimm device arrival and departure
  to coordinate bus rescans when a bridge arrives and trigger remove
  operations when the bridge is removed.
 4-byte status follows the input data in the payload 
	
	  Set "firmware" status (4-packed bytes at the end of the input
	  payload.
	
	  No firmware response to translate, let the transport error
	  code take precedence.
	
	  Set the state of cxl_nvdimm devices to unbound  idle before
	  nvdimm_bus_unregister() rips the nvdimm objects out from
	  underneath them.
 SPDX-License-Identifier: GPL-2.0-only
 Copyright(c) 2020 Intel Corporation. All rights reserved. 
  DOC: cxl pci
  This implements the PCI exclusive functionality for a CXL device as it is
  defined by the Compute Express Link specification. CXL devices may surface
  certain functionality even if it isn't CXL enabled. While this driver is
  focused around the PCI specific aspects of a CXL device, it binds to the
  specific CXL memory device class code, and therefore the implementation of
  cxl_pci is focused around CXL memory devices.
  The driver has several responsibilities, mainly:
   - Create the memX device and register on the CXL bus.
   - Enumerate device's register interface and map them.
   - Registers nvdimm bridge device with cxl_core.
   - Registers a CXL mailbox with cxl_core.
 CXL 2.0 - 8.2.8.4 
 Check again in case preempted before timeout test 
  __cxl_pci_mbox_send_cmd() - Execute a mailbox command
  @cxlm: The CXL memory device to communicate with.
  @mbox_cmd: Command to send to the memory device.
  Context: Any context. Expects mbox_mutex to be held.
  Return: -ETIMEDOUT if timeout occurred waiting for completion. 0 on success.
          Caller should check the return code in @mbox_cmd to make sure it
          succeeded.
  This is a generic form of the CXL mailbox send command thus only using the
  registers defined by the mailbox capability ID - CXL 2.0 8.2.8.4. Memory
  devices, and perhaps other types of CXL devices may have further information
  available upon error conditions. Driver facilities wishing to send mailbox
  commands should use the wrapper command.
  The CXL spec allows for up to two mailboxes. The intention is for the primary
  mailbox to be OS controlled and the secondary mailbox to be used by system
  firmware. This allows the OS and firmware to communicate with the device and
  not need to coordinate with each other. The driver only uses the primary
  mailbox.
	
	  Here are the steps from 8.2.8.4 of the CXL 2.0 spec.
	    1. Caller reads MB Control Register to verify doorbell is clear
	    2. Caller writes Command Register
	    3. Caller writes Command Payload Registers if input payload is non-empty
	    4. Caller writes MB Control Register to set doorbell
	    5. Caller either polls for doorbell to be clear or waits for interrupt if configured
	    6. Caller reads MB Status Register to fetch Return code
	    7. If command successful, Caller reads Command Register to get Payload Length
	    8. If output payload is non-empty, host reads Command Payload Registers
	 
	  Hardware is free to do whatever it wants before the doorbell is rung,
	  and isn't allowed to change anything after it clears the doorbell. As
	  such, steps 2 and 3 can happen in any order, and steps 6, 7, 8 can
	  also happen in any order (though some orders might not make sense).
 #1 
 #2, #3 
 #4 
 #5 
 #6 
 #7 
 #8 
		
		  Sanitize the copy. If hardware misbehaves, out_len per the
		  spec can actually be greater than the max allowed size (21
		  bits available but spec defined 1M max). The caller also may
		  have requested less data than the hardware supplied even
		  within spec.
  cxl_pci_mbox_get() - Acquire exclusive access to the mailbox.
  @cxlm: The memory device to gain access to.
  Context: Any context. Takes the mbox_mutex.
  Return: 0 if exclusive access was acquired.
	
	  XXX: There is some amount of ambiguity in the 2.0 version of the spec
	  around the mailbox interface ready (8.2.8.5.1.1).  The purpose of the
	  bit is to allow firmware running on the device to notify the driver
	  that it's ready to receive commands. It is unclear if the bit needs
	  to be read for each transaction mailbox, ie. the firmware can switch
	  it on and off as needed. Second, there is no defined timeout for
	  mailbox ready, like there is for the doorbell interface.
	 
	  Assumptions:
	  1. The firmware might toggle the Mailbox Interface Ready bit, check
	     it for every command.
	 
	  2. If the doorbell is clear, the firmware should have first set the
	     Mailbox Interface Ready bit. Therefore, waiting for the doorbell
	     to be ready is sufficient.
	
	  Hardware shouldn't allow a ready status but also have failure bits
	  set. Spit out an error, this should be a bug report
 with lock held 
  cxl_pci_mbox_put() - Release exclusive access to the mailbox.
  @cxlm: The CXL memory device to communicate with.
  Context: Any context. Expects mbox_mutex to be held.
	
	  CXL 2.0 8.2.8.4.3 Mailbox Capabilities Register
	 
	  If the size is too small, mandatory commands will not work and so
	  there's no point in going forward. If the size is too large, there's
	  no harm is soft limiting it.
 Basic sanity check that BAR is big enough 
  cxl_find_regblock() - Locate register blocks by type
  @pdev: The CXL PCI device to enumerate.
  @type: Register Block Indicator id
  @map: Enumeration output, clobbered on error
  Return: 0 if register block enumerated, negative error code otherwise
  A CXL DVSEC may point to one or more register blocks, search for them
  by @type.
	
	  Double check the anonymous union trickery in struct cxl_regs
	  FIXME switch to struct_group()
 PCI class code for CXL.mem Type-3 Devices 
 terminate list  },
 SPDX-License-Identifier: GPL-2.0-only
 Copyright(c) 2021 Intel Corporation. All rights reserved. 
 Encode defined in CXL 2.0 8.2.5.12.7 HDM Decoder Control Register 
 TODO walk DVSEC to find component register base 
  A host bridge is a dport to a CFMWS decode and it is a uport to the
  dport (PCIe Root Ports) in the host bridge.
	
	  Note that this lookup already succeeded in
	  to_cxl_host_bridge(), so no need to check for failure here
 TODO: Scan CHBCR for HDM Decoder resources 
	
	  Per the CXL specification (8.2.5.12 CXL HDM Decoder Capability
	  Structure) single ported host-bridges need not publish a decoder
	  capability when a passthrough decode can be assumed, i.e. all
	  transactions that the uport sees are claimed and passed to the single
	  dport. Disable the range until the first CXL region is enumerated 
	  activated.
 for cxl_test request a non-canonical instance 
	
	  Root level scanned with host-bridge as dports, now scan host-bridges
	  for their role as CXL uports to their CXL-capable PCIe Root Ports.
 SPDX-License-Identifier: GPL-2.0-only
 Copyright(c) 2020 Intel Corporation. All rights reserved. 
  DOC: cxl mbox
  Core implementation of the CXL 2.0 Type-3 Memory Device Mailbox. The
  implementation is used by the cxl_pci driver to initialize the device
  and implement the cxl_mem.h IOCTL UAPI. It also implements the
  backend of the cxl_pmem_ctl() transport for LIBNVDIMM.
  This table defines the supported mailbox commands for the driver. This table
  is made up of a UAPI structure. Non-negative values as parameters in the
  table will be validated against the user's input. For example, if size_in is
  0, and the user passed in 1, it is an error.
  Commands that RAW doesn't permit. The rationale for each:
  CXL_MBOX_OP_ACTIVATE_FW: Firmware activation requires adjustment 
  coordination of transaction timeout values at the root bridge level.
  CXL_MBOX_OP_SET_PARTITION_INFO: The device memory map may change live
  and needs to be coordinated with HDM updates.
  CXL_MBOX_OP_SET_LSA: The label storage area may be cached by the
  driver and any writes from userspace invalidates those contents.
  CXL_MBOX_OP_SET_SHUTDOWN_STATE: Set shutdown state assumes no writes
  to the device after it is marked clean, userspace can not make that
  assertion.
  CXL_MBOX_OP_[GET_]SCAN_MEDIA: The kernel provides a native error list that
  is kept up to date with patrol notifications and error management.
  Command sets that RAW doesn't permit. All opcodes in this set are
  disabled because they pass plain text security payloads over the
  userkernel boundary. This functionality is intended to be wrapped
  behind the keys ABI which allows for encrypted payloads in the UAPI
 Sanitize 
 Persistent Memory Data-at-rest Security 
 Security Passthrough 
  cxl_mem_mbox_send_cmd() - Send a mailbox command to a memory device.
  @cxlm: The CXL memory device to communicate with.
  @opcode: Opcode for the mailbox command.
  @in: The input payload for the mailbox command.
  @in_size: The length of the input payload
  @out: Caller allocated buffer for the output.
  @out_size: Expected size of output.
  Context: Any context. Will acquire and release mbox_mutex.
  Return:
    %>=0	- Number of bytes returned in @out.
    %-E2BIG	- Payload is too large for hardware.
    %-EBUSY	- Couldn't acquire exclusive mailbox access.
    %-EFAULT	- Hardware error occurred.
    %-ENXIO	- Command completed, but device reported an error.
    %-EIO	- Unexpected output size.
  Mailbox commands may execute successfully yet the device itself reported an
  error. While this distinction can be useful for commands from userspace, the
  kernel will only be able to use results when both are successful.
  See __cxl_mem_mbox_send_cmd()
 TODO: Map return code to proper kernel style errno 
	
	  Variable sized commands can't be validated and so it's up to the
	  caller to do that if they wish.
  cxl_validate_cmd_from_user() - Check fields for CXL_MEM_SEND_COMMAND.
  @cxlm: &struct cxl_mem device whose mailbox will be used.
  @send_cmd: &struct cxl_send_command copied in from userspace.
  @out_cmd: Sanitized and populated &struct cxl_mem_command.
  Return:
    %0	- @out_cmd is ready to send.
    %-ENOTTY	- Invalid command specified.
    %-EINVAL	- Reserved fields or invalid values were used.
    %-ENOMEM	- Input or output buffer wasn't sized properly.
    %-EPERM	- Attempted to use a protected command.
    %-EBUSY	- Kernel has claimed exclusive access to this opcode
  The result of this command is a fully validated command in @out_cmd that is
  safe to send to the hardware.
  See handle_mailbox_cmd_from_user()
	
	  The user can never specify an input payload larger than what hardware
	  supports, but output can be arbitrarily large (simply write out as
	  much data as the hardware provides).
	
	  Checks are bypassed for raw commands but a WARNtaint will occur
	  later in the callchain
		
		  Unlike supported commands, the output size of RAW commands
		  gets passed along without further checking, so it must be
		  validated here.
 Convert user's command into the internal representation 
 Check that the command is enabled for hardware 
 Check that the command is not claimed for exclusive kernel use 
 Check the input buffer is the expected size 
 Check the output buffer is at least large enough 
	
	  XXX: out_cmd->info.size_out will be controlled by the driver, and the
	  specified number of bytes @send_cmd->out.size will be copied back out
	  to userspace.
 returns the total number if 0 elements are requested. 
	
	  otherwise, return max(n_commands, total commands) cxl_command_info
	  structures.
  handle_mailbox_cmd_from_user() - Dispatch a mailbox command for userspace.
  @cxlm: The CXL memory device to communicate with.
  @cmd: The validated command.
  @in_payload: Pointer to userspace's input payload.
  @out_payload: Pointer to userspace's output payload.
  @size_out: (Input) Max payload size to copy out.
             (Output) Payload size hardware generated.
  @retval: Hardware generated return code from the operation.
  Return:
    %0	- Mailbox transaction succeeded. This implies the mailbox
 		  protocol completed successfully not that the operation itself
 		  was successful.
    %-ENOMEM  - Couldn't allocate a bounce buffer.
    %-EFAULT	- Something happened with copy_tofrom_user.
    %-EINTR	- Mailbox acquisition interrupted.
    %-EXXX	- Transaction level failures.
  Creates the appropriate mailbox command and dispatches it on behalf of a
  userspace request. The input and output payloads are copied between
  userspace.
  See cxl_send_cmd().
	
	  @size_out contains the max size that's allowed to be written back out
	  to userspace. While the payload may have written more output than
	  this it will have to be ignored.
 Prepare to handle a full payload for variable sized output 
  cxl_walk_cel() - Walk through the Command Effects Log.
  @cxlm: Device.
  @size: Length of the Command Effects Log.
  @cel: CEL
  Iterate over each entry in the CEL and determine if the driver supports the
  command. If so, the command is enabled for the device and can be used later.
 See CXL 2.0 Table 170. Get Log Input Payload 
  cxl_mem_enumerate_cmds() - Enumerate commands for a device.
  @cxlm: The device.
  Returns 0 if enumerate completed successfully.
  CXL devices have optional support for certain commands. This function will
  determine the set of supported commands for the hardware and update the
  enabled_cmds bitmap in the @cxlm.
 In case CEL was bogus, enable some default commands. 
 Found the required CEL 
  cxl_mem_get_partition_info - Get partition info
  @cxlm: cxl_mem instance to update partition info
  Retrieve the current partition info for the device specified.  The active
  values are the current capacity in bytes.  If not 0, the 'next' values are
  the pending values, in bytes, which take affect on next cold reset.
  Return: 0 if no error: or the result of the mailbox command.
  See CXL @8.2.9.5.2.1 Get Partition Info
  cxl_mem_identify() - Send the IDENTIFY command to the device.
  @cxlm: The device to identify.
  Return: 0 if identify was executed successfully.
  This will dispatch the identify command to the device and on success populate
  structures to be exported to sysfs.
 See CXL 2.0 Table 175 Identify Memory Device Output Payload 
 SPDX-License-Identifier: GPL-2.0-only
 Copyright(c) 2020 Intel Corporation. 
  DOC: cxl pmem
  The core CXL PMEM infrastructure supports persistent memory
  provisioning and serves as a bridge to the LIBNVDIMM subsystem. A CXL
  'bridge' device is added at the root of a CXL device topology if
  platform firmware advertises at least one persistent memory capable
  CXL window. That root-level bridge corresponds to a LIBNVDIMM 'bus'
  device. Then for each cxl_memdev in the CXL device topology a bridge
  device is added to host a LIBNVDIMM dimm object. When these bridges
  are registered native LIBNVDIMM uapis are translated to CXL
  operations, for example, namespace label access commands.
	
	  If the bridge was ever activated then there might be in-flight state
	  work to flush. Once the state has been changed to 'dead' then no new
	  work can be queued by user-triggered bind.
	
	  Even though the device core will trigger device_release_driver()
	  before the unregister, it does not know about the fact that
	  cxl_nvdimm_bridge_driver defers ->remove() work. So, do the driver
	  release not and flush it before tearing down the nvdimm device
	  hierarchy.
  devm_cxl_add_nvdimm_bridge() - add the root of a LIBNVDIMM topology
  @host: platform firmware root device
  @port: CXL port at the root of a CXL topology
  Return: bridge device that can host cxl_nvdimm objects
  devm_cxl_add_nvdimm() - add a bridge between a cxl_memdev and an nvdimm
  @host: same host as @cxlmd
  @cxlmd: cxl_memdev instance that will perform LIBNVDIMM operations
  Return: 0 on success negative error code on failure.
 SPDX-License-Identifier: GPL-2.0-only
 Copyright(c) 2020 Intel Corporation. All rights reserved. 
  DOC: cxl core
  The CXL core provides a set of interfaces that can be consumed by CXL aware
  drivers. The interfaces allow for creation, modification, and destruction of
  regions, memory devices, ports, and decoders. CXL aware drivers must register
  with the CXL core via these interfaces in order to be able to participate in
  cross-device interleave coordination. The CXL core also establishes and
  maintains the bridge to the nvdimm subsystem.
  CXL core introduces sysfs hierarchy to control the devices that are
  instantiated by the core.
	
	  The top-level cxl_port "cxl_root" does not have a cxl_port as
	  its parent and it does not have any corresponding component
	  registers as its decode is described by a fixed platform
	  description.
  devm_cxl_add_port - register a cxl_port in CXL memory decode hierarchy
  @host: host device for devm operations
  @uport: "physical" device implementing this upstream port
  @component_reg_phys: (optional) for configurable cxl_port instances
  @parent_port: next hop up in the CXL memory decode hierarchy
  cxl_add_dport - append downstream port data to a cxl_port
  @port: the cxl_port that references this dport
  @dport_dev: firmware or PCI device representing the dport
  @port_id: identifier for this dport in a decoder's target list
  @component_reg_phys: optional location of CXL component registers
  Note that all allocations and links are undone by cxl_port deletion
  and release.
 root ports do not have a cxl_port_type parent 
  __cxl_driver_register - register a driver for the cxl bus
  @cxl_drv: cxl driver structure to attach
  @owner: owning moduledriver
  @modname: KBUILD_MODNAME for parent driver
 SPDX-License-Identifier: GPL-2.0-only
 Copyright(c) 2020 Intel Corporation. 
  DOC: cxl registers
  CXL device capabilities are enumerated by PCI DVSEC (Designated
  Vendor-specific) and  or descriptors provided by platform firmware.
  They can be defined as a set like the device and component registers
  mandated by CXL Section 8.1.12.2 Memory Device PCIe Capabilities and
  Extended Capabilities, or they can be individual capabilities
  appended to bridged and endpoint devices.
  Provide common infrastructure for enumerating and mapping these
  discrete capabilities.
  cxl_probe_component_regs() - Detect CXL Component register blocks
  @dev: Host device of the @base mapping
  @base: Mapping containing the HDM Decoder Capability Header
  @map: Map object describing the register block information found
  See CXL 2.0 8.2.4 Component Register Layout and Definition
  See CXL 2.0 8.2.5.5 CXL Device Register Interface
  Probe for component register information and return it in map object.
	
	  CXL.cache and CXL.mem registers are at offset 0x1000 as defined in
	  CXL 2.0 8.2.4 Table 141.
 It's assumed that future versions will be backward compatible 
  cxl_probe_device_regs() - Detect CXL Device register blocks
  @dev: Host device of the @base mapping
  @base: Mapping of CXL 2.0 8.2.8 CXL Device Register Interface
  @map: Map object describing the register block information found
  Probe for device register information and return it in map object.
 SPDX-License-Identifier: GPL-2.0-only
 Copyright(c) 2020 Intel Corporation. 
  An entire PCI topology full of devices should be enough for any
  config
  set_exclusive_cxl_commands() - atomically disable user cxl commands
  @cxlm: cxl_mem instance to modify
  @cmds: bitmap of commands to mark exclusive
  Grab the cxl_memdev_rwsem in write mode to flush in-flight
  invocations of the ioctl path and then disable future execution of
  commands with the command ids set in @cmds.
  clear_exclusive_cxl_commands() - atomically enable user cxl commands
  @cxlm: cxl_mem instance to modify
  @cmds: bitmap of commands to mark available for userspace
	
	  Activate ioctl operations, no cxl_memdev_rwsem manipulation
	  needed as this is ordered with cdev_add() publishing the device.
	
	  The cdev was briefly live, shutdown any ioctl operations that
	  saw that state.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018, The Linux Foundation. All rights reserved.
  In Certain QCOM SoCs like apq8096 and msm8996 that have KRYO processors,
  the CPU frequency subset and voltage value of each OPP varies
  based on the silicon variant in use. Qualcomm Process Voltage Scaling Tables
  defines the voltage and frequency value based on the msm-id in SMEM
  and speedbin blown in the efuse combination.
  The qcom-cpufreq-nvmem driver reads the msm-id and efuse value from the SoC
  to provide the OPP framework with required information.
  This is used to determine the voltage and frequency value for each OPP of
  operating-points-v2 table when it is parsed by the OPP framework.
 4 bits of PVS are in efuse register bits 31, 8-6. 
 Check SPEED_BIN_BLOW_STATUS 
 Check PVS_BLOW_STATUS 
 The first 4 bytes are format, next to them is the actual msm-id 
  Since the driver depends on smem and nvmem drivers, which may
  return EPROBE_DEFER, all the real activity is done in the probe,
  which may be defered as well. The init here is only registering
  the driver and the platform device.
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2018, The Linux Foundation. All rights reserved.
	
	  Mutex to synchronize between de-init sequence and re-starting LMh
	  pollinginterrupts
 Skip voltage update if the opp table is not available 
 Disable all opps and cross-validate against LUT later 
		
		  Two of the same frequencies with the same core counts means
		  end of table
			
			  Only treat the last frequency that might be a boost
			  as the boost frequency
	
	  Get the hw throttled frequency, normalize it using the
	  registered opp table and use it to calculate thermal pressure.
 Update thermal pressure 
 Don't pass boost capacity to scheduler 
	
	  In the unlikely case policy is unregistered do not enable
	  polling or hw interrupt
	
	  If hw throttled frequency is higher than what cpufreq has requested
	  for, then stop polling and switch back to interrupt mechanism.
 Disable interrupt and enable polling 
	
	  Look for LMh interrupt. If no interrupt line is specified 
	  if there is an error, allow cpufreq to be enabled as usual.
 HW should be in enabled state to proceed 
 Check for optional interconnect paths on CPU0 
  CPU frequency scaling for Broadcom SoCs with AVS firmware that
  supports DVS or DVFS
  Copyright (c) 2016 Broadcom
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  "AVS" is the name of a firmware developed at Broadcom. It derives
  its name from the technique called "Adaptive Voltage Scaling".
  Adaptive voltage scaling was the original purpose of this firmware.
  The AVS firmware still supports "AVS mode", where all it does is
  adaptive voltage scaling. However, on some newer Broadcom SoCs, the
  AVS Firmware, despite its unchanged name, also supports DFS mode and
  DVFS mode.
  In the context of this document and the related driver, "AVS" by
  itself always means the Broadcom firmware and never refers to the
  technique called "Adaptive Voltage Scaling".
  The Broadcom STB AVS CPUfreq driver provides voltage and frequency
  scaling on Broadcom SoCs using AVS firmware with support for DFS and
  DVFS. The AVS firmware is running on its own co-processor. The
  driver supports both uniprocessor (UP) and symmetric multiprocessor
  (SMP) systems which share clock and voltage across all CPUs.
  Actual voltage and frequency scaling is done solely by the AVS
  firmware. This driver does not change frequency or voltage itself.
  It provides a standard CPUfreq interface to the rest of the kernel
  and to userland. It interfaces with the AVS firmware to effect the
  requested changes and to report back the current system status in a
  way that is expected by existing tools.
 Max number of arguments AVS calls take 
  This macro is used to generate AVS parameter register offsets. For
  x >= AVS_MAX_CMD_ARGS, it returns 0 to protect against accidental memory
  access outside of the parameter range. (Offset 0 is the first parameter.)
 AVS Mailbox Register offsets 
 AVS Commands 
 PMAP and P-STATE commands 
 Different modes AVS supports (for GET_PMAPSET_PMAP) 
  PMAP parameter p1
  unused:31-24, mdiv_p0:23-16, unused:15-14, pdiv:13-10 , ndiv_int:9-0
  PMAP parameter p2
  mdiv_p4:31-24, mdiv_p3:23-16, mdiv_p2:15:8, mdiv_p1:7:0
 Different P-STATES AVS supports (for GET_PSTATESET_PSTATE) 
 CPU L2 Interrupt Controller Registers 
 AVS Command Status Values 
 Commandnotification accepted 
 Commandnotification rejected 
 Invalid commandnotification (unknown) 
 Non-AVS modes are not supported 
 Cannot set P-State until P-Map supplied 
 Cannot change P-Map after initial P-Map set 
 Max AVS status; higher numbers are used for debugging 
 Other AVS related constants 
 in ms; expected completion is < 10ms 
 Event driven, wait for the command interrupt 
 Polling for command completion 
	
	  Make sure no other command is currently running: cmd is 0 if AVS
	  co-processor is idle. Due to the guard above, we should almost never
	  have to wait here.
 Give the caller a chance to retry if AVS is busy. 
 Clear status before we begin. 
 Provide input parameters 
 Protect from spurious interrupts. 
 Now issue the command & tell firmware to wake up to process it. 
 Wait for AVS co-processor to finish processing the command. 
	
	  If the AVS status is not in the expected range, it means AVS didn't
	  complete our command in time, and we return an error. Also, if there
	  is no "time left", we timed out waiting for the interrupt.
 Process returned values 
 Clear status to tell AVS co-processor we are done. 
 Convert firmware errors to errno's as much as possible. 
 AVS command completed execution. Wake up __issue_avs_command(). 
 in kHz 
  We determine which frequencies are supported by cycling through all P-states
  and reading back what frequency we are running at for each P-state.
 Remember P-state for later 
 Restore P-state 
  To ensure the right firmware is running we need to
     - check the MAGIC matches what we expect
     - brcm_avs_get_pmap() doesn't return -ENOTSUPP or -EINVAL
  We need to set up our interrupt handling before calling brcm_avs_get_pmap()!
	
	  We can't use the P-state returned by brcm_avs_get_pmap(), since
	  that's the initial P-state from when the P-map was downloaded to the
	  AVS co-processor, not necessarily the P-state we are running at now.
	  So, we get the current P-state explicitly.
 This is best effort. Nothing to do if it fails. 
 This is best effort. Nothing to do if it fails. 
  All initialization code that we only want to execute once goes here. Setup
  code that can be re-tried on every core (if it failed before) can go into
  brcm_avs_cpufreq_init().
 All cores share the same clock and thus the same policy. 
 SPDX-License-Identifier: GPL-2.0-only
  Match running platform with pre-defined OPP values for CPUFreq
  Author: Ajit Pal Singh <ajitpal.singh@st.com>
          Lee Jones <lee.jones@linaro.org>
  Copyright (C) 2015 STMicroelectronics (R&D) Limited
  Only match on "suitable for ALL versions" entries
  This will be used with the BIT() macro.  It sets the
  top bit of a 32bit value and is equal to 0x80000000.
  struct sti_cpufreq_ddata - ST CPUFreq Driver Data
  @cpu:		CPU's OF node
  @syscfg_eng:		Engineering Syscon register map
  @syscfg:		Syscon register map
 Use default pcode 
 Use default substrate 
 Use default major number 
 Use default minor number 
 SPDX-License-Identifier: GPL-2.0-only
   CPU frequency scaling for OMAP using OPP information
   Copyright (C) 2005 Nokia Corporation
   Written by Tony Lindgren <tony@atomide.com>
   Based on cpu-sa1110.c, Copyright (C) 2001 Russell King
  Copyright (C) 2007-2011 Texas Instruments, Inc.
  - OMAP34 support by Rajendra Nayak, Santosh Shilimkar
 OPP tolerance in percentage 
 scaling up?  scale voltage before frequency 
 scaling down?  scale voltage after frequency 
 FIXME: what's the actual transition time? 
		 
		  Ensure physical regulator is present.
		  (e.g. could be dummy regulator.)
 SPDX-License-Identifier: GPL-2.0-only
  CPU frequency scaling for DaVinci
  Copyright (C) 2009 Texas Instruments Incorporated - https:www.ti.com
  Based on linuxarcharmplat-omapcpu-omap.c. Original Copyright follows:
   Copyright (C) 2005 Nokia Corporation
   Written by Tony Lindgren <tony@atomide.com>
   Based on cpu-sa1110.c, Copyright (C) 2001 Russell King
  Copyright (C) 2007-2008 Texas Instruments, Inc.
  Updated to support OMAP3
  Rajendra Nayak <rnayak@ti.com>
 if moving to higher frequency, up the voltage beforehand 
 if moving to lower freq, lower the voltage after lowering freq 
 Finish platform specific initialization 
	
	  Time measurement across the target() function yields ~1500-1800us
	  time taken with no drivers on notification list.
	  Setting the latency to 2000 us to accommodate addition of drivers
	  to prepost change notification list.
 SPDX-License-Identifier: GPL-2.0-only
  S3C24162450 CPUfreq Support
  Copyright 2011 Heiko Stuebner <heiko@sntech.de>
  based on s3c64xx_cpufreq.c
  Copyright 2009 Wolfson Microelectronics plc
 pseudo-frequency for dvs mode 
 frequency to sleep and reboot in
  it's essential to leave dvs, as some boards do not reconfigure the
  regulator on reboot
 Sources for the ARMCLK 
 S3C2416 only supports changing the voltage in the dvs-mode.
  Voltages down to 1.0V seem to work, so we take what the regulator
  can get us.
 return our pseudo-frequency when in dvs mode 
 changing the core voltage is only allowed when in dvs mode 
 when lowering the voltage failed, there is nothing to do 
 force armdiv to hclk frequency for transition from dvs
 switching to dvs when it's not allowed 
	 When leavin dvs mode, always switch the armdiv to the hclk rate
	  The S3C2416 has stability issues when switching directly to
	  higher frequencies.
 Check only the min-voltage, more is always ok on S3C2416 
 Guessed 
 disable further changes 
	 some boards don't reconfigure the regulator on reboot, which
	  could lead to undervolting the cpu when the clock is reset.
	  Therefore we always leave the DVS mode on reboot.
	
	  S3C2416 and S3C2450 share the same processor-ID and also provide no
	  other means to distinguish them other than through the rate of
	  msysclk. On S3C2416 msysclk runs at 800MHz and on S3C2450 at 533MHz.
 not needed anymore 
	 chech hclk rate, we only support the common 133MHz for now
	  hclk could also run at 66MHz, but this not often used
 special handling for dvs mode 
 Check for frequencies we can generate 
	 Datasheet says PLL stabalisation time must be at least 300us,
	  so but add some fudge. (reference in LOCKCON0 register description)
 SPDX-License-Identifier: GPL-2.0-only
 us3_cpufreq.c: UltraSPARC-III cpu frequency support
  Copyright (C) 2003 David S. Miller (davem@redhat.com)
  Many thanks to Dominik Brodowski for fixing up the cpufreq
  infrastructure in order to make this driver easier to implement.
 Indexed by cpu number. 
 UltraSPARC-III has three dividers: 1, 2, and 32.  These are controlled
  in the Safari config register.
 no outputs 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2006-2008 Simtec Electronics
 	http:armlinux.simtec.co.uk
 	Ben Dooks <ben@simtec.co.uk>
  S3C2410 CPU Frequency scaling
 Note, 2410A has an extra mode for 1:4:4 ratio, bit 2 of CLKDIV 
 record the result 
	 transition latency is about 5ms worst-case, so
	 alter the maximum freq settings for S3C2410A. If a board knows
	  it only has a maximum of 200, then it should register its own
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2010 Samsung Electronics Co., Ltd.
 		http:www.samsung.com
  CPU frequency scaling for S5PC110S5PV210
 CLKSRC0 
 CLKSRC2 
 CLKDIV0 
 CLKDIV2 
 CLKDIV6 
 APLL M,P,S values for 1G800Mhz 
 Use 800MHz when entering sleep mode 
 Tracks if CPU frequency can be updated anymore 
  DRAM configurations to calculate refresh counter for changing
  frequency of memory.
 HZ 
 DRAM refresh counter  1000 
 DRAM configuration (DMC0 and DMC1) 
 uV 
 uV 
	
	  Clock divider value for following
	  { APLL, A2M, HCLK_MSYS, PCLK_MSYS,
	    HCLK_DSYS, PCLK_DSYS, HCLK_PSYS, PCLK_PSYS,
	    ONEDRAM, MFC, G3D }
 L0 : [1000200100][16683][13366][200200] 
 L1 : [800200100][16683][13366][200200] 
 L2 : [400200100][16683][13366][200200] 
 L3 : [200200100][16683][13366][200200] 
 L4 : [100100100][8383][6666][100100] 
  This function set DRAM refresh counter
  according to operating frequency of DRAM
  ch: DMC port number 0 or 1
  freq: Operating frequency of DRAM(KHz)
 Find current DRAM frequency 
 Finding current running level index 
 Check if there need to change PLL 
 Check if there need to change System bus clock 
		
		  Reconfigure DRAM refresh counter value for minimum
		  temporary clock while changing divider.
		  expected clock is 83Mhz : 7.8usec(183Mhz) = 0x287
	
	  APLL should be changed in this level
	  APLL -> MPLL(for stable transition) -> APLL
	  Some clock source's clock API are not prepared.
	  Do not use clock API in below code.
		
		  1. Temporary Change divider for MFC and G3D
		  SCLKA2M(2001=200)->(2004=50)Mhz
 For MFC, G3D dividing 
		
		  2. Change SCLKA2M(200Mhz)to SCLKMPLL in MFC_MUX, G3D MUX
		  (2004=50)->(6674=166)Mhz
		
		  3. DMC1 refresh count for 133Mhz if (index == L4) is
		  true refresh counter is already programmed in upper
		  code. 0x287@83Mhz
 4. SCLKAPLL -> SCLKMPLL 
 Change divider 
 ARM MCS value changed 
 5. Set Lock time = 30us24Mhz = 0x2cf 
		
		  6. Turn on APLL
		  6-1. Set PMS values
		  6-2. Wait until the PLL is locked
		
		  7. Change source clock from SCLKMPLL(667Mhz)
		  to SCLKA2M(200Mhz) in MFC_MUX and G3D MUX
		  (6674=166)->(2004=50)Mhz
		
		  8. Change divider for MFC and G3D
		  (2004=50)->(2001=200)Mhz
 For MFC, G3D dividing 
 9. Change MPLL to APLL in MSYS_MUX 
		
		  10. DMC1 refresh counter
		  L4 : DMC1 = 100Mhz 7.8us(1100) = 0x30c
		  Others : DMC1 = 200Mhz 7.8us(1200) = 0x618
	
	  L4 level needs to change memory bus speed, hence ONEDRAM clock
	  divider and memory refresh parameter should be changed
 Reconfigure DRAM refresh counter value 
			
			  DMC0 : 166Mhz
			  DMC1 : 200Mhz
			
			  DMC0 : 83Mhz
			  DMC1 : 100Mhz
	
	  check_mem_type : This driver only support LPDDR & LPDDR2.
	  other memory type is not supported.
 Find current refresh counter and frequency each DMC 
 We need to set SLEEP FREQ again 
	
	  HACK: This is a temporary workaround to get access to clock
	  and DMC controller registers directly and remove static mappings
	  and dependencies on platform headers. It is necessary to enable
	  S5PV210 multi-platform support and will be removed together with
	  this whole driver as soon as S5PV210 gets migrated to use
	  cpufreq-dt driver.
 SPDX-License-Identifier: GPL-2.0+
  CPUFreq support for Armada 8K
  Copyright (C) 2018 Marvell
  Omri Itach <omrii@marvell.com>
  Gregory Clement <gregory.clement@bootlin.com>
  Setup the opps list with the divider for the max frequency, that
  will be filled at runtime.
 If the CPUs share the same clock, then they are in the same cluster. 
 Get nominal (current) CPU frequency. 
 If cpu_dev is NULL then we reached the end of the array 
			
			  A 0Hz frequency is not valid, this meant
			  that it was not yet initialized so there is
			  no more opp to free
	
	  For each CPU, this loop registers the operating points
	  supported (which are the nominal CPU frequency and full integer
	  divisions of it).
 SPDX-License-Identifier: GPL-2.0-only
  linuxdriverscpufreqfreq_table.c
  Copyright (C) 2002 - 2003 Dominik Brodowski
                      FREQUENCY TABLE HELPERS                       
	
	  If the driver has set its own cpuinfo.max_freq above max_freq, leave
	  it as is.
  Generic routine to verify policy & frequency table, requires driver to set
  policy->freq_table prior to it.
  show_available_freqs - show available frequencies for the specified CPU
		
		  show_boost = true and driver_data = BOOST freq
		  display BOOST freqs
		 
		  show_boost = false and driver_data = BOOST freq
		  show_boost = true and driver_data != BOOST freq
		  continue - do not display anything
		 
		  show_boost = false and driver_data != BOOST freq
		  display NON BOOST freqs
  scaling_available_frequencies_show - show available normal frequencies for
  the specified CPU
  scaling_boost_frequencies_show - show available boost frequencies for
  the specified CPU
 Frequency increased from prev to pos 
 But frequency was decreasing earlier 
 Frequency decreased from prev to pos 
 But frequency was increasing earlier 
 SPDX-License-Identifier: GPL-2.0-only
  cpufreq driver for Enhanced SpeedStep, as found in Intel's Pentium
  M (part of the Centrino chipset).
  Since the original Pentium M, most new Intel CPUs support Enhanced
  SpeedStep.
  Despite the "SpeedStep" in the name, this is almost entirely unlike
  traditional SpeedStep.
  Modelled on speedstep.c
  Copyright (C) 2003 Jeremy Fitzhardinge <jeremy@goop.org>
 current 
 CPU family 
 model 
 stepping 
 max clock in kHz 
 clockvoltage pairs 
 Operating points for current CPU 
 Computes the correct form for IA32_PERF_CTL MSR for a particular
   frequencyvoltage operating point; frequency in MHz, volts in mV.
  These voltage tables were derived from the Intel Pentium M
  datasheet, document 25261202.pdf, Table 5.  I have verified they
  are consistent with my IBM ThinkPad X31, which has a 1.3GHz Pentium
  M.
 Ultra Low Voltage Intel Pentium M processor 900MHz (Banias) 
 Ultra Low Voltage Intel Pentium M processor 1000MHz (Banias) 
 Low Voltage Intel Pentium M processor 1.10GHz (Banias) 
 Low Voltage Intel Pentium M processor 1.20GHz (Banias) 
 Intel Pentium M processor 1.30GHz (Banias) 
 Intel Pentium M processor 1.40GHz (Banias) 
 Intel Pentium M processor 1.50GHz (Banias) 
 Intel Pentium M processor 1.60GHz (Banias) 
 Intel Pentium M processor 1.70GHz (Banias) 
 CPU models, their operating frequency range, and freqvoltage
 NULL model_name is a wildcard 
 No match at all 
 Matched a non-match 
 CONFIG_X86_SPEEDSTEP_CENTRINO_TABLE 
 To be called only after centrino_model is initialized 
	
	  Extract clock in kHz from PERF_CTL value
	  for centrino, as some DSDTs are buggy.
	  Ideally, this can be done using the acpi_data structure.
 Return the current CPU frequency in kHz 
		
		  On some CPUs, we can see transient MSR values (which are
		  not present in _PSS), while CPU is doing some automatic
		  P-state transition (like TM2). Get the last freq set 
		  in PERF_CTL.
 Only Intel makes Enhanced Speedstep-capable CPUs 
	 Check to see if Enhanced SpeedStep is enabled, and try to
 check to see if it stuck 
 10uS transition latency 
  centrino_target - set a new CPUFreq policy
  @policy: new policy
  @index: index of target frequency
  Sets a new CPUFreq policy.
		
		  Support for SMP systems.
		  Make sure we are running on CPU that wants to change freq
 We haven't started the transition yet. 
 all but 16 LSB are reserved, treat them with care 
		
		  We have failed halfway through the frequency change.
		  We have sent callbacks to policy->cpus and
		  MSRs have already been written on coverd_cpus.
		  Best effort undo..
	.name		= "centrino",  should be speedstep-centrino,
  This doesn't replace the detailed checks above because
  the generic CPU IDs don't have a way to match for steppings
  or ASCII model IDs.
  centrino_init - initializes the Enhanced SpeedStep CPUFreq driver
  Initializes the Enhanced SpeedStep support. Returns -ENODEV on
  unsupported devices, -ENOENT if there's no voltage table for this
  particular CPU model, -EINVAL on problems during initiatization,
  and zero on success.
  This is quite picky.  Not only does the CPU have to advertise the
  "est" flag in the cpuid capability flags, we look for a specific
  CPU model and stepping, and we need to have the exact model name in
  our voltage tables.  That is, be paranoid about not releasing
  someone's valuable magic smoke.
 SPDX-License-Identifier: GPL-2.0-only
   Based on documentation provided by Dave Jones. Thanks!
   BIG FAT DISCLAIMER: Work in progress code. Possibly dangerous
 Module parameters 
 Minimum necessary to get acpi_processor_get_bios_limit() working 
 Return current frequency 
 Wait while CPU is busy 
 Set new multiplier and voltage 
 Wait until transition end 
 Print voltage and multiplier 
 Make frequency transition 
 Check brand 
 Enable Enhanced PowerSaver 
 Can be locked at 0 
 Print voltage and multiplier 
 Print limits 
 Sanity checks 
 Check for systems using underclocked CPU 
 Calc FSB speed 
 Check for ACPI processor speed limit 
 Check if max_multiplier is in BIOS limits 
	 Allow user to set lower maximum voltage then that reported
 Change mV to something hardware can use 
 Check if voltage is within limits 
 Calc number of p-states supported 
 Allocate private data and frequency table for current cpu 
 Copy basic values 
 Fill frequency and MSR value table 
 844mV -> 700mV in ns 
 Bye 
 This driver will work only on Centaur C7 processors with
 Allow user to overclock his machine or to change frequency to higher after
  cpufreq driver for the SuperH processors.
  Copyright (C) 2002 - 2012 Paul Mundt
  Copyright (C) 2002 M. R. Brown
  Clock framework bits from archavr32mach-at32apcpufreq.c
    Copyright (C) 2004-2007 Atmel Corporation
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
 Convert target_freq from kHz to Hz 
  Here we notify other drivers of the proposed change and the final change.
 SPDX-License-Identifier: GPL-2.0-only
  CPPC (Collaborative Processor Performance Control) driver for
  interfacing with the CPUfreq layer and governors. See
  cppc_acpi.c for CPPC specific methods.
  (C) Copyright 2014, 2015 Linaro Ltd.
  Author: Ashwin Chaugule <ashwin.chaugule@linaro.org>
 Minimum struct length needed for the DMI processor entry we want 
 Offset in the DMI processor structure for the max frequency 
  This list contains information parsed from per CPU ACPI _CPC and _PSD
  structures: e.g. the highest and lowest supported performance, capabilities,
  desired performance, level requested etc. Depending on the share_type, not
  all CPUs will have an entry in the list.
 Frequency invariance support 
  cppc_scale_freq_workfn - CPPC arch_freq_scale updater for frequency invariance
  @work: The work item.
  The CPPC driver register itself with the topology core to provide its own
  implementation (cppc_scale_freq_tick()) of topology_scale_freq_tick() which
  gets called by the scheduler on every tick.
  Note that the arch specific counters have higher priority than CPPC counters,
  if available, though the CPPC driver doesn't need to have any special
  handling for that.
  On an invocation of cppc_scale_freq_tick(), we schedule an irq work (since we
  reach here from hard-irq context), which then schedules a normal work item
  and cppc_scale_freq_workfn() updates the per_cpu arch_freq_scale variable
  based on the counter updates since the last tick.
 This can happen due to counter's overflow 
	
	  cppc_get_perf_ctrs() can potentially sleep, call that from the right
	  context.
			
			  Don't abort if the CPU was offline while the driver
			  was getting registered.
 Register for freq-invariance 
  We free all the resources on policy's removal and not on CPU removal as the
  irq-work are per-cpu and the hotplug core takes care of flushing the pending
  irq-works (hint: smpcfd_dying_cpu()) on CPU hotplug. Even if the kthread-work
  fires on another CPU after the concerned CPU is removed, it won't harm.
  We just need to make sure to remove them all on policy->exit().
 policy->cpus will be empty here, use related_cpus instead 
		
		  Fake (unused) bandwidth; workaround to "fix"
		  priority inheritance.
 CONFIG_ACPI_CPPC_CPUFREQ_FIE 
 Callback function used to retrieve the max frequency from DMI 
 Look up the max frequency in DMI 
	
	  Real stupid fallback value, just in case there is no
	  actual value set.
  If CPPC lowest_freq and nominal_freq registers are exposed then we can
  use them to convert perf to freq and vice versa
  If the perffreq point lies between Nominal and Lowest, we can treat
  (Low perf, Low freq) and (Nom Perf, Nom freq) as 2D co-ordinates of a line
  and extrapolate the rest
  For perffreq > Nominal, we use the ratio perf:freq at Nominal for conversion
 Return if it is exactly the same perf 
  The PCC subspace describes the rate at which platform can accept commands
  on the shared PCC channel (including READs which do not count towards freq
  transition requests), so ideally we need to use the PCC values as a fallback
  if we don't have a platform specific transition_delay_us
 Convert the lowest and nominal freq from MHz to KHz 
	
	  Set min to lowest nonlinear perf to avoid any efficiency penalty (see
	  Section 8.4.7.1.1.5 of ACPI 6.1 spec)
	
	  Set cpuinfo.min_freq to Lowest to make the full range of performance
	  available if userspace wants to use any perf between lowest & lowest
	  nonlinear perf
 Nothing to be done - we'll have a policy for each CPU 
		
		  All CPUs in the domain will share a policy and all cpufreq
		  operations will use a single cppc_cpudata structure stored
		  in policy->driver_data.
	
	  If 'highest_perf' is greater than 'nominal_perf', we assume CPU Boost
	  is supported.
 Set policy->cur to max now. The governors will adjust later. 
 Check to avoid divide-by zero and invalid delivered_perf 
 2usec delay between sampling 
  HISI platform does not support delivered performance counter and
  reference performance counter. It can calculate the performance using the
  platform specific mechanism. We reuse the desired performance register to
  store the real performance calculated by the platform.
 Overwrite the get() callback 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2015 Linaro Ltd.
  Author: Pi-Cheng Chen <pi-cheng.chen@linaro.org>
  The struct mtk_cpu_dvfs_info holds necessary information for doing CPU DVFS
  on each CPU powerclock domain of Mediatek SoCs. Each CPU cluster in
  Mediatek SoCs has two voltage inputs, Vproc and Vsram. In some cases the two
  voltage inputs need to be controlled under a hardware limitation:
  100mV < Vsram - Vproc < 200mV
  When scaling the clock frequency of a CPU clock domain, the clock source
  needs to be switched to another stable PLL clock temporarily until
  the original PLL becomes stable at target frequency.
 Vsram should not exceed the maximum allowed voltage of SoC. 
		
		  When scaling up voltages, Vsram and Vproc scale up step
		  by step. At each step, set Vsram to (Vproc + 200mV) first,
		  then set Vproc to (Vsram - 100mV).
		  Keep doing it until Vsram and Vproc hit target voltages.
				
				  If the target Vsram hits the maximum voltage,
				  try to set the exact voltage value first.
		
		  When scaling down voltages, Vsram and Vproc scale down step
		  by step. At each step, set Vproc to (Vsram - 200mV) first,
		  then set Vproc to (Vproc + 100mV).
		  Keep doing it until Vsram and Vproc hit target voltages.
				
				  If the target Vsram hits the maximum voltage,
				  try to set the exact voltage value first.
	
	  If the new voltage or the intermediate voltage is higher than the
	  current voltage, scale up voltage first.
 Reparent the CPU clock to intermediate clock. 
 Set the original PLL to target rate. 
 Set parent of CPU clock back to the original PLL. 
	
	  If the new voltage is lower than the intermediate voltage or the
	  original voltage, scale down to the new voltage.
 Both presence and absence of sram regulator are valid cases. 
 Get OPP-sharing information from "operating-points-v2" bindings 
 Search a safe voltage for intermediate frequency. 
	
	  If SRAM regulator is present, software "voltage tracking" is needed
	  for this CPU power domain.
 List of machines supported by this driver 
	
	  Since there's no place to hold device registration code and no
	  device tree based way to match cpufreq driver yet, both the driver
	  and the device registration codes are put here to handle defer
	  probing.
 SPDX-License-Identifier: GPL-2.0-only
   This file was based upon code in Powertweak Linux (http:powertweak.sf.net)
   (C) 2000-2003  Dave Jones, Arjan van de Ven, Janne Pnkl,
                  Dominik Brodowski.
   BIG FAT DISCLAIMER: Work in progress code. Possibly dangerous
#define POWERNOW_IOPORT 0xfff0           it doesn't matter where, as long
 FSB, in 10 kHz 
 Clock ratio multiplied by 10 - see table 27 in AMD#23446 
 110 -> 6.0x  0},
 011 -> 5.5x  0},
 001 -> 5.0x  0},
 000 -> 4.5x  0},
 010 -> 4.0x  0},
 111 -> 3.5x  0},
 101 -> 3.0x  0},
 100 -> 2.0x  0},
 100    3.5
 100    4
 100    4.5
  95    5
 100    5
 112.5  4.5
  97    5.5
 100    5.5
 112.5  5
  95    6
 100    6
 112.5  5.5
 120    5.5
 112.5  6
 120    6
  powernow_k6_get_cpu_multiplier - returns the current FSB multiplier
  Returns the current setting of the frequency multiplier. Core clock
  speed is frequency of the Front-Side Bus multiplied with this value.
 enable the PowerNow port 
 disable it again 
 we now need to transform best_i to the BVC format, see AMD#23446 
	
	  The processor doesn't respond to inquiry cycles while changing the
	  frequency, so we must disable cache.
 enable the PowerNow port 
 disable it again 
  powernow_k6_target - set the PowerNow! multiplier
  @best_i: clock_ratio[best_i] is the target multiplier
    Tries to change the PowerNow! multiplier
 table init 
 cpuinfo and default policy values 
  powernow_k6_init - initializes the k6 PowerNow! CPUFreq driver
    Initializes the K6 PowerNow! support. Returns -ENODEV on unsupported
  devices, -EINVAL or -ENOMEM on problems during initiatization, and zero
  on success.
  powernow_k6_exit - unregisters AMD K6-2+3+ PowerNow! support
    Unregisters AMD K6-2+  K6-3+ PowerNow! support.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2008 Simtec Electronics
 	http:armlinux.simtec.co.uk
 	Ben Dooks <ben@simtec.co.uk>
  S3C2412 CPU Frequency scalling
 our clock resources. 
 HDIV: 1, 2, 3, 4, 6, 8 
	 We can't run hclk above armclk as at the best we have to
 set dvs depending on whether we reached armclk or not. 
 update the actual armclk we achieved. 
 store the result, and then return 
 clear off current clock info 
 set the default cpu frequency information, based on an 200MHz part
  as we have no other way of detecting the speed rating in software.
 5ms 
 SPDX-License-Identifier: GPL-2.0-only
  driverscpufreqcpufreq_governor.c
  CPUFREQ governors common code
  Copyright	(C) 2001 Russell King
 		(C) 2003 Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>.
 		(C) 2003 Jun Nakajima <jun.nakajima@intel.com>
 		(C) 2009 Alexander Clouter <alex@digriz.org.uk>
 		(c) 2012 Viresh Kumar <viresh.kumar@linaro.org>
 Common sysfs tunables 
  store_sampling_rate - update sampling rate effective immediately if needed.
  If new rate is smaller than the old, simply updating
  dbs.sampling_rate might not be appropriate. For example, if the
  original sampling_rate was 1 second and the requested new sampling rate is 10
  ms because the user needs immediate reaction from ondemand governor, but not
  sure if higher frequency will be required or not, then, the governor may
  change the sampling rate too late; up to 1 second later. Thus, if we are
  reducing the sampling rate, we need to make the new value effective
  immediately.
  This must be called with dbs_data->mutex held, otherwise traversing
  policy_dbs_list isn't safe.
	
	  We are operating under dbs_data->mutex and so the list and its
	  entries can't be freed concurrently.
		
		  On 32-bit architectures this may race with the
		  sample_delay_ns read in dbs_update_util_handler(), but that
		  really doesn't matter.  If the read returns a value that's
		  too big, the sample will be skipped, but the next invocation
		  of dbs_update_util_handler() (when the update has been
		  completed) will take a sample.
		 
		  If this runs in parallel with dbs_work_handler(), we may end
		  up overwriting the sample_delay_ns value that it has just
		  written, but it will be corrected next time a sample is
		  taken, so it shouldn't be significant.
  gov_update_cpu_data - Update CPU load data.
  @dbs_data: Top-level governor data pointer.
  Update CPU load data for all CPUs in the domain governed by @dbs_data
  (that may be a single policy or a bunch of them if governor tunables are
  system-wide).
  Call under the @dbs_data mutex.
	
	  Sometimes governors may use an additional multiplier to increase
	  sample delays temporarily.  Apply that multiplier to sampling_rate
	  so as to keep the wake-up-from-idle detection logic a bit
	  conservative.
	
	  For the purpose of ondemand, waiting for disk IO is an indication
	  that you're performance critical, and not that the system is actually
	  idle, so do not add the iowait time to the CPU idle time then.
 Get Absolute Load 
			
			  That can only happen when this function is called
			  twice in a row with a very short interval between the
			  calls, so the previous load value can be used then.
			
			  If the CPU had gone completely idle and a task has
			  just woken up on this CPU now, it would be unfair to
			  calculate 'load' the usual way for this elapsed
			  time-window, because it would show near-zero load,
			  irrespective of how CPU intensive that task actually
			  was. This is undesirable for latency-sensitive bursty
			  workloads.
			 
			  To avoid this, reuse the 'load' from the previous
			  time-window and give this task a chance to start with
			  a reasonably high CPU frequency. However, that
			  shouldn't be over-done, lest we get stuck at a high
			  load (high frequency) for too long, even when the
			  current system load has actually dropped down, so
			  clear prev_load to guarantee that the load will be
			  computed again next time.
			 
			  Detecting this situation is easy: an unusually large
			  'idle_time' (as compared to the sampling rate)
			  indicates this scenario.
				
				  That can happen if idle_time is returned by
				  get_cpu_idle_time_jiffy().  In that case
				  idle_time is roughly equal to the difference
				  between time_elapsed and "busy time" obtained
				  from CPU statistics.  Then, the "busy time"
				  can end up being greater than time_elapsed
				  (for example, if jiffies_64 and the CPU
				  statistics are updated by different CPUs),
				  so idle_time may in fact be negative.  That
				  means, though, that the CPU was busy all
				  the time (on the rough average) during the
				  last sampling interval and 100 can be
				  returned as the load.
	
	  Make sure cpufreq_governor_limits() isn't evaluating load or the
	  ondemand governor isn't updating the sampling rate in parallel.
 Allow the utilization update handler to queue up more work. 
	
	  If the update below is reordered with respect to the sample delay
	  modification, the utilization update handler may end up using a stale
	  sample delay value.
	
	  The work may not be allowed to be queued up right now.
	  Possible reasons:
	  - Work has already been queued up or is in progress.
	  - It is too early (too little time from the previous sample).
	
	  If the reads below are reordered before the check above, the value
	  of sample_delay_ns used in the computation may be stale.
	
	  If the policy is not shared, the irq_work may be queued up right away
	  at this point.  Otherwise, we need to ensure that only one of the
	  CPUs sharing the policy will do that.
		
		  If another CPU updated last_sample_time in the meantime, we
		  shouldn't be here, so clear the work counter and bail out.
 Allocate memory for per-policy governor data. 
 Set policy_dbs for all CPUs, online+offline 
 State should be equivalent to EXIT 
 Protect gov->gdbs_data against concurrent updates. 
	
	  The sampling interval should not be less than the transition latency
	  of the CPU and it also cannot be too small for dbs_update() to work
	  correctly.
 Failure, so roll back. 
 Protect gov->gdbs_data against concurrent updates. 
		
		  Make the first invocation of dbs_update() compute the load.
 Protect gov->gdbs_data against cpufreq_dbs_governor_exit() 
 SPDX-License-Identifier: GPL-2.0-or-later
 	elanfreq:	cpufreq driver for the AMD ELAN family
 	(c) Copyright 2002 Robert Schwebel <r.schwebel@pengutronix.de>
 	Parts of this code are (c) Sven Geggus <sven@geggus.net>
       All Rights Reserved.
 	2002-02-13: - initial revision for 2.4.18-pre9 by Robert Schwebel
 Chip Setup and Control Index Register    
 Chip Setup and Control Data  Register    
 Module parameter 
 frequency in kHz                         
 PMU Force Mode register                  
 CPU Clock Speed Register                 
  It is important that the frequencies
  are listed in ascending order here!
 	elanfreq_get_cpu_frequency: determine current cpu speed
 	Finds out at which frequency the CPU of the Elan SOC runs
 	at the moment. Frequencies from 1 to 33 MHz are generated
 	the normal way, 66 and 99 MHz are called "Hyperspeed Mode"
 	and have the rest of the chip running with 33 MHz.
 Clock Speed Register 
 Are we in CPU clock multiplied mode (6699 MHz)? 
 33 MHz is not 32 MHz... 
	
	  Access to the Elan's internal registers is indexed via
	  0x22: Chip Setup & Control Register Index Register (CSCI)
	  0x23: Chip Setup & Control Register Data  Register (CSCD)
	 
	
	  0x40 is the Power Management Unit's Force Mode Register.
	  Bit 6 enables Hyperspeed Mode (66100 MHz core frequency)
 Disable hyperspeed mode 
 wait till internal pipelines and 
 buffers have cleaned up          
 now, set the CPU clock speed register (0x80) 
 now, the hyperspeed bit in PMU Force Mode Register (0x40) 
 	Module init and exit code
 capability check 
 max freq 
 table init 
  elanfreq_setup - elanfreq command line parameter parsing
  elanfreq command line parameter.  Use:
   elanfreq=66000
  to set the maximum CPU frequency to 66 MHz. Note that in
  case you do not give this boot parameter, the maximum
  frequency will fall back to _current_ CPU frequency which
  might be lower. If you build this as a module, use the
  max_freq module parameter instead.
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2008 Marvell International Ltd.
 in mV 
 in mV 
  CPU XL XN  HSS DMEM SMEM SRAM DFI VCC_CORE VCC_SRAM 
 104MHz 
 208MHz 
 416MHz 
 624MHz 
  CPU XL XN  HSS DMEM SMEM SRAM DFI VCC_CORE VCC_SRAM 
 104MHz 
 208MHz 
 416MHz 
 624MHz 
 806MHz 
 No clock until core PLL is re-locked 
 turbo bit 
 set default policy and cpuinfo 
 FIXME: 1 ms, assumed 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2006-2009 Simtec Electronics
 	http:armlinux.simtec.co.uk
 	Ben Dooks <ben@simtec.co.uk>
 	Vincent Sanders <vince@simtec.co.uk>
  S3C2440S3C2442 CPU Frequency scaling
 HDIV: 1, 2, 3, 4, 6, 8 
  s3c2440_cpufreq_calcdivs - calculate divider settings
  @cfg: The cpu frequency settings.
  Calcualte the divider values for the given frequency settings
  specified in @cfg. The values are stored in @cfg for later use
  by the relevant set routine if the request settings can be reached.
 if we are in DVS, we need HCLK to be <= ARMCLK 
 calculate a valid armclk 
	 if we're running armclk lower than fclk, this really means
	  that the system should go into dvs mode, which means that
 store the result, and then return 
  s3c2440_cpufreq_setdivs - set the cpu frequency divider settings
  @cfg: The cpu frequency settings.
  Set the divisors from the settings in @cfg, which where generated
  during the calculation phase by s3c2440_cpufreq_calcdivs().
 we don't expect to get here. 
 todo - set pclk. 
	 Write the divisors first with hclk intentionally halved so that
	  when we write clkdiv we will under-frequency instead of over. We
	  then make a short delay and remove the hclk halving if necessary.
 table is in kHz 
 arch_initcall adds the clocks we need, so use subsys_initcall. 
 SPDX-License-Identifier: GPL-2.0-only
  This file provides the ACPI based P-state support. This
  module works with generic cpufreq infrastructure. Most of
  the code is based on i386 version
  (archi386kernelcpucpufreqacpi-cpufreq.c)
  Copyright (C) 2005 Intel Corp
       Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
 To be used only after data->acpi_data is initialized 
 processor_get_pstate gets the instantaneous frequency 
	
	  First we write the target state's 'control' value to the
	  control_register.
 capability check 
 alloc freq_table 
 detect transition latency 
 table init 
 notify BIOS that we exist 
	 the first call to ->target() should result in us actually
 SPDX-License-Identifier: GPL-2.0-only
   linuxdriverscpufreqcpufreq_performance.c
   Copyright (C) 2002 - 2003 Dominik Brodowski <linux@brodo.de>
  Cpufreq driver for the loongson-2 processors
  The 2E revision of loongson processor not support this feature.
  Copyright (C) 2006 - 2008 Lemote Inc. & Institute of Computing Technology
  Author: Yanhua, yanh@lemote.com
  This file is subject to the terms and conditions of the GNU General Public
  License.  See the file "COPYING" in the main directory of this archive
  for more details.
  Here we notify other drivers of the proposed change and the final change.
 setting the cpu frequency 
 clock table init 
  This is the simple version of Loongson-2 wait, Maybe we need do this in
  interrupt disabled context.
 Put CPU into wait mode 
 Restore CPU state 
 Register platform stuff 
 SPDX-License-Identifier: GPL-2.0-or-later
  cpu-sa1100.c: clock scaling for the SA1100
  Copyright (C) 2000 2001, The Delft University of Technology
  Authors:
  - Johan Pouwelse (J.A.Pouwelse@its.tudelft.nl): initial version
  - Erik Mouw (J.A.K.Mouw@its.tudelft.nl):
    - major rewrite for linux-2.3.99
    - rewritten for the more generic power management scheme in
      linux-2.4.5-rmk1
  This software has been developed while working on the LART
  computing board (http:www.lartmaker.nl), which is
  sponsored by the Mobile Multi-media Communications
  (http:www.mobimedia.org) and Ubiquitous Communications
  (http:www.ubicom.tudelft.nl) projects.
  The authors can be reached at:
   Erik Mouw
   Information and Communication Theory Group
   Faculty of Information Technology and Systems
   Delft University of Technology
   P.O. Box 5031
   2600 GA Delft
   The Netherlands
  Theory of operations
  ====================
  Clock scaling can be used to lower the power consumption of the CPU
  core. This will give you a somewhat longer running time.
  The SA-1100 has a single register to change the core clock speed:
    PPCR      0x90020014    PLL config
  However, the DRAM timings are closely related to the core clock
  speed, so we need to change these, too. The used registers are:
    MDCNFG    0xA0000000    DRAM config
    MDCAS0    0xA0000004    Access waveform
    MDCAS1    0xA0000008    Access waveform
    MDCAS2    0xA000000C    Access waveform
  Care must be taken to change the DRAM parameters the correct way,
  because otherwise the DRAM becomes unusable and the kernel will
  crash.
  The simple solution to avoid a kernel crash is to put the actual
  clock change in ROM and jump to that code from the kernel. The main
  disadvantage is that the ROM has to be modified, which is not
  possible on all SA-1100 platforms. Another disadvantage is that
  jumping to ROM makes clock switching unnecessary complicated.
  The idea behind this driver is that the memory configuration can be
  changed while running from DRAM (even with interrupts turned on!)
  as long as all re-configuration steps yield a valid DRAM
  configuration. The advantages are clear: it will run on all SA-1100
  platforms, and the code is very simple.
  If you really want to understand what is going on in
  sa1100_update_dram_timings(), you'll have to read sections 8.2,
  9.5.7.3, and 10.2 from the "Intel StrongARM SA-1100 Microprocessor
  Developers Manual" (available for free from Intel).
speed,     mdcnfg,     mdcas0,     mdcas1,     mdcas2,   clock freq 
  59.0 MHz 
  73.7 MHz 
  88.5 MHz 
 103.2 MHz 
 118.0 MHz 
 132.7 MHz 
 147.5 MHz 
 162.2 MHz 
 176.9 MHz 
 191.7 MHz 
 206.4 MHz 
 221.2 MHz 
 235.9 MHz 
 250.7 MHz 
 265.4 MHz 
 280.2 MHz 
 last entry 
 find speed 
 No risk, no fun: run with interrupts on! 
		 We're going FASTER, so first relax the memory
		  timings before changing the core frequency
 Half the memory access clock 
		 The order of these statements IS important, keep 8
		  pulses!!
		 We're going SLOWER: first decrease the core
		  frequency and then tighten the memory settings.
 Half the memory access clock 
		 The order of these statements IS important, keep 8
		  pulses!!
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2006-2008 Simtec Electronics
 	http:armlinux.simtec.co.uk
 	Ben Dooks <ben@simtec.co.uk>
  S3C24XX CPU Frequency scaling
 note, cpufreq support deals in kHz, no Hz 
 CONFIG_ARM_S3C24XX_CPUFREQ_DEBUGFS 
 convert hclk into 10ths of nanoseconds for io calcs 
 functions to wrapper the driver info calls to do the cpu specific work 
 copy new from current 
 TODO - check for DMA currently outstanding 
 update our frequencies 
 setup our cpufreq parameters 
	 update fhp clock settings before we issue the change
	  notification, so that drivers do not need to do anything
 start the frequency change 
	 If hclk is staying the same, then we do not need to
	  re-write the IO or the refresh timings whilst we are changing
 is our memory clock slowing down? 
 not changing PLL, just set the divisors 
 slow the cpu down, then set divisors 
 set the divisors, then speed up 
 did our memory clock speed up 
 update our current settings 
 notify everyone we've done this 
 s3c_cpufreq_target
  called by the cpufreq core to adjust the frequency that the CPU
  is currently running at.
	 avoid repeated calls which cause a needless amout of duplicated
	  logging output (and CPU time as the calculation process is
 convert target to Hz 
 find the settings for our new frequency 
		 either we've not got any PLL values, or we've locked
		 we keep the cpu pll table in Hz, to ensure we get an
		 cpufreq_frequency_table_target returns the index
		  of the table entry, not the value of
 invalidate last_target setting 
	 whilst we will be called later on, we try and re-set the
	  cpu frequencies as soon as possible so that we do not end
	  up resuming devices and then immediately having to re-set
	  a number of settings once these devices have restarted.
	 
	  as a note, it is expected devices are not used until they
	  have been un-suspended and at that time they should have
	  used the updated clock settings.
 check our driver info has valid data 
	 info->set_fvco is optional, depending on whether there
 Note, driver registering should probably update locktime 
	 Copy the board information so that each board can make this
 if one or is zero, then return the other, otherwise return the min 
  s3c_cpufreq_freq_min - find the minimum settings for the given freq.
  @dst: The destination structure
  @a: One argument.
  @b: The other argument.
  Create a minimum of each frequency entry in the 'struct s3c_freq',
  unless the entry is zero when it is ignored and the non-zero argument
  used.
 get current settings 
  s3c_plltab_register - register CPU PLL table.
  @plls: The list of PLL entries.
  @plls_no: The size of the PLL entries @plls.
  Register the given set of PLLs with the system.
		 write a terminating entry, we don't store it in the
 SPDX-License-Identifier: GPL-2.0-only
  (C) 2004-2006  Sebastian Witt <se.witt@gmx.net>
   Based upon reverse engineered information
   BIG FAT DISCLAIMER: Work in progress code. Possibly dangerous
 Delay in ms between FSB changes 
 #define NFORCE2_DELAY 10 
  nforce2_chipset:
  FSB is changed using the chipset
 fid:
  multiplier  10
 min_fsb, max_fsb:
  minimum and maximum FSB (= FSB at boot time)
  nforce2_calc_fsb - calculate FSB
  @pll: PLL value
    Calculates FSB from PLL value
  nforce2_calc_pll - calculate PLL value
  @fsb: FSB
    Calculate PLL value for given FSB
 Try to calculate multiplier and divider up to 4 times 
  nforce2_write_pll - write PLL value to chipset
  @pll: PLL value
    Writes new FSB PLL value to chipset
 Set the pll addr. to 0x00 
 Now write the value in all 64 registers 
  nforce2_fsb_read - Read FSB
    Read FSB from chipset
    If bootfsb != 0, return FSB at boot-time
 Get chipset boot FSB from subdevice 5 (FSB at boot-time) 
 Check if PLL register is already set 
 Use PLL register FSB value 
  nforce2_set_fsb - set new FSB
  @fsb: New FSB
    Sets new FSB
 First write? Then set actual value 
 Enable write access 
 Calculate the PLL reg. value 
  nforce2_get - get the CPU frequency
  @cpu: CPU number
  Returns the CPU frequency
  nforce2_target - set a new CPUFreq policy
  @policy: new policy
  @target_freq: the target frequency
  @relation: how that frequency relates to achieved frequency
   (CPUFREQ_RELATION_L or CPUFREQ_RELATION_H)
  Sets a new CPUFreq policy.
        unsigned long         flags; 
 Disable IRQs 
 local_irq_save(flags); 
 Enable IRQs 
 local_irq_restore(flags); 
  nforce2_verify - verifies a new CPUFreq policy
  @policy: new policy
 capability check 
 Get current FSB 
 FIX: Get FID from CPU 
 Set maximum FSB to FSB at boot time 
 cpuinfo and default policy values 
  nforce2_detect_chipset - detect the Southbridge which contains FSB PLL logic
  Detects nForce2 A2 and C1 stepping
  nforce2_init - initializes the nForce2 CPUFreq driver
  Initializes the nForce2 FSB support. Returns -ENODEV on unsupported
  devices, -EINVAL on problems during initialization, and zero on
  success.
 TODO: do we need to detect the processor? 
 detect chipset 
  nforce2_exit - unregisters cpufreq module
    Unregisters nForce2 FSB change support.
 SPDX-License-Identifier: GPL-2.0-only
   driverscpufreqcpufreq_ondemand.c
   Copyright (C)  2001 Russell King
             (C)  2003 Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>.
                       Jun Nakajima <jun.nakajima@intel.com>
 On-demand governor macros 
  Not all CPUs want IO time to be accounted as busy; this depends on how
  efficient idling at a higher frequencyvoltage is.
  Pavel Machek says this is not so for various generations of AMD and old
  Intel systems.
  Mike Chan (android.com) claims this is also not true for ARM.
  Because of this, whitelist specific known (series) of CPUs by default, and
  leave all others up to the user.
	
	  For Intel, Core 2 (model 15) and later have an efficient idle.
  Find right freq to be set now with powersave_bias on.
  Returns the freq_hi to be used right now and will set freq_hi_delay_us,
  freq_lo, and freq_lo_delay_us in percpu area for averaging freqs.
 Find freq bounds for freq_avg in freq_table 
 Find out how long we have to be in hi and lo freqs 
  Every sampling_rate, we check, if current idle time is less than 20%
  (default), then we try to increase frequency. Else, we adjust the frequency
  proportional to load.
 Check for frequency increase 
 If switching to max speed, apply sampling_down_factor 
 Calculate the next frequency proportional to load 
 No longer fully busy, reset rate_mult 
 Common NORMAL_SAMPLE setup 
	
	  OD_SUB_SAMPLE doesn't make sense if sample_delay_ns is 0, so ignore
	  it then.
 Setup SUB_SAMPLE 
 sysfs interface 
 we need to re-evaluate prev_cpu_idle 
 Reset down sampling multiplier in case it was active 
		
		  Doing this without locking might lead to using different
		  rate_mult values in od_update() and od_dbs_update().
 nothing to do 
 we need to re-evaluate prev_cpu_idle 
 sysfs end 
 Idle micro accounting is supported. Use finer thresholds 
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (C) 2002 - 2005 Benjamin Herrenschmidt <benh@kernel.crashing.org>
   and                       Markus Demleitner <msdemlei@cl.uni-heidelberg.de>
  This driver adds basic cpufreq support for SMU & 970FX based G5 Macs,
  that is iMac G5 and latest single CPU desktop.
 see 970FX user manual 
 PCR scom addr 
 1 = PCR, 0 = PCRH 
 1:1 speed value 
 1:2 speed value 
 1:4 speed value 
 speed mask 
 freq request valid 
 volt request valid 
 target time 
 STATLAT value 
 SNOOPLAT value 
 SNOOPACC value 
 PSR scom addr 
 warning: PSR is a 64 bits register 
 command received 
 command completed 
 current speed 
  The G5 only supports two frequencies (Quarter speed is not supported)
 Power mode data is an array of the 32 bits PCR values to use for
  the various frequencies, retrieved from the device-tree
 table of op. points 
 number of op. points 
 current op. point 
  SMU based voltage switching for Neo2 platforms
  Platform function based voltagevdnap switching for Neo2
	 It's an irq GPIO so we should be able to just block here,
	  I'll do that later after I've properly tested the IRQ code for
	  platform functions
  SCOM based frequency switching for 970FX rev3
 If frequency is going up, first ramp up the voltage 
 Clear PCR high 
 Clear PCR low 
 Set PCR low 
 Wait for completion 
 If frequency is going down, last ramp the voltage 
  Fake voltage switching for platforms with missing support
 CONFIG_PMAC_SMU 
  Platform function based voltage switching for PowerMac7,2 & 7,3
 should be faster , to fix 
  Platform function based frequency switching for PowerMac7,2 & 7,3
 If frequency is going up, first ramp up the voltage 
 Do it 
	 It's an irq GPIO so we should be able to just block here,
	  I'll do that later after I've properly tested the IRQ code for
	  platform functions
 If frequency is going down, last ramp the voltage 
  Common interface to the cpufreq core
 Check supported platforms 
 Check 970FX for now 
 Look for the powertune data in the device-tree 
 Look for the FVT table 
 Sanity checking 
	
	  From what I see, clock-frequency is always the maximal frequency.
	  The current driver can not slew sysclk yet, so we really only deal
	  with powertune steps for now. We also only implement full freq and
	  half freq in this version. So far, I haven't yet seen a machine
	  supporting anything else.
 Set callbacks 
	 Force apply current frequency to make sure everything is in
	  sync (voltage is right for example). Firmware may leave us with
	  a strange setting ...
	 We keep the CPU node on hold... hopefully, Apple G5 don't have
	  hotplug CPU with a dynamic device-tree ...
 CONFIG_PMAC_SMU 
 Lookup the cpuid eeprom node 
 Lookup the i2c hwclock 
 Now get all the platform functions 
 Check we have minimum requirements 
 Check that we have complete sets 
	 Note: The device tree also contains a "platform-set-values"
	  function for which I haven't quite figured out the usage. It
	  might have to be called on init andor wakeup, I'm not too sure
	  but things seem to work fine without it so far ...
 Get max frequency from device-tree 
	 Now calculate reduced frequency by using the cpuid input freq
	  ratio. This requires 64 bits math unless we are willing to lose
	  some precision
 Check for machines with no useful settings 
 Sanity check 
 Based on a measurement on Xserve G5, rounded up. 
 Set callbacks 
	 Force apply current frequency to make sure everything is in
	  sync (voltage is right for example). Firmware may leave us with
	  a strange setting ...
 Get first CPU node 
 CONFIG_PMAC_SMU 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2016 Linaro.
  Viresh Kumar <viresh.kumar@linaro.org>
  Machines for which the cpufreq device is always created, mostly used for
  platforms using "operating-points" (V1) property.
  Machines for which the cpufreq device is not created, mostly used for
  platforms using "operating-points-v2" property.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2012 Calxeda, Inc.
  This driver provides the clk notifier callbacks that are used when
  the cpufreq-dt driver changes to frequency to alert the highbank
  EnergyCore Management Engine (ECME) about the need to change
  voltage. The ECME interfaces with the actual voltage regulators.
 Instantiate cpufreq-dt 
  CPU Frequency Scaling for Loongson 1 SoC
  Copyright (C) 2014-2016 Zhang, Keguang <keguang.zhang@gmail.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 CPU clk 
 MUX of CPU clk 
 PLL clk 
 OSC clk 
	
	  The procedure of reconfiguring CPU clk is as below.
	 
	   - Reparent CPU clk to OSC clk
	   - Reset CPU clock (very important)
	   - Reconfigure CPU DIV
	   - Reparent CPU clk back to CPU DIV clk
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2020 MediaTek Inc.
 Get the bases of cpufreq for domains 
 HW should be in enabled state to proceed now 
 HW should be in paused state now 
 SPDX-License-Identifier: GPL-2.0-only
 us2e_cpufreq.c: UltraSPARC-IIe cpu frequency support
  Copyright (C) 2003 David S. Miller (davem@redhat.com)
  Many thanks to Dominik Brodowski for fixing up the cpufreq
  infrastructure in order to make this driver easier to implement.
 Indexed by cpu number. 
 UltraSPARC-IIe has five dividers: 1, 2, 4, 6, and 8.  These are controlled
  in the ESTAR mode control register.
 no outputs 
 Need to wait 16 clock cycles for the PLL to lock.  
		 We have to wait for both refresh counts (old
		  and new) to go to zero.
 This is based upon the state transition diagram in the IIe manual.  
 SPDX-License-Identifier: GPL-2.0-only
   driverscpufreqcpufreq_stats.c
   Copyright (C) 2003-2004 Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>.
   (C) 2004 Zou Nan hai <nanhai.zou@intel.com>.
 Deferred reset 
 Adjust for the time elapsed since reset was requested 
	
	  Prevent the reset_time read from being reordered before the
	  reset_pending accesses in cpufreq_stats_record_transition().
				
				  Prevent the reset_time read from occurring
				  before the reset_pending read above.
 We don't care what is written to the attribute 
	
	  Defer resetting of stats to cpufreq_stats_record_transition() to
	  avoid races.
	
	  The memory barrier below is to prevent the readers of reset_time from
	  seeing a stale or partially updated value.
 Already freed 
 stats already initialized 
 Allocate memory for time_in_statefreq_tabletrans_table in one go 
 Find valid-unique entries 
 We failed, release resources 
 We can't do stats->time_in_state[-1]= .. 
 SPDX-License-Identifier: GPL-2.0
  Raspberry Pi cpufreq driver
  Copyright (C) 2019, Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
	
	  The max and min frequencies are configurable in the Raspberry Pi
	  firmware, so we query them at runtime.
  Since the driver depends on clk-raspberrypi, which may return EPROBE_DEFER,
  all the activity is performed in the probe, which may be defered as well.
 SPDX-License-Identifier: GPL-2.0-or-later
  acpi-cpufreq.c - ACPI Processor P-States Driver
   Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
   Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
   Copyright (C) 2002 - 2004 Dominik Brodowski <linux@brodo.de>
   Copyright (C) 2006       Denis Sadykov <denis.m.sadykov@intel.com>
 acpi_perf_data is a pointer to percpu data. 
 Called via smp_call_function_single(), on the target CPU 
 smp_call_function_any() was buggy? 
 Called via smp_call_function_many(), on the target CPUs 
		
		  The dreaded BIOS frequency change behind our back.
		  Force set the frequency on next target call.
 Index into perf table 
	
	  The core won't allow CPUs to go away until the governor has been
	  stopped, so we can rely on the stability of policy->cpus.
	
	  Find the closest frequency above target_freq.
 search the closest match to cpu_khz 
 assume CPU is at P0... 
 Freeing a NULL pointer is OK, and alloc_percpu zeroes. 
	
	  On the CPU_UP path we simply keep the boost-disable flag
	  in sync with the current global state.
	
	  Clear the boost-disable bit on the CPU_DOWN path so that
	  this cpu cannot block the remaining ones from boosting.
  acpi_cpufreq_early_init - initialize ACPI P-States library
  Initialize the ACPI P-States library (driversacpiprocessor_perflib.c)
  in order to determine correct frequency and voltage pairings. We can
  do _PDC and _PSD and find out the processor dependency for the
  actual init that will happen later...
 Freeing a NULL pointer is OK: alloc_percpu zeroes. 
 Do initialization in ACPI core 
  Some BIOSes do SW_ANY coordination internally, either set it up in hw
  or do it in BIOS firmware and won't inform about it to OS. If not
  detected, this has a side effect of making CPU run at a different speed
  than OS intended it to run at. Detect it and handle it cleanly.
	 Intel Xeon Processor 7100 Series Specification Update
	  https:www.intel.comAssetsPDFspecupdate314554.pdf
	  AL30: A Machine Check Exception (MCE) Occurring during an
	  Enhanced Intel SpeedStep Technology Ratio Change May Cause
	
	  Will let policy->cpus know about dependency only when software
	  coordination is required.
 capability check 
 detect transition latency 
 Check for high latency (>20uS) from buggy BIOSes, like on T42 
 table init 
		
		  Because the loop above sorts the freq_table entries in the
		  descending order, freq is the maximum frequency in the table.
		  Assume that it corresponds to the CPPC nominal frequency and
		  use it to set cpuinfo.max_freq.
		
		  If the maximum "boost" frequency is unknown, ask the arch
		  scale-invariance code to use the "nominal" performance for
		  CPU utilization scaling so as to prevent the schedutil
		  governor from selecting inadequate CPU frequencies.
		
		  The core will not set policy->cur, because
		  cpufreq_driver->get is NULL, so we need to set it here.
		  However, we have to guess it, because the current speed is
		  unknown and not detectable via IO ports.
 notify BIOS that we exist 
	
	  the first call to ->target() should result in us actually
	  writing something to the appropriate registers.
	
	  This calls the online callback on all online cpu and forces all
	  MSRs to the same value.
 don't keep reloading if cpufreq_driver exists 
	 this is a sysfs file with a strange name and an even stranger
	  semantic - per CPU instantiation, but system global effect.
	  Lets enable it only on AMD CPUs for compatibility reasons and
	  only if configured. This is considered legacy code, which
	  will probably be removed at some point in the future.
 SPDX-License-Identifier: GPL-2.0-or-later
 	Pentium 4Xeon CPU on demand clock modulationspeed scaling
 	(C) 2002 - 2003 Dominik Brodowski <linux@brodo.de>
 	(C) 2002 Zwane Mwaikambo <zwane@commfireservices.com>
 	(C) 2002 Arjan van de Ven <arjanv@redhat.com>
 	(C) 2002 Tora T. Engstad
 	All Rights Reserved
       The author(s) of this software shall not be held liable for damages
       of any nature resulting due to the use of this software. This
       software is provided AS-IS with no warranties.
 	Date		Errata			Description
 	20020525	N44, O17	12.5% or 25% DC causes lockup
  Duty Cycle (3bits), note DC_DISABLE is not specified in
  intel docs i just use it to mean disable
		 bits 63 - 5	: reserved
		  bit  4	: enabledisable
		  bits 3-1	: duty cycle
		  bit  0	: reserved
	 run on each logical CPU,
	  see section 13.15.3 of IA32 Intel Architecture Software
	  Developer's Manual, Volume 3
 Core 
 Core Duo 
 Celeron Core 
 Atom 
 Pentium M (Dothan) 
 Pentium M (Banias) 
	 on P-4s, the TSC runs with constant frequency independent whether
 Errata workaround 
 switch to maximum frequency and measure result 
 get max frequency 
 table init 
 cpuinfo and default policy values 
	 the transition latency is set to be 1 higher than the maximum
  Intentionally no MODULE_DEVICE_TABLE here: this driver should not
  be auto loaded.  Please don't add one.
	
	  THERM_CONTROL is architectural for IA32 now, so
	  we can rely on the capability checks
 SPDX-License-Identifier: GPL-2.0-only
  linuxdriverscpufreqcpufreq_powersave.c
  Copyright (C) 2002 - 2003 Dominik Brodowski <linux@brodo.de>
 SPDX-License-Identifier: GPL-2.0-only
   (C) 2001-2004  Dave Jones.
   (C) 2002  Padraig Brady. <padraig@antefacto.com>
   Based upon datasheets & sample CPUs kindly provided by VIA.
   VIA have currently 3 different versions of Longhaul.
   Version 1 (Longhaul) uses the BCR2 MSR at 0x1147.
    It is present only in Samuel 1 (C5A), Samuel 2 (C5B) stepping 0.
   Version 2 of longhaul is backward compatible with v1, but adds
    LONGHAUL MSR for purpose of both frequency and voltage scaling.
    Present in Samuel 2 (steppings 1-7 only) (C5B), and Ezra (C5C).
   Version 3 of longhaul got renamed to Powersaver and redesigned
    to use only the POWERSAVER MSR at 0x110a.
    It is present in Ezra-T (C5M), Nehemiah (C5X) and above.
    It's pretty much the same feature wise to longhaul v2, though
    there is provision for scaling FSB too, but this doesn't work
    too well in practice so we don't even try to use this.
   BIG FAT DISCLAIMER: Work in progress code. Possibly dangerous
 Flags 
 kHz 
 Module parameters 
 Clock ratios multiplied by 10 
 For processor with BCR2 MSR 
 Enable software clock multiplier 
 Sync to timer tick 
 Change frequency on next halt or sleep 
 Invoke transition 
 Disable software clock multiplier 
 For processor with Longhaul MSR 
 Setup new frequency 
 Setup new voltage 
 Sync to timer tick 
 Raise voltage if necessary 
 Change voltage 
 Invoke C3 
			 Dummy op - must do something useless after P_LVL3
 Change frequency on next halt or sleep 
 Invoke C3 
 Dummy op - must do something useless after P_LVL3 read 
 Disable bus ratio bit 
 Reduce voltage if necessary 
 Change voltage 
 Invoke C3 
			 Dummy op - must do something useless after P_LVL3
  longhaul_set_cpu_frequency()
  @mults_index : bitpattern of the new multiplier.
  Sets a new clock ratio.
 Safety precautions 
 Voltage transition before frequency transition? 
 works on C3. save mask. 
 Overkill 
 TMR0 only 
 Wait while PCI bus is busy. 
 Disable AGP and PCI arbiters 
 Disable bus master arbitration 
	
	  Longhaul v1. (Samuel[C5A] and Samuel2 stepping 0[C5B])
	  Software controlled multipliers only.
	
	  Longhaul v2 appears in Samuel2 Steppings 1->7 [C5B] and Ezra [C5C]
	 
	  Longhaul v3 (aka Powersaver). (Ezra-T [C5M] & Nehemiah [C5N])
	  Nehemiah can do FSB scaling too, but this has never been proven
	  to work in practice.
 Don't allow wakeup 
 Enable arbiters 
 Enable bus master arbitration 
 restore mask 
 Check if requested frequency is set. 
		 Revision ID = 1 but processor is expecting revision key
		  equal to 0. Jumpers at the bottom of processor will change
		  multiplier and FSB, but will not change bits in Longhaul
		 Why ACPI C3 sometimes doesn't work is a mystery for me.
		  But it does happen. Processor is entering ACPI C3 state,
		  but it doesn't change frequency. I tried poking various
		 This shouldn't happen. Longhaul ver. 2 was reported not
		  working on processors without voltage scaling, but with
		  RevID = 1. RevID errata will make things right. Just
  Centaur decided to make life a little more tricky.
  Only longhaul v1 is allowed to read EBLCR BSEL[0:1].
  Samuel2 and above have to try and guess what the FSB is.
  We do this by assuming we booted at maximum multiplier, and interpolate
  between that value multiplied by possible FSBs and cpu_mhz which
  was calculated at boot time. Really ugly, but no other way to do this.
 Get current frequency 
	 Get max multiplier - as we always did.
	  Longhaul MSR is useful only when voltage scaling is enabled.
 Get min multiplier 
 Sort 
 Find index we are running on 
 How many voltage steps
 Calculate max frequency at min voltage 
 Calculate kHz for one voltage step 
		 On test system voltage transitions exceeding single
		  step up or down were turning motherboard off. Both
		  "ondemand" and "userspace" are unsafe. C7 is doing
		  this in hardware, C3 is old and we need to do this
 VIA don't support PM2 reg, but have something similar 
 Find PLE133 host bridge 
 Find PM133VT8605 host bridge 
 Find CLE266 host bridge 
 Find CN400 V-Link host bridge 
 Enable access to port 0x22 
 Find VT8235 southbridge 
 Find VT8237 southbridge 
 Set transition time to max 
 Get address of ACPI registers block
 Check what we have on this motherboard 
			 Note, this is not a typo, early Samuel2's had
 Check Longhaul ver. 2 
 Looks like MSR isn't present 
 Doesn't hurt 
 Find ACPI data for processor 
 Check ACPI support for C3 state 
 Disable if it isn't working 
 Check if northbridge is friendly 
 Check ACPI support for bus master arbiter disable 
 usec 
 Even if BIOS is exporting ACPI C3 state, and it is used
  with success when CPU is idle, this state doesn't
 Change CPU voltage with frequency. Very useful to save
 Force revision key to 0 for processors which doesn't
  support voltage scaling, but are introducing itself as
 By default driver is disabled to prevent incompatible
 SPDX-License-Identifier: GPL-2.0-only
  TI CPUFreqOPP hw-supported driver
  Copyright (C) 2016-2017 Texas Instruments, Inc.
 	 Dave Gerlach <d-gerlach@ti.com>
 AM335x and AM437x use "OPP disable" bits, so invert 
	
	  The efuse on dra7 and am57 parts contains a specific
	  value indicating the highest available OPP.
 OPP enable bit ("Speed Binned") 
  OMAP35x TRM (SPRUF98K):
   CONTROL_IDCODE (0x4830 A204) describes Silicon revisions.
   Control OMAP Status Register 15:0 (Address 0x4800 244C)
     to separate between omap3503, omap3515, omap3525, omap3530
     and feature presence.
     There are encodings for versions limited to 400266MHz
     but we ignore.
     Not clear if this also holds for omap34xx.
   some eFuse values e.g. CONTROL_FUSE_OPP1_VDD1
     are stored in the SYSCON register range
   Register 0x4830A20C [ProdID.SKUID] [0:3]
     0x0 for normal 600430MHz device.
     0x8 for 720520MHz device.
     Not clear what omap34xx value is.
  AMDM37x TRM (SPRUGN4M)
   CONTROL_IDCODE (0x4830 A204) describes Silicon revisions.
   Control Device Status Register 15:0 (Address 0x4800 244C)
     to separate between am3703, am3715, dm3725, dm3730
     and feature presence.
    Speed Binned = Bit 9
      0 800600 MHz
      1 1000800 MHz
   some eFuse values e.g. CONTROL_FUSE_OPP 1G_VDD1
     are stored in the SYSCON register range.
   There is no 0x4830A20C [ProdID.SKUID] register (exists but
     seems to always read as 0).
  AM3517 is quite similar to AMDM37x except that it has no
  high speed grade eFuse and no abb ldo
  ti_cpufreq_get_efuse() - Parse and return efuse value present on SoC
  @opp_data: pointer to ti_cpufreq_data context
  @efuse_value: Set to the value parsed from efuse
  Returns error code if efuse not read properly.
 not a syscon register! 
  ti_cpufreq_get_rev() - Parse and return rev value present on SoC
  @opp_data: pointer to ti_cpufreq_data context
  @revision_value: Set to the value parsed from revision register
  Returns error code if revision not read properly.
 not a syscon register! 
 legacy 
	
	  OPPs determine whether or not they are supported based on
	  two metrics:
	 	0 - SoC Revision
	 	1 - eFuse value
 Check to ensure we are on a compatible platform 
 SPDX-License-Identifier: GPL-2.0-only
    (c) 2003-2012 Advanced Micro Devices, Inc.
   Maintainer:
   Andreas Herrmann <herrmann.der.user@googlemail.com>
   Based on the powernow-k7.c module written by Dave Jones.
   (C) 2003 Dave Jones on behalf of SuSE Labs
   (C) 2004 Dominik Brodowski <linux@brodo.de>
   (C) 2004 Pavel Machek <pavel@ucw.cz>
   Based upon datasheets & sample CPUs kindly provided by AMD.
   Valuable input gratefully received from Dave Jones, Pavel Machek,
   Dominik Brodowski, Jacob Shin, and others.
   Originally developed by Paul Devriendt.
   Processor information obtained from Chapter 9 (Power and Thermal
   Management) of the "BIOS and Kernel Developer's Guide (BKDG) for
   the AMD Athlon 64 and AMD Opteron Processors" and section "2.x
   Power Management" in BKDGs for newer AMD CPU families.
   Tables for specific CPUs can be inferred from AMD's processor
   power and thermal data sheets, (e.g. 30417.pdf, 30430.pdf, 43375.pdf)
 serialize freq changes  
 Return a frequency in MHz, given an input fid 
 Return a frequency in KHz, given an input fid 
 Return the vco fid for an input fid
  Each "low" fid has corresponding "high" fid, and you can get to "low" fids
  only from corresponding high fids. This returns "high" fid corresponding to
  "low" one.
  Return 1 if the pending bit is set. Unless we just instructed the processor
  to transition to a new state, seeing this bit set is really bad news.
  Update the global current fid  vid values from the status msr.
  Returns 1 on error.
 the isochronous relief time 
 the voltage stabilization time 
 need to init the control msr to a safe value (for each cpu) 
 write the new fid value along with the other control fields to the msr 
 Write a new vid to the hardware 
  Reduce the vid by the max of step or reqvid.
  Decreasing vid codes represent increasing voltages:
  vid of 0 is 1.550V, vid of 0x1e is 0.800V, vid of VID_OFF is off.
 Change OpteronAthlon64 fid and vid, by the 3 phases. 
 Phase 1 - core voltage transition ... setup voltage 
 lower numbers are higher voltages 
 Phase 2 - core frequency transition 
 Phase 3 - core voltage transition flow ... jump to the final vid. 
 IO based frequency switching 
 vid + rvo >= 0 
 vid + rvo >= maxvid 
 Only first fid is allowed to be in "low" range 
 use ACPI support to get full speed on mains power 
 lower 8 bits 
 upper 8 bits 
 Find and validate the PSBPST table in BIOS. 
 Scan BIOS looking for the signature. 
 It can not be at ffff0 - it is too big. 
	
	  If you see this message, complain to BIOS manufacturer. If
	  he tells you "we do not support Linux" or some similar
	  nonsense, remember that Windows 2000 uses the same legacy
	  mechanism that the old Linux PSB driver uses. Tell them it
	  is broken with Windows 2000.
	 
	  The reference to the AMD documentation is chapter 9 in the
	  BIOS and Kernel Developer's Guide, which is available on
	  www.amd.com
 verify the data contained in the ACPI structures 
 fill in data->powernow_table 
 fill in data 
 notify BIOS that we exist 
	 data->acpi_data.state_count informs us at ->exit()
 verify frequency is OK 
		 verify voltage is OK -
 value in usecs, needs to be in nanoseconds 
 Take a frequency, and issue the fidvid transition command 
 fidvid correctness check for k8 
	 fid are the lower 8 bits of the index we stored into
	  the cpufreq frequency table in find_psb_table, vid
	  are the upper 8 bits.
 Driver entry point to switch to the target frequency 
 per CPU init entry point to the driver 
		
		  Use the PSB BIOS structure. This is only available on
		  an UP version, and is deprecated by AMD.
		 Take a crude guess here.
 ACPI _PSS objects available 
 only run on specific CPU from here on 
 Point all the CPUs in this policy to the same data 
 driver entry point for init 
 driver entry point for term 
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (C) 2002 - 2005 Benjamin Herrenschmidt <benh@kernel.crashing.org>
   Copyright (C) 2004        John Steele Scott <toojays@toojays.net>
  TODO: Need a big cleanup here. Basically, we need to have different
  cpufreq_driver structures for the different type of HW instead of the
  current mess. We also need to better deal with the detection of the
  type of machine.
 WARNING !!! This will cause calibrate_delay() to be called,
  but this is an __init function ! So you MUST go edit
  initmain.c to make it non-init before enabling DEBUG_FREQ
  Currently, PowerMac cpufreq supports only high & low frequencies
  that are set by the firmware
  Different models uses different mechanisms to switch the frequency
  Some definitions used by the various speedprocs
 There are only two frequency states for each processor. Values
  are in kHz for the time being.
	 This will cause a recalc of bogomips and display the
	  result. We backuprestore the value to avoid affecting the
	  core cpufreq framework's own calculation.
 DEBUG_FREQ 
 Switch CPU speed under 750FX CPU control
 ramping up, set voltage first 
 Make sure we sleep for at least 1ms 
 tweak L2 for high voltage 
 tweak L2 for low voltage 
 ramping down, set voltage last 
 Switch CPU speed using DFS 
 ramping up, set voltage first 
 Make sure we sleep for at least 1ms 
 set frequency 
 ramping down, set voltage last 
 Switch CPU speed using slewing GPIOs
 If ramping up, set voltage first 
 Delay is way too big but it's ok, we schedule 
 Set frequency 
 If ramping down, set voltage last 
 Delay is way too big but it's ok, we schedule 
 Switch CPU speed under PMU control
 Disable all interrupt sources on openpic 
 Make sure the decrementer won't interrupt us 
	 Make sure any pending DEC interrupt occurring while we did
 We can now disable MSR_EE 
 Giveup the FPU & vec 
 CONFIG_ALTIVEC 
 Save & disable L2 and L3 caches 
 (returns -1 if not available) 
 (returns -1 if not available) 
	 Send the new speed command. My assumption is that this command
	  will cause PLL_CFG[0..3] to be changed next time CPU goes to sleep
 Prepare the northbridge for the speed transition 
	 Call low level code to backup CPU state and recover from
	  hardware reset
 Restore the northbridge 
 Restore L2 cache 
 Restore L3 cache 
 Restore userland MMU context 
 Restore low level PMU operations 
	
	  Restore decrementer; we'll take a decrementer interrupt
	  as soon as interrupts are re-enabled and the generic
	  clockevents code will reprogram it with the right value.
 Restore interrupts 
 Let interrupts flow again ... 
	 That works for all keylargos but shall be fixed properly
	  some day... The problem is that it seems we can't rely
	  on the "reg" property of the GPIO nodes, they are either
	  relative to the base of KeyLargo or to the base of the
	  GPIO space, and the device-tree doesn't help.
	 Ok, this could be made a bit smarter, but let's be robust for now. We
	  always force a speed change to high speed before sleep, to make sure
	  we have appropriate voltage andor bus speed for the wakeup process,
	  and to make sure our loops_per_jiffies are "good enough", that is will
	  not cause too short delays if we sleep in low speed and wake in high
	  speed..
 If we resume, first check if we have a get() function 
	 We don't, hrm... we don't really know our speed here, best
	  is that we force a switch to whatever it was, which is
	  probably high speed due to our suspend() routine
	
	  Check to see if it's GPIO driven or PMU only
	 
	  The way we extract the GPIO address is slightly hackish, but it
	  works well enough for now. We need to abstract the whole GPIO
	  stuff sooner or later anyway
	 If we use the frequency GPIOs, calculate the minmax speeds based
	  on the bus frequencies
 Get the minmax bus frequencies 
		 Grrrr.. It _seems_ that the device-tree is lying on the low bus
		  frequency, it claims it to be around 84Mhz on some models while
		  it appears to be approx. 101Mhz on all. Let's hack around here...
		  fortunately, we don't need to be too precise
 Convert those to CPU core clocks 
		 Now we get the frequencies, we read the GPIO to see what is out current
		  speed
	 If we use the PMU, look for the min & max frequencies in the
	  device-tree
	 The PowerBook G4 12" (PowerBook6,1) has an error in the device-tree
 OF only reports the high frequency 
 Read actual frequency from CPU 
 Currently, we support the following machines:
   - Titanium PowerBook 1Ghz (PMU based, 667Mhz & 1Ghz)
   - Titanium PowerBook 800 (PMU based, 667Mhz & 800Mhz)
   - Titanium PowerBook 400 (PMU based, 300Mhz & 400Mhz)
   - Titanium PowerBook 500 (PMU based, 300Mhz & 500Mhz)
   - iBook2 500600 (PMU based, 400Mhz & 500600Mhz)
   - iBook2 700 (CPU based, 400Mhz & 700Mhz, support low voltage)
   - Recent MacRISC3 laptops
   - All new machines with 7447A CPUs
 Get first CPU node 
 Get current cpu clock freq 
  Check for 7447A based MacRISC3 
 Allow dynamic switching 
 Check for other MacRISC3 machines 
 Else check for iBook2 500600 
 Else check for TiPb 550 
 Else check for TiPb 400 & 500 
		 We only know about the 400 MHz and the 500Mhz model
		  they both have 300 MHz as low frequency
 Else check for 750FX 
 SPDX-License-Identifier: GPL-2.0-only
   linuxarcharmmach-sa1100cpu-sa1110.c
   Copyright (C) 2001 Russell King
  Note: there are two erratas that apply to the SA1110 here:
   7 - SDRAM auto-power-up failure (rev A0)
  13 - Corruption of internal register readswrites following
       SDRAM reads (rev A0, B0, B1)
  We ignore rev. A0 and B0 devices; I don't think they're worth supporting.
  The SDRAM type can be passed on the command line as cpu_sa1110.sdram=type
 bits				 
 cycles			 
 clock cycle time (ns)	 
 activate to rw (ns)		 
 precharge to activate (ns)	 
 write recovery time (ns)	 
 refresh time for array (us)	 
 Toshiba TC59SM716 CL2 
 Toshiba TC59SM716 CL3 
 Samsung K4S641632D TC75 
 Samsung K4S281632B-1H 
 Samsung KM416S4030CT 
 3 CLKs 
 3 CLKs 
 Trdl: 2 CLKs 
 Winbond W982516AH75L CL3 
 Micron MT48LC8M16A2TG-75 
  Given a period in ns and frequency in khz, calculate the number of
  cycles of frequency in period.  Note that we round up to the next
  cycle, even if we are only slightly over.
  Create the MDCAS register bit pattern.
	
	  If SDCLK would invalidate the SDRAM timings,
	  run SDCLK at half speed.
	 
	  CPU steppings prior to B2 must either run the memory at
	  half speed or use delayed read latching (errata 13).
 trp should always be >1 
 initial number of '1's in MDCAS + 1 
  Set the SDRAM refresh rate.
  Update the refresh period.  We do this such that we always refresh
  the SDRAMs within their permissible period.  The refresh period is
  always a multiple of the memory clock (fixed at cpu_clock  2).
  FIXME: we don't currently take account of burst accesses here,
  but neither do Intels DM nor Angel.
  Ok, set the CPU frequency.
	
	  These values are wrong according to the SA1110 documentation
	  and errata, but they seem to work.  Need to get a storage
	  scope on to the SDRAM signals to work out why.
	
	  The clock could be going away for some time.  Set the SDRAMs
	  to refresh rapidly (every 64 memory clock cycles).  To get
	  through the whole array, we need to wait 262144 mclk cycles.
	  We wait 20ms to be safe.
	
	  Reprogram the DRAM timings with interrupts disabled, and
	  ensure that we are doing this within a complete cache line.
	  This means that we won't access SDRAM for the duration of
	  the programming.
	
	  Now, return the SDRAM refresh back to normal.
 sa1110_driver needs __refdata because it must remain after init registers
 SPDX-License-Identifier: GPL-2.0
  Versatile Express SPC CPUFreq Interface driver
  Copyright (C) 2013 - 2019 ARM Ltd.
  Sudeep Holla <sudeep.holla@arm.com>
  Copyright (C) 2013 Linaro.
  Viresh Kumar <viresh.kumar@linaro.org>
 Currently we support only two clusters 
 (Big) clock frequencies 
 Maximum clock frequency (Little) 
 For switcher we use virtual A7 clock rates 
		
		  FIXME: clk_set_rate hasn't returned an error here however it
		  may be that clk_change_rate failed due to hardware or
		  firmware issues and wasn't able to report that due to the
		  current design of the clk core layer. To work around this
		  problem we will read back the clock rate and check it is
		  correct. This needs to be removed once clk core is fixed.
 Recalc freq for old cluster when switching clusters 
 Switch cluster 
 Set freq of old cluster if there are cpus left on it 
 Set clock frequency 
 get the minimum frequency in the cpufreq_frequency_table 
 get the maximum frequency in the cpufreq_frequency_table 
 Add in reverse order to get freqs in increasing order 
 skip duplicates 
 free virtual table 
	
	  platform specific SPC code must initialise the opp table
	  so just check if the OPP count is non-zero
	
	  Get data for all clusters and fill virtual cluster with a merge of
	  both
 Assuming 2 cluster, set clk_big_min and clk_little_max 
 Per-CPU initialization 
 Assumption: during init, we are always running on A15 
 1 ms 
 SPDX-License-Identifier: GPL-2.0-only
  amd_freq_sensitivity.c: AMD frequency sensitivity feedback powersave bias
                          for the ondemand governor.
  Copyright (C) 2013 Advanced Micro Devices, Inc.
  Author: Jacob Shin <jacob.shin@amd.com>
 counter wrapped around, so stay on current frequency 
 divide by 0, so stay on current frequency as well 
 this workload is not CPU bound, so choose a lower freq 
 SPDX-License-Identifier: GPL-2.0-or-later
 	sc520_freq.c: cpufreq driver for the AMD Elan sc520
 	Copyright (C) 2005 Sean Young <sean@mess.org>
 	Based on elanfreq.c
 	2005-03-30: - initial revision
 The default base address 
 CPU Control Register 
 	Module init and exit code
 capability check 
 cpuinfo and default policy values 
 1ms 
 SPDX-License-Identifier: GPL-2.0-or-later
  POWERNV cpufreq driver for the IBM POWER processors
  (C) Copyright IBM 2014
  Author: Vaidyanathan Srinivasan <svaidy at linux.vnet.ibm.com>
 Required for cpu_sibling_mask() in UP configs 
  On an idle system we want the global pstate to ramp-down from max value to
  min over a span of ~5 secs. Also we want it to initially ramp-down slowly and
  then ramp-down rapidly later on.
  This gives a percentage rampdown for time elapsed in milliseconds.
  ramp_down_percentage = ((ms  ms) >> 18)
 			~= 3.8  (sec  sec)
  At 0 ms	ramp_down_percent = 0
  At 5120 ms	ramp_down_percent = 100
 Interval after which the timer is queued to bring down global pstate 
  struct global_pstate_info -	Per policy data structure to maintain history of
 				global pstates
  @highest_lpstate_idx:	The local pstate index from which we are
 				ramping down
  @elapsed_time:		Time in ms spent in ramping down from
 				highest_lpstate_idx
  @last_sampled_time:		Time from boot in ms when global pstates were
 				last set
  @last_lpstate_idx:		Last set value of local pstate and global
  @last_gpstate_idx:		pstate in terms of cpufreq table index
  @timer:			Is used for ramping down if cpu goes idle for
 				a long time with global pstate held high
  @gpstate_lock:		A spinlock to maintain synchronization between
 				routines called by the timer handler and
 				governer's target_index calls
  @policy:			Associated CPUFreq policy
  struct pstate_idx_revmap_data: Entry in the hashmap pstate_revmap
 				  indexed by a function of pstate id.
  @pstate_id: pstate id for this entry.
  @cpufreq_table_idx: Index into the powernv_freqs
 		       cpufreq_frequency_table for frequency
 		       corresponding to pstate_id.
  @hentry: hlist_node that hooks this entry into the pstate_revmap
 	    hashtable
  Note:
  The set of pstates consists of contiguous integers.
  powernv_pstate_info stores the index of the frequency table for
  max, min and nominal frequencies. It also stores number of
  available frequencies.
  powernv_pstate_info.nominal indicates the index to the highest
  non-turbo frequency.
 Use following functions for conversions between pstate_id and index 
  idx_to_pstate : Returns the pstate id corresponding to the
 		   frequency in the cpufreq frequency table
 		   powernv_freqs indexed by @i.
 		   If @i is out of bound, this will return the pstate
 		   corresponding to the nominal frequency.
  pstate_to_idx : Returns the index in the cpufreq frequencytable
 		   powernv_freqs for the frequency whose corresponding
 		   pstate id is @pstate.
 		   If no frequency corresponding to @pstate is found,
 		   this will return the index of the nominal
 		   frequency.
  Initialize the freq table based on data obtained
  from the firmware passed via device-tree
 kHz 
 End of list marker entry 
 Returns the CPU frequency corresponding to the pstate_id. 
  cpuinfo_nominal_freq_show - Show the nominal CPU frequency as indicated by
  the firmware
 Helper routines 
 Access helpers to power mgt SPR 
  Use objects of this type to queryupdate
  pstates on a remote CPU via smp_call_function.
  powernv_read_cpu_freq: Reads the current frequency on this CPU.
  Called via smp_call_function.
  Note: The caller of the smp_call_function should pass an argument of
  the type 'struct powernv_smp_call_data ' along with this function.
  The current frequency on this CPU will be returned via
  ((struct powernv_smp_call_data )arg)->freq;
  powernv_cpufreq_get: Returns the CPU frequency as reported by the
  firmware for CPU 'cpu'. This value is reported through the sysfs
  file cpuinfo_cur_freq.
  set_pstate: Sets the pstate on this CPU.
  This is called via an smp_call_function.
  The caller must ensure that freq_data is of the type
  (struct powernv_smp_call_data ) and the pstate_id which needs to be set
  on this CPU should be present in freq_data->pstate_id.
 Set both global(bits 56..63) and local(bits 48..55) PStates 
  get_nominal_index: Returns the index corresponding to the nominal
  pstate in the cpufreq table
 Check for Pmax Capping 
 Check if Psafe_mode_active is set in PMSR. 
 Check if SPR_EM_DISABLE is set in PMSR 
  calc_global_pstate - Calculate global pstate
  @elapsed_time:		Elapsed time in milliseconds
  @local_pstate_idx:		New local pstate
  @highest_lpstate_idx:	pstate from which its ramping down
  Finds the appropriate global pstate based on the pstate from which its
  ramping down and the time elapsed in ramping down. It follows a quadratic
  equation which ensures that it reaches ramping down to pmin in 5sec.
	
	  Using ramp_down_percent we get the percentage of rampdown
	  that we are expecting to be dropping. Difference between
	  highest_lpstate_idx and powernv_pstate_info.min will give a absolute
	  number of how many pstates we will drop eventually by the end of
	  5 seconds, then just scale it get the number pstates to be dropped.
 Ensure that global pstate is >= to local pstate 
	
	  Setting up timer to fire after GPSTATE_TIMER_INTERVAL ms, But
	  if it exceeds MAX_RAMP_DOWN_TIME ms for ramp down time.
	  Set timer such that it fires exactly at MAX_RAMP_DOWN_TIME
	  seconds of ramp down time.
  gpstate_timer_handler
  @t: Timer context used to fetch global pstate info struct
  This handler brings down the global pstate closer to the local pstate
  according quadratic equation. Queues a new timer if it is still not equal
  to local pstate
	
	  If the timer has migrated to the different cpu then bring
	  it back to one of the policy->cpus
	
	  If PMCR was last updated was using fast_swtich then
	  We may have wrong in gpstate->last_lpstate_idx
	  value. Hence, read from PMCR to get correct data.
	
	  If local pstate is equal to global pstate, rampdown is over
	  So timer is not required to be queued.
  powernv_cpufreq_target_index: Sets the frequency corresponding to
  the cpufreq table entry indexed by new_index on the cpus in the
  mask policy->cpus
		 we don't want to be preempted while
		  checking if the CPU frequency has been throttled
		
		  If its has been ramping down for more than MAX_RAMP_DOWN_TIME
		  we should be resetting all global pstate related data. Set it
		  equal to local pstate to start fresh.
 Elaspsed_time is less than 5 seconds, continue to rampdown 
	
	  If local pstate is equal to global pstate, rampdown is over
	  So timer is not required to be queued.
	
	  Use smp_call_function to send IPI and execute the
	  mtspr on target CPU.  We could do that without IPI
	  if current CPU is within policy->cpus (core)
 Initialise Gpstate ramp-down timer only on POWER8 
 initialize timer 
		
		  powernv_cpufreq_throttle_check() is called in
		  target() callback which can detect the throttle state
		  for governors like ondemand.
		  But static governors will not call target() often thus
		  report throttling here.
 Allocate a chip cpu mask large enough to fit mask for all chips 
 flush any pending work items 
 Don't probe on pseries (guest) platforms 
 Discover pstates from device tree and init 
 Populate chip info 
 SPDX-License-Identifier: GPL-2.0-or-later
  pmi backend for the cbe_cpufreq driver
  (C) Copyright IBM Deutschland Entwicklung GmbH 2005-2007
  Author: Christian Krafft <krafft@de.ibm.com>
  hardware specific functions
 SPDX-License-Identifier: GPL-2.0-only
   AMD K7 Powernow driver.
   (C) 2003 Dave Jones on behalf of SuSE Labs.
   Based upon datasheets & sample CPUs kindly provided by AMD.
  Errata 5:
   CPU may fail to execute a FIDVID change in presence of interrupt.
   - We clisti on stepping A0 CPUs around the FIDVID transition.
  Errata 15:
   CPU with half frequency multipliers may hang upon wakeup from disconnect.
   - We disable half multipliers if ACPI is used on A0 stepping CPUs.
 Needed for recalibrate_cpu_khz() 
 divide by 1000 to get VCore voltage in V. 
 divide by 10 to get FID. 
 This parameter is used in order to force ACPI instead of legacy method for
  configuration purpose.
 Get maximum capabilities 
 Any powernow info ? 
 Check we can actually do something before we say anything.
 lower 8 bits 
 upper 8 bits 
	 fid are the lower 8 bits of the index we stored into
	  the cpufreq frequency table in powernow_decode_bios,
	  vid are the upper 8 bits.
 Now do the magic poking into the MSRs.  
 A0 errata 5 
 Going down, so change FID first 
 Going up, so change VID first 
 lower 8 bits 
 upper 8 bits 
		 processor_perflib will multiply the MHz value by 1000 to
		  get a KHz value (e.g. 1266000). However, powernow-k7 works
		  with true KHz values (e.g. 1266768). To ensure that all
		  powernow frequencies are available, we must ensure that
		  ACPI doesn't restrict them, so we round up the MHz value
		  to ensure that perflib's computed KHz value is greater than
		  or equal to powernow's KHz value.
 notify BIOS that we exist 
  We use the fact that the bus frequency is somehow
  a multiple of 1000003 khz, then we compute sgtc according
  to this multiple.
  That way, we match more how AMD thinks all of that work.
  We will then get the same kind of behaviour already tested under
  the "well-known" other OS.
  Some Athlon laptops have really fucked PST tables.
  A BIOS update is all that can save them.
  Mention this, and disable cpufreq.
 SGTC use the bus clock as timer 
 SPDX-License-Identifier: GPL-2.0-only
  Tegra 124 cpufreq driver
	
	  PLLP rate 408Mhz is below the CPU Fmax at Vmin and is safe to
	  use during suspend and resume. So, switch the CPU clock source
	  to PLLP and disable DFLL.
	
	  Warmboot code powers up the CPU with PLLP clock source.
	  Enable DFLL clock and switch CPU clock source back to DFLL.
	
	  Platform driver+device required for handling EPROBE_DEFER with
	  the regulator and the DFLL clock
 SPDX-License-Identifier: GPL-2.0-only
  (C) 2002 - 2003  Dominik Brodowski <linux@brodo.de>
   BIG FAT DISCLAIMER: Work in progress code. Possibly dangerous
  longrun_{low,high}_freq is needed for the conversion of cpufreq kHz
  values into per cent values. In TMTA microcode, the following is valid:
  performance_pctg = (current_freq - low_freq)(high_freq - low_freq)
  longrun_get_policy - get the current LongRun policy
  @policy: struct cpufreq_policy where current policy is written into
  Reads the current LongRun policy by access to MSR_TMTA_LONGRUN_FLAGS
  and MSR_TMTA_LONGRUN_CTRL
 Assume degenerate Longrun table 
  longrun_set_policy - sets a new CPUFreq policy
  @policy: new policy
  Sets a new CPUFreq policy on LongRun-capable processors. This function
  has to be called with cpufreq_driver locked.
 Assume degenerate Longrun table 
 performance or economy mode 
 lower and upper boundary 
  longrun_verify_poliy - verifies a new CPUFreq policy
  @policy: the policy to verify
  Validates a new CPUFreq policy. This function has to be called with
  cpufreq_driver locked.
  longrun_determine_freqs - determines the lowest and highest possible core frequency
  @low_freq: an int to put the lowest frequency into
  @high_freq: an int to put the highest frequency into
  Determines the lowest and highest possible core frequencies on this CPU.
  This is necessary to calculate the performance percentage according to
  TMTA rules:
  performance_pctg = (target_freq - low_freq)(high_freq - low_freq)
		 if the LongRun Table Interface is present, the
		  detection is a bit easier:
		  For minimum frequency, read out the maximum
		  level (msr_hi), write that into "currently
		  selected level", and read out the frequency.
		  For maximum frequency, read out level zero.
 minimum 
 to kHz 
 maximum 
 to kHz 
 set the upper border to the value determined during TSC init 
 get current borders 
	 if current perf_pctg is larger than 90%, we need to decrease the
	  upper limit to make the calculation more accurate.
	 try decreasing in 10% steps, some processors react only
 set to 0 to try_hi perf_pctg 
 read out current core MHz and current perf_pctg 
 restore values 
	 performance_pctg = (current_freq - low_freq)(high_freq - low_freq)
	  eqals
	  low_freq  (1 - perf_pctg) = (cur_freq - high_freq  perf_pctg)
	 
	  high_freq  perf_pctg is stored tempoarily into "ebx".
 to MHz 
 back to kHz 
 capability check 
 detect low and high frequency 
 cpuinfo and default policy values 
  longrun_init - initializes the Transmeta Crusoe LongRun CPUFreq driver
  Initializes the LongRun support.
  longrun_exit - unregisters LongRun support
 SPDX-License-Identifier: GPL-2.0-or-later
  pervasive backend for the cbe_cpufreq driver
  This driver makes use of the pervasive unit to
  engage the desired frequency.
  (C) Copyright IBM Deutschland Entwicklung GmbH 2005-2007
  Author: Christian Krafft <krafft@de.ibm.com>
 to write to MIC register 
 more values for the MIC 
 set bits to zero 
 set bits to next pmode 
 wait until new pmode appears in status register 
  driverscpufreqspear-cpufreq.c
  CPU Frequency Scaling for SPEAr platform
  Copyright (C) 2012 ST Microelectronics
  Deepak Sikri <deepak.sikri@st.com>
  This file is licensed under the terms of the GNU General Public
  License version 2. This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
 SPEAr CPUFreq driver data structure 
	
	  In SPEAr1340, cpu clk's parent sys clk can take input from
	  following sources
	
	  As sys clk can have multiple source with their own range
	  limitation so we choose possible sources accordingly
 src is sys_syn_clk 
 src is pll3_clk 
 src is pll1_clk 
 Get parent to sys clock 
  In SPEAr1340, we cannot use newfreq directly because we need to actually
  access a source clock (clk) which might not be ancestor of cpu at present.
  Hence in SPEAr1340 we would operate on source clock directly before switching
  cpu clock to it.
 Set the rate of the source clock before changing the parent 
		
		  SPEAr1340 is special in the sense that due to the possibility
		  of multiple clock sources for cpu clk's parent we can have
		  different clock source for different frequency of cpu clk.
		  Hence we need to choose one from amongst these possible clock
		  sources.
 SPEAr1340: src clk is always 2  intended cpu clk 
		
		  src clock to be altered is ancestor of cpu clock. Hence we
		  can directly work on cpu clk
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2007 PA Semi, Inc
  Authors: Egor Martovetsky <egor@pasemi.com>
 	    Olof Johansson <olof@lixom.net>
  Maintained by: Olof Johansson <olof@lixom.net>
  Based on archpowerpcplatformscellcbe_cpufreq.c:
  (C) Copyright IBM Deutschland Entwicklung GmbH 2005
 SDCPWR_GIZTIME_REG fields 
 Offset of ASR registers from SDC base 
 Current astate, is used when waking up from power savings on
  one core, in case the other core has switched states during
  the idle time.
 We support 5(A0-A4) power states excluding turbo(A5-A6) modes 
  hardware specific functions
 just provide the upper bound 
 Return if called before init has run 
  cpufreq functions
 we need the freq in kHz 
 initialize frequency table 
	
	  We don't support CPU hotplug. Don't unmap after the system
	  has already made it to a running state.
  module init and destoy
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2010 Google, Inc.
  Author:
 	Colin Cross <ccross@google.com>
 	Based on archarmplat-omapcpu-omap.c, (C) 2005 Nokia Corporation
 SPDX-License-Identifier: GPL-2.0
  Allwinner CPUFreq nvmem based driver
  The sun50i-cpufreq-nvmem driver reads the efuse value from the SoC to
  provide the OPP framework with required information.
  Copyright (C) 2019 Yangtao Li <tiny.windzz@gmail.com>
  sun50i_cpufreq_get_efuse() - Determine speed grade from efuse value
  @versions: Set to the value parsed from efuse
  Returns 0 if success.
	
	  We treat unexpected efuse values as if the SoC was from
	  the slowest bin. Expected efuse values are 1-3, slowest
	  to fastest.
  Since the driver depends on nvmem drivers, which may return EPROBE_DEFER,
  all the real activity is done in the probe, which may be defered as well.
  The init here is only registering the driver and the platform device.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2017, NVIDIA CORPORATION. All rights reserved
 CPU0 - A57 Cluster 
 CPU1 - Denver Cluster 
 CPU2 - Denver Cluster 
 CPU3 - A57 Cluster 
 CPU4 - A57 Cluster 
 CPU5 - A57 Cluster 
 Only store lowest voltage index for each rate 
 Only store lowest voltage index for each rate 
 SPDX-License-Identifier: GPL-2.0-only
 	Cyrix MediaGX and NatSemi Geode Suspend Modulation
 	(C) 2002 Zwane Mwaikambo <zwane@commfireservices.com>
 	(C) 2002 Hiroshi Miura   <miura@da-cha.org>
 	All Rights Reserved
       The author(s) of this software shall not be held liable for damages
       of any nature resulting due to the use of this software. This
       software is provided AS-IS with no warranties.
  Theoretical note:
 	(see Geode(tm) CS5530 manual (rev.4.1) page.56)
 	CPU frequency control on NatSemi Geode GX1GXLV processor and CS55x0
 	are based on Suspend Modulation.
 	Suspend Modulation works by asserting and de-asserting the SUSP# pin
 	to CPU(GX1GXLV) for configurable durations. When asserting SUSP#
 	the CPU enters an idle state. GX1 stops its core clock when SUSP# is
 	asserted then power consumption is reduced.
 	Suspend Modulation's OFFON duration are configurable
 	with 'Suspend Modulation OFF Count Register'
 	and 'Suspend Modulation ON Count Register'.
 	These registers are 8bit counters that represent the number of
 	32us intervals which the SUSP# pin is asserted(ON)de-asserted(OFF)
 	to the processor.
 	These counters define a ratio which is the effective frequency
 	of operation of the system.
 			       OFF Count
 	F_eff = Fgx  ----------------------
 	                OFF Count + ON Count
 	0 <= On Count, Off Count <= 255
 	From these limits, we can get register values
 	off_duration + on_duration <= MAX_DURATION
 	on_duration = off_duration  (stock_freq - freq)  freq
       off_duration  =  (freq  DURATION)  stock_freq
       on_duration = DURATION - off_duration
 ---------------------------------------------------------------------------
  ChangeLog:
 	Dec. 12, 2003	Hiroshi Miura <miura@da-cha.org>
 		- fix onoff register mistake
 		- fix cpu_khz calc when it stops cpu modulation.
 	Dec. 11, 2002	Hiroshi Miura <miura@da-cha.org>
 		- rewrite for Cyrix MediaGX Cx55105520 and
 		  NatSemi Geode Cs5530(A).
 	Jul. ??, 2002  Zwane Mwaikambo <zwane@commfireservices.com>
 		- cs5530_mod patch for 2.4.19-rc1.
 ---------------------------------------------------------------------------
  Todo
 	Test on machines with 5510, 5530, 5530A
 			Suspend Modulation - Definitions		
 PCI config registers, all at F0 
 power management enable register 1 
 power management enable register 2 
 power management enable register 3 
 irq speedup timer counter register:typical 2 to 4ms 
 video speedup timer counter register: typical 50 to 100ms 
 suspend modulation OFF counter register, 1 = 32us 
 suspend modulation ON counter register 
 suspend configuration register 
 PMER1 bits 
 global power management 
 globally enable PM device idle timers 
 globally enable IO traps 
 disable clock throttle during interrupt handling 
 disable clock throttle during vga video handling 
 SUSCFG bits 
 enabledisable suspend modulation 
 the below is supported only with cs5530 (after rev.1.2)cs5530A 
 select how SMI re-enable suspend modulation: 
 IRQTC timer or read SMI speedup disable reg.(F1BAR[08-09h]) 
 enable powering down a GXLV processor. "Special 3Volt Suspend" mode 
 the below is supported only with cs5530A 
 stop ISA clock  
 active idle 
 PCI bus clock - defaults to 30.000 if cpu_khz is not available 
 maximum duration for which the cpu may be suspended
  (32us  MAX_DURATION). If no parameter is given, this defaults
  to 255.
  Note that this leads to a maximum of 8 ms(!) where the CPU clock
  is suspended -- processing power is just 0.39% of what it used to be,
 For the default policy, we want at least some processing power
  - let's say 5%. (min = maxfreq  POLICY_MIN_DIV)
  we can detect a core multiplier from dir0_lsb
  from GX1 datasheet p.56,
 	MULT[3:0]:
 	0000 = SYSCLK multiplied by 4 (test only)
 	0001 = SYSCLK multiplied by 10
 	0010 = SYSCLK multiplied by 4
 	0011 = SYSCLK multiplied by 6
 	0100 = SYSCLK multiplied by 9
 	0101 = SYSCLK multiplied by 5
 	0110 = SYSCLK multiplied by 7
 	0111 = SYSCLK multiplied by 8
               of 33.3MHz
 	Low Level chipset interface				
  gx_detect_chipset:
 detect which companion chip is used 
  gx_get_cpuspeed:
  Finds out at which efficient frequency the Cyrix MediaGXNatSemi
  Geode CPU runs.
       gx_validate_speed:
       determine current cpu speed
		 if this relation is closer to khz, use this. If it's equal,
  gx_set_cpuspeed:
  set cpu speed in khz.
 if new khz == 100% of CPU speed, it is special case 
 FIXME: need to test other values -- Zwane,Miura 
 typical 2 to 4ms 
 typical 50 to 100ms 
 CS5530(rev 1.2, 1.3) 
 CS5530A,B.. 
              High level functions                             
 	cpufreq_gx_verify: test if frequency range is valid
 	This function checks if a given frequency range in kHz is valid
       for the hardware supported by the driver.
	 it needs to be assured that at least one supported frequency is
	  within policy->min and policy->max. If it is not, policy->max
	  needs to be increased until one frequency is supported.
	  policy->min may not be decreased, though. This way we guarantee a
	  specific processing capacity.
       cpufreq_gx_target:
 determine maximum frequency 
 setup basic struct for cpufreq API 
  cpufreq_gx_init:
    MediaGXGeode GX initialize cpufreq driver
 Test if we have the right hardware 
 check whether module parameters are sane 
 keep cs55x0 configurations 
 register error! 
 SPDX-License-Identifier: GPL-2.0
  Copyright (c) 2020, NVIDIA CORPORATION. All rights reserved
 408 MHz 
 cpufreq transisition latency 
 unit in nanoseconds 
  Read per-core Read-only system register NVFREQ_FEEDBACK_EL1.
  The register provides frequency feedback information to
  determine the average actual frequency a core has run at over
  a period of time.
 	[31:0] PLLP counter: Counts at fixed frequency (408 MHz)
 	[63:32] Core clock counter: counts on every core clock cycle
 			where the core is architecturally clocking
	
	  ref_clk_counter(32 bit counter) runs on constant clk,
	  pll_p(408MHz).
	  It will take = 2 ^ 32  408 MHz to overflow ref clk counter
	               = 10526880 usec = 10.527 sec to overflow
	 
	  Like wise core_clk_counter(32 bit counter) runs on core clock.
	  It's synchronized to crab_clk (cpu_crab_clk) which runs at
	  freq of cluster. Assuming max cluster clock ~2000MHz,
	  It will take = 2 ^ 32  2000 MHz to overflow core clk counter
	               = ~2.147 sec to overflow
  Return instantaneous cpu speed
  Instantaneous freq is calculated as -
  -Takes sample on every query of getting the freq.
 	- Read core and ref clock counters;
 	- Delay for X us
 	- Read above cycle counters again
 	- Calculates freq by subtracting current and previous counters
 	  divided by the delay time or eqv. of ref_clk_counter in delta time
 	- Return Kcyclessecond, freq in KHz
 	delta time period = x sec
 			  = delta ref_clk_counter  (408  10^6) sec
 	freq in Hz = cyclessec
 		   = (delta cycles  x sec
 		   = (delta cycles  408  10^6)  delta ref_clk_counter
 	in KHz	   = (delta cycles  408  10^3)  delta ref_clk_counter
  @cpu - logical cpu whose freq to be updated
  Returns freq in KHz on success, 0 if cpu is offline
	
	  udelay() is required to reconstruct cpu frequency over an
	  observation window. Using workqueue to call udelay() with
	  interrupts enabled.
 ref clock is 32 bits 
 in KHz 
 reconstruct actual cpu freq using counters 
 get last written ndiv value 
	
	  If the reconstructed frequency has acceptable delta from
	  the last written value, then return freq corresponding
	  to the last written ndiv value from freq_table. This is
	  done to return consistent value.
 set same policy for all cpus in a cluster 
	
	  Each core writes frequency in per core register. Then both cores
	  in a cluster run at same frequency which is the maximum frequency
	  request out of the values requested by both cores in that cluster.
 Cluster not available 
	
	  Make sure frequency table step is a multiple of mdiv to match
	  vhint table granularity.
 We store both ndiv_min and ndiv_max hence the +1 
 sentinel  }
 SPDX-License-Identifier: GPL-2.0-or-later
 	kirkwood_freq.c: cpufreq driver for the Marvell kirkwood
 	Copyright (C) 2013 Andrew Lunn <andrew@lunn.ch>
  Kirkwood can swap the clock to the CPU between two clocks:
  - cpu clk
  - ddr clk
  The frequencies are set at runtime before registering this table.
 CPU uses cpuclk 
 CPU uses ddrclk 
 Disable interrupts to the CPU 
 Wait-for-Interrupt, while the hardware changes frequency 
 Enable interrupts to the CPU 
 Module init and exit code 
 SPDX-License-Identifier: GPL-2.0-only
  (C) 2002 - 2003 Dominik Brodowski <linux@brodo.de>
   Library for common functions for Intel SpeedStep v.1 and v.2 support
   BIG FAT DISCLAIMER: Work in progress code. Possibly dangerous
                    GET PROCESSOR CORE SPEED IN KHZ                 
 See table 14 of p3_ds.pdf and table 22 of 29834003.pdf 
 Frequency Multiplier (x10) 
		u8 bitmap;		 power on configuration bits
 error or unknown value 
 PIII(-M) FSB settings: see table b1-b of 24547206.pdf 
 Front Side Bus speed in MHz 
		u8 bitmap;		 power on configuration bits [18: 19]
 read MSR 0x2a - we only need the low 32 bits 
 decode the FSB 
 decode the multiplier 
 see table B-2 of 24547212.pdf 
 see table B-2 of 25366920.pdf 
	 Pentium 4 Model 0 and 1 do not have the Core Clock Frequency
	  to System Bus Frequency Ratio Field in the Processor Frequency
	  Configuration Register of the MSR. Therefore the current
	  frequency cannot be calculated and has to be measured.
	 decode the FSB: see IA-32 Intel (C) Architecture Software
	  Developer's Manual, Volume 3: System Prgramming Guide,
	  revision #12 in Table B-1: MSRs in the Pentium 4 and
	  Intel Xeon Processors, on page B-4 and B-5.
 Multiplier. 
 Warning: may get called from smp_call_function_single. 
                  DETECT SPEEDSTEP-CAPABLE PROCESSOR                
 Keep in sync with the x86_cpu_id tables in the different modules 
		 Intel Mobile Pentium 4-M
			
			  B-stepping [M-P4-M]
			  sample has ebx = 0x0f, production has 0x0e.
			
			  C-stepping [M-P4-M]
			  needs to have ebx=0x0e, else it's a celeron:
			  cf. 25130917.pdf  page 7, footnote 5 even
			  though 25072120.pdf  page 7 doesn't say
			  samples are only of B-stepping...
			
			  D-stepping [M-P4-M or M-P4533]
			 
			  this is totally strange: CPUID 0x0F29 is
			  used by M-P4-M, M-P4533 and(!) Celeron CPUs.
			  The latter need to be sorted out as they don't
			  support speedstep.
			  Celerons with CPUID 0x0F29 may have either
			  ebx=0x8 or 0xf -- 25130917.pdf doesn't say anything
			  specific.
			  M-P4-Ms may have either ebx=0xe or 0xf [see above]
			  M-P4533 have either ebx=0xe or 0xf. [25317607.pdf]
			  also, M-P4M HTs have ebx=0x8, too
			  For now, they are distinguished by the model_id
			  string
 Intel PIII [Tualatin] 
		 cpuid_ebx(1) is 0x04 for desktop PIII,
		 So far all PIII-M processors support SpeedStep. See
		  Intel's 24540640.pdf of June 2003
 Intel PIII [Coppermine] 
		 all mobile PIII Coppermines have FSB 100 MHz
		
		  If the processor is a mobile version,
		  platform ID has bit 50 set
		  it has SpeedStep technology if either
		  bit 56 or 57 is set
                      DETECT SPEEDSTEP SPEEDS                       
 get current speed 
 switch to low state 
 start latency measurement 
 switch to high state 
 end latency measurement 
 switch to previous state, if necessary 
 convert uSec to nSec and add 20% for safety reasons 
		 check if the latency measurement is too high or too low
		  and set it to a safe value (500uSec) in that case
 SPDX-License-Identifier: GPL-2.0-only
  Intel SpeedStep SMI driver.
  (C) 2003  Hiroshi Miura <miura@da-cha.org>
                         SPEEDSTEP - DEFINITIONS                    
 speedstep system management interface portcommand.
  These parameters are got from IST-SMI BIOS call.
  If user gives it, these are used.
 info about the processor 
  There are only two frequency states for each processor. Values
  are in kHz for the time being.
 how often shall the SMI call be tried if it failed, e.g. because
  speedstep_smi_ownership
  speedstep_smi_get_freqs - get SpeedStep preferred & current freq.
  @low: the low frequency value is placed here
  @high: the high frequency value is placed here
  Only available on later SpeedStep-enabled systems, returns false results or
  even hangs [cf. bugme.osdl.org # 1422] on earlier systems. Empirical testing
  shows that the latter occurs if !(ist_info.event & 0xFFFF).
 abort if results are obviously incorrect... 
  speedstep_set_state - set the SpeedStep state
  @state: new processor frequency state (SPEEDSTEP_LOW or SPEEDSTEP_HIGH)
 Disable IRQs 
			
			  We need to enable interrupts, otherwise the blockage
			  won't resolve.
			 
			  We disable preemption so that other processes don't
			  run. If other processes were running, they could
			  submit more DMA requests, making the blockage worse.
 enable IRQs 
  speedstep_target - set a new CPUFreq policy
  @policy: new policy
  @index: index of new freq
  Sets a new CPUFreq policyfreq.
 capability check 
 detect low and high frequency 
		 fall back to speedstep_lib.c dection mechanism:
  speedstep_init - initializes the SpeedStep CPUFreq driver
    Initializes the SpeedStep support. Returns -ENODEV on unsupported
  BIOS, -EINVAL on problems during initiatization, and zero on
  success.
	 Error if no IST-SMI BIOS or no PARM
 setup smi_port from MODLULE_PARM or BIOS 
  speedstep_exit - unregisters SpeedStep support
    Unregisters SpeedStep support.
   pcc-cpufreq.c - Processor Clocking Control firmware cpufreq interface
   Copyright (C) 2009 Red Hat, Matthew Garrett <mjg@redhat.com>
   Copyright (C) 2009 Hewlett-Packard Development Company, L.P.
 	Nagananda Chumbalkar <nagananda.chumbalkar@hp.com>
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   This program is free software; you can redistribute it andor modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 of the License.
   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or NON
   INFRINGEMENT. See the GNU General Public License for more details.
   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation, Inc.,
   675 Mass Ave, Cambridge, MA 02139, USA.
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Clear the input buffer - we are done with the current command 
 Clear the input buffer - we are done with the current command 
 Firmware's use of _OSC is optional 
 Skip initialization if another cpufreq driver is there. 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2013 Freescale Semiconductor, Inc.
 MX6UL requires two more clks 
 scaling up?  scale voltage before frequency 
	
	  The setpoints are selected per PLLPDF frequencies, so we need to
	  reprogram PLL for frequency scaling.  The procedure of reprogramming
	  PLL1 is as below.
	  For i.MX6UL, it has a secondary clk mux, the cpu frequency change
	  flow is slightly different from other i.MX6 OSC.
	  The cpu frequeny change flow for i.MX6(except i.MX6UL) is as below:
	   - Enable pll2_pfd2_396m_clk and reparent pll1_sw_clk to it
	   - Reprogram pll1_sys_clk and reparent pll1_sw_clk back to it
	   - Disable pll2_pfd2_396m_clk
		
		  When changing pll1_sw_clk's parent to pll1_sys_clk,
		  CPU may run at higher than 528MHz, this will lead to
		  the system unstable if the voltage is lower than the
		  voltage of 528MHz, so lower the CPU frequency to one
		  half before changing CPU frequency.
 pll1_sys needs to be enabled for divider rate change to work. 
 Ensure the arm clock divider is what we expect 
 PLL1 is only needed until after ARM-PODF is set. 
 scaling down?  scale voltage after frequency 
		
		  SPEED_GRADING[1:0] defines the max speed of ARM:
		  2b'11: 1200000000Hz;
		  2b'10: 996000000Hz;
		  2b'01: 852000000Hz; -- i.MX6Q Only, exclusive with 996MHz.
		  2b'00: 792000000Hz;
		  We need to set the max speed of ARM according to fuse map.
	
	  Speed GRADING[1:0] defines the max speed of ARM:
	  2b'00: Reserved;
	  2b'01: 528000000Hz;
	  2b'10: 696000000Hz on i.MX6UL, 792000000Hz on i.MX6ULL;
	  2b'11: 900000000Hz on i.MX6ULL only;
	  We need to set the max speed of ARM according to fuse map.
 Make imx6_soc_volt array's size same as arm opp number 
	
	  Each OPP is a set of tuples consisting of frequency and
	  voltage like <freq-kHz vol-uV>.
 use fixed soc opp volt if no valid soc opp info found in dtb 
	
	  Calculate the ramp time for max voltage change in the
	  VDDSOC and VDDPU regulators.
	
	  OPP is maintained in order of increasing frequency, and
	  freq_table initialised from OPP is therefore sorted in the
	  same order.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (C) 2012 Freescale Semiconductor, Inc.
  Copyright (C) 2014 Linaro.
  Viresh Kumar <viresh.kumar@linaro.org>
 Extra space for boost-attr if required 
  An earlier version of opp-v1 bindings used to name the regulator
  "cpu0-supply", we still need to handle that for backwards compatibility.
 This must be valid for sure 
 Try "cpu0" for older DTs 
 Support turboboost mode 
 This gets disabled by core on driver unregister 
 We did light-weight tear down earlier, nothing to do here 
	
	  Preserve policy->driver_data and don't free resources on light-weight
	  tear down.
 Check if this CPU is already covered by some other policy 
	
	  OPP layer will be taking care of regulators now, but it needs to know
	  the name of the regulator first.
 Get OPP-sharing information from "operating-points-v2" bindings 
		
		  operating-points-v2 not supported, fallback to all CPUs share
		  OPP for backward compatibility if the platform hasn't set
		  sharing CPUs.
	
	  Initialize OPP tables for all priv->cpus. They will be shared by
	  all CPUs which have marked their CPUs shared with OPP bindings.
	 
	  For platforms not using operating-points-v2 bindings, we do this
	  before updating priv->cpus. Otherwise, we will end up creating
	  duplicate OPPs for the CPUs.
	 
	  OPPs might be populated at runtime, don't fail for error here unless
	  it is -EPROBE_DEFER.
	
	  The OPP table must be initialized, statically or dynamically, by this
	  point.
 Request resources early so we can return in case of -EPROBE_DEFER 
 SPDX-License-Identifier: GPL-2.0-only
   Copyright (C) 2011 Dmitry Eremin-Solenikov
   Copyright (C) 2002 - 2005 Benjamin Herrenschmidt <benh@kernel.crashing.org>
   and                       Markus Demleitner <msdemlei@cl.uni-heidelberg.de>
  This driver adds basic cpufreq support for SMU & 970FX based G5 Macs,
  that is iMac G5 and latest single CPU desktop.
 see 970FX user manual 
 PCR scom addr 
 1 = PCR, 0 = PCRH 
 1:1 speed value 
 1:2 speed value 
 1:4 speed value 
 speed mask 
 freq request valid 
 volt request valid 
 target time 
 STATLAT value 
 SNOOPLAT value 
 SNOOPACC value 
 PSR scom addr 
 warning: PSR is a 64 bits register 
 command received 
 command completed 
 current speed 
  The G5 only supports two frequencies (Quarter speed is not supported)
 Power mode data is an array of the 32 bits PCR values to use for
  the various frequencies, retrieved from the device-tree
  SCOM based frequency switching for 970FX rev3
 Clear PCR high 
 Clear PCR low 
 Set PCR low 
 Wait for completion 
  Common interface to the cpufreq core
	
	  Behave here like powermac driver which checks machine compatibility
	  to ease merging of two drivers in future.
 Get first CPU node 
 Check 970FX for now 
 we actually don't care on which CPU to access PVR 
 Look for the powertune data in the device-tree 
	
	  On Maple this property is provided by PIBS in dual-processor config,
	  not provided by PIBS in CPU0 config and also not provided by SLOF,
	  so YMMV
	
	  From what I see, clock-frequency is always the maximal frequency.
	  The current driver can not slew sysclk yet, so we really only deal
	  with powertune steps for now. We also only implement full freq and
	  half freq in this version. So far, I haven't yet seen a machine
	  supporting anything else.
	 Force apply current frequency to make sure everything is in
	  sync (voltage is right for example). Firmware may leave us with
	  a strange setting ...
 SPDX-License-Identifier: GPL-2.0-or-later
   Copyright (C) 2002,2003 Intrinsyc Software
  History:
    31-Jul-2002 : Initial version [FB]
    29-Jan-2003 : added PXA255 support [FB]
    20-Apr-2003 : ported to v2.5 (Dustin McIntire, Sensoria Corp.)
  Note:
    This driver may change the memory bus clock rate, but will not do any
    platform specific access timing changes... for example if you have flash
    memory connected to CS0, you will need to register a platform specific
    notifier which will adjust the memory access strobes to maintain a
    minimum strobe width.
  PXA255 definitions
 CPU   MEMBUS		   run  turbo PXbus SDRAM 
  99,   99,   50,   50  
 133,  133,   66,   66  
 199,  199,   99,   99  
 265,  265,  133,   66  
 331,  331,  166,   83  
 398,  398,  196,   99  
 Use the turbo mode frequencies for the CPUFREQ_POLICY_POWERSAVE policy 
 CPU			   run  turbo PXbus SDRAM 
  99,   99,   50,   50  
  99,  199,   50,   99  
  99,  287,   50,   99  
 199,  287,   99,   99  
 199,  398,   99,   99  
 Get the current policy 
	
	  Even if voltage setting fails, we don't report it, as the frequency
	  change succeeded. The voltage reduction is not a critical failure,
	  only power savings will suffer from this.
	 
	  Note: if the voltage change fails, and a return value is returned, a
	  bug is triggered (seems a deadlock). Should anybody find out where,
	  the "return 0" should become a "return ret".
 try to guess pxa27x cpu 
 set default policy and cpuinfo 
 FIXME: 1 ms, assumed 
 Generate pxa25x the run cpufreq_frequency_table struct 
 Generate pxa25x the turbo cpufreq_frequency_table struct 
 Generate the pxa27x cpufreq_frequency_table struct 
	
	  Set the policy's minimum and maximum frequencies from the tables
	  just constructed.  This sets cpuinfo.mxx_freq, min and max.
 SPDX-License-Identifier: GPL-2.0-only
  Copyright (c) 2009 Simtec Electronics
 	http:armlinux.simtec.co.uk
 	Ben Dooks <ben@simtec.co.uk>
  S3C24XX CPU Frequency scaling - debugfs status support
 SPDX-License-Identifier: GPL-2.0+
  CPU frequency scaling support for Armada 37xx platform.
  Copyright (C) 2017 Marvell
  Gregory CLEMENT <gregory.clement@free-electrons.com>
 Clk register set 
 Power management in North Bridge register set 
 AVS register set 
  On Armada 37xx the Power management manages 4 level of CPU load,
  each level can be associated with a CPU clock source, a CPU
  divider, a VDD level, etc...
  AVS value for the corresponding voltage (in mV) 
	
	  The cpufreq scaling for 1.2 GHz variant of the SOC is currently
	  unstable because we do not know how to configure it properly.
 {.cpu_freq_max = 120010001000, .divider = {1, 2, 4, 6} }, 
  Setup the four level managed by the hardware. Once the four level
  will be configured then the DVFS will be enabled.
 Determine to which TBG clock is CPU connected 
 Set cpu clock source, for all the level we use TBG 
 Set TBG index, for all levels we use the same TBG 
		
		  Set cpu divider based on the pre-computed array in
		  order to have balanced step.
 Set VDD divider which is actually the load level. 
  Find out the armada 37x supported AVS value whose voltage value is
  the round-up closest to the target voltage value.
 Find out the round-up closest supported voltage value 
	
	  If all supported voltages are smaller than target one,
	  choose the largest supported voltage
  For Armada 37xx soc, L0(VSET0) VDD AVS value is set to SVC revision
  value or a default value when SVC is not supported.
  - L0 can be read out from the register of AVS_CTRL_0 and L0 voltage
    can be got from the mapping table of avs_map.
  - L1 voltage should be about 100mv smaller than L0 voltage
  - L2 & L3 voltage should be about 150mv smaller than L0 voltage.
  This function calculates L1 & L2 & L3 AVS values dynamically based
  on L0 voltage and fill all AVS values to the AVS value table.
  When base CPU frequency is 1000 or 1200 MHz then there is additional
  minimal avs value for load L1.
 Get L0 VDD min value 
		
		  If L0 voltage is smaller than 1000mv, then all VDD sets
		  use L0 voltage;
		
		  Set the avs values for load L0 and L1 when base CPU frequency
		  is 10001200 MHz to its typical initial values according to
		  the Armada 3700 Hardware Specifications.
	
	  L1 voltage is equal to L0 voltage - 100mv and it must be
	  larger than 1000mv
	
	  L2 & L3 voltage is equal to L0 voltage - 150mv and it must
	  be larger than 1000mv
	
	  Fix the avs value for load L1 when base CPU frequency is 10001200 MHz,
	  otherwise the CPU gets stuck when switching from load L1 to load L0.
	  Also ensure that avs value for load L1 is not higher than for L0.
 Disable AVS before the configuration 
 Enable low voltage mode 
 Enable AVS after the configuration 
 Start with the highest load (0) 
 Now enable DVFS for the CPUs 
 Ensure DVFS is disabled otherwise the following registers are RO 
	
	  NB_DYN_MOD register is the one that actually enable back DVFS if it
	  was enabled before the suspend operation. This must be done last
	  otherwise other registers are not writable.
 if AVS is not present don't use it but still try to setup dvfs 
 Before doing any configuration on the DVFS first, disable it 
	
	  On CPU 0 register the operating points supported (which are
	  the nominal CPU frequency and full integer divisions of
	  it).
 Get parent CPU frequency 
 Now that everything is setup, enable the DVFS at hardware level 
 clean-up the already added opp before leaving 
 late_initcall, to guarantee the driver is loaded after A37xx clock driver 
  CPUFreq support for Armada 370XP platforms.
  Copyright (C) 2012-2016 Marvell
  Yehuda Yitschak <yehuday@marvell.com>
  Gregory Clement <gregory.clement@free-electrons.com>
  Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  This file is licensed under the terms of the GNU General Public
  License version 2.  This program is licensed "as is" without any
  warranty of any kind, whether express or implied.
	
	  In order to have proper cpufreq handling, we need to ensure
	  that the Device Tree description of the CPU clock includes
	  the definition of the PMU DFS registers. If not, we do not
	  register the clock notifier and the cpufreq driver. This
	  piece of code is only for compatibility with old Device
	  Trees.
	
	  For each CPU, this loop registers the operating points
	  supported (which are the nominal CPU frequency and half of
	  it), and registers the clock notifier that will take care
	  of doing the PMSU part of a frequency transition.
 SPDX-License-Identifier: GPL-2.0-only
   linuxdriverscpufreqcpufreq.c
   Copyright (C) 2001 Russell King
             (C) 2002 - 2003 Dominik Brodowski <linux@brodo.de>
             (C) 2013 Viresh Kumar <viresh.kumar@linaro.org>
   Oct 2005 - Ashok Raj <ashok.raj@intel.com>
 	Added handling for CPU hotplug
   Feb 2006 - Jacob Shin <jacob.shin@amd.com>
 	Fix handling for CPU hotplug -- affected CPUs
 Macros to iterate over CPU policies 
 Iterate over governors 
  The "cpufreq driver" - the arch- or hardware-dependent low
  level driver of CPUFreq support, and its spinlock. This lock
  also protects the cpufreq_cpu_data array.
 Flag to suspendresume CPUFreq governors 
 internal prototypes 
  Two notifier lists: the "policy" list is involved in the
  validation process for a new CPU frequency policy; the
  "transition" list for kernel code that needs to handle
  changes to devices when the CPU clock speed changes.
  The mutex locks both lists.
  This is a generic cpufreq init() routine which can be used by cpufreq
  drivers of SMP systems. It will do following:
  - validate & show freq table passed
  - set policies transition latency
  - policy->cpus with all possible CPUs
	
	  The driver only supports the SMP configuration where all processors
	  share the clock and voltage and clock.
  cpufreq_cpu_get - Return policy for a CPU and mark it as busy.
  @cpu: CPU to find the policy for.
  Call cpufreq_cpu_get_raw() to obtain a cpufreq policy for @cpu and increment
  the kobject reference counter of that policy.  Return a valid policy on
  success or NULL on failure.
  The policy returned by this function has to be released with the help of
  cpufreq_cpu_put() to balance its kobject reference counter properly.
 get the cpufreq driver 
 get the CPU 
  cpufreq_cpu_put - Decrement kobject usage counter for cpufreq policy.
  @policy: cpufreq policy returned by cpufreq_cpu_get().
  cpufreq_cpu_release - Unlock a policy and decrement its usage counter.
  @policy: cpufreq policy returned by cpufreq_cpu_acquire().
  cpufreq_cpu_acquire - Find policy for a CPU, mark it as busy and lock it.
  @cpu: CPU to find the policy for.
  Call cpufreq_cpu_get() to get a reference on the cpufreq policy for @cpu and
  if the policy returned by it is not NULL, acquire its rwsem for writing.
  Return the policy if it is active or release it and return NULL otherwise.
  The policy returned by this function has to be released with the help of
  cpufreq_cpu_release() in order to release its rwsem and balance its usage
  counter properly.
             EXTERNALLY AFFECTING FREQUENCY CHANGES                 
  adjust_jiffies - Adjust the system "loops_per_jiffy".
  @val: CPUFREQ_PRECHANGE or CPUFREQ_POSTCHANGE.
  @ci: Frequency change information.
  This function alters the system "loops_per_jiffy" for the clock
  speed change. Note that loops_per_jiffy cannot be updated on SMP
  systems as each CPU might be scaled differently. So, use the arch
  per-CPU loops_per_jiffy value wherever possible.
  cpufreq_notify_transition - Notify frequency transition and adjust jiffies.
  @policy: cpufreq policy to enable fast frequency switching for.
  @freqs: contain details of the frequency update.
  @state: set to CPUFREQ_PRECHANGE or CPUFREQ_POSTCHANGE.
  This function calls the transition notifiers and adjust_jiffies().
  It is called twice on all CPU frequency changes that have external effects.
		
		  Detect if the driver reported a value as "old frequency"
		  which is not equal to what the cpufreq core thinks is
		  "old frequency".
 Do post notifications when there are chances that transition has failed 
	
	  Catch double invocations of _begin() which lead to self-deadlock.
	  ASYNC_NOTIFICATION drivers are left out because the cpufreq core
	  doesn't invoke _begin() on their behalf, and hence the chances of
	  double invocations are very low. Moreover, there are scenarios
	  where these checks can emit false-positive warnings in these
	  drivers; so we avoid that by skipping them altogether.
  Fast frequency switching status count.  Positive means "enabled", negative
  means "disabled" and 0 means "not decided yet".
  cpufreq_enable_fast_switch - Enable fast frequency switching for policy.
  @policy: cpufreq policy to enable fast frequency switching for.
  Try to enable fast frequency switching for @policy.
  The attempt will fail if there is at least one transition notifier registered
  at this point, as fast frequency switching is quite fundamentally at odds
  with transition notifiers.  Thus if successful, it will make registration of
  transition notifiers fail going forward.
  cpufreq_disable_fast_switch - Disable fast frequency switching for policy.
  @policy: cpufreq policy to disable fast frequency switching for.
  cpufreq_driver_resolve_freq - Map a target frequency to a driver-supported
  one.
  @policy: associated policy to interrogate
  @target_freq: target frequency to resolve.
  The target to driver frequency mapping is cached in the policy.
  Return: Lowest driver-supported frequency greater than or equal to the
  given target_freq, subject to policy (minmax) and driver limitations.
		
		  For platforms that can change the frequency very fast (< 10
		  us), the above formula gives a decent transition delay. But
		  for platforms where transition_latency is in milliseconds, it
		  ends up giving unrealistic values.
		 
		  Cap the default transition delay to 10 ms, which seems to be
		  a reasonable amount of time after which we should reevaluate
		  the frequency.
                           SYSFS INTERFACE                          
  cpufreq_parse_governor - parse a governor string only for has_target()
  @str_governor: Governor name.
  cpufreq_per_cpu_attr_read()  show_##file_name() -
  print out cpufreq information
  Write out information from cpufreq_driver->policy[cpu]; object must be
  "unsigned int".
  cpufreq_per_cpu_attr_write()  store_##file_name() - sysfs write access
  show_cpuinfo_cur_freq - current CPU frequency as detected by hardware
  show_scaling_governor - show the current policy for the specified CPU
  store_scaling_governor - store policy for the specified CPU
  show_scaling_driver - show the cpufreq driver currently loaded
  show_scaling_available_governors - show the available CPUfreq governors
  show_related_cpus - show the CPUs affected by each transition even if
  hw coordination is in use
  show_affected_cpus - show the CPUs affected by each transition
  show_bios_limit - show the current cpufreq HWBIOS limitation
	
	  cpus_read_trylock() is used here to work around a circular lock
	  dependency problem with respect to the cpufreq_register_driver().
 set up files for this cpu device 
 Update policy governor to the one used before hotplug. 
 Use the default policy if there is no last_policy. 
			
			  In case the default governor is neither "performance"
			  nor "powersave", fall back to the initial policy
			  value set by the driver.
 Has this CPU been taken care of already? 
	
	  We need to make sure that the underlying kobj is
	  actually not referenced anymore by anybody before we
	  proceed with unloading.
		
		  The entire policy object will be freed below, but the extra
		  memory allocated for the kobject name needs to be freed by
		  releasing the kobject.
 Remove policy from list 
 Cancel any pending policy->update work before freeing the policy. 
		
		  CPUFREQ_CREATE_POLICY notification is sent only after
		  successfully adding max_freq_req request.
 Check if this CPU already has a policy to manage it 
 This is the only online CPU for the policy.  Start over. 
 Recover policy->cpus using related_cpus 
		
		  Call driver. From then on the cpufreq must be able
		  to accept all calls to ->verify and ->setpolicy for this CPU.
		
		  The initialization has succeeded and the policy is online.
		  If there is a problem with its frequency table, take it
		  offline and drop it.
 related_cpus should at least include policy->cpus. 
	
	  affected cpus must always be the one, which are online. We aren't
	  managing offline cpus here.
			
			  So we don't call freq_qos_remove_request() for an
			  uninitialized request.
		
		  This must be initialized right here to avoid calling
		  freq_qos_remove_request() on uninitialized request in case
		  of errors.
	
	  Sometimes boot loaders set CPU frequency to a value outside of
	  frequency table present with cpufreq core. In such cases CPU might be
	  unstable if it has to run on that frequency for long duration of time
	  and so its better to set it to a frequency which is specified in
	  freq-table. This also makes cpufreq stats inconsistent as
	  cpufreq-stats would fail to register because current frequency of CPU
	  isn't found in freq-table.
	 
	  Because we don't want this change to effect boot process badly, we go
	  for the next freq which is >= policy->cur ('cur' must be set by now,
	  otherwise we will end up setting freq to lowest of the table as 'cur'
	  is initialized to zero).
	 
	  We are passing target-freq as "policy->cur - 1" otherwise
	  __cpufreq_driver_target() would simply fail, as policy->cur will be
	  equal to target-freq.
 Are we running at unknown frequency ? 
			
			  Reaching here after boot in a few seconds may not
			  mean that system will remain stable at "unknown"
			  frequency for longer duration. Hence, a BUG_ON().
		
		  Register with the energy model before
		  sched_cpufreq_governor_change() is called, which will result
		  in rebuilding of the sched domains, which should only be done
		  once the energy model is properly initialized for the policy
		  first.
		 
		  Also, this should be called before the policy is registered
		  with cooling framework.
  cpufreq_add_dev - the cpufreq interface for a CPU device.
  @dev: CPU device.
  @sif: Subsystem interface structure pointer (not used)
 Create sysfs link on CPU registration 
 Nominate new CPU 
 Start governor again for active policy 
	
	  Perform the ->offline() during light-weight tear-down, as
	  that allows fast recovery when the CPU comes back.
  cpufreq_remove_dev - remove a CPU device
  Removes the cpufreq interface for a CPU device.
 We did light-weight exit earlier, do full tear down now 
  cpufreq_out_of_sync - Fix up actual and saved CPU frequency difference.
  @policy: Policy managing CPUs.
  @new_freq: New CPU frequency.
  Adjust to the current frequency first and clean up later by either calling
  cpufreq_update_policy(), or scheduling handle_update().
	
	  If fast frequency switching is used with the given policy, the check
	  against policy->cur is pointless, so skip it in that case.
  cpufreq_quick_get - get the CPU frequency (in kHz) from policy->cur
  @cpu: CPU number
  This is the last known freq, without actually getting it from the driver.
  Return value will be same as what is shown in scaling_cur_freq in sysfs.
  cpufreq_quick_get_max - get the max reported CPU frequency for this CPU
  @cpu: CPU number
  Just return the max possible frequency for a given CPU.
  cpufreq_get_hw_max_freq - get the max hardware frequency of the CPU
  @cpu: CPU number
  The default return value is the max_freq field of cpuinfo.
  cpufreq_get - get the current CPU frequency (in kHz)
  @cpu: CPU number
  Get the CPU current (static) CPU frequency
  In case platform wants some specific frequency to be configured
  during suspend..
  cpufreq_suspend() - Suspend CPUFreq governors.
  Called during system wide SuspendHibernate cycles for suspending governors
  as some platforms can't change frequency after this point in suspend cycle.
  Because some of the devices (like: i2c, regulators, etc) they use for
  changing frequency are suspended quickly after this point.
  cpufreq_resume() - Resume CPUFreq governors.
  Called during system wide SuspendHibernate cycle for resuming governors that
  are suspended with cpufreq_suspend().
  cpufreq_driver_test_flags - Test cpufreq driver's flags against given ones.
  @flags: Flags to test against the current cpufreq driver's flags.
  Assumes that the driver is there, so callers must ensure that this is the
  case.
  cpufreq_get_current_driver - Return the current driver's name.
  Return the name string of the currently registered cpufreq driver or NULL if
  none.
  cpufreq_get_driver_data - Return current driver data.
  Return the private data of the currently registered cpufreq driver, or NULL
  if no cpufreq driver has been registered.
                      NOTIFIER LISTS INTERFACE                      
  cpufreq_register_notifier - Register a notifier with cpufreq.
  @nb: notifier function to register.
  @list: CPUFREQ_TRANSITION_NOTIFIER or CPUFREQ_POLICY_NOTIFIER.
  Add a notifier to one of two lists: either a list of notifiers that run on
  clock rate changes (once before and once after every transition), or a list
  of notifiers that ron on cpufreq policy changes.
  This function may sleep and it has the same return values as
  blocking_notifier_chain_register().
  cpufreq_unregister_notifier - Unregister a notifier from cpufreq.
  @nb: notifier block to be unregistered.
  @list: CPUFREQ_TRANSITION_NOTIFIER or CPUFREQ_POLICY_NOTIFIER.
  Remove a notifier from one of the cpufreq notifier lists.
  This function may sleep and it has the same return values as
  blocking_notifier_chain_unregister().
                               GOVERNORS                            
  cpufreq_driver_fast_switch - Carry out a fast CPU frequency switch.
  @policy: cpufreq policy to switch the frequency for.
  @target_freq: New frequency to set (may be approximate).
  Carry out a fast frequency switch without sleeping.
  The driver's ->fast_switch() callback invoked by this function must be
  suitable for being called from within RCU-sched read-side critical sections
  and it is expected to select the minimum available frequency greater than or
  equal to @target_freq (CPUFREQ_RELATION_L).
  This function must not be called if policy->fast_switch_enabled is unset.
  Governors calling this function must guarantee that it will never be invoked
  twice in parallel for the same policy and that it will never be called in
  parallel with either ->target() or ->target_index() for the same policy.
  Returns the actual frequency set for the CPU.
  If 0 is returned by the driver's ->fast_switch() callback to indicate an
  error condition, the hardware configuration must be preserved.
  cpufreq_driver_adjust_perf - Adjust CPU performance level in one go.
  @cpu: Target CPU.
  @min_perf: Minimum (required) performance level (units of @capacity).
  @target_perf: Target (desired) performance level (units of @capacity).
  @capacity: Capacity of the target CPU.
  Carry out a fast performance level switch of @cpu without sleeping.
  The driver's ->adjust_perf() callback invoked by this function must be
  suitable for being called from within RCU-sched read-side critical sections
  and it is expected to select a suitable performance level equal to or above
  @min_perf and preferably equal to or below @target_perf.
  This function must not be called if policy->fast_switch_enabled is unset.
  Governors calling this function must guarantee that it will never be invoked
  twice in parallel for the same CPU and that it will never be called in
  parallel with either ->target() or ->target_index() or ->fast_switch() for
  the same CPU.
  cpufreq_driver_has_adjust_perf - Check "direct fast switch" callback.
  Return 'true' if the ->adjust_perf callback is present for the
  current driver or 'false' otherwise.
 Must set freqs->new to intermediate frequency 
 We don't need to switch to intermediate freq 
 Save last value to restore later on errors 
 Handle switching to intermediate frequency 
 Set old freq to intermediate 
		
		  Failed after setting to intermediate freq? Driver should have
		  reverted back to initial frequency and so should we. Check
		  here for intermediate_freq instead of get_intermediate, in
		  case we haven't switched to intermediate freq at all.
	
	  This might look like a redundant call as we are checking it again
	  after finding index. But it is left intentionally for cases where
	  exactly same freq is called again and so we can save on few function
	  calls.
		
		  If the driver hasn't setup a single inefficient frequency,
		  it's unlikely it knows how to decode CPUFREQ_RELATION_E.
 Don't start any governor operations if we are entering suspend 
	
	  Governor might not be initiated here if ACPI _PPC changed
	  notification happened, so check it.
 Platform doesn't want dynamic frequency switching ? 
 clear last_governor for all inactive policies 
                           POLICY INTERFACE                         
  cpufreq_get_policy - get the current cpufreq_policy
  @policy: struct cpufreq_policy into which the current cpufreq_policy
 	is written
  @cpu: CPU to find the policy for
  Reads the current cpufreq policy.
  cpufreq_set_policy - Modify cpufreq policy parameters.
  @policy: Policy object to modify.
  @new_gov: Policy governor pointer.
  @new_pol: Policy value (for drivers with built-in governors).
  Invoke the cpufreq driver's ->verify() callback to sanity-check the frequency
  limits to be set for the policy, update @policy with the verified limits
  values and either invoke the driver's ->setpolicy() callback (if present) or
  carry out a governor update for @policy.  That is, run the current governor's
  ->limits() callback (if @new_gov points to the same object as the one in
  @policy) or replace the governor for @policy with @new_gov.
  The cpuinfo part of @policy is not updated by this function.
	
	  PM QoS framework collects all the requests from users and provide us
	  the final aggregated value here.
	
	  Verify that the CPU speed can be set within these limits and make sure
	  that min <= max.
	
	  Resolve policy minmax to available frequencies. It ensures
	  no frequency resolution will neither overshoot the requested maximum
	  nor undershoot the requested minimum.
 save old, working values 
 end old governor 
 start new governor 
 new governor failed, so re-start old one 
  cpufreq_update_policy - Re-evaluate an existing cpufreq policy.
  @cpu: CPU to re-evaluate the policy for.
  Update the current frequency for the cpufreq policy of @cpu and use
  cpufreq_set_policy() to re-apply the min and max limits, which triggers the
  evaluation of policy notifiers and the cpufreq driver's ->verify() callback
  for the policy in question, among other things.
	
	  BIOS might change freq behind our back
	  -> ask driver for current freq and notify governors about a change
  cpufreq_update_limits - Update policy limits for a given CPU.
  @cpu: CPU to update the policy limits for.
  Invoke the driver's ->update_limits callback if present or call
  cpufreq_update_policy() for @cpu.
                BOOST						     
 This will get removed on driver unregister 
                REGISTER  UNREGISTER CPUFREQ DRIVER                
  cpufreq_register_driver - register a CPU Frequency driver
  @driver_data: A struct cpufreq_driver containing the values#
  submitted by the CPU Frequency driver.
  Registers a CPU Frequency driver to this core code. This code
  returns zero on success, -EEXIST when another driver got here first
  (and isn't unregistered in the meantime).
	
	  The cpufreq core depends heavily on the availability of device
	  structure, make sure they are available before proceeding further.
 Protect against concurrent CPU onlineoffline. 
	
	  Mark support for the scheduler's frequency invariance engine for
	  drivers that implement target(), target_index() or fast_switch().
 if all ->init() calls failed, unregister 
  cpufreq_unregister_driver - unregister the current CPUFreq driver
  Unregister the current CPUFreq driver. Only call this if you have
  the right to do so, i.e. if you have succeeded in initialising before!
  Returns zero if successful, and -EINVAL if the cpufreq_driver is
  currently not initialised.
 Protect against concurrent cpu hotplug 
 SPDX-License-Identifier: GPL-2.0
  Copyright 2019 NXP
 cpufreq-dt device registered by imx-cpufreq-dt 
	
	  Early samples without fuses written report "0 0" which may NOT
	  match any OPP defined in DT. So clamp to minimum OPP defined in
	  DT to avoid warning for "no OPPs".
	 
	  Applies to i.MX8M series SoCs.
  System Control and Power Interface (SCPI) based CPUFreq Interface driver
  Copyright (C) 2015 ARM Ltd.
  Sudeep Holla <sudeep.holla@arm.com>
  This program is free software; you can redistribute it andor modify
  it under the terms of the GNU General Public License version 2 as
  published by the Free Software Foundation.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.
 scpi allows DVFS request for any domain from any CPU 
 SPDX-License-Identifier: GPL-2.0-only
  intel_pstate.c: Native P state management for Intel processors
  (C) Copyright 2012 Intel Corporation
  Author: Dirk Brandewie <dirk.j.brandewie@intel.com>
  struct sample -	Store performance sample
  @core_avg_perf:	Ratio of APERFMPERF which is the actual average
 			performance during last sample period
  @busy_scaled:	Scaled busy value which is used to calculate next
 			P state. This can be different than core_avg_perf
 			to account for cpu idle period
  @aperf:		Difference of actual performance frequency clock count
 			read from APERF MSR between last and current sample
  @mperf:		Difference of maximum performance frequency clock count
 			read from MPERF MSR between last and current sample
  @tsc:		Difference of time stamp counter between last and
 			current sample
  @time:		Current time from scheduler
  This structure is used in the cpudata structure to store performance sample
  data for choosing next P State.
  struct pstate_data - Store P state data
  @current_pstate:	Current requested P state
  @min_pstate:		Min P state possible for this platform
  @max_pstate:		Max P state possible for this platform
  @max_pstate_physical:This is physical Max P state for a processor
 			This can be higher than the max_pstate which can
 			be limited by platform thermal design power limits
  @perf_ctl_scaling:	PERF_CTL P-state to frequency scaling factor
  @scaling:		Scaling factor between performance and frequency
  @turbo_pstate:	Max Turbo P state possible for this platform
  @min_freq:		@min_pstate frequency in cpufreq units
  @max_freq:		@max_pstate frequency in cpufreq units
  @turbo_freq:		@turbo_pstate frequency in cpufreq units
  Stores the per cpu model P state limits and current P state.
  struct vid_data -	Stores voltage information data
  @min:		VID data for this platform corresponding to
 			the lowest P state
  @max:		VID data corresponding to the highest P State.
  @turbo:		VID data for turbo P state
  @ratio:		Ratio of (vid max - vid min) 
 			(max P state - Min P State)
  Stores the voltage data for DVFS (Dynamic Voltage and Frequency Scaling)
  This data is used in Atom platforms, where in addition to target P state,
  the voltage data needs to be specified to select next P State.
  struct global_params - Global parameters, mostly tunable via sysfs.
  @no_turbo:		Whether or not to use turbo P-states.
  @turbo_disabled:	Whether or not turbo P-states are available at all,
 			based on the MSR_IA32_MISC_ENABLE value and whether or
 			not the maximum reported turbo P-state is different from
 			the maximum reported non-turbo one.
  @turbo_disabled_mf:	The @turbo_disabled value reflected by cpuinfo.max_freq.
  @min_perf_pct:	Minimum capacity limit in percent of the maximum turbo
 			P-state capacity.
  @max_perf_pct:	Maximum capacity limit in percent of the maximum turbo
 			P-state capacity.
  struct cpudata -	Per CPU instance data storage
  @cpu:		CPU number for this instance data
  @policy:		CPUFreq policy value
  @update_util:	CPUFreq utility callback information
  @update_util_set:	CPUFreq utility callback is set
  @iowait_boost:	iowait-related boost fraction
  @last_update:	Time of the last update.
  @pstate:		Stores P state limits for this CPU
  @vid:		Stores VID limits for this CPU
  @last_sample_time:	Last Sample time
  @aperf_mperf_shift:	APERF vs MPERF counting frequency difference
  @prev_aperf:		Last APERF value read from APERF MSR
  @prev_mperf:		Last MPERF value read from MPERF MSR
  @prev_tsc:		Last timestamp counter (TSC) value
  @prev_cummulative_iowait: IO Wait time difference from last and
 			current sample
  @sample:		Storage for storing last Sample data
  @min_perf_ratio:	Minimum capacity in terms of PERF or HWP ratios
  @max_perf_ratio:	Maximum capacity in terms of PERF or HWP ratios
  @acpi_perf_data:	Stores ACPI perf information read from _PSS
  @valid_pss_table:	Set to true for valid ACPI _PSS entries found
  @epp_powersave:	Last saved HWP energy performance preference
 			(EPP) or energy performance bias (EPB),
 			when policy switched to performance
  @epp_policy:		Last saved policy used to set EPPEPB
  @epp_default:	Power on default HWP energy performance
 			preferencebias
  @epp_cached		Cached HWP energy-performance preference value
  @hwp_req_cached:	Cached value of the last HWP Request MSR
  @hwp_cap_cached:	Cached value of the last HWP Capabilities MSR
  @last_io_update:	Last time when IO wake flag was set
  @sched_flags:	Store scheduler flags for possible cross CPU update
  @hwp_boost_min:	Last HWP boosted min performance
  @suspended:		Whether or not the driver has been suspended.
  @hwp_notify_work:	workqueue for HWP notifications.
  This structure stores per CPU instance data for all CPUs.
  struct pstate_funcs - Per CPU model specific callbacks
  @get_max:		Callback to get maximum non turbo effective P state
  @get_max_physical:	Callback to get maximum non turbo physical P state
  @get_min:		Callback to get minimum P state
  @get_turbo:		Callback to get turbo P state
  @get_scaling:	Callback to get frequency scaling factor
  @get_cpu_scaling:	Get frequency scaling factor for a given cpu
  @get_aperf_mperf_shift: Callback to get the APERF vs MPERF frequency difference
  @get_val:		Callback to convert P state to actual MSR write value
  @get_vid:		Callback to get VID data for Atom platforms
  Core and Atom CPU models have different way to get P State limits. This
  structure is used to store those callbacks.
 The work item is needed to avoid CPU hotplug locking issues 
	
	  The priorities can be set regardless of whether or not
	  sched_set_itmt_support(true) has been called and it is valid to
	  update them at any time after it has been called.
			
			  This code can be run during CPU online under the
			  CPU hotplug locks, so sched_set_itmt_support()
			  cannot be called from here.  Queue up a work item
			  to invoke it.
 CONFIG_ACPI_CPPC_LIB 
 CONFIG_ACPI_CPPC_LIB 
	
	  Check if the control value in _PSS is for PERF_CTL MSR, which should
	  guarantee that the states returned by it map to the states in our
	  list directly.
	
	  If there is only one entry _PSS, simply ignore _PSS and continue as
	  usual without taking _PSS into account
	
	  The _PSS table doesn't contain whole turbo frequency range.
	  This just contains +1 MHZ above the max non turbo frequency,
	  with control value corresponding to max turbo ratio. But
	  when cpufreq set policy is called, it will call with this
	  max frequency, which will cause a reduced performance as
	  this driver uses real max turbo frequency as the max
	  frequency. So correct this frequency in _PSS table to
	  correct max turbo frequency based on the turbo state.
	  Also need to convert to MHz as _PSS freq is in MHz.
 CONFIG_ACPI 
 CONFIG_ACPI 
 CONFIG_ACPI_CPPC_LIB 
  intel_pstate_hybrid_hwp_adjust - Calibrate HWP performance levels.
  @cpu: Target CPU.
  On hybrid processors, HWP may expose more performance levels than there are
  P-states accessible through the PERF_CTL interface.  If that happens, the
  scaling factor between HWP performance levels and CPU frequency will be less
  than the scaling factor between P-state values and CPU frequency.
  In that case, adjust the CPU parameters used in computations accordingly.
	
	  If the product of the HWP performance scaling factor and the HWP_CAP
	  highest performance is greater than the maximum turbo frequency
	  corresponding to the pstate_funcs.get_turbo() return value, the
	  scaling factor is too high, so recompute it to make the HWP_CAP
	  highest performance correspond to the maximum turbo frequency.
	
	  Cast the min P-state value retrieved via pstate_funcs.get_min() to
	  the effective range of HWP performance levels.
		
		  When hwp_req_data is 0, means that caller didn't read
		  MSR_HWP_REQUEST, so need to read and get EPP.
 When there is no EPP present, HWP uses EPB settings 
  EPPEPB display strings corresponding to EPP index in the
  energy_perf_strings[]
 	index		String
 -------------------------------------
 	0		default
 	1		performance
 	2		balance_performance
 	3		balance_power
 	4		power
		
		  Range:
		 	0x00-0x03	:	Performance
		 	0x04-0x07	:	Balance performance
		 	0x08-0x0B	:	Balance power
		 	0x0C-0x0F	:	Power
		  The EPB is a 4 bit value, but our ranges restrict the
		  value which can be set. Here only using top two bits
		  effectively.
	
	  Use the cached HWP Request MSR value, because in the active mode the
	  register itself may be updated by intel_pstate_hwp_boost_up() or
	  intel_pstate_hwp_boost_down() at any time.
	
	  The only other updater of hwp_req_cached in the active mode,
	  intel_pstate_hwp_set(), is called under the same lock as this
	  function, so it cannot run in parallel with the update below.
		
		  To avoid confusion, refuse to set EPP to any values different
		  from 0 (performance) if the current policy is "performance",
		  because those values would be overridden.
	
	  This function runs with the policy RW semaphore held, which
	  guarantees that the driver pointer will not change while it is
	  running.
		
		  In the passive mode the governor needs to be stopped on the
		  target CPU before the EPP update and restarted after it,
		  which is super-heavy-weight, so make sure it is worth doing
		  upfront.
 If EPP read was failed, then don't try to write 
 skip setting EPP, when saved value is invalid 
		
		  No need to restore EPP when it is not zero. This
		  means:
		   - Policy is not changed
		   - user has manually changed
		   - Error reading EPB
		
		  In case the EPP has been set to "performance" by the
		  active mode "performance" scaling algorithm, replace that
		  temporary value with the cached EPP one.
	
	  Clear the desired perf field in the cached HWP request value to
	  prevent nonzero desired values from being leaked into the active
	  mode.
 Set hwp_max = hwp_min 
 Set EPP to min 
 disable HWP interrupt and cancel any pending work 
 Only restore if the system default is changed 
 Re-enable HWP, because "online" has not done that. 
	
	  If turbo has been turned on or off globally, policy limits for
	  all CPUs need to be updated to reflect that.
 sysfs begin 
 Squash the global minimum into the permitted range. 
	
	  If per cpu limits are enforced there are no global limits, so
	  return without creating maxmin_perf_pct attributes
 sysfs end 
	
	  Currently we never free all_cpu_data. And we can't reach here
	  without this allocated. But for safety for future changes, added
	  check.
	
	  The free is done during cleanup, when cpufreq registry is failed.
	  We wouldn't be here if it fails on init or switch status. But for
	  future changes, added check.
 wrmsrl_on_cpu has to be outside spinlock as this can result in IPC 
 Enable HWP notification interrupt for guaranteed performance change 
 wrmsrl_on_cpu has to be outside spinlock as this can result in IPC 
 First disable HWP notification interrupt till we activate again 
 Defined in Table 35-6 from SDM (Sept 2015) 
 Defined in Table 35-10 from SDM (Sept 2015) 
 Check how many TDP levels present 
 Get the TDP level (0, 1, 2) to get ratios 
 TDP MSR are continuous starting at 0x648 
 For level 1 and 2, bits[23:16] contain the ratio 
 ratios are only 8 bits long 
 Turbo activation ratio is not used on HWP platforms 
 Do some sanity checking for safety 
 CONFIG_ACPI_CPPC_LIB 
	
	  Generally, there is no guarantee that this code will always run on
	  the CPU being updated, so force the register update to run on the
	  right CPU.
  Long hold time will keep high perf limits for long time,
  which negatively impacts perfwatt for some workloads,
  like specpower. 3ms is based on experiements on some
  workoads.
	
	  Cases to consider (User changes via sysfs or boot time):
	  If, P0 (Turbo max) = P1 (Guaranteed max) = min:
	 	No boost, return.
	  If, P0 (Turbo max) > P1 (Guaranteed max) = min:
	      Should result in one level boost only for P0.
	  If, P0 (Turbo max) = P1 (Guaranteed max) > min:
	      Should result in two level boost:
	          (min + p1)2 and P1.
	  If, P0 (Turbo max) > P1 (Guaranteed max) > min:
	      Should result in three level boost:
	         (min + p1)2, P1 and P0.
 If max and min are equal or already at max, nothing to boost 
 level at half way mark between min and guranteed 
 Check if we are idle for hold time to boost down 
		
		  Set iowait_boost flag and update time. Since IO WAIT flag
		  is set all the time, we can't just conclude that there is
		  some IO bound activity is scheduled on this CPU with just
		  one occurrence. If we receive at least two in two
		  consecutive ticks, then we treat as boost candidate.
	
	  First time this function is invoked in a given cycle, all of the
	  previous sample data fields are equal to zero or stale and they must
	  be populated with meaningful numbers for things to work, so assume
	  that sample.time will always be reset before setting the utilization
	  update hook and make the caller skip the sample then.
	
	  If the average P-state during the previous cycle was higher than the
	  current target, add 50% of the difference to the target to reduce
	  possible performance oscillations and offset possible performance
	  loss related to moving the workload from one CPU to another within
	  a packagemodule.
 Don't allow remote callbacks 
 Start over if the CPU may have been idle. 
 Clear iowait_boost if the CPU may have been idle. 
		
		  Re-enable HWP in case this happens after a resume from ACPI
		  S3 if the CPU was offline during the whole systemresume
		  cycle.
 Prevent intel_pstate_update_util() from using stale data. 
	
	  HWP needs some special consideration, because HWP_REQUEST uses
	  abstract values to represent performance rather than pure ratios.
 Normalize user input to [min_perf, max_perf] 
 Global limits are in percent of the maximum turbo P-state. 
 Make sure min_perf <= max_perf 
		
		  NOHZ_FULL CPUs need this as the governor callback may not
		  be invoked on them.
		
		  When hwp_boost was active before and dynamically it
		  was turned off, in that case we need to clear the
		  update util hook.
	
	  If the CPU is an SMT thread and it goes offline with the performance
	  settings different from the minimum, it will prevent its sibling
	  from getting to lower performance levels, so force the minimum
	  performance on CPU offline to prevent that from happening.
		
		  Re-enable HWP and clear the "suspended" flag to let "resume"
		  know that it need not do that.
 cpuinfo and default policy values 
	
	  Set the policy to powersave to provide a valid fallback value in case
	  the default cpufreq governor is neither powersave nor performance.
 Use of trace in passive mode:
  In passive mode the trace core_busy field (also known as the
  performance field, and lablelled as such on the graphs; also known as
  core_avg_perf) is not needed and so is re-assigned to indicate if the
  driver call was via the normal or fast switch path. Various graphs
  output from the intel_pstate_tracer.py utility that include core_busy
  (or performance or core_avg_perf) have a fixed y-axis from 0 to 100%,
  so we use 10 to indicate the normal path through the driver, and
  90 to indicate the fast switch path through the driver.
  The scaled_busy field is not used, and is set to 0.
 Optimization: Avoid unnecessary divisions. 
 This reflects the intel_pstate_get_cpu_pstates() setting. 
		
		  Clear the desired perf field in MSR_HWP_REQUEST in case
		  intel_cpufreq_adjust_perf() is in use and the last value
		  written by it may not be suitable.
 Hardware vendor-specific info that has its own power management modes 
 End 
	
	  It may be unsafe to request P-states control from SMM if _PPC support
	  has not been enabled.
 CONFIG_ACPI not enabled 
 CONFIG_ACPI 
		
		  Avoid enabling HWP for processors without EPP support,
		  because that means incomplete HWP implementation which is a
		  corner case and supporting it is generally problematic.
		 
		  If HWP is enabled already, though, there is no choice but to
		  deal with it.
 Without HWP start in the passive mode. 
	
	  The Intel pstate driver will be ignored if the platform
	  firmware has its own power management modes.
 SPDX-License-Identifier: GPL-2.0-or-later
  cpufreq driver for the cell processor
  (C) Copyright IBM Deutschland Entwicklung GmbH 2005-2007
  Author: Christian Krafft <krafft@de.ibm.com>
 the CBE supports an 8 step frequency scaling 
  hardware specific functions
  cpufreq functions
	
	  Let's check we can actually get to the CELL regs
 we need the freq in kHz 
 initialize frequency table 
	 if DEBUG is enabled set_pmode() measures the latency
  module init and destoy
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2013 Freescale Semiconductor, Inc.
  CPU Frequency Scaling driver for Freescale QorIQ SoCs.
  struct cpu_data
  @pclk: the parent clock of cpu
  @table: frequency table
  struct soc_data - SoC specific data
  @flags: SOC_xxx
 get platform freq by searching bus-frequency property 
 get platform freq by its clock name 
 traverse cpu nodes to get cpu mask of sharing clock wire 
 reduce the duplicated frequencies in frequency table 
 sort the frequencies in frequency table in descenting order 
 exchange the frequencies 
 update ->cpus if we have cluster, no harm if not 
 Minimum transition latency is 12 platform clocks 
 e6500 cannot use cpufreq due to erratum A-008083 
 SPDX-License-Identifier: GPL-2.0-only
   linuxdriverscpufreqcpufreq_userspace.c
   Copyright (C)  2001 Russell King
             (C)  2002 - 2004 Dominik Brodowski <linux@brodo.de>
  cpufreq_set - set the CPU frequency
  @policy: pointer to policy struct where freq is being set
  @freq: target frequency in kHz
  Sets the CPU frequency to freq.
 SPDX-License-Identifier: GPL-2.0-only
  (C) 2001  Dave Jones, Arjan van de ven.
  (C) 2002 - 2003  Dominik Brodowski <linux@brodo.de>
   Based upon reverse engineered information, and on Intel documentation
   for chipsets ICH2-M and ICH3-M.
   Many thanks to Ducrot Bruno for finding and fixing the last
   "missing link" for ICH2-MICH3-M support, and to Thomas Winkler
   for extensive testing.
   BIG FAT DISCLAIMER: Work in progress code. Possibly dangerous
                         SPEEDSTEP - DEFINITIONS                    
 speedstep_chipset:
    It is necessary to know which chipset is used. As accesses to
  this device occur at various places in this module, we need a
  static struct pci_dev  pointing to that device.
 speedstep_processor
    There are only two frequency states for each processor. Values
  are in kHz for the time being.
  speedstep_find_register - read the PMBASE address
  Returns: -ENODEV if no register could be found
 get PMBASE 
  speedstep_set_state - set the SpeedStep state
  @state: new processor frequency state (SPEEDSTEP_LOW or SPEEDSTEP_HIGH)
    Tries to change the SpeedStep state.  Can be called from
    smp_call_function_single.
 Disable IRQs 
 read state 
 write new state 
 Disable bus master arbitration 
 Actual transition 
 Restore bus master arbitration 
 check if transition was successful 
 Enable IRQs 
 Wrapper for smp_call_function_single. 
  speedstep_activate - activate SpeedStep control in the chipset
    Tries to activate the SpeedStep status and control registers.
  Returns -EINVAL on an unsupported chipset, and zero on success.
  speedstep_detect_chipset - detect the Southbridge which contains SpeedStep logic
    Detects ICH2-M, ICH3-M and ICH4-M so far. The pci_dev points to
  the LPC bridge  PM module which contains all power-management
  functions. Returns the SPEEDSTEP_CHIPSET_-number for the detected
  chipset, or zero on failure.
 4-M 
 3-M 
		 speedstep.c causes lockups on Dell Inspirons 8000 and
		  8100 which use a pretty old revision of the 82815
		  host bridge. Abort on these systems.
 2-M 
 2-M 
 You're supposed to ensure CPU is online. 
  speedstep_target - set a new CPUFreq policy
  @policy: new policy
  @index: index of target frequency
  Sets a new CPUFreq policy.
 only run on CPU to be set, or on its sibling 
 detect low and high frequency and transition latency 
  speedstep_init - initializes the SpeedStep CPUFreq driver
    Initializes the SpeedStep support. Returns -ENODEV on unsupported
  devices, -EINVAL on problems during initiatization, and zero on
  success.
 detect processor 
 detect chipset 
 activate speedstep support 
  speedstep_exit - unregisters SpeedStep support
    Unregisters SpeedStep support.
 SPDX-License-Identifier: GPL-2.0-only
   driverscpufreqcpufreq_conservative.c
   Copyright (C)  2001 Russell King
             (C)  2003 Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>.
                       Jun Nakajima <jun.nakajima@intel.com>
             (C)  2009 Alexander Clouter <alex@digriz.org.uk>
 Conservative governor macros 
 max freq cannot be less than 100. But who knows... 
  Every sampling_rate, we check, if current idle time is less than 20%
  (default), then we try to increase frequency. Every sampling_rate 
  sampling_down_factor, we check, if current idle time is more than 80%
  (default), then we try to decrease frequency
  Frequency updates happen at minimum steps of 5% (default) of maximum
  frequency
	
	  break out if we 'cannot' reduce the speed as the user might
	  want freq_step to be zero
	
	  If requested_freq is out of range, it is likely that the limits
	  changed in the meantime, so fall back to current frequency in that
	  case.
	
	  Decrease requested_freq one freq_step for each idle period that
	  we didn't update the frequency.
 Check for frequency increase 
 if we are already at full speed then break out early 
 if sampling_down_factor is active break out early 
 Check for frequency decrease 
		
		  if we cannot reduce the frequency anymore, break out early
 sysfs interface 
 cannot be lower than 1 otherwise freq will not fall 
 nothing to do 
 we need to re-evaluate prev_cpu_idle 
	
	  no need to test here if freq_step is zero as the user might actually
	  want this, they would be crazy though :)
 sysfs end 
 SPDX-License-Identifier: GPL-2.0-only
  Copyright 2009 Wolfson Microelectronics plc
  S3C64xx CPUfreq Support
	 Guess based on having to do an I2CSPI write; in future we
 Check for frequencies we can generate 
		 If we have no regulator then assume startup
	 Datasheet says PLL stabalisation time (if we were to use
	  the PLLs, which we don't currently) is ~300us worst case,
	  but add some fudge.
 SPDX-License-Identifier: GPL-2.0
  System Control and Power Interface (SCMI) based CPUFreq Interface driver
  Copyright (C) 2018-2021 ARM Ltd.
  Sudeep Holla <sudeep.holla@arm.com>
  perf_ops->freq_set is not a synchronous, the actual OPP change will
  happen asynchronously and can get notified if the events are
  subscribed for by the SCMI firmware
 Get the power cost of the performance domain. 
 The EM framework specifies the frequency in KHz. 
 Obtain CPUs that share SCMI performance controls 
	
	  Obtain CPUs that share performance levels.
	  The OPP 'sharing cpus' info may come from DT through an empty opp
	  table and opp-shared.
		
		  Either opp-table is not set or no opp-shared was found.
		  Use the CPU mask from SCMI to designate CPUs sharing an OPP
		  table.
	 
	   A previous CPU may have marked OPPs as shared for a few CPUs, based on
	   what OPP core provided. If the current CPU is part of those few, then
	   there is no need to add OPPs again.
 SCMI allows DVFS request for any domain from any CPU 
	
	  This callback will be called for each policy, but we don't need to
	  register with EM every time. Despite not being part of the same
	  policy, some CPUs may still share their perf-domains, and a CPU from
	  another policy may already have registered with EM on behalf of CPUs
	  of this policy.
 dummy clock provider as needed by OPP if clocks property is used 
 SPDX-License-Identifier: GPL-2.0-only
  Abstract code for CPUFreq governor tunable sysfs attributes.
  Copyright (C) 2016, Intel Corporation
  Author: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
  CPU frequency scaling for Broadcom BMIPS SoCs
  Copyright (c) 2017 Broadcom
  This program is free software; you can redistribute it andor
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation version 2.
  This program is distributed "as is" WITHOUT ANY WARRANTY of any
  kind, whether express or implied; without even the implied warranty
  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 for mips_hpt_frequency 
 25 us 
 We hit the guard element of the array. No compatible CPU found. 
  vgaarb.c: Implements the VGA arbitration. For details refer to
  Documentationgpuvgaarbiter.rst
  (C) Copyright 2005 Benjamin Herrenschmidt <benh@kernel.crashing.org>
  (C) Copyright 2007 Paulo R. Zanoni <przanoni@gmail.com>
  (C) Copyright 2007, 2009 Tiago Vignatti <vignatti@freedesktop.org>
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS
  IN THE SOFTWARE.
  We keep a list of all vga devices in the system to speed
  up the various operations of the arbiter
 what does it decodes 
 what does it owns 
 what does it locks 
 legacy IO lock count 
 legacy MEM lock count 
 normal IO count 
 normal MEM count 
 Ignore VGA_RSRC_IO and VGA_RSRC_MEM 
	 we could in theory hand out locks on IO and mem
 XXX We're not chekcing the str_size! 
 this is only used a cookie - it should not be dereferenced 
 Find somebody in our list 
  vga_default_device - return the default VGA device, for vgacon
  This can be defined by the platform. The default implementation
  is rather dumb and will probably only work properly on single
  vga card setups andor x86 platforms.
  If your VGA default device is not PCI, you'll have to return
  NULL here. In this case, I assume it will not conflict with
  any PCI card. If this is not true, I'll have to define two archs
  hooks for enablingdisabling the VGA default device if that is
  possible. This may be a problem with real _ISA_ VGA cards, in
  addition to a PCI one. I don't know at this point how to deal
  with that card. Can theirs IOs be disabled at all ? If not, then
  I suppose it's a matter of having the proper arch hook telling
  us about it, so we basically never allow anybody to succeed a
  vga_get()...
  vga_remove_vgacon - deactivete vga console
  Unbind and unregister vgacon in case pdev is the default vga
  device.  Can be called by gpu drivers on initialization to make
  sure vga register access done by vgacon will not disturb the
  device.
  @pdev: pci device.
 Ignore "already unregistered". 
 If we don't ever use VGA arb we should avoid
   turning off anything anywhere due to old X servers getting
	 we should inform all GPUs in the system that
	  VGA arb has occurred and to try and disable resources
	 Account for "normal" resources to lock. If we decode the legacy,
	  counterpart, we need to request it as well
 Check what resources we need to acquire 
 We already own everything, just mark locked & bye bye 
	 We don't need to request a legacy resource, we just enable
	  appropriate decoding and go
 Ok, we don't, let's find out how we need to kick off 
 Don't conflict with myself 
		 We have a possible conflict. before we go further, we must
		  check if we sit on the same bus as the conflicting device.
		  if we don't, then we must tie both IO and MEM resources
		  together since there is only a single bit controlling
		  VGA forwarding on P2P bridges
		 Check if the guy has a lock on the resource. If he does,
		  return the conflicting entry
		 Ok, now check if it owns the resource we want.  We can
		  lock resources that are not decoded, therefore a device
		  can own resources it doesn't decode.
		 looks like he doesn't have a lock, we can steal
		  them from him
		 If we can't control legacy resources via the bridge, we
		  also need to disable normal decoding.
 If we disabled normal decoding, reflect it in owns 
	 ok dude, we got it, everybody conflicting has been disabled, let's
	  enable us.  Mark any bits in "owns" regardless of whether we
	  decoded them.  We can lock resources we don't decode, therefore
	  we must track them via "owns".
	 Update our counters, and account for equivalent legacy resources
	  if we decode them
	 Just clear lock bits, we do lazy operations so we don't really
	  have to bother about anything else at this point
	 Kick the wait queue in case somebody was waiting if we actually
	  released something
  vga_get - acquire & locks VGA resources
  @pdev: pci device of the VGA card or NULL for the system default
  @rsrc: bit mask of resources to acquire and lock
  @interruptible: blocking should be interruptible by signals ?
  This function acquires VGA resources for the given card and mark those
  resources locked. If the resource requested are "normal" (and not legacy)
  resources, the arbiter will first check whether the card is doing legacy
  decoding for that type of resource. If yes, the lock is "converted" into a
  legacy resource lock.
  The arbiter will first look for all VGA cards that might conflict and disable
  their IOs andor Memory access, including VGA forwarding on P2P bridges if
  necessary, so that the requested resources can be used. Then, the card is
  marked as locking these resources and the IO andor Memory accesses are
  enabled on the card (including VGA forwarding on parent P2P bridges if any).
  This function will block if some conflicting card is already locking one of
  the required resources (or any resource on a different bus segment, since P2P
  bridges don't differentiate VGA memory and IO afaik). You can indicate
  whether this blocking should be interruptible by a signal (for userland
  interface) or not.
  Must not be called at interrupt time or in atomic context.  If the card
  already owns the resources, the function succeeds.  Nested calls are
  supported (a per-resource counter is maintained)
  On success, release the VGA resource again with vga_put().
  Returns:
  0 on success, negative error code on failure.
 The one who calls us should check for this, but lets be sure... 
		 We have a conflict, we wait until somebody kicks the
		  work queue. Currently we have one work queue that we
		  kick each time some resources are released, but it would
		  be fairly easy to have a per device one so that we only
		  need to attach to the conflicting device
  vga_tryget - try to acquire & lock legacy VGA resources
  @pdev: pci devivce of VGA card or NULL for system default
  @rsrc: bit mask of resources to acquire and lock
  This function performs the same operation as vga_get(), but will return an
  error (-EBUSY) instead of blocking if the resources are already locked by
  another card. It can be called in any context
  On success, release the VGA resource again with vga_put().
  Returns:
  0 on success, negative error code on failure.
 The one who calls us should check for this, but lets be sure... 
  vga_put - release lock on legacy VGA resources
  @pdev: pci device of VGA card or NULL for system default
  @rsrc: but mask of resource to release
  This fuction releases resources previously locked by vga_get() or
  vga_tryget(). The resources aren't disabled right away, so that a subsequence
  vga_get() on the same card will succeed immediately. Resources have a
  counter, so locks are only released if the counter reaches 0.
 The one who calls us should check for this, but lets be sure... 
  Rules for using a bridge to control a VGA descendant decoding: if a bridge
  has only one VGA descendant then it can be used to control the VGA routing
  for that device. It should always use the bridge closest to the device to
  control it. If a bridge has a direct VGA descendant, but also have a sub-
  bridge VGA descendant then we cannot use that bridge to control the direct
  VGA descendant. So for every device we register, we need to iterate all
  its parent bridges so we can invalidate any devices using them properly.
 okay iterate the new devices bridge hierarachy 
 go through list of devices already registered 
 see if the share a bridge with this device 
				
				  If their direct parent bridge is the same
				  as any bridge of this device then it can't
				  be used for that device.
			
			  Now iterate the previous devices bridge hierarchy.
			  If the new devices parent bridge is in the other
			  devices hierarchy then we can't use it to control
			  this device
  Currently, we assume that the "initial" setup of the system is
  not sane, that is we come up with conflicting devices and let
  the arbiter's client decides if devices decodes or not legacy
  things.
 Only deal with VGA class devices 
 Allocate structure 
		
		  What to do on allocation failure ? For now, let's just do
		  nothing, I'm not sure there is anything saner to be done.
 Take lock & check for duplicates 
 By default, assume we decode everything 
 by default mark it as decoding 
	 Mark that we "own" resources based on our enables, we will
	  clear that below if the bridge isn't forwarding
 Check if VGA cycles can get down to us 
	 Deal with VGA default device. Use first enabled one
	  by default if arch doesn't have it's own hook
 Add to the list 
 Remove entry from list 
	 Notify userland driver that the device is gone so it discards
	  it's copies of the pci_dev pointer
 Wake up all possible waiters 
 this is called with the lock 
 if we removed locked decodes, lock count goes to zero, and release 
 change decodes counter 
 don't let userspace futz with kernel driver decodes 
 update the device decodes + counter 
	 XXX if somebody is going from "doesn't decode" to "decodes" state
	  here, additional care must be taken as we may have pending owner
	  ship of non-legacy region ...
  vga_set_legacy_decoding
  @pdev: pci device of the VGA card
  @decodes: bit mask of what legacy regions the card decodes
  Indicates to the arbiter if the card decodes legacy VGA IOs, legacy VGA
  Memory, both, or none. All cards default to both, the card driver (fbdev for
  example) should tell the arbiter if it has disabled legacy decoding, so the
  card can be left out of the arbitration process (and can be safe to take
  interrupts at any time.
  vga_client_register - register or unregister a VGA arbitration client
  @pdev: pci device of the VGA client
  @set_decode: vga decode change callback
  Clients have two callback mechanisms they can use.
  @set_decode callback: If a client can disable its GPU VGA resource, it
  will get a callback from this to set the encodedecode state.
  Rationale: we cannot disable VGA decode resources unconditionally some single
  GPU laptops seem to require ACPI or BIOS access to the VGA registers to
  control things like backlights etc.  Hopefully newer multi-GPU laptops do
  something saner, and desktops won't have any special ACPI for this. The
  driver will get a callback when VGA arbitration is first used by userspace
  since some older X servers have issues.
  This function does not check whether a client for @pdev has been registered
  already.
  To unregister just call vga_client_unregister().
  Returns: 0 on success, -1 on failure
  Char driver implementation
  Semantics is:
   open       : open user instance of the arbitrer. by default, it's
                 attached to the default VGA device of the system.
   close      : close user instance, release locks
   read       : return a string indicating the status of the target.
                 an IO state string is of the form {io,mem,io+mem,none},
                 mc and ic are respectively mem and io lock counts (for
                 debuggingdiagnostic only). "decodes" indicate what the
                 card currently decodes, "owns" indicates what is currently
                 enabled on it, and "locks" indicates what is locked by this
                 card. If the card is unplugged, we get "invalid" then for
                 card_ID and an -ENODEV error is returned for any command
                 until a new card is targeted
    "<card_ID>,decodes=<io_state>,owns=<io_state>,locks=<io_state> (ic,mc)"
  write       : write a command to the arbiter. List of commands is:
    target <card_ID>   : switch target to card <card_ID> (see below)
    lock <io_state>    : acquires locks on target ("none" is invalid io_state)
    trylock <io_state> : non-blocking acquire locks on target
    unlock <io_state>  : release locks on target
    unlock all         : release all locks on target held by this user
    decodes <io_state> : set the legacy decoding attributes for the card
  poll         : event if something change on any card (not just the target)
  card_ID is of the form "PCI:domain:bus:dev.fn". It can be set to "default"
  to go back to the system default card (TODO: not implemented yet).
  Currently, only PCI is supported as a prefix, but the userland API may
  support other bus types in the future, even if the current kernel
  implementation doesn't.
  Note about locks:
  The driver keeps track of which user has what locks on which card. It
  supports stacking, like the kernel one. This complexifies the implementation
  a bit, but makes the arbiter more tolerant to userspace problems and able
  to properly cleanup in all cases when a process dies.
  Currently, a max of 16 cards simultaneously can have locks issued from
  userspace for a given user (file descriptor instance) of the arbiter.
  If the device is hot-unplugged, there is a hook inside the module to notify
  they being addedremoved in the system and automatically addedremoved in
  the arbiter.
  Each user has an array of these, tracking which cards have locks
  This function gets a string in the format: "PCI:domain:bus:dev.fn" and
  returns the respective values. If the string is not in this format,
  it returns 0.
	 Shields against vga_arb_device_card_gone (pci_dev going
	  away), and allows access to vga list
 If we are targeting the default, use it 
 Find card vgadev structure 
		 Wow, it's not in the list, that shouldn't happen,
		  let's fix us up and return invalid card
 Fill the buffer with infos 
 Copy that to user 
  TODO: To avoid parsing inside kernel and to improve the speed we may
  consider use ioctl here
 Just to make sure... 
 Update the client's locks lists... 
			 TODO: Add this?
			   if (io_state == VGA_RSRC_NONE) {
			   ret_val = -EPROTO;
			   goto done;
			   }
		 TODO: Add this?
		   if (io_state == VGA_RSRC_NONE) {
		   ret_val = -EPROTO;
		   goto done;
		   }
 Update the client's locks lists... 
 if target is default 
 XXX: which value to return? 
 If we got here, the message written is not part of the protocol! 
 Set the client' lists of locks 
 Maybe this is still null! 
  callback any registered clients to let them know we have a
  change in VGA cards
	 For now we're only intereted in devices added and removed. I didn't
	  test this thing here, so someone needs to double check for the
		
		  Override vga_arbiter_add_pci_device()'s IO based detection
		  as it may take the wrong device (e.g. on Apple system under
		  EFI).
		 
		  Select the device owning the boot framebuffer if there is
		  one.
 Does firmware framebuffer belong to us? 
	 We add all PCI devices satisfying VGA class in the arbiter by
  vga_switcheroo.c - Support for laptop with dual GPU using one set of outputs
  Copyright (c) 2010 Red Hat Inc.
  Author : Dave Airlie <airlied@redhat.com>
  Copyright (c) 2015 Lukas Wunner <lukas@wunner.de>
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS
  IN THE SOFTWARE.
  DOC: Overview
  vga_switcheroo is the Linux subsystem for laptop hybrid graphics.
  These come in two flavors:
   muxed: Dual GPUs with a multiplexer chip to switch outputs between GPUs.
   muxless: Dual GPUs but only one of them is connected to outputs.
    The other one is merely used to offload rendering, its results
    are copied over PCIe into the framebuffer. On Linux this is
    supported with DRI PRIME.
  Hybrid graphics started to appear in the late Naughties and were initially
  all muxed. Newer laptops moved to a muxless architecture for cost reasons.
  A notable exception is the MacBook Pro which continues to use a mux.
  Muxes come with varying capabilities: Some switch only the panel, others
  can also switch external displays. Some switch all display pins at once
  while others can switch just the DDC lines. (To allow EDID probing
  for the inactive GPU.) Also, muxes are often used to cut power to the
  discrete GPU while it is not used.
  DRM drivers register GPUs with vga_switcheroo, these are henceforth called
  clients. The mux is called the handler. Muxless machines also register a
  handler to control the power state of the discrete GPU, its ->switchto
  callback is a no-op for obvious reasons. The discrete GPU is often equipped
  with an HDA controller for the HDMIDP audio signal, this will also
  register as a client so that vga_switcheroo can take care of the correct
  suspendresume order when changing the discrete GPU's power state. In total
  there can thus be up to three clients: Two vga clients (GPUs) and one audio
  client (on the discrete GPU). The code is mostly prepared to support
  machines with more than two GPUs should they become available.
  The GPU to which the outputs are currently switched is called the
  active client in vga_switcheroo parlance. The GPU not in use is the
  inactive client. When the inactive client's DRM driver is loaded,
  it will be unable to probe the panel's EDID and hence depends on
  VBIOS to provide its display modes. If the VBIOS modes are bogus or
  if there is no VBIOS at all (which is common on the MacBook Pro),
  a client may alternatively request that the DDC lines are temporarily
  switched to it, provided that the handler supports this. Switching
  only the DDC lines and not the entire output avoids unnecessary
  flickering.
  struct vga_switcheroo_client - registered client
  @pdev: client pci device
  @fb_info: framebuffer to which console is remapped on switching
  @pwr_state: current power state if manual power control is used.
 	For driver power control, call vga_switcheroo_pwr_state().
  @ops: client callbacks
  @id: client identifier. Determining the id requires the handler,
 	so gpus are initially assigned VGA_SWITCHEROO_UNKNOWN_ID
 	and later given their true id in vga_switcheroo_enable()
  @active: whether the outputs are currently switched to this client
  @driver_power_control: whether power state is controlled by the driver's
 	runtime pm. If true, writing ON and OFF to the vga_switcheroo debugfs
 	interface is a no-op so as not to interfere with runtime pm
  @list: client list
  @vga_dev: pci device, indicate which GPU is bound to current audio client
  Registered client. A client can be either a GPU or an audio device on a GPU.
  For audio clients, the @fb_info and @active members are bogus. For GPU
  clients, the @vga_dev is bogus.
  protects access to struct vgasr_priv
  struct vgasr_priv - vga_switcheroo private data
  @active: whether vga_switcheroo is enabled.
 	Prerequisite is the registration of two GPUs and a handler
  @delayed_switch_active: whether a delayed switch is pending
  @delayed_client_id: client to which a delayed switch is pending
  @debugfs_root: directory for vga_switcheroo debugfs interface
  @registered_clients: number of registered GPUs
 	(counting only vga clients, not audio clients)
  @clients: list of registered clients
  @handler: registered handler
  @handler_flags: flags of registered handler
  @mux_hw_lock: protects mux state
 	(in particular while DDC lines are temporarily switched)
  @old_ddc_owner: client to which DDC lines will be switched back on unlock
  vga_switcheroo private data. Currently only one vga_switcheroo instance
  per system is supported.
 only one switcheroo per system 
 we're ready if we get two clients + handler 
 call the handler to init 
  vga_switcheroo_register_handler() - register handler
  @handler: handler callbacks
  @handler_flags: handler flags
  Register handler. Enable vga_switcheroo if two vga clients have already
  registered.
  Return: 0 on success, -EINVAL if a handler was already registered.
  vga_switcheroo_unregister_handler() - unregister handler
  Unregister handler. Disable vga_switcheroo.
  vga_switcheroo_handler_flags() - obtain handler flags
  Helper for clients to obtain the handler flags bitmask.
  Return: Handler flags. A value of 0 means that no handler is registered
  or that the handler has no special capabilities.
  vga_switcheroo_register_client - register vga client
  @pdev: client pci device
  @ops: client callbacks
  @driver_power_control: whether power state is controlled by the driver's
 	runtime pm
  Register vga client (GPU). Enable vga_switcheroo if another GPU and a
  handler have already registered. The power state of the client is assumed
  to be ON. Beforehand, vga_switcheroo_client_probe_defer() shall be called
  to ensure that all prerequisites are met.
  Return: 0 on success, -ENOMEM on memory allocation error.
  vga_switcheroo_register_audio_client - register audio client
  @pdev: client pci device
  @ops: client callbacks
  @vga_dev:  pci device which is bound to current audio client
  Register audio client (audio device on a GPU). The client is assumed
  to use runtime PM. Beforehand, vga_switcheroo_client_probe_defer()
  shall be called to ensure that all prerequisites are met.
  Return: 0 on success, -ENOMEM on memory allocation error, -EINVAL on getting
  client id error.
	
	  if vga_switcheroo has enabled, that mean two GPU clients and also
	  handler are registered. Get audio client id from bound GPU client
	  id directly, otherwise, set it as VGA_SWITCHEROO_UNKNOWN_ID,
	  it will set to correct id in later when vga_switcheroo_enable()
	  is called.
 notify if GPU has been already bound 
  vga_switcheroo_client_probe_defer() - whether to defer probing a given client
  @pdev: client pci device
  Determine whether any prerequisites are not fulfilled to probe a given
  client. Drivers shall invoke this early on in their ->probe callback
  and return %-EPROBE_DEFER if it evaluates to %true. Thou shalt not
  register the client ere thou hast called this.
  Return: %true if probing should be deferred, otherwise %false.
		
		  apple-gmux is needed on pre-retina MacBook Pro
		  to probe the panel if pdev is the inactive GPU.
  vga_switcheroo_get_client_state() - obtain power state of a given client
  @pdev: client pci device
  Obtain power state of a given client as seen from vga_switcheroo.
  The function is only called from hda_intel.c.
  Return: Power state.
  vga_switcheroo_unregister_client() - unregister client
  @pdev: client pci device
  Unregister client. Disable vga_switcheroo if this is a vga client (GPU).
  vga_switcheroo_client_fb_set() - set framebuffer of a given client
  @pdev: client pci device
  @info: framebuffer
  Set framebuffer of a given client. The console will be remapped to this
  on switching.
  vga_switcheroo_lock_ddc() - temporarily switch DDC lines to a given client
  @pdev: client pci device
  Temporarily switch DDC lines to the client identified by @pdev
  (but leave the outputs otherwise switched to where they are).
  This allows the inactive client to probe EDID. The DDC lines must
  afterwards be switched back by calling vga_switcheroo_unlock_ddc(),
  even if this function returns an error.
  Return: Previous DDC owner on success or a negative int on error.
  Specifically, %-ENODEV if no handler has registered or if the handler
  does not support switching the DDC lines. Also, a negative value
  returned by the handler is propagated back to the caller.
  The return value has merely an informational purpose for any caller
  which might be interested in it. It is acceptable to ignore the return
  value and simply rely on the result of the subsequent EDID probe,
  which will be %NULL if DDC switching failed.
  vga_switcheroo_unlock_ddc() - switch DDC lines back to previous owner
  @pdev: client pci device
  Switch DDC lines back to the previous owner after calling
  vga_switcheroo_lock_ddc(). This must be called even if
  vga_switcheroo_lock_ddc() returned an error.
  Return: Previous DDC owner on success (i.e. the client identifier of @pdev)
  or a negative int on error.
  Specifically, %-ENODEV if no handler has registered or if the handler
  does not support switching the DDC lines. Also, a negative value
  returned by the handler is propagated back to the caller.
  Finally, invoking this function without calling vga_switcheroo_lock_ddc()
  first is not allowed and will result in %-EINVAL.
  DOC: Manual switching and manual power control
  In this mode of use, the file syskerneldebugvgaswitcherooswitch
  can be read to retrieve the current vga_switcheroo state and commands
  can be written to it to change the state. The file appears as soon as
  two GPU drivers and one handler have registered with vga_switcheroo.
  The following commands are understood:
   OFF: Power off the device not in use.
   ON: Power on the device not in use.
   IGD: Switch to the integrated graphics device.
    Power on the integrated GPU if necessary, power off the discrete GPU.
    Prerequisite is that no user space processes (e.g. Xorg, alsactl)
    have opened device files of the GPUs or the audio client. If the
    switch fails, the user may invoke lsof(8) or fuser(1) on devdri
    and devsndcontrolC1 to identify processes blocking the switch.
   DIS: Switch to the discrete graphics device.
   DIGD: Delayed switch to the integrated graphics device.
    This will perform the switch once the last user space process has
    closed the device files of the GPUs and the audio client.
   DDIS: Delayed switch to the discrete graphics device.
   MIGD: Mux-only switch to the integrated graphics device.
    Does not remap console or change the power state of either gpu.
    If the integrated GPU is currently off, the screen will turn black.
    If it is on, the screen will show whatever happens to be in VRAM.
    Either way, the user has to blindly enter the command to switch back.
   MDIS: Mux-only switch to the discrete graphics device.
  For GPUs whose power state is controlled by the driver's runtime pm,
  the ON and OFF commands are a no-op (see next section).
  For muxless machines, the IGDDIS, DIGDDDIS and MIGDMDIS commands
  should not be used.
 call the driver callback to turn on device 
 call the driver callback to turn off device 
 stage one happens before delay 
 post delay 
 let HDA controller autosuspend if GPU uses driver power control 
 let HDA controller autoresume if GPU uses driver power control 
 pwr off the device not in use 
 pwr on the device not in use 
 request a delayed switch - test can we switch now 
 okay we want a switch - test if devices are willing to switch 
 already initialised 
  vga_switcheroo_process_delayed_switch() - helper for delayed switching
  Process a delayed switch if one is pending. DRM drivers should call this
  from their ->lastclose callback.
  Return: 0 on success. -EINVAL if no delayed switch is pending, if the client
  has unregistered in the meantime or if there are other clients blocking the
  switch. If the actual switch fails, an error is reported and 0 is returned.
  DOC: Driver power control
  In this mode of use, the discrete GPU automatically powers up and down at
  the discretion of the driver's runtime pm. On muxed machines, the user may
  still influence the muxer state by way of the debugfs interface, however
  the ON and OFF commands become a no-op for the discrete GPU.
  This mode is the default on Nvidia HybridPowerOptimus and ATI PowerXpress.
  Specifying nouveau.runpm=0, radeon.runpm=0 or amdgpu.runpm=0 on the kernel
  command line disables it.
  After the GPU has been suspended, the handler needs to be called to cut
  power to the GPU. Likewise it needs to reinstate power before the GPU
  can resume. This is achieved by vga_switcheroo_init_domain_pm_ops(),
  which augments the GPU's suspendresume functions by the requisite
  calls to the handler.
  When the audio device resumes, the GPU needs to be woken. This is achieved
  by a PCI quirk which calls device_link_add() to declare a dependency on the
  GPU. That way, the GPU is kept awake whenever and as long as the audio
  device is in use.
  On muxed machines, if the mux is initially switched to the discrete GPU,
  the user ends up with a black screen when the GPU powers down after boot.
  As a workaround, the mux is forced to the integrated GPU on runtime suspend,
  cf. https:bugs.freedesktop.orgshow_bug.cgi?id=75917
 switcheroo power domain 
  vga_switcheroo_init_domain_pm_ops() - helper for driver power control
  @dev: vga client device
  @domain: power domain
  Helper for GPUs whose power state is controlled by the driver's runtime pm.
  After the GPU has been suspended, the handler needs to be called to cut
  power to the GPU. Likewise it needs to reinstate power before the GPU
  can resume. To this end, this helper augments the suspendresume functions
  by the requisite calls to the handler. It needs only be called on platforms
  where the power switch is separate to the device being powered down.
 copy over all the bus versions 
  Copyright  2008 Intel Corporation
  Copyright  2016 Collabora Ltd
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
  Based on code from the i915 driver.
  Original author: Damien Lespiau <damien.lespiau@intel.com>
  DOC: CRC ABI
  DRM device drivers can provide to userspace CRC information of each frame as
  it reached a given hardware component (a CRC sampling "source").
  Userspace can control generation of CRCs in a given CRTC by writing to the
  file dri0crtc-Ncrccontrol in debugfs, with N being the :ref:`index of
  the CRTC<crtc_index>`. Accepted values are source names (which are
  driver-specific) and the "auto" keyword, which will let the driver select a
  default source of frame CRCs for this CRTC.
  Once frame CRC generation is enabled, userspace can capture them by reading
  the dri0crtc-Ncrcdata file. Each line in that file contains the frame
  number in the first field and then a number of unsigned integer fields
  containing the CRC data. Fields are separated by a single space and the number
  of CRC fields is source-specific.
  Note that though in some cases the CRC is computed in a specified way and on
  the frame contents as supplied by userspace (eDP 1.3), in general the CRC
  computation is performed in an unspecified way and on frame contents that have
  been already processed in also an unspecified way and thus userspace cannot
  rely on being able to generate matching CRC values for the frame contents that
  it submits. In this general case, the maximum userspace can do is to compare
  the reported CRCs of frames that should have the same contents.
  On the driver side the implementation effort is minimal, drivers only need to
  implement &drm_crtc_funcs.set_crc_source and &drm_crtc_funcs.verify_crc_source.
  The debugfs files are automatically set up if those vfuncs are set. CRC samples
  need to be captured in the driver by calling drm_crtc_add_crc_entry().
  Depending on the driver and HW requirements, &drm_crtc_funcs.set_crc_source
  may result in a commit (even a full modeset).
  CRC results must be reliable across non-full-modeset atomic commits, so if a
  commit via DRM_IOCTL_MODE_ATOMIC would disable or otherwise interfere with
  CRC generation, then the driver must mark that commit as a full modeset
  (drm_atomic_crtc_needs_modeset() should return true). As a result, to ensure
  consistent results, generic userspace must re-setup CRC generation after a
  legacy SETCRTC or an atomic commit with DRM_MODE_ATOMIC_ALLOW_MODESET.
 terminate the infinite while loop if 'drm_dp_aux_crc_work' running 
  1 frame field of 10 chars plus a number of CRC fields of 10 chars each, space
  separated, with a newline at the end and null-terminated.
 Nothing to read? 
 We know we have an entry to be read 
  drm_crtc_add_crc_entry - Add entry with CRC information for a frame
  @crtc: CRTC to which the frame belongs
  @has_frame: whether this entry has a frame number to go with
  @frame: number of the frame these CRCs are about
  @crcs: array of CRC values, with length matching #drm_crtc_crc.values_cnt
  For each frame, the driver polls the source of CRCs for new data and calls
  this function to add them to the buffer from where userspace reads.
 Caller may not have noticed yet that userspace has stopped reading 
  Legacy: Generic DRM Buffer Management
  Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
  Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
  All Rights Reserved.
  Author: Rickard E. (Rik) Faith <faith@valinux.com>
  Author: Gareth Hughes <gareth@valinux.com>
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  VA LINUX SYSTEMS ANDOR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
		
		  Because the kernel-userspace ABI is fixed at a 32-bit offset
		  while PCI resources may live above that, we only compare the
		  lower 32 bits of the map offset for maps of type
		  _DRM_FRAMEBUFFER or _DRM_REGISTERS.
		  It is assumed that if a driver have more than one resource
		  of each type, the lower 32 bits are different.
 Make gcc happy 
		 For shared memory, we have to preserve the SHMLBA
		  bits of the eventual vma->vm_pgoff value during
		  mmap().  Otherwise we run into cache aliasing problems
		  on some platforms.  On these platforms, the pgoff of
		  a mmap() request is used to pick a suitable virtual
		  address for the mmap() region such that it will not
		  cause cache aliasing problems.
		 
		  Therefore, make sure the SHMLBA relevant bits of the
		  hash value we use are equal to those in the original
		  kernel virtual address.
  Core function to create a range of memory available for mapping by a
  non-root process.
  Adjusts the memory offset to its absolute value according to the mapping
  type.  Adds the map to the map list drm_device::maplist. Adds MTRR's where
  applicable and if supported by the kernel.
	 Only allow shared memory to be removable since we only keep enough
	  book keeping information about shared memory to allow for removal
	  when processes fork.
	 page-align _DRM_SHM maps. They are allocated here so there is no security
	  hole created by that and it works around various broken drivers that use
	  a non-aligned quantity to map the SAREA. --BenH
		 Some drivers preinitialize some maps, without the X Server
		  needing to be aware of it.  Therefore, we just return success
		  when the server tries to create a duplicate map.
 Prevent a 2nd X Server from creating a 2nd lock 
 Pointer to lock 
		 In some cases (i810 driver), user space may have already
		  added the AGP base itself, because dev->agp->base previously
		  only got set during AGP enable.  So, only add the base
		  address if the map's offset isn't already within the
		  aperture.
 for getmap 
		 This assumes the DRM is in total control of AGP space.
		  It's not always the case as AGP can be in the control
		  of user space (i.e. i810 driver). So this loop will get
		  skipped and we double check that dev->agp->memory is
		  actually set as well as being invalid before EPERM'ing
		 dma_addr_t is 64bit on i386 with CONFIG_HIGHMEM64G,
		  As we're limiting the address to 2^32-1 (or less),
		  casting it down to 32 bits is no problem, but we
		  need to point to a 64bit variable first.
 Assign a 32-bit handle 
 We do it here so that dev->struct_mutex protects the increment 
  Ioctl to specify a range of memory that is available for mapping by a
  non-root process.
  \param inode device inode.
  \param file_priv DRM file private.
  \param cmd command.
  \param arg pointer to a drm_map structure.
  \return zero on success or a negative value on error.
 avoid a warning on 64-bit, this casting isn't very nice, but the API is set so too late 
	
	  It appears that there are no users of this value whatsoever --
	  drmAddMap just discards it.  Let's not encourage its use.
	  (Keeping drm_addmap_core's returned mtrr value would be wrong --
	   it's not a real mtrr index anymore.)
  Get a mapping information.
  \param inode device inode.
  \param file_priv DRM file private.
  \param cmd command.
  \param arg user argument, pointing to a drm_map structure.
  \return zero on success or a negative number on failure.
  Searches for the mapping with the specified offset and copies its information
  into userspace
  Remove a map private from list and deallocate resources if the mapping
  isn't in use.
  Searches the map on drm_device::maplist, removes it from the list, see if
  it's being used, and free any associated resource (such as MTRR's) if it's not
  being on use.
  \sa drm_legacy_addmap
 Find the list entry for the map and remove it 
 SHM removed 
 The rmmap ioctl appears to be unnecessary.  All mappings are torn down on
  the last close of the device, and this is necessary for cleanup when things
  exit uncleanly.  Therefore, having userland manually remove mappings seems
  like a pointless exercise since they're going away anyway.
  One use case might be after addmap is allowed for normal users for SHM and
  gets used by drivers that the server doesn't need to care about.  This seems
  unlikely.
  \param inode device inode.
  \param file_priv DRM file private.
  \param cmd command.
  \param arg pointer to a struct drm_map structure.
  \return zero on success or a negative value on error.
	 List has wrapped around to the head pointer, or it's empty we didn't
	  find anything.
 Register and framebuffer maps are permanent 
  Cleanup after an error on one of the addbufs() functions.
  \param dev DRM device.
  \param entry buffer entry where the error occurred.
  Frees any pages and buffers associated with the given entry.
  Add AGP buffers for DMA transfers.
  \param dev struct drm_device to which the buffers are to be added.
  \param request pointer to a struct drm_buf_desc describing the request.
  \return zero on success or a negative number on failure.
  After some sanity checks creates a drm_buf structure for each buffer and
  reallocates the buffer list of the same size order to accommodate the new
  buffers.
 Make sure buffers are located in AGP memory that we own 
 May only call once for each order 
 Set count correctly so we free the proper amount. 
 Free the entry because it isn't valid 
 CONFIG_AGP 
 May only call once for each order 
	 Keep the original pagelist until we know all the allocations
	  have succeeded
 Set count correctly so we free the proper amount. 
 Set count correctly so we free the proper amount. 
 Set count correctly so we free the proper amount. 
 Free the entry because it isn't valid 
	 No allocations failed, so now we can replace the original pagelist
	  with the new one.
 May only call once for each order 
 Set count correctly so we free the proper amount. 
 Free the entry because it isn't valid 
  Add buffers for DMA transfers (ioctl).
  \param inode device inode.
  \param file_priv DRM file private.
  \param cmd command.
  \param arg pointer to a struct drm_buf_desc request.
  \return zero on success or a negative number on failure.
  According with the memory type specified in drm_buf_desc::flags and the
  build options, it dispatches the call either to addbufs_agp(),
  addbufs_sg() or addbufs_pci() for AGP, scatter-gather or consistent
  PCI memory respectively.
  Get information about the buffer mappings.
  This was originally mean for debugging purposes, or by a sophisticated
  client library to determine how best to use the available buffers (e.g.,
  large buffers can be used for image transfer).
  \param inode device inode.
  \param file_priv DRM file private.
  \param cmd command.
  \param arg pointer to a drm_buf_info structure.
  \return zero on success or a negative number on failure.
  Increments drm_device::buf_use while holding the drm_device::buf_lock
  lock, preventing of allocating more buffers after this call. Information
  about each requested buffer is then copied into user space.
 Can't allocate more after this call 
  Specifies a low and high water mark for buffer allocation
  \param inode device inode.
  \param file_priv DRM file private.
  \param cmd command.
  \param arg a pointer to a drm_buf_desc structure.
  \return zero on success or a negative number on failure.
  Verifies that the size order is bounded between the admissible orders and
  updates the respective drm_device_dma::bufs entry low and high water mark.
  \note This ioctl is deprecated and mostly never used.
  Unreserve the buffers in list, previously reserved using drmDMA.
  \param inode device inode.
  \param file_priv DRM file private.
  \param cmd command.
  \param arg pointer to a drm_buf_free structure.
  \return zero on success or a negative number on failure.
  Calls free_buffer() for each used buffer.
  This function is primarily used for debugging.
  Maps all of the DMA buffers into client-virtual space (ioctl).
  \param inode device inode.
  \param file_priv DRM file private.
  \param cmd command.
  \param arg pointer to a drm_buf_map structure.
  \return zero on success or a negative number on failure.
  Maps the AGP, SG or PCI buffer region with vm_mmap(), and copies information
  about each buffer into user space. For PCI buffers, it calls vm_mmap() with
  offset equal to 0, which drm_mmap() interprets as PCI buffers and calls
  drm_mmap_dma().
 Can't allocate more after this call 
 Real error 
  Copyright 2017 Red Hat
  Parts ported from amdgpu (fence wait code).
  Copyright 2016 Advanced Micro Devices, Inc.
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
  Authors:
  DOC: Overview
  DRM synchronisation objects (syncobj, see struct &drm_syncobj) provide a
  container for a synchronization primitive which can be used by userspace
  to explicitly synchronize GPU commands, can be shared between userspace
  processes, and can be shared between different DRM drivers.
  Their primary use-case is to implement Vulkan fences and semaphores.
  The syncobj userspace API provides ioctls for several operations:
   - Creation and destruction of syncobjs
   - Import and export of syncobjs tofrom a syncobj file descriptor
   - Import and export a syncobj's underlying fence tofrom a sync file
   - Reset a syncobj (set its fence to NULL)
   - Signal a syncobj (set a trivially signaled fence)
   - Wait for a syncobj's fence to appear and be signaled
  The syncobj userspace API also provides operations to manipulate a syncobj
  in terms of a timeline of struct &dma_fence_chain rather than a single
  struct &dma_fence, through the following operations:
    - Signal a given point on the timeline
    - Wait for a given point to appear andor be signaled
    - Import and export fromto a given point of a timeline
  At it's core, a syncobj is simply a wrapper around a pointer to a struct
  &dma_fence which may be NULL.
  When a syncobj is first created, its pointer is either NULL or a pointer
  to an already signaled fence depending on whether the
  &DRM_SYNCOBJ_CREATE_SIGNALED flag is passed to
  &DRM_IOCTL_SYNCOBJ_CREATE.
  If the syncobj is considered as a binary (its state is either signaled or
  unsignaled) primitive, when GPU work is enqueued in a DRM driver to signal
  the syncobj, the syncobj's fence is replaced with a fence which will be
  signaled by the completion of that work.
  If the syncobj is considered as a timeline primitive, when GPU work is
  enqueued in a DRM driver to signal the a given point of the syncobj, a new
  struct &dma_fence_chain pointing to the DRM driver's fence and also
  pointing to the previous fence that was in the syncobj. The new struct
  &dma_fence_chain fence replace the syncobj's fence and will be signaled by
  completion of the DRM driver's work and also any work associated with the
  fence previously in the syncobj.
  When GPU work which waits on a syncobj is enqueued in a DRM driver, at the
  time the work is enqueued, it waits on the syncobj's fence before
  submitting the work to hardware. That fence is either :
     - The syncobj's current fence if the syncobj is considered as a binary
       primitive.
     - The struct &dma_fence associated with a given point if the syncobj is
       considered as a timeline primitive.
  If the syncobj's fence is NULL or not present in the syncobj's timeline,
  the enqueue operation is expected to fail.
  With binary syncobj, all manipulation of the syncobjs's fence happens in
  terms of the current fence at the time the ioctl is called by userspace
  regardless of whether that operation is an immediate host-side operation
  (signal or reset) or or an operation which is enqueued in some driver
  queue. &DRM_IOCTL_SYNCOBJ_RESET and &DRM_IOCTL_SYNCOBJ_SIGNAL can be used
  to manipulate a syncobj from the host by resetting its pointer to NULL or
  setting its pointer to a fence which is already signaled.
  With a timeline syncobj, all manipulation of the synobj's fence happens in
  terms of a u64 value referring to point in the timeline. See
  dma_fence_chain_find_seqno() to see how a given point is found in the
  timeline.
  Note that applications should be careful to always use timeline set of
  ioctl() when dealing with syncobj considered as timeline. Using a binary
  set of ioctl() with a syncobj considered as timeline could result incorrect
  synchronization. The use of binary syncobj is supported through the
  timeline set of ioctl() by using a point value of 0, this will reproduce
  the behavior of the binary set of ioctl() (for example replace the
  syncobj's fence when signaling).
  Host-side wait on syncobjs
  --------------------------
  &DRM_IOCTL_SYNCOBJ_WAIT takes an array of syncobj handles and does a
  host-side wait on all of the syncobj fences simultaneously.
  If &DRM_SYNCOBJ_WAIT_FLAGS_WAIT_ALL is set, the wait ioctl will wait on
  all of the syncobj fences to be signaled before it returns.
  Otherwise, it returns once at least one syncobj fence has been signaled
  and the index of a signaled fence is written back to the client.
  Unlike the enqueued GPU work dependencies which fail if they see a NULL
  fence in a syncobj, if &DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT is set,
  the host-side wait will first wait for the syncobj to receive a non-NULL
  fence and then wait on that fence.
  If &DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT is not set and any one of the
  syncobjs in the array has a NULL fence, -EINVAL will be returned.
  Assuming the syncobj starts off with a NULL fence, this allows a client
  to do a host wait in one thread (or process) which waits on GPU work
  submitted in another thread (or process) without having to manually
  synchronize between the two.
  This requirement is inherited from the Vulkan fence API.
  Similarly, &DRM_IOCTL_SYNCOBJ_TIMELINE_WAIT takes an array of syncobj
  handles as well as an array of u64 points and does a host-side wait on all
  of syncobj fences at the given points simultaneously.
  &DRM_IOCTL_SYNCOBJ_TIMELINE_WAIT also adds the ability to wait for a given
  fence to materialize on the timeline without waiting for the fence to be
  signaled by using the &DRM_SYNCOBJ_WAIT_FLAGS_WAIT_AVAILABLE flag. This
  requirement is inherited from the wait-before-signal behavior required by
  the Vulkan timeline semaphore API.
  Importexport of syncobjs
  -------------------------
  &DRM_IOCTL_SYNCOBJ_FD_TO_HANDLE and &DRM_IOCTL_SYNCOBJ_HANDLE_TO_FD
  provide two mechanisms for importexport of syncobjs.
  The first lets the client import or export an entire syncobj to a file
  descriptor.
  These fd's are opaque and have no other use case, except passing the
  syncobj between processes.
  All exported file descriptors and any syncobj handles created as a
  result of importing those file descriptors own a reference to the
  same underlying struct &drm_syncobj and the syncobj can be used
  persistently across all the processes with which it is shared.
  The syncobj is freed only once the last reference is dropped.
  Unlike dma-buf, importing a syncobj creates a new handle (with its own
  reference) for every import instead of de-duplicating.
  The primary use-case of this persistent importexport is for shared
  Vulkan fences and semaphores.
  The second importexport mechanism, which is indicated by
  &DRM_SYNCOBJ_FD_TO_HANDLE_FLAGS_IMPORT_SYNC_FILE or
  &DRM_SYNCOBJ_HANDLE_TO_FD_FLAGS_EXPORT_SYNC_FILE lets the client
  importexport the syncobj's current fence fromto a &sync_file.
  When a syncobj is exported to a sync file, that sync file wraps the
  sycnobj's fence at the time of export and any later signal or reset
  operations on the syncobj will not affect the exported sync file.
  When a sync file is imported into a syncobj, the syncobj's fence is set
  to the fence wrapped by that sync file.
  Because sync files are immutable, resetting or signaling the syncobj
  will not affect any sync files whose fences have been imported into the
  syncobj.
  Importexport of timeline points in timeline syncobjs
  -----------------------------------------------------
  &DRM_IOCTL_SYNCOBJ_TRANSFER provides a mechanism to transfer a struct
  &dma_fence_chain of a syncobj at a given u64 point to another u64 point
  into another syncobj.
  Note that if you want to transfer a struct &dma_fence_chain from a given
  point on a timeline syncobj frominto a binary syncobj, you can use the
  point 0 to mean takereplace the fence in the syncobj.
  drm_syncobj_find - lookup and reference a sync object.
  @file_private: drm file private pointer
  @handle: sync object handle to lookup.
  Returns a reference to the syncobj pointed to by handle or NULL. The
  reference must be released by calling drm_syncobj_put().
 Check if we currently have a reference on the object 
	 We've already tried once to get a fence and failed.  Now that we
	  have the lock, try one more time just to be sure we don't add a
	  callback when a fence has already been set.
  drm_syncobj_add_point - add new timeline point to the syncobj
  @syncobj: sync object to add timeline point do
  @chain: chain node to use to add the point
  @fence: fence to encapsulate in the chain node
  @point: sequence number to use for the point
  Add the chain node as new timeline point to the syncobj.
 You are adding an unorder point to timeline, which could cause payload returned from query_ioctl is 0! 
 Walk the chain once to trigger garbage collection 
  drm_syncobj_replace_fence - replace fence in a sync object.
  @syncobj: Sync object to replace fence in
  @fence: fence to install in sync file.
  This replaces the fence on a sync object.
  drm_syncobj_assign_null_handle - assign a stub fence to the sync object
  @syncobj: sync object to assign the fence on
  Assign a already signaled stub fence to the sync object.
 5s default for wait submission 
  drm_syncobj_find_fence - lookup and reference the fence in a sync object
  @file_private: drm file private pointer
  @handle: sync object handle to lookup.
  @point: timeline point
  @flags: DRM_SYNCOBJ_WAIT_FLAGS_WAIT_FOR_SUBMIT or not
  @fence: out parameter for the fence
  This is just a convenience function that combines drm_syncobj_find() and
  drm_syncobj_fence_get().
  Returns 0 on success or a negative error value on failure. On success @fence
  contains a reference to the fence, which must be released by calling
  dma_fence_put().
	 Waiting for userspace with locks help is illegal cause that can
	  trivial deadlock with page faults for example. Make lockdep complain
	  about it early on.
  drm_syncobj_free - free a sync object.
  @kref: kref to free.
  Only to be called from kref_put in drm_syncobj_put.
  drm_syncobj_create - create a new syncobj
  @out_syncobj: returned syncobj
  @flags: DRM_SYNCOBJ_ flags
  @fence: if non-NULL, the syncobj will represent this fence
  This is the first function to create a sync object. After creating, drivers
  probably want to make it available to userspace, either through
  drm_syncobj_get_handle() or drm_syncobj_get_fd().
  Returns 0 on success or a negative error value on failure.
  drm_syncobj_get_handle - get a handle from a syncobj
  @file_private: drm file private pointer
  @syncobj: Sync object to export
  @handle: out parameter with the new handle
  Exports a sync object created with drm_syncobj_create() as a handle on
  @file_private to userspace.
  Returns 0 on success or a negative error value on failure.
 take a reference to put in the idr 
  drm_syncobj_get_fd - get a file descriptor from a syncobj
  @syncobj: Sync object to export
  @p_fd: out parameter with the new file descriptor
  Exports a sync object created with drm_syncobj_create() as a file descriptor.
  Returns 0 on success or a negative error value on failure.
 take a reference to put in the idr 
  drm_syncobj_open - initializes syncobj file-private structures at devnode open time
  @file_private: drm file-private structure to set up
  Called at device open time, sets up the structure for handling refcounting
  of sync objects.
  drm_syncobj_release - release file-private sync object resources
  @file_private: drm file-private structure to clean up
  Called at close time when the filp is going away.
  Releases any remaining references on objects by this filp.
 no valid flags yet 
 make sure padding is empty 
 This happens inside the syncobj lock 
	 Walk the list of sync objects and initialize entries.  We do
	  this up-front so that we can properly return -EINVAL if there is
	  a syncobj with a missing fence and then never have the chance of
	  returning -EINVAL again.
	 There's a very annoying laxness in the dma_fence API here, in
	  that backends are not required to automatically report when a
	  fence is signaled prior to fence->ops->enable_signaling() being
	  called.  So here if we fail to match signaled_count, we need to
	  fallthough and try a 0 timeout wait!
 The fence has been signaled 
  drm_timeout_abs_to_jiffies - calculate jiffies timeout from absolute value
  @timeout_nsec: timeout nsec component in ns, 0 for poll
  Calculate the timeout in jiffies from an absolute time in secnsec.
 make 0 timeout means poll - absolute 0 doesn't seem valid 
  clamp timeout to avoid infinite timeout 
						 It is most likely that timeline has
  Created: Fri Jan  8 09:01:26 1999 by faith@valinux.com
  Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
  Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
  All Rights Reserved.
  Author Rickard E. (Rik) Faith <faith@valinux.com>
  Author Gareth Hughes <gareth@valinux.com>
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  VA LINUX SYSTEMS ANDOR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
  DOC: getunique and setversion story
  BEWARE THE DRAGONS! MIND THE TRAPDOORS!
  In an attempt to warn anyone else who's trying to figure out what's going
  on here, I'll try to summarize the story. First things first, let's clear up
  the names, because the kernel internals, libdrm and the ioctls are all named
  differently:
   - GET_UNIQUE ioctl, implemented by drm_getunique is wrapped up in libdrm
     through the drmGetBusid function.
   - The libdrm drmSetBusid function is backed by the SET_UNIQUE ioctl. All
     that code is nerved in the kernel with drm_invalid_op().
   - The internal set_busid kernel functions and driver callbacks are
     exclusively use by the SET_VERSION ioctl, because only drm 1.0 (which is
     nerved) allowed userspace to set the busid through the above ioctl.
   - Other ioctls and functions involved are named consistently.
  For anyone wondering what's the difference between drm 1.1 and 1.4: Correctly
  handling pci domains in the busid on ppc. Doing this correctly was only
  implemented in libdrm in 2010, hence can't be nerved yet. No one knows what's
  special with drm 1.2 and 1.3.
  Now the actual horror story of how device lookup in drm works. At large,
  there's 2 different ways, either by busid, or by device driver name.
  Opening by busid is fairly simple:
  1. First call SET_VERSION to make sure pci domains are handled properly. As a
     side-effect this fills out the unique name in the master structure.
  2. Call GET_UNIQUE to read out the unique name from the master structure,
     which matches the busid thanks to step 1. If it doesn't, proceed to try
     the next device node.
  Opening by name is slightly different:
  1. Directly call VERSION to get the version and to match against the driver
     name returned by that ioctl. Note that SET_VERSION is not called, which
     means the the unique name for the master node just opening is _not_ filled
     out. This despite that with current drm device nodes are always bound to
     one device, and can't be runtime assigned like with drm 1.0.
  2. Match driver name. If it mismatches, proceed to the next device node.
  3. Call GET_UNIQUE, and check whether the unique name has length zero (by
     checking that the first byte in the string is 0). If that's not the case
     libdrm skips and proceeds to the next device node. Probably this is just
     copypasta from drm 1.0 times where a set unique name meant that the driver
     was in use already, but that's just conjecture.
  Long story short: To keep the open by name logic working, GET_UNIQUE must
  _not_ return a unique string when SET_VERSION hasn't been called yet,
  otherwise libdrm breaks. Even when that unique string can't ever change, and
  is totally irrelevant for actually opening the device because runtime
  assignable device instances were only support in drm 1.0, which is long dead.
  But the libdrm code in drmOpenByName somehow survived, hence this can't be
  broken.
  Get the bus id.
  \param inode device inode.
  \param file_priv DRM file private.
  \param cmd command.
  \param arg user argument, pointing to a drm_unique structure.
  \return zero on success or a negative number on failure.
  Copies the bus id from drm_device::unique into user space.
  Get client information.
  \param inode device inode.
  \param file_priv DRM file private.
  \param cmd command.
  \param arg user argument, pointing to a drm_client structure.
  \return zero on success or a negative number on failure.
  Searches for the client with the specified index and copies its information
  into userspace
	
	  Hollowed-out getclient ioctl to keep some dead old drm teststools
	  not breaking completely. Userspace tools stop enumerating one they
	  get -EINVAL, hence this is the return value we need to hand back for
	  no clients tracked.
	 
	  Unfortunately some clients (cough libva cough) use this in a fun
	  attempt to figure out whether they're authenticated or not. Since
	  that's the only thing they care about, give it to the directly
	  instead of walking one giant list.
  Get statistics information.
  \param inode device inode.
  \param file_priv DRM file private.
  \param cmd command.
  \param arg user argument, pointing to a drm_stats structure.
  \return zero on success or a negative number on failure.
 Clear stats to prevent userspace from eating its stack garbage. 
  Get devicedriver capabilities
 Only some caps make sense with UMSrender-only drivers. 
 Other caps only work with KMS drivers 
  Set devicedriver capabilities
 No render-only settable capabilities for now 
 Below caps that only works with KMS drivers 
 The modesetting DDX has a totally broken idea of atomic. 
		
		  No atomic user-space blows up on aspect ratio mode bits.
  Setversion ioctl.
  \param inode device inode.
  \param file_priv DRM file private.
  \param cmd command.
  \param arg user argument, pointing to a drm_lock structure.
  \return zero on success or negative number on failure.
  Sets the requested interface version
			
			  Version 1.1 includes tying of DRM to specific device
			  Version 1.4 has proper PCI domain support
  drm_noop - DRM no-op ioctl implementation
  @dev: DRM device for the ioctl
  @data: data pointer for the ioctl
  @file_priv: DRM file for the ioctl call
  This no-op implementation for drm ioctls is useful for deprecated
  functionality where we can't return a failure code because existing userspace
  checks the result of the ioctl, but doesn't care about the action.
  Always returns successfully with 0.
  drm_invalid_op - DRM invalid ioctl implementation
  @dev: DRM device for the ioctl
  @data: data pointer for the ioctl
  @file_priv: DRM file for the ioctl call
  This no-op implementation for drm ioctls is useful for deprecated
  functionality where we really don't want to allow userspace to call the ioctl
  any more. This is the case for old ums interfaces for drivers that
  transitioned to kms gradually and so kept the old legacy tables around. This
  only applies to radeon and i915 kms drivers, other drivers shouldn't need to
  use this function.
  Always fails with a return value of -EINVAL.
  Copy and IOCTL return string to user space
 don't overflow userbuf 
	 let userspace know exact length of driver value (which could be
 finally, try filling in the userbuf 
  Get version information
  \param inode device inode.
  \param filp file pointer.
  \param cmd command.
  \param arg user argument, pointing to a drm_version structure.
  \return zero on success or negative number on failure.
  Fills in the version information in \p arg.
 ROOT_ONLY is only for CAP_SYS_ADMIN 
 AUTH is only for authenticated or render client 
 MASTER is only for master or control clients 
 Render clients must be explicitly allowed 
 Ioctl table 
  DOC: driver specific ioctls
  First things first, driver private IOCTLs should only be needed for drivers
  supporting rendering. Kernel modesetting is all standardized, and extended
  through properties. There are a few exceptions in some existing drivers,
  which define IOCTL for use by the display DRM master, but they all predate
  properties.
  Now if you do have a render driver you always have to support it through
  driver private properties. There's a few steps needed to wire all the things
  up.
  First you need to define the structure for your IOCTL in your driver private
  UAPI header in ``includeuapidrmmy_driver_drm.h``::
      struct my_driver_operation {
              u32 some_thing;
              u32 another_thing;
      };
  Please make sure that you follow all the best practices from
  ``Documentationprocessbotching-up-ioctls.rst``. Note that drm_ioctl()
  automatically zero-extends structures, hence make sure you can add more stuff
  at the end, i.e. don't put a variable sized array there.
  Then you need to define your IOCTL number, using one of DRM_IO(), DRM_IOR(),
  DRM_IOW() or DRM_IOWR(). It must start with the DRM_IOCTL\_ prefix::
      ##define DRM_IOCTL_MY_DRIVER_OPERATION \
          DRM_IOW(DRM_COMMAND_BASE, struct my_driver_operation)
  DRM driver private IOCTL must be in the range from DRM_COMMAND_BASE to
  DRM_COMMAND_END. Finally you need an array of &struct drm_ioctl_desc to wire
  up the handlers and set the access rights::
      static const struct drm_ioctl_desc my_driver_ioctls[] = {
          DRM_IOCTL_DEF_DRV(MY_DRIVER_OPERATION, my_driver_operation,
                  DRM_AUTH|DRM_RENDER_ALLOW),
      };
  And then assign this to the &drm_driver.ioctls field in your driver
  structure.
  See the separate chapter on :ref:`file operations<drm_driver_fops>` for how
  the driver-specific IOCTLs are wired up.
 Enforce sane locking for modern driver ioctls. 
  drm_ioctl - ioctl callback implementation for DRM drivers
  @filp: file this ioctl is called on
  @cmd: ioctl cmd number
  @arg: user argument
  Looks up the ioctl function in the DRM core and the driver dispatch table,
  stored in &drm_driver.ioctls. It checks for necessary permission by calling
  drm_ioctl_permit(), and dispatches to the respective function.
  Returns:
  Zero on success, negative error code on failure.
 driver ioctl 
 core ioctl 
 Do not trust userspace, use our own definition 
  drm_ioctl_flags - Check for core ioctl and return ioctl permission flags
  @nr: ioctl number
  @flags: where to return the ioctl permission flags
  This ioctl is only used by the vmwgfx driver to augment the access checks
  done by the drm core and insofar a pretty decent layering violation. This
  shouldn't be used by any drivers.
  Returns:
  True if the @nr corresponds to a DRM core ioctl number, false otherwise.
 SPDX-License-Identifier: GPL-2.0-only
  DOC: overview
  A set of helper functions to aid DRM drivers in parsing standard DT
  properties.
  drm_of_crtc_port_mask - find the mask of a registered CRTC by port OF node
  @dev: DRM device
  @port: port OF node
  Given a port OF node, return the possible mask of the corresponding
  CRTC within a device's list of CRTCs.  Returns zero if not found.
  drm_of_find_possible_crtcs - find the possible CRTCs for an encoder port
  @dev: DRM device
  @port: encoder port to scan for endpoints
  Scan all endpoints attached to a port, locate their attached CRTCs,
  and generate the DRM mask of CRTCs which may be attached to this
  encoder.
  See Documentationdevicetreebindingsgraph.txt for the bindings.
  drm_of_component_match_add - Add a component helper OF node match rule
  @master: master device
  @matchptr: component match pointer
  @compare: compare function used for matching component
  @node: of_node
  drm_of_component_probe - Generic probe function for a component based master
  @dev: master device containing the OF node
  @compare_of: compare function used for matching components
  @m_ops: component master ops to be used
  Parse the platform device OF node and bind all the components associated
  with the master. Interface ports are added before the encoders in order to
  satisfy their .bind requirements
  See Documentationdevicetreebindingsgraph.txt for the bindings.
  Returns zero if successful, or one of the standard error codes if it fails.
	
	  Bind the crtc's ports first, so that drm_of_find_possible_crtcs()
	  called from encoder's .bind callbacks works as expected
	
	  For bound crtcs, bind the encoders attached to their remote endpoint
  drm_of_encoder_active_endpoint - return the active encoder endpoint
  @node: device tree node containing encoder input ports
  @encoder: drm_encoder
  Given an encoder device node and a drm_encoder with a connected crtc,
  parse the encoder endpoint connecting to the crtc port.
  drm_of_find_panel_or_bridge - return connected panel or bridge device
  @np: device tree node containing encoder output ports
  @port: port in the device tree node
  @endpoint: endpoint in the device tree node
  @panel: pointer to hold returned drm_panel
  @bridge: pointer to hold returned drm_bridge
  Given a DT node's port and endpoint number, find the connected node and
  return either the associated struct drm_panel or drm_bridge device. Either
  @panel or @bridge must not be NULL.
  This function is deprecated and should not be used in new drivers. Use
  devm_drm_of_get_bridge() instead.
  Returns zero if successful, or one of the standard error codes if it fails.
	
	  of_graph_get_remote_node() produces a noisy error message if port
	  node isn't found and the absence of the port is a legit case here,
	  so at first we silently check whether graph presents in the
	  device-tree node.
 No panel found yet, check for a bridge next. 
		
		  Sanity check, ensure that all remote endpoints have the same
		  pixel type. We may lift this restriction later if we need to
		  support multiple sinks with different dual-link
		  configurations by passing the endpoints explicitly to
		  drm_of_lvds_get_dual_link_pixel_order().
  drm_of_lvds_get_dual_link_pixel_order - Get LVDS dual-link pixel order
  @port1: First DT port node of the Dual-link LVDS source
  @port2: Second DT port node of the Dual-link LVDS source
  An LVDS dual-link connection is made of two links, with even pixels
  transitting on one link, and odd pixels on the other link. This function
  returns, for two ports of an LVDS dual-link source, which port shall transmit
  the even and odd pixels, based on the requirements of the connected sink.
  The pixel order is determined from the dual-lvds-even-pixels and
  dual-lvds-odd-pixels properties in the sink's DT port nodes. If those
  properties are not present, or if their usage is not valid, this function
  returns -EINVAL.
  If either port is not connected, this function returns -EPIPE.
  @port1 and @port2 are typically DT sibling nodes, but may have different
  parents when, for instance, two separate LVDS encoders carry the even and odd
  pixels.
  Return:
   DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS - @port1 carries even pixels and @port2
    carries odd pixels
   DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS - @port1 carries odd pixels and @port2
    carries even pixels
   -EINVAL - @port1 and @port2 are not connected to a dual-link LVDS sink, or
    the sink configuration is invalid
   -EPIPE - when @port1 or @port2 are not connected
	
	  A valid dual-lVDS bus is found when one remote port is marked with
	  "dual-lvds-even-pixels", and the other remote port is marked with
	  "dual-lvds-odd-pixels", bail out if the markers are not right.
  Copyright (c) 2016 Intel Corporation
  Permission to use, copy, modify, distribute, and sell this software and its
  documentation for any purpose is hereby granted without fee, provided that
  the above copyright notice appear in all copies and that both that copyright
  notice and this permission notice appear in supporting documentation, and
  that the name of the copyright holders not be used in advertising or
  publicity pertaining to distribution of the software without specific,
  written prior permission.  The copyright holders make no representations
  about the suitability of this software for any purpose.  It is provided "as
  is" without express or implied warranty.
  THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
  EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
  DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
  OF THIS SOFTWARE.
  DOC: aux kms helpers
  This helper library contains various one-off functions which don't really fit
  anywhere else in the DRM modeset helper library.
  drm_helper_move_panel_connectors_to_head() - move panels to the front in the
  						connector list
  @dev: drm device to operate on
  Some userspace presumes that the first connected connector is the main
  display, where it's supposed to display e.g. the login screen. For
  laptops, this should be the main panel. Use this function to sort all
  (eDPLVDSDSI) panels to the front of the connector list, instead of
  painstakingly trying to initialize them in the right order.
  drm_helper_mode_fill_fb_struct - fill out framebuffer metadata
  @dev: DRM device
  @fb: drm_framebuffer object to fill out
  @mode_cmd: metadata from the userspace fb creation request
  This helper can be used in a drivers fb_create callback to pre-fill the fb's
  metadata fields.
  This is the minimal list of formats that seem to be safe for modeset use
  with all current DRM drivers.  Most hardware can actually support more
  formats than this and drivers may specify a more accurate list when
  creating the primary plane.  However drivers that still call
  drm_plane_init() will use this minimal format list as the default.
	
	  Remove the format_default field from drm_plane when dropping
	  this helper.
 possible_crtc's will be filled in later by crtc_init 
  drm_crtc_init - Legacy CRTC initialization function
  @dev: DRM device
  @crtc: CRTC object to init
  @funcs: callbacks for the new CRTC
  Initialize a CRTC object with a default helper-provided primary plane and no
  cursor plane.
  Note that we make some assumptions about hardware limitations that may not be
  true for all hardware:
  1. Primary plane cannot be repositioned.
  2. Primary plane cannot be scaled.
  3. Primary plane must cover the entire CRTC.
  4. Subpixel positioning is not supported.
  5. The primary plane must always be on if the CRTC is enabled.
  This is purely a backwards compatibility helper for old drivers. Drivers
  should instead implement their own primary plane. Atomic drivers must do so.
  Drivers with the above hardware restriction can look into using &struct
  drm_simple_display_pipe, which encapsulates the above limitations into a nice
  interface.
  Returns:
  Zero on success, error code on failure.
  drm_mode_config_helper_suspend - Modeset suspend helper
  @dev: DRM device
  This helper function takes care of suspending the modeset side. It disables
  output polling if initialized, suspends fbdev if used and finally calls
  drm_atomic_helper_suspend().
  If suspending fails, fbdev and polling is re-enabled.
  Returns:
  Zero on success, negative error code on error.
  See also:
  drm_kms_helper_poll_disable() and drm_fb_helper_set_suspend_unlocked().
  drm_mode_config_helper_resume - Modeset resume helper
  @dev: DRM device
  This helper function takes care of resuming the modeset side. It calls
  drm_atomic_helper_resume(), resumes fbdev if used and enables output polling
  if initiaized.
  Returns:
  Zero on success, negative error code on error.
  See also:
  drm_fb_helper_set_suspend_unlocked() and drm_kms_helper_poll_enable().
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright (C) 2016 Noralf Trnnes
  DOC: overview
  This helper library provides helpers for drivers for simple display
  hardware.
  drm_simple_display_pipe_init() initializes a simple display pipeline
  which has only one full-screen scanout buffer feeding one output. The
  pipeline is represented by &struct drm_simple_display_pipe and binds
  together &drm_plane, &drm_crtc and &drm_encoder structures into one fixed
  entity. Some flexibility for code reuse is provided through a separately
  allocated &drm_connector object and supporting optional &drm_bridge
  encoder drivers.
  Many drivers require only a very simple encoder that fulfills the minimum
  requirements of the display pipeline and does not add additional
  functionality. The function drm_simple_encoder_init() provides an
  implementation of such an encoder.
  drm_simple_encoder_init - Initialize a preallocated encoder with
                            basic functionality.
  @dev: drm device
  @encoder: the encoder to initialize
  @encoder_type: user visible type of the encoder
  Initialises a preallocated encoder that has no further functionality.
  Settings for possible CRTC and clones are left to their initial values.
  The encoder will be cleaned up automatically as part of the mode-setting
  cleanup.
  The caller of drm_simple_encoder_init() is responsible for freeing
  the encoder's memory after the encoder has been cleaned up. At the
  moment this only works reliably if the encoder data structure is
  stored in the device structure. Free the encoder's memory as part of
  the device release function.
  Note: consider using drmm_simple_encoder_alloc() instead of
  drm_simple_encoder_init() to let the DRM managed resource infrastructure
  take care of cleanup and deallocation.
  Returns:
  Zero on success, error code on failure.
 Anything goes 
 We always want to have an active plane with an active CRTC 
  drm_simple_display_pipe_attach_bridge - Attach a bridge to the display pipe
  @pipe: simple display pipe object
  @bridge: bridge to attach
  Makes it possible to still use the drm_simple_display_pipe helpers when
  a DRM bridge has to be used.
  Note that you probably want to initialize the pipe by passing a NULL
  connector to drm_simple_display_pipe_init().
  Returns:
  Zero on success, negative error code on failure.
  drm_simple_display_pipe_init - Initialize a simple display pipeline
  @dev: DRM device
  @pipe: simple display pipe object to initialize
  @funcs: callbacks for the display pipe (optional)
  @formats: array of supported formats (DRM_FORMAT\_\)
  @format_count: number of elements in @formats
  @format_modifiers: array of formats modifiers
  @connector: connector to attach and register (optional)
  Sets up a display pipeline which consist of a really simple
  plane-crtc-encoder pipe.
  If a connector is supplied, the pipe will be coupled with the provided
  connector. You may supply a NULL connector when using drm bridges, that
  handle connectors themselves (see drm_simple_display_pipe_attach_bridge()).
  Teardown of a simple display pipe is all handled automatically by the drm
  core through calling drm_mode_config_cleanup(). Drivers afterwards need to
  release the memory for the structure themselves.
  Returns:
  Zero on success, negative error code on failure.
  Copyright  2016 Intel Corporation
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
  DOC: dp dual mode helpers
  Helper functions to deal with DP dual mode (aka. DP++) adaptors.
  Type 1:
  Adaptor registers (if any) and the sink DDC bus may be accessed via I2C.
  Type 2:
  Adaptor registers and sink DDC bus can be accessed either via I2C or
  I2C-over-AUX. Source devices may choose to implement either of these
  access methods.
  drm_dp_dual_mode_read - Read from the DP dual mode adaptor register(s)
  @adapter: I2C adapter for the DDC bus
  @offset: register offset
  @buffer: buffer for return data
  @size: sizo of the buffer
  Reads @size bytes from the DP dual mode adaptor registers
  starting at @offset.
  Returns:
  0 on success, negative error code on failure
  drm_dp_dual_mode_write - Write to the DP dual mode adaptor register(s)
  @adapter: I2C adapter for the DDC bus
  @offset: register offset
  @buffer: buffer for write data
  @size: sizo of the buffer
  Writes @size bytes to the DP dual mode adaptor registers
  starting at @offset.
  Returns:
  0 on success, negative error code on failure
  drm_dp_dual_mode_detect - Identify the DP dual mode adaptor
  @dev: &drm_device to use
  @adapter: I2C adapter for the DDC bus
  Attempt to identify the type of the DP dual mode adaptor used.
  Note that when the answer is @DRM_DP_DUAL_MODE_UNKNOWN it's not
  certain whether we're dealing with a native HDMI port or
  a type 1 DVI dual mode adaptor. The driver will have to use
  some other hardwaredriver specific mechanism to make that
  distinction.
  Returns:
  The type of the DP dual mode adaptor used
	
	  Let's see if the adaptor is there the by reading the
	  HDMI ID registers.
	 
	  Note that type 1 DVI adaptors are not required to implemnt
	  any registers, and that presents a problem for detection.
	  If the i2c transfer is nacked, we may or may not be dealing
	  with a type 1 DVI adaptor. Some other mechanism of detecting
	  the presence of the adaptor is required. One way would be
	  to check the state of the CONFIG1 pin, Another method would
	  simply require the driver to know whether the port is a DP++
	  port or a native HDMI port. Both of these methods are entirely
	  hardwaredriver specific so we can't deal with them here.
	
	  Sigh. Some (maybe all?) type 1 adaptors are broken and ack
	  the offset but ignore it, and instead they just always return
	  data from the start of the HDMI ID buffer. So for a broken
	  type 1 HDMI adaptor a single byte read will always give us
	  0x44, and for a type 1 DVI adaptor it should give 0x00
	  (assuming it implements any registers). Fortunately neither
	  of those values will match the type 2 signature of the
	  DP_DUAL_MODE_ADAPTOR_ID register so we can proceed with
	  the type 2 adaptor detection safely even in the presence
	  of broken type 1 adaptors.
		
		  If neither a proper type 1 ID nor a broken type 1 adaptor
		  as described above, assume type 1, but let the user know
		  that we may have misdetected the type.
  drm_dp_dual_mode_max_tmds_clock - Max TMDS clock for DP dual mode adaptor
  @dev: &drm_device to use
  @type: DP dual mode adaptor type
  @adapter: I2C adapter for the DDC bus
  Determine the max TMDS clock the adaptor supports based on the
  type of the dual mode adaptor and the DP_DUAL_MODE_MAX_TMDS_CLOCK
  register (on type2 adaptors). As some type 1 adaptors have
  problems with registers (see comments in drm_dp_dual_mode_detect())
  we don't read the register on those, instead we simply assume
  a 165 MHz limit based on the specification.
  Returns:
  Maximum supported TMDS clock rate for the DP dual mode adaptor in kHz.
 native HDMI so no limit 
	
	  Type 1 adaptors are limited to 165MHz
	  Type 2 adaptors can tells us their limit
  drm_dp_dual_mode_get_tmds_output - Get the state of the TMDS output buffers in the DP dual mode adaptor
  @dev: &drm_device to use
  @type: DP dual mode adaptor type
  @adapter: I2C adapter for the DDC bus
  @enabled: current state of the TMDS output buffers
  Get the state of the TMDS output buffers in the adaptor. For
  type2 adaptors this is queried from the DP_DUAL_MODE_TMDS_OEN
  register. As some type 1 adaptors have problems with registers
  (see comments in drm_dp_dual_mode_detect()) we don't read the
  register on those, instead we simply assume that the buffers
  are always enabled.
  Returns:
  0 on success, negative error code on failure
  drm_dp_dual_mode_set_tmds_output - Enabledisable TMDS output buffers in the DP dual mode adaptor
  @dev: &drm_device to use
  @type: DP dual mode adaptor type
  @adapter: I2C adapter for the DDC bus
  @enable: enable (as opposed to disable) the TMDS output buffers
  Set the state of the TMDS output buffers in the adaptor. For
  type2 this is set via the DP_DUAL_MODE_TMDS_OEN register. As
  some type 1 adaptors have problems with registers (see comments
  in drm_dp_dual_mode_detect()) we avoid touching the register,
  making this function a no-op on type 1 adaptors.
  Returns:
  0 on success, negative error code on failure
	
	  LSPCON adapters in low-power state may ignore the first write, so
	  read back and verify the written value a few times.
  drm_dp_get_dual_mode_type_name - Get the name of the DP dual mode adaptor type as a string
  @type: DP dual mode adaptor type
  Returns:
  String representation of the DP dual mode adaptor type
  drm_lspcon_get_mode: Get LSPCON's current mode of operation by
  reading offset (0x80, 0x41)
  @dev: &drm_device to use
  @adapter: I2C-over-aux adapter
  @mode: current lspcon mode of operation output variable
  Returns:
  0 on success, sets the current_mode value to appropriate mode
  -error on failure
 Read Status: i2c over aux 
  drm_lspcon_set_mode: Change LSPCON's mode of operation by
  writing offset (0x80, 0x40)
  @dev: &drm_device to use
  @adapter: I2C-over-aux adapter
  @mode: required mode of operation
  Returns:
  0 on success, -error on failuretimeout
 Change mode 
	
	  Confirm mode change by reading the status bit.
	  Sometimes, it takes a while to change the mode,
	  so wait and retry until time out or done.
  Copyright (c) 2016 Intel Corporation
  Permission to use, copy, modify, distribute, and sell this software and its
  documentation for any purpose is hereby granted without fee, provided that
  the above copyright notice appear in all copies and that both that copyright
  notice and this permission notice appear in supporting documentation, and
  that the name of the copyright holders not be used in advertising or
  publicity pertaining to distribution of the software without specific,
  written prior permission.  The copyright holders make no representations
  about the suitability of this software for any purpose.  It is provided "as
  is" without express or implied warranty.
  THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
  EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
  DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
  OF THIS SOFTWARE.
  DOC: overview
  Frame buffers are abstract memory objects that provide a source of pixels to
  scanout to a CRTC. Applications explicitly request the creation of frame
  buffers through the DRM_IOCTL_MODE_ADDFB(2) ioctls and receive an opaque
  handle that can be passed to the KMS CRTC control, plane configuration and
  page flip functions.
  Frame buffers rely on the underlying memory manager for allocating backing
  storage. When creating a frame buffer applications pass a memory handle
  (or a list of memory handles for multi-planar formats) through the
  &struct drm_mode_fb_cmd2 argument. For drivers using GEM as their userspace
  buffer management interface this would be a GEM handle.  Drivers are however
  free to use their own backing storage object handles, e.g. vmwgfx directly
  exposes special TTM handles to userspace and so expects TTM handles in the
  create ioctl and not GEM handles.
  Framebuffers are tracked with &struct drm_framebuffer. They are published
  using drm_framebuffer_init() - after calling that function userspace can use
  and access the framebuffer object. The helper function
  drm_helper_mode_fill_fb_struct() can be used to pre-fill the required
  metadata fields.
  The lifetime of a drm framebuffer is controlled with a reference count,
  drivers can grab additional references with drm_framebuffer_get() and drop
  them again with drm_framebuffer_put(). For driver-private framebuffers for
  which the last reference is never dropped (e.g. for the fbdev framebuffer
  when the struct &struct drm_framebuffer is embedded into the fbdev helper
  struct) drivers can manually clean up a framebuffer at module unload time
  with drm_framebuffer_unregister_private(). But doing this is not
  recommended, and it's better to have a normal free-standing &struct
  drm_framebuffer.
 Make sure source coordinates are inside the fb. 
  drm_mode_addfb - add an FB to the graphics configuration
  @dev: drm device for the ioctl
  @or: pointer to request structure
  @file_priv: drm file
  Add a new FB to the specified CRTC, given a user request. This is the
  original addfb ioctl which only supported RGB formats.
  Called by the user via ioctl, or by an in-kernel client.
  Returns:
  Zero on success, negative errno on failure.
 convert to new format and call new ioctl 
 check if the format is supported at all 
 now let the driver pick its own format info 
 modifier specific checks: 
			 NOTE: the pitch restriction may be lifted later if it turns
			  out that no hw has this restriction:
 Pre-FB_MODIFIERS userspace didn't clear the structs properly. 
  drm_mode_addfb2 - add an FB to the graphics configuration
  @dev: drm device for the ioctl
  @data: data pointer for the ioctl
  @file_priv: drm file for the ioctl call
  Add a new FB to the specified CRTC, given a user request with format. This is
  the 2nd version of the addfb ioctl, which supports multi-planar framebuffers
  and uses fourcc codes as pixel format specifiers.
  Called by the user via ioctl.
  Returns:
  Zero on success, negative errno on failure.
 Transfer ownership to the filp for reaping on close 
		
		  Drivers must set the
		  quirk_addfb_prefer_host_byte_order quirk to make
		  the drm_mode_addfb() compat code work correctly on
		  bigendian machines.
		 
		  If they don't they interpret pixel_format values
		  incorrectly for bug compatibility, which in turn
		  implies the ADDFB2 ioctl does not work correctly
		  then.  So block it to make userspace fallback to
		  ADDFB.
  drm_mode_rmfb - remove an FB from the configuration
  @dev: drm device
  @fb_id: id of framebuffer to remove
  @file_priv: drm file
  Remove the specified FB.
  Called by the user via ioctl, or by an in-kernel client.
  Returns:
  Zero on success, negative errno on failure.
 drop the reference we picked up in framebuffer lookup 
	
	  we now own the reference that was stored in the fbs list
	 
	  drm_framebuffer_remove may fail with -EINTR on pending signals,
	  so run this in a separate stack as there's no way to correctly
	  handle this after the fb is already removed from the lookup table.
  drm_mode_getfb - get FB info
  @dev: drm device for the ioctl
  @data: data pointer for the ioctl
  @file_priv: drm file for the ioctl call
  Lookup the FB given its ID and return info about it.
  Called by the user via ioctl.
  Returns:
  Zero on success, negative errno on failure.
 Multi-planar framebuffers need getfb2. 
	 GET_FB() is an unprivileged ioctl so we must not return a
	  buffer-handle to non-master processes! For
	  backwards-compatibility reasons, we cannot make GET_FB() privileged,
	  so just return an invalid handle for non-masters.
  drm_mode_getfb2_ioctl - get extended FB info
  @dev: drm device for the ioctl
  @data: data pointer for the ioctl
  @file_priv: drm file for the ioctl call
  Lookup the FB given its ID and return info about it.
  Called by the user via ioctl.
  Returns:
  Zero on success, negative errno on failure.
	 For multi-plane framebuffers, we require the driver to place the
	  GEM objects directly in the drm_framebuffer. For single-plane
	  framebuffers, we can fall back to create_handle.
	 GET_FB2() is an unprivileged ioctl so we must not return a
	  buffer-handle to non masterroot processes! To match GET_FB()
	  just return invalid handles (0) for non mastersroot
	  rather than making GET_FB2() privileged.
		 If we reuse the same object for multiple planes, also
		  return the same handle.
 Delete any previously-created handles on failure. 
			 Zero out any handles identical to the one we just
			  deleted.
  drm_mode_dirtyfb_ioctl - flush frontbuffer rendering on an FB
  @dev: drm device for the ioctl
  @data: data pointer for the ioctl
  @file_priv: drm file for the ioctl call
  Lookup the FB and flush out the damaged area supplied by userspace as a clip
  rectangle list. Generic userspace which does frontbuffer rendering must call
  this ioctl to flush out the changes on manual-update display outputs, e.g.
  usb display-link, mipi manual update panels or edp panel self refresh modes.
  Modesetting drivers which always update the frontbuffer do not need to
  implement the corresponding &drm_framebuffer_funcs.dirty callback.
  Called by the user via ioctl.
  Returns:
  Zero on success, negative errno on failure.
 If userspace annotates copy, clips must come in pairs 
  drm_fb_release - remove and free the FBs on this file
  @priv: drm file for the ioctl
  Destroy all the FBs associated with @filp.
  Called by the user via ioctl.
  Returns:
  Zero on success, negative errno on failure.
	
	  When the file gets released that means no one else can access the fb
	  list any more, so no need to grab fpriv->fbs_lock. And we need to
	  avoid upsetting lockdep since the universal cursor code adds a
	  framebuffer while holding mutex locks.
	 
	  Note that a real deadlock between fpriv->fbs_lock and the modeset
	  locks is impossible here since no one else but this function can get
	  at it any more.
 This drops the fpriv->fbs reference. 
	
	  The lookup idr holds a weak reference, which has not necessarily been
	  removed at this point. Check for that.
  drm_framebuffer_init - initialize a framebuffer
  @dev: DRM device
  @fb: framebuffer to be initialized
  @funcs: ... with these functions
  Allocates an ID for the framebuffer's parent mode object, sets its mode
  functions & device file and adds it to the master fd list.
  IMPORTANT:
  This functions publishes the fb and makes it available for concurrent access
  by other users. Which means by this point the fb _must_ be fully set up -
  since all the fb attributes are invariant over its lifetime, no further
  locking but only correct reference counting is required.
  Returns:
  Zero on success, error code on failure.
  drm_framebuffer_lookup - look up a drm framebuffer and grab a reference
  @dev: drm device
  @file_priv: drm file to check for lease against.
  @id: id of the fb object
  If successful, this grabs an additional reference to the framebuffer -
  callers need to make sure to eventually unreference the returned framebuffer
  again, using drm_framebuffer_put().
  drm_framebuffer_unregister_private - unregister a private fb from the lookup idr
  @fb: fb to unregister
  Drivers need to call this when cleaning up driver-private framebuffers, e.g.
  those used for fbdev. Note that the caller must hold a reference of its own,
  i.e. the object may not be destroyed through this call (since it'll lead to a
  locking inversion).
  NOTE: This function is deprecated. For driver-private framebuffers it is not
  recommended to embed a framebuffer struct info fbdev struct, instead, a
  framebuffer pointer is preferred and drm_framebuffer_put() should be called
  when the framebuffer is to be cleaned up.
 Mark fb as reaped and drop idr ref. 
  drm_framebuffer_cleanup - remove a framebuffer object
  @fb: framebuffer to remove
  Cleanup framebuffer. This function is intended to be used from the drivers
  &drm_framebuffer_funcs.destroy callback. It can also be used to clean up
  driver private framebuffers embedded into a larger structure.
  Note that this function does not remove the fb from active usage - if it is
  still used anywhere, hilarity can ensue since userspace could call getfb on
  the id and get back -EINVAL. Obviously no concern at driver unload time.
  Also, the framebuffer will not be removed from the lookup idr - for
  user-created framebuffers this will happen in in the rmfb ioctl. For
  driver-private objects (e.g. for fbdev) drivers need to explicitly call
  drm_framebuffer_unregister_private.
 This list is only filled when disable_crtcs is set. 
 remove from any CRTC 
 should turn off the crtc 
  drm_framebuffer_remove - remove and unreference a framebuffer object
  @fb: framebuffer to remove
  Scans all the CRTCs and planes in @dev's mode_config.  If they're
  using @fb, removes it, setting it to NULL. Then drops the reference to the
  passed-in framebuffer. Might take the modeset locks.
  Note that this function optimizes the cleanup away if the caller holds the
  last reference to the framebuffer. It is also guaranteed to not take the
  modeset locks in this case.
	
	  drm ABI mandates that we remove any deleted framebuffers from active
	  usage. But since most sane clients only remove framebuffers they no
	  longer need, try to optimize this away.
	 
	  Since we're holding a reference ourselves, observing a refcount of 1
	  means that we're the last holder and can skip it. Also, the refcount
	  can never increase from 1 again, so we don't need any barriers or
	  locks.
	 
	  Note that userspace could try to race with use and instate a new
	  usage _after_ we've cleared all current ones. End result will be an
	  in-use fb with fb-id == 0. Userspace is allowed to shoot its own foot
	  in this manner.
  drm_framebuffer_plane_width - width of the plane given the first plane
  @width: width of the first plane
  @fb: the framebuffer
  @plane: plane index
  Returns:
  The width of @plane, given that the width of the first plane is @width.
  drm_framebuffer_plane_height - height of the plane given the first plane
  @height: height of the first plane
  @fb: the framebuffer
  @plane: plane index
  Returns:
  The height of @plane, given that the height of the first plane is @height.
 SPDX-License-Identifier: GPL-2.0 or MIT
  Copyright 2018 Noralf Trnnes
  DOC: overview
  This library provides support for clients running in the kernel like fbdev and bootsplash.
  GEM drivers which provide a GEM based dumb buffer with a virtual address are supported.
  drm_client_init - Initialise a DRM client
  @dev: DRM device
  @client: DRM client
  @name: Client name
  @funcs: DRM client functions (optional)
  This initialises the client and opens a &drm_file.
  Use drm_client_register() to complete the process.
  The caller needs to hold a reference on @dev before calling this function.
  The client is freed when the &drm_device is unregistered. See drm_client_release().
  Returns:
  Zero on success or negative error code on failure.
  drm_client_register - Register client
  @client: DRM client
  Add the client to the &drm_device client list to activate its callbacks.
  @client must be initialized by a call to drm_client_init(). After
  drm_client_register() it is no longer permissible to call drm_client_release()
  directly (outside the unregister callback), instead cleanup will happen
  automatically on driver unload.
  drm_client_release - Release DRM client resources
  @client: DRM client
  Releases resources by closing the &drm_file that was opened by drm_client_init().
  It is called automatically if the &drm_client_funcs.unregister callback is _not_ set.
  This function should only be called from the unregister callback. An exception
  is fbdev which cannot free the buffer if userspace has open file descriptors.
  Note:
  Clients cannot initiate a release by themselves. This is done to keep the code simple.
  The driver has to be unloaded before the client can be unloaded.
  drm_client_dev_hotplug - Send hotplug event to clients
  @dev: DRM device
  This function calls the &drm_client_funcs.hotplug callback on the attached clients.
  drm_kms_helper_hotplug_event() calls this function, so drivers that use it
  don't need to call this function themselves.
 The first one to return zero gets the privilege to restore 
  drm_client_buffer_vmap - Map DRM client buffer into address space
  @buffer: DRM client buffer
  @map_copy: Returns the mapped memory's address
  This function maps a client buffer into kernel address space. If the
  buffer is already mapped, it returns the existing mapping's address.
  Client buffer mappings are not ref'counted. Each call to
  drm_client_buffer_vmap() should be followed by a call to
  drm_client_buffer_vunmap(); or the client buffer should be mapped
  throughout its lifetime.
  The returned address is a copy of the internal value. In contrast to
  other vmap interfaces, you don't need it for the client's vunmap
  function. So you can modify it at will during blit and draw operations.
  Returns:
 	0 on success, or a negative errno code otherwise.
	
	  FIXME: The dependency on GEM here isn't required, we could
	  convert the driver handle to a dma-buf instead and use the
	  backend-agnostic dma-buf vmap support instead. This would
	  require that the handle2fd prime ioctl is reworked to pull the
	  fd_install step out of the driver backend hooks, to make that
	  final step optional for internal users.
  drm_client_buffer_vunmap - Unmap DRM client buffer
  @buffer: DRM client buffer
  This function removes a client buffer's memory mapping. Calling this
  function is only required by clients that manage their buffer mappings
  by themselves.
 drop the reference we picked up in framebuffer lookup 
  drm_client_framebuffer_create - Create a client framebuffer
  @client: DRM client
  @width: Framebuffer width
  @height: Framebuffer height
  @format: Buffer format
  This function creates a &drm_client_buffer which consists of a
  &drm_framebuffer backed by a dumb buffer.
  Call drm_client_framebuffer_delete() to free the buffer.
  Returns:
  Pointer to a client buffer or an error pointer on failure.
  drm_client_framebuffer_delete - Delete a client framebuffer
  @buffer: DRM client buffer (can be NULL)
  drm_client_framebuffer_flush - Manually flush client framebuffer
  @buffer: DRM client buffer (can be NULL)
  @rect: Damage rectangle (if NULL flushes all)
  This calls &drm_framebuffer_funcs->dirty (if present) to flush buffer changes
  for drivers that need it.
  Returns:
  Zero on success or negative error code on failure.
 SPDX-License-Identifier: GPL-2.0 OR MIT
  Copyright (c) 2006-2009 VMware, Inc., Palo Alto, CA., USA
  Copyright (c) 2012 David Airlie <airlied@linux.ie>
  Copyright (c) 2013 David Herrmann <dh.herrmann@gmail.com>
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
  DOC: vma offset manager
  The vma-manager is responsible to map arbitrary driver-dependent memory
  regions into the linear user address-space. It provides offsets to the
  caller which can then be used on the address_space of the drm-device. It
  takes care to not overlap regions, size them appropriately and to not
  confuse mm-core by inconsistent fake vm_pgoff fields.
  Drivers shouldn't use this for object placement in VMEM. This manager should
  only be used to manage mappings into linear user-space VMs.
  We use drm_mm as backend to manage object allocations. But it is highly
  optimized for allocfree calls, not lookups. Hence, we use an rb-tree to
  speed up offset lookups.
  You must not use multiple offset managers on a single address_space.
  Otherwise, mm-core will be unable to tear down memory mappings as the VM will
  no longer be linear.
  This offset manager works on page-based addresses. That is, every argument
  and return code (with the exception of drm_vma_node_offset_addr()) is given
  in number of pages, not number of bytes. That means, object sizes and offsets
  must always be page-aligned (as usual).
  If you want to get a valid byte-based user-space address for a given offset,
  please see drm_vma_node_offset_addr().
  Additionally to offset management, the vma offset manager also handles access
  management. For every open-file context that is allowed to access a given
  node, you must call drm_vma_node_allow(). Otherwise, an mmap() call on this
  open-file with the offset of the node will fail with -EACCES. To revoke
  access again, use drm_vma_node_revoke(). However, the caller is responsible
  for destroying already existing mappings, if required.
  drm_vma_offset_manager_init - Initialize new offset-manager
  @mgr: Manager object
  @page_offset: Offset of available memory area (page-based)
  @size: Size of available address space range (page-based)
  Initialize a new offset-manager. The offset and area size available for the
  manager are given as @page_offset and @size. Both are interpreted as
  page-numbers, not bytes.
  Addingremoving nodes from the manager is locked internally and protected
  against concurrent access. However, node allocation and destruction is left
  for the caller. While calling into the vma-manager, a given node must
  always be guaranteed to be referenced.
  drm_vma_offset_manager_destroy() - Destroy offset manager
  @mgr: Manager object
  Destroy an object manager which was previously created via
  drm_vma_offset_manager_init(). The caller must remove all allocated nodes
  before destroying the manager. Otherwise, drm_mm will refuse to free the
  requested resources.
  The manager must not be accessed after this function is called.
  drm_vma_offset_lookup_locked() - Find node in offset space
  @mgr: Manager object
  @start: Start address for object (page-based)
  @pages: Size of object (page-based)
  Find a node given a start address and object size. This returns the _best_
  match for the given node. That is, @start may point somewhere into a valid
  region and the given node will be returned, as long as the node spans the
  whole requested area (given the size in number of pages as @pages).
  Note that before lookup the vma offset manager lookup lock must be acquired
  with drm_vma_offset_lock_lookup(). See there for an example. This can then be
  used to implement weakly referenced lookups using kref_get_unless_zero().
  Example:
  ::
      drm_vma_offset_lock_lookup(mgr);
      node = drm_vma_offset_lookup_locked(mgr);
      if (node)
          kref_get_unless_zero(container_of(node, sth, entr));
      drm_vma_offset_unlock_lookup(mgr);
  RETURNS:
  Returns NULL if no suitable node can be found. Otherwise, the best match
  is returned. It's the caller's responsibility to make sure the node doesn't
  get destroyed before the caller can access it.
 verify that the node spans the requested area 
  drm_vma_offset_add() - Add offset node to manager
  @mgr: Manager object
  @node: Node to be added
  @pages: Allocation size visible to user-space (in number of pages)
  Add a node to the offset-manager. If the node was already added, this does
  nothing and return 0. @pages is the size of the object given in number of
  pages.
  After this call succeeds, you can access the offset of the node until it
  is removed again.
  If this call fails, it is safe to retry the operation or call
  drm_vma_offset_remove(), anyway. However, no cleanup is required in that
  case.
  @pages is not required to be the same size as the underlying memory object
  that you want to map. It only limits the size that user-space can map into
  their address space.
  RETURNS:
  0 on success, negative error code on failure.
  drm_vma_offset_remove() - Remove offset node from manager
  @mgr: Manager object
  @node: Node to be removed
  Remove a node from the offset manager. If the node wasn't added before, this
  does nothing. After this call returns, the offset and size will be 0 until a
  new offset is allocated via drm_vma_offset_add() again. Helper functions like
  drm_vma_node_start() and drm_vma_node_offset_addr() will return 0 if no
  offset is allocated.
  drm_vma_node_allow - Add open-file to list of allowed users
  @node: Node to modify
  @tag: Tag of file to remove
  Add @tag to the list of allowed open-files for this node. If @tag is
  already on this list, the ref-count is incremented.
  The list of allowed-users is preserved across drm_vma_offset_add() and
  drm_vma_offset_remove() calls. You may even call it if the node is currently
  not added to any offset-manager.
  You must remove all open-files the same number of times as you added them
  before destroying the node. Otherwise, you will leak memory.
  This is locked against concurrent access internally.
  RETURNS:
  0 on success, negative error code on internal failure (out-of-mem)
	 Preallocate entry to avoid atomic allocations below. It is quite
	  unlikely that an open-file is added twice to a single node so we
	  don't optimize for this case. OOM is checked below only if the entry
  drm_vma_node_revoke - Remove open-file from list of allowed users
  @node: Node to modify
  @tag: Tag of file to remove
  Decrement the ref-count of @tag in the list of allowed open-files on @node.
  If the ref-count drops to zero, remove @tag from the list. You must call
  this once for every drm_vma_node_allow() on @tag.
  This is locked against concurrent access internally.
  If @tag is not on the list, nothing is done.
  drm_vma_node_is_allowed - Check whether an open-file is granted access
  @node: Node to check
  @tag: Tag of file to remove
  Search the list in @node whether @tag is currently on the list of allowed
  open-files (see drm_vma_node_allow()).
  This is locked against concurrent access internally.
  RETURNS:
  true if @filp is on the list
  Copyright (C) 2011-2013 Intel Corporation
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
  drm_rect_intersect - intersect two rectangles
  @r1: first rectangle
  @r2: second rectangle
  Calculate the intersection of rectangles @r1 and @r2.
  @r1 will be overwritten with the intersection.
  RETURNS:
  %true if rectangle @r1 is still visible after the operation,
  %false otherwise.
 Only clip what we have. Keeps the result bounded. 
	
	  Round toward 1.0 when clipping so that we don't accidentally
	  change upscaling to downscaling or vice versa.
  drm_rect_clip_scaled - perform a scaled clip operation
  @src: source window rectangle
  @dst: destination window rectangle
  @clip: clip rectangle
  Clip rectangle @dst by rectangle @clip. Clip rectangle @src by the
  the corresponding amounts, retaining the vertical and horizontal scaling
  factors from @src to @dst.
  RETURNS:
  %true if rectangle @dst is still visible after being clipped,
  %false otherwise.
  drm_rect_calc_hscale - calculate the horizontal scaling factor
  @src: source window rectangle
  @dst: destination window rectangle
  @min_hscale: minimum allowed horizontal scaling factor
  @max_hscale: maximum allowed horizontal scaling factor
  Calculate the horizontal scaling factor as
  (@src width)  (@dst width).
  If the scale is below 1 << 16, round down. If the scale is above
  1 << 16, round up. This will calculate the scale with the most
  pessimistic limit calculation.
  RETURNS:
  The horizontal scaling factor, or errno of out of limits.
  drm_rect_calc_vscale - calculate the vertical scaling factor
  @src: source window rectangle
  @dst: destination window rectangle
  @min_vscale: minimum allowed vertical scaling factor
  @max_vscale: maximum allowed vertical scaling factor
  Calculate the vertical scaling factor as
  (@src height)  (@dst height).
  If the scale is below 1 << 16, round down. If the scale is above
  1 << 16, round up. This will calculate the scale with the most
  pessimistic limit calculation.
  RETURNS:
  The vertical scaling factor, or errno of out of limits.
  drm_rect_debug_print - print the rectangle information
  @prefix: prefix string
  @r: rectangle to print
  @fixed_point: rectangle is in 16.16 fixed point format
  drm_rect_rotate - Rotate the rectangle
  @r: rectangle to be rotated
  @width: Width of the coordinate space
  @height: Height of the coordinate space
  @rotation: Transformation to be applied
  Apply @rotation to the coordinates of rectangle @r.
  @width and @height combined with @rotation define
  the location of the new origin.
  @width correcsponds to the horizontal and @height
  to the vertical axis of the untransformed coordinate
  space.
  drm_rect_rotate_inv - Inverse rotate the rectangle
  @r: rectangle to be rotated
  @width: Width of the coordinate space
  @height: Height of the coordinate space
  @rotation: Transformation whose inverse is to be applied
  Apply the inverse of @rotation to the coordinates
  of rectangle @r.
  @width and @height combined with @rotation define
  the location of the new origin.
  @width correcsponds to the horizontal and @height
  to the vertical axis of the original untransformed
  coordinate space, so that you never have to flip
  them when doing a rotatation and its inverse.
  That is, if you do ::
      drm_rect_rotate(&r, width, height, rotation);
      drm_rect_rotate_inv(&r, width, height, rotation);
  you will always get back the original rectangle.
  Copyright (c) 2015 NVIDIA Corporation. All rights reserved.
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sub license,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial portions
  of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  DOC: scdc helpers
  Status and Control Data Channel (SCDC) is a mechanism introduced by the
  HDMI 2.0 specification. It is a point-to-point protocol that allows the
  HDMI source and HDMI sink to exchange data. The same I2C interface that
  is used to access EDID serves as the transport mechanism for SCDC.
  drm_scdc_read - read a block of data from SCDC
  @adapter: I2C controller
  @offset: start offset of block to read
  @buffer: return location for the block to read
  @size: size of the block to read
  Reads a block of data from SCDC, starting at a given offset.
  Returns:
  0 on success, negative error code on failure.
  drm_scdc_write - write a block of data to SCDC
  @adapter: I2C controller
  @offset: start offset of block to write
  @buffer: block of data to write
  @size: size of the block to write
  Writes a block of data to SCDC, starting at a given offset.
  Returns:
  0 on success, negative error code on failure.
  drm_scdc_get_scrambling_status - what is status of scrambling?
  @adapter: I2C adapter for DDC channel
  Reads the scrambler status over SCDC, and checks the
  scrambling status.
  Returns:
  True if the scrambling is enabled, false otherwise.
  drm_scdc_set_scrambling - enable scrambling
  @adapter: I2C adapter for DDC channel
  @enable: bool to indicate if scrambling is to be enableddisabled
  Writes the TMDS config register over SCDC channel, and:
  enables scrambling when enable = 1
  disables scrambling when enable = 0
  Returns:
  True if scrambling is setreset successfully, false otherwise.
  drm_scdc_set_high_tmds_clock_ratio - set TMDS clock ratio
  @adapter: I2C adapter for DDC channel
  @set: ret or reset the high clock ratio
 	TMDS clock ratio calculations go like this:
 		TMDS character = 10 bit TMDS encoded value
 		TMDS character rate = The rate at which TMDS characters are
 		transmitted (Mcsc)
 		TMDS bit rate = 10x TMDS character rate
 	As per the spec:
 		TMDS clock rate for pixel clock < 340 MHz = 1x the character
 		rate = 110 pixel clock rate
 		TMDS clock rate for pixel clock > 340 MHz = 0.25x the character
 		rate = 140 pixel clock rate
 	Writes to the TMDS config register over SCDC channel, and:
 		sets TMDS clock ratio to 140 when set = 1
 		sets TMDS clock ratio to 110 when set = 0
  Returns:
  True if write is successful, false otherwise.
	
	  The spec says that a source should wait minimum 1ms and maximum
	  100ms after writing the TMDS config for clock ratio. Lets allow a
	  wait of up to 2ms here.
 SPDX-License-Identifier: MIT
  Copyright 2018 Noralf Trnnes
  Copyright (c) 2006-2009 Red Hat Inc.
  Copyright (c) 2006-2008 Intel Corporation
    Jesse Barnes <jesse.barnes@intel.com>
  Copyright (c) 2007 Dave Airlie <airlied@linux.ie>
 Add terminating zero entry to enable index less iteration 
 Cloning is only supported in the single crtc case. 
	 attempt to find a matching mode in the list of modes
	   we have gotten so far, if not add a CVT mode that conforms
 Check (optional) mode name first 
 check widthheight 
 only contemplate cloning in the single crtc case 
 only contemplate cloning if more than one connector is enabled 
 check the command line or if nothing common pick 1024x768 
 try and find a 1024x768 mode on each connector 
 first pass over all the untiled connectors 
 if this tile_pass doesn't cover any of the tiles - keep going 
			
			  find the tile offsets for this pass - need to find
			  all tiles left and above
 got for command line mode first 
 No preferred modes, pick one off the list 
		
		  In case of tiled mode if all tiles not present fallback to
		  first available non tiled mode.
		  After all tiles are present, try to find the tiled mode
		  for all and if tiled mode not present due to fbcon size
		  limitations, use first non tiled mode only for
		  tile 0,0 and set to no mode for all other tiles.
	
	  select a crtc for this connector and then attempt to configure
	  remaining connectors
 ignore cloning unless only a single crtc 
 Try to read the BIOS display configuration and use it for the initial config 
		
		  Make sure we're not trying to drive multiple connectors
		  with a single CRTC, since our cloning support may not
		  match the BIOS.
 go for command line mode first 
 try for preferred next 
 No preferred mode marked by the EDID? Are there any modes? 
 last resort: use current mode 
			
			  IMPORTANT: We want to use the adjusted mode (i.e.
			  after the panel fitter upscaling) as the initial
			  config, not the input mode, which is what crtc->mode
			  usually contains. But since our current
			  code puts a mode derived from the post-pfit timings
			  into crtc->mode this works out correctly.
			 
			  This is crtc->mode and not crtc->state->mode for the
			  fastboot check to work correctly.
		
		  In case of tiled modes, if all tiles are not present
		  then fallback to a non tiled mode.
	
	  If the BIOS didn't enable everything it could, fall back to have the
	  same user experiencing of lighting up as much as possible like the
	  fbdev helper library.
  drm_client_modeset_probe() - Probe for displays
  @client: DRM client
  @width: Maximum display mode width (optional)
  @height: Maximum display mode height (optional)
  This function sets up display pipelines for enabled connectors and stores the
  config in the client's modeset array.
  Returns:
  Zero on success or negative error code on failure.
  drm_client_rotation() - Check the initial rotation value
  @modeset: DRM modeset
  @rotation: Returned rotation value
  This function checks if the primary plane in @modeset can hw rotate
  to match the rotation needed on its connector.
  Note: Currently only 0 and 180 degrees are supported.
  Return:
  True if the plane can do the rotation, false otherwise.
	
	  The panel already defined the default rotation
	  through its orientation. Whatever has been provided
	  on the command line needs to be added to that.
	 
	  Unfortunately, the rotations are at different bit
	  indices, so the math to add them up are not as
	  trivial as they could.
	 
	  Reflections on the other hand are pretty trivial to deal with, a
	  simple XOR between the two handle the addition nicely.
	
	  TODO: support 90  270 degree hardware rotation,
	  depending on the hardware this may require the framebuffer
	  to be in a specific tiling format.
 disable non-primary: 
 Cannot fail as we've already gotten the plane state above 
		
		  __drm_atomic_helper_set_config() sets active when a
		  mode is set, unconditionally clear it if we force DPMS off
  drm_client_modeset_check() - Check modeset configuration
  @client: DRM client
  Check modeset configuration.
  Returns:
  Zero on success or negative error code on failure.
  drm_client_modeset_commit_locked() - Force commit CRTC configuration
  @client: DRM client
  Commit modeset configuration to crtcs without checking if there is a DRM
  master. The assumption is that the caller already holds an internal DRM
  master reference acquired with drm_master_internal_acquire().
  Returns:
  Zero on success or negative error code on failure.
  drm_client_modeset_commit() - Commit CRTC configuration
  @client: DRM client
  Commit modeset configuration to crtcs.
  Returns:
  Zero on success or negative error code on failure.
  drm_client_modeset_dpms() - Set DPMS mode
  @client: DRM client
  @mode: DPMS mode
  Note: For atomic drivers @mode is reduced to onoff.
  Returns:
  Zero on success or negative error code on failure.
  \file drm_dma.c
  DMA IOCTL and function support
  \author Rickard E. (Rik) Faith <faith@valinux.com>
  \author Gareth Hughes <gareth@valinux.com>
  Created: Fri Mar 19 14:30:16 1999 by faith@valinux.com
  Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
  Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
  All Rights Reserved.
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  VA LINUX SYSTEMS ANDOR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
  drm_legacy_dma_setup() - Initialize the DMA data.
  @dev: DRM device.
  Return: zero on success or a negative value on failure.
  Allocate and initialize a drm_device_dma structure.
  drm_legacy_dma_takedown() - Cleanup the DMA resources.
  @dev: DRM device.
  Free all pages associated with DMA buffers, the buffers and pages lists, and
  finally the drm_device::dma structure itself.
 Clear dma buffers 
  drm_legacy_free_buffer() - Free a buffer.
  @dev: DRM device.
  @buf: buffer to free.
  Resets the fields of \p buf.
  drm_legacy_reclaim_buffers() - Reclaim the buffers.
  @dev: DRM device.
  @file_priv: DRM file private.
  Frees each buffer associated with \p file_priv not already on the hardware.
 Buffer already on hardware. 
  MIPI DSI Bus
  Copyright (C) 2012-2013, Samsung Electronics, Co., Ltd.
  Andrzej Hajda <a.hajda@samsung.com>
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sub license, andor sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial portions
  of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
  THE COPYRIGHT HOLDERS, AUTHORS ANDOR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  USE OR OTHER DEALINGS IN THE SOFTWARE.
  DOC: dsi helpers
  These functions contain some common logic and helpers to deal with MIPI DSI
  peripherals.
  Helpers are provided for a number of standard MIPI DSI command as well as a
  subset of the MIPI DCS command set.
 attempt OF style match 
 compare DSI device and driver names 
  of_find_mipi_dsi_device_by_node() - find the MIPI DSI device matching a
     device tree node
  @np: device tree node
  Return: A pointer to the MIPI DSI device corresponding to @np or NULL if no
     such device exists (or has not been registered yet).
  mipi_dsi_device_register_full - create a MIPI DSI device
  @host: DSI host to which this device is connected
  @info: pointer to template containing DSI device information
  Create a MIPI DSI device by using the device information provided by
  mipi_dsi_device_info template
  Returns:
  A pointer to the newly created MIPI DSI device, or, a pointer encoded
  with an error
  mipi_dsi_device_unregister - unregister MIPI DSI device
  @dsi: DSI peripheral device
  devm_mipi_dsi_device_register_full - create a managed MIPI DSI device
  @dev: device to tie the MIPI-DSI device lifetime to
  @host: DSI host to which this device is connected
  @info: pointer to template containing DSI device information
  Create a MIPI DSI device by using the device information provided by
  mipi_dsi_device_info template
  This is the managed version of mipi_dsi_device_register_full() which
  automatically calls mipi_dsi_device_unregister() when @dev is
  unbound.
  Returns:
  A pointer to the newly created MIPI DSI device, or, a pointer encoded
  with an error
  of_find_mipi_dsi_host_by_node() - find the MIPI DSI host matching a
 				     device tree node
  @node: device tree node
  Returns:
  A pointer to the MIPI DSI host corresponding to @node or NULL if no
  such device exists (or has not been registered yet).
 skip nodes without reg property 
  mipi_dsi_attach - attach a DSI device to its DSI host
  @dsi: DSI peripheral
  mipi_dsi_detach - detach a DSI device from its DSI host
  @dsi: DSI peripheral
  devm_mipi_dsi_attach - Attach a MIPI-DSI device to its DSI Host
  @dev: device to tie the MIPI-DSI device attachment lifetime to
  @dsi: DSI peripheral
  This is the managed version of mipi_dsi_attach() which automatically
  calls mipi_dsi_detach() when @dev is unbound.
  Returns:
  0 on success, a negative error code on failure.
  mipi_dsi_packet_format_is_short - check if a packet is of the short format
  @type: MIPI DSI data type of the packet
  Return: true if the packet for the given data type is a short packet, false
  otherwise.
  mipi_dsi_packet_format_is_long - check if a packet is of the long format
  @type: MIPI DSI data type of the packet
  Return: true if the packet for the given data type is a long packet, false
  otherwise.
  mipi_dsi_create_packet - create a packet from a message according to the
      DSI protocol
  @packet: pointer to a DSI packet structure
  @msg: message to translate into a packet
  Return: 0 on success or a negative error code on failure.
 do some minimum sanity checking 
 TODO: compute ECC if hardware support is not available 
	
	  Long write packets contain the word count in header bytes 1 and 2.
	  The payload follows the header and is word count bytes long.
	 
	  Short write packets encode up to two parameters in header bytes 1
	  and 2.
  mipi_dsi_shutdown_peripheral() - sends a Shutdown Peripheral command
  @dsi: DSI peripheral device
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_turn_on_peripheral() - sends a Turn On Peripheral command
  @dsi: DSI peripheral device
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_set_maximum_return_packet_size() - specify the maximum size of the
     the payload in a long packet transmitted from the peripheral back to the
     host processor
  @dsi: DSI peripheral device
  @value: the maximum size of the payload
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_compression_mode() - enabledisable DSC on the peripheral
  @dsi: DSI peripheral device
  @enable: Whether to enable or disable the DSC
  Enable or disable Display Stream Compression on the peripheral using the
  default Picture Parameter Set and VESA DSC 1.1 algorithm.
  Return: 0 on success or a negative error code on failure.
 Note: Needs updating for non-default PPS or algorithm 
  mipi_dsi_picture_parameter_set() - transmit the DSC PPS to the peripheral
  @dsi: DSI peripheral device
  @pps: VESA DSC 1.1 Picture Parameter Set
  Transmit the VESA DSC 1.1 Picture Parameter Set to the peripheral.
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_generic_write() - transmit data using a generic write packet
  @dsi: DSI peripheral device
  @payload: buffer containing the payload
  @size: size of payload buffer
  This function will automatically choose the right data type depending on
  the payload length.
  Return: The number of bytes transmitted on success or a negative error code
  on failure.
  mipi_dsi_generic_read() - receive data using a generic read packet
  @dsi: DSI peripheral device
  @params: buffer containing the request parameters
  @num_params: number of request parameters
  @data: buffer in which to return the received data
  @size: size of receive buffer
  This function will automatically choose the right data type depending on
  the number of parameters passed in.
  Return: The number of bytes successfully read or a negative error code on
  failure.
  mipi_dsi_dcs_write_buffer() - transmit a DCS command with payload
  @dsi: DSI peripheral device
  @data: buffer containing data to be transmitted
  @len: size of transmission buffer
  This function will automatically choose the right data type depending on
  the command payload length.
  Return: The number of bytes successfully transmitted or a negative error
  code on failure.
  mipi_dsi_dcs_write() - send DCS write command
  @dsi: DSI peripheral device
  @cmd: DCS command
  @data: buffer containing the command payload
  @len: command payload length
  This function will automatically choose the right data type depending on
  the command payload length.
  Return: The number of bytes successfully transmitted or a negative error
  code on failure.
 concatenate the DCS command byte and the payload 
  mipi_dsi_dcs_read() - send DCS read request command
  @dsi: DSI peripheral device
  @cmd: DCS command
  @data: buffer in which to receive data
  @len: size of receive buffer
  Return: The number of bytes read or a negative error code on failure.
  mipi_dsi_dcs_nop() - send DCS nop packet
  @dsi: DSI peripheral device
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_dcs_soft_reset() - perform a software reset of the display module
  @dsi: DSI peripheral device
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_dcs_get_power_mode() - query the display module's current power
     mode
  @dsi: DSI peripheral device
  @mode: return location for the current power mode
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_dcs_get_pixel_format() - gets the pixel format for the RGB image
     data used by the interface
  @dsi: DSI peripheral device
  @format: return location for the pixel format
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_dcs_enter_sleep_mode() - disable all unnecessary blocks inside the
     display module except interface communication
  @dsi: DSI peripheral device
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_dcs_exit_sleep_mode() - enable all blocks inside the display
     module
  @dsi: DSI peripheral device
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_dcs_set_display_off() - stop displaying the image data on the
     display device
  @dsi: DSI peripheral device
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_dcs_set_display_on() - start displaying the image data on the
     display device
  @dsi: DSI peripheral device
  Return: 0 on success or a negative error code on failure
  mipi_dsi_dcs_set_column_address() - define the column extent of the frame
     memory accessed by the host processor
  @dsi: DSI peripheral device
  @start: first column of frame memory
  @end: last column of frame memory
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_dcs_set_page_address() - define the page extent of the frame
     memory accessed by the host processor
  @dsi: DSI peripheral device
  @start: first page of frame memory
  @end: last page of frame memory
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_dcs_set_tear_off() - turn off the display module's Tearing Effect
     output signal on the TE signal line
  @dsi: DSI peripheral device
  Return: 0 on success or a negative error code on failure
  mipi_dsi_dcs_set_tear_on() - turn on the display module's Tearing Effect
     output signal on the TE signal line.
  @dsi: DSI peripheral device
  @mode: the Tearing Effect Output Line mode
  Return: 0 on success or a negative error code on failure
  mipi_dsi_dcs_set_pixel_format() - sets the pixel format for the RGB image
     data used by the interface
  @dsi: DSI peripheral device
  @format: pixel format
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_dcs_set_tear_scanline() - set the scanline to use as trigger for
     the Tearing Effect output signal of the display module
  @dsi: DSI peripheral device
  @scanline: scanline to use as trigger
  Return: 0 on success or a negative error code on failure
  mipi_dsi_dcs_set_display_brightness() - sets the brightness value of the
     display
  @dsi: DSI peripheral device
  @brightness: brightness value
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_dcs_get_display_brightness() - gets the current brightness value
     of the display
  @dsi: DSI peripheral device
  @brightness: brightness value
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_driver_register_full() - register a driver for DSI devices
  @drv: DSI driver structure
  @owner: owner module
  Return: 0 on success or a negative error code on failure.
  mipi_dsi_driver_unregister() - unregister a driver for DSI devices
  @drv: DSI driver structure
  Return: 0 on success or a negative error code on failure.
  Copyright (C) 2013 Red Hat
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
  drm_flip_work_allocate_task - allocate a flip-work task
  @data: data associated to the task
  @flags: allocator flags
  Allocate a drm_flip_task object and attach private data to it.
  drm_flip_work_queue_task - queue a specific task
  @work: the flip-work
  @task: the task to handle
  Queues task, that will later be run (passed back to drm_flip_func_t
  func) on a work queue after drm_flip_work_commit() is called.
  drm_flip_work_queue - queue work
  @work: the flip-work
  @val: the value to queue
  Queues work, that will later be run (passed back to drm_flip_func_t
  func) on a work queue after drm_flip_work_commit() is called.
  drm_flip_work_commit - commit queued work
  @work: the flip-work
  @wq: the work-queue to run the queued work on
  Trigger work previously queued by drm_flip_work_queue() to run
  on a workqueue.  The typical usage would be to queue work (via
  drm_flip_work_queue()) at any point (from vblank irq andor
  prior), and then from vblank irq commit the queued work.
  drm_flip_work_init - initialize flip-work
  @work: the flip-work to initialize
  @name: debug name
  @func: the callback work function
  Initializesallocates resources for the flip-work
  drm_flip_work_cleanup - cleans up flip-work
  @work: the flip-work to cleanup
  Destroy resources allocated for the flip-work
  \file drm_ioc32.c
  32-bit ioctl compatibility routines for the DRM.
  \author Paul Mackerras <paulus@samba.org>
  Copyright (C) Paul Mackerras 2005.
  All Rights Reserved.
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
 Major version 
 Minor version 
 Patch level 
 Length of name buffer 
 Name of driver 
 Length of date buffer 
 User-space buffer to hold date 
 Length of desc buffer 
 User-space buffer to hold desc 
 Length of unique 
 Unique name for driver instantiation 
 it's dead 
 Requested physical address (0 for SAREA) 
 Requested physical size (bytes) 
 Type of memory to map 
 Flags 
 User-space: "Handle" to pass to mmap() 
 MTRR slot used 
 Which client desired? 
 Is client authenticated? 
 Process ID 
 User ID 
 Magic 
 Ioctl count 
 getstats is defunct, just clear 
 Number of buffers of this size 
 Size in bytes 
 Low water mark 
 High water mark 
 Start address in the AGP aperture 
< Entries in list 
< Index into the master buffer list 
< Buffer size 
< Amount of buffer in use (for DMA) 
< Address of buffer 
< Length of the buffer list 
< Mmap'd area in user-virtual 
< Buffer information 
< Context requesting private mapping 
< Handle of map 
< Context handle 
< Number of buffers to send 
< List of handles to buffers 
< Lengths of data to send 
< Flags 
< Number of buffers requested 
< Desired size for buffers 
< Buffer information 
< Number of buffers granted 
< AGP mode 
 physical address 
 bytes 
 bytes 
 PCI information 
< In bytes -- will round to page boundary 
< Used for binding  unbinding 
< Type of memory to allocate 
< Physical used by i810 
< From drm_agp_buffer 
< In bytes -- will round to page boundary 
 CONFIG_AGP 
< In bytes -- will round to page boundary 
< Used for mapping  unmapping 
 XXX not sure about the handle conversion here... 
 64-bit version has a 32-bit pad here 
< Pointer 
 update_draw is defunct 
  drm_compat_ioctl - 32bit IOCTL compatibility handler for DRM drivers
  @filp: file this ioctl is called on
  @cmd: ioctl cmd number
  @arg: user argument
  Compatibility handler for 32 bit userspace running on 64 kernels. All actual
  IOCTL handling is forwarded to drm_ioctl(), while marshalling structures as
  appropriate. Note that this only handles DRM core IOCTLs, if the driver has
  botched IOCTL itself, it must handle those by wrapping this function.
  Returns:
  Zero on success, negative error code on failure.
	 Assume that ioctls without an explicit compat routine will just
	  work.  This may not always be a good assumption, but it's better
	  than always failing.
  \file drm_memory.c
  Memory management wrappers for DRM
  \author Rickard E. (Rik) Faith <faith@valinux.com>
  \author Gareth Hughes <gareth@valinux.com>
  Created: Thu Feb  4 14:00:34 1999 by faith@valinux.com
  Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
  Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
  All Rights Reserved.
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  VA LINUX SYSTEMS ANDOR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
	
	  OK, we're mapping AGP space on a chipsetplatform on which memory accesses by
	  the CPU do not get remapped by the GART.  We fix this by using the kernel's
	  page-table instead (that's probably faster anyhow...).
 note: use vmalloc() because num_pages could be large... 
  CONFIG_AGP  
 CONFIG_AGP 
  \file drm_agpsupport.c
  DRM support for AGPGART backend
  \author Rickard E. (Rik) Faith <faith@valinux.com>
  \author Gareth Hughes <gareth@valinux.com>
  Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
  Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
  All Rights Reserved.
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  VA LINUX SYSTEMS ANDOR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
  Get AGP information.
  \return zero on success or a negative number on failure.
  Verifies the AGP device has been initialized and acquired and fills in the
  drm_agp_info structure with the information in drm_agp_head::agp_info.
  Acquire the AGP device.
  \param dev DRM device that is to acquire AGP.
  \return zero on success or a negative number on failure.
  Verifies the AGP device hasn't been acquired before and calls
  \c agp_backend_acquire.
  Acquire the AGP device (ioctl).
  \return zero on success or a negative number on failure.
  Verifies the AGP device hasn't been acquired before and calls
  \c agp_backend_acquire.
  Release the AGP device.
  \param dev DRM device that is to release AGP.
  \return zero on success or a negative number on failure.
  Verifies the AGP device has been acquired and calls \c agp_backend_release.
  Enable the AGP bus.
  \param dev DRM device that has previously acquired AGP.
  \param mode Requested AGP mode.
  \return zero on success or a negative number on failure.
  Verifies the AGP device has been acquired but not enabled, and calls
  \c agp_enable.
  Allocate AGP memory.
  \return zero on success or a negative number on failure.
  Verifies the AGP device is present and has been acquired, allocates the
  memory via agp_allocate_memory() and creates a drm_agp_mem entry for it.
  Search for the AGP memory entry associated with a handle.
  \param dev DRM device structure.
  \param handle AGP memory handle.
  \return pointer to the drm_agp_mem structure associated with \p handle.
  Walks through drm_agp_head::memory until finding a matching handle.
  Unbind AGP memory from the GATT (ioctl).
  \return zero on success or a negative number on failure.
  Verifies the AGP device is present and acquired, looks-up the AGP memory
  entry and passes it to the unbind_agp() function.
  Bind AGP memory into the GATT (ioctl)
  \return zero on success or a negative number on failure.
  Verifies the AGP device is present and has been acquired and that no memory
  is currently bound into the GATT. Looks-up the AGP memory entry and passes
  it to bind_agp() function.
  Free AGP memory (ioctl).
  \return zero on success or a negative number on failure.
  Verifies the AGP device is present and has been acquired and looks up the
  AGP memory entry. If the memory is currently bound, unbind it via
  unbind_agp(). Frees it via free_agp() as well as the entry itself
  and unlinks from the doubly linked list it's inserted in.
  Initialize the AGP resources.
  \return pointer to a drm_agp_head structure.
  Gets the drm_agp_t structure which is made available by the agpgart module
  via the inter_module_ functions. Creates and initializes a drm_agp_head
  structure.
  Note that final cleanup of the kmalloced structure is directly done in
  drm_pci_agp_destroy.
 Only exported for i810.ko 
  drm_legacy_agp_clear - Clear AGP resource list
  @dev: DRM device
  Iterate over all AGP resources and remove them. But keep the AGP head
  intact so it can still be used. It is safe to call this if AGP is disabled or
  was already removed.
  Cleanup is only done for drivers who have DRIVER_LEGACY set.
  Created: Tue Feb  2 08:37:54 1999 by faith@valinux.com
  Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
  Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
  All Rights Reserved.
  Author Rickard E. (Rik) Faith <faith@valinux.com>
  Author Gareth Hughes <gareth@valinux.com>
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  VA LINUX SYSTEMS ANDOR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
  DOC: master and authentication
  &struct drm_master is used to track groups of clients with open
  primarylegacy device nodes. For every &struct drm_file which has had at
  least once successfully became the device master (either through the
  SET_MASTER IOCTL, or implicitly through opening the primary device node when
  no one else is the current master that time) there exists one &drm_master.
  This is noted in &drm_file.is_master. All other clients have just a pointer
  to the &drm_master they are associated with.
  In addition only one &drm_master can be the current master for a &drm_device.
  It can be switched through the DROP_MASTER and SET_MASTER IOCTL, or
  implicitly through closingopening the primary device node. See also
  drm_is_current_master().
  Clients can authenticate against the current master (if it matches their own)
  using the GETMAGIC and AUTHMAGIC IOCTLs. Together with exchanging masters,
  this allows controlled access to the device for an entire group of mutually
  trusted clients.
  drm_is_current_master - checks whether @priv is the current master
  @fpriv: DRM file private
  Checks whether @fpriv is current master on its device. This decides whether a
  client is allowed to run DRM_MASTER IOCTLs.
  Most of the modern IOCTL which require DRM_MASTER are for kernel modesetting
  - the current master is assumed to own the non-shareable display hardware.
 initialize the tree of output resource lessees 
  In the olden days the SETDROP_MASTER ioctls used to return EACCES when
  CAP_SYS_ADMIN was not set. This was used to prevent rogue applications
  from becoming master andor failing to release it.
  At the same time, the first client (for a given VT) is _always_ master.
  Thus in order for the ioctls to succeed, one had to _explicitly_ run the
  application as root or flip the setuid bit.
  If the CAP_SYS_ADMIN was missing, no other client could become master...
  EVER :-( Leading to a) the graphics session dying badly or b) a completely
  locked session.
  As some point systemd-logind was introduced to orchestrate and delegate
  master as applicable. It does so by opening the fd and passing it to users
  while in itself logind a) does the setdrop master per users' request and
  b)   implicitly drops master on VT switch.
  Even though logind looks like the future, there are a few issues:
   - some platforms don't have equivalent (Android, CrOS, some BSDs) so
  root is required _solely_ for SETDROP MASTER.
   - applications may not be updated to use it,
   - any client which fails to drop master can DoS the application using
  logind, to a varying degree.
   Either due missing CAP_SYS_ADMIN or simply not calling DROP_MASTER.
  Here we implement the next best thing:
   - ensure the logind style of fd passing works unchanged, and
   - allow a client to dropset master, iff it iswas master at a given point
  in time.
  Note: DROP_MASTER cannot be free for all, as an arbitrator user could:
   - DoScrash the arbitrator - details would be implementation specific
   - open the node, become master implicitly and cause issues
  As a result this fixes the following when using root-less build wo logind
  - startx
  - weston
  - various compositors based on wlroots
	 if there is no current master make this fd it, but do not create
	  any master object for render clients
		 Revoke any leases held by this or lessees, but only if
		  this is the "real" master
 drop the master reference held by the file priv 
  drm_master_get - reference a master pointer
  @master: &struct drm_master
  Increments the reference count of @master and returns a pointer to @master.
  drm_file_get_master - reference &drm_file.master of @file_priv
  @file_priv: DRM file private
  Increments the reference count of @file_priv's &drm_file.master and returns
  the &drm_file.master. If @file_priv has no &drm_file.master, returns NULL.
  Master pointers returned from this function should be unreferenced using
  drm_master_put().
  drm_master_put - unreference and clear a master pointer
  @master: pointer to a pointer of &struct drm_master
  This decrements the &drm_master behind @master and sets it to NULL.
 Used by drm_client and drm_fb_helper 
 Used by drm_client and drm_fb_helper 
  \author Rickard E. (Rik) Faith <faith@valinux.com>
  \author Daryll Strauss <daryll@valinux.com>
  \author Gareth Hughes <gareth@valinux.com>
  Created: Mon Jan  4 08:58:31 1999 by faith@valinux.com
  Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
  Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
  All Rights Reserved.
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  VA LINUX SYSTEMS ANDOR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
 from BKL pushdown 
	
	  Legacy drivers rely on all kinds of BKL locking semantics, don't
	  bother. They also still need BKL locking for their ioctls, so better
	  safe than sorry.
	
	  The deprecated ->load callback must be called after the driver is
	  already registered. This means such drivers rely on the BKL to make
	  sure an open can't proceed until the driver is actually fully set up.
	  Similar hilarity holds for the unload callback.
	
	  Drivers with the lastclose callback assume that it's synchronized
	  against concurrent opens, which again needs the BKL. The proper fix
	  is to use the drm_client infrastructure with proper locking for each
	  client.
  DOC: file operations
  Drivers must define the file operations structure that forms the DRM
  userspace API entry point, even though most of those operations are
  implemented in the DRM core. The resulting &struct file_operations must be
  stored in the &drm_driver.fops field. The mandatory functions are drm_open(),
  drm_read(), drm_ioctl() and drm_compat_ioctl() if CONFIG_COMPAT is enabled
  Note that drm_compat_ioctl will be NULL if CONFIG_COMPAT=n, so there's no
  need to sprinkle #ifdef into the code. Drivers which implement private ioctls
  that require 3264 bit compatibility support must provide their own
  &file_operations.compat_ioctl handler that processes private ioctls and calls
  drm_compat_ioctl() for core ioctls.
  In addition drm_read() and drm_poll() provide support for DRM events. DRM
  events are a generic and extensible means to send asynchronous events to
  userspace through the file descriptor. They are used to send vblank event and
  page flip completions by the KMS API. But drivers can also use it for their
  own needs, e.g. to signal completion of rendering.
  For the driver-side event interface see drm_event_reserve_init() and
  drm_send_event() as the main starting points.
  The memory mapping implementation will vary depending on how the driver
  manages memory. Legacy drivers will use the deprecated drm_legacy_mmap()
  function, modern drivers should use one of the provided memory-manager
  specific implementations. For GEM-based drivers this is drm_gem_mmap().
  No other file operations are supported by the DRM userspace API. Overall the
  following is an example &file_operations structure::
      static const example_drm_fops = {
              .owner = THIS_MODULE,
              .open = drm_open,
              .release = drm_release,
              .unlocked_ioctl = drm_ioctl,
              .compat_ioctl = drm_compat_ioctl,  NULL if CONFIG_COMPAT=n
              .poll = drm_poll,
              .read = drm_read,
              .llseek = no_llseek,
              .mmap = drm_gem_mmap,
      };
  For plain GEM based drivers there is the DEFINE_DRM_GEM_FOPS() macro, and for
  CMA based drivers there is the DEFINE_DRM_GEM_CMA_FOPS() macro to make this
  simpler.
  The driver's &file_operations must be stored in &drm_driver.fops.
  For driver-private IOCTL handling see the more detailed discussion in
  :ref:`IOCTL support in the userland interfaces chapter<drm_driver_ioctl>`.
  drm_file_alloc - allocate file context
  @minor: minor to allocate on
  This allocates a new DRM file context. It is not linked into any context and
  can be used by the caller freely. Note that the context keeps a pointer to
  @minor, so it must be freed before @minor is.
  RETURNS:
  Pointer to newly allocated context, ERR_PTR on failure.
 for compatibility root is always authenticated 
 set aside 4k for event buffer 
 Unlink pending events 
 Remove unconsumed events 
  drm_file_free - free file context
  @file: context to free, or NULL
  This destroys and deallocates a DRM file context previously allocated via
  drm_file_alloc(). The caller must make sure to unlink it from any contexts
  before calling this.
  If NULL is passed, this is a no-op.
  Check whether DRI will run on this CPU.
  \return non-zero if the DRI will run on this CPU, or zero otherwise.
 No cmpxchg before v9 sparc. 
  Called whenever a process opens a drm node
  \param filp file pointer.
  \param minor acquired minor-object.
  \return zero on success or a negative number on failure.
  Creates and initializes a drm_file structure for the file private data in \p
  filp and add it into the double linked list in \p dev.
 No exclusive opens 
	
	  Default the hose
  drm_open - open method for DRM file
  @inode: device inode
  @filp: file pointer.
  This function must be used by drivers as their &file_operations.open method.
  It looks up the correct DRM device and instantiates all the per-file
  resources for it. It also calls the &drm_driver.open driver callback.
  RETURNS:
  0 on success or negative errno value on failure.
 share address_space across all char-devs of a single device 
  drm_release - release method for DRM file
  @inode: device inode
  @filp: file pointer.
  This function must be used by drivers as their &file_operations.release
  method. It frees any resources associated with the open file, and calls the
  &drm_driver.postclose driver callback. If this is the last open file for the
  DRM device also proceeds to call the &drm_driver.lastclose driver callback.
  RETURNS:
  Always succeeds and returns 0.
  drm_release_noglobal - release method for DRM file
  @inode: device inode
  @filp: file pointer.
  This function may be used by drivers as their &file_operations.release
  method. It frees any resources associated with the open file prior to taking
  the drm_global_mutex, which then calls the &drm_driver.postclose driver
  callback. If this is the last open file for the DRM device also proceeds to
  call the &drm_driver.lastclose driver callback.
  RETURNS:
  Always succeeds and returns 0.
  drm_read - read method for DRM file
  @filp: file pointer
  @buffer: userspace destination pointer for the read
  @count: count in bytes to read
  @offset: offset to read
  This function must be used by drivers as their &file_operations.read
  method if they use DRM events for asynchronous signalling to userspace.
  Since events are used by the KMS API for vblank and page flip completion this
  means all modern display drivers must use it.
  @offset is ignored, DRM events are read like a pipe. Therefore drivers also
  must set the &file_operation.llseek to no_llseek(). Polling support is
  provided by drm_poll().
  This function will only ever read a full event. Therefore userspace must
  supply a big enough buffer to fit any event to ensure forward progress. Since
  the maximum event space is currently 4K it's recommended to just use that for
  safety.
  RETURNS:
  Number of bytes read (always aligned to full events, and can be 0) or a
  negative error code on failure.
  drm_poll - poll method for DRM file
  @filp: file pointer
  @wait: poll waiter table
  This function must be used by drivers as their &file_operations.read method
  if they use DRM events for asynchronous signalling to userspace.  Since
  events are used by the KMS API for vblank and page flip completion this means
  all modern display drivers must use it.
  See also drm_read().
  RETURNS:
  Mask of POLL flags indicating the current status of the file.
  drm_event_reserve_init_locked - init a DRM event and reserve space for it
  @dev: DRM device
  @file_priv: DRM file private data
  @p: tracking structure for the pending event
  @e: actual event data to deliver to userspace
  This function prepares the passed in event for eventual delivery. If the event
  doesn't get delivered (because the IOCTL fails later on, before queuing up
  anything) then the even must be cancelled and freed using
  drm_event_cancel_free(). Successfully initialized events should be sent out
  using drm_send_event() or drm_send_event_locked() to signal completion of the
  asynchronous event to userspace.
  If callers embedded @p into a larger structure it must be allocated with
  kmalloc and @p must be the first member element.
  This is the locked version of drm_event_reserve_init() for callers which
  already hold &drm_device.event_lock.
  RETURNS:
  0 on success or a negative error code on failure.
  drm_event_reserve_init - init a DRM event and reserve space for it
  @dev: DRM device
  @file_priv: DRM file private data
  @p: tracking structure for the pending event
  @e: actual event data to deliver to userspace
  This function prepares the passed in event for eventual delivery. If the event
  doesn't get delivered (because the IOCTL fails later on, before queuing up
  anything) then the even must be cancelled and freed using
  drm_event_cancel_free(). Successfully initialized events should be sent out
  using drm_send_event() or drm_send_event_locked() to signal completion of the
  asynchronous event to userspace.
  If callers embedded @p into a larger structure it must be allocated with
  kmalloc and @p must be the first member element.
  Callers which already hold &drm_device.event_lock should use
  drm_event_reserve_init_locked() instead.
  RETURNS:
  0 on success or a negative error code on failure.
  drm_event_cancel_free - free a DRM event and release its space
  @dev: DRM device
  @p: tracking structure for the pending event
  This function frees the event @p initialized with drm_event_reserve_init()
  and releases any allocated space. It is used to cancel an event when the
  nonblocking operation could not be submitted and needed to be aborted.
  drm_send_event_timestamp_locked - send DRM event to file descriptor
  @dev: DRM device
  @e: DRM event to deliver
  @timestamp: timestamp to set for the fence event in kernel's CLOCK_MONOTONIC
  time domain
  This function sends the event @e, initialized with drm_event_reserve_init(),
  to its associated userspace DRM file. Callers must already hold
  &drm_device.event_lock.
  Note that the core will take care of unlinking and disarming events when the
  corresponding DRM file is closed. Drivers need not worry about whether the
  DRM file for this event still exists and can call this function upon
  completion of the asynchronous work unconditionally.
  drm_send_event_locked - send DRM event to file descriptor
  @dev: DRM device
  @e: DRM event to deliver
  This function sends the event @e, initialized with drm_event_reserve_init(),
  to its associated userspace DRM file. Callers must already hold
  &drm_device.event_lock, see drm_send_event() for the unlocked version.
  Note that the core will take care of unlinking and disarming events when the
  corresponding DRM file is closed. Drivers need not worry about whether the
  DRM file for this event still exists and can call this function upon
  completion of the asynchronous work unconditionally.
  drm_send_event - send DRM event to file descriptor
  @dev: DRM device
  @e: DRM event to deliver
  This function sends the event @e, initialized with drm_event_reserve_init(),
  to its associated userspace DRM file. This function acquires
  &drm_device.event_lock, see drm_send_event_locked() for callers which already
  hold this lock.
  Note that the core will take care of unlinking and disarming events when the
  corresponding DRM file is closed. Drivers need not worry about whether the
  DRM file for this event still exists and can call this function upon
  completion of the asynchronous work unconditionally.
  mock_drm_getfile - Create a new struct file for the drm device
  @minor: drm minor to wrap (e.g. #drm_device.primary)
  @flags: file creation mode (O_RDWR etc)
  This create a new struct file that wraps a DRM file context around a
  DRM minor. This mimicks userspace opening e.g. devdricard0, but without
  invoking userspace. The struct file may be operated on using its f_op
  (the drm_device.driver.fops) to mimick userspace operations, or be supplied
  to userspace facing functions as an internalanonymous client.
  RETURNS:
  Pointer to newly created struct file, ERR_PTR on failure.
 Everyone shares a single global address space 
  drm_addr_inflate() attempts to construct an aligned area by inflating
  the area size and skipping the unaligned start of the area.
  adapted from shmem_get_unmapped_area()
  drm_get_unmapped_area() - Get an unused user-space virtual memory area
  suitable for huge page table entries.
  @file: The struct file representing the address space being mmap()'d.
  @uaddr: Start address suggested by user-space.
  @len: Length of the area.
  @pgoff: The page offset into the address space.
  @flags: mmap flags
  @mgr: The address space manager used by the drm driver. This argument can
  probably be removed at some point when all drivers use the same
  address space manager.
  This function attempts to find an unused user-space virtual memory area
  that can accommodate the size we want to map, and that is properly
  aligned to facilitate huge page table entries matching actual
  huge pages or huge page aligned memory in buffer objects. Buffer objects
  are assumed to start at huge page boundary pfns (io memory) or be
  populated by huge pages aligned to the start of the buffer object
  (system- or coherent memory). Adapted from shmem_get_unmapped_area.
  Return: aligned user-space address.
	
	  @pgoff is the file page-offset the huge page boundaries of
	  which typically aligns to physical address huge page boundaries.
	  That's not true for DRM, however, where physical address huge
	  page boundaries instead are aligned with the offset from
	  buffer object start. So adjust @pgoff to be the offset from
	  buffer object start.
	
	  Our priority is to support MAP_SHARED mapped hugely;
	  and support MAP_PRIVATE mapped hugely too, until it is COWed.
	  But if caller specified an address hint, respect that as before.
 CONFIG_TRANSPARENT_HUGEPAGE 
 CONFIG_TRANSPARENT_HUGEPAGE 
 CONFIG_MMU 
 SPDX-License-Identifier: MIT
 for firmware helpers 
  DOC: overview
  A graphics device might be supported by different drivers, but only one
  driver can be active at any given time. Many systems load a generic
  graphics drivers, such as EFI-GOP or VESA, early during the boot process.
  During later boot stages, they replace the generic driver with a dedicated,
  hardware-specific driver. To take over the device the dedicated driver
  first has to remove the generic driver. DRM aperture functions manage
  ownership of DRM framebuffer memory and hand-over between drivers.
  DRM drivers should call drm_aperture_remove_conflicting_framebuffers()
  at the top of their probe function. The function removes any generic
  driver that is currently associated with the given framebuffer memory.
  If the framebuffer is located at PCI BAR 0, the rsp code looks as in the
  example given below.
  .. code-block:: c
 	static const struct drm_driver example_driver = {
 		...
 	};
 	static int remove_conflicting_framebuffers(struct pci_dev pdev)
 	{
 		bool primary = false;
 		resource_size_t base, size;
 		int ret;
 		base = pci_resource_start(pdev, 0);
 		size = pci_resource_len(pdev, 0);
 	#ifdef CONFIG_X86
 		primary = pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW;
 	#endif
 		return drm_aperture_remove_conflicting_framebuffers(base, size, primary,
 		                                                    &example_driver);
 	}
 	static int probe(struct pci_dev pdev)
 	{
 		int ret;
 		 Remove any generic drivers...
 		ret = remove_conflicting_framebuffers(pdev);
 		if (ret)
 			return ret;
 		 ... and initialize the hardware.
 		...
 		drm_dev_register();
 		return 0;
 	}
  PCI device drivers should call
  drm_aperture_remove_conflicting_pci_framebuffers() and let it detect the
  framebuffer apertures automatically. Device drivers without knowledge of
  the framebuffer's location shall call drm_aperture_remove_framebuffers(),
  which removes all drivers for known framebuffer.
  Drivers that are susceptible to being removed by other drivers, such as
  generic EFI or VESA drivers, have to register themselves as owners of their
  given framebuffer memory. Ownership of the framebuffer memory is achieved
  by calling devm_aperture_acquire_from_firmware(). On success, the driver
  is the owner of the framebuffer range. The function fails if the
  framebuffer is already by another driver. See below for an example.
  .. code-block:: c
 	static int acquire_framebuffers(struct drm_device dev, struct platform_device pdev)
 	{
 		resource_size_t base, size;
 		mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 		if (!mem)
 			return -EINVAL;
 		base = mem->start;
 		size = resource_size(mem);
 		return devm_acquire_aperture_from_firmware(dev, base, size);
 	}
 	static int probe(struct platform_device pdev)
 	{
 		struct drm_device dev;
 		int ret;
 		 ... Initialize the device...
 		dev = devm_drm_dev_alloc();
 		...
 		 ... and acquire ownership of the framebuffer.
 		ret = acquire_framebuffers(dev, pdev);
 		if (ret)
 			return ret;
 		drm_dev_register(dev, 0);
 		return 0;
 	}
  The generic driver is now subject to forced removal by other drivers. This
  only works for platform drivers that support hot unplug.
  When a driver calls drm_aperture_remove_conflicting_framebuffers() et al
  for the registered framebuffer range, the aperture helpers call
  platform_device_unregister() and the generic driver unloads itself. It
  may not access the device's registers, framebuffer memory, ROM, etc
  afterwards.
	
	  Remove the device from the device hierarchy. This is the right thing
	  to do for firmware-based DRM drivers, such as EFI, VESA or VGA. After
	  the new driver takes over the hardware, the firmware device's state
	  will be lost.
	 
	  For non-platform devices, a new callback would be required.
	 
	  If the aperture helpers ever need to handle native drivers, this call
	  would only have to unplug the DRM device, so that the hardware device
	  stays around after detachment.
  devm_aperture_acquire_from_firmware - Acquires ownership of a firmware framebuffer
                                        on behalf of a DRM driver.
  @dev:	the DRM device to own the framebuffer memory
  @base:	the framebuffer's byte offset in physical memory
  @size:	the framebuffer size in bytes
  Installs the given device as the new owner of the framebuffer. The function
  expects the framebuffer to be provided by a platform device that has been
  set up by firmware. Firmware can be any generic interface, such as EFI,
  VESA, VGA, etc. If the native hardware driver takes over ownership of the
  framebuffer range, the firmware state gets lost. Aperture helpers will then
  unregister the platform device automatically. Acquired apertures are
  released automatically if the underlying device goes away.
  The function fails if the framebuffer range, or parts of it, is currently
  owned by another driver. To evict current owners, callers should use
  drm_aperture_remove_conflicting_framebuffers() et al. before calling this
  function. The function also fails if the given device is not a platform
  device.
  Returns:
  0 on success, or a negative errno value otherwise.
 detach from device 
  drm_aperture_remove_conflicting_framebuffers - remove existing framebuffers in the given range
  @base: the aperture's base address in physical memory
  @size: aperture size in bytes
  @primary: also kick vga16fb if present
  @req_driver: requesting DRM driver
  This function removes graphics device drivers which use memory range described by
  @base and @size.
  Returns:
  0 on success, or a negative errno code otherwise
  drm_aperture_remove_conflicting_pci_framebuffers - remove existing framebuffers for PCI devices
  @pdev: PCI device
  @req_driver: requesting DRM driver
  This function removes graphics device drivers using memory range configured
  for any of @pdev's memory bars. The function assumes that PCI device with
  shadowed ROM drives a primary display and so kicks out vga16fb.
  Returns:
  0 on success, or a negative errno code otherwise
	
	  WARNING: Apparently we must kick fbdev drivers before vgacon,
	  otherwise the vga fbdev driver falls over.
 SPDX-License-Identifier: GPL-2.0-or-later
  MIPI Display Bus Interface (DBI) LCD controller support
  Copyright 2016 Noralf Trnnes
 2MHz 
  DOC: overview
  This library provides helpers for MIPI Display Bus Interface (DBI)
  compatible display controllers.
  Many controllers for tiny lcd displays are MIPI compliant and can use this
  library. If a controller uses registers 0x2A and 0x2B to set the area to
  update and uses register 0x2C to write to frame memory, it is most likely
  MIPI compliant.
  Only MIPI Type 1 displays are supported since a full frame memory is needed.
  There are 3 MIPI DBI implementation types:
  A. Motorola 6800 type parallel bus
  B. Intel 8080 type parallel bus
  C. SPI type with 3 options:
     1. 9-bit with the DataCommand signal as the ninth bit
     2. Same as above except it's sent as 16 bits
     3. 8-bit with the DataCommand signal as a separate DCX pin
  Currently mipi_dbi only supports Type C options 1 and 3 with
  mipi_dbi_spi_init().
 sentinel 
  mipi_dbi_command_read - MIPI DCS read command
  @dbi: MIPI DBI structure
  @cmd: Command
  @val: Value read
  Send MIPI DCS read command to the controller.
  Returns:
  Zero on success, negative error code on failure.
  mipi_dbi_command_buf - MIPI DCS command with parameter(s) in an array
  @dbi: MIPI DBI structure
  @cmd: Command
  @data: Parameter buffer
  @len: Buffer length
  Returns:
  Zero on success, negative error code on failure.
 SPI requires dma-safe buffers 
 This should only be used by mipi_dbi_command() 
  mipi_dbi_buf_copy - Copy a framebuffer, transforming it if necessary
  @dst: The destination buffer
  @fb: The source framebuffer
  @clip: Clipping rectangle of the area to be copied
  @swap: When true, swap MSBLSB of 16-bit values
  Returns:
  Zero on success, negative error code on failure.
  mipi_dbi_pipe_update - Display pipe update helper
  @pipe: Simple display pipe
  @old_state: Old plane state
  This function handles framebuffer flushing and vblank events. Drivers can use
  this as their &drm_simple_display_pipe_funcs->update callback.
  mipi_dbi_enable_flush - MIPI DBI enable helper
  @dbidev: MIPI DBI device structure
  @crtc_state: CRTC state
  @plane_state: Plane state
  Flushes the whole framebuffer and enables the backlight. Drivers can use this
  in their &drm_simple_display_pipe_funcs->enable callback.
  Note: Drivers which don't use mipi_dbi_pipe_update() because they have custom
  framebuffer flushing, can't use this function since they both use the same
  flushing code.
  mipi_dbi_pipe_disable - MIPI DBI pipe disable helper
  @pipe: Display pipe
  This function disables backlight if present, if not the display memory is
  blanked. The regulator is disabled if in use. Drivers can use this as their
  &drm_simple_display_pipe_funcs->disable callback.
  mipi_dbi_dev_init_with_formats - MIPI DBI device initialization with custom formats
  @dbidev: MIPI DBI device structure to initialize
  @funcs: Display pipe functions
  @formats: Array of supported formats (DRM_FORMAT\_\).
  @format_count: Number of elements in @formats
  @mode: Display mode
  @rotation: Initial rotation in degrees Counter Clock Wise
  @tx_buf_size: Allocate a transmit buffer of this size.
  This function sets up a &drm_simple_display_pipe with a &drm_connector that
  has one fixed &drm_display_mode which is rotated according to @rotation.
  This mode is used to set the mode config minmax widthheight properties.
  Use mipi_dbi_dev_init() if you don't need custom formats.
  Note:
  Some of the helper functions expects RGB565 to be the default format and the
  transmit buffer sized to fit that.
  Returns:
  Zero on success, negative error code on failure.
  mipi_dbi_dev_init - MIPI DBI device initialization
  @dbidev: MIPI DBI device structure to initialize
  @funcs: Display pipe functions
  @mode: Display mode
  @rotation: Initial rotation in degrees Counter Clock Wise
  This function sets up a &drm_simple_display_pipe with a &drm_connector that
  has one fixed &drm_display_mode which is rotated according to @rotation.
  This mode is used to set the mode config minmax widthheight properties.
  Additionally &mipi_dbi.tx_buf is allocated.
  Supported formats: Native RGB565 and emulated XRGB8888.
  Returns:
  Zero on success, negative error code on failure.
  mipi_dbi_hw_reset - Hardware reset of controller
  @dbi: MIPI DBI structure
  Reset controller if the &mipi_dbi->reset gpio is set.
  mipi_dbi_display_is_on - Check if display is on
  @dbi: MIPI DBI structure
  This function checks the Power Mode register (if readable) to see if
  display output is turned on. This can be used to see if the bootloader
  has already turned on the display avoiding flicker when the pipeline is
  enabled.
  Returns:
  true if the display can be verified to be on, false otherwise.
 The poweronreset value is 08h DCS_POWER_MODE_DISPLAY_NORMAL_MODE 
	
	  If we did a hw reset, we know the controller is in Sleep mode and
	  per MIPI DSC spec should wait 5ms after soft reset. If we didn't,
	  we assume worst case and wait 120ms.
  mipi_dbi_poweron_reset - MIPI DBI poweron and reset
  @dbidev: MIPI DBI device structure
  This function enables the regulator if used and does a hardware and software
  reset.
  Returns:
  Zero on success, or a negative error code.
  mipi_dbi_poweron_conditional_reset - MIPI DBI poweron and conditional reset
  @dbidev: MIPI DBI device structure
  This function enables the regulator if used and if the display is off, it
  does a hardware and software reset. If mipi_dbi_display_is_on() determines
  that the display is on, no reset is performed.
  Returns:
  Zero if the controller was reset, 1 if the display was already on, or a
  negative error code.
  mipi_dbi_spi_cmd_max_speed - get the maximum SPI bus speed
  @spi: SPI device
  @len: The transfer buffer length.
  Many controllers have a max speed of 10MHz, but can be pushed way beyond
  that. Increase reliability by running pixel data at max speed and the rest
  at 10MHz, preventing transfer glitches from messing up the init settings.
 use default 
  MIPI DBI Type C Option 1
  If the SPI controller doesn't have 9 bits per word support,
  use blocks of 9 bytes to send 8x 9-bit words using a 8-bit SPI transfer.
  Pad partial blocks with MIPI_DCS_NOP (zero).
  This is how the DC bit (x) is added:
      x7654321
      0x765432
      10x76543
      210x7654
      3210x765
      43210x76
      543210x7
      6543210x
      76543210
 Command: pad no-op's (zeroes) at beginning of block 
 max with room for adding one bit per byte 
 but no bigger than len 
 8 byte blocks 
 Data: pad no-op's (zeroes) at end of block 
		
		  FIXME: implement something like mipi_dbi_spi1e_transfer() but
		  for reads using emulation.
	
	  Turn the 8bit command into a 16bit version of the command in the
	  buffer. Only 9 bits of this will be used when executing the actual
	  transfer.
 MIPI DBI Type C Option 3 
	
	  Support non-standard 24-bit and 32-bit Nokia read commands which
	  start with a dummy clock, so we need to read an extra byte.
  mipi_dbi_spi_init - Initialize MIPI DBI SPI interface
  @spi: SPI device
  @dbi: MIPI DBI structure to initialize
  @dc: DC gpio (optional)
  This function sets &mipi_dbi->command, enables &mipi_dbi->read_commands for the
  usual read commands. It should be followed by a call to mipi_dbi_dev_init() or
  a driver-specific init.
  If @dc is set, a Type C Option 3 interface is assumed, if not
  Type C Option 1.
  If the SPI master driver doesn't support the necessary bits per word,
  the following transformation is used:
  - 9-bit: reorder buffer as 9x 8-bit words, padded with no-op command.
  - 16-bit: if big endian send as 8-bit, if little endian swap bytes
  Returns:
  Zero on success, negative error code on failure.
	
	  Even though it's not the SPI device that does DMA (the master does),
	  the dma mask is necessary for the dma_alloc_wc() in
	  drm_gem_cma_create(). The dma_addr returned will be a physical
	  address which might be different from the bus address, but this is
	  not a problem since the address will not be used.
	  The virtual address is used in the transfer and the SPI core
	  re-maps it on the SPI master device using the DMA streaming API
	  (spi_map_buf()).
  mipi_dbi_spi_transfer - SPI transfer helper
  @spi: SPI device
  @speed_hz: Override speed (optional)
  @bpw: Bits per word
  @buf: Buffer to transfer
  @len: Buffer length
  This SPI transfer helper breaks up the transfer of @buf into chunks which
  the SPI controller driver can handle.
  Returns:
  Zero on success, negative error code on failure.
 CONFIG_SPI 
 strip trailing whitespace 
  mipi_dbi_debugfs_init - Create debugfs entries
  @minor: DRM minor
  This function creates a 'command' debugfs file for sending commands to the
  controller or getting the read command values.
  Drivers can use this as their &drm_driver->debugfs_init callback.
 SPDX-License-Identifier: MIT
  Copyright (C) 2019 Google, Inc.
  Authors:
  Sean Paul <seanpaul@chromium.org>
  DOC: overview
  This helper library provides an easy way for drivers to leverage the atomic
  framework to implement panel self refresh (SR) support. Drivers are
  responsible for initializing and cleaning up the SR helpers on loadunload
  (see &drm_self_refresh_helper_init&drm_self_refresh_helper_cleanup).
  The connector is responsible for setting
  &drm_connector_state.self_refresh_aware to true at runtime if it is SR-aware
  (meaning it knows how to initiate self refresh on the panel).
  Once a crtc has enabled SR using &drm_self_refresh_helper_init, the
  helpers will monitor activity and call back into the driver to enabledisable
  SR as appropriate. The best way to think about this is that it's a DPMS
  onoff request with &drm_crtc_state.self_refresh_active set in crtc state
  that tells you to disableenable SR on the panel instead of power-cycling it.
  During SR, drivers may choose to fully disable their crtcencoderbridge
  hardware (in which case no driver changes are necessary), or they can inspect
  &drm_crtc_state.self_refresh_active if they want to enter low power mode
  without full disable (in case full disableenable is too slow).
  SR will be deactivated if there are any atomic updates affecting the
  pipe that is in SR mode. If a crtc is driving multiple connectors, all
  connectors must be SR aware and all will enterexit SR mode at the same time.
  If the crtc and connector are SR aware, but the panel connected does not
  support it (or is otherwise unable to enter SR), the driver should fail
  atomic_check when &drm_crtc_state.self_refresh_active is true.
  drm_self_refresh_helper_update_avg_times - Updates a crtc's SR time averages
  @state: the state which has just been applied to hardware
  @commit_time_ms: the amount of time in ms that this commit took to complete
  @new_self_refresh_mask: bitmask of crtc's that have self_refresh_active in
     new state
  Called after &drm_mode_config_funcs.atomic_commit_tail, this function will
  update the average entryexit self refresh times on self refresh transitions.
  These averages will be used when calculating how long to delay before
  entering self refresh mode after activity.
  drm_self_refresh_helper_alter_state - Alters the atomic state for SR exit
  @state: the state currently being checked
  Called at the end of atomic check. This function checks the state for flags
  incompatible with self refresh exit and changes them. This is a bit
  disingenuous since userspace is expecting one thing and we're giving it
  another. However in order to keep self refresh entirely hidden from
  userspace, this is required.
  At the end, we queue up the self refresh entry work so we can enter PSR after
  the desired delay.
 Don't trigger the entry timer when we're already in SR 
  drm_self_refresh_helper_init - Initializes self refresh helpers for a crtc
  @crtc: the crtc which supports self refresh supported displays
  Returns zero if successful or -errno on failure
 Helper is already initialized 
	
	  Seed the averages so they're non-zero (and sufficiently large
	  for even poorly performing panels). As time goes on, this will be
	  averaged out and the values will trend to their true value.
  drm_self_refresh_helper_cleanup - Cleans up self refresh helpers for a crtc
  @crtc: the crtc to cleanup
 Helper is already uninitialized 
 SPDX-License-Identifier: GPL-2.0
  DisplayPort CEC-Tunneling-over-AUX support
  Copyright 2018 Cisco Systems, Inc. andor its affiliates. All rights reserved.
  Unfortunately it turns out that we have a chicken-and-egg situation
  here. Quite a few active (mini-)DP-to-HDMI or USB-C-to-HDMI adapters
  have a converter chip that supports CEC-Tunneling-over-AUX (usually the
  Parade PS176), but they do not wire up the CEC pin, thus making CEC
  useless. Note that MegaChips 2900-based adapters appear to have good
  support for CEC tunneling. Those adapters that I have tested using
  this chipset all have the CEC line connected.
  Sadly there is no way for this driver to know this. What happens is
  that a devcecX device is created that is isolated and unable to see
  any of the other CEC devices. Quite literally the CEC wire is cut
  (or in this case, never connected in the first place).
  The reason so few adapters support this is that this tunneling protocol
  was never supported by any OS. So there was no easy way of testing it,
  and no incentive to correctly wire up the CEC pin.
  Hopefully by creating this driver it will be easier for vendors to
  finally fix their adapters and test the CEC functionality.
  I keep a list of known working adapters here:
  https:hverkuil.home.xs4all.nlcec-status.txt
  Please mail me (hverkuil@xs4all.nl) if you find an adapter that works
  and is not yet listed there.
  Note that the current implementation does not support CEC over an MST hub.
  As far as I can see there is no mechanism defined in the DisplayPort
  standard to transport CEC interrupts over an MST device. It might be
  possible to do this through polling, but I have not been able to get that
  to work.
  DOC: dp cec helpers
  These functions take care of supporting the CEC-Tunneling-over-AUX
  feature of DisplayPort-to-HDMI adapters.
  When the EDID is unset because the HPD went low, then the CEC DPCD registers
  typically can no longer be read (true for a DP-to-HDMI adapter since it is
  powered by the HPD). However, some displays toggle the HPD off and on for a
  short period for one reason or another, and that would cause the CEC adapter
  to be removed and added again, even though nothing else changed.
  This module parameter sets a delay in seconds before the CEC adapter is
  actually unregistered. Only if the HPD does not return within that time will
  the CEC adapter be unregistered.
  If it is set to a value >= NEVER_UNREG_DELAY, then the CEC adapter will never
  be unregistered for as long as the connector remains registered.
  If it is set to 0, then the CEC adapter will be unregistered immediately as
  soon as the HPD disappears.
  The default is one second to prevent short HPD glitches from unregistering
  the CEC adapter.
  Note that for integrated HDMI branch devices that support CEC the DPCD
  registers remain available even if the HPD goes low since it is not powered
  by the HPD. In that case the CEC adapter will never be unregistered during
  the life time of the connector. At least, this is the theory since I do not
  have hardware with an integrated HDMI branch device that supports CEC.
 Bit 15 (logical address 15) should always be set 
	
	  Show this both in decimal and hex: at least one vendor
	  always reports this in hex.
  drm_dp_cec_irq() - handle CEC interrupt, if any
  @aux: DisplayPort AUX channel
  Should be called when handling an IRQ_HPD request. If CEC-tunneling-over-AUX
  is present, then it will check for a CEC_IRQ and handle it accordingly.
 No transfer function was set, so not a DP connector 
  Called if the HPD was low for more than drm_dp_cec_unregister_delay
  seconds. This unregisters the CEC adapter.
  A new EDID is set. If there is no CEC adapter, then create one. If
  there was a CEC adapter, then check if the CEC adapter properties
  were unchanged and just update the CEC physical address. Otherwise
  unregister the old CEC adapter and create a new one.
 No transfer function was set, so not a DP connector 
	
	  CEC_CAP_RC is part of CEC_CAP_DEFAULTS, but it is stripped by
	  cec_allocate_adapter() if CONFIG_MEDIA_CEC_RC is undefined.
	 
	  Do this here as well to ensure the tests against cec_caps are
	  correct.
 CEC is not supported, unregister any existing adapter 
 Unchanged, so just set the phys addr 
		
		  The capabilities changed, so unregister the old
		  adapter first.
 Create a new adapter 
		
		  Update the phys addr for the new CEC adapter. When called
		  from drm_dp_cec_register_connector() edid == NULL, so in
		  that case the phys addr is just invalidated.
  The EDID disappeared (likely because of the HPD going down).
 No transfer function was set, so not a DP connector 
	
	  We're done if we want to keep the CEC device
	  (drm_dp_cec_unregister_delay is >= NEVER_UNREG_DELAY) or if the
	  DPCD still indicates the CEC capability (expected for an integrated
	  HDMI branch device).
		
		  Unregister the CEC adapter after drm_dp_cec_unregister_delay
		  seconds. This to debounce short HPD off-and-on cycles from
		  displays.
  drm_dp_cec_register_connector() - register a new connector
  @aux: DisplayPort AUX channel
  @connector: drm connector
  A new connector was registered with associated CEC adapter name and
  CEC adapter parent device. After registering the name and parent
  drm_dp_cec_set_edid() is called to check if the connector supports
  CEC and to register a CEC adapter if that is the case.
  drm_dp_cec_unregister_connector() - unregister the CEC adapter, if any
  @aux: DisplayPort AUX channel
  Copyright  2015 Intel Corporation
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
  Authors:
     Rafael Antognolli <rafael.antognolli@intel.com>
	 don't increase kref count here because this function should only be
	  used by drm_dp_aux_unregister_devnode. Thus, it will always have at
	  least one reference - the one that drm_dp_aux_register_devnode
	  created
 attach must have failed 
	
	  As some AUX adapters may exist as platform devices which outlive their respective DRM
	  devices, we clear drm_dev to ensure that we never accidentally reference a stale pointer
  \file drm_lock.c
  IOCTLs for locking
  \author Rickard E. (Rik) Faith <faith@valinux.com>
  \author Gareth Hughes <gareth@valinux.com>
  Created: Tue Feb  2 08:37:54 1999 by faith@valinux.com
  Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
  Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
  All Rights Reserved.
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  VA LINUX SYSTEMS ANDOR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
  Take the heavyweight lock.
  \param lock lock pointer.
  \param context locking context.
  \return one if the lock is held, or zero otherwise.
  Attempt to mark the lock as held by the given context, via the \p cmpxchg instruction.
 Have lock 
  This takes a lock forcibly and hands it to context.	Should ONLY be used
  inside _unlock to give lock to kernel before calling _dma_schedule.
  \param dev DRM device.
  \param lock lock pointer.
  \param context locking context.
  \return always one.
  Resets the lock file pointer.
  Marks the lock as held by the given context, via the \p cmpxchg instruction.
  Lock ioctl.
  \param inode device inode.
  \param file_priv DRM file private.
  \param cmd command.
  \param arg user argument, pointing to a drm_lock structure.
  \return zero on success or negative number on failure.
  Add the current task to the lock wait queue, and attempt to take to lock.
 Device has been unregistered 
 Got lock 
 Contention 
	 don't set the block all signals on the master process for now 
	  really probably not the correct answer but lets us debug xkb
  Unlock ioctl.
  \param inode device inode.
  \param file_priv DRM file private.
  \param cmd command.
  \param arg user argument, pointing to a drm_lock structure.
  \return zero on success or negative number on failure.
  Transfer and free the lock.
 FIXME: Should really bail out here. 
  This function returns immediately and takes the hw lock
  with the kernel context if it is free, otherwise it gets the highest priority when and if
  it is eventually released.
  This guarantees that the kernel will _eventually_ have the lock _unless_ it is held
  by a blocked process. (In the latter case an explicit wait for the hardware lock would cause
  a deadlock, which is why the "idlelock" was invented).
  This should be sufficient to wait for GPU idle without
  having to worry about starvation.
 if the master has gone away we can't do anything with the lock 
	
	  Since the master is disappearing, so is the
	  possibility to lock.
 SPDX-License-Identifier: MIT
  DOC: vblank works
  Many DRM drivers need to program hardware in a time-sensitive manner, many
  times with a deadline of starting and finishing within a certain region of
  the scanout. Most of the time the safest way to accomplish this is to
  simply do said time-sensitive programming in the driver's IRQ handler,
  which allows drivers to avoid being preempted during these critical
  regions. Or even better, the hardware may even handle applying such
  time-critical programming independently of the CPU.
  While there's a decent amount of hardware that's designed so that the CPU
  doesn't need to be concerned with extremely time-sensitive programming,
  there's a few situations where it can't be helped. Some unforgiving
  hardware may require that certain time-sensitive programming be handled
  completely by the CPU, and said programming may even take too long to
  handle in an IRQ handler. Another such situation would be where the driver
  needs to perform a task that needs to complete within a specific scanout
  period, but might possibly block and thus cannot be handled in an IRQ
  context. Both of these situations can't be solved perfectly in Linux since
  we're not a realtime kernel, and thus the scheduler may cause us to miss
  our deadline if it decides to preempt us. But for some drivers, it's good
  enough if we can lower our chance of being preempted to an absolute
  minimum.
  This is where &drm_vblank_work comes in. &drm_vblank_work provides a simple
  generic delayed work implementation which delays work execution until a
  particular vblank has passed, and then executes the work at realtime
  priority. This provides the best possible chance at performing
  time-sensitive hardware programming on time, even when the system is under
  heavy load. &drm_vblank_work also supports rescheduling, so that self
  re-arming work items can be easily implemented.
 Handle cancelling any pending vblank work items and drop respective vblank
  references in response to vblank interrupts being disabled.
  drm_vblank_work_schedule - schedule a vblank work
  @work: vblank work to schedule
  @count: target vblank count
  @nextonmiss: defer until the next vblank if target vblank was missed
  Schedule @work for execution once the crtc vblank count reaches @count.
  If the crtc vblank count has already reached @count and @nextonmiss is
  %false the work starts to execute immediately.
  If the crtc vblank count has already reached @count and @nextonmiss is
  %true the work is deferred until the next vblank (as if @count has been
  specified as crtc vblank count + 1).
  If @work is already scheduled, this function will reschedule said work
  using the new @count. This can be used for self-rearming work items.
  Returns:
  %1 if @work was successfully (re)scheduled, %0 if it was either already
  scheduled or cancelled, or a negative error code on failure.
 Already scheduled w same vbl count 
  drm_vblank_work_cancel_sync - cancel a vblank work and wait for it to
  finish executing
  @work: vblank work to cancel
  Cancel an already scheduled vblank work and wait for its
  execution to finish.
  On return, @work is guaranteed to no longer be scheduled or running, even
  if it's self-arming.
  Returns:
  %True if the work was cancelled before it started to execute, %false
  otherwise.
  drm_vblank_work_flush - wait for a scheduled vblank work to finish
  executing
  @work: vblank work to flush
  Wait until @work has finished executing once.
  drm_vblank_work_init - initialize a vblank work item
  @work: vblank work item
  @crtc: CRTC whose vblank will trigger the work execution
  @func: work function to be executed
  Initialize a vblank work item for a specific crtc.
  Copyright (C) 2018 Intel Corp.
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
  Authors:
  Rob Clark <robdclark@gmail.com>
  Daniel Vetter <daniel.vetter@ffwll.ch>
  DOC: atomic state reset and initialization
  Both the drm core and the atomic helpers assume that there is always the full
  and correct atomic software state for all connectors, CRTCs and planes
  available. Which is a bit a problem on driver load and also after system
  suspend. One way to solve this is to have a hardware state read-out
  infrastructure which reconstructs the full software state (e.g. the i915
  driver).
  The simpler solution is to just reset the software state to everything off,
  which is easiest to do by calling drm_mode_config_reset(). To facilitate this
  the atomic helpers provide default reset implementations for all hooks.
  On the upside the precise state tracking of atomic simplifies system suspend
  and resume a lot. For drivers using drm_mode_config_reset() a complete recipe
  is implemented in drm_atomic_helper_suspend() and drm_atomic_helper_resume().
  For other drivers the building blocks are split out, see the documentation
  for these functions.
  __drm_atomic_helper_crtc_state_reset - reset the CRTC state
  @crtc_state: atomic CRTC state, must not be NULL
  @crtc: CRTC object, must not be NULL
  Initializes the newly allocated @crtc_state with default
  values. This is useful for drivers that subclass the CRTC state.
  __drm_atomic_helper_crtc_reset - reset state on CRTC
  @crtc: drm CRTC
  @crtc_state: CRTC state to assign
  Initializes the newly allocated @crtc_state and assigns it to
  the &drm_crtc->state pointer of @crtc, usually required when
  initializing the drivers or when called from the &drm_crtc_funcs.reset
  hook.
  This is useful for drivers that subclass the CRTC state.
  drm_atomic_helper_crtc_reset - default &drm_crtc_funcs.reset hook for CRTCs
  @crtc: drm CRTC
  Resets the atomic state for @crtc by freeing the state pointer (which might
  be NULL, e.g. at driver load time) and allocating a new empty state object.
  __drm_atomic_helper_crtc_duplicate_state - copy atomic CRTC state
  @crtc: CRTC object
  @state: atomic CRTC state
  Copies atomic state from a CRTC's current state and resets inferred values.
  This is useful for drivers that subclass the CRTC state.
 Self refresh should be canceled when a new update is available 
  drm_atomic_helper_crtc_duplicate_state - default state duplicate hook
  @crtc: drm CRTC
  Default CRTC state duplicate hook for drivers which don't have their own
  subclassed CRTC state structure.
  __drm_atomic_helper_crtc_destroy_state - release CRTC state
  @state: CRTC state object to release
  Releases all resources stored in the CRTC state without actually freeing
  the memory of the CRTC state. This is useful for drivers that subclass the
  CRTC state.
		
		  In the event that a non-blocking commit returns
		  -ERESTARTSYS before the commit_tail work is queued, we will
		  have an extra reference to the commit object. Release it, if
		  the event has not been consumed by the worker.
		 
		  state->event may be freed, so we can't directly look at
		  state->event->base.completion.
  drm_atomic_helper_crtc_destroy_state - default state destroy hook
  @crtc: drm CRTC
  @state: CRTC state object to release
  Default CRTC state destroy hook for drivers which don't have their own
  subclassed CRTC state structure.
  __drm_atomic_helper_plane_state_reset - resets plane state to default values
  @plane_state: atomic plane state, must not be NULL
  @plane: plane object, must not be NULL
  Initializes the newly allocated @plane_state with default
  values. This is useful for drivers that subclass the CRTC state.
  __drm_atomic_helper_plane_reset - reset state on plane
  @plane: drm plane
  @plane_state: plane state to assign
  Initializes the newly allocated @plane_state and assigns it to
  the &drm_crtc->state pointer of @plane, usually required when
  initializing the drivers or when called from the &drm_plane_funcs.reset
  hook.
  This is useful for drivers that subclass the plane state.
  drm_atomic_helper_plane_reset - default &drm_plane_funcs.reset hook for planes
  @plane: drm plane
  Resets the atomic state for @plane by freeing the state pointer (which might
  be NULL, e.g. at driver load time) and allocating a new empty state object.
  __drm_atomic_helper_plane_duplicate_state - copy atomic plane state
  @plane: plane object
  @state: atomic plane state
  Copies atomic state from a plane's current state. This is useful for
  drivers that subclass the plane state.
  drm_atomic_helper_plane_duplicate_state - default state duplicate hook
  @plane: drm plane
  Default plane state duplicate hook for drivers which don't have their own
  subclassed plane state structure.
  __drm_atomic_helper_plane_destroy_state - release plane state
  @state: plane state object to release
  Releases all resources stored in the plane state without actually freeing
  the memory of the plane state. This is useful for drivers that subclass the
  plane state.
  drm_atomic_helper_plane_destroy_state - default state destroy hook
  @plane: drm plane
  @state: plane state object to release
  Default plane state destroy hook for drivers which don't have their own
  subclassed plane state structure.
  __drm_atomic_helper_connector_state_reset - reset the connector state
  @conn_state: atomic connector state, must not be NULL
  @connector: connectotr object, must not be NULL
  Initializes the newly allocated @conn_state with default
  values. This is useful for drivers that subclass the connector state.
  __drm_atomic_helper_connector_reset - reset state on connector
  @connector: drm connector
  @conn_state: connector state to assign
  Initializes the newly allocated @conn_state and assigns it to
  the &drm_connector->state pointer of @connector, usually required when
  initializing the drivers or when called from the &drm_connector_funcs.reset
  hook.
  This is useful for drivers that subclass the connector state.
  drm_atomic_helper_connector_reset - default &drm_connector_funcs.reset hook for connectors
  @connector: drm connector
  Resets the atomic state for @connector by freeing the state pointer (which
  might be NULL, e.g. at driver load time) and allocating a new empty state
  object.
  drm_atomic_helper_connector_tv_reset - Resets TV connector properties
  @connector: DRM connector
  Resets the TV-related properties attached to a connector.
  __drm_atomic_helper_connector_duplicate_state - copy atomic connector state
  @connector: connector object
  @state: atomic connector state
  Copies atomic state from a connector's current state. This is useful for
  drivers that subclass the connector state.
 Don't copy over a writeback job, they are used only once 
  drm_atomic_helper_connector_duplicate_state - default state duplicate hook
  @connector: drm connector
  Default connector state duplicate hook for drivers which don't have their own
  subclassed connector state structure.
  __drm_atomic_helper_connector_destroy_state - release connector state
  @state: connector state object to release
  Releases all resources stored in the connector state without actually
  freeing the memory of the connector state. This is useful for drivers that
  subclass the connector state.
  drm_atomic_helper_connector_destroy_state - default state destroy hook
  @connector: drm connector
  @state: connector state object to release
  Default connector state destroy hook for drivers which don't have their own
  subclassed connector state structure.
  __drm_atomic_helper_private_obj_duplicate_state - copy atomic private state
  @obj: CRTC object
  @state: new private object state
  Copies atomic state from a private objects's current state and resets inferred values.
  This is useful for drivers that subclass the private state.
  __drm_atomic_helper_bridge_duplicate_state() - Copy atomic bridge state
  @bridge: bridge object
  @state: atomic bridge state
  Copies atomic state from a bridge's current state and resets inferred values.
  This is useful for drivers that subclass the bridge state.
  drm_atomic_helper_bridge_duplicate_state() - Duplicate a bridge state object
  @bridge: bridge object
  Allocates a new bridge state and initializes it with the current bridge
  state values. This helper is meant to be used as a bridge
  &drm_bridge_funcs.atomic_duplicate_state hook for bridges that don't
  subclass the bridge state.
  drm_atomic_helper_bridge_destroy_state() - Destroy a bridge state object
  @bridge: the bridge this state refers to
  @state: bridge state to destroy
  Destroys a bridge state previously created by
  &drm_atomic_helper_bridge_reset() or
  &drm_atomic_helper_bridge_duplicate_state(). This helper is meant to be
  used as a bridge &drm_bridge_funcs.atomic_destroy_state hook for bridges
  that don't subclass the bridge state.
  __drm_atomic_helper_bridge_reset() - Initialize a bridge state to its
 					default
  @bridge: the bridge this state refers to
  @state: bridge state to initialize
  Initializes the bridge state to default values. This is meant to be called
  by the bridge &drm_bridge_funcs.atomic_reset hook for bridges that subclass
  the bridge state.
  drm_atomic_helper_bridge_reset() - Allocate and initialize a bridge state
 				      to its default
  @bridge: the bridge this state refers to
  Allocates the bridge state and initializes it to default values. This helper
  is meant to be used as a bridge &drm_bridge_funcs.atomic_reset hook for
  bridges that don't subclass the bridge state.
  Created: Sun Dec 21 13:08:50 2008 by bgamari@gmail.com
  Copyright 2008 Ben Gamari <bgamari@gmail.com>
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  VA LINUX SYSTEMS ANDOR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
  Initialization, etc.
	 dev->filelist is sorted youngest first, but we want to present
	  oldest first (i.e. kernel, servers, clients), so walk backwardss.
 locks pid_task()->comm 
  drm_debugfs_create_files - Initialize a given set of debugfs files for DRM
  			minor
  @files: The array of files to create
  @count: The number of files given
  @root: DRI debugfs dir entry.
  @minor: device minor number
  Create a given set of debugfs files represented by an array of
  &struct drm_info_list in the given root directory. These files will be removed
  automatically on drm_debugfs_cleanup().
  Returns the min and max vrr vfreq through the connector's debugfs file.
  Example usage: cat syskerneldebugdri0DP-1vrr_range
 force 
 edid 
 vrr range 
 CONFIG_DEBUG_FS 
  \file drm_vm.c
  Memory mapping for DRM
  \author Rickard E. (Rik) Faith <faith@valinux.com>
  \author Gareth Hughes <gareth@valinux.com>
  Created: Mon Jan  4 08:58:31 1999 by faith@valinux.com
  Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
  Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
  All Rights Reserved.
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  VA LINUX SYSTEMS ANDOR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
  \c fault method for AGP virtual memory.
  \param vma virtual memory area.
  \param address access address.
  \return pointer to the page structure.
  Find the right map and if it's AGP memory find the real physical page to
  map, get the page, increment the use count and return it.
	
	  Find the right map
		
		  Using vm_pgoff as a selector forces us to use this unusual
		  addressing scheme.
		
		  Adjust to a bus-relative address
		
		  It's AGP memory - find the real physical page to map
		
		  Get the page, inc the use count, and return it
 Disallow mremap 
  \c nopage method for shared virtual memory.
  \param vma virtual memory area.
  \param address access address.
  \return pointer to the page structure.
  Get the mapping, find the real physical page to map, get the page, and
  return it.
 Nothing allocated 
  \c close method for shared virtual memory.
  \param vma virtual memory area.
  Deletes map information if we are the last
  person to close a mapping and it's not in the global maplist.
 We were the only map that was found 
		 Check to see if we are in the maplist, if we are not, then
		  we delete this mappings information.
  \c fault method for DMA virtual memory.
  \param address access address.
  \return pointer to the page structure.
  Determine the page number from the page offset and get it from drm_device_dma::pagelist.
 Error 
 Nothing allocated 
 vm_[pg]off[set] should be 0 
 page_nr could just be vmf->pgoff 
  \c fault method for scatter-gather virtual memory.
  \param address access address.
  \return pointer to the page structure.
  Determine the map offset from the page offset and get it from drm_sg_mem::pagelist.
 Error 
 Nothing allocated 
 AGP virtual memory operations 
 Shared virtual memory operations 
 DMA virtual memory operations 
 Scatter-gather virtual memory operations 
  \c close method for all virtual memory types.
  \param vma virtual memory area.
  Search the \p vma private data entry in drm_device::vmalist, unlink it, and
  free it.
  mmap DMA memory.
  \param file_priv DRM file private.
  \param vma virtual memory area.
  \return zero on success or a negative number on failure.
  Sets the virtual memory area operations structure to vm_dma_ops, the file
  pointer, and calls vm_open().
 Length must match exact page count 
		 Ye gads this is ugly.  With more thought
		   we could move this up higher and use
  mmap DMA memory.
  \param file_priv DRM file private.
  \param vma virtual memory area.
  \return zero on success or a negative number on failure.
  If the virtual memory area has no offset associated with it then it's a DMA
  area, so calls mmap_dma(). Otherwise searches the map in drm_device::maplist,
  checks that the restricted flag is not set, sets the virtual memory operations
  according to the mapping type and remaps the pages. Finally sets the file
  pointer and calls vm_open().
	 We check for "dma". On Apple's UniNorth, it's valid to have
	  the AGP mapped at physical address 0
	  --BenH.
 Check for valid size. 
		 Ye gads this is ugly.  With more thought
		   we could move this up higher and use
			
			  On some platforms we can't talk to bus dma address from the CPU, so for
			  memory of type DRM_AGP, we'll deal with sorting out the real physical
			  pages and mappings in fault()
 to _DRM_FRAME_BUFFER... 
		 Consistent memory is really like shared memory. But
 to _DRM_SHM 
 This should never happen. 
 Clear vma list (only needed for legacy drivers) 
  Copyright (c) 2006-2007 Tungsten Graphics, Inc., Cedar Park, TX., USA
  All Rights Reserved.
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sub license, andor sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial portions
  of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
  THE COPYRIGHT HOLDERS, AUTHORS ANDOR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  USE OR OTHER DEALINGS IN THE SOFTWARE.
  Authors: Thomas Hellstrm <thomas-at-tungstengraphics-dot-com>
 A small bounce buffer that fits on the stack. 
  clflushopt is an unordered instruction which needs fencing with mfence or
  sfence to avoid ordering issues.  For drm_clflush_page this fencing happens
  in the caller.
Full memory barrier used before so that CLFLUSH is ordered
Also used after CLFLUSH so that all cache is flushed
  drm_clflush_pages - Flush dcache lines of a set of pages.
  @pages: List of pages to be flushed.
  @num_pages: Number of pages in the array.
  Flush every data cache line entry that points to an address belonging
  to a page in the array.
  drm_clflush_sg - Flush dcache lines pointing to a scather-gather.
  @st: struct sg_table.
  Flush every data cache line entry that points to an address in the
  sg.
CLFLUSH is ordered only by using memory barriers
Make sure that all cache line entry is flushed
  drm_clflush_virt_range - Flush dcache lines of a region
  @addr: Initial kernel memory address.
  @length: Region size.
  Flush every data cache line entry that points to an address in the
  region requested.
CLFLUSH is only ordered with a full memory barrier
 force serialisation 
Ensure that every data cache line entry is flushed
	
	  Xen paravirtual hosts require swiotlb regardless of requested dma
	  transfer size.
	 
	  NOTE: Really, what it requires is use of the dma_alloc_coherent
	        allocator used in ttm_dma_populate() instead of
	        ttm_populate_and_map_pages(), which bounce buffers so much in
	        Xen it leads to swiotlb buffer exhaustion.
	
	  Enforce dma_alloc_coherent when memory encryption is active as well
	  for the same reasons as for Xen paravirtual hosts.
		
		  Bounce size is not performance tuned, but using a
		  bounce buffer like this is significantly faster than
		  resorting to ioreadxx() + iowritexx().
  __drm_memcpy_from_wc copies @len bytes from @src to @dst using
  non-temporal instructions where available. Note that all arguments
  (@src, @dst) must be aligned to 16 bytes and @len must be a multiple
  of 16.
  drm_memcpy_from_wc - Perform the fastest available memcpy from a source
  that may be WC.
  @dst: The destination pointer
  @src: The source pointer
  @len: The size of the area o transfer in bytes
  Tries an arch optimized memcpy for prefetching reading out of a WC region,
  and if no such beast is available, falls back to a normal memcpy.
  drm_memcpy_init_early - One time initialization of the WC memcpy code
	
	  Some hypervisors (e.g. KVM) don't support VEX-prefix instructions
	  emulation. So don't enable movntdqa in hypervisor guest.
 CONFIG_X86 
 SPDX-License-Identifier: MIT
  Copyright  2021 Intel Corporation
 +1 for DispID checksum 
 EDID extensions block checksum isn't for us 
 current block should always be valid 
 next block in section 
 SPDX-License-Identifier: GPL-2.0-or-later
  drm gem framebuffer helper functions
  Copyright (C) 2017 Noralf Trnnes
  DOC: overview
  This library provides helpers for drivers that don't subclass
  &drm_framebuffer and use &drm_gem_object for their backing storage.
  Drivers without additional needs to validate framebuffers can simply use
  drm_gem_fb_create() and everything is wired up automatically. Other drivers
  can use all parts independently.
  drm_gem_fb_get_obj() - Get GEM object backing the framebuffer
  @fb: Framebuffer
  @plane: Plane index
  No additional reference is taken beyond the one that the &drm_frambuffer
  already holds.
  Returns:
  Pointer to &drm_gem_object for the given framebuffer and plane index or NULL
  if it does not exist.
  drm_gem_fb_destroy - Free GEM backed framebuffer
  @fb: Framebuffer
  Frees a GEM backed framebuffer with its backing buffer(s) and the structure
  itself. Drivers can use this as their &drm_framebuffer_funcs->destroy
  callback.
  drm_gem_fb_create_handle - Create handle for GEM backed framebuffer
  @fb: Framebuffer
  @file: DRM file to register the handle for
  @handle: Pointer to return the created handle
  This function creates a handle for the GEM object backing the framebuffer.
  Drivers can use this as their &drm_framebuffer_funcs->create_handle
  callback. The GETFB IOCTL calls into this callback.
  Returns:
  0 on success or a negative error code on failure.
  drm_gem_fb_init_with_funcs() - Helper function for implementing
 				  &drm_mode_config_funcs.fb_create
 				  callback in cases when the driver
 				  allocates a subclass of
 				  struct drm_framebuffer
  @dev: DRM device
  @fb: framebuffer object
  @file: DRM file that holds the GEM handle(s) backing the framebuffer
  @mode_cmd: Metadata from the userspace framebuffer creation request
  @funcs: vtable to be used for the new framebuffer object
  This function can be used to set &drm_framebuffer_funcs for drivers that need
  custom framebuffer callbacks. Use drm_gem_fb_create() if you don't need to
  change &drm_framebuffer_funcs. The function does buffer size validation.
  The buffer size validation is for a general case, though, so users should
  pay attention to the checks being appropriate for them or, at least,
  non-conflicting.
  Returns:
  Zero or a negative error code.
  drm_gem_fb_create_with_funcs() - Helper function for the
                                   &drm_mode_config_funcs.fb_create
                                   callback
  @dev: DRM device
  @file: DRM file that holds the GEM handle(s) backing the framebuffer
  @mode_cmd: Metadata from the userspace framebuffer creation request
  @funcs: vtable to be used for the new framebuffer object
  This function can be used to set &drm_framebuffer_funcs for drivers that need
  custom framebuffer callbacks. Use drm_gem_fb_create() if you don't need to
  change &drm_framebuffer_funcs. The function does buffer size validation.
  Returns:
  Pointer to a &drm_framebuffer on success or an error pointer on failure.
  drm_gem_fb_create() - Helper function for the
                        &drm_mode_config_funcs.fb_create callback
  @dev: DRM device
  @file: DRM file that holds the GEM handle(s) backing the framebuffer
  @mode_cmd: Metadata from the userspace framebuffer creation request
  This function creates a new framebuffer object described by
  &drm_mode_fb_cmd2. This description includes handles for the buffer(s)
  backing the framebuffer.
  If your hardware has special alignment or pitch requirements these should be
  checked before calling this function. The function does buffer size
  validation. Use drm_gem_fb_create_with_dirty() if you need framebuffer
  flushing.
  Drivers can use this as their &drm_mode_config_funcs.fb_create callback.
  The ADDFB2 IOCTL calls into this callback.
  Returns:
  Pointer to a &drm_framebuffer on success or an error pointer on failure.
  drm_gem_fb_create_with_dirty() - Helper function for the
                        &drm_mode_config_funcs.fb_create callback
  @dev: DRM device
  @file: DRM file that holds the GEM handle(s) backing the framebuffer
  @mode_cmd: Metadata from the userspace framebuffer creation request
  This function creates a new framebuffer object described by
  &drm_mode_fb_cmd2. This description includes handles for the buffer(s)
  backing the framebuffer. drm_atomic_helper_dirtyfb() is used for the dirty
  callback giving framebuffer flushing through the atomic machinery. Use
  drm_gem_fb_create() if you don't need the dirty callback.
  The function does buffer size validation.
  Drivers should also call drm_plane_enable_fb_damage_clips() on all planes
  to enable userspace to use damage clips also with the ATOMIC IOCTL.
  Drivers can use this as their &drm_mode_config_funcs.fb_create callback.
  The ADDFB2 IOCTL calls into this callback.
  Returns:
  Pointer to a &drm_framebuffer on success or an error pointer on failure.
  drm_gem_fb_vmap - maps all framebuffer BOs into kernel address space
  @fb: the framebuffer
  @map: returns the mapping's address for each BO
  @data: returns the data address for each BO, can be NULL
  This function maps all buffer objects of the given framebuffer into
  kernel address space and stores them in struct dma_buf_map. If the
  mapping operation fails for one of the BOs, the function unmaps the
  already established mappings automatically.
  Callers that want to access a BO's stored data should pass @data.
  The argument returns the addresses of the data stored in each BO. This
  is different from @map if the framebuffer's offsets field is non-zero.
  See drm_gem_fb_vunmap() for unmapping.
  Returns:
  0 on success, or a negative errno code otherwise.
  drm_gem_fb_vunmap - unmaps framebuffer BOs from kernel address space
  @fb: the framebuffer
  @map: mapping addresses as returned by drm_gem_fb_vmap()
  This function unmaps all buffer objects of the given framebuffer.
  See drm_gem_fb_vmap() for more information.
  drm_gem_fb_begin_cpu_access - prepares GEM buffer objects for CPU access
  @fb: the framebuffer
  @dir: access mode
  Prepares a framebuffer's GEM buffer objects for CPU access. This function
  must be called before accessing the BO data within the kernel. For imported
  BOs, the function calls dma_buf_begin_cpu_access().
  See drm_gem_fb_end_cpu_access() for signalling the end of CPU access.
  Returns:
  0 on success, or a negative errno code otherwise.
  drm_gem_fb_end_cpu_access - signals end of CPU access to GEM buffer objects
  @fb: the framebuffer
  @dir: access mode
  Signals the end of CPU access to the given framebuffer's GEM buffer objects. This
  function must be paired with a corresponding call to drm_gem_fb_begin_cpu_access().
  For imported BOs, the function calls dma_buf_end_cpu_access().
  See also drm_gem_fb_begin_cpu_access().
 use whatever a driver has set 
 guess otherwise 
 all attempts failed 
 remove bpp when all users properly encode cpp in drm_format_info 
 no user exists yet - fall through 
 tiled header afbc 
  drm_gem_fb_afbc_init() - Helper function for drivers using afbc to
 			    fill and validate all the afbc-specific
 			    struct drm_afbc_framebuffer members
  @dev: DRM device
  @afbc_fb: afbc-specific framebuffer
  @mode_cmd: Metadata from the userspace framebuffer creation request
  @afbc_fb: afbc framebuffer
  This function can be used by drivers which support afbc to complete
  the preparation of struct drm_afbc_framebuffer. It must be called after
  allocating the said struct and calling drm_gem_fb_init_with_funcs().
  It is caller's responsibility to put afbc_fb->base.obj objects in case
  the call is unsuccessful.
  Returns:
  Zero on success or a negative error value on failure.
  Copyright (C) 2009 Francisco Jerez.
  All Rights Reserved.
  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sublicense, andor sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial
  portions of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE COPYRIGHT OWNER(S) ANDOR ITS SUPPLIERS BE
  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  drm_i2c_encoder_init - Initialize an I2C slave encoder
  @dev:	DRM device.
  @encoder:    Encoder to be attached to the I2C device. You aren't
 		required to have called drm_encoder_init() before.
  @adap:	I2C adapter that will be used to communicate with
 		the device.
  @info:	Information that will be used to create the I2C device.
 		Required fields are @addr and @type.
  Create an I2C device on the specified bus (the module containing its
  driver is transparently loaded) and attach it to the specified
  &drm_encoder_slave. The @slave_funcs field will be initialized with
  the hooks provided by the slave driver.
  If @info.platform_data is non-NULL it will be used as the initial
  slave config.
  Returns 0 on success or a negative errno on failure, in particular,
  -ENODEV is returned when no matching driver is found.
  drm_i2c_encoder_destroy - Unregister the I2C device backing an encoder
  @drm_encoder:	Encoder to be unregistered.
  This should be called from the @destroy method of an I2C slave
  encoder driver once I2C access is no longer needed.
  Wrapper fxns which can be plugged in to drm_encoder_helper_funcs:
 SPDX-License-Identifier: GPL-2.0 OR MIT
  Copyright (c) 2018 VMware, Inc., Palo Alto, CA., USA
  All Rights Reserved.
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the
  "Software"), to deal in the Software without restriction, including
  without limitation the rights to use, copy, modify, merge, publish,
  distribute, sub license, andor sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to
  the following conditions:
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial portions
  of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
  THE COPYRIGHT HOLDERS, AUTHORS ANDOR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  USE OR OTHER DEALINGS IN THE SOFTWARE.
  Authors:
  Deepak Rawat <drawat@vmware.com>
  Rob Clark <robdclark@gmail.com>
  drm_atomic_helper_check_plane_damage - Verify plane damage on atomic_check.
  @state: The driver state object.
  @plane_state: Plane state for which to verify damage.
  This helper function makes sure that damage from plane state is discarded
  for full modeset. If there are more reasons a driver would want to do a full
  plane update rather than processing individual damage regions, then those
  cases should be taken care of here.
  Note that &drm_plane_state.fb_damage_clips == NULL in plane state means that
  full plane update should happen. It also ensure helper iterator will return
  &drm_plane_state.src as damage.
  drm_atomic_helper_dirtyfb - Helper for dirtyfb.
  @fb: DRM framebuffer.
  @file_priv: Drm file for the ioctl call.
  @flags: Dirty fb annotate flags.
  @color: Color for annotate fill.
  @clips: Dirty region.
  @num_clips: Count of clip in clips.
  A helper to implement &drm_framebuffer_funcs.dirty using damage interface
  during plane update. If num_clips is 0 then this helper will do a full plane
  update. This is the same behaviour expected by DIRTFB IOCTL.
  Note that this helper is blocking implementation. This is what current
  drivers and userspace expect in their DIRTYFB IOCTL implementation, as a way
  to rate-limit userspace and make sure its rendering doesn't get ahead of
  uploading new data too much.
  Return: Zero on success, negative errno on failure.
	
	  When called from ioctl, we are interruptible, but not when called
	  internally (ie. defio worker)
  drm_atomic_helper_damage_iter_init - Initialize the damage iterator.
  @iter: The iterator to initialize.
  @old_state: Old plane state for validation.
  @state: Plane state from which to iterate the damage clips.
  Initialize an iterator, which clips plane damage
  &drm_plane_state.fb_damage_clips to plane &drm_plane_state.src. This iterator
  returns full plane src in case damage is not present because either
  user-space didn't sent or driver discarded it (it want to do full plane
  update). Currently this iterator returns full plane src in case plane src
  changed but that can be changed in future to return damage.
  For the case when plane is not visible or plane update should not happen the
  first call to iter_next will return false. Note that this helper use clipped
  &drm_plane_state.src, so driver calling this helper should have called
  drm_atomic_helper_check_plane_state() earlier.
 Round down for x1y1 and round up for x2y2 to catch all pixels 
  drm_atomic_helper_damage_iter_next - Advance the damage iterator.
  @iter: The iterator to advance.
  @rect: Return a rectangle in fb coordinate clipped to plane src.
  Since plane src is in 16.16 fixed point and damage clips are whole number,
  this iterator round off clips that intersect with plane src. Round down for
  x1y1 and round up for x2y2 for the intersected coordinate. Similar rounding
  off for full plane src, in case it's returned as damage. This iterator will
  skip damage clips outside of plane src.
  Return: True if the output is valid, false if reached the end.
  If the first call to iterator next returns false then it means no need to
  update the plane.
  drm_atomic_helper_damage_merged - Merged plane damage
  @old_state: Old plane state for validation.
  @state: Plane state from which to iterate the damage clips.
  @rect: Returns the merged damage rectangle
  This function merges any valid plane damage clips into one rectangle and
  returns it in @rect.
  For details see: drm_atomic_helper_damage_iter_init() and
  drm_atomic_helper_damage_iter_next().
  Returns:
  True if there is valid plane damage otherwise false.
  Copyright (c) 2006-2008 Intel Corporation
  Copyright (c) 2007 Dave Airlie <airlied@linux.ie>
  DRM core CRTC related functions
  Permission to use, copy, modify, distribute, and sell this software and its
  documentation for any purpose is hereby granted without fee, provided that
  the above copyright notice appear in all copies and that both that copyright
  notice and this permission notice appear in supporting documentation, and
  that the name of the copyright holders not be used in advertising or
  publicity pertaining to distribution of the software without specific,
  written prior permission.  The copyright holders make no representations
  about the suitability of this software for any purpose.  It is provided "as
  is" without express or implied warranty.
  THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
  EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
  DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
  OF THIS SOFTWARE.
  Authors:
       Keith Packard
 	Eric Anholt <eric@anholt.net>
       Dave Airlie <airlied@linux.ie>
       Jesse Barnes <jesse.barnes@intel.com>
  DOC: output probing helper overview
  This library provides some helper code for output probing. It provides an
  implementation of the core &drm_connector_funcs.fill_modes interface with
  drm_helper_probe_single_connector_modes().
  It also provides support for polling connectors with a work item and for
  generic hotplug interrupt handling where the driver doesn't or cannot keep
  track of a per-connector hpd interrupt.
  This helper library can be used independently of the modeset helper library.
  Drivers can also overwrite different parts e.g. use their own hotplug
  handling code to avoid probing unrelated outputs.
  The probe helpers share the function table structures with other display
  helper libraries. See &struct drm_connector_helper_funcs for the details.
 Step 1: Validate against connector 
 Step 2: Validate against encoders and crtcs 
			 No point in continuing for crtc check as this encoder
			  will not accept the mode anyway. If all encoders
			  reject the mode then, at exit, ret will not be
			 There is also no point in continuing for crtc check
				 If we get to this point there is at least
				  one combination of encoder+crtc that works
 Only add a GTF mode if we find no matching probed modes 
 The probed mode's vrefresh is set until later 
 Mark the matching mode as being preferred by the user 
  drm_kms_helper_poll_enable - re-enable output polling.
  @dev: drm_device
  This function re-enables the output polling work, after it has been
  temporarily disabled using drm_kms_helper_poll_disable(), for example over
  suspendresume.
  Drivers can call this helper from their device resume implementation. It is
  not an error to call this even when output polling isn't enabled.
  Note that calls to enable and disable polling must be strictly ordered, which
  is automatically the case when they're only call from suspendresume
  callbacks.
		
		  FIXME:
		 
		  Use short (1s) delay to handle the initial delayed event.
		  This delay should not be needed, but Optimusnouveau will
		  fail in a mysterious way if the delayed event is handled as
		  soon as possible like it is done in
		  drm_helper_probe_single_connector_modes() in case the poll
		  was enabled before.
  drm_helper_probe_detect - probe connector status
  @connector: connector to probe
  @ctx: acquire_ctx, or NULL to let this function handle locking.
  @force: Whether destructive probe operations should be performed.
  This function calls the detect callbacks of the connector.
  This function returns &drm_connector_status, or
  if @ctx is set, it might also return -EDEADLK.
  drm_helper_probe_single_connector_modes - get complete set of display modes
  @connector: connector to probe
  @maxX: max width for modes
  @maxY: max height for modes
  Based on the helper callbacks implemented by @connector in struct
  &drm_connector_helper_funcs try to detect all valid modes.  Modes will first
  be added to the connector's probed_modes list, then culled (based on validity
  and the @maxX, @maxY parameters) and put into the normal modes list.
  Intended to be used as a generic implementation of the
  &drm_connector_funcs.fill_modes() vfunc for drivers that use the CRTC helpers
  for output mode filtering and detection.
  The basic procedure is as follows
  1. All modes currently on the connector's modes list are marked as stale
  2. New modes are added to the connector's probed_modes list with
     drm_mode_probed_add(). New modes start their life with status as OK.
     Modes are added from a single source using the following priority order.
     - &drm_connector_helper_funcs.get_modes vfunc
     - if the connector status is connector_status_connected, standard
       VESA DMT modes up to 1024x768 are automatically added
       (drm_add_modes_noedid())
     Finally modes specified via the kernel command line (video=...) are
     added in addition to what the earlier probes produced
     (drm_helper_probe_add_cmdline_mode()). These modes are generated
     using the VESA GTFCVT formulas.
  3. Modes are moved from the probed_modes list to the modes list. Potential
     duplicates are merged together (see drm_connector_list_update()).
     After this step the probed_modes list will be empty again.
  4. Any non-stale mode on the modes list then undergoes validation
     - drm_mode_validate_basic() performs basic sanity checks
     - drm_mode_validate_size() filters out modes larger than @maxX and @maxY
       (if specified)
     - drm_mode_validate_flag() checks the modes against basic connector
       capabilities (interlace_allowed,doublescan_allowed,stereo_allowed)
     - the optional &drm_connector_helper_funcs.mode_valid or
       &drm_connector_helper_funcs.mode_valid_ctx helpers can perform driver
       andor sink specific checks
     - the optional &drm_crtc_helper_funcs.mode_valid,
       &drm_bridge_funcs.mode_valid and &drm_encoder_helper_funcs.mode_valid
       helpers can perform driver andor source specific checks which are also
       enforced by the modesetatomic helpers
  5. Any mode whose status is not OK is pruned from the connector's modes list,
     accompanied by a debug message indicating the reason for the mode's
     rejection (see drm_mode_prune_invalid()).
  Returns:
  The number of modes found on @connector.
 set all old modes to the stale state 
	
	  Normally either the driver's hpd code or the poll loop should
	  pick up any changes and fire the hotplug event. But if
	  userspace sneaks in a probe, we might miss a change. Hence
	  check here, and if anything changed start the hotplug code.
		
		  The hotplug event code might call into the fb
		  helpers, and so expects that we do not hold any
		  locks. Fire up the poll struct instead, it will
		  disable itself again.
 Re-enable polling in case the global poll config changed. 
	
	  Fallback for when DDC probe failed in drm_get_edid() and thus skipped
	  overridefirmware EDID.
  drm_kms_helper_hotplug_event - fire off KMS hotplug events
  @dev: drm_device whose connector state changed
  This function fires off the uevent for userspace and also calls the
  output_poll_changed function, which is most commonly used to inform the fbdev
  emulation code and allow it to update the fbcon output configuration.
  Drivers should call this from their hotplug handling code when a change is
  detected. Note that this function does not do any output detection of its
  own, like drm_helper_hpd_irq_event() does - this is assumed to be done by the
  driver already.
  This function must be called from process context with no mode
  setting locks held.
 send a uevent + call fbdev 
 Pick up any changes detected by the probe functions. 
 Ignore forced connectors. 
		 Ignore HPD capable connectors and connectors where we don't
		 if we are connected and don't want to poll for disconnect
			
			  The poll work sets force=false when calling detect so
			  that drivers can avoid to do disruptive tests (e.g.
			  when load detect cycles could cause flickering on
			  other, running displays). This bears the risk that we
			  flip-flop between unknown here in the poll work and
			  the real state when userspace forces a full detect
			  call after receiving a hotplug event due to this
			  change.
			 
			  Hence clamp an unknown detect status to the old
			  value.
  drm_kms_helper_is_poll_worker - is %current task an output poll worker?
  Determine if %current task is an output poll worker.  This can be used
  to select distinct code paths for output polling versus other contexts.
  One use case is to avoid a deadlock between the output poll worker and
  the autosuspend worker wherein the latter waits for polling to finish
  upon calling drm_kms_helper_poll_disable(), while the former waits for
  runtime suspend to finish upon calling pm_runtime_get_sync() in a
  connector ->detect hook.
  drm_kms_helper_poll_disable - disable output polling
  @dev: drm_device
  This function disables the output polling work.
  Drivers can call this helper from their device suspend implementation. It is
  not an error to call this even when output polling isn't enabled or already
  disabled. Polling is re-enabled by calling drm_kms_helper_poll_enable().
  Note that calls to enable and disable polling must be strictly ordered, which
  is automatically the case when they're only call from suspendresume
  callbacks.
  drm_kms_helper_poll_init - initialize and enable output polling
  @dev: drm_device
  This function initializes and then also enables output polling support for
  @dev. Drivers which do not have reliable hotplug support in hardware can use
  this helper infrastructure to regularly poll such connectors for changes in
  their connection state.
  Drivers can control which connectors are polled by setting the
  DRM_CONNECTOR_POLL_CONNECT and DRM_CONNECTOR_POLL_DISCONNECT flags. On
  connectors where probing live outputs can result in visual distortion drivers
  should not set the DRM_CONNECTOR_POLL_DISCONNECT flag to avoid this.
  Connectors which have no flag or only DRM_CONNECTOR_POLL_HPD set are
  completely ignored by the polling logic.
  Note that a connector can be both polled and probed from the hotplug handler,
  in case the hotplug interrupt is known to be unreliable.
  drm_kms_helper_poll_fini - disable output polling and clean it up
  @dev: drm_device
 Only handle HPD capable connectors. 
  drm_connector_helper_hpd_irq_event - hotplug processing
  @connector: drm_connector
  Drivers can use this helper function to run a detect cycle on a connector
  which has the DRM_CONNECTOR_POLL_HPD flag set in its &polled member.
  This helper function is useful for drivers which can track hotplug
  interrupts for a single connector. Drivers that want to send a
  hotplug event for all connectors or can't track hotplug interrupts
  per connector need to use drm_helper_hpd_irq_event().
  This function must be called from process context with no mode
  setting locks held.
  Note that a connector can be both polled and probed from the hotplug
  handler, in case the hotplug interrupt is known to be unreliable.
  Returns:
  A boolean indicating whether the connector status changed or not
  drm_helper_hpd_irq_event - hotplug processing
  @dev: drm_device
  Drivers can use this helper function to run a detect cycle on all connectors
  which have the DRM_CONNECTOR_POLL_HPD flag set in their &polled member. All
  other connectors are ignored, which is useful to avoid reprobing fixed
  panels.
  This helper function is useful for drivers which can't or don't track hotplug
  interrupts for each connector.
  Drivers which support hotplug interrupts for each connector individually and
  which have a more fine-grained detect logic can use
  drm_connector_helper_hpd_irq_event(). Alternatively, they should bypass this
  code and directly call drm_kms_helper_hotplug_event() in case the connector
  state changed.
  This function must be called from process context with no mode
  setting locks held.
  Note that a connector can be both polled and probed from the hotplug handler,
  in case the hotplug interrupt is known to be unreliable.
  Returns:
  A boolean indicating whether the connector status changed or not
 Only handle HPD capable connectors. 
 SPDX-License-Identifier: MIT
  Copyright  2018 Intel Corp
  Author:
  Manasi Navare <manasi.d.navare@intel.com>
  DOC: dsc helpers
  VESA specification for DP 1.4 adds a new feature called Display Stream
  Compression (DSC) used to compress the pixel bits before sending it on
  DPeDPMIPI DSI interface. DSC is required to be enabled so that the existing
  display interfaces can support high resolutions at higher frames rates uisng
  the maximum available link capacity of these interfaces.
  These functions contain some common logic and helpers to deal with VESA
  Display Stream Compression standard required for DSC on Display PorteDP or
  MIPI display interfaces.
  drm_dsc_dp_pps_header_init() - Initializes the PPS Header
  for DisplayPort as per the DP 1.4 spec.
  @pps_header: Secondary data packet header for DSC Picture
               Parameter Set as defined in &struct dp_sdp_header
  DP 1.4 spec defines the secondary data packet for sending the
  picture parameter infoframes from the source to the sink.
  This function populates the SDP header defined in
  &struct dp_sdp_header.
  drm_dsc_dp_rc_buffer_size - get rc buffer size in bytes
  @rc_buffer_block_size: block size code, according to DPCD offset 62h
  @rc_buffer_size: number of blocks - 1, according to DPCD offset 63h
  return:
  buffer size in bytes, or 0 on invalid input
  drm_dsc_pps_payload_pack() - Populates the DSC PPS
  @pps_payload:
  Bitwise struct for DSC Picture Parameter Set. This is defined
  by &struct drm_dsc_picture_parameter_set
  @dsc_cfg:
  DSC Configuration data filled by driver as defined by
  &struct drm_dsc_config
  DSC source device sends a picture parameter set (PPS) containing the
  information required by the sink to decode the compressed frame. Driver
  populates the DSC PPS struct using the DSC configuration parameters in
  the order expected by the DSC Display Sink device. For the DSC, the sink
  device expects the PPS payload in big endian format for fields
  that span more than 1 byte.
 Protect against someone accidentally changing struct size 
 PPS 0 
 PPS 1, 2 is 0 
 PPS 3 
 PPS 4 
 PPS 5 
	
	  The DSC panel expects the PPS packet to have big endian format
	  for data spanning 2 bytes. Use a macro cpu_to_be16() to convert
	  to big endian format. If format is little endian, it will swap
	  bytes to convert to Big endian else keep it unchanged.
 PPS 6, 7 
 PPS 8, 9 
 PPS 10, 11 
 PPS 12, 13 
 PPS 14, 15 
 PPS 16 
 PPS 17 
 PPS 18, 19 
 PPS 20 is 0 
 PPS 21 
 PPS 22, 23 
 PPS 24 
 PPS 25 
 PPS 26[7:0], PPS 27[7:5] RESERVED 
 PPS 27 
 PPS 28, 29 
 PPS 30, 31 
 PPS 32, 33 
 PPS 34, 35 
 PPS 36 
 PPS 37 
 PPS 38, 39 
 PPS 40 
 PPS 41 
 PPS 42 
 PPS 43 
 PPS 44 - 57 
 PPS 58 - 87 
	
	  For DSC sink programming the RC Range parameter fields
	  are as follows: Min_qp[15:11], max_qp[10:6], offset[5:0]
 PPS 88 
 PPS 89 
 PPS 90, 91 
 PPS 92, 93 
 PPS 94 - 127 are O 
  drm_dsc_compute_rc_parameters() - Write rate control
  parameters to the dsc configuration defined in
  &struct drm_dsc_config in accordance with the DSC 1.2
  specification. Some configuration fields must be present
  beforehand.
  @vdsc_cfg:
  DSC Configuration data partially filled by driver
 Number of groups used to code each line of a slice 
 chunksize in Bytes 
 Number of groups used to code each line of a slice 
 chunksize in Bytes 
 Number of bits in one Slice 
 scale_decrement_interval calculation according to DSC spec 1.11 
		
		  NflBpgOffset is 16 bit value with 11 fractional bits
		  hence we multiply by 2^11 for preserving the
		  fractional part
 Number of groups used to code the entire slice 
 slice_bpg_offset is 16 bit value with 11 fractional bits 
		
		  ScaleIncrementInterval =
		  finaloffset((NflBpgOffset + SliceBpgOffset)8(finalscale - 1.125))
		  as (NflBpgOffset + SliceBpgOffset) has 11 bit fractional value,
		  we need divide by 2^11 from pstDscCfg values
		
		  If finalScaleValue is less than or equal to 9, a value of 0 should
		  be used to disable the scale increment at the end of the slice
	
	  DSC spec mentions that bits_per_pixel specifies the target
	  bitspixel (bpp) rate that is used by the encoder,
	  in steps of 116 of a bit per pixel
  Copyright (C) 2014 Intel Corporation
  DRM universal plane helper functions
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the next
  paragraph) shall be included in all copies or substantial portions of the
  Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
  DOC: overview
  This helper library has two parts. The first part has support to implement
  primary plane support on top of the normal CRTC configuration interface.
  Since the legacy &drm_mode_config_funcs.set_config interface ties the primary
  plane together with the CRTC state this does not allow userspace to disable
  the primary plane itself. The default primary plane only expose XRBG8888 and
  ARGB8888 as valid pixel formats for the attached framebuffer.
  Drivers are highly recommended to implement proper support for primary
  planes, and newly merged drivers must not rely upon these transitional
  helpers.
  The second part also implements transitional helpers which allow drivers to
  gradually switch to the atomic helper infrastructure for plane updates. Once
  that switch is complete drivers shouldn't use these any longer, instead using
  the proper legacy implementations for update and disable plane hooks provided
  by the atomic helpers.
  Again drivers are strongly urged to switch to the new interfaces.
  The plane helpers share the function table structures with other helpers,
  specifically also the atomic helpers. See &struct drm_plane_helper_funcs for
  the details.
  Returns the connectors currently associated with a CRTC.  This function
  should be called twice:  once with a NULL connector list to retrieve
  the list size, and once with the properly allocated list to be filled in.
	
	  Note: Once we change the plane hooks to more fine-grained locking we
	  need to grab the connection_mutex here to be able to make these
	  checks.
		
		  Primary plane isn't visible.  Note that unless a driver
		  provides their own disable function, this will just
		  wind up returning -EINVAL to userspace.
 Find current connectors for CRTC 
	
	  We call set_config() directly here rather than using
	  drm_mode_set_config_internal.  We're reprogramming the same
	  connectors that were already in use, so we shouldn't need the extra
	  cross-CRTC fb refcounting to accommodate stealing connectors.
	  drm_mode_setplane() already handles the basic refcounting for the
	  framebuffers involved in this operation.
  drm_primary_helper_destroy() - Helper for primary plane destruction
  @plane: plane to destroy
  Provides a default plane destroy handler for primary planes.  This handler
  is called during CRTC destruction.  We disable the primary plane, remove
  it from the DRM plane list, and deallocate the plane structure.
 SPDX-License-Identifier: GPL-2.0
  Copyright (C) 2020 Intel
  Based on driversbasedevres.c
  DOC: managed resources
  Inspired by struct &device managed resources, but tied to the lifetime of
  struct &drm_device, which can outlive the underlying physical device, usually
  when userspace has some open files and other handles to resources still open.
  Release actions can be added with drmm_add_action(), memory allocations can
  be done directly with drmm_kmalloc() and the related functions. Everything
  will be released on the final drm_dev_put() in reverse order of how the
  release actions have been added and memory has been allocated since driver
  loading started with devm_drm_dev_alloc().
  Note that release actions and managed memory can also be added and removed
  during the lifetime of the driver, all the functions are fully concurrent
  safe. But it is recommended to use managed resources only for resources that
  change rarely, if ever, during the lifetime of the &drm_device instance.
	
	  Some archs want to perform DMA into kmalloc caches
	  and need a guaranteed alignment larger than
	  the alignment of a 64-bit integer.
	  Thus we use ARCH_KMALLOC_MINALIGN here and get exactly the same
	  buffer alignment as if it was allocated by plain kmalloc().
  Always inline so that kmalloc_track_caller tracks the actual interesting
  caller outside of drm_managed.c.
 We must catch any near-SIZE_MAX cases that could overflow. 
  drmm_kmalloc - &drm_device managed kmalloc()
  @dev: DRM device
  @size: size of the memory allocation
  @gfp: GFP allocation flags
  This is a &drm_device managed version of kmalloc(). The allocated memory is
  automatically freed on the final drm_dev_put(). Memory can also be freed
  before the final drm_dev_put() by calling drmm_kfree().
  drmm_kstrdup - &drm_device managed kstrdup()
  @dev: DRM device
  @s: 0-terminated string to be duplicated
  @gfp: GFP allocation flags
  This is a &drm_device managed version of kstrdup(). The allocated memory is
  automatically freed on the final drm_dev_put() and works exactly like a
  memory allocation obtained by drmm_kmalloc().
  drmm_kfree - &drm_device managed kfree()
  @dev: DRM device
  @data: memory allocation to be freed
  This is a &drm_device managed version of kfree() which can be used to
  release memory allocated through drmm_kmalloc() or any of its related
  functions before the final drm_dev_put() of @dev.
  Copyright (c) 2016 Intel Corporation
  Permission to use, copy, modify, distribute, and sell this software and its
  documentation for any purpose is hereby granted without fee, provided that
  the above copyright notice appear in all copies and that both that copyright
  notice and this permission notice appear in supporting documentation, and
  that the name of the copyright holders not be used in advertising or
  publicity pertaining to distribution of the software without specific,
  written prior permission.  The copyright holders make no representations
  about the suitability of this software for any purpose.  It is provided "as
  is" without express or implied warranty.
  THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
  EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
  DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
  OF THIS SOFTWARE.
  DOC: overview
  Encoders represent the connecting element between the CRTC (as the overall
  pixel pipeline, represented by &struct drm_crtc) and the connectors (as the
  generic sink entity, represented by &struct drm_connector). An encoder takes
  pixel data from a CRTC and converts it to a format suitable for any attached
  connector. Encoders are objects exposed to userspace, originally to allow
  userspace to infer cloning and connectorCRTC restrictions. Unfortunately
  almost all drivers get this wrong, making the uabi pretty much useless. On
  top of that the exposed restrictions are too simple for today's hardware, and
  the recommended way to infer restrictions is by using the
  DRM_MODE_ATOMIC_TEST_ONLY flag for the atomic IOCTL.
  Otherwise encoders aren't used in the uapi at all (any modeset request from
  userspace directly connects a connector with a CRTC), drivers are therefore
  free to use them however they wish. Modeset helper libraries make strong use
  of encoders to facilitate code sharing. But for more complex settings it is
  usually better to move shared code into a separate &drm_bridge. Compared to
  encoders, bridges also have the benefit of being purely an internal
  abstraction since they are not exposed to userspace at all.
  Encoders are initialized with drm_encoder_init() and cleaned up using
  drm_encoder_cleanup().
 encoder index is used with 32bit bitmasks 
  drm_encoder_init - Init a preallocated encoder
  @dev: drm device
  @encoder: the encoder to init
  @funcs: callbacks for this encoder
  @encoder_type: user visible type of the encoder
  @name: printf style format string for the encoder name, or NULL for default name
  Initializes a preallocated encoder. Encoder should be subclassed as part of
  driver encoder objects. At driver unload time the driver's
  &drm_encoder_funcs.destroy hook should call drm_encoder_cleanup() and kfree()
  the encoder structure. The encoder structure should not be allocated with
  devm_kzalloc().
  Note: consider using drmm_encoder_alloc() instead of drm_encoder_init() to
  let the DRM managed resource infrastructure take care of cleanup and
  deallocation.
  Returns:
  Zero on success, error code on failure.
  drm_encoder_cleanup - cleans up an initialised encoder
  @encoder: encoder to cleanup
  Cleans up the encoder but doesn't free the object.
	 Note that the encoder_list is considered to be static; should we
	  remove the drm_encoder at runtime we would have to decrement all
	  the indices on the drm_encoder after us in the encoder_list.
	 For atomic drivers only state objects are synchronously updated and
 Don't return stale data (e.g. pending async disable). 
 SPDX-License-Identifier: GPL-2.0-or-later
   drm_edid_load.c: use a built-in EDID data set or load it via the firmware
		    interface
   Copyright (C) 2012 Carsten Emde <C.Emde@osadl.org>
 Use only for backward compatibility with drm_kms_helper.edid_firmware 
 Use only for backward compatibility with drm_kms_helper.edid_firmware 
	
	  If there are multiple edid files specified and separated
	  by commas, search through the list looking for one that
	  matches the connector.
	 
	  If there's one or more that doesn't specify a connector, keep
	  the last one found one as a fallback.
 corner case: multiple ',' 
 SPDX-License-Identifier: GPL-2.0-or-later
  Copyright  2017 Keith Packard <keithp@keithp.com>
  DOC: drm leasing
  DRM leases provide information about whether a DRM master may control a DRM
  mode setting object. This enables the creation of multiple DRM masters that
  manage subsets of display resources.
  The original DRM master of a device 'owns' the available drm resources. It
  may create additional DRM masters and 'lease' resources which it controls
  to the new DRM master. This gives the new DRM master control over the
  leased resources until the owner revokes the lease, or the new DRM master
  is closed. Some helpful terminology:
  - An 'owner' is a &struct drm_master that is not leasing objects from
    another &struct drm_master, and hence 'owns' the objects. The owner can be
    identified as the &struct drm_master for which &drm_master.lessor is NULL.
  - A 'lessor' is a &struct drm_master which is leasing objects to one or more
    other &struct drm_master. Currently, lessees are not allowed to
    create sub-leases, hence the lessor is the same as the owner.
  - A 'lessee' is a &struct drm_master which is leasing objects from some
    other &struct drm_master. Each lessee only leases resources from a single
    lessor recorded in &drm_master.lessor, and holds the set of objects that
    it is leasing in &drm_master.leases.
  - A 'lease' is a contract between the lessor and lessee that identifies
    which resources may be controlled by the lessee. All of the resources
    that are leased must be owned by or leased to the lessor, and lessors are
    not permitted to lease the same object to multiple lessees.
  The set of objects any &struct drm_master 'controls' is limited to the set
  of objects it leases (for lessees) or all objects (for owners).
  Objects not controlled by a &struct drm_master cannot be modified through
  the various state manipulating ioctls, and any state reported back to user
  space will be edited to make them appear idle andor unusable. For
  instance, connectors always report 'disconnected', while encoders
  report no possible crtcs or clones.
  Since each lessee may lease objects from a single lessor, display resource
  leases form a tree of &struct drm_master. As lessees are currently not
  allowed to create sub-leases, the tree depth is limited to 1. All of
  these get activated simultaneously when the top level device owner changes
  through the SETMASTER or DROPMASTER IOCTL, so &drm_device.master points to
  the owner at the top of the lease tree (i.e. the &struct drm_master for which
  &drm_master.lessor is NULL). The full list of lessees that are leasing
  objects from the owner can be searched via the owner's
  &drm_master.lessee_idr.
 Checks if the given object has been leased to some lessee of drm_master 
 Called with idr_mutex held 
  Given a bitmask of crtcs to check, reconstructs a crtc mask based on the
  crtcs which are visible through the specified file.
  Uses drm_master_create to allocate a new drm_master, then checks to
  make sure all of the desired objects can be leased, atomically
  leasing them to the new drmmaster.
  	ERR_PTR(-EACCES)	some other master holds the title to any object
  	ERR_PTR(-ENOENT)	some object is not a valid DRM object for this device
  	ERR_PTR(-EBUSY)		some other lessee holds title to this object
 	ERR_PTR(-EEXIST)	same object specified more than once in the provided list
 	ERR_PTR(-ENOMEM)	allocation failed
 Insert the new lessee into the tree 
 Move the leases over 
	 This master is referenced by all lessees, hence it cannot be destroyed
	  until all of them have been
 Remove this master from the lessee idr in the owner 
 Remove this master from any lessee list it may be on 
 Tell the master to check the lessee list 
	
	  Walk the tree starting at 'top' emptying all leases. Because
	  the tree is fully connected, we can do this without recursing
 Evacuate the lease 
 Depth-first list walk 
 Down 
 Up 
 Over 
	 we want to confirm that there is at least one crtc, plane
	 step one - get references to all the mode objects
	 add their IDs to the lease request - taking into account
		
		  We're using an IDR to hold the set of leased
		  objects, but we don't need to point at the object's
		  data structure from the lease as the main object_idr
		  will be used to actually find that. Instead, all we
		  really want is a 'leasednot-leased' result, for
		  which any non-NULL pointer will work fine.
  The master associated with the specified file will have a lease
  created containing the objects specified in the ioctl structure.
  A file descriptor will be allocated for that and returned to the
  application.
 Can't lease without MODESET 
 Do not allow sub-leases 
 Handle leased objects, if any 
 fill and validate the object idr 
 Allocate a file descriptor for the lease 
 lessee will take the ownership of leases 
 Clone the lessor file to create a new file for us 
 Change the file to a master one 
 Pass fd back to userspace 
 Hook up the fd 
 Can't lease without MODESET 
 Only list un-revoked leases 
 Return the list of leased objects for the specified lessee 
 Can't lease without MODESET 
 owner can use all objects 
 lessee can only use allowed object 
  This removes all of the objects from the lease without
  actually getting rid of the lease itself; that way all
  references to it still work correctly
 Can't lease without MODESET 
 No such lessee 
 Lease is not held by lessor 
  Copyright (c) 2016 Intel Corporation
  Permission to use, copy, modify, distribute, and sell this software and its
  documentation for any purpose is hereby granted without fee, provided that
  the above copyright notice appear in all copies and that both that copyright
  notice and this permission notice appear in supporting documentation, and
  that the name of the copyright holders not be used in advertising or
  publicity pertaining to distribution of the software without specific,
  written prior permission.  The copyright holders make no representations
  about the suitability of this software for any purpose.  It is provided "as
  is" without express or implied warranty.
  THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
  EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
  DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
  OF THIS SOFTWARE.
  DOC: overview
  Color management or color space adjustments is supported through a set of 5
  properties on the &drm_crtc object. They are set up by calling
  drm_crtc_enable_color_mgmt().
  "DEGAMMA_LUT:
 	Blob property to set the degamma lookup table (LUT) mapping pixel data
 	from the framebuffer before it is given to the transformation matrix.
 	The data is interpreted as an array of &struct drm_color_lut elements.
 	Hardware might choose not to use the full precision of the LUT elements
 	nor use all the elements of the LUT (for example the hardware might
 	choose to interpolate between LUT[0] and LUT[4]).
 	Setting this to NULL (blob property value set to 0) means a
 	linearpass-thru gamma table should be used. This is generally the
 	driver boot-up state too. Drivers can access this blob through
 	&drm_crtc_state.degamma_lut.
  DEGAMMA_LUT_SIZE:
 	Unsinged range property to give the size of the lookup table to be set
 	on the DEGAMMA_LUT property (the size depends on the underlying
 	hardware). If drivers support multiple LUT sizes then they should
 	publish the largest size, and sub-sample smaller sized LUTs (e.g. for
 	split-gamma modes) appropriately.
  CTM:
 	Blob property to set the current transformation matrix (CTM) apply to
 	pixel data after the lookup through the degamma LUT and before the
 	lookup through the gamma LUT. The data is interpreted as a struct
 	&drm_color_ctm.
 	Setting this to NULL (blob property value set to 0) means a
 	unitpass-thru matrix should be used. This is generally the driver
 	boot-up state too. Drivers can access the blob for the color conversion
 	matrix through &drm_crtc_state.ctm.
  GAMMA_LUT:
 	Blob property to set the gamma lookup table (LUT) mapping pixel data
 	after the transformation matrix to data sent to the connector. The
 	data is interpreted as an array of &struct drm_color_lut elements.
 	Hardware might choose not to use the full precision of the LUT elements
 	nor use all the elements of the LUT (for example the hardware might
 	choose to interpolate between LUT[0] and LUT[4]).
 	Setting this to NULL (blob property value set to 0) means a
 	linearpass-thru gamma table should be used. This is generally the
 	driver boot-up state too. Drivers can access this blob through
 	&drm_crtc_state.gamma_lut.
  GAMMA_LUT_SIZE:
 	Unsigned range property to give the size of the lookup table to be set
 	on the GAMMA_LUT property (the size depends on the underlying hardware).
 	If drivers support multiple LUT sizes then they should publish the
 	largest size, and sub-sample smaller sized LUTs (e.g. for split-gamma
 	modes) appropriately.
  There is also support for a legacy gamma table, which is set up by calling
  drm_mode_crtc_set_gamma_size(). The DRM core will then alias the legacy gamma
  ramp with "GAMMA_LUT" or, if that is unavailable, "DEGAMMA_LUT".
  Support for different non RGB color encodings is controlled through
  &drm_plane specific COLOR_ENCODING and COLOR_RANGE properties. They
  are set up by calling drm_plane_create_color_properties().
  "COLOR_ENCODING":
  	Optional plane enum property to support different non RGB
  	color encodings. The driver can provide a subset of standard
  	enum values supported by the DRM plane.
  "COLOR_RANGE":
  	Optional plane enum property to support different non RGB
  	color parameter ranges. The driver can provide a subset of
  	standard enum values supported by the DRM plane.
  drm_color_ctm_s31_32_to_qm_n
  @user_input: input value
  @m: number of integer bits, only support m <= 32, include the sign-bit
  @n: number of fractional bits, only support n <= 32
  Convert and clamp S31.32 sign-magnitude to Qm.n (signed 2's complement).
  The sign-bit BIT(m+n-1) and above are 0 for positive value and 1 for negative
  the range of value is [-2^(m-1), 2^(m-1) - 2^-n]
  For example
  A Q3.12 format number:
  - required bit: 3 + 12 = 15bits
  - range: [-2^2, 2^2 - 2^15]
  NOTE: the m can be zero if all bit_precision are used to present fractional
        bits like Q0.32
  drm_crtc_enable_color_mgmt - enable color management properties
  @crtc: DRM CRTC
  @degamma_lut_size: the size of the degamma lut (before CSC)
  @has_ctm: whether to attach ctm_property for CSC matrix
  @gamma_lut_size: the size of the gamma lut (after CSC)
  This function lets the driver enable the color correction
  properties on a CRTC. This includes 3 degamma, csc and gamma
  properties that userspace can set and 2 size properties to inform
  the userspace of the lut sizes. Each of the properties are
  optional. The gamma and degamma properties are only attached if
  their size is not 0 and ctm_property is only attached if has_ctm is
  true.
  drm_mode_crtc_set_gamma_size - set the gamma table size
  @crtc: CRTC to set the gamma table size for
  @gamma_size: size of the gamma table
  Drivers which support gamma tables should set this to the supported gamma
  table size when initializing the CRTC. Currently the drm core only supports a
  fixed gamma table size.
  Returns:
  Zero on success, negative errno on failure.
  drm_crtc_supports_legacy_gamma - does the crtc support legacy gamma correction table
  @crtc: CRTC object
  Returns truefalse if the given crtc supports setting the legacy gamma
  correction table.
  drm_crtc_legacy_gamma_set - set the legacy gamma correction table
  @crtc: CRTC object
  @red: red correction table
  @green: green correction table
  @blue: green correction table
  @size: size of the tables
  @ctx: lock acquire context
  Implements support for legacy gamma correction table for drivers
  that have set drm_crtc_funcs.gamma_set or that support color management
  through the DEGAMMA_LUTGAMMA_LUT properties. See
  drm_crtc_enable_color_mgmt() and the containing chapter for
  how the atomic color management and gamma tables work.
  This function sets the gamma using drm_crtc_funcs.gamma_set if set, or
  alternatively using crtc color management properties.
 Prepare GAMMA_LUT with the legacy values. 
 Set GAMMA_LUT and reset DEGAMMA_LUT and CTM 
  drm_mode_gamma_set_ioctl - set the gamma table
  @dev: DRM device
  @data: ioctl data
  @file_priv: DRM file info
  Set the gamma table of a CRTC to the one passed in by the user. Userspace can
  inquire the required gamma table size through drm_mode_gamma_get_ioctl.
  Called by the user via ioctl.
  Returns:
  Zero on success, negative errno on failure.
 memcpy into gamma store 
  drm_mode_gamma_get_ioctl - get the gamma table
  @dev: DRM device
  @data: ioctl data
  @file_priv: DRM file info
  Copy the current gamma table into the storage provided. This also provides
  the gamma table size the driver expects, which can be used to size the
  allocated storage.
  Called by the user via ioctl.
  Returns:
  Zero on success, negative errno on failure.
 memcpy into gamma store 
  drm_get_color_encoding_name - return a string for color encoding
  @encoding: color encoding to compute name of
  In contrast to the other drm_get__name functions this one here returns a
  const pointer and hence is threadsafe.
  drm_get_color_range_name - return a string for color range
  @range: color range to compute name of
  In contrast to the other drm_get__name functions this one here returns a
  const pointer and hence is threadsafe.
  drm_plane_create_color_properties - color encoding related plane properties
  @plane: plane object
  @supported_encodings: bitfield indicating supported color encodings
  @supported_ranges: bitfileld indicating supported color ranges
  @default_encoding: default color encoding
  @default_range: default color range
  Create and attach plane specific COLOR_ENCODING and COLOR_RANGE
  properties to @plane. The supported encodings and ranges should
  be provided in supported_encodings and supported_ranges bitmasks.
  Each bit set in the bitmask indicates that its number as enum
  value is supported.
  drm_color_lut_check - check validity of lookup table
  @lut: property blob containing LUT to check
  @tests: bitmask of tests to run
  Helper to check whether a userspace-provided lookup table is valid and
  satisfies hardware requirements.  Drivers pass a bitmask indicating which of
  the tests in &drm_color_lut_tests should be performed.
  Returns 0 on success, -EINVAL on failure.
  Copyright (c) 2016 Intel Corporation
  Permission to use, copy, modify, distribute, and sell this software and its
  documentation for any purpose is hereby granted without fee, provided that
  the above copyright notice appear in all copies and that both that copyright
  notice and this permission notice appear in supporting documentation, and
  that the name of the copyright holders not be used in advertising or
  publicity pertaining to distribution of the software without specific,
  written prior permission.  The copyright holders make no representations
  about the suitability of this software for any purpose.  It is provided "as
  is" without express or implied warranty.
  THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
  EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
  DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
  OF THIS SOFTWARE.
  DOC: overview
  In DRM connectors are the general abstraction for display sinks, and include
  also fixed panels or anything else that can display pixels in some form. As
  opposed to all other KMS objects representing hardware (like CRTC, encoder or
  plane abstractions) connectors can be hotplugged and unplugged at runtime.
  Hence they are reference-counted using drm_connector_get() and
  drm_connector_put().
  KMS driver must create, initialize, register and attach at a &struct
  drm_connector for each such sink. The instance is created as other KMS
  objects and initialized by setting the following fields. The connector is
  initialized with a call to drm_connector_init() with a pointer to the
  &struct drm_connector_funcs and a connector type, and then exposed to
  userspace with a call to drm_connector_register().
  Connectors must be attached to an encoder to be used. For devices that map
  connectors to encoders 1:1, the connector should be attached at
  initialization time with a call to drm_connector_attach_encoder(). The
  driver must also set the &drm_connector.encoder field to point to the
  attached encoder.
  For connectors which are not fixed (like built-in panels) the driver needs to
  support hotplug notifications. The simplest way to do that is by using the
  probe helpers, see drm_kms_helper_poll_init() for connectors which don't have
  hardware support for hotplug interrupts. Connectors with hardware hotplug
  support can instead use e.g. drm_helper_hpd_irq_event().
  Global connector list for drm_connector_find_by_fwnode().
  Note drm_connector_[un]register() first take connector->lock and then
  take the connector_list_lock.
  Connector and encoder types.
  drm_get_connector_type_name - return a string for connector type
  @type: The connector type (DRM_MODE_CONNECTOR_)
  Returns: the name of the connector type, or NULL if the type is not valid.
  drm_connector_get_cmdline_mode - reads the user's cmdline mode
  @connector: connector to query
  The kernel supports per-connector configuration of its consoles through
  use of the video= parameter. This function parses that option and
  extracts the user's specified mode (or enabledisable status) for a
  particular connector. This is typically only used during the early fbdev
  setup.
  drm_connector_init - Init a preallocated connector
  @dev: DRM device
  @connector: the connector to init
  @funcs: callbacks for this connector
  @connector_type: user visible type of the connector
  Initialises a preallocated connector. Connectors should be
  subclassed as part of driver connector objects.
  Returns:
  Zero on success, error code on failure.
 connector index is used with 32bit bitmasks 
	 We should add connectors at the end to avoid upsetting the connector
	  index too much.
  drm_connector_init_with_ddc - Init a preallocated connector
  @dev: DRM device
  @connector: the connector to init
  @funcs: callbacks for this connector
  @connector_type: user visible type of the connector
  @ddc: pointer to the associated ddc adapter
  Initialises a preallocated connector. Connectors should be
  subclassed as part of driver connector objects.
  Ensures that the ddc field of the connector is correctly set.
  Returns:
  Zero on success, error code on failure.
 provide ddc symlink in sysfs 
  drm_connector_attach_edid_property - attach edid property.
  @connector: the connector
  Some connector types like DRM_MODE_CONNECTOR_VIRTUAL do not get a
  edid property attached by default.  This function can be used to
  explicitly enable the edid property in these cases.
  drm_connector_attach_encoder - attach a connector to an encoder
  @connector: connector to attach
  @encoder: encoder to attach @connector to
  This function links up a connector to an encoder. Note that the routing
  restrictions between encoders and crtcs are exposed to userspace through the
  possible_clones and possible_crtcs bitmasks.
  Returns:
  Zero on success, negative errno on failure.
	
	  In the past, drivers have attempted to model the static association
	  of connector to encoder in simple connectorencoder devices using a
	  direct assignment of connector->encoder = encoder. This connection
	  is a logical one and the responsibility of the core, so drivers are
	  expected not to mess with this.
	 
	  Note that the error return should've been enough here, but a large
	  majority of drivers ignores the return value, so add in a big WARN
	  to get people's attention.
  drm_connector_has_possible_encoder - check if the connector and encoder are
  associated with each other
  @connector: the connector
  @encoder: the encoder
  Returns:
  True if @encoder is one of the possible encoders for @connector.
  drm_connector_cleanup - cleans up an initialised connector
  @connector: connector to cleanup
  Cleans up the connector but doesn't free the object.
	 The connector should have been removed from userspace long before
	  it is finally destroyed.
  drm_connector_register - register a connector
  @connector: the connector to register
  Register userspace interfaces for a connector. Only call this for connectors
  which can be hotplugged after drm_dev_register() has been called already,
  e.g. DP MST connectors. All other connectors will be registered automatically
  when calling drm_dev_register().
  Returns:
  Zero on success, error code on failure.
 Let userspace know we have a new connector 
  drm_connector_unregister - unregister a connector
  @connector: the connector to unregister
  Unregister userspace interfaces for a connector. Only call this for
  connectors which have registered explicitly by calling drm_dev_register(),
  since connectors are unregistered automatically when drm_dev_unregister() is
  called.
  drm_get_connector_status_name - return a string for connector status
  @status: connector status to compute name of
  In contrast to the other drm_get__name functions this one here returns a
  const pointer and hence is threadsafe.
  Returns: connector status string
  drm_get_connector_force_name - return a string for connector force
  @force: connector force to get name of
  Returns: const pointer to name.
  drm_connector_list_iter_begin - initialize a connector_list iterator
  @dev: DRM device
  @iter: connector_list iterator
  Sets @iter up to walk the &drm_mode_config.connector_list of @dev. @iter
  must always be cleaned up again by calling drm_connector_list_iter_end().
  Iteration itself happens using drm_connector_list_iter_next() or
  drm_for_each_connector_iter().
  Extra-safe connector put function that works in any context. Should only be
  used from the connector_iter functions, where we never really expect to
  actually release the connector when dropping our final reference.
  drm_connector_list_iter_next - return next connector
  @iter: connector_list iterator
  Returns: the next connector for @iter, or NULL when the list walk has
  completed.
 loop until it's not a zombie connector 
  drm_connector_list_iter_end - tear down a connector_list iterator
  @iter: connector_list iterator
  Tears down @iter and releases any resources (like &drm_connector references)
  acquired while walking the list. This must always be called, both when the
  iteration completes fully or when it was aborted without walking the entire
  list.
  drm_get_subpixel_order_name - return a string for a given subpixel enum
  @order: enum of subpixel_order
  Note you could abuse this and return something out of bounds, but that
  would be a caller error.  No unscrubbed user data should make it here.
  Returns: string describing an enumerated subpixel property
  drm_display_info_set_bus_formats - set the supported bus formats
  @info: display info to store bus formats in
  @formats: array containing the supported bus formats
  @num_formats: the number of entries in the fmts array
  Store the supported bus formats in display info structure.
  See MEDIA_BUS_FMT_ definitions in includeuapilinuxmedia-bus-format.h for
  a full list of available formats.
  Returns:
  0 on success or a negative error code on failure.
 Optional connector properties. 
 DVI-I and TV-out 
 DVI-I  
 DVI-I  
 DVI-I, TV-out and DP 
 DVI-I  
 DVI-I  
 DVI-I and TV-out 
 TV-out 
 TV-out 
 TV-out 
 TV-out 
 DVI-I, TV-out and DP 
 TV-out 
 TV-out 
 TV-out 
 TV-out 
 DVI-I, TV-out and DP 
 DP 
 DP 
 DP 
 DP 
 DP 
 DP 
 For Default case, driver will set the colorspace 
 Standard Definition Colorimetry based on CEA 861 
 Standard Definition Colorimetry based on IEC 61966-2-4 
 High Definition Colorimetry based on IEC 61966-2-4 
 Colorimetry based on IEC 61966-2-1Amendment 1 
 Colorimetry based on IEC 61966-2-5 [33] 
 Colorimetry based on IEC 61966-2-5 
 Colorimetry based on ITU-R BT.2020 
 Colorimetry based on ITU-R BT.2020 
 Colorimetry based on ITU-R BT.2020 
 Added as part of Additional Colorimetry Extension in 861.G 
  As per DP 1.4a spec, 2.2.5.7.5 VSC SDP Payload for Pixel EncodingColorimetry
  Format Table 2-120
 For Default case, driver will set the colorspace 
 Colorimetry based on scRGB (IEC 61966-2-2) 
 Colorimetry based on IEC 61966-2-5 
 Colorimetry based on SMPTE RP 431-2 
 Colorimetry based on ITU-R BT.2020 
 Standard Definition Colorimetry based on IEC 61966-2-4 
 High Definition Colorimetry based on IEC 61966-2-4 
 Colorimetry based on IEC 61966-2-1Amendment 1 
 Colorimetry based on IEC 61966-2-5 [33] 
 Colorimetry based on ITU-R BT.2020 
 Colorimetry based on ITU-R BT.2020 
  DOC: standard connector properties
  DRM connectors have a few standardized properties:
  EDID:
  	Blob property which contains the current EDID read from the sink. This
  	is useful to parse sink identification information like vendor, model
  	and serial. Drivers should update this property by calling
  	drm_connector_update_edid_property(), usually after having parsed
  	the EDID using drm_add_edid_modes(). Userspace cannot change this
  	property.
  	User-space should not parse the EDID to obtain information exposed via
  	other KMS properties (because the kernel might apply limits, quirks or
  	fixups to the EDID). For instance, user-space should not try to parse
  	mode lists from the EDID.
  DPMS:
  	Legacy property for setting the power state of the connector. For atomic
  	drivers this is only provided for backwards compatibility with existing
  	drivers, it remaps to controlling the "ACTIVE" property on the CRTC the
  	connector is linked to. Drivers should never set this property directly,
  	it is handled by the DRM core by calling the &drm_connector_funcs.dpms
  	callback. For atomic drivers the remapping to the "ACTIVE" property is
  	implemented in the DRM core.
  	Note that this property cannot be set through the MODE_ATOMIC ioctl,
  	userspace must use "ACTIVE" on the CRTC instead.
  	WARNING:
  	For userspace also running on legacy drivers the "DPMS" semantics are a
  	lot more complicated. First, userspace cannot rely on the "DPMS" value
  	returned by the GETCONNECTOR actually reflecting reality, because many
  	drivers fail to update it. For atomic drivers this is taken care of in
  	drm_atomic_helper_update_legacy_modeset_state().
  	The second issue is that the DPMS state is only well-defined when the
  	connector is connected to a CRTC. In atomic the DRM core enforces that
  	"ACTIVE" is off in such a case, no such checks exists for "DPMS".
  	Finally, when enabling an output using the legacy SETCONFIG ioctl then
  	"DPMS" is forced to ON. But see above, that might not be reflected in
  	the software value on legacy drivers.
  	Summarizing: Only set "DPMS" when the connector is known to be enabled,
  	assume that a successful SETCONFIG call also sets "DPMS" to on, and
  	never read back the value of "DPMS" because it can be incorrect.
  PATH:
  	Connector path property to identify how this sink is physically
  	connected. Used by DP MST. This should be set by calling
  	drm_connector_set_path_property(), in the case of DP MST with the
  	path property the MST manager created. Userspace cannot change this
  	property.
  TILE:
  	Connector tile group property to indicate how a set of DRM connector
  	compose together into one logical screen. This is used by both high-res
  	external screens (often only using a single cable, but exposing multiple
  	DP MST sinks), or high-res integrated panels (like dual-link DSI) which
  	are not gen-locked. Note that for tiled panels which are genlocked, like
  	dual-link LVDS or dual-link DSI, the driver should try to not expose the
  	tiling and virtualise both &drm_crtc and &drm_plane if needed. Drivers
  	should update this value using drm_connector_set_tile_property().
  	Userspace cannot change this property.
  link-status:
       Connector link-status property to indicate the status of link. The
       default value of link-status is "GOOD". If something fails during or
       after modeset, the kernel driver may set this to "BAD" and issue a
       hotplug uevent. Drivers should update this value using
       drm_connector_set_link_status_property().
       When user-space receives the hotplug uevent and detects a "BAD"
       link-status, the sink doesn't receive pixels anymore (e.g. the screen
       becomes completely black). The list of available modes may have
       changed. User-space is expected to pick a new mode if the current one
       has disappeared and perform a new modeset with link-status set to
       "GOOD" to re-enable the connector.
       If multiple connectors share the same CRTC and one of them gets a "BAD"
       link-status, the other are unaffected (ie. the sinks still continue to
       receive pixels).
       When user-space performs an atomic commit on a connector with a "BAD"
       link-status without resetting the property to "GOOD", the sink may
       still not receive pixels. When user-space performs an atomic commit
       which resets the link-status property to "GOOD" without the
       ALLOW_MODESET flag set, it might fail because a modeset is required.
       User-space can only change link-status to "GOOD", changing it to "BAD"
       is a no-op.
       For backwards compatibility with non-atomic userspace the kernel
       tries to automatically set the link-status back to "GOOD" in the
       SETCRTC IOCTL. This might fail if the mode is no longer valid, similar
       to how it might fail if a different screen has been connected in the
       interim.
  non_desktop:
  	Indicates the output should be ignored for purposes of displaying a
  	standard desktop environment or console. This is most likely because
  	the output device is not rectilinear.
  Content Protection:
 	This property is used by userspace to request the kernel protect future
 	content communicated over the link. When requested, kernel will apply
 	the appropriate means of protection (most often HDCP), and use the
 	property to tell userspace the protection is active.
 	Drivers can set this up by calling
 	drm_connector_attach_content_protection_property() on initialization.
 	The value of this property can be one of the following:
 	DRM_MODE_CONTENT_PROTECTION_UNDESIRED = 0
 		The link is not protected, content is transmitted in the clear.
 	DRM_MODE_CONTENT_PROTECTION_DESIRED = 1
 		Userspace has requested content protection, but the link is not
 		currently protected. When in this state, kernel should enable
 		Content Protection as soon as possible.
 	DRM_MODE_CONTENT_PROTECTION_ENABLED = 2
 		Userspace has requested content protection, and the link is
 		protected. Only the driver can set the property to this value.
 		If userspace attempts to set to ENABLED, kernel will return
 		-EINVAL.
 	A few guidelines:
 	- DESIRED state should be preserved until userspace de-asserts it by
 	  setting the property to UNDESIRED. This means ENABLED should only
 	  transition to UNDESIRED when the user explicitly requests it.
 	- If the state is DESIRED, kernel should attempt to re-authenticate the
 	  link whenever possible. This includes across disableenable, dpms,
 	  hotplug, downstream device changes, link status failures, etc..
 	- Kernel sends uevent with the connector id and property id through
 	  @drm_hdcp_update_content_protection, upon below kernel triggered
 	  scenarios:
 		- DESIRED -> ENABLED (authentication success)
 		- ENABLED -> DESIRED (termination of authentication)
 	- Please note no uevents for userspace triggered property state changes,
 	  which can't fail such as
 		- DESIREDENABLED -> UNDESIRED
 		- UNDESIRED -> DESIRED
 	- Userspace is responsible for polling the property or listen to uevents
 	  to determine when the value transitions from ENABLED to DESIRED.
 	  This signifies the link is no longer protected and userspace should
 	  take appropriate action (whatever that might be).
  HDCP Content Type:
 	This Enum property is used by the userspace to declare the content type
 	of the display stream, to kernel. Here display stream stands for any
 	display content that userspace intended to display through HDCP
 	encryption.
 	Content Type of a stream is decided by the owner of the stream, as
 	"HDCP Type0" or "HDCP Type1".
 	The value of the property can be one of the below:
 	  - "HDCP Type0": DRM_MODE_HDCP_CONTENT_TYPE0 = 0
 	  - "HDCP Type1": DRM_MODE_HDCP_CONTENT_TYPE1 = 1
 	When kernel starts the HDCP authentication (see "Content Protection"
 	for details), it uses the content type in "HDCP Content Type"
 	for performing the HDCP authentication with the display sink.
 	Please note in HDCP spec versions, a link can be authenticated with
 	HDCP 2.2 for Content Type 0Content Type 1. Where as a link can be
 	authenticated with HDCP1.4 only for Content Type 0(though it is implicit
 	in nature. As there is no reference for Content Type in HDCP1.4).
 	HDCP2.2 authentication protocol itself takes the "Content Type" as a
 	parameter, which is a input for the DP HDCP2.2 encryption algo.
 	In case of Type 0 content protection request, kernel driver can choose
 	either of HDCP spec versions 1.4 and 2.2. When HDCP2.2 is used for
 	"HDCP Type 0", a HDCP 2.2 capable repeater in the downstream can send
 	that content to a HDCP 1.4 authenticated HDCP sink (Type0 link).
 	But if the content is classified as "HDCP Type 1", above mentioned
 	HDCP 2.2 repeater wont send the content to the HDCP sink as it can't
 	authenticate the HDCP1.4 capable sink for "HDCP Type 1".
 	Please note userspace can be ignorant of the HDCP versions used by the
 	kernel driver to achieve the "HDCP Content Type".
 	At current scenario, classifying a content as Type 1 ensures that the
 	content will be displayed only through the HDCP2.2 encrypted link.
 	Note that the HDCP Content Type property is introduced at HDCP 2.2, and
 	defaults to type 0. It is only exposed by drivers supporting HDCP 2.2
 	(hence supporting Type 0 and Type 1). Based on how next versions of
 	HDCP specs are defined content Type could be used for higher versions
 	too.
 	If content type is changed when "Content Protection" is not UNDESIRED,
 	then kernel will disable the HDCP and re-enable with new type in the
 	same atomic commit. And when "Content Protection" is ENABLED, it means
 	that link is HDCP authenticated and encrypted, for the transmission of
 	the Type of stream mentioned at "HDCP Content Type".
  HDR_OUTPUT_METADATA:
 	Connector property to enable userspace to send HDR Metadata to
 	driver. This metadata is based on the composition and blending
 	policies decided by user, taking into account the hardware and
 	sink capabilities. The driver gets this metadata and creates a
 	Dynamic Range and Mastering Infoframe (DRM) in case of HDMI,
 	SDP packet (Non-audio INFOFRAME SDP v1.3) for DP. This is then
 	sent to sink. This notifies the sink of the upcoming frame's Color
 	Encoding and Luminance parameters.
 	Userspace first need to detect the HDR capabilities of sink by
 	reading and parsing the EDID. Details of HDR metadata for HDMI
 	are added in CTA 861.G spec. For DP , its defined in VESA DP
 	Standard v1.4. It needs to then get the metadata information
 	of the videogameapp content which are encoded in HDR (basically
 	using HDR transfer functions). With this information it needs to
 	decide on a blending policy and compose the relevant
 	layersoverlays into a common format. Once this blending is done,
 	userspace will be aware of the metadata of the composed frame to
 	be send to sink. It then uses this property to communicate this
 	metadata to driver which then make a Infoframe packet and sends
 	to sink based on the type of encoder connected.
 	Userspace will be responsible to do Tone mapping operation in case:
 		- Some layers are HDR and others are SDR
 		- HDR layers luminance is not same as sink
 	It will even need to do colorspace conversion and get all layers
 	to one common colorspace for blending. It can use either GL, Media
 	or display engine to get this done based on the capabilities of the
 	associated hardware.
 	Driver expects metadata to be put in &struct hdr_output_metadata
 	structure from userspace. This is received as blob and stored in
 	&drm_connector_state.hdr_output_metadata. It parses EDID and saves the
 	sink metadata in &struct hdr_sink_metadata, as
 	&drm_connector.hdr_sink_metadata.  Driver uses
 	drm_hdmi_infoframe_set_hdr_metadata() helper to set the HDR metadata,
 	hdmi_drm_infoframe_pack() to pack the infoframe as per spec, in case of
 	HDMI encoder.
  max bpc:
 	This range property is used by userspace to limit the bit depth. When
 	used the driver would limit the bpc in accordance with the valid range
 	supported by the hardware and sink. Drivers to use the function
 	drm_connector_attach_max_bpc_property() to create and attach the
 	property to the connector during initialization.
  Connectors also have one standardized atomic property:
  CRTC_ID:
  	Mode object ID of the &drm_crtc this connector should be connected to.
  Connectors for LCD panels may also have one standardized property:
  panel orientation:
 	On some devices the LCD panel is mounted in the casing in such a way
 	that the uptop side of the panel does not match with the top side of
 	the device. Userspace can use this property to check for this.
 	Note that input coordinates from touchscreens (input devices with
 	INPUT_PROP_DIRECT) will still map 1:1 to the actual LCD panel
 	coordinates, so if userspace rotates the picture to adjust for
 	the orientation it must also apply the same transformation to the
 	touchscreen input coordinates. This property is initialized by calling
 	drm_connector_set_panel_orientation() or
 	drm_connector_set_panel_orientation_with_quirk()
  scaling mode:
 	This property defines how a non-native mode is upscaled to the native
 	mode of an LCD panel:
 	None:
 		No upscaling happens, scaling is left to the panel. Not all
 		drivers expose this mode.
 	Full:
 		The output is upscaled to the full resolution of the panel,
 		ignoring the aspect ratio.
 	Center:
 		No upscaling happens, the output is centered within the native
 		resolution the panel.
 	Full aspect:
 		The output is upscaled to maximize either the width or height
 		while retaining the aspect ratio.
 	This property should be set up by calling
 	drm_connector_attach_scaling_mode_property(). Note that drivers
 	can also expose this property to external outputs, in which case they
 	must support "None", which should be the default (since external screens
 	have a built-in scaler).
  subconnector:
 	This property is used by DVI-I, TVout and DisplayPort to indicate different
 	connector subtypes. Enum values more or less match with those from main
 	connector types.
 	For DVI-I and TVout there is also a matching property "select subconnector"
 	allowing to switch between signal types.
 	DP subconnector corresponds to a downstream port.
  drm_mode_create_dvi_i_properties - create DVI-I specific connector properties
  @dev: DRM device
  Called by a driver the first time a DVI-I connector is made.
  Returns: %0
  drm_connector_attach_dp_subconnector_property - create subconnector property for DP
  @connector: drm_connector to attach property
  Called by a driver when DP connector is created.
  DOC: HDMI connector properties
  content type (HDMI specific):
 	Indicates content type setting to be used in HDMI infoframes to indicate
 	content type for the external device, so that it adjusts its display
 	settings accordingly.
 	The value of this property can be one of the following:
 	No Data:
 		Content type is unknown
 	Graphics:
 		Content type is graphics
 	Photo:
 		Content type is photo
 	Cinema:
 		Content type is cinema
 	Game:
 		Content type is game
 	The meaning of each content type is defined in CTA-861-G table 15.
 	Drivers can set up this property by calling
 	drm_connector_attach_content_type_property(). Decoding to
 	infoframe values is done through drm_hdmi_avi_infoframe_content_type().
  drm_connector_attach_content_type_property - attach content-type property
  @connector: connector to attach content type property on.
  Called by a driver the first time a HDMI connector is made.
  Returns: %0
  drm_hdmi_avi_infoframe_content_type() - fill the HDMI AVI infoframe
                                          content type information, based
                                          on correspondent DRM property.
  @frame: HDMI AVI infoframe
  @conn_state: DRM display connector state
 Graphics is the default(0) 
  drm_connector_attach_tv_margin_properties - attach TV connector margin
  	properties
  @connector: DRM connector
  Called by a driver when it needs to attach TV margin props to a connector.
  Typically used on SDTV and HDMI connectors.
  drm_mode_create_tv_margin_properties - create TV connector margin properties
  @dev: DRM device
  Called by a driver's HDMI connector initialization routine, this function
  creates the TV margin properties for a given device. No need to call this
  function for an SDTV connector, it's already called from
  drm_mode_create_tv_properties().
  Returns:
  0 on success or a negative error code on failure.
  drm_mode_create_tv_properties - create TV specific connector properties
  @dev: DRM device
  @num_modes: number of different TV formats (modes) supported
  @modes: array of pointers to strings containing name of each format
  Called by a driver's TV initialization routine, this function creates
  the TV specific connector properties for a given device.  Caller is
  responsible for allocating a list of format names and passing them to
  this routine.
  Returns:
  0 on success or a negative error code on failure.
	
	  Basic connector properties
	
	  Other, TV specific properties: margins & TV modes.
  drm_mode_create_scaling_mode_property - create scaling mode property
  @dev: DRM device
  Called by a driver the first time it's needed, must be attached to desired
  connectors.
  Atomic drivers should use drm_connector_attach_scaling_mode_property()
  instead to correctly assign &drm_connector_state.scaling_mode
  in the atomic state.
  Returns: %0
  DOC: Variable refresh properties
  Variable refresh rate capable displays can dynamically adjust their
  refresh rate by extending the duration of their vertical front porch
  until page flip or timeout occurs. This can reduce or remove stuttering
  and latency in scenarios where the page flip does not align with the
  vblank interval.
  An example scenario would be an application flipping at a constant rate
  of 48Hz on a 60Hz display. The page flip will frequently miss the vblank
  interval and the same contents will be displayed twice. This can be
  observed as stuttering for content with motion.
  If variable refresh rate was active on a display that supported a
  variable refresh range from 35Hz to 60Hz no stuttering would be observable
  for the example scenario. The minimum supported variable refresh rate of
  35Hz is below the page flip frequency and the vertical front porch can
  be extended until the page flip occurs. The vblank interval will be
  directly aligned to the page flip rate.
  Not all userspace content is suitable for use with variable refresh rate.
  Large and frequent changes in vertical front porch duration may worsen
  perceived stuttering for input sensitive applications.
  Panel brightness will also vary with vertical front porch duration. Some
  panels may have noticeable differences in brightness between the minimum
  vertical front porch duration and the maximum vertical front porch duration.
  Large and frequent changes in vertical front porch duration may produce
  observable flickering for such panels.
  Userspace control for variable refresh rate is supported via properties
  on the &drm_connector and &drm_crtc objects.
  "vrr_capable":
 	Optional &drm_connector boolean property that drivers should attach
 	with drm_connector_attach_vrr_capable_property() on connectors that
 	could support variable refresh rates. Drivers should update the
 	property value by calling drm_connector_set_vrr_capable_property().
 	Absence of the property should indicate absence of support.
  "VRR_ENABLED":
 	Default &drm_crtc boolean property that notifies the driver that the
 	content on the CRTC is suitable for variable refresh rate presentation.
 	The driver will take this property as a hint to enable variable
 	refresh rate support if the receiver supports it, ie. if the
 	"vrr_capable" property is true on the &drm_connector object. The
 	vertical front porch duration will be extended until page-flip or
 	timeout when enabled.
 	The minimum vertical front porch duration is defined as the vertical
 	front porch duration for the current mode.
 	The maximum vertical front porch duration is greater than or equal to
 	the minimum vertical front porch duration. The duration is derived
 	from the minimum supported variable refresh rate for the connector.
 	The driver may place further restrictions within these minimum
 	and maximum bounds.
  drm_connector_attach_vrr_capable_property - creates the
  vrr_capable property
  @connector: connector to create the vrr_capable property on.
  This is used by atomic drivers to add support for querying
  variable refresh rate capability for a connector.
  Returns:
  Zero on success, negative errno on failure.
  drm_connector_attach_scaling_mode_property - attach atomic scaling mode property
  @connector: connector to attach scaling mode property on.
  @scaling_mode_mask: or'ed mask of BIT(%DRM_MODE_SCALE_\).
  This is used to add support for scaling mode to atomic drivers.
  The scaling mode will be set to &drm_connector_state.scaling_mode
  and can be used from &drm_connector_helper_funcs->atomic_check for validation.
  This is the atomic version of drm_mode_create_scaling_mode_property().
  Returns:
  Zero on success, negative errno on failure.
  drm_mode_create_aspect_ratio_property - create aspect ratio property
  @dev: DRM device
  Called by a driver the first time it's needed, must be attached to desired
  connectors.
  Returns:
  Zero on success, negative errno on failure.
  DOC: standard connector properties
  Colorspace:
      This property helps select a suitable colorspace based on the sink
      capability. Modern sink devices support wider gamut like BT2020.
      This helps switch to BT2020 mode if the BT2020 encoded video stream
      is being played by the user, same for any other colorspace. Thereby
      giving a good visual experience to users.
      The expectation from userspace is that it should parse the EDID
      and get supported colorspaces. Use this property and switch to the
      one supported. Sink supported colorspaces should be retrieved by
      userspace from EDID and driver will not explicitly expose them.
      Basically the expectation from userspace is:
       - Set up CRTC DEGAMMACTMGAMMA to convert to some sink
         colorspace
       - Set this new property to let the sink know what it
         converted the CRTC output to.
       - This property is just to inform sink what colorspace
         source is trying to drive.
  Because between HDMI and DP have different colorspaces,
  drm_mode_create_hdmi_colorspace_property() is used for HDMI connector and
  drm_mode_create_dp_colorspace_property() is used for DP connector.
  drm_mode_create_hdmi_colorspace_property - create hdmi colorspace property
  @connector: connector to create the Colorspace property on.
  Called by a driver the first time it's needed, must be attached to desired
  HDMI connectors.
  Returns:
  Zero on success, negative errno on failure.
  drm_mode_create_dp_colorspace_property - create dp colorspace property
  @connector: connector to create the Colorspace property on.
  Called by a driver the first time it's needed, must be attached to desired
  DP connectors.
  Returns:
  Zero on success, negative errno on failure.
  drm_mode_create_content_type_property - create content type property
  @dev: DRM device
  Called by a driver the first time it's needed, must be attached to desired
  connectors.
  Returns:
  Zero on success, negative errno on failure.
  drm_mode_create_suggested_offset_properties - create suggests offset properties
  @dev: DRM device
  Create the suggested xy offset property for connectors.
  Returns:
  0 on success or a negative error code on failure.
  drm_connector_set_path_property - set tile property on connector
  @connector: connector to set property on.
  @path: path to use for property; must not be NULL.
  This creates a property to expose to userspace to specify a
  connector path. This is mainly used for DisplayPort MST where
  connectors have a topology and we want to allow userspace to give
  them more meaningful names.
  Returns:
  Zero on success, negative errno on failure.
  drm_connector_set_tile_property - set tile property on connector
  @connector: connector to set property on.
  This looks up the tile information for a connector, and creates a
  property for userspace to parse if it exists. The property is of
  the form of 8 integers using ':' as a separator.
  This is used for dual port tiled displays with DisplayPort SST
  or DisplayPort MST connectors.
  Returns:
  Zero on success, errno on failure.
  drm_connector_update_edid_property - update the edid property of a connector
  @connector: drm connector
  @edid: new value of the edid property
  This function creates a new blob modeset object and assigns its id to the
  connector's edid property.
  Since we also parse tile information from EDID's displayID block, we also
  set the connector's tile property here. See drm_connector_set_tile_property()
  for more details.
  Returns:
  Zero on success, negative errno on failure.
 ignore requests to set edid when overridden 
	 Set the display info, using edid if available, otherwise
	  resetting the values to defaults. This duplicates the work
	  done in drm_add_edid_modes, but that function is not
	  consistently called before this one in all drivers and the
	  computation is cheap enough that it seems better to
	  duplicate it rather than attempt to ensure some arbitrary
	  ordering of calls.
  drm_connector_set_link_status_property - Set link status property of a connector
  @connector: drm connector
  @link_status: new value of link status property (0: Good, 1: Bad)
  In usual working scenario, this link status property will always be set to
  "GOOD". If something fails during or after a mode set, the kernel driver
  may set this link status property to "BAD". The caller then needs to send a
  hotplug uevent for userspace to re-check the valid modes through
  GET_CONNECTOR_IOCTL and retry modeset.
  Note: Drivers cannot rely on userspace to support this property and
  issue a modeset. As such, they may choose to handle issues (like
  re-training a link) without userspace's intervention.
  The reason for adding this property is to handle link training failures, but
  it is not limited to DP or link training. For example, if we implement
  asynchronous setcrtc, this property can be used to report any failures in that.
  drm_connector_attach_max_bpc_property - attach "max bpc" property
  @connector: connector to attach max bpc property on.
  @min: The minimum bit depth supported by the connector.
  @max: The maximum bit depth supported by the connector.
  This is used to add support for limiting the bit depth on a connector.
  Returns:
  Zero on success, negative errno on failure.
  drm_connector_attach_hdr_output_metadata_property - attach "HDR_OUTPUT_METADA" property
  @connector: connector to attach the property on.
  This is used to allow the userspace to send HDR Metadata to the
  driver.
  Returns:
  Zero on success, negative errno on failure.
  drm_connector_attach_colorspace_property - attach "Colorspace" property
  @connector: connector to attach the property on.
  This is used to allow the userspace to signal the output colorspace
  to the driver.
  Returns:
  Zero on success, negative errno on failure.
  drm_connector_atomic_hdr_metadata_equal - checks if the hdr metadata changed
  @old_state: old connector state to compare
  @new_state: new connector state to compare
  This is used by HDR-enabled drivers to test whether the HDR metadata
  have changed between two different connector state (and thus probably
  requires a full blown mode change).
  Returns:
  True if the metadata are equal, False otherwise
  drm_connector_set_vrr_capable_property - sets the variable refresh rate
  capable property for a connector
  @connector: drm connector
  @capable: True if the connector is variable refresh rate capable
  Should be used by atomic drivers to update the indicated support for
  variable refresh rate over a connector.
  drm_connector_set_panel_orientation - sets the connector's panel_orientation
  @connector: connector for which to set the panel-orientation property.
  @panel_orientation: drm_panel_orientation value to set
  This function sets the connector's panel_orientation and attaches
  a "panel orientation" property to the connector.
  Calling this function on a connector where the panel_orientation has
  already been set is a no-op (e.g. the orientation has been overridden with
  a kernel commandline option).
  It is allowed to call this function with a panel_orientation of
  DRM_MODE_PANEL_ORIENTATION_UNKNOWN, in which case it is a no-op.
  Returns:
  Zero on success, negative errno on failure.
 Already set? 
 Don't attach the property if the orientation is unknown 
  drm_connector_set_panel_orientation_with_quirk - set the
 	connector's panel_orientation after checking for quirks
  @connector: connector for which to init the panel-orientation property.
  @panel_orientation: drm_panel_orientation value to set
  @width: width in pixels of the panel, used for panel quirk detection
  @height: height in pixels of the panel, used for panel quirk detection
  Like drm_connector_set_panel_orientation(), but with a check for platform
  specific (e.g. DMI based) quirks overriding the passed in panel_orientation.
  Returns:
  Zero on success, negative errno on failure.
 Do DPMS ourselves 
 It does all the locking and checking we need 
	 For atomic drivers only state objects are synchronously updated and
	  protected by modeset locks, so check those first.
	
	  If user-space hasn't configured the driver to expose the stereo 3D
	  modes, don't expose them.
	
	  If user-space hasn't configured the driver to expose the modes
	  with aspect-ratio, don't expose them. However if such a mode
	  is unique, let it be exposed, but reset the aspect-ratio flags
	  while preparing the list of user-modes.
 delayed so we get modes regardless of pre-fill_modes state 
	
	  This ioctl is called twice, once to determine how much space is
	  needed, and the 2nd time to fill it.
 Clear the tag for the next time around 
			
			  Reset aspect ratio flags of user-mode, if modes with
			  aspect-ratio are not supported.
				
				  Clear the tag for the rest of
				  the modes for the next time around.
 Clear the tag for the next time around 
	 Only grab properties after probing, to make sure EDID and other
	  properties reflect the latest status.
  drm_connector_find_by_fwnode - Find a connector based on the associated fwnode
  @fwnode: fwnode for which to find the matching drm_connector
  This functions looks up a drm_connector based on its associated fwnode. When
  a connector is found a reference to the connector is returned. The caller must
  call drm_connector_put() to release this reference when it is done with the
  connector.
  Returns: A reference to the found connector or an ERR_PTR().
  drm_connector_oob_hotplug_event - Report out-of-band hotplug event to connector
  @connector_fwnode: fwnode_handle to report the event on
  On some hardware a hotplug event notification may come from outside the display
  driver  device. An example of this is some USB Type-C setups where the hardware
  muxes the DisplayPort data and aux-lines but does not pass the altmode HPD
  status bit to the GPU's DP HPD pin.
  This function can be used to report these out-of-band events after obtaining
  a drm_connector reference through calling drm_connector_find_by_fwnode().
  DOC: Tile group
  Tile groups are used to represent tiled monitors with a unique integer
  identifier. Tiled monitors using DisplayID v1.3 have a unique 8-byte handle,
  we store this in a tile group, so we have a common identifier for all tiles
  in a monitor group. The property is called "TILE". Drivers can manage tile
  groups using drm_mode_create_tile_group(), drm_mode_put_tile_group() and
  drm_mode_get_tile_group(). But this is only needed for internal panels where
  the tile group information is exposed through a non-standard way.
  drm_mode_put_tile_group - drop a reference to a tile group.
  @dev: DRM device
  @tg: tile group to drop reference to.
  drop reference to tile group and free if 0.
  drm_mode_get_tile_group - get a reference to an existing tile group
  @dev: DRM device
  @topology: 8-bytes unique per monitor.
  Use the unique bytes to get a reference to an existing tile group.
  RETURNS:
  tile group or NULL if not found.
  drm_mode_create_tile_group - create a tile group from a displayid description
  @dev: DRM device
  @topology: 8-bytes unique per monitor.
  Create a tile group for the unique monitor, and get a unique
  identifier for the tile group.
  RETURNS:
  new tile group or NULL.
  Copyright (c) 2006 Luc Verhaegen (quirks list)
  Copyright (c) 2007-2008 Intel Corporation
    Jesse Barnes <jesse.barnes@intel.com>
  Copyright 2010 Red Hat, Inc.
  DDC probing routines (drm_ddc_read & drm_do_probe_ddc_edid) originally from
  FB layer.
    Copyright (C) 2006 Dennis Munsie <dmunsie@cecropia.com>
  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sub license,
  andor sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial portions
  of the Software.
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.
  EDID blocks out in the wild have a variety of bugs, try to collect
  them here (note that userspace may work around broken monitors first,
  but fixes should make their way here so that the kernel "just works"
  on as many displays as possible).
 First detailed mode wrong, use largest 60Hz mode 
 Reported 135MHz pixel clock is too high, needs adjustment 
 Prefer the largest mode at 75 Hz 
 Detail timing is in cm not mm 
 Detailed timing descriptors have bogus size values, so just take the
  maximum size and use that.
 use +hsync +vsync for detailed mode 
 Force reduced-blanking timings for detailed modes 
 Force 8bpc 
 Force 12bpc 
 Force 6bpc 
 Force 10bpc 
 Non desktop display (i.e. HMD) 
 Acer AL1706 
 Acer F51 
 AEO model 0 reports 8 bpc, but is a 6 bpc panel 
 BOE model on HP Pavilion 15-n233sl reports 8 bpc, but is a 6 bpc panel 
 CPT panel of Asus UX303LA reports 8 bpc, but is a 6 bpc panel 
 SDC panel of Lenovo B50-80 reports 8 bpc, but is a 6 bpc panel 
 BOE model 0x0771 reports 8 bpc, but is a 6 bpc panel 
 Belinea 10 15 55 
 Envision Peripherals, Inc. EN-7100e 
 Envision EN2028 
 Funai Electronics PM36B 
 LGD panel of HP zBook 17 G2, eDP 10 bpc, but reports unknown bpc 
 LG Philips LCD LP154W01-A5 
 Samsung SyncMaster 205BW.  Note: irony 
 Samsung SyncMaster 22[5-6]BW 
 Sony PVM-2541A does up to 12 bpc, but only reports max 8 bpc 
 ViewSonic VA2026w 
 Medion MD 30217 PG 
 Lenovo G50 
 Panel in Samsung NP700G7A-S01PL notebook reports 6bpc 
 Rotel RSX-1058 forwards sink's EDID but only does HDMI 1.1
 Valve Index Headset 
 HTC Vive and Vive Pro VR Headsets 
 Oculus Rift DK1, DK2, CV1 and Rift S VR Headsets 
 Windows Mixed Reality Headsets 
 Sony PlayStation VR Headset 
 Sensics VR Headsets 
 OSVR HDK and HDK2 VR Headsets 
  Autogenerated from the DMT spec.
  This table is copied from xfree86modesxf86EdidModes.c.
 0x01 - 640x350@85Hz 
 0x02 - 640x400@85Hz 
 0x03 - 720x400@85Hz 
 0x04 - 640x480@60Hz 
 0x05 - 640x480@72Hz 
 0x06 - 640x480@75Hz 
 0x07 - 640x480@85Hz 
 0x08 - 800x600@56Hz 
 0x09 - 800x600@60Hz 
 0x0a - 800x600@72Hz 
 0x0b - 800x600@75Hz 
 0x0c - 800x600@85Hz 
 0x0d - 800x600@120Hz RB 
 0x0e - 848x480@60Hz 
 0x0f - 1024x768@43Hz, interlace 
 0x10 - 1024x768@60Hz 
 0x11 - 1024x768@70Hz 
 0x12 - 1024x768@75Hz 
 0x13 - 1024x768@85Hz 
 0x14 - 1024x768@120Hz RB 
 0x15 - 1152x864@75Hz 
 0x55 - 1280x720@60Hz 
 0x16 - 1280x768@60Hz RB 
 0x17 - 1280x768@60Hz 
 0x18 - 1280x768@75Hz 
 0x19 - 1280x768@85Hz 
 0x1a - 1280x768@120Hz RB 
 0x1b - 1280x800@60Hz RB 
 0x1c - 1280x800@60Hz 
 0x1d - 1280x800@75Hz 
 0x1e - 1280x800@85Hz 
 0x1f - 1280x800@120Hz RB 
 0x20 - 1280x960@60Hz 
 0x21 - 1280x960@85Hz 
 0x22 - 1280x960@120Hz RB 
 0x23 - 1280x1024@60Hz 
 0x24 - 1280x1024@75Hz 
 0x25 - 1280x1024@85Hz 
 0x26 - 1280x1024@120Hz RB 
 0x27 - 1360x768@60Hz 
 0x28 - 1360x768@120Hz RB 
 0x51 - 1366x768@60Hz 
 0x56 - 1366x768@60Hz 
 0x29 - 1400x1050@60Hz RB 
 0x2a - 1400x1050@60Hz 
 0x2b - 1400x1050@75Hz 
 0x2c - 1400x1050@85Hz 
 0x2d - 1400x1050@120Hz RB 
 0x2e - 1440x900@60Hz RB 
 0x2f - 1440x900@60Hz 
 0x30 - 1440x900@75Hz 
 0x31 - 1440x900@85Hz 
 0x32 - 1440x900@120Hz RB 
 0x53 - 1600x900@60Hz 
 0x33 - 1600x1200@60Hz 
 0x34 - 1600x1200@65Hz 
 0x35 - 1600x1200@70Hz 
 0x36 - 1600x1200@75Hz 
 0x37 - 1600x1200@85Hz 
 0x38 - 1600x1200@120Hz RB 
 0x39 - 1680x1050@60Hz RB 
 0x3a - 1680x1050@60Hz 
 0x3b - 1680x1050@75Hz 
 0x3c - 1680x1050@85Hz 
 0x3d - 1680x1050@120Hz RB 
 0x3e - 1792x1344@60Hz 
 0x3f - 1792x1344@75Hz 
 0x40 - 1792x1344@120Hz RB 
 0x41 - 1856x1392@60Hz 
 0x42 - 1856x1392@75Hz 
 0x43 - 1856x1392@120Hz RB 
 0x52 - 1920x1080@60Hz 
 0x44 - 1920x1200@60Hz RB 
 0x45 - 1920x1200@60Hz 
 0x46 - 1920x1200@75Hz 
 0x47 - 1920x1200@85Hz 
 0x48 - 1920x1200@120Hz RB 
 0x49 - 1920x1440@60Hz 
 0x4a - 1920x1440@75Hz 
 0x4b - 1920x1440@120Hz RB 
 0x54 - 2048x1152@60Hz 
 0x4c - 2560x1600@60Hz RB 
 0x4d - 2560x1600@60Hz 
 0x4e - 2560x1600@75Hz 
 0x4f - 2560x1600@85Hz 
 0x50 - 2560x1600@120Hz RB 
 0x57 - 4096x2160@60Hz RB 
 0x58 - 4096x2160@59.94Hz RB 
  These more or less come from the DMT spec.  The 720x400 modes are
  inferred from historical 80x25 practice.  The 640x480@67 and 832x624@75
  modes are old-school Mac modes.  The EDID spec says the 1152x864@75 mode
  should be 1152x870, again for the Mac, but instead we use the x864 DMT
  mode.
  The DMT modes have been fact-checked; the rest are mild guesses.
 800x600@60Hz 
 800x600@56Hz 
 640x480@75Hz 
 640x480@72Hz 
 640x480@67Hz 
 640x480@60Hz 
 720x400@88Hz 
 720x400@70Hz 
 1280x1024@75Hz 
 1024x768@75Hz 
 1024x768@70Hz 
 1024x768@60Hz 
 1024x768@43Hz 
 832x624@75Hz 
 800x600@75Hz 
 800x600@72Hz 
 1152x864@75Hz 
 byte 6 
 byte 7 
 byte 8 
 byte 9 
 byte 10 
 byte 11 
  From CEACTA-861 spec.
  Do not access directly, instead always use cea_mode_for_vic().
 1 - 640x480@60Hz 4:3 
 2 - 720x480@60Hz 4:3 
 3 - 720x480@60Hz 16:9 
 4 - 1280x720@60Hz 16:9 
 5 - 1920x1080i@60Hz 16:9 
 6 - 720(1440)x480i@60Hz 4:3 
 7 - 720(1440)x480i@60Hz 16:9 
 8 - 720(1440)x240@60Hz 4:3 
 9 - 720(1440)x240@60Hz 16:9 
 10 - 2880x480i@60Hz 4:3 
 11 - 2880x480i@60Hz 16:9 
 12 - 2880x240@60Hz 4:3 
 13 - 2880x240@60Hz 16:9 
 14 - 1440x480@60Hz 4:3 
 15 - 1440x480@60Hz 16:9 
 16 - 1920x1080@60Hz 16:9 
 17 - 720x576@50Hz 4:3 
 18 - 720x576@50Hz 16:9 
 19 - 1280x720@50Hz 16:9 
 20 - 1920x1080i@50Hz 16:9 
 21 - 720(1440)x576i@50Hz 4:3 
 22 - 720(1440)x576i@50Hz 16:9 
 23 - 720(1440)x288@50Hz 4:3 
 24 - 720(1440)x288@50Hz 16:9 
 25 - 2880x576i@50Hz 4:3 
 26 - 2880x576i@50Hz 16:9 
 27 - 2880x288@50Hz 4:3 
 28 - 2880x288@50Hz 16:9 
 29 - 1440x576@50Hz 4:3 
 30 - 1440x576@50Hz 16:9 
 31 - 1920x1080@50Hz 16:9 
 32 - 1920x1080@24Hz 16:9 
 33 - 1920x1080@25Hz 16:9 
 34 - 1920x1080@30Hz 16:9 
 35 - 2880x480@60Hz 4:3 
 36 - 2880x480@60Hz 16:9 
 37 - 2880x576@50Hz 4:3 
 38 - 2880x576@50Hz 16:9 
 39 - 1920x1080i@50Hz 16:9 
 40 - 1920x1080i@100Hz 16:9 
 41 - 1280x720@100Hz 16:9 
 42 - 720x576@100Hz 4:3 
 43 - 720x576@100Hz 16:9 
 44 - 720(1440)x576i@100Hz 4:3 
 45 - 720(1440)x576i@100Hz 16:9 
 46 - 1920x1080i@120Hz 16:9 
 47 - 1280x720@120Hz 16:9 
 48 - 720x480@120Hz 4:3 
 49 - 720x480@120Hz 16:9 
 50 - 720(1440)x480i@120Hz 4:3 
 51 - 720(1440)x480i@120Hz 16:9 
 52 - 720x576@200Hz 4:3 
 53 - 720x576@200Hz 16:9 
 54 - 720(1440)x576i@200Hz 4:3 
 55 - 720(1440)x576i@200Hz 16:9 
 56 - 720x480@240Hz 4:3 
 57 - 720x480@240Hz 16:9 
 58 - 720(1440)x480i@240Hz 4:3 
 59 - 720(1440)x480i@240Hz 16:9 
 60 - 1280x720@24Hz 16:9 
 61 - 1280x720@25Hz 16:9 
 62 - 1280x720@30Hz 16:9 
 63 - 1920x1080@120Hz 16:9 
 64 - 1920x1080@100Hz 16:9 
 65 - 1280x720@24Hz 64:27 
 66 - 1280x720@25Hz 64:27 
 67 - 1280x720@30Hz 64:27 
 68 - 1280x720@50Hz 64:27 
 69 - 1280x720@60Hz 64:27 
 70 - 1280x720@100Hz 64:27 
 71 - 1280x720@120Hz 64:27 
 72 - 1920x1080@24Hz 64:27 
 73 - 1920x1080@25Hz 64:27 
 74 - 1920x1080@30Hz 64:27 
 75 - 1920x1080@50Hz 64:27 
 76 - 1920x1080@60Hz 64:27 
 77 - 1920x1080@100Hz 64:27 
 78 - 1920x1080@120Hz 64:27 
 79 - 1680x720@24Hz 64:27 
 80 - 1680x720@25Hz 64:27 
 81 - 1680x720@30Hz 64:27 
 82 - 1680x720@50Hz 64:27 
 83 - 1680x720@60Hz 64:27 
 84 - 1680x720@100Hz 64:27 
 85 - 1680x720@120Hz 64:27 
 86 - 2560x1080@24Hz 64:27 
 87 - 2560x1080@25Hz 64:27 
 88 - 2560x1080@30Hz 64:27 
 89 - 2560x1080@50Hz 64:27 
 90 - 2560x1080@60Hz 64:27 
 91 - 2560x1080@100Hz 64:27 
 92 - 2560x1080@120Hz 64:27 
 93 - 3840x2160@24Hz 16:9 
 94 - 3840x2160@25Hz 16:9 
 95 - 3840x2160@30Hz 16:9 
 96 - 3840x2160@50Hz 16:9 
 97 - 3840x2160@60Hz 16:9 
 98 - 4096x2160@24Hz 256:135 
 99 - 4096x2160@25Hz 256:135 
 100 - 4096x2160@30Hz 256:135 
 101 - 4096x2160@50Hz 256:135 
 102 - 4096x2160@60Hz 256:135 
 103 - 3840x2160@24Hz 64:27 
 104 - 3840x2160@25Hz 64:27 
 105 - 3840x2160@30Hz 64:27 
 106 - 3840x2160@50Hz 64:27 
 107 - 3840x2160@60Hz 64:27 
 108 - 1280x720@48Hz 16:9 
 109 - 1280x720@48Hz 64:27 
 110 - 1680x720@48Hz 64:27 
 111 - 1920x1080@48Hz 16:9 
 112 - 1920x1080@48Hz 64:27 
 113 - 2560x1080@48Hz 64:27 
 114 - 3840x2160@48Hz 16:9 
 115 - 4096x2160@48Hz 256:135 
 116 - 3840x2160@48Hz 64:27 
 117 - 3840x2160@100Hz 16:9 
 118 - 3840x2160@120Hz 16:9 
 119 - 3840x2160@100Hz 64:27 
 120 - 3840x2160@120Hz 64:27 
 121 - 5120x2160@24Hz 64:27 
 122 - 5120x2160@25Hz 64:27 
 123 - 5120x2160@30Hz 64:27 
 124 - 5120x2160@48Hz 64:27 
 125 - 5120x2160@50Hz 64:27 
 126 - 5120x2160@60Hz 64:27 
 127 - 5120x2160@100Hz 64:27 
  From CEACTA-861 spec.
  Do not access directly, instead always use cea_mode_for_vic().
 193 - 5120x2160@120Hz 64:27 
 194 - 7680x4320@24Hz 16:9 
 195 - 7680x4320@25Hz 16:9 
 196 - 7680x4320@30Hz 16:9 
 197 - 7680x4320@48Hz 16:9 
 198 - 7680x4320@50Hz 16:9 
 199 - 7680x4320@60Hz 16:9 
 200 - 7680x4320@100Hz 16:9 
 201 - 7680x4320@120Hz 16:9 
 202 - 7680x4320@24Hz 64:27 
 203 - 7680x4320@25Hz 64:27 
 204 - 7680x4320@30Hz 64:27 
 205 - 7680x4320@48Hz 64:27 
 206 - 7680x4320@50Hz 64:27 
 207 - 7680x4320@60Hz 64:27 
 208 - 7680x4320@100Hz 64:27 
 209 - 7680x4320@120Hz 64:27 
 210 - 10240x4320@24Hz 64:27 
 211 - 10240x4320@25Hz 64:27 
 212 - 10240x4320@30Hz 64:27 
 213 - 10240x4320@48Hz 64:27 
 214 - 10240x4320@50Hz 64:27 
 215 - 10240x4320@60Hz 64:27 
 216 - 10240x4320@100Hz 64:27 
 217 - 10240x4320@120Hz 64:27 
 218 - 4096x2160@100Hz 256:135 
 219 - 4096x2160@120Hz 256:135 
  HDMI 1.4 4k modes. Index using the VIC.
 0 - dummy, VICs start at 1 
 1 - 3840x2160@30Hz 
 2 - 3840x2160@25Hz 
 3 - 3840x2160@24Hz 
 4 - 4096x2160@24Hz (SMPTE) 
 DDC fetch and block validation 
  drm_edid_header_is_valid - sanity check the header of the base EDID block
  @raw_edid: pointer to raw base EDID block
  Sanity check the header of the base EDID block.
  Return: 8 if the header is perfect, down to 0 if it's totally wrong.
  drm_edid_are_equal - compare two edid blobs.
  @edid1: pointer to first blob
  @edid2: pointer to second blob
  This helper can be used during probing to determine if
  edid had changed.
  drm_edid_block_valid - Sanity check the EDID block (base or extension)
  @raw_edid: pointer to raw EDID block
  @block: type of block to validate (0 for base, extension otherwise)
  @print_bad_edid: if true, dump bad EDID blocks to the console
  @edid_corrupt: if true, the header or checksum is invalid
  Validate a base or extension EDID block and optionally dump bad blocks to
  the console.
  Return: True if the block is valid, false otherwise.
			 Displayport Link CTS Core 1.2 rev1.1 test 4.2.2.6
			  The corrupt flag needs to be set here otherwise, the
			  fix-up code here will correct the problem, the
			  checksum is correct and the test fails
 allow CEA to slide through, switches mangle this 
 per-block-type checks 
 base 
  drm_edid_is_valid - sanity check EDID data
  @edid: EDID data
  Sanity-check an entire EDID record (including extensions)
  Return: True if the EDID data is valid, false otherwise.
  drm_do_probe_ddc_edid() - get EDID information via I2C
  @data: I2C device adapter
  @buf: EDID data buffer to be filled
  @block: 128 byte EDID block to start fetching from
  @len: EDID data buffer length to fetch
  Try to fetch EDID information by calling I2C driver functions.
  Return: 0 on success or -1 on failure.
	
	  The core I2C driver will automatically retry the transfer if the
	  adapter reports EAGAIN. However, we find that bit-banging transfers
	  are susceptible to errors under a heavily loaded machine and
	  generate spurious NAKs and timeouts. Retrying the transfer
	  of the individual block a few times seems to overcome this.
		
		  Avoid sending the segment addr to not upset non-compliant
		  DDC monitors.
	
	  0x7e in the EDID is the number of extension blocks. The EDID
	  is 1 (base block) + num_ext_blocks big. That means we can think
	  of 0x7e in the EDID of the _index_ of the last block in the
	  combined chunk of memory.
 Calculate real checksum for the last edid extension block data 
 Get override or firmware EDID 
  drm_add_override_edid_modes - add modes from overridefirmware EDID
  @connector: connector we're probing
  Add modes from the overridefirmware EDID, if available. Only to be used from
  drm_helper_probe_single_connector_modes() as a fallback for when DDC probe
  failed during drm_get_edid() and caused the overridefirmware EDID to be
  skipped.
  Return: The number of modes added or 0 if we couldn't find any.
 base block fetch 
  drm_do_get_edid - get EDID data using a custom EDID block read function
  @connector: connector we're probing
  @get_edid_block: EDID block read function
  @data: private data passed to the block read function
  When the I2C adapter connected to the DDC bus is hidden behind a device that
  exposes a different interface to read EDID blocks this function can be used
  to get EDID data using a custom block read function.
  As in the general case the DDC bus is accessible by the kernel at the I2C
  level, drivers must make all reasonable efforts to expose it as an I2C
  adapter and use drm_get_edid() instead of abusing this function.
  The EDID may be overridden using debugfs override_edid or firmware EDID
  (drm_load_edid_firmware() and drm.edid_firmware parameter), in this priority
  order. Having either of them bypasses actual EDID reads.
  Return: Pointer to valid EDID or NULL if we couldn't find any.
 if there's no extensions or no connector, we're done 
  drm_probe_ddc() - probe DDC presence
  @adapter: I2C adapter to probe
  Return: True on success, false on failure.
  drm_get_edid - get EDID data, if available
  @connector: connector we're probing
  @adapter: I2C adapter to use for DDC
  Poke the given I2C channel to grab EDID data if possible.  If found,
  attach it to the connector.
  Return: Pointer to valid EDID or NULL if we couldn't find any.
	
	  We represent the ID as a 32-bit number so it can easily be compared
	  with "==".
	 
	  NOTE that we deal with endianness differently for the top half
	  of this ID than for the bottom half. The bottom half (the product
	  id) gets decoded as little endian by the EDID_PRODUCT_ID because
	  that's how everyone seems to interpret it. The top half (the mfg_id)
	  gets stored as big endian because that makes
	  drm_edid_encode_panel_id() and drm_edid_decode_panel_id() easier
	  to write (it's easier to extract the ASCII). It doesn't really
	  matter, though, as long as the number here is unique.
  drm_edid_get_panel_id - Get a panel's ID through DDC
  @adapter: I2C adapter to use for DDC
  This function reads the first block of the EDID of a panel and (assuming
  that the EDID is valid) extracts the ID out of it. The ID is a 32-bit value
  (16 bits of manufacturer ID and 16 bits of per-manufacturer ID) that's
  supposed to be different for each different modem of panel.
  This function is intended to be used during early probing on devices where
  more than one panel might be present. Because of its intended use it must
  assume that the EDID of the panel is correct, at least as far as the ID
  is concerned (in other words, we don't process any overrides here).
  NOTE: it's expected that this function and drm_do_get_edid() will both
  be read the EDID, but there is no caching between them. Since we're only
  reading the first block, hopefully this extra overhead won't be too big.
  Return: A 32-bit ID that should be different for each makemodel of panel.
          See the functions drm_edid_encode_panel_id() and
          drm_edid_decode_panel_id() for some details on the structure of this
          ID.
	
	  There are no manufacturer IDs of 0, so if there is a problem reading
	  the EDID then we'll just return 0.
  drm_get_edid_switcheroo - get EDID data for a vga_switcheroo output
  @connector: connector we're probing
  @adapter: I2C adapter to use for DDC
  Wrapper around drm_get_edid() for laptops with dual GPUs using one set of
  outputs. The wrapper adds the requisite vga_switcheroo calls to temporarily
  switch DDC to the GPU which is retrieving EDID.
  Return: Pointer to valid EDID or %NULL if we couldn't find any.
  drm_edid_duplicate - duplicate an EDID and the extensions
  @edid: EDID to duplicate
  Return: Pointer to duplicated EDID or NULL on allocation failure.
 EDID parsing 
  edid_get_quirks - return quirk flags for a given EDID
  @edid: EDID to process
  This tells subsequent routines what fixes they need to apply.
  edid_fixup_preferred - set preferred modes based on quirk list
  @connector: has mode list to fix up
  @quirks: quirks list
  Walk the mode list for @connector, clearing the preferred status
  on existing modes and setting it anew for the right mode ala @quirks.
 Largest mode is preferred 
 At a given size, try to get closest to target refresh 
  drm_mode_find_dmt - Create a copy of a mode if present in DMT
  @dev: Device to duplicate against
  @hsize: Mode width
  @vsize: Mode height
  @fresh: Mode refresh rate
  @rb: Mode reduced-blanking-ness
  Walk the DMT mode list looking for a match for the given parameters.
  Return: A newly allocated copy of the mode, or NULL if not found.
 unknown version 
 EDID 1.4 defines this explicitly.  For EDID 1.3, we guess, badly. 
 Secondary GTF curve kicks in above some break frequency 
  standard_timing_level - get std. timing level(CVTGTFDMT)
  @edid: EDID block to scan
  0 is reserved.  The spec says 0x01 fill for unused timings.  Some old
  monitors fill with ascii space (0x20) instead.
  drm_mode_std - convert standard mode info (width, height, refresh) into mode
  @connector: connector of for the EDID block
  @edid: EDID block to scan
  @t: standard timing params
  Take the standard timing params (in this case width, aspect, and refresh)
  and convert them into a real mode using CVTGTFDMT.
 According to the EDID spec, the hdisplay = hsize  8 + 248 
 vrefresh_rate = vfreq + 60 
 the vdisplay is calculated based on the aspect ratio 
 HDTV hack, part 1 
	
	  If this connector already has a mode for this size and refresh
	  rate (because it came from detailed or CVT info), use that
	  instead.  This way we don't have to guess at interlace or
	  reduced blanking.
 HDTV hack, part 2 
 check whether it can be found in default mode table 
 okay, generate it 
		
		  This is potentially wrong if there's ever a monitor with
		  more than one ranges section, each claiming a different
		  secondary GTF curve.  Please don't do that.
  EDID is delightfully ambiguous about how interlaced modes are to be
  encoded.  Our internal representation is of frame height, but some
  HDTV detailed timings are encoded as field height.
  The format list here is from CEA, in frame size.  Technically we
  should be checking refresh rate too.  Whatever.
  drm_mode_detailed - create a new mode from an EDID detailed timing section
  @dev: DRM device (needed to create new mode)
  @edid: EDID block
  @timing: EDID detailed timing info
  @quirks: quirks to apply
  An EDID detailed timing block contains enough info for us to create and
  return a new struct drm_display_mode.
 ignore tiny modes 
 it is incorrect if hsyncvsync width is zero 
 Some EDIDs have bogus hvtotal values 
 unspecified 
 1.4 with CVT support gives us real precision, yay 
 1.3 is pathetic, so fuzz up a bit 
 1.4 max horizontal check 
 duplicated 
 fix up 1366x768 mode from 1368x768;
  GFTCVT can't express 1366 width which isn't dividable by 8
 GTF not defined yet 
 secondary gtf, XXX could do more 
 default gtf 
 cvt, only in 1.4+ 
 just the ranges, no formula 
  add_established_modes - get est. modes from EDID and add them
  @connector: connector to add mode(s) to
  @edid: EDID block to scan
  Each EDID block contains a bitmap of the supported "established modes" list
  (defined above).  Tease them out and add them to the global modes list.
  add_standard_modes - get std. modes from EDID and add them
  @connector: connector to add mode(s) to
  @edid: EDID block to scan
  Standard modes can be calculated using the appropriate standard (DMT,
  GTF or CVT. Grab them from @edid and add them to the list.
 XXX should also look for standard codes in VTB blocks 
 default - because compiler doesn't see that we've enumerated all cases 
 XXX should also look for CVT codes in VTB blocks 
	
	  Detailed modes are limited to 10kHz pixel clock resolution,
	  so fix up anything that looks like CEAHDMI mode, but the clock
	  is just slightly off.
  add_detailed_modes - Add modes from detailed timings
  @connector: attached connector
  @edid: EDID block to scan
  @quirks: quirks to apply
  Search EDID for CEA extension block.
 No EDID or EDID extensions 
 Find CEA extension 
 Look for a top level CEA extension block 
 FIXME: make callers iterate through multiple CEA ext blocks? 
 CEA blocks can also be found embedded in a DisplayID block 
  Calculate the alternate clock for the CEA mode
  (60Hz vs. 59.94Hz etc.)
	
	  edid_cea_modes contains the 59.94Hz
	  variant for 240 and 480 line modes,
	  and the 60Hz variant otherwise.
	
	  For certain VICs the spec allows the vertical
	  front porch to vary by one or two lines.
	 
	  cea_modes[] stores the variant with the shortest
	  vertical front porch. We can adjust the mode to
	  get the other variants by simply increasing the
	  vertical front porch length.
 Check both 60Hz and 59.94Hz 
  drm_match_cea_mode - look for a CEA mode matching given mode
  @to_match: display mode
  Return: The CEA Video ID (VIC) of the mode or 0 if it isn't a CEA-861
  mode.
 Check both 60Hz and 59.94Hz 
  Calculate the alternate clock for HDMI modes (those from the HDMI vendor
  specific block).
 Make sure to also match alternate clocks 
  drm_match_hdmi_mode - look for a HDMI mode matching given mode
  @to_match: display mode
  An HDMI mode is one defined in the HDMI vendor specific block.
  Returns the HDMI Video ID (VIC) of the mode or 0 if it isn't one.
 Make sure to also match alternate clocks 
 Don't add CEA modes if the CEA extension block is missing 
	
	  Go through all probed modes and create a new mode
	  with the alternate clock for certain CEA modes.
 Carry over the stereo flags 
		
		  The current mode could be either variant. Make
		  sure to pick the "other" clock for the new mode.
 0-6 bit vic, 7th bit native mode indicator 
 CEA modes are numbered 1..127 
  do_y420vdb_modes - Parse YCBCR 420 only modes
  @connector: connector corresponding to the HDMI sink
  @svds: start of the data block of CEA YCBCR 420 VDB
  @len: length of the CEA YCBCR 420 VDB
  Parse the CEA-861-F YCBCR 420 Video Data Block (Y420VDB)
  which contains modes which can be supported in YCBCR 420
  output format only.
  drm_add_cmdb_modes - Add a YCBCR 420 mode into bitmap
  @connector: connector corresponding to the HDMI sink
  @vic: CEA vic for the video mode to be added in the map
  Makes an entry for a videomode in the YCBCR 420 bitmap
  drm_display_mode_from_cea_vic() - return a mode for CEA VIC
  @dev: DRM device
  @video_code: CEA VIC of the mode
  Creates a new mode matching the specified CEA VIC.
  Returns: A new drm_display_mode on success or NULL on failure
			
			  YCBCR420 capability block contains a bitmap which
			  gives the index of CEA modes from CEA VDB, which
			  can support YCBCR 420 sampling output also (apart
			  from RGBYCBCR444 etc).
			  For example, if the bit 0 in bitmap is set,
			  first mode in VDB can support YCBCR420 output too.
			  Add YCBCR420 modes only if sink is HDMI 2.0 capable.
  do_hdmi_vsdb_modes - Parse the HDMI Vendor Specific data block
  @connector: connector corresponding to the HDMI sink
  @db: start of the CEA vendor specific block
  @len: length of the CEA block payload, ie. one can access up to db[len]
  Parses the HDMI VSDB looking for modes to add to @connector. This function
  also adds the stereo 3d modes when applicable.
 no HDMI_Video_Present 
 Latency_Fields_Present 
 I_Latency_Fields_Present 
	 the declared length is not long enough for the 2 first bytes
 3D_Present 
 3D_Multi_present 
 3D_Structure_ALL 
 check if 3D_MASK is present 
 2D_VIC_order_X 
 3D_Structure_X 
 3D_Detail_X 
	
	  FIXME is this correct for the DispID variant?
	  The DispID spec doesn't really specify whether
	  this is the revision of the CEA extension or
	  the DispID CEA data block. And the only value
	  given as an example is 0.
	 DisplayID CTA extension blocks and top-level CEA EDID
	  block header definitions differ in the following bytes:
	    1) Byte 2 of the header specifies length differently,
	    2) Byte 3 is only present in the CEA top level block.
	 
	  The different definitions for byte 2 follow.
	 
	  DisplayID CTA extension block defines byte 2 as:
	    Number of payload bytes
	 
	  CEA EDID block defines byte 2 as:
	    Byte number (decimal) within this block where the 18-byte
	    DTDs begin. If no non-DTD data is present in this extension
	    block, the value should be set to 04h (the byte after next).
	    If set to 00h, there are no DTDs present in this block and
	    no non-DTD data.
		
		  for_each_displayid_db() has already verified
		  that these stay within expected bounds.
 Data block offset in CEA extension block 
 All CEA modes support ycbcr420 sampling also.
	
	  This map indicates which of the existing CEA block modes
	  from VDB can support YCBCR420 output too. So if bit=0 is
	  set, first mode from VDB can support YCBCR420 output too.
	  We will parse and keep this map, before parsing VDB itself
	  to avoid going through the same block again and again.
	 
	  Spec is not clear about max possible size of this block.
	  Clamping max bitmap block size at 8 bytes. Every byte can
	  address 8 CEA modes, in this way this map can address
	  88 = first 64 SVDs.
 Add 4:2:0(only) modes present in EDID 
	
	  We parse the HDMI VSDB after having added the cea modes as we will
	  be patching their flags when the sink supports stereo 3D.
	
	  allow 5kHz clock difference either way to account for
	  the 10kHz clock resolution limit of detailed timings.
 pick whichever is closest 
  drm_edid_get_monitor_name - fetch the monitor name from the edid
  @edid: monitor EDID information
  @name: pointer to a character array to hold the name of the monitor
  @bufsize: The size of the name buffer (should be at least 14 chars.)
  drm_edid_to_eld - build ELD from EDID
  @connector: connector corresponding to the HDMIDP sink
  @edid: EDID to parse
  Fill the ELD (EDID-Like Data) buffer for passing to the audio driver. The
  HDCP and Port_ID ELD fields are left for the graphics driver to fill in.
 Audio Data Block, contains SADs 
 Speaker Allocation Data Block 
 HDMI Vendor-Specific Data Block 
  drm_edid_to_sad - extracts SADs from EDID
  @edid: EDID to parse
  @sads: pointer that will be set to the extracted SADs
  Looks for CEA EDID block and extracts SADs (Short Audio Descriptors) from it.
  Note: The returned pointer needs to be freed using kfree().
  Return: The number of found SADs or negative number on error.
 SAD is 3B 
  drm_edid_to_speaker_allocation - extracts Speaker Allocation Data Blocks from EDID
  @edid: EDID to parse
  @sadb: pointer to the speaker block
  Looks for CEA EDID block and extracts the Speaker Allocation Data Block from it.
  Note: The returned pointer needs to be freed using kfree().
  Return: The number of found Speaker Allocation Blocks or negative number on
  error.
 Speaker Allocation Data Block 
  drm_av_sync_delay - compute the HDMIDP sink audio-video sync delay
  @connector: connector associated with the HDMIDP sink
  @mode: the display mode
  Return: The HDMIDP sink's audio-video sync delay in milliseconds or 0 if
  the sink doesn't support audio or video.
	
	  HDMIDP sink doesn't support audio or video?
	
	  Convert raw EDID values to millisecond.
	  Treat unknown latency as 0ms.
  drm_detect_hdmi_monitor - detect whether monitor is HDMI
  @edid: monitor EDID information
  Parse the CEA extension according to CEA-861-B.
  Drivers that have added the modes parsed from EDID to drm_display_info
  should use &drm_display_info.is_hdmi instead of calling this function.
  Return: True if the monitor is HDMI, false if not or unknown.
	
	  Because HDMI identifier is in Vendor Specific Block,
	  search it from all data blocks of CEA extension.
  drm_detect_monitor_audio - check monitor audio capability
  @edid: EDID block to scan
  Monitor should have CEA extension block.
  If monitor has 'basic audio', but no CEA audio blocks, it's 'basic
  audio' only. If there is any audio extension block and supported
  audio format, assume at least 'basic audio' support, even if 'basic
  audio' is not defined in EDID.
  Return: True if the monitor supports audio, false otherwise.
  drm_default_rgb_quant_range - default RGB quantization range
  @mode: display mode
  Determine the default RGB quantization range for the mode,
  as specified in CEA-861.
  Return: The default RGB quantization range for the mode
 All CEA modes other than VIC 1 use limited quantization range. 
	
	  All HDMI 2.0 monitors must support scrambling at rates > 340 MHz.
	  And as per the spec, three factors confirm this:
	   Availability of a HF-VSDB block in EDID (check)
	   Non zero Max_TMDS_Char_Rate filed in HF-VSDB (let's check)
	   SCDC support available (let's check)
	  Lets check it out.
 max clock is 5000 KHz times block value 
 Few sinks support scrambling for clocks < 340M 
 HDMI supports at least 8 bpc 
	
	  Deep color support mandates RGB444 support for all video
	  modes and forbids YCRCB422 support for all video modes per
	  HDMI 1.3 spec.
 YCRCB444 is optional according to spec. 
	
	  Spec says that if any deep color mode is supported at all,
	  then deep color 36 bit must be supported.
 The existence of a CEA block should imply RGB support 
	
	  Check for flag range limits only. If flag == 1 then
	  no additional timing information provided.
	  Default GTF, GTF Secondary curve and CVT are not
	  supported
 2 or 4 links 
 4 links 
 A connector has no EDID information, so we've got no EDID to compute quirks from. Reset
  all of the values which would have been set from EDID
	
	  Digital sink with "DFP 1.x compliant TMDS" according to EDID 1.3?
	 
	  For such displays, the DFP spec 1.0, section 3.10 "EDID support"
	  tells us to assume 8 bpc color depth if the EDID doesn't have
	  extensions which tell otherwise.
 Only defined for 1.4 with digital displays 
 blocks must be multiple of 20 bytes length 
  drm_add_edid_modes - add modes from EDID data, if available
  @connector: connector we're probing
  @edid: EDID data
  Add the specified modes to the connector's mode list. Also fills out the
  &drm_display_info structure and ELD in @connector with any information which
  can be derived from the edid.
  Return: The number of modes added or 0 if we couldn't find any.
	
	  CEA-861-F adds ycbcr capability map block, for HDMI 2.0 sinks.
	  To avoid multiple parsing of same block, lets parse that map
	  from sink info, before parsing CEA modes.
	
	  EDID spec says modes should be preferred in this order:
	  - preferred detailed mode
	  - other detailed modes from base block
	  - detailed modes from extension blocks
	  - CVT 3-byte code modes
	  - standard timing codes
	  - established timing codes
	  - modes inferred from GTF or CVT range information
	 
	  We get this pretty much right.
	 
	  XXX order for additional mode types in extension blocks?
  drm_add_modes_noedid - add modes for the connectors without EDID
  @connector: connector we're probing
  @hdisplay: the horizontal display limit
  @vdisplay: the vertical display limit
  Add the specified modes to the connector's mode list. Only when the
  hdisplayvdisplay is not beyond the given limit, it will be added.
  Return: The number of modes added or 0 if we couldn't find any.
			
			  Only when two are valid, they will be used to check
			  whether the mode should be added to the mode list of
			  the connector.
  drm_set_preferred_mode - Sets the preferred mode of a connector
  @connector: connector whose mode list should be processed
  @hpref: horizontal resolution of preferred mode
  @vpref: vertical resolution of preferred mode
  Marks a mode as preferred if it matches the resolution specified by @hpref
  and @vpref.
	
	  FIXME: sil-sii8620 doesn't have a connector around when
	  we need one, so we have to be prepared for a NULL connector.
  drm_hdmi_infoframe_set_hdr_metadata() - fill an HDMI DRM infoframe with
                                          HDR metadata from userspace
  @frame: HDMI DRM infoframe
  @conn_state: Connector state containing HDR metadata
  Return: 0 on success or a negative error code on failure.
 Sink EOTF is Bit map while infoframe is absolute values 
 No HDMI VIC when signalling 3D video format 
	
	  HDMI spec says if a mode is found in HDMI 1.4b 4K modes
	  we should send its VIC in vendor infoframes, else send the
	  VIC in AVI infoframes. Lets check if this mode is present in
	  HDMI 1.4b 4K modes
	
	  HDMI 1.4 VIC range: 1 <= VIC <= 64 (CEA-861-D) but
	  HDMI 2.0 VIC range: 1 <= VIC <= 107 (CEA-861-F). So we
	  have to make sure we dont break HDMI 1.4 sinks.
  drm_hdmi_avi_infoframe_from_display_mode() - fill an HDMI AVI infoframe with
                                               data from a DRM display mode
  @frame: HDMI AVI infoframe
  @connector: the connector
  @mode: DRM display mode
  Return: 0 on success or a negative error code on failure.
	
	  As some drivers don't support atomic, we can't use connector state.
	  So just initialize the frame with default values, just the same way
	  as it's done with other properties here.
	
	  Populate picture aspect ratio from either
	  user input (if specified) or from the CEAHDMI mode lists.
	
	  The infoframe can't convey anything but none, 4:3
	  and 16:9, so if the user has asked for anything else
	  we can only satisfy it by specifying the right VIC.
 HDMI Colorspace Spec Definitions 
  drm_hdmi_avi_infoframe_colorspace() - fill the HDMI AVI infoframe
                                        colorspace information
  @frame: HDMI AVI infoframe
  @conn_state: connector state
	
	  ToDo: Extend it for ACE formats as well. Modify the infoframe
	  structure and extend it in driversvideohdmi
  drm_hdmi_avi_infoframe_quant_range() - fill the HDMI AVI infoframe
                                         quantization range information
  @frame: HDMI AVI infoframe
  @connector: the connector
  @mode: DRM display mode
  @rgb_quant_range: RGB quantization range (Q)
	
	  CEA-861:
	  "A Source shall not send a non-zero Q value that does not correspond
	   to the default RGB Quantization Range for the transmitted Picture
	   unless the Sink indicates support for the Q bit in a Video
	   Capabilities Data Block."
	 
	  HDMI 2.0 recommends sending non-zero Q when it does match the
	  default RGB quantization range for the mode, even when QS=0.
	
	  CEA-861-F:
	  "When transmitting any RGB colorimetry, the Source should set the
	   YQ-field to match the RGB Quantization Range being transmitted
	   (e.g., when Limited Range RGB, set YQ=0 or when Full Range RGB,
	   set YQ=1) and the Sink shall ignore the YQ-field."
	 
	  Unfortunate certain sinks (eg. VIZ Model 67E261VA) get confused
	  by non-zero YQ when receiving RGB. There doesn't seem to be any
	  good way to tell which version of CEA-861 the sink supports, so
	  we limit non-zero YQ to HDMI 2.0 sinks only as HDMI 2.0 is based
	  on on CEA-861-F.
  drm_hdmi_avi_infoframe_bars() - fill the HDMI AVI infoframe
                                  bar information
  @frame: HDMI AVI infoframe
  @conn_state: connector state
  drm_hdmi_vendor_infoframe_from_display_mode() - fill an HDMI infoframe with
  data from a DRM display mode
  @frame: HDMI vendor infoframe
  @connector: the connector
  @mode: DRM display mode
  Note that there's is a need to send HDMI vendor infoframes only when using a
  4k or stereoscopic 3D mode. So when giving any other mode as input this
  function will return -EINVAL, error that can be safely ignored.
  Return: 0 on success or a negative error code on failure.
	
	  FIXME: sil-sii8620 doesn't have a connector around when
	  we need one, so we have to be prepared for a NULL connector.
	
	  Even if it's not absolutely necessary to send the infoframe
	  (ie.vic==0 and s3d_struct==0) we will still send it if we
	  know that the sink can handle it. This is based on a
	  suggestion in HDMI 2.0 Appendix F. Apparently some sinks
	  have trouble realizing that they should switch from 3D to 2D
	  mode if the source simply stops sending the infoframe when
	  it wants to switch from 3D to 2D.
		 if we haven't got a pointer,
 if same tile group, then release the ref we just took. 
