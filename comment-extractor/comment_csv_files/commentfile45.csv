/*******************************************************************

 * This file is part of the Emulex Linux Device Driver for         *

 * Fibre Channel Host Bus Adapters.                                *

 * Copyright (C) 2017-2021 Broadcom. All Rights Reserved. The term *

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.     *

 * Copyright (C) 2004-2016 Emulex.  All rights reserved.           *

 * EMULEX and SLI are trademarks of Emulex.                        *

 * www.broadcom.com                                                *

 * Portions Copyright (C) 2004-2005 Christoph Hellwig              *

 *                                                                 *

 * This program is free software; you can redistribute it and/or   *

 * modify it under the terms of version 2 of the GNU General       *

 * Public License as published by the Free Software Foundation.    *

 * This program is distributed in the hope that it will be useful. *

 * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *

 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *

 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *

 * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *

 * TO BE LEGALLY INVALID.  See the GNU General Public License for  *

 * more details, a copy of which can be found in the file COPYING  *

 * included with this package.                                     *

 There are only four IOCB completion types. */

 Provide function prototypes local to this module. */

 Setup WQE templates for IOs */

 IREAD template */

 Word 0, 1, 2 - BDE is variable */

 Word 3 - cmd_buff_len, payload_offset_len is zero */

 Word 4 - total_xfer_len is variable */

 Word 5 - is zero */

 Word 6 - ctxt_tag, xri_tag is variable */

 Word 7 */

 Word 8 - abort_tag is variable */

 Word 9  - reqtag is variable */

 Word 10 - dbde, wqes is variable */

 Word 11 - pbde is variable */

 Word 12 - is zero */

 Word 13, 14, 15 - PBDE is variable */

 IWRITE template */

 Word 0, 1, 2 - BDE is variable */

 Word 3 - cmd_buff_len, payload_offset_len is zero */

 Word 4 - total_xfer_len is variable */

 Word 5 - initial_xfer_len is variable */

 Word 6 - ctxt_tag, xri_tag is variable */

 Word 7 */

 Word 8 - abort_tag is variable */

 Word 9  - reqtag is variable */

 Word 10 - dbde, wqes is variable */

 Word 11 - pbde is variable */

 Word 12 - is zero */

 Word 13, 14, 15 - PBDE is variable */

 ICMND template */

 Word 0, 1, 2 - BDE is variable */

 Word 3 - payload_offset_len is variable */

 Word 4, 5 - is zero */

 Word 6 - ctxt_tag, xri_tag is variable */

 Word 7 */

 Word 8 - abort_tag is variable */

 Word 9  - reqtag is variable */

 Word 10 - dbde, wqes is variable */

 Word 11 */

 Word 12, 13, 14, 15 - is zero */

/**

 * lpfc_sli4_pcimem_bcopy - SLI4 memory copy function

 * @srcp: Source memory pointer.

 * @destp: Destination memory pointer.

 * @cnt: Number of words required to be copied.

 *       Must be a multiple of sizeof(uint64_t)

 *

 * This function is used for copying data between driver memory

 * and the SLI WQ. This function also changes the endianness

 * of each word if native endianness is different from SLI

 * endianness. This function can be called with or without

 * lock.

/**

 * lpfc_sli4_wq_put - Put a Work Queue Entry on an Work Queue

 * @q: The Work Queue to operate on.

 * @wqe: The work Queue Entry to put on the Work queue.

 *

 * This routine will copy the contents of @wqe to the next available entry on

 * the @q. This function will then ring the Work Queue Doorbell to signal the

 * HBA to start processing the Work Queue Entry. This function returns 0 if

 * successful. If no entries are available on @q then this function will return

 * -ENOMEM.

 * The caller is expected to hold the hbalock when calling this routine.

 sanity check on queue memory */

 If the host has not yet processed the next entry then we are done */

 set consumption flag every once in a while */

 write to DPP aperture taking advatage of Combined Writes */

 ensure WQE bcopy and DPP flushed before doorbell write */

 Update the host index before invoking device */

 Ring Doorbell */

 Leave bits <23:16> clear for if_type 6 dpp */

/**

 * lpfc_sli4_wq_release - Updates internal hba index for WQ

 * @q: The Work Queue to operate on.

 * @index: The index to advance the hba index to.

 *

 * This routine will update the HBA index of a queue to reflect consumption of

 * Work Queue Entries by the HBA. When the HBA indicates that it has consumed

 * an entry the host calls this function to update the queue's internal

 * pointers.

 sanity check on queue memory */

/**

 * lpfc_sli4_mq_put - Put a Mailbox Queue Entry on an Mailbox Queue

 * @q: The Mailbox Queue to operate on.

 * @mqe: The Mailbox Queue Entry to put on the Work queue.

 *

 * This routine will copy the contents of @mqe to the next available entry on

 * the @q. This function will then ring the Work Queue Doorbell to signal the

 * HBA to start processing the Work Queue Entry. This function returns 0 if

 * successful. If no entries are available on @q then this function will return

 * -ENOMEM.

 * The caller is expected to hold the hbalock when calling this routine.

 sanity check on queue memory */

 If the host has not yet processed the next entry then we are done */

 Save off the mailbox pointer for completion */

 Update the host index before invoking device */

 Ring Doorbell */

/**

 * lpfc_sli4_mq_release - Updates internal hba index for MQ

 * @q: The Mailbox Queue to operate on.

 *

 * This routine will update the HBA index of a queue to reflect consumption of

 * a Mailbox Queue Entry by the HBA. When the HBA indicates that it has consumed

 * an entry the host calls this function to update the queue's internal

 * pointers. This routine returns the number of entries that were consumed by

 * the HBA.

 sanity check on queue memory */

 Clear the mailbox pointer for completion */

/**

 * lpfc_sli4_eq_get - Gets the next valid EQE from a EQ

 * @q: The Event Queue to get the first valid EQE from

 *

 * This routine will get the first valid Event Queue Entry from @q, update

 * the queue's internal hba index, and return the EQE. If no valid EQEs are in

 * the Queue (no more work to do), or the Queue is full of EQEs that have been

 * processed, but not popped back to the HBA then this routine will return NULL.

 sanity check on queue memory */

 If the next EQE is not valid then we are done */

	/*

	 * insert barrier for instruction interlock : data from the hardware

	 * must have the valid bit checked before it can be copied and acted

	 * upon. Speculative instructions were allowing a bcopy at the start

	 * of lpfc_sli4_fp_handle_wcqe(), which is called immediately

	 * after our return, to copy data before the valid bit check above

	 * was done. As such, some of the copied data was stale. The barrier

	 * ensures the check is before any data is copied.

/**

 * lpfc_sli4_eq_clr_intr - Turn off interrupts from this EQ

 * @q: The Event Queue to disable interrupts

 *

/**

 * lpfc_sli4_if6_eq_clr_intr - Turn off interrupts from this EQ

 * @q: The Event Queue to disable interrupts

 *

/**

 * lpfc_sli4_write_eq_db - write EQ DB for eqe's consumed or arm state

 * @phba: adapter with EQ

 * @q: The Event Queue that the host has completed processing for.

 * @count: Number of elements that have been consumed

 * @arm: Indicates whether the host wants to arms this CQ.

 *

 * This routine will notify the HBA, by ringing the doorbell, that count

 * number of EQEs have been processed. The @arm parameter indicates whether

 * the queue should be rearmed when ringing the doorbell.

 sanity check on queue memory */

 ring doorbell for number popped */

 PCI read to flush PCI pipeline on re-arming for INTx mode */

/**

 * lpfc_sli4_if6_write_eq_db - write EQ DB for eqe's consumed or arm state

 * @phba: adapter with EQ

 * @q: The Event Queue that the host has completed processing for.

 * @count: Number of elements that have been consumed

 * @arm: Indicates whether the host wants to arms this CQ.

 *

 * This routine will notify the HBA, by ringing the doorbell, that count

 * number of EQEs have been processed. The @arm parameter indicates whether

 * the queue should be rearmed when ringing the doorbell.

 sanity check on queue memory */

 ring doorbell for number popped */

 PCI read to flush PCI pipeline on re-arming for INTx mode */

 if the index wrapped around, toggle the valid bit */

 walk all the EQ entries and drop on the floor */

 Get the reference to the corresponding CQ */

 If CQ is valid, iterate through it and drop all the CQEs */

 Clear and re-arm the CQ */

 Clear and re-arm the EQ */

 Track the max number of EQEs processed in 1 intr */

 Always clear the EQ. */

/**

 * lpfc_sli4_cq_get - Gets the next valid CQE from a CQ

 * @q: The Completion Queue to get the first valid CQE from

 *

 * This routine will get the first valid Completion Queue Entry from @q, update

 * the queue's internal hba index, and return the CQE. If no valid CQEs are in

 * the Queue (no more work to do), or the Queue is full of CQEs that have been

 * processed, but not popped back to the HBA then this routine will return NULL.

 sanity check on queue memory */

 If the next CQE is not valid then we are done */

	/*

	 * insert barrier for instruction interlock : data from the hardware

	 * must have the valid bit checked before it can be copied and acted

	 * upon. Given what was seen in lpfc_sli4_cq_get() of speculative

	 * instructions allowing action on content before valid bit checked,

	 * add barrier here as well. May not be needed as "content" is a

	 * single 32-bit entity here (vs multi word structure for cq's).

 if the index wrapped around, toggle the valid bit */

/**

 * lpfc_sli4_write_cq_db - write cq DB for entries consumed or arm state.

 * @phba: the adapter with the CQ

 * @q: The Completion Queue that the host has completed processing for.

 * @count: the number of elements that were consumed

 * @arm: Indicates whether the host wants to arms this CQ.

 *

 * This routine will notify the HBA, by ringing the doorbell, that the

 * CQEs have been processed. The @arm parameter specifies whether the

 * queue should be rearmed when ringing the doorbell.

 sanity check on queue memory */

 ring doorbell for number popped */

/**

 * lpfc_sli4_if6_write_cq_db - write cq DB for entries consumed or arm state.

 * @phba: the adapter with the CQ

 * @q: The Completion Queue that the host has completed processing for.

 * @count: the number of elements that were consumed

 * @arm: Indicates whether the host wants to arms this CQ.

 *

 * This routine will notify the HBA, by ringing the doorbell, that the

 * CQEs have been processed. The @arm parameter specifies whether the

 * queue should be rearmed when ringing the doorbell.

 sanity check on queue memory */

 ring doorbell for number popped */

/*

 * lpfc_sli4_rq_put - Put a Receive Buffer Queue Entry on a Receive Queue

 *

 * This routine will copy the contents of @wqe to the next available entry on

 * the @q. This function will then ring the Receive Queue Doorbell to signal the

 * HBA to start processing the Receive Queue Entry. This function returns the

 * index that the rqe was copied to if successful. If no entries are available

 * on @q then this function will return -ENOMEM.

 * The caller is expected to hold the hbalock when calling this routine.

 sanity check on queue memory */

 If the host has not yet processed the next entry then we are done */

 Update the host index to point to the next slot */

 Ring The Header Receive Queue Doorbell */

/*

 * lpfc_sli4_rq_release - Updates internal hba index for RQ

 *

 * This routine will update the HBA index of a queue to reflect consumption of

 * one Receive Queue Entry by the HBA. When the HBA indicates that it has

 * consumed an entry the host calls this function to update the queue's

 * internal pointers. This routine returns the number of entries that were

 * consumed by the HBA.

 sanity check on queue memory */

/**

 * lpfc_cmd_iocb - Get next command iocb entry in the ring

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 *

 * This function returns pointer to next command iocb entry

 * in the command ring. The caller must hold hbalock to prevent

 * other threads consume the next command iocb.

 * SLI-2/SLI-3 provide different sized iocbs.

/**

 * lpfc_resp_iocb - Get next response iocb entry in the ring

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 *

 * This function returns pointer to next response iocb entry

 * in the response ring. The caller must hold hbalock to make sure

 * that no other thread consume the next response iocb.

 * SLI-2/SLI-3 provide different sized iocbs.

/**

 * __lpfc_sli_get_iocbq - Allocates an iocb object from iocb pool

 * @phba: Pointer to HBA context object.

 *

 * This function is called with hbalock held. This function

 * allocates a new driver iocb object from the iocb pool. If the

 * allocation is successful, it returns pointer to the newly

 * allocated iocb object else it returns NULL.

/**

 * __lpfc_clear_active_sglq - Remove the active sglq for this XRI.

 * @phba: Pointer to HBA context object.

 * @xritag: XRI value.

 *

 * This function clears the sglq pointer from the array of active

 * sglq's. The xritag that is passed in is used to index into the

 * array. Before the xritag can be used it needs to be adjusted

 * by subtracting the xribase.

 *

 * Returns sglq ponter = success, NULL = Failure.

/**

 * __lpfc_get_active_sglq - Get the active sglq for this XRI.

 * @phba: Pointer to HBA context object.

 * @xritag: XRI value.

 *

 * This function returns the sglq pointer from the array of active

 * sglq's. The xritag that is passed in is used to index into the

 * array. Before the xritag can be used it needs to be adjusted

 * by subtracting the xribase.

 *

 * Returns sglq ponter = success, NULL = Failure.

/**

 * lpfc_clr_rrq_active - Clears RRQ active bit in xri_bitmap.

 * @phba: Pointer to HBA context object.

 * @xritag: xri used in this exchange.

 * @rrq: The RRQ to be cleared.

 *

 Lookup did to verify if did is still active on this vport */

/**

 * lpfc_handle_rrq_active - Checks if RRQ has waithed RATOV.

 * @phba: Pointer to HBA context object.

 *

 * This function is called with hbalock held. This function

 * Checks if stop_time (ratov from setting rrq active) has

 * been reached, if it has and the send_rrq flag is set then

 * it will call lpfc_send_rrq. If the send_rrq flag is not set

 * then it will just call the routine to clear the rrq and

 * free the rrq resource.

 * The timer is set to the next rrq that is going to expire before

 * leaving the routine.

 *

 this call will free the rrq */

			/* if we send the rrq then the completion handler

			*  will clear the bit in the xribitmap.

/**

 * lpfc_get_active_rrq - Get the active RRQ for this exchange.

 * @vport: Pointer to vport context object.

 * @xri: The xri used in the exchange.

 * @did: The targets DID for this exchange.

 *

 * returns NULL = rrq not found in the phba->active_rrq_list.

 *         rrq = rrq for this xri and target.

/**

 * lpfc_cleanup_vports_rrqs - Remove and clear the active RRQ for this vport.

 * @vport: Pointer to vport context object.

 * @ndlp: Pointer to the lpfc_node_list structure.

 * If ndlp is NULL Remove all active RRQs for this vport from the

 * phba->active_rrq_list and clear the rrq.

 * If ndlp is not NULL then only remove rrqs for this vport & this ndlp.

/**

 * lpfc_test_rrq_active - Test RRQ bit in xri_bitmap.

 * @phba: Pointer to HBA context object.

 * @ndlp: Targets nodelist pointer for this exchange.

 * @xritag: the xri in the bitmap to test.

 *

 * This function returns:

 * 0 = rrq not active for this xri

 * 1 = rrq is valid for this xri.

/**

 * lpfc_set_rrq_active - set RRQ active bit in xri_bitmap.

 * @phba: Pointer to HBA context object.

 * @ndlp: nodelist pointer for this target.

 * @xritag: xri used in this exchange.

 * @rxid: Remote Exchange ID.

 * @send_rrq: Flag used to determine if we should send rrq els cmd.

 *

 * This function takes the hbalock.

 * The active bit is always set in the active rrq xri_bitmap even

 * if there is no slot avaiable for the other rrq information.

 *

 * returns 0 rrq actived for this xri

 *         < 0 No memory or invalid ndlp.

/**

 * __lpfc_sli_get_els_sglq - Allocates an iocb object from sgl pool

 * @phba: Pointer to HBA context object.

 * @piocbq: Pointer to the iocbq.

 *

 * The driver calls this function with either the nvme ls ring lock

 * or the fc els ring lock held depending on the iocb usage.  This function

 * gets a new driver sglq object from the sglq list. If the list is not empty

 * then it is successful, it returns pointer to the newly allocated sglq

 * object else it returns NULL.

			/* This xri has an rrq outstanding for this DID.

			 * put it back in the list and get another xri.

/**

 * __lpfc_sli_get_nvmet_sglq - Allocates an iocb object from sgl pool

 * @phba: Pointer to HBA context object.

 * @piocbq: Pointer to the iocbq.

 *

 * This function is called with the sgl_list lock held. This function

 * gets a new driver sglq object from the sglq list. If the

 * list is not empty then it is successful, it returns pointer to the newly

 * allocated sglq object else it returns NULL.

/**

 * lpfc_sli_get_iocbq - Allocates an iocb object from iocb pool

 * @phba: Pointer to HBA context object.

 *

 * This function is called with no lock held. This function

 * allocates a new driver iocb object from the iocb pool. If the

 * allocation is successful, it returns pointer to the newly

 * allocated iocb object else it returns NULL.

/**

 * __lpfc_sli_release_iocbq_s4 - Release iocb to the iocb pool

 * @phba: Pointer to HBA context object.

 * @iocbq: Pointer to driver iocb object.

 *

 * This function is called to release the driver iocb object

 * to the iocb pool. The iotag in the iocb object

 * does not change for each use of the iocb object. This function

 * clears all other fields of the iocb object when it is freed.

 * The sqlq structure that holds the xritag and phys and virtual

 * mappings for the scatter gather list is retrieved from the

 * active array of sglq. The get of the sglq pointer also clears

 * the entry in the array. If the status of the IO indiactes that

 * this IO was aborted then the sglq entry it put on the

 * lpfc_abts_els_sgl_list until the CQ_ABORTED_XRI is received. If the

 * IO has good status or fails for any other reason then the sglq

 * entry is added to the free list (lpfc_els_sgl_list). The hbalock is

 *  asserted held in the code path calling this routine.

 Check if we can get a reference on ndlp */

 Check if TXQ queue needs to be serviced */

	/*

	 * Clean all volatile data fields, preserve iotag and node struct.

/**

 * __lpfc_sli_release_iocbq_s3 - Release iocb to the iocb pool

 * @phba: Pointer to HBA context object.

 * @iocbq: Pointer to driver iocb object.

 *

 * This function is called to release the driver iocb object to the

 * iocb pool. The iotag in the iocb object does not change for each

 * use of the iocb object. This function clears all other fields of

 * the iocb object when it is freed. The hbalock is asserted held in

 * the code path calling this routine.

	/*

	 * Clean all volatile data fields, preserve iotag and node struct.

/**

 * __lpfc_sli_release_iocbq - Release iocb to the iocb pool

 * @phba: Pointer to HBA context object.

 * @iocbq: Pointer to driver iocb object.

 *

 * This function is called with hbalock held to release driver

 * iocb object to the iocb pool. The iotag in the iocb object

 * does not change for each use of the iocb object. This function

 * clears all other fields of the iocb object when it is freed.

/**

 * lpfc_sli_release_iocbq - Release iocb to the iocb pool

 * @phba: Pointer to HBA context object.

 * @iocbq: Pointer to driver iocb object.

 *

 * This function is called with no lock held to release the iocb to

 * iocb pool.

	/*

	 * Clean all volatile data fields, preserve iotag and node struct.

/**

 * lpfc_sli_cancel_iocbs - Cancel all iocbs from a list.

 * @phba: Pointer to HBA context object.

 * @iocblist: List of IOCBs.

 * @ulpstatus: ULP status in IOCB command field.

 * @ulpWord4: ULP word-4 in IOCB command field.

 *

 * This function is called with a list of IOCBs to cancel. It cancels the IOCB

 * on the list by invoking the complete callback function associated with the

 * IOCB with the provided @ulpstatus and @ulpword4 set to the IOCB commond

 * fields.

/**

 * lpfc_sli_iocb_cmd_type - Get the iocb type

 * @iocb_cmnd: iocb command code.

 *

 * This function is called by ring event handler function to get the iocb type.

 * This function translates the iocb command to an iocb command type used to

 * decide the final disposition of each completed IOCB.

 * The function returns

 * LPFC_UNKNOWN_IOCB if it is an unsupported iocb

 * LPFC_SOL_IOCB     if it is a solicited iocb completion

 * LPFC_ABORT_IOCB   if it is an abort iocb

 * LPFC_UNSOL_IOCB   if it is an unsolicited iocb

 *

 * The caller is not required to hold any lock.

/**

 * lpfc_sli_ring_map - Issue config_ring mbox for all rings

 * @phba: Pointer to HBA context object.

 *

 * This function is called from SLI initialization code

 * to configure every ring of the HBA's SLI interface. The

 * caller is not required to hold any lock. This function issues

 * a config_ring mailbox command for each ring.

 * This function returns zero if successful else returns a negative

 * error code.

/**

 * lpfc_sli_ringtxcmpl_put - Adds new iocb to the txcmplq

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @piocb: Pointer to the driver iocb object.

 *

 * The driver calls this function with the hbalock held for SLI3 ports or

 * the ring lock held for SLI4 ports. The function adds the

 * new iocb to txcmplq of the given ring. This function always returns

 * 0. If this function is called for ELS ring, this function checks if

 * there is a vport associated with the ELS command. This function also

 * starts els_tmofunc timer if this is an ELS command.

/**

 * lpfc_sli_ringtx_get - Get first element of the txq

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 *

 * This function is called with hbalock held to get next

 * iocb in txq of the given ring. If there is any iocb in

 * the txq, the function returns first iocb in the list after

 * removing the iocb from the list, else it returns NULL.

/**

 * lpfc_cmf_sync_cmpl - Process a CMF_SYNC_WQE cmpl

 * @phba: Pointer to HBA context object.

 * @cmdiocb: Pointer to driver command iocb object.

 * @cmf_cmpl: Pointer to completed WCQE.

 *

 * This routine will inform the driver of any BW adjustments we need

 * to make. These changes will be picked up during the next CMF

 * timer interrupt. In addition, any BW changes will be logged

 * with LOG_CGN_MGMT.

 First check for error */

 Gather congestion information on a successful cmpl */

 See if firmware info count is valid or has changed */

 Get BW requirement from firmware */

 Gather information needed for logging if a BW change is required */

 Are we increasing or decreasing BW */

 What is the change percentage */

For rounding*/

 Save BW change to be picked up during next timer interrupt */

/**

 * lpfc_issue_cmf_sync_wqe - Issue a CMF_SYNC_WQE

 * @phba: Pointer to HBA context object.

 * @ms:   ms to set in WQE interval, 0 means use init op

 * @total: Total rcv bytes for this interval

 *

 * This routine is called every CMF timer interrupt. Its purpose is

 * to issue a CMF_SYNC_WQE to the firmware to inform it of any events

 * that may indicate we have congestion (FPINs or Signals). Upon

 * completion, the firmware will indicate any BW restrictions the

 * driver may need to take.

 First address any alarm / warning activity */

 ONLY Managed mode will send the CMF_SYNC_WQE to the HBA */

 WQEs are reused.  Clear stale data and set key fields to zero */

 If this is the very first CMF_SYNC_WQE, issue an init operation */

 1=init */

 0=recalc */

 Check for alarms / warnings */

 We hit an Signal alarm condition */

 We hit a FPIN alarm condition */

 We hit an Signal warning condition */

 We hit a FPIN warning condition */

 Update total read blocks during previous timer interval */

 Setup reqtag to match the wqe completion. */

/**

 * lpfc_sli_next_iocb_slot - Get next iocb slot in the ring

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 *

 * This function is called with hbalock held and the caller must post the

 * iocb without releasing the lock. If the caller releases the lock,

 * iocb slot returned by the function is not guaranteed to be available.

 * The function returns pointer to the next available iocb slot if there

 * is available slot in the ring, else it returns NULL.

 * If the get index of the ring is ahead of the put index, the function

 * will post an error attention event to the worker thread to take the

 * HBA to offline state.

			/*

			 * All error attention handlers are posted to

			 * worker thread

/**

 * lpfc_sli_next_iotag - Get an iotag for the iocb

 * @phba: Pointer to HBA context object.

 * @iocbq: Pointer to driver iocb object.

 *

 * This function gets an iotag for the iocb. If there is no unused iotag and

 * the iocbq_lookup_len < 0xffff, this function allocates a bigger iotag_lookup

 * array and assigns a new iotag.

 * The function returns the allocated iotag if successful, else returns zero.

 * Zero is not a valid iotag.

 * The caller is not required to hold any lock.

 highly unprobable case */

/**

 * lpfc_sli_submit_iocb - Submit an iocb to the firmware

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @iocb: Pointer to iocb slot in the ring.

 * @nextiocb: Pointer to driver iocb object which need to be

 *            posted to firmware.

 *

 * This function is called to post a new iocb to the firmware. This

 * function copies the new iocb to ring iocb slot and updates the

 * ring pointers. It adds the new iocb to txcmplq if there is

 * a completion call back for this iocb else the function will free the

 * iocb object.  The hbalock is asserted held in the code path calling

 * this routine.

	/*

	 * Set up an iotag

	/*

	 * Issue iocb command to adapter

	/*

	 * If there is no completion routine to call, we can release the

	 * IOCB buffer back right now. For IOCBs, like QUE_RING_BUF,

	 * that have no rsp ring completion, iocb_cmpl MUST be NULL.

	/*

	 * Let the HBA know what IOCB slot will be the next one the

	 * driver will put a command into.

/**

 * lpfc_sli_update_full_ring - Update the chip attention register

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 *

 * The caller is not required to hold any lock for calling this function.

 * This function updates the chip attention bits for the ring to inform firmware

 * that there are pending work to be done for this ring and requests an

 * interrupt when there is space available in the ring. This function is

 * called when the driver is unable to post more iocbs to the ring due

 * to unavailability of space in the ring.

	/*

	 * Set ring 'ringno' to SET R0CE_REQ in Chip Att register.

	 * The HBA will tell us when an IOCB entry is available.

 flush */

/**

 * lpfc_sli_update_ring - Update chip attention register

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 *

 * This function updates the chip attention register bit for the

 * given ring to inform HBA that there is more work to be done

 * in this ring. The caller is not required to hold any lock.

	/*

	 * Tell the HBA that there is work to do in this ring.

 flush */

/**

 * lpfc_sli_resume_iocb - Process iocbs in the txq

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 *

 * This function is called with hbalock held to post pending iocbs

 * in the txq to the firmware. This function is called when driver

 * detects space available in the ring.

	/*

	 * Check to see if:

	 *  (a) there is anything on the txq to send

	 *  (b) link is up

	 *  (c) link attention events can be processed (fcp ring only)

	 *  (d) IOCB processing is not blocked by the outstanding mbox command.

/**

 * lpfc_sli_next_hbq_slot - Get next hbq entry for the HBQ

 * @phba: Pointer to HBA context object.

 * @hbqno: HBQ number.

 *

 * This function is called with hbalock held to get the next

 * available slot for the given HBQ. If there is free slot

 * available for the HBQ it will return pointer to the next available

 * HBQ entry else it will return NULL.

/**

 * lpfc_sli_hbqbuf_free_all - Free all the hbq buffers

 * @phba: Pointer to HBA context object.

 *

 * This function is called with no lock held to free all the

 * hbq buffers while uninitializing the SLI interface. It also

 * frees the HBQ buffers returned by the firmware but not yet

 * processed by the upper layers.

 Return all memory used by all HBQs */

 Mark the HBQs not in use */

/**

 * lpfc_sli_hbq_to_firmware - Post the hbq buffer to firmware

 * @phba: Pointer to HBA context object.

 * @hbqno: HBQ number.

 * @hbq_buf: Pointer to HBQ buffer.

 *

 * This function is called with the hbalock held to post a

 * hbq buffer to the firmware. If the function finds an empty

 * slot in the HBQ, it will post the buffer. The function will return

 * pointer to the hbq entry if it successfully post the buffer

 * else it will return NULL.

/**

 * lpfc_sli_hbq_to_firmware_s3 - Post the hbq buffer to SLI3 firmware

 * @phba: Pointer to HBA context object.

 * @hbqno: HBQ number.

 * @hbq_buf: Pointer to HBQ buffer.

 *

 * This function is called with the hbalock held to post a hbq buffer to the

 * firmware. If the function finds an empty slot in the HBQ, it will post the

 * buffer and place it on the hbq_buffer_list. The function will return zero if

 * it successfully post the buffer else it will return an error.

 Get next HBQ entry slot to use */

 Sync SLIM */

 flush */

/**

 * lpfc_sli_hbq_to_firmware_s4 - Post the hbq buffer to SLI4 firmware

 * @phba: Pointer to HBA context object.

 * @hbqno: HBQ number.

 * @hbq_buf: Pointer to HBQ buffer.

 *

 * This function is called with the hbalock held to post an RQE to the SLI4

 * firmware. If able to post the RQE to the RQ it will queue the hbq entry to

 * the hbq_buffer_list and return zero, otherwise it will return an error.

 HBQ for ELS and CT traffic. */

 Array of HBQs */

/**

 * lpfc_sli_hbqbuf_fill_hbqs - Post more hbq buffers to HBQ

 * @phba: Pointer to HBA context object.

 * @hbqno: HBQ number.

 * @count: Number of HBQ buffers to be posted.

 *

 * This function is called with no lock held to post more hbq buffers to the

 * given HBQ. The function returns the number of HBQ buffers successfully

 * posted.

 Allocate HBQ entries */

 Check whether HBQ is still in use */

/**

 * lpfc_sli_hbqbuf_add_hbqs - Post more HBQ buffers to firmware

 * @phba: Pointer to HBA context object.

 * @qno: HBQ number.

 *

 * This function posts more buffers to the HBQ. This function

 * is called with no lock held. The function returns the number of HBQ entries

 * successfully allocated.

/**

 * lpfc_sli_hbqbuf_init_hbqs - Post initial buffers to the HBQ

 * @phba: Pointer to HBA context object.

 * @qno:  HBQ queue number.

 *

 * This function is called from SLI initialization code path with

 * no lock held to post initial HBQ buffers to firmware. The

 * function returns the number of HBQ entries successfully allocated.

/*

 * lpfc_sli_hbqbuf_get - Remove the first hbq off of an hbq list

 *

 * This function removes the first hbq buffer on an hbq list and returns a

 * pointer to that buffer. If it finds no buffers on the list it returns NULL.

/**

 * lpfc_sli_rqbuf_get - Remove the first dma buffer off of an RQ list

 * @phba: Pointer to HBA context object.

 * @hrq: HBQ number.

 *

 * This function removes the first RQ buffer on an RQ buffer list and returns a

 * pointer to that buffer. If it finds no buffers on the list it returns NULL.

/**

 * lpfc_sli_hbqbuf_find - Find the hbq buffer associated with a tag

 * @phba: Pointer to HBA context object.

 * @tag: Tag of the hbq buffer.

 *

 * This function searches for the hbq buffer associated with the given tag in

 * the hbq buffer list. If it finds the hbq buffer, it returns the hbq_buffer

 * otherwise it returns NULL.

/**

 * lpfc_sli_free_hbq - Give back the hbq buffer to firmware

 * @phba: Pointer to HBA context object.

 * @hbq_buffer: Pointer to HBQ buffer.

 *

 * This function is called with hbalock. This function gives back

 * the hbq buffer to firmware. If the HBQ does not have space to

 * post the buffer, it will free the buffer.

/**

 * lpfc_sli_chk_mbx_command - Check if the mailbox is a legitimate mailbox

 * @mbxCommand: mailbox command code.

 *

 * This function is called by the mailbox event handler function to verify

 * that the completed mailbox command is a legitimate mailbox command. If the

 * completed mailbox is not known to the function, it will return MBX_SHUTDOWN

 * and the mailbox event handler will take the HBA offline.

/**

 * lpfc_sli_wake_mbox_wait - lpfc_sli_issue_mbox_wait mbox completion handler

 * @phba: Pointer to HBA context object.

 * @pmboxq: Pointer to mailbox command.

 *

 * This is completion handler function for mailbox commands issued from

 * lpfc_sli_issue_mbox_wait function. This function is called by the

 * mailbox event handler function with no lock held. This function

 * will wake up thread waiting on the wait queue pointed by context1

 * of the mailbox.

	/*

	 * If pmbox_done is empty, the driver thread gave up waiting and

	 * continued running.

/**

 * lpfc_sli_def_mbox_cmpl - Default mailbox completion handler

 * @phba: Pointer to HBA context object.

 * @pmb: Pointer to mailbox object.

 *

 * This function is the default mailbox completion handler. It

 * frees the memory resources associated with the completed mailbox

 * command. If the completed command is a REG_LOGIN mailbox command,

 * this function will issue a UREG_LOGIN to re-claim the RPI.

	/*

	 * If a REG_LOGIN succeeded  after node is destroyed or node

	 * is in re-discovery driver need to cleanup the RPI.

 Check to see if there are any deferred events to process */

			/* The unreg_login mailbox is complete and had a

			 * reference that has to be released.  The PLOGI

			 * got its own ref.

 This nlp_put pairs with lpfc_sli4_resume_rpi */

 Check security permission status on INIT_LINK mailbox command */

 /**

 * lpfc_sli4_unreg_rpi_cmpl_clr - mailbox completion handler

 * @phba: Pointer to HBA context object.

 * @pmb: Pointer to mailbox object.

 *

 * This function is the unreg rpi mailbox completion handler. It

 * frees the memory resources associated with the completed mailbox

 * command. An additional reference is put on the ndlp to prevent

 * lpfc_nlp_release from freeing the rpi bit in the bitmask before

 * the unreg mailbox command completes, this routine puts the

 * reference back.

 *

				/* Check to see if there are any deferred

				 * events to process

/**

 * lpfc_sli_handle_mb_event - Handle mailbox completions from firmware

 * @phba: Pointer to HBA context object.

 *

 * This function is called with no lock held. This function processes all

 * the completed mailbox commands and gives it to upper layers. The interrupt

 * service routine processes mailbox completion interrupt and adds completed

 * mailbox commands to the mboxq_cmpl queue and signals the worker thread.

 * Worker thread call lpfc_sli_handle_mb_event, which will return the

 * completed mailbox commands in mboxq_cmpl queue to the upper layers. This

 * function returns the mailbox commands to the upper layer by calling the

 * completion handler function of each mailbox.

 Get all completed mailboxe buffers into the cmplq */

 Get a Mailbox buffer to setup mailbox commands for callback */

		/*

		 * It is a fatal error if unknown mbox command completion.

 Unknown mailbox command compl */

 Mbox cmd cmpl error - RETRYing */

 Mailbox cmd <cmd> Cmpl <cmpl> */

/**

 * lpfc_sli_get_buff - Get the buffer associated with the buffer tag

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @tag: buffer tag.

 *

 * This function is called with no lock held. When QUE_BUFTAG_BIT bit

 * is set in the tag the buffer is posted for a particular exchange,

 * the function will return the buffer without replacing the buffer.

 * If the buffer is for unsolicited ELS or CT traffic, this function

 * returns the buffer and also posts another buffer to the firmware.

/**

 * lpfc_nvme_unsol_ls_handler - Process an unsolicited event data buffer

 *                              containing a NVME LS request.

 * @phba: pointer to lpfc hba data structure.

 * @piocb: pointer to the iocbq struct representing the sequence starting

 *        frame.

 *

 * This routine initially validates the NVME LS, validates there is a login

 * with the port that sent the LS, and then calls the appropriate nvme host

 * or target LS request handler.

 validate the source of the LS is logged in */

			/* This reference is a single occurrence to hold the

			 * node valid until the nvmet transport calls

			 * host_release.

 if zero, LS was successfully handled. If non-zero, LS not handled */

 recycle receive buffer */

 If start of new exchange, abort it */

/**

 * lpfc_complete_unsol_iocb - Complete an unsolicited sequence

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @saveq: Pointer to the iocbq struct representing the sequence starting frame.

 * @fch_r_ctl: the r_ctl for the first frame of the sequence.

 * @fch_type: the type for the first frame of the sequence.

 *

 * This function is called with no lock held. This function uses the r_ctl and

 * type of the received sequence to find the correct callback function to call

 * to process the sequence.

 unSolicited Responses */

	/* We must search, based on rctl / type

/**

 * lpfc_sli_process_unsol_iocb - Unsolicited iocb handler

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @saveq: Pointer to the unsolicited iocb.

 *

 * This function is called with no lock held by the ring event handler

 * when there is an unsolicited iocb posted to the response ring by the

 * firmware. This function gets the buffer associated with the iocbs

 * and calls the event handler for the ring. This function handles both

 * qring buffers and hbq buffers.

 * When the function returns 1 the caller can free the iocb object otherwise

 * upper layer functions will free the iocb objects.

 search continue save q for same XRI */

 Firmware Workaround */

/**

 * lpfc_sli_iocbq_lookup - Find command iocb for the given response iocb

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @prspiocb: Pointer to response iocb object.

 *

 * This function looks up the iocb_lookup table to get the command iocb

 * corresponding to the given response iocb using the iotag of the

 * response iocb. The driver calls this function with the hbalock held

 * for SLI3 ports or the ring lock held for SLI4 ports.

 * This function returns the command iocb object if it finds the command

 * iocb else returns NULL.

 remove from txcmpl queue list */

/**

 * lpfc_sli_iocbq_lookup_by_tag - Find command iocb for the iotag

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @iotag: IOCB tag.

 *

 * This function looks up the iocb_lookup table to get the command iocb

 * corresponding to the given iotag. The driver calls this function with

 * the ring lock held because this function is an SLI4 port only helper.

 * This function returns the command iocb object if it finds the command

 * iocb else returns NULL.

 remove from txcmpl queue list */

/**

 * lpfc_sli_process_sol_iocb - process solicited iocb completion

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @saveq: Pointer to the response iocb to be processed.

 *

 * This function is called by the ring event handler for non-fcp

 * rings when there is a new response iocb in the response ring.

 * The caller is not required to hold any locks. This function

 * gets the command iocb associated with the response iocb and

 * calls the completion handler for the command iocb. If there

 * is no completion handler, the function will free the resources

 * associated with command iocb. If the response iocb is for

 * an already aborted command iocb, the status of the completion

 * is changed to IOSTAT_LOCAL_REJECT/IOERR_SLI_ABORTED.

 * This function always returns 1.

			/*

			 * If an ELS command failed send an event to mgmt

			 * application.

			/*

			 * Post all ELS completions to the worker thread.

			 * All other are passed to the completion callback.

					/* Firmware could still be in progress

					 * of DMAing payload, so don't free data

					 * buffer till after a hbeat.

						/* Set cmdiocb flag for the

						 * exchange busy so sgl (xri)

						 * will not be released until

						 * the abort xri is received

						 * from hba.

						/*

						 * Clear LPFC_DRIVER_ABORTED

						 * bit in case it was driver

						 * initiated abort.

						/*

						 * For SLI4, irsiocb contains

						 * NO_XRI in sli_xritag, it

						 * shall not affect releasing

						 * sgl (xri) process.

		/*

		 * Unknown initiating command based on the response iotag.

		 * This could be the case on the ELS ring because of

		 * lpfc_els_abort().

			/*

			 * Ring <ringno> handler: unexpected completion IoTag

			 * <IoTag>

/**

 * lpfc_sli_rsp_pointers_error - Response ring pointer error handler

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 *

 * This function is called from the iocb ring event handlers when

 * put pointer is ahead of the get pointer for a ring. This function signal

 * an error attention condition to the worker thread and the worker

 * thread will transition the HBA to offline state.

	/*

	 * Ring <ringno> handler: portRspPut <portRspPut> is bigger than

	 * rsp ring <portRspMax>

	/*

	 * All error attention handlers are posted to

	 * worker thread

/**

 * lpfc_poll_eratt - Error attention polling timer timeout handler

 * @t: Context to fetch pointer to address of HBA context object from.

 *

 * This function is invoked by the Error Attention polling timer when the

 * timer times out. It will check the SLI Error Attention register for

 * possible attention events. If so, it will post an Error Attention event

 * and wake up worker thread to process it. Otherwise, it will set up the

 * Error Attention polling timer for the next poll.

 Here we will also keep track of interrupts per sec of the hba */

 64-bit integer division not supported on 32-bit x86 - use do_div */

 Check chip HA register for error event */

 Tell the worker thread there is work to do */

 Restart the timer for next eratt poll */

/**

 * lpfc_sli_handle_fast_ring_event - Handle ring events on FCP ring

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @mask: Host attention register mask for this ring.

 *

 * This function is called from the interrupt context when there is a ring

 * event for the fcp ring. The caller does not hold any lock.

 * The function processes each response iocb in the response ring until it

 * finds an iocb with LE bit set and chains all the iocbs up to the iocb with

 * LE bit set. The function will call the completion handler of the command iocb

 * if the response iocb indicates a completion for a command iocb or it is

 * an abort completion. The function will call lpfc_sli_process_unsol_iocb

 * function if this is an unsolicited iocb.

 * This routine presumes LPFC_FCP_RING handling and doesn't bother

 * to check it explicitly.

	/*

	 * The next available response entry should never exceed the maximum

	 * entries.  If it does, treat it as an adapter hardware error.

		/*

		 * Fetch an entry off the ring and copy it into a local data

		 * structure.  The copy involves a byte-swap since the

		 * network byte order and pci byte orders are different.

			/*

			 * If resource errors reported from HBA, reduce

			 * queuedepths of the SCSI device.

 Rsp ring <ringno> error: IOCB */

			/*

			 * Idle exchange closed via ABTS from port.  No iocb

			 * resources need to be recovered.

 Unknown IOCB command */

		/*

		 * The response IOCB has been processed.  Update the ring

		 * pointer in SLIM.  If the port response put pointer has not

		 * been updated, sync the pgp->rspPutInx and fetch the new port

		 * response put pointer.

 Force update of the local copy of cmdGetInx */

/**

 * lpfc_sli_sp_handle_rspiocb - Handle slow-path response iocb

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @rspiocbp: Pointer to driver response IOCB object.

 *

 * This function is called from the worker thread when there is a slow-path

 * response IOCB to process. This function chains all the response iocbs until

 * seeing the iocb with the LE bit set. The function will call

 * lpfc_sli_process_sol_iocb function if the response iocb indicates a

 * completion of a command iocb. The function will call the

 * lpfc_sli_process_unsol_iocb function if this is an unsolicited iocb.

 * The function frees the resources or calls the completion handler if this

 * iocb is an abort completion. The function returns NULL when the response

 * iocb has the LE bit set and all the chained iocbs are processed, otherwise

 * this function shall chain the iocb on to the iocb_continueq and return the

 * response iocb passed in.

 First add the response iocb to the countinueq list */

 Now, determine whether the list is completed for processing */

		/*

		 * By default, the driver expects to free all resources

		 * associated with this iocb completion.

		/*

		 * If resource errors reported from HBA, reduce

		 * queuedepths of the SCSI device.

 Rsp ring <ringno> error: IOCB */

		/*

		 * Fetch the IOCB command type and call the correct completion

		 * routine. Solicited and Unsolicited IOCBs on the ELS ring

		 * get freed back to the lpfc_iocb_list by the discovery

		 * kernel thread.

 Call the specified completion routine */

 Unknown IOCB command */

/**

 * lpfc_sli_handle_slow_ring_event - Wrapper func for handling slow-path iocbs

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @mask: Host attention register mask for this ring.

 *

 * This routine wraps the actual slow_ring event process routine from the

 * API jump table function pointer from the lpfc_hba struct.

/**

 * lpfc_sli_handle_slow_ring_event_s3 - Handle SLI3 ring event for non-FCP rings

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @mask: Host attention register mask for this ring.

 *

 * This function is called from the worker thread when there is a ring event

 * for non-fcp rings. The caller does not hold any lock. The function will

 * remove each response iocb in the response ring and calls the handle

 * response iocb routine (lpfc_sli_sp_handle_rspiocb) to process it.

	/*

	 * The next available response entry should never exceed the maximum

	 * entries.  If it does, treat it as an adapter hardware error.

		/*

		 * Ring <ringno> handler: portRspPut <portRspPut> is bigger than

		 * rsp ring <portRspMax>

		/*

		 * Build a completion list and call the appropriate handler.

		 * The process is to get the next available response iocb, get

		 * a free iocb from the list, copy the response data into the

		 * free iocb, insert to the continuation list, and update the

		 * next response index to slim.  This process makes response

		 * iocb's in the ring available to DMA as fast as possible but

		 * pays a penalty for a copy operation.  Since the iocb is

		 * only 32 bytes, this penalty is considered small relative to

		 * the PCI reads for register values and a slim write.  When

		 * the ulpLe field is set, the entire Command has been

		 * received.

 Handle the response IOCB */

		/*

		 * If the port response put pointer has not been updated, sync

		 * the pgp->rspPutInx in the MAILBOX_tand fetch the new port

		 * response put pointer.

 while (pring->sli.sli3.rspidx != portRspPut) */

 At least one response entry has been freed */

 SET RxRE_RSP in Chip Att register */

 flush */

 Force update of the local copy of cmdGetInx */

/**

 * lpfc_sli_handle_slow_ring_event_s4 - Handle SLI4 slow-path els events

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @mask: Host attention register mask for this ring.

 *

 * This function is called from the worker thread when there is a pending

 * ELS response iocb on the driver internal slow-path response iocb worker

 * queue. The caller does not hold any lock. The function will remove each

 * response iocb from the response worker queue and calls the handle

 * response iocb routine (lpfc_sli_sp_handle_rspiocb) to process it.

 Get the response iocb from the head of work queue */

 Translate ELS WCQE to response IOCBQ */

 Limit the number of events to 64 to avoid soft lockups */

/**

 * lpfc_sli_abort_iocb_ring - Abort all iocbs in the ring

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 *

 * This function aborts all iocbs in the given ring and frees all the iocb

 * objects in txq. This function issues an abort iocb for all the iocb commands

 * in txcmplq. The iocbs in the txcmplq is not guaranteed to complete before

 * the return of this function. The caller is not required to hold any locks.

	/* Error everything on txq and txcmplq

	 * First do the txq.

 Next issue ABTS for everything on the txcmplq */

 Next issue ABTS for everything on the txcmplq */

 Make sure HBA is alive */

 Cancel all the IOCBs from the completions list */

/**

 * lpfc_sli_abort_fcp_rings - Abort all iocbs in all FCP rings

 * @phba: Pointer to HBA context object.

 *

 * This function aborts all iocbs in FCP rings and frees all the iocb

 * objects in txq. This function issues an abort iocb for all the iocb commands

 * in txcmplq. The iocbs in the txcmplq is not guaranteed to complete before

 * the return of this function. The caller is not required to hold any locks.

 Look on all the FCP Rings for the iotag */

/**

 * lpfc_sli_flush_io_rings - flush all iocbs in the IO ring

 * @phba: Pointer to HBA context object.

 *

 * This function flushes all iocbs in the IO ring and frees all the iocb

 * objects in txq and txcmplq. This function will not issue abort iocbs

 * for all the iocb commands in txcmplq, they will just be returned with

 * IOERR_SLI_DOWN. This function is invoked with EEH when device's PCI

 * slot has been permanently disabled.

 Indicate the I/O queues are flushed */

 Look on all the FCP Rings for the iotag */

 Retrieve everything on txq */

 Retrieve everything on the txcmplq */

 Flush the txq */

 Flush the txcmplq */

 Retrieve everything on txq */

 Retrieve everything on the txcmplq */

 Flush the txq */

 Flush the txcmpq */

/**

 * lpfc_sli_brdready_s3 - Check for sli3 host ready status

 * @phba: Pointer to HBA context object.

 * @mask: Bit mask to be checked.

 *

 * This function reads the host status register and compares

 * with the provided bit mask to check if HBA completed

 * the restart. This function will wait in a loop for the

 * HBA to complete restart. If the HBA does not restart within

 * 15 iterations, the function will reset the HBA again. The

 * function returns 1 when HBA fail to restart otherwise returns

 * zero.

 Read the HBA Host Status Register */

	/*

	 * Check status register every 100ms for 5 retries, then every

	 * 500ms for 5, then every 2.5 sec for 5, then reset board and

	 * every 2.5 sec for 4.

	 * Break our of the loop if errors occurred during init.

 Do post */

 Read the HBA Host Status Register */

 Check to see if any errors occurred during init */

/**

 * lpfc_sli_brdready_s4 - Check for sli4 host ready status

 * @phba: Pointer to HBA context object.

 * @mask: Bit mask to be checked.

 *

 * This function checks the host status register to check if HBA is

 * ready. This function will wait in a loop for the HBA to be ready

 * If the HBA is not ready , the function will will reset the HBA PCI

 * function again. The function returns 1 when HBA fail to be ready

 * otherwise returns zero.

 Read the HBA Host Status Register */

 Check to see if any errors occurred during init */

/**

 * lpfc_sli_brdready - Wrapper func for checking the hba readyness

 * @phba: Pointer to HBA context object.

 * @mask: Bit mask to be checked.

 *

 * This routine wraps the actual SLI3 or SLI4 hba readyness check routine

 * from the API jump table function pointer from the lpfc_hba struct.

/**

 * lpfc_reset_barrier - Make HBA ready for HBA reset

 * @phba: Pointer to HBA context object.

 *

 * This function is called before resetting an HBA. This function is called

 * with hbalock held and requests HBA to quiesce DMAs before a reset.

	/*

	 * Tell the other part of the chip to suspend temporarily all

	 * its DMA activity.

 Disable the error attention */

 flush */

 Clear Chip error bit */

 flush */

/**

 * lpfc_sli_brdkill - Issue a kill_board mailbox command

 * @phba: Pointer to HBA context object.

 *

 * This function issues a kill_board mailbox command and waits for

 * the error attention interrupt. This function is called for stopping

 * the firmware processing. The caller is not required to hold any

 * locks. This function calls lpfc_hba_down_post function to free

 * any pending commands after the kill. The function will return 1 when it

 * fails to kill the board else will return 0.

 Kill HBA */

 Disable the error attention */

 flush */

	/* There is no completion for a KILL_BOARD mbox cmd. Check for an error

	 * attention every 100ms for 3 seconds. If we don't get ERATT after

	 * 3 seconds we still set HBA_ERROR state because the status of the

	 * board is now undefined.

/**

 * lpfc_sli_brdreset - Reset a sli-2 or sli-3 HBA

 * @phba: Pointer to HBA context object.

 *

 * This function resets the HBA by writing HC_INITFF to the control

 * register. After the HBA resets, this function resets all the iocb ring

 * indices. This function disables PCI layer parity checking during

 * the reset.

 * This function returns 0 always.

 * The caller is not required to hold any locks.

 Reset HBA */

 perform board reset */

 Turn off parity checking and serr during the physical reset */

 Now toggle INITFF bit in the Host Control Register */

 flush */

 flush */

 Restore PCI cmd register */

 Initialize relevant SLI info */

/**

 * lpfc_sli4_brdreset - Reset a sli-4 HBA

 * @phba: Pointer to HBA context object.

 *

 * This function resets a SLI4 HBA. This function disables PCI layer parity

 * checking during resets the device. The caller is not required to hold

 * any locks.

 *

 * This function returns 0 on success else returns negative error code.

 Reset HBA */

 perform board reset */

 SLI4 INTF 2: if FW dump is being taken skip INIT_PORT */

 Now physically reset the device */

 Turn off parity checking and serr during the physical reset */

 Perform FCoE PCI function reset before freeing queue memory */

 Restore PCI cmd register */

/**

 * lpfc_sli_brdrestart_s3 - Restart a sli-3 hba

 * @phba: Pointer to HBA context object.

 *

 * This function is called in the SLI initialization code path to

 * restart the HBA. The caller is not required to hold any lock.

 * This function writes MBX_RESTART mailbox command to the SLIM and

 * resets the HBA. At the end of the function, it calls lpfc_hba_down_post

 * function to free any pending commands. The function enables

 * POST only during the first initialization. The function returns zero.

 * The function does not guarantee completion of MBX_RESTART mailbox

 * command before the return of this function.

 Take PCIe device Advanced Error Reporting (AER) state */

 Restart HBA */

 flush */

 Only skip post after fc_ffinit is completed */

 This is really setting up word1 */

 This is really setting up word1 */

 flush */

 Give the INITFF and Post time to settle. */

 Reset HBA AER if it was enabled, note hba_flag was reset above */

/**

 * lpfc_sli_brdrestart_s4 - Restart the sli-4 hba

 * @phba: Pointer to HBA context object.

 *

 * This function is called in the SLI initialization code path to restart

 * a SLI4 HBA. The caller is not required to hold any lock.

 * At the end of the function, it calls lpfc_hba_down_post function to

 * free any pending commands.

 Restart HBA */

 Take PCIe device Advanced Error Reporting (AER) state */

 Reset HBA AER if it was enabled, note hba_flag was reset above */

/**

 * lpfc_sli_brdrestart - Wrapper func for restarting hba

 * @phba: Pointer to HBA context object.

 *

 * This routine wraps the actual SLI3 or SLI4 hba restart routine from the

 * API jump table function pointer from the lpfc_hba struct.

/**

 * lpfc_sli_chipset_init - Wait for the restart of the HBA after a restart

 * @phba: Pointer to HBA context object.

 *

 * This function is called after a HBA restart to wait for successful

 * restart of the HBA. Successful restart of the HBA is indicated by

 * HS_FFRDY and HS_MBRDY bits. If the HBA fails to restart even after 15

 * iteration, the function will restart the HBA again. The function returns

 * zero if HBA successfully restarted else returns negative error code.

 Read the HBA Host Status Register */

 Check status register to see what current state is */

		/* Check every 10ms for 10 retries, then every 100ms for 90

		 * retries, then every 1 sec for 50 retires for a total of

		 * ~60 seconds before reset the board again and check every

		 * 1 sec for 50 retries. The up to 60 seconds before the

		 * board ready is required by the Falcon FIPS zeroization

		 * complete, and any reset the board in between shall cause

		 * restart of zeroization, further delay the board ready.

			/* Adapter failed to init, timeout, status reg

 Check to see if any errors occurred during init */

 ERROR: During chipset initialization */

			/* Adapter failed to init, chipset, status reg

 Do post */

 Read the HBA Host Status Register */

 Check to see if any errors occurred during init */

 ERROR: During chipset initialization */

 Adapter failed to init, chipset, status reg <status> */

 Clear all interrupt enable conditions */

 flush */

 setup host attn register */

 flush */

/**

 * lpfc_sli_hbq_count - Get the number of HBQs to be configured

 *

 * This function calculates and returns the number of HBQs required to be

 * configured.

/**

 * lpfc_sli_hbq_entry_count - Calculate total number of hbq entries

 *

 * This function adds the number of hbq entries in every HBQ to get

 * the total number of hbq entries required for the HBA and returns

 * the total count.

/**

 * lpfc_sli_hbq_size - Calculate memory required for all hbq entries

 *

 * This function calculates amount of memory required for all hbq entries

 * to be configured and returns the total memory required.

/**

 * lpfc_sli_hbq_setup - configure and initialize HBQs

 * @phba: Pointer to HBA context object.

 *

 * This function is called during the SLI initialization to configure

 * all the HBQs and post buffers to the HBQ. The caller is not

 * required to hold any locks. This function will return zero if successful

 * else it will return negative error code.

				/* Get a Mailbox buffer to setup mailbox

				 * commands for HBA initialization

 Initialize the struct lpfc_sli_hbq structure for each hbq */

			/* Adapter failed to init, mbxCmd <cmd> CFG_RING,

 Initially populate or replenish the HBQs */

/**

 * lpfc_sli4_rb_setup - Initialize and post RBs to HBA

 * @phba: Pointer to HBA context object.

 *

 * This function is called during the SLI initialization to configure

 * all the HBQs and post buffers to the HBQ. The caller is not

 * required to hold any locks. This function will return zero if successful

 * else it will return negative error code.

	/**

	 * Specific case when the MDS diagnostics is enabled and supported.

	 * The receive buffer count is truncated to manage the incoming

	 * traffic.

 Initially populate or replenish the HBQs */

/**

 * lpfc_sli_config_port - Issue config port mailbox command

 * @phba: Pointer to HBA context object.

 * @sli_mode: sli mode - 2/3

 *

 * This function is called by the sli initialization code path

 * to issue config_port mailbox command. This function restarts the

 * HBA firmware and issues a config_port mailbox command to configure

 * the SLI interface in the sli mode specified by sli_mode

 * variable. The caller is not required to hold any locks.

 * The function returns 0 if successful, else returns negative error

 * code.

		/* Call pre CONFIG_PORT mailbox command initialization.  A

		 * value of 0 means the call was successful.  Any other

		 * nonzero value is a failure, but if ERESTART is returned,

		 * the driver may reset the HBA and try again.

 Allow asynchronous mailbox command to go through */

/**

 * lpfc_sli_hba_setup - SLI initialization function

 * @phba: Pointer to HBA context object.

 *

 * This function is the main SLI initialization function. This function

 * is called by the HBA initialization code, HBA reset code and HBA

 * error attention handler code. Caller is not required to hold any

 * locks. This function issues config_port mailbox command to configure

 * the SLI, setup iocb rings and HBQ rings. In the end the function

 * calls the config_port_post function to issue init_link mailbox

 * command and to start the discovery. The function will return zero

 * if successful, else it will return negative error code.

 Enable ISR already does config_port because of config_msi mbx */

 SLI4 FC support only */

 Enable PCIe device Advanced Error Reporting (AER) if configured */

 Initialize VPIs. */

		/*

		 * The VPI bitmask and physical ID array are allocated

		 * and initialized once only - at driver load.  A port

		 * reset doesn't need to reinitialize this memory.

 Init HBQs */

/**

 * lpfc_sli4_read_fcoe_params - Read fcoe params from conf region

 * @phba: Pointer to HBA context object.

 *

 * This function issue a dump mailbox command to read config region

 * 23 and parse the records in the region and populate driver

 * data structure.

 Program the default value of vlan_id and fc_map */

/**

 * lpfc_sli4_read_rev - Issue READ_REV and collect vpd data

 * @phba: pointer to lpfc hba data structure.

 * @mboxq: pointer to the LPFC_MBOXQ_t structure.

 * @vpd: pointer to the memory to hold resulting port vpd data.

 * @vpd_size: On input, the number of bytes allocated to @vpd.

 *	      On output, the number of data bytes in @vpd.

 *

 * This routine executes a READ_REV SLI4 mailbox command.  In

 * addition, this routine gets the port vpd data.

 *

 * Return codes

 * 	0 - successful

 * 	-ENOMEM - could not allocated memory.

	/*

	 * Get a DMA buffer for the vpd data resulting from the READ_REV

	 * mailbox command.

	/*

	 * The SLI4 implementation of READ_REV conflicts at word1,

	 * bits 31:16 and SLI4 adds vpd functionality not present

	 * in SLI3.  This code corrects the conflicts.

	/*

	 * The available vpd length cannot be bigger than the

	 * DMA buffer passed to the port.  Catch the less than

	 * case and update the caller's size.

/**

 * lpfc_sli4_get_ctl_attr - Retrieve SLI4 device controller attributes

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine retrieves SLI4 device physical port name this PCI function

 * is attached to.

 *

 * Return codes

 *      0 - successful

 *      otherwise - failed to retrieve controller attributes

 Send COMMON_GET_CNTL_ATTRIBUTES mbox cmd */

/**

 * lpfc_sli4_retrieve_pport_name - Retrieve SLI4 device physical port name

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine retrieves SLI4 device physical port name this PCI function

 * is attached to.

 *

 * Return codes

 *      0 - successful

 *      otherwise - failed to retrieve physical port name

 We assume nothing at this point */

 obtain link type and link number via READ_CONFIG */

 obtain link type and link number via COMMON_GET_CNTL_ATTRIBUTES */

/**

 * lpfc_sli4_arm_cqeq_intr - Arm sli-4 device completion and event queues

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is called to explicitly arm the SLI4 device's completion and

 * event queues

 Loop thru all Hardware Queues */

 ARM the corresponding CQ */

 Loop thru all IRQ vectors */

 ARM the corresponding EQ */

/**

 * lpfc_sli4_get_avail_extnt_rsrc - Get available resource extent count.

 * @phba: Pointer to HBA context object.

 * @type: The resource extent type.

 * @extnt_count: buffer to hold port available extent count.

 * @extnt_size: buffer to hold element count per extent.

 *

 * This function calls the port and retrievs the number of available

 * extents and their size for a particular extent type.

 *

 * Returns: 0 if successful.  Nonzero otherwise.

 Find out how many extents are available for this resource type */

 Send an extents count of 0 - the GET doesn't use it. */

/**

 * lpfc_sli4_chk_avail_extnt_rsrc - Check for available SLI4 resource extents.

 * @phba: Pointer to HBA context object.

 * @type: The extent type to check.

 *

 * This function reads the current available extents from the port and checks

 * if the extent count or extent size has changed since the last access.

 * Callers use this routine post port reset to understand if there is a

 * extent reprovisioning requirement.

 *

 * Returns:

 *   -Error: error indicates problem.

 *   1: Extent count or size has changed.

 *   0: No changes.

/**

 * lpfc_sli4_cfg_post_extnts -

 * @phba: Pointer to HBA context object.

 * @extnt_cnt: number of available extents.

 * @type: the extent type (rpi, xri, vfi, vpi).

 * @emb: buffer to hold either MBX_EMBED or MBX_NEMBED operation.

 * @mbox: pointer to the caller's allocated mailbox structure.

 *

 * This function executes the extents allocation request.  It also

 * takes care of the amount of memory needed to allocate or get the

 * allocated extents. It is the caller's responsibility to evaluate

 * the response.

 *

 * Returns:

 *   -Error:  Error value describes the condition found.

 *   0: if successful

 Calculate the total requested length of the dma memory */

	/*

	 * Calculate the size of an embedded mailbox.  The uint32_t

	 * accounts for extents-specific word.

	/*

	 * Presume the allocation and response will fit into an embedded

	 * mailbox.  If not true, reconfigure to a non-embedded mailbox.

/**

 * lpfc_sli4_alloc_extent - Allocate an SLI4 resource extent.

 * @phba: Pointer to HBA context object.

 * @type:  The resource extent type to allocate.

 *

 * This function allocates the number of elements for the specified

 * resource type.

	/*

	 * Figure out where the response is located.  Then get local pointers

	 * to the response data.  The port does not guarantee to respond to

	 * all extents counts request so update the local variable with the

	 * allocated count from the port.

	/*

	 * Based on the resource size and count, correct the base and max

	 * resource values.

		/*

		 * The next_rpi was initialized with the maximum available

		 * count but the port may allocate a smaller number.  Catch

		 * that case and update the next_rpi.

 Initialize local ptrs for common extent processing later. */

 Initialize local ptrs for common extent processing later. */

 Initialize local ptrs for common extent processing later. */

 Initialize local ptrs for common extent processing later. */

 Unsupported Opcode.  Fail call. */

	/*

	 * Complete initializing the extent configuration with the

	 * allocated ids assigned to this function.  The bitmask serves

	 * as an index into the array and manages the available ids.  The

	 * array just stores the ids communicated to the port via the wqes.

 Entire word processed.  Get next word.*/

/**

 * lpfc_sli4_dealloc_extent - Deallocate an SLI4 resource extent.

 * @phba: Pointer to HBA context object.

 * @type: the extent's type.

 *

 * This function deallocates all extents of a particular resource type.

 * SLI4 does not allow for deallocating a particular extent range.  It

 * is the caller's responsibility to release all kernel memory resources.

	/*

	 * This function sends an embedded mailbox because it only sends the

	 * the resource type.  All extents of this type are released by the

	 * port.

 Send an extents count of 0 - the dealloc doesn't use it. */

 Release kernel memory resources for the specific type. */

 RPI bitmask and physical id array are cleaned up earlier. */

/**

 * lpfc_ras_stop_fwlog: Disable FW logging by the adapter

 * @phba: Pointer to HBA context object.

 *

 * Disable FW logging into host memory on the adapter. To

 * be done before reading logs from the host memory.

 Disable FW logging to host memory */

 Wait 10ms for firmware to stop using DMA buffer */

/**

 * lpfc_sli4_ras_dma_free - Free memory allocated for FW logging.

 * @phba: Pointer to HBA context object.

 *

 * This function is called to free memory allocated for RAS FW logging

 * support in the driver.

/**

 * lpfc_sli4_ras_dma_alloc: Allocate memory for FW support

 * @phba: Pointer to HBA context object.

 * @fwlog_buff_count: Count of buffers to be created.

 *

 * This routine DMA memory for Log Write Position Data[LPWD] and buffer

 * to update FW log is posted to the adapter.

 * Buffer count is calculated based on module param ras_fwlog_buffsize

 * Size of each buffer posted to FW is 64K.

 Initialize List */

 Allocate memory for the LWPD */

/**

 * lpfc_sli4_ras_mbox_cmpl: Completion handler for RAS MBX command

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * Completion handler for driver's RAS MBX command to the device.

 Free RAS DMA memory */

/**

 * lpfc_sli4_ras_fwlog_init: Initialize memory and post RAS MBX command

 * @phba: pointer to lpfc hba data structure.

 * @fwlog_level: Logging verbosity level.

 * @fwlog_enable: Enable/Disable logging.

 *

 * Initialize memory and post mailbox command to enable FW logging in host

 * memory.

	/*

	 * If re-enabling FW logging support use earlier allocated

	 * DMA buffers while posting MBX command.

 Setup Mailbox command */

 Update DMA buffer address */

 Update LPWD address */

/**

 * lpfc_sli4_ras_setup - Check if RAS supported on the adapter

 * @phba: Pointer to HBA context object.

 *

 * Check if RAS is supported on the adapter and initialize it.

 Check RAS FW Log needs to be enabled or not */

/**

 * lpfc_sli4_alloc_resource_identifiers - Allocate all SLI4 resource extents.

 * @phba: Pointer to HBA context object.

 *

 * This function allocates all SLI4 resource identifiers.

		/*

		 * The port supports resource extents. The XRI, VPI, VFI, RPI

		 * resource extent count must be read and allocated before

		 * provisioning the resource id arrays.

			/*

			 * Extent-based resources are set - the driver could

			 * be in a port reset. Figure out if any corrective

			 * actions need to be taken.

			/*

			 * It's possible that the number of resources

			 * provided to this port instance changed between

			 * resets.  Detect this condition and reallocate

			 * resources.  Otherwise, there is no action.

		/*

		 * The port does not support resource extents.  The XRI, VPI,

		 * VFI, RPI resource ids were determined from READ_CONFIG.

		 * Just allocate the bitmasks and provision the resource id

		 * arrays.  If a port reset is active, the resources don't

		 * need any action - just exit.

 RPIs. */

 VPIs. */

 XRIs. */

 VFIs. */

		/*

		 * Mark all resources ready.  An HBA reset doesn't need

		 * to reset the initialization.

/**

 * lpfc_sli4_dealloc_resource_identifiers - Deallocate all SLI4 resource extents.

 * @phba: Pointer to HBA context object.

 *

 * This function allocates the number of elements for the specified

 * resource type.

/**

 * lpfc_sli4_get_allocated_extnts - Get the port's allocated extents.

 * @phba: Pointer to HBA context object.

 * @type: The resource extent type.

 * @extnt_cnt: buffer to hold port extent count response

 * @extnt_size: buffer to hold port extent size response.

 *

 * This function calls the port to read the host allocated extents

 * for a particular type.

 Count the number of extents currently allocatd for this type. */

			/*

			 * The GET_ALLOCATED mailbox does not return the size,

			 * just the count.  The size should be just the size

			 * stored in the current allocated block and all sizes

			 * for an extent type are the same so set the return

			 * value now.

	/*

	 * Calculate the size of an embedded mailbox.  The uint32_t

	 * accounts for extents-specific word.

	/*

	 * Presume the allocation and response will fit into an embedded

	 * mailbox.  If not true, reconfigure to a non-embedded mailbox.

	/*

	 * Figure out where the response is located.  Then get local pointers

	 * to the response data.  The port does not guarantee to respond to

	 * all extents counts request so update the local variable with the

	 * allocated count from the port.

/**

 * lpfc_sli4_repost_sgl_list - Repost the buffers sgl pages as block

 * @phba: pointer to lpfc hba data structure.

 * @sgl_list: linked link of sgl buffers to post

 * @cnt: number of linked list buffers

 *

 * This routine walks the list of buffers that have been allocated and

 * repost them to the port by using SGL block post. This is needed after a

 * pci_function_reset/warm_start or start. It attempts to construct blocks

 * of buffer sgls which contains contiguous xris and uses the non-embedded

 * SGL block post mailbox commands to post them to the port. For single

 * buffer sgl with non-contiguous xri, if any, it shall use embedded SGL post

 * mailbox command for posting.

 *

 * Returns: 0 = success, non-zero failure.

 a hole in xri block, form a sgl posting block */

 prepare list for next posting block */

 prepare list for next posting block */

 enough sgls for non-embed sgl mbox command */

 keep track of last sgl's xritag */

 end of repost sgl list condition for buffers */

 successful, put sgl to posted list */

 Failure, put sgl to free list */

 continue until a nembed page worth of sgls */

 post the buffer list sgls as a block */

 success, put sgl list to posted sgl list */

 Failure, put sgl list to free sgl list */

 don't reset xirtag due to hole in xri block */

 reset sgl post count for next round of posting */

 free the sgls failed to post */

 push sgls posted to the available list */

 return the number of XRIs actually posted */

/**

 * lpfc_sli4_repost_io_sgl_list - Repost all the allocated nvme buffer sgls

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine walks the list of nvme buffers that have been allocated and

 * repost them to the port by using SGL block post. This is needed after a

 * pci_function_reset/warm_start or start. The lpfc_hba_down_post_s4 routine

 * is responsible for moving all nvme buffers on the lpfc_abts_nvme_sgl_list

 * to the lpfc_io_buf_list. If the repost fails, reject all nvme buffers.

 *

 * Returns: 0 = success, non-zero failure.

 get all NVME buffers need to repost to a local list */

 post the list of nvme buffer sgls to port if available */

 failed to post any nvme buffer, return error */

 IF RQ is already full, don't bother */

	/* Two outcomes. (1) Set featurs was successul and EDC negotiation

	 * is done. (2) Mailbox failed and send FPIN support only.

 If there is a mbox error, move on to RDF */

 Zero out Congestion Signal ACQE counter */

	/* Register for FPIN events from the fabric now that the

	 * EDC common_set_features has completed.

 If there is a mbox error, move on to RDF */

/**

 * lpfc_init_idle_stat_hb - Initialize idle_stat tracking

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine initializes the per-cq idle_stat to dynamically dictate

 * polling decisions.

 *

 * Return codes:

 *   None

 Skip if we've already handled this cq's primary CPU */

/**

 * lpfc_cmf_setup - Initialize idle_stat tracking

 * @phba: Pointer to HBA context object.

 *

 * This is called from HBA setup during driver load or when the HBA

 * comes online. this does all the initialization to support CMF and MI.

 Are we forcing MI off via module parameter? */

 Always try to enable MI feature if we can */

 mi_ver is already set from GET_SLI4_PARAMETERS */

 Ensure FDMI is enabled for MI if enable_mi is set */

 Always try to enable CMF feature if we can */

 Allocate Congestion Information Buffer */

 initialize congestion buffer info */

 Zero out Congestion Signal counters */

 Ensure CGN Mode is off */

 Ensure CGN Mode is off */

	/* Only register congestion buffer with firmware if BOTH

	 * CMF and E2E are enabled.

 Ensure CGN Mode is off */

 Initialize atomic counters */

 Allocate RX Monitor Buffer */

/**

 * lpfc_sli4_hba_setup - SLI4 device initialization PCI function

 * @phba: Pointer to HBA context object.

 *

 * This function is the main SLI4 device initialization PCI function. This

 * function is called by the HBA initialization code, HBA reset code and

 * HBA error attention handler code. Caller is not required to hold any

 * locks.

 Perform a PCI function reset to start from clean */

 Check the HBA Host Status Register for readyness */

		/* Allow a little time after setting SLI_ACTIVE for any polled

		 * MBX commands to complete via BSG.

	/*

	 * Allocate a single mailbox container for initializing the

	 * port.

 Issue READ_REV to collect vpd and FW information. */

 SLI4 FC support only */

	/*

	 * Continue initialization with default values even if driver failed

	 * to read FCoE param config regions, only read parameters if the

	 * board is FCoE

	/*

	 * Retrieve sli4 device physical port name, failure of doing it

	 * is considered as non-fatal.

	/*

	 * Evaluate the read rev and vpd data. Populate the driver

	 * state with the results. If this routine fails, the failure

	 * is not fatal as the driver will use generic values.

 Save information as VPD data */

	/*

	 * This is because first G7 ASIC doesn't support the standard

	 * 0x5a NVME cmd descriptor type/subtype

 Set 1Sec interval to detect UE */

 Enable MDS Diagnostics only if the SLI Port supports it */

	/*

	 * Discover the port's supported feature set and match it against the

	 * hosts requests.

 Disable VMID if app header is not supported */

	/*

	 * The port must support FCP initiator mode as this is the

	 * only mode running in the host.

 Performance Hints are ONLY for FCoE */

	/*

	 * If the port cannot support the host's requested features

	 * then turn off the global config parameters to disable the

	 * feature in the driver.  This is not a fatal error.

 These SLI3 features are assumed in SLI4 */

 Always try to enable dual dump feature if we can */

	/*

	 * Allocate all resources (xri,rpi,vpi,vfi) now.  Subsequent

	 * calls depends on these resources to complete port setup.

 Read the port's service parameters. */

	/*

	 * This memory was allocated by the lpfc_read_sparam routine. Release

	 * it to the mbuf pool.

 Update the fc_host data structures with new wwn. */

 Create all the SLI4 queues */

 Set up all the queues to the device */

 Initialize the driver internal SLI layer lists. */

 update host els xri-sgl sizes and mappings */

 register the els sgl pool to the port */

 update host nvmet xri-sgl sizes and mappings */

 register the nvmet sgl pool to the port */

		/* We allocate an iocbq for every receive context SGL.

		 * The additional allocation is for abort and ls handling.

 update host common xri-sgl sizes and mappings */

 register the allocated common sgl pool to the port */

 Some NVME buffers were moved to abort nvme list */

 A pci function reset will repost them */

		/* Each lpfc_io_buf job structure has an iocbq element.

		 * This cnt provides for abort, els, ct and ls requests.

 Initialize and populate the iocb list per host */

 Post initial buffers to all RQs created */

 Post the rpi header region to the device. */

			/*

			 * The FC Port needs to register FCFI (index 0)

 We are a NVME Target mode with MRQ > 1 */

 First register the FCFI */

 Next register the MRQs */

 Check if the port is configured to be disabled */

	/* Don't post more new bufs if repost already recovered

	 * the nvme sgls.

 Allow asynchronous mailbox command to go through */

 Post receive buffers to the device */

 Reset HBA FCF states after HBA reset */

 Start the ELS watchdog timer */

 Start heart beat timer */

 start eq_delay heartbeat */

 start per phba idle_stat_delay heartbeat */

 Start error attention (ERATT) polling timer */

 Enable PCIe device Advanced Error Reporting (AER) if configured */

	/*

	 * The port is ready, set the host's link state to LINK_DOWN

	 * in preparation for link interrupts.

 Check if physical ports are trunked */

 Arm the CQs and then EQs on device */

 Indicate device interrupt mode */

 Setup CMF after HBA is initialized */

 don't perform init_link on SLI4 FC port loopback test */

 Free allocated IO Buffers */

 Unset all the queues set up in this routine when error out */

/**

 * lpfc_mbox_timeout - Timeout call back function for mbox timer

 * @t: Context to fetch pointer to hba structure from.

 *

 * This is the callback function for mailbox timer. The mailbox

 * timer is armed when a new mailbox command is issued and the timer

 * is deleted when the mailbox complete. The function is called by

 * the kernel timer code when a mailbox does not complete within

 * expected time. This function wakes up the worker thread to

 * process the mailbox timeout and returns. All the processing is

 * done by the worker thread function lpfc_mbox_timeout_handler.

/**

 * lpfc_sli4_mbox_completions_pending - check to see if any mailbox completions

 *                                    are pending

 * @phba: Pointer to HBA context object.

 *

 * This function checks if any mailbox completions are present on the mailbox

 * completion queue.

 Check for completions on mailbox completion queue */

 if the index wrapped around, toggle the valid bit */

/**

 * lpfc_sli4_process_missed_mbox_completions - process mbox completions

 *					      that were missed.

 * @phba: Pointer to HBA context object.

 *

 * For sli4, it is possible to miss an interrupt. As such mbox completions

 * maybe missed causing erroneous mailbox timeouts to occur. This function

 * checks to see if mbox completions are on the mailbox completion queue

 * and will process all the completions associated with the eq for the

 * mailbox completion queue.

 Find the EQ associated with the mbox CQ */

 Turn off interrupts from this EQ */

 Check to see if a mbox completion is pending */

	/*

	 * If a mbox completion is pending, process all the events on EQ

	 * associated with the mbox completion queue (this could include

	 * mailbox commands, async events, els commands, receive queue data

	 * and fcp commands)

 process and rearm the EQ */

 Always clear and re-arm the EQ */

/**

 * lpfc_mbox_timeout_handler - Worker thread function to handle mailbox timeout

 * @phba: Pointer to HBA context object.

 *

 * This function is called from worker thread when a mailbox command times out.

 * The caller is not required to hold any locks. This function will reset the

 * HBA and recover all the pending commands.

 If the mailbox completed, process the completion */

	/* Check the pmbox pointer first.  There is a race condition

	 * between the mbox timeout handler getting executed in the

	 * worklist and the mailbox actually completing. When this

	 * race condition occurs, the mbox_active will be NULL.

 Mbox cmd <mbxCommand> timeout */

	/* Setting state unknown so lpfc_sli_abort_iocb_ring

	 * would get IOCB_ERROR from lpfc_sli_issue_iocb, allowing

	 * it to fail all outstanding SCSI IO.

 Reset the HBA device */

/**

 * lpfc_sli_issue_mbox_s3 - Issue an SLI3 mailbox command to firmware

 * @phba: Pointer to HBA context object.

 * @pmbox: Pointer to mailbox object.

 * @flag: Flag indicating how the mailbox need to be processed.

 *

 * This function is called by discovery code and HBA management code

 * to submit a mailbox command to firmware with SLI-3 interface spec. This

 * function gets the hbalock to protect the data structures.

 * The mailbox command can be submitted in polling mode, in which case

 * this function will wait in a polling loop for the completion of the

 * mailbox.

 * If the mailbox is submitted in no_wait mode (not polling) the

 * function will submit the command and returns immediately without waiting

 * for the mailbox completion. The no_wait is supported only when HBA

 * is in SLI2/SLI3 mode - interrupts are enabled.

 * The SLI interface allows only one mailbox pending at a time. If the

 * mailbox is issued in polling mode and there is already a mailbox

 * pending, then the function will return an error. If the mailbox is issued

 * in NO_WAIT mode and there is a mailbox pending already, the function

 * will return MBX_BUSY after queuing the mailbox into mailbox queue.

 * The sli layer owns the mailbox object until the completion of mailbox

 * command if this function return MBX_BUSY or MBX_SUCCESS. For all other

 * return codes the caller owns the mailbox command after the return of

 * the function.

 processing mbox queue from intr_handler */

 If the PCI channel is in offline state, do not post mbox. */

 If HBA has a deferred error attention, fail the iocb. */

 Mbox command <mbxCommand> cannot issue */

		/* Polling for a mbox command when another one is already active

		 * is not allowed in SLI. Also, the driver must have established

		 * SLI2 mode to queue and process multiple mbox commands.

 Mbox command <mbxCommand> cannot issue */

 Mbox command <mbxCommand> cannot issue */

		/* Another mailbox command is still being processed, queue this

		 * command to be processed later.

 Mbox cmd issue - BUSY */

 If we are not polling, we MUST be in SLI2 mode */

 Mbox command <mbxCommand> cannot issue */

 timeout active mbox command */

 Mailbox cmd <cmd> issue */

 next set own bit for the adapter and copy over command word */

 Populate mbox extension offset word. */

 Copy the mailbox extension data */

 Copy command data to host SLIM area */

 Populate mbox extension offset word. */

 Copy the mailbox extension data */

 copy command data into host mbox for cmpl */

		/* First copy mbox command data to HBA SLIM, skip past first

 Next copy over first word, with mbxOwner set */

 flush */

 switch over to host mailbox */

 Set up reference to mailbox command */

 Interrupt board to do it */

 flush */

 Don't wait for it to finish, just return */

 Set up null reference to mailbox command */

 Interrupt board to do it */

 flush */

 First read mbox status word */

 First read mbox status word */

 Read the HBA Host Attention Register */

 Wait for command to complete */

			/* Check if we took a mbox interrupt while we were

 First copy command data */

 Check real SLIM for any errors */

 First copy command data */

 Read the HBA Host Attention Register */

 copy results back to user */

 Copy the mailbox extension data */

 First copy command data */

 Copy the mailbox extension data */

 flush */

/**

 * lpfc_sli4_async_mbox_block - Block posting SLI4 asynchronous mailbox command

 * @phba: Pointer to HBA context object.

 *

 * The function blocks the posting of SLI4 asynchronous mailbox commands from

 * the driver internal pending mailbox queue. It will then try to wait out the

 * possible outstanding mailbox command before return.

 *

 * Returns:

 * 	0 - the outstanding mailbox command completed; otherwise, the wait for

 * 	the outstanding mailbox command timed out.

 Mark the asynchronous mailbox command posting as blocked */

	/* Determine how long we might wait for the active mailbox

	 * command to be gracefully completed by firmware.

 Make sure the mailbox is really active */

 Wait for the outstanding mailbox command to complete */

 Check active mailbox complete status every 2ms */

 Timeout, mark the outstanding cmd not complete */

			/* Sanity check sli.mbox_active has not completed or

			 * cancelled from another context during last 2ms sleep,

			 * so take hbalock to be sure before logging.

 Can not cleanly block async mailbox command, fails it */

/**

 * lpfc_sli4_async_mbox_unblock - Block posting SLI4 async mailbox command

 * @phba: Pointer to HBA context object.

 *

 * The function unblocks and resume posting of SLI4 asynchronous mailbox

 * commands from the driver internal pending mailbox queue. It makes sure

 * that there is no outstanding mailbox command before resuming posting

 * asynchronous mailbox commands. If, for any reason, there is outstanding

 * mailbox command, it will try to wait it out before resuming asynchronous

 * mailbox command posting.

 Asynchronous mailbox posting is not blocked, do nothing */

	/* Outstanding synchronous mailbox command is guaranteed to be done,

	 * successful or timeout, after timing-out the outstanding mailbox

	 * command shall always be removed, so just unblock posting async

	 * mailbox command and resume

 wake up worker thread to post asynchronous mailbox command */

/**

 * lpfc_sli4_wait_bmbx_ready - Wait for bootstrap mailbox register ready

 * @phba: Pointer to HBA context object.

 * @mboxq: Pointer to mailbox object.

 *

 * The function waits for the bootstrap mailbox register ready bit from

 * port for twice the regular mailbox command timeout value.

 *

 *      0 - no timeout on waiting for bootstrap mailbox register ready.

 *      MBXERR_ERROR - wait for bootstrap mailbox register timed out.

/**

 * lpfc_sli4_post_sync_mbox - Post an SLI4 mailbox to the bootstrap mailbox

 * @phba: Pointer to HBA context object.

 * @mboxq: Pointer to mailbox object.

 *

 * The function posts a mailbox to the port.  The mailbox is expected

 * to be comletely filled in and ready for the port to operate on it.

 * This routine executes a synchronous completion operation on the

 * mailbox by polling for its completion.

 *

 * The caller must not be holding any locks when calling this routine.

 *

 * Returns:

 *	MBX_SUCCESS - mailbox posted successfully

 *	Any of the MBX error values.

	/*

	 * Only one mailbox can be active to the bootstrap mailbox region

	 * at a time and there is no queueing provided.

 The server grabs the token and owns it until release */

 wait for bootstrap mbox register for readyness */

	/*

	 * Initialize the bootstrap memory region to avoid stale data areas

	 * in the mailbox post.  Then copy the caller's mailbox contents to

	 * the bmbx mailbox region.

 Post the high mailbox dma address to the port and wait for ready. */

 wait for bootstrap mbox register for hi-address write done */

 Post the low mailbox dma address to the port. */

 wait for bootstrap mbox register for low address write done */

	/*

	 * Read the CQ to ensure the mailbox has completed.

	 * If so, update the mailbox status so that the upper layers

	 * can complete the request normally.

	/*

	 * When the CQE status indicates a failure and the mailbox status

	 * indicates success then copy the CQE status into the mailbox status

	 * (and prefix it with x4000).

 We are holding the token, no needed for lock when release */

/**

 * lpfc_sli_issue_mbox_s4 - Issue an SLI4 mailbox command to firmware

 * @phba: Pointer to HBA context object.

 * @mboxq: Pointer to mailbox object.

 * @flag: Flag indicating how the mailbox need to be processed.

 *

 * This function is called by discovery code and HBA management code to submit

 * a mailbox command to firmware with SLI-4 interface spec.

 *

 * Return codes the caller owns the mailbox command after the return of the

 * function.

 dump from issue mailbox command if setup */

 Detect polling mode and jump to a handler */

 Try to block the asynchronous mailbox posting */

 Successfully blocked, now issue sync mbox cmd */

 Unblock the async mailbox posting afterward */

 Now, interrupt mode asynchronous mailbox command */

 Put the mailbox command to the driver internal FIFO */

 Wake up worker thread to transport mailbox command from head */

/**

 * lpfc_sli4_post_async_mbox - Post an SLI4 mailbox command to device

 * @phba: Pointer to HBA context object.

 *

 * This function is called by worker thread to send a mailbox command to

 * SLI4 HBA firmware.

 *

 Check interrupt mode before post async mailbox command */

 Check for mailbox command service token */

 Take the mailbox command service token */

 Get the next mailbox command from head of queue */

 If no more mailbox command waiting for post, we're done */

 Check device readiness for posting mailbox command */

 Driver clean routine will clean up pending mailbox */

 Prepare the mbox command to be posted */

 Start timer for the mbox_tmo and log some mailbox post messages */

 Post the mailbox command to the port */

 Release the token */

/**

 * lpfc_sli_issue_mbox - Wrapper func for issuing mailbox command

 * @phba: Pointer to HBA context object.

 * @pmbox: Pointer to mailbox object.

 * @flag: Flag indicating how the mailbox need to be processed.

 *

 * This routine wraps the actual SLI3 or SLI4 mailbox issuing routine from

 * the API jump table function pointer from the lpfc_hba struct.

 *

 * Return codes the caller owns the mailbox command after the return of the

 * function.

/**

 * lpfc_mbox_api_table_setup - Set up mbox api function jump table

 * @phba: The hba struct for which this call is being executed.

 * @dev_grp: The HBA PCI-Device group number.

 *

 * This routine sets up the mbox interface API function jump table in @phba

 * struct.

 * Returns: 0 - success, -ENODEV - failure.

/**

 * __lpfc_sli_ringtx_put - Add an iocb to the txq

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @piocb: Pointer to address of newly added command iocb.

 *

 * This function is called with hbalock held for SLI3 ports or

 * the ring lock held for SLI4 ports to add a command

 * iocb to the txq when SLI layer cannot submit the command iocb

 * to the ring.

 Insert the caller's iocb in the txq tail for later processing. */

/**

 * lpfc_sli_next_iocb - Get the next iocb in the txq

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @piocb: Pointer to address of newly added command iocb.

 *

 * This function is called with hbalock held before a new

 * iocb is submitted to the firmware. This function checks

 * txq to flush the iocbs in txq to Firmware before

 * submitting new iocbs to the Firmware.

 * If there are iocbs in the txq which need to be submitted

 * to firmware, lpfc_sli_next_iocb returns the first element

 * of the txq after dequeuing it from txq.

 * If there is no iocb in the txq then the function will return

 * *piocb and *piocb is set to NULL. Caller needs to check

 * *piocb to find if there are more commands in the txq.

/**

 * __lpfc_sli_issue_iocb_s3 - SLI3 device lockless ver of lpfc_sli_issue_iocb

 * @phba: Pointer to HBA context object.

 * @ring_number: SLI ring number to issue iocb on.

 * @piocb: Pointer to command iocb.

 * @flag: Flag indicating if this command can be put into txq.

 *

 * __lpfc_sli_issue_iocb_s3 is used by other functions in the driver to issue

 * an iocb command to an HBA with SLI-3 interface spec. If the PCI slot is

 * recovering from error state, if HBA is resetting or if LPFC_STOP_IOCB_EVENT

 * flag is turned on, the function returns IOCB_ERROR. When the link is down,

 * this function allows only iocbs for posting buffers. This function finds

 * next available slot in the command ring and posts the command to the

 * available slot and writes the port attention register to request HBA start

 * processing new iocb. If there is no slot available in the ring and

 * flag & SLI_IOCB_RET_IOCB is set, the new iocb is added to the txq, otherwise

 * the function returns IOCB_BUSY.

 *

 * This function is called with hbalock held. The function will return success

 * after it successfully submit the iocb to firmware or after adding to the

 * txq.

 If the PCI channel is in offline state, do not post iocbs. */

 If HBA has a deferred error attention, fail the iocb. */

	/*

	 * We should never get an IOCB if we are in a < LINK_DOWN state

	/*

	 * Check to see if we are blocking IOCB processing because of a

	 * outstanding event.

		/*

		 * Only CREATE_XRI, CLOSE_XRI, and QUE_RING_BUF

		 * can be issued if the link is not up.

			/*

			 * For IOCBs, like QUE_RING_BUF, that have no rsp ring

			 * completion, iocb_cmpl MUST be 0.

	/*

	 * For FCP commands, we must be in a state where we can process link

	 * attention events.

/**

 * lpfc_sli4_bpl2sgl - Convert the bpl/bde to a sgl.

 * @phba: Pointer to HBA context object.

 * @piocbq: Pointer to command iocb.

 * @sglq: Pointer to the scatter gather queue object.

 *

 * This routine converts the bpl or bde that is in the IOCB

 * to a sgl list for the sli4 hardware. The physical address

 * of the bpl/bde is converted back to a virtual address.

 * If the IOCB contains a BPL then the list of BDE's is

 * converted to sli4_sge's. If the IOCB contains a single

 * BDE then it is converted to a single sli_sge.

 * The IOCB is still in cpu endianess so the contents of

 * the bpl can be used without byte swapping.

 *

 * Returns valid XRI = Success, NO_XRI = Failure.

 accumulated offset in the sg request list */

 number of sg reply entries inbound from firmware */

		/* The addrHigh and addrLow fields within the IOCB

		 * have not been byteswapped yet so there is no

		 * need to swap them back.

 Should already be byte swapped. */

			/* swap the size field back to the cpu so we

			 * can assign it to the sgl.

			/* The offsets in the sgl need to be accumulated

			 * separately for the request and reply lists.

			 * The request is always first, the reply follows.

 add up the reply sg entries */

 first inbound? reset the offset */

			/* The addrHigh and addrLow fields of the BDE have not

			 * been byteswapped yet so they need to be swapped

			 * before putting them in the sgl.

/**

 * lpfc_sli4_iocb2wqe - Convert the IOCB to a work queue entry.

 * @phba: Pointer to HBA context object.

 * @iocbq: Pointer to command iocb.

 * @wqe: Pointer to the work queue entry.

 *

 * This routine converts the iocb command to its Work Queue Entry

 * equivalent. The wqe pointer should not have any fields set when

 * this routine is called because it will memcpy over them.

 * This routine does not set the CQ_ID or the WQEC bits in the

 * wqe.

 *

 * Returns: 0 = Success, IOCB_ERROR = Failure.

 The fcp commands will set command type */

 Some of the fields are in the right position already */

 The ct field has moved so reset */

 words0-2 bpl convert bde */

 Should already be byte swapped. */

		/* swap the size field back to the cpu so we

		 * can assign it to the sgl.

 Els_reguest64 has a TMO */

 Need a VF for word 4 set the vf bit*/

 And a VFID for word 12 */

 CCP CCPE PV PRI in word10 were set in the memcpy */

 The entire sequence is transmitted for this IOCB */

 word3 iocb=io_tag32 wqe=reserved */

 word4 relative_offset memcpy */

 word5 r_ctl/df_ctl memcpy */

 word3 iocb=iotag32 wqe=seq_payload_len */

 word4 iocb=rsvd wqe=rsvd */

 word5 iocb=rctl/type/df_ctl wqe=rctl/type/df_ctl memcpy */

 word6 iocb=ctxt_tag/io_tag wqe=ctxt_tag/xri */

 word3 iocb=iotag wqe=payload_offset_len */

 Add the FCP_CMD and FCP_RSP sizes to get the offset */

 word4 iocb=parameter wqe=total_xfer_length memcpy */

 word5 iocb=initial_xfer_len wqe=initial_xfer_len memcpy */

 Always open the exchange */

 Note, word 10 is already initialized to 0 */

 Don't set PBDE for Perf hints, just lpfc_enable_pbde */

 128 byte wqe support here */

 Word 0-2 - FCP_CMND */

 Word 22 */

 Word 22-29  FCP CMND Payload */

 word3 iocb=iotag wqe=payload_offset_len */

 Add the FCP_CMD and FCP_RSP sizes to get the offset */

 word4 iocb=parameter wqe=total_xfer_length memcpy */

 word5 iocb=initial_xfer_len wqe=initial_xfer_len memcpy */

 Always open the exchange */

 Note, word 10 is already initialized to 0 */

 Don't set PBDE for Perf hints, just lpfc_enable_pbde */

 128 byte wqe support here */

 Word 0-2 - FCP_CMND */

 Word 22 */

 Word 22-29  FCP CMND Payload */

 word3 iocb=iotag wqe=payload_offset_len */

 Add the FCP_CMD and FCP_RSP sizes to get the offset */

 word3 iocb=IO_TAG wqe=reserved */

 Always open the exchange */

 Note, word 10 is already initialized to 0 */

 128 byte wqe support here */

 Word 0-2 - FCP_CMND */

 Word 22 */

 Word 22-29  FCP CMND Payload */

		/* For this command calculate the xmit length of the

		 * request bde.

 word3 iocb=IO_TAG wqe=request_payload_len */

 word4 iocb=parameter wqe=relative_offset memcpy */

 word5 [rctl, type, df_ctl, la] copied in memcpy */

 word6 context tag copied in memcpy */

 words0-2 BDE memcpy */

 word3 iocb=iotag32 wqe=response_payload_len */

 word4 */

 word5 iocb=rsvd wge=did */

 words 0-2 memcpy should be 0 rserved */

 port will send abts */

			/*

			 * The link is down, or the command was ELS_FIP

			 * so the fw does not need to send abts

			 * on the wire.

 word5 iocb=CONTEXT_TAG|IO_TAG wqe=reserved */

		/*

		 * The abort handler will send us CMD_ABORT_XRI_CN or

		 * CMD_CLOSE_XRI_CN and the fw only accepts CMD_ABORT_XRI_CX

		/* As BLS ABTS RSP WQE is very different from other WQEs,

		 * we re-construct this WQE here based on information in

		 * iocbq from scratch.

 OX_ID is invariable to who sent ABTS to CT exchange */

			/* ABTS sent by initiator to CT exchange, the

			 * RX_ID field will be filled with the newly

			 * allocated responder XRI.

			/* ABTS sent by responder to CT exchange, the

			 * RX_ID field will be filled with the responder

			 * RX_ID from ABTS.

 Use CT=VPI */

 Overwrite the pre-set comnd type with OTHER_COMMAND */

 SOF byte */

 EOF byte */

 Do we expect to use this? */

 bidirectional xfer */

 Target mode send xfer-ready */

 Target mode rcv */

 Auto target rsp */

/**

 * __lpfc_sli_issue_fcp_io_s3 - SLI3 device for sending fcp io iocb

 * @phba: Pointer to HBA context object.

 * @ring_number: SLI ring number to issue wqe on.

 * @piocb: Pointer to command iocb.

 * @flag: Flag indicating if this command can be put into txq.

 *

 * __lpfc_sli_issue_fcp_io_s3 is wrapper function to invoke lockless func to

 * send  an iocb command to an HBA with SLI-4 interface spec.

 *

 * This function takes the hbalock before invoking the lockless version.

 * The function will return success after it successfully submit the wqe to

 * firmware or after adding to the txq.

/**

 * __lpfc_sli_issue_fcp_io_s4 - SLI4 device for sending fcp io wqe

 * @phba: Pointer to HBA context object.

 * @ring_number: SLI ring number to issue wqe on.

 * @piocb: Pointer to command iocb.

 * @flag: Flag indicating if this command can be put into txq.

 *

 * __lpfc_sli_issue_fcp_io_s4 is used by other functions in the driver to issue

 * an wqe command to an HBA with SLI-4 interface spec.

 *

 * This function is a lockless version. The function will return success

 * after it successfully submit the wqe to firmware or after adding to the

 * txq.

 128 byte wqe support here */

 Word 0-2 - FCP_CMND */

 Word 22 */

 Word 22-29  FCP CMND Payload */

 Word 0-2 - Inline BDE */

 Word 10 */

 add the VMID tags as per switch response */

/**

 * __lpfc_sli_issue_iocb_s4 - SLI4 device lockless ver of lpfc_sli_issue_iocb

 * @phba: Pointer to HBA context object.

 * @ring_number: SLI ring number to issue iocb on.

 * @piocb: Pointer to command iocb.

 * @flag: Flag indicating if this command can be put into txq.

 *

 * __lpfc_sli_issue_iocb_s4 is used by other functions in the driver to issue

 * an iocb command to an HBA with SLI-4 interface spec.

 *

 * This function is called with ringlock held. The function will return success

 * after it successfully submit the iocb to firmware or after adding to the

 * txq.

 Get the WQ */

 Get corresponding ring */

	/*

	 * The WQE can be either 64 or 128 bytes,

 These IO's already have an XRI and a mapped sgl. */

		/*

		 * This is a continuation of a commandi,(CX) so this

		 * sglq is on the active list

/*

 * lpfc_sli_issue_fcp_io - Wrapper func for issuing fcp i/o

 *

 * This routine wraps the actual fcp i/o function for issusing WQE for sli-4

 * or IOCB for sli-3  function.

 * pointer from the lpfc_hba struct.

 *

 * Return codes:

 * IOCB_ERROR - Error

 * IOCB_SUCCESS - Success

 * IOCB_BUSY - Busy

/*

 * __lpfc_sli_issue_iocb - Wrapper func of lockless version for issuing iocb

 *

 * This routine wraps the actual lockless version for issusing IOCB function

 * pointer from the lpfc_hba struct.

 *

 * Return codes:

 * IOCB_ERROR - Error

 * IOCB_SUCCESS - Success

 * IOCB_BUSY - Busy

/**

 * lpfc_sli_api_table_setup - Set up sli api function jump table

 * @phba: The hba struct for which this call is being executed.

 * @dev_grp: The HBA PCI-Device group number.

 *

 * This routine sets up the SLI interface API function jump table in @phba

 * struct.

 * Returns: 0 - success, -ENODEV - failure.

/**

 * lpfc_sli4_calc_ring - Calculates which ring to use

 * @phba: Pointer to HBA context object.

 * @piocb: Pointer to command iocb.

 *

 * For SLI4 only, FCP IO can deferred to one fo many WQs, based on

 * hba_wqidx, thus we need to calculate the corresponding ring.

 * Since ABORTS must go on the same WQ of the command they are

 * aborting, we use command's hba_wqidx.

		/*

		 * for abort iocb hba_wqidx should already

		 * be setup based on what work queue we used.

/**

 * lpfc_sli_issue_iocb - Wrapper function for __lpfc_sli_issue_iocb

 * @phba: Pointer to HBA context object.

 * @ring_number: Ring number

 * @piocb: Pointer to command iocb.

 * @flag: Flag indicating if this command can be put into txq.

 *

 * lpfc_sli_issue_iocb is a wrapper around __lpfc_sli_issue_iocb

 * function. This function gets the hbalock and calls

 * __lpfc_sli_issue_iocb function and will return the error returned

 * by __lpfc_sli_issue_iocb function. This wrapper is used by

 * functions which do not hold hbalock.

 For now, SLI2/3 will still use hbalock */

/**

 * lpfc_extra_ring_setup - Extra ring setup function

 * @phba: Pointer to HBA context object.

 *

 * This function is called while driver attaches with the

 * HBA to setup the extra ring. The extra ring is used

 * only when driver needs to support target mode functionality

 * or IP over FC functionalities.

 *

 * This function is called with no lock held. SLI3 only.

 Adjust cmd/rsp ring iocb entries more evenly */

 Take some away from the FCP ring */

 and give them to the extra ring */

 Setup default profile for this ring */

 Mask 0 */

 Incrementing the reference count until the queued work is done. */

/* lpfc_sli_abts_err_handler - handle a failed ABTS request from an SLI3 port.

 * @phba: Pointer to HBA context object.

 * @iocbq: Pointer to iocb object.

 *

 * The async_event handler calls this routine when it receives

 * an ASYNC_STATUS_CN event from the port.  The port generates

 * this event when an Abort Sequence request to an rport fails

 * twice in succession.  The abort could be originated by the

 * driver or by the port.  The ABTS could have been for an ELS

 * or FCP IO.  The port only generates this event when an ABTS

 * fails to complete after one retry.

 The rpi in the ulpContext is vport-sensitive. */

/* lpfc_sli4_abts_err_handler - handle a failed ABTS request from an SLI4 port.

 * @phba: pointer to HBA context object.

 * @ndlp: nodelist pointer for the impacted rport.

 * @axri: pointer to the wcqe containing the failed exchange.

 *

 * The driver calls this routine when it receives an ABORT_XRI_FCP CQE from the

 * port.  The port generates this event when an abort exchange request to an

 * rport fails twice in succession with no reply.  The abort could be originated

 * by the driver or by the port.  The ABTS could have been for an ELS or FCP IO.

	/*

	 * Catch the ABTS protocol failure case.  Older OCe FW releases returned

	 * LOCAL_REJECT and 0 for a failed ABTS exchange and later OCe and

	 * LPe FW releases returned LOCAL_REJECT and SEQUENCE_TIMEOUT.

/**

 * lpfc_sli_async_event_handler - ASYNC iocb handler function

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @iocbq: Pointer to iocb object.

 *

 * This function is called by the slow ring event handler

 * function when there is an ASYNC event iocb in the ring.

 * This function is called with no lock held.

 * Currently this function handles only temperature related

 * ASYNC events. The function decodes the temperature sensor

 * event message and posts events for the management applications.

 Send temperature change event to applications */

/**

 * lpfc_sli4_setup - SLI ring setup function

 * @phba: Pointer to HBA context object.

 *

 * lpfc_sli_setup sets up rings of the SLI interface with

 * number of iocbs per ring and iotags. This function is

 * called while driver attach to the HBA and before the

 * interrupts are enabled. So there is no need for locking.

 *

 * This function always returns 0.

 Mask 0 */

 Mask 1 */

 Mask 2 */

 NameServer Inquiry */

 NameServer */

 Mask 3 */

 NameServer response */

 NameServer */

/**

 * lpfc_sli_setup - SLI ring setup function

 * @phba: Pointer to HBA context object.

 *

 * lpfc_sli_setup sets up rings of the SLI interface with

 * number of iocbs per ring and iotags. This function is

 * called while driver attach to the HBA and before the

 * interrupts are enabled. So there is no need for locking.

 *

 * This function always returns 0. SLI3 only.

 ring 0 - FCP */

 numCiocb and numRiocb are used in config_port */

 ring 1 - EXTRA */

 numCiocb and numRiocb are used in config_port */

 ring 2 - ELS / CT */

 numCiocb and numRiocb are used in config_port */

 Mask 0 */

 Mask 1 */

 Mask 2 */

 NameServer Inquiry */

 NameServer */

 Mask 3 */

 NameServer response */

 NameServer */

 Too many cmd / rsp ring entries in SLI2 SLIM */

/**

 * lpfc_sli4_queue_init - Queue initialization function

 * @phba: Pointer to HBA context object.

 *

 * lpfc_sli4_queue_init sets up mailbox queues and iocb queues for each

 * ring. This function also initializes ring indices of each ring.

 * This function is called during the initialization of the SLI

 * interface of an HBA.

 * This function is called with no lock held and always returns

 * 1.

 Initialize list headers for txq and txcmplq as double linked lists */

/**

 * lpfc_sli_queue_init - Queue initialization function

 * @phba: Pointer to HBA context object.

 *

 * lpfc_sli_queue_init sets up mailbox queues and iocb queues for each

 * ring. This function also initializes ring indices of each ring.

 * This function is called during the initialization of the SLI

 * interface of an HBA.

 * This function is called with no lock held and always returns

 * 1.

 Initialize list headers for txq and txcmplq as double linked lists */

/**

 * lpfc_sli_mbox_sys_flush - Flush mailbox command sub-system

 * @phba: Pointer to HBA context object.

 *

 * This routine flushes the mailbox command subsystem. It will unconditionally

 * flush all the mailbox commands in the three possible stages in the mailbox

 * command sub-system: pending mailbox command queue; the outstanding mailbox

 * command; and completed mailbox command queue. It is caller's responsibility

 * to make sure that the driver is in the proper state to flush the mailbox

 * command sub-system. Namely, the posting of mailbox commands into the

 * pending mailbox command queue from the various clients must be stopped;

 * either the HBA is in a state that it will never works on the outstanding

 * mailbox command (such as in EEH or ERATT conditions) or the outstanding

 * mailbox command has been completed.

 Disable softirqs, including timers from obtaining phba->hbalock */

 Flush all the mailbox commands in the mbox system */

 The pending mailbox command queue */

 The outstanding active mailbox command */

 The completed mailbox command queue */

 Enable softirqs again, done with phba->hbalock */

 Return all flushed mailbox commands with MBX_NOT_FINISHED status */

/**

 * lpfc_sli_host_down - Vport cleanup function

 * @vport: Pointer to virtual port object.

 *

 * lpfc_sli_host_down is called to clean up the resources

 * associated with a vport before destroying virtual

 * port data structures.

 * This function does following operations:

 * - Free discovery resources associated with this virtual

 *   port.

 * - Free iocbs associated with this virtual port in

 *   the txq.

 * - Send abort for all iocb commands associated with this

 *   vport in txcmplq.

 *

 * This function is called with no lock held and always returns 1.

	/*

	 * Error everything on the txq since these iocbs

	 * have not been given to the FW yet.

	 * Also issue ABTS for everything on the txcmplq

 Only slow rings */

 Set the lpfc data pending flag */

 Set the lpfc data pending flag */

 Make sure HBA is alive */

 Cancel all the IOCBs from the completions list */

/**

 * lpfc_sli_hba_down - Resource cleanup function for the HBA

 * @phba: Pointer to HBA context object.

 *

 * This function cleans up all iocb, buffers, mailbox commands

 * while shutting down the HBA. This function is called with no

 * lock held and always returns 1.

 * This function does the following to cleanup driver resources:

 * - Free discovery resources for each virtual port

 * - Cleanup any pending fabric iocbs

 * - Iterate through the iocb txq and free each entry

 *   in the list.

 * - Free up any buffer posted to the HBA

 * - Free mailbox commands in the mailbox queue.

 Shutdown the mailbox command sub-system */

 Disable softirqs, including timers from obtaining phba->hbalock */

	/*

	 * Error everything on the txq since these iocbs

	 * have not been given to the FW yet.

 Only slow rings */

 Set the lpfc data pending flag */

 Set the lpfc data pending flag */

 Cancel all the IOCBs from the completions list */

 Enable softirqs again, done with phba->hbalock */

 Return any active mbox cmds */

/**

 * lpfc_sli_pcimem_bcopy - SLI memory copy function

 * @srcp: Source memory pointer.

 * @destp: Destination memory pointer.

 * @cnt: Number of words required to be copied.

 *

 * This function is used for copying data between driver memory

 * and the SLI memory. This function also changes the endianness

 * of each word if native endianness is different from SLI

 * endianness. This function can be called with or without

 * lock.

/**

 * lpfc_sli_bemem_bcopy - SLI memory copy function

 * @srcp: Source memory pointer.

 * @destp: Destination memory pointer.

 * @cnt: Number of words required to be copied.

 *

 * This function is used for copying data between a data structure

 * with big endian representation to local endianness.

 * This function can be called with or without lock.

/**

 * lpfc_sli_ringpostbuf_put - Function to add a buffer to postbufq

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @mp: Pointer to driver buffer object.

 *

 * This function is called with no lock held.

 * It always return zero after adding the buffer to the postbufq

 * buffer list.

	/* Stick struct lpfc_dmabuf at end of postbufq so driver can look it up

/**

 * lpfc_sli_get_buffer_tag - allocates a tag for a CMD_QUE_XRI64_CX buffer

 * @phba: Pointer to HBA context object.

 *

 * When HBQ is enabled, buffers are searched based on tags. This function

 * allocates a tag for buffer posted using CMD_QUE_XRI64_CX iocb. The

 * tag is bit wise or-ed with QUE_BUFTAG_BIT to make sure that the tag

 * does not conflict with tags of buffer posted for unsolicited events.

 * The function returns the allocated tag. The function is called with

 * no locks held.

	/*

	 * Always set the QUE_BUFTAG_BIT to distiguish between

	 * a tag assigned by HBQ.

/**

 * lpfc_sli_ring_taggedbuf_get - find HBQ buffer associated with given tag

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @tag: Buffer tag.

 *

 * Buffers posted using CMD_QUE_XRI64_CX iocb are in pring->postbufq

 * list. After HBA DMA data to these buffers, CMD_IOCB_RET_XRI64_CX

 * iocb is posted to the response ring with the tag of the buffer.

 * This function searches the pring->postbufq list using the tag

 * to find buffer associated with CMD_IOCB_RET_XRI64_CX

 * iocb. If the buffer is found then lpfc_dmabuf object of the

 * buffer is returned to the caller else NULL is returned.

 * This function is called with no lock held.

 Search postbufq, from the beginning, looking for a match on tag */

/**

 * lpfc_sli_ringpostbuf_get - search buffers for unsolicited CT and ELS events

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @phys: DMA address of the buffer.

 *

 * This function searches the buffer list using the dma_address

 * of unsolicited event to find the driver's lpfc_dmabuf object

 * corresponding to the dma_address. The function returns the

 * lpfc_dmabuf object if a buffer is found else it returns NULL.

 * This function is called by the ct and els unsolicited event

 * handlers to get the buffer associated with the unsolicited

 * event.

 *

 * This function is called with no lock held.

 Search postbufq, from the beginning, looking for a match on phys */

/**

 * lpfc_sli_abort_els_cmpl - Completion handler for the els abort iocbs

 * @phba: Pointer to HBA context object.

 * @cmdiocb: Pointer to driver command iocb object.

 * @rspiocb: Pointer to driver response iocb object.

 *

 * This function is the completion handler for the abort iocbs for

 * ELS commands. This function is called from the ELS ring event

 * handler with no lock held. This function frees memory resources

 * associated with the abort iocb.

		/*

		 * Assume that the port already completed and returned, or

		 * will return the iocb. Just Log the message.

			/* For sli4 the abort_tag is the XRI,

			 * so the abort routine puts the iotag  of the iocb

			 * being aborted in the context field of the abort

			 * IOCB.

/**

 * lpfc_ignore_els_cmpl - Completion handler for aborted ELS command

 * @phba: Pointer to HBA context object.

 * @cmdiocb: Pointer to driver command iocb object.

 * @rspiocb: Pointer to driver response iocb object.

 *

 * The function is called from SLI ring event handler with no

 * lock held. This function is the completion handler for ELS commands

 * which are aborted. The function frees memory resources used for

 * the aborted ELS commands.

 ELS cmd tag <ulpIoTag> completes */

	/*

	 * Deref the ndlp after free_iocb. sli_release_iocb will access the ndlp

	 * if exchange is busy.

/**

 * lpfc_sli_issue_abort_iotag - Abort function for a command iocb

 * @phba: Pointer to HBA context object.

 * @pring: Pointer to driver SLI ring object.

 * @cmdiocb: Pointer to driver command iocb object.

 * @cmpl: completion function.

 *

 * This function issues an abort iocb for the provided command iocb. In case

 * of unloading, the abort iocb will not be issued to commands on the ELS

 * ring. Instead, the callback function shall be changed to those commands

 * so that nothing happens when them finishes. This function is called with

 * hbalock held andno ring_lock held (SLI4). The function returns IOCB_SUCCESS

 * when the command iocb is an abort request.

 *

	/*

	 * There are certain command types we don't want to abort.  And we

	 * don't want to abort commands that are already in the process of

	 * being aborted.

	/*

	 * If we're unloading, don't abort iocb on the ELS ring, but change

	 * the callback so that nothing happens when it finishes.

 issue ABTS for this IOCB based on iotag */

	/* This signals the response to set the correct status

	 * before calling the completion handler

 ABTS WQE must go to the same WQ as the WQE to be aborted */

 Note: both hbalock and ring_lock need to be set here */

	/*

	 * Caller to this routine should check for IOCB_ERROR

	 * and handle it properly.  This routine no longer removes

	 * iocb off txcmplq and call compl in case of IOCB_ERROR.

/**

 * lpfc_sli_hba_iocb_abort - Abort all iocbs to an hba.

 * @phba: pointer to lpfc HBA data structure.

 *

 * This routine will abort all pending and outstanding iocbs to an HBA.

/**

 * lpfc_sli_validate_fcp_iocb_for_abort - filter iocbs appropriate for FCP aborts

 * @iocbq: Pointer to iocb object.

 * @vport: Pointer to driver virtual port object.

 *

 * This function acts as an iocb filter for functions which abort FCP iocbs.

 *

 * Return values

 * -ENODEV, if a null iocb or vport ptr is encountered

 * -EINVAL, if the iocb is not an FCP I/O, not on the TX cmpl queue, premarked as

 *          driver already started the abort process, or is an abort iocb itself

 * 0, passes criteria for aborting the FCP I/O iocb

 No null ptr vports */

	/* iocb must be for FCP IO, already exists on the TX cmpl queue,

	 * can't be premarked as driver aborted, nor be an ABORT iocb itself

/**

 * lpfc_sli_validate_fcp_iocb - validate commands associated with a SCSI target

 * @iocbq: Pointer to driver iocb object.

 * @vport: Pointer to driver virtual port object.

 * @tgt_id: SCSI ID of the target.

 * @lun_id: LUN ID of the scsi device.

 * @ctx_cmd: LPFC_CTX_LUN/LPFC_CTX_TGT/LPFC_CTX_HOST

 *

 * This function acts as an iocb filter for validating a lun/SCSI target/SCSI

 * host.

 *

 * It will return

 * 0 if the filtering criteria is met for the given iocb and will return

 * 1 if the filtering criteria is not met.

 * If ctx_cmd == LPFC_CTX_LUN, the function returns 0 only if the

 * given iocb is for the SCSI device specified by vport, tgt_id and

 * lun_id parameter.

 * If ctx_cmd == LPFC_CTX_TGT,  the function returns 0 only if the

 * given iocb is for the SCSI target specified by vport and tgt_id

 * parameters.

 * If ctx_cmd == LPFC_CTX_HOST, the function returns 0 only if the

 * given iocb is for the SCSI host associated with the given vport.

 * This function is called with no locks held.

/**

 * lpfc_sli_sum_iocb - Function to count the number of FCP iocbs pending

 * @vport: Pointer to virtual port.

 * @tgt_id: SCSI ID of the target.

 * @lun_id: LUN ID of the scsi device.

 * @ctx_cmd: LPFC_CTX_LUN/LPFC_CTX_TGT/LPFC_CTX_HOST.

 *

 * This function returns number of FCP commands pending for the vport.

 * When ctx_cmd == LPFC_CTX_LUN, the function returns number of FCP

 * commands pending on the vport associated with SCSI device specified

 * by tgt_id and lun_id parameters.

 * When ctx_cmd == LPFC_CTX_TGT, the function returns number of FCP

 * commands pending on the vport associated with SCSI target specified

 * by tgt_id parameter.

 * When ctx_cmd == LPFC_CTX_HOST, the function returns number of FCP

 * commands pending on the vport.

 * This function returns the number of iocbs which satisfy the filter.

 * This function is called without any lock held.

 Include counting outstanding aborts */

/**

 * lpfc_sli4_abort_fcp_cmpl - Completion handler function for aborted FCP IOCBs

 * @phba: Pointer to HBA context object

 * @cmdiocb: Pointer to command iocb object.

 * @wcqe: pointer to the complete wcqe

 *

 * This function is called when an aborted FCP iocb completes. This

 * function is called by the ring event handler with no lock held.

 * This function frees the iocb. It is called for sli-4 adapters.

/**

 * lpfc_sli_abort_fcp_cmpl - Completion handler function for aborted FCP IOCBs

 * @phba: Pointer to HBA context object

 * @cmdiocb: Pointer to command iocb object.

 * @rspiocb: Pointer to response iocb object.

 *

 * This function is called when an aborted FCP iocb completes. This

 * function is called by the ring event handler with no lock held.

 * This function frees the iocb.

/**

 * lpfc_sli_abort_iocb - issue abort for all commands on a host/target/LUN

 * @vport: Pointer to virtual port.

 * @tgt_id: SCSI ID of the target.

 * @lun_id: LUN ID of the scsi device.

 * @abort_cmd: LPFC_CTX_LUN/LPFC_CTX_TGT/LPFC_CTX_HOST.

 *

 * This function sends an abort command for every SCSI command

 * associated with the given virtual port pending on the ring

 * filtered by lpfc_sli_validate_fcp_iocb_for_abort and then

 * lpfc_sli_validate_fcp_iocb function.  The ordering for validation before

 * submitting abort iocbs must be lpfc_sli_validate_fcp_iocb_for_abort

 * followed by lpfc_sli_validate_fcp_iocb.

 *

 * When abort_cmd == LPFC_CTX_LUN, the function sends abort only to the

 * FCP iocbs associated with lun specified by tgt_id and lun_id

 * parameters

 * When abort_cmd == LPFC_CTX_TGT, the function sends abort only to the

 * FCP iocbs associated with SCSI target specified by tgt_id parameter.

 * When abort_cmd == LPFC_CTX_HOST, the function sends abort to all

 * FCP iocbs associated with virtual port.

 * The pring used for SLI3 is sli3_ring[LPFC_FCP_RING], for SLI4

 * lpfc_sli4_calc_ring is used.

 * This function returns number of iocbs it failed to abort.

 * This function is called with no locks held.

 all I/Os are in process of being flushed */

/**

 * lpfc_sli_abort_taskmgmt - issue abort for all commands on a host/target/LUN

 * @vport: Pointer to virtual port.

 * @pring: Pointer to driver SLI ring object.

 * @tgt_id: SCSI ID of the target.

 * @lun_id: LUN ID of the scsi device.

 * @cmd: LPFC_CTX_LUN/LPFC_CTX_TGT/LPFC_CTX_HOST.

 *

 * This function sends an abort command for every SCSI command

 * associated with the given virtual port pending on the ring

 * filtered by lpfc_sli_validate_fcp_iocb_for_abort and then

 * lpfc_sli_validate_fcp_iocb function.  The ordering for validation before

 * submitting abort iocbs must be lpfc_sli_validate_fcp_iocb_for_abort

 * followed by lpfc_sli_validate_fcp_iocb.

 *

 * When taskmgmt_cmd == LPFC_CTX_LUN, the function sends abort only to the

 * FCP iocbs associated with lun specified by tgt_id and lun_id

 * parameters

 * When taskmgmt_cmd == LPFC_CTX_TGT, the function sends abort only to the

 * FCP iocbs associated with SCSI target specified by tgt_id parameter.

 * When taskmgmt_cmd == LPFC_CTX_HOST, the function sends abort to all

 * FCP iocbs associated with virtual port.

 * This function returns number of iocbs it aborted .

 * This function is called with no locks held right after a taskmgmt

 * command is sent.

 all I/Os are in process of being flushed */

 Guard against IO completion being called at same time */

 Note: both hbalock and ring_lock must be set here */

		/*

		 * If the iocbq is already being aborted, don't take a second

		 * action, but do count it.

 issue ABTS for this IOCB based on iotag */

 ABTS WQE must go to the same WQ as the WQE to be aborted */

 Setup callback routine and issue the command. */

		/*

		 * Indicate the IO is being aborted by the driver and set

		 * the caller's flag into the aborted IO.

/**

 * lpfc_sli_wake_iocb_wait - lpfc_sli_issue_iocb_wait's completion handler

 * @phba: Pointer to HBA context object.

 * @cmdiocbq: Pointer to command iocb.

 * @rspiocbq: Pointer to response iocb.

 *

 * This function is the completion handler for iocbs issued using

 * lpfc_sli_issue_iocb_wait function. This function is called by the

 * ring event handler function without any lock held. This function

 * can be called from both worker thread context and interrupt

 * context. This function also can be called from other thread which

 * cleans up the SLI layer objects.

 * This function copy the contents of the response iocb to the

 * response iocb memory object provided by the caller of

 * lpfc_sli_issue_iocb_wait and then wakes up the thread which

 * sleeps for the iocb completion.

		/*

		 * A time out has occurred for the iocb.  If a time out

		 * completion handler has been supplied, call it.  Otherwise,

		 * just free the iocbq.

 Set the exchange busy flag for task management commands */

/**

 * lpfc_chk_iocb_flg - Test IOCB flag with lock held.

 * @phba: Pointer to HBA context object..

 * @piocbq: Pointer to command iocb.

 * @flag: Flag to test.

 *

 * This routine grabs the hbalock and then test the iocb_flag to

 * see if the passed in flag is set.

 * Returns:

 * 1 if flag is set.

 * 0 if flag is not set.

/**

 * lpfc_sli_issue_iocb_wait - Synchronous function to issue iocb commands

 * @phba: Pointer to HBA context object..

 * @ring_number: Ring number

 * @piocb: Pointer to command iocb.

 * @prspiocbq: Pointer to response iocb.

 * @timeout: Timeout in number of seconds.

 *

 * This function issues the iocb to firmware and waits for the

 * iocb to complete. The iocb_cmpl field of the shall be used

 * to handle iocbs which time out. If the field is NULL, the

 * function shall free the iocbq structure.  If more clean up is

 * needed, the caller is expected to provide a completion function

 * that will provide the needed clean up.  If the iocb command is

 * not completed within timeout seconds, the function will either

 * free the iocbq structure (if iocb_cmpl == NULL) or execute the

 * completion function set in the iocb_cmpl field and then return

 * a status of IOCB_TIMEDOUT.  The caller should not free the iocb

 * resources if this function returns IOCB_TIMEDOUT.

 * The function waits for the iocb completion using an

 * non-interruptible wait.

 * This function will sleep while waiting for iocb completion.

 * So, this function should not be called from any context which

 * does not allow sleeping. Due to the same reason, this function

 * cannot be called with interrupt disabled.

 * This function assumes that the iocb completions occur while

 * this function sleep. So, this function cannot be called from

 * the thread which process iocb completion for this ring.

 * This function clears the iocb_flag of the iocb object before

 * issuing the iocb and the iocb completion handler sets this

 * flag and wakes this thread when the iocb completes.

 * The contents of the response iocb will be copied to prspiocbq

 * by the completion handler when the command completes.

 * This function returns IOCB_SUCCESS when success.

 * This function is called with no lock held.

	/*

	 * If the caller has provided a response iocbq buffer, then context2

	 * is NULL or its an error.

 flush */

			/*

			 * IOCB timed out.  Inform the wake iocb wait

			 * completion function and set local status

			/* Note: we are not indicating if the IOCB has a success

			 * status or not - that's for the caller to check.

			 * IOCB_SUCCESS means just that the command was sent and

			 * completed. Not that it completed successfully.

 flush */

/**

 * lpfc_sli_issue_mbox_wait - Synchronous function to issue mailbox

 * @phba: Pointer to HBA context object.

 * @pmboxq: Pointer to driver mailbox object.

 * @timeout: Timeout in number of seconds.

 *

 * This function issues the mailbox to firmware and waits for the

 * mailbox command to complete. If the mailbox command is not

 * completed within timeout seconds, it returns MBX_TIMEOUT.

 * The function waits for the mailbox completion using an

 * interruptible wait. If the thread is woken up due to a

 * signal, MBX_TIMEOUT error is returned to the caller. Caller

 * should not free the mailbox resources, if this function returns

 * MBX_TIMEOUT.

 * This function will sleep while waiting for mailbox completion.

 * So, this function should not be called from any context which

 * does not allow sleeping. Due to the same reason, this function

 * cannot be called with interrupt disabled.

 * This function assumes that the mailbox completion occurs while

 * this function sleep. So, this function cannot be called from

 * the worker thread which processes mailbox completion.

 * This function is called in the context of HBA management

 * applications.

 * This function returns MBX_SUCCESS when successful.

 * This function is called with no lock held.

 setup wake call as IOCB callback */

 setup context3 field to pass wait_queue pointer to wake function  */

 now issue the command */

		/*

		 * if LPFC_MBX_WAKE flag is set the mailbox is completed

		 * else do not free the resources.

/**

 * lpfc_sli_mbox_sys_shutdown - shutdown mailbox command sub-system

 * @phba: Pointer to HBA context.

 * @mbx_action: Mailbox shutdown options.

 *

 * This function is called to shutdown the driver's mailbox sub-system.

 * It first marks the mailbox sub-system is in a block state to prevent

 * the asynchronous mailbox command from issued off the pending mailbox

 * command queue. If the mailbox command sub-system shutdown is due to

 * HBA error conditions such as EEH or ERATT, this routine shall invoke

 * the mailbox sub-system flush routine to forcefully bring down the

 * mailbox sub-system. Otherwise, if it is due to normal condition (such

 * as with offline or HBA function reset), this routine will wait for the

 * outstanding mailbox command to complete before invoking the mailbox

 * sub-system flush routine to gracefully bring down mailbox sub-system.

 delay 100ms for port state */

 Disable softirqs, including timers from obtaining phba->hbalock */

		/* Determine how long we might wait for the active mailbox

		 * command to be gracefully completed by firmware.

 Enable softirqs again, done with phba->hbalock */

 Check active mailbox complete status every 2ms */

				/* Timeout, let the mailbox flush routine to

				 * forcefully release active mailbox command

 Enable softirqs again, done with phba->hbalock */

/**

 * lpfc_sli_eratt_read - read sli-3 error attention events

 * @phba: Pointer to HBA context.

 *

 * This function is called to read the SLI3 device error attention registers

 * for possible error attention events. The caller must hold the hostlock

 * with spin_lock_irq().

 *

 * This function returns 1 when there is Error Attention in the Host Attention

 * Register and returns 0 otherwise.

 Read chip Host Attention (HA) register */

 Read host status register to retrieve error event */

 Check if there is a deferred error condition is active */

 Clear all interrupt enable conditions */

 Set the driver HA work bitmap */

 Indicate polling handles this ERATT */

 Set the driver HS work bitmap */

 Set the driver HA work bitmap */

 Indicate polling handles this ERATT */

/**

 * lpfc_sli4_eratt_read - read sli-4 error attention events

 * @phba: Pointer to HBA context.

 *

 * This function is called to read the SLI4 device error attention registers

 * for possible error attention events. The caller must hold the hostlock

 * with spin_lock_irq().

 *

 * This function returns 1 when there is Error Attention in the Host Attention

 * Register and returns 0 otherwise.

	/*

	 * For now, use the SLI4 device internal unrecoverable error

	 * registers for error attention. This can be changed later.

/**

 * lpfc_sli_check_eratt - check error attention events

 * @phba: Pointer to HBA context.

 *

 * This function is called from timer soft interrupt context to check HBA's

 * error attention register bit for error attention events.

 *

 * This function returns 1 when there is Error Attention in the Host Attention

 * Register and returns 0 otherwise.

	/* If somebody is waiting to handle an eratt, don't process it

	 * here. The brdkill function will do this.

 Check if interrupt handler handles this ERATT */

 Interrupt handler has handled ERATT */

	/*

	 * If there is deferred error attention, do not check for error

	 * attention

 If PCI channel is offline, don't process it */

 Read chip Host Attention (HA) register */

 Read device Uncoverable Error (UERR) registers */

/**

 * lpfc_intr_state_check - Check device state for interrupt handling

 * @phba: Pointer to HBA context.

 *

 * This inline routine checks whether a device or its PCI slot is in a state

 * that the interrupt should be handled.

 *

 * This function returns 0 if the device or the PCI slot is in a state that

 * interrupt should be handled, otherwise -EIO.

 If the pci channel is offline, ignore all the interrupts */

 Update device level interrupt statistics */

 Ignore all interrupts during initialization. */

/**

 * lpfc_sli_sp_intr_handler - Slow-path interrupt handler to SLI-3 device

 * @irq: Interrupt number.

 * @dev_id: The device context pointer.

 *

 * This function is directly called from the PCI layer as an interrupt

 * service routine when device with SLI-3 interface spec is enabled with

 * MSI-X multi-message interrupt mode and there are slow-path events in

 * the HBA. However, when the device is enabled with either MSI or Pin-IRQ

 * interrupt mode, this function is called as part of the device-level

 * interrupt handler. When the PCI slot is in error recovery or the HBA

 * is undergoing initialization, the interrupt handler will not process

 * the interrupt. The link attention and ELS ring attention events are

 * handled by the worker thread. The interrupt handler signals the worker

 * thread and returns for these events. This function is called without

 * any lock held. It gets the hbalock to access and update SLI data

 * structures.

 *

 * This function returns IRQ_HANDLED when interrupt is handled else it

 * returns IRQ_NONE.

	/*

	 * Get the driver's phba structure from the dev_id and

	 * assume the HBA is not interrupting.

	/*

	 * Stuff needs to be attented to when this function is invoked as an

	 * individual interrupt handler in MSI-X multi-message interrupt mode

 Check device state for handling interrupt */

 Need to read HA REG for slow-path events */

		/* If somebody is waiting to handle an eratt don't process it

		 * here. The brdkill function will do this.

 Check the need for handling ERATT in interrupt handler */

 ERATT polling has handled ERATT */

 Indicate interrupt handler handles ERATT */

		/*

		 * If there is deferred error attention, do not check for any

		 * interrupt.

 Clear up only attention source related to slow-path */

 flush */

				/*

				 * Turn off Link Attention interrupts

				 * until CLEAR_LA done

 flush */

			/*

			 * Turn off Slow Rings interrupts, LPFC_ELS_RING is

			 * the only slow ring.

 flush */

			/*

			 * Check if there is a deferred error condition

			 * is active

 Clear all interrupt enable conditions */

 First check out the status word */

				/*

				 * Stray Mailbox Interrupt, mbxCommand <cmd>

				 * mbxStatus <status>

 clear mailbox attention bit */

						/* Reg_LOGIN of dflt RPI was

						 * successful. new lets get

						 * rid of the RPI using the

						 * same mbox buffer.

				/* Do NOT queue MBX_HEARTBEAT to the worker

				 * thread for processing.

 Process mbox now */

 Queue to worker thread to process */

 Process next mailbox command if there is one */

 lpfc_sli_sp_intr_handler */

/**

 * lpfc_sli_fp_intr_handler - Fast-path interrupt handler to SLI-3 device.

 * @irq: Interrupt number.

 * @dev_id: The device context pointer.

 *

 * This function is directly called from the PCI layer as an interrupt

 * service routine when device with SLI-3 interface spec is enabled with

 * MSI-X multi-message interrupt mode and there is a fast-path FCP IOCB

 * ring event in the HBA. However, when the device is enabled with either

 * MSI or Pin-IRQ interrupt mode, this function is called as part of the

 * device-level interrupt handler. When the PCI slot is in error recovery

 * or the HBA is undergoing initialization, the interrupt handler will not

 * process the interrupt. The SCSI FCP fast-path ring event are handled in

 * the intrrupt context. This function is called without any lock held.

 * It gets the hbalock to access and update SLI data structures.

 *

 * This function returns IRQ_HANDLED when interrupt is handled else it

 * returns IRQ_NONE.

	/* Get the driver's phba structure from the dev_id and

	 * assume the HBA is not interrupting.

	/*

	 * Stuff needs to be attented to when this function is invoked as an

	 * individual interrupt handler in MSI-X multi-message interrupt mode

 Check device state for handling interrupt */

 Need to read HA REG for FCP ring and other ring events */

 Clear up only attention source related to fast-path */

		/*

		 * If there is deferred error attention, do not check for

		 * any interrupt.

 flush */

	/*

	 * Process all events on FCP ring. Take the optimized path for FCP IO.

		/*

		 * Process all events on extra ring. Take the optimized path

		 * for extra ring IO.

 lpfc_sli_fp_intr_handler */

/**

 * lpfc_sli_intr_handler - Device-level interrupt handler to SLI-3 device

 * @irq: Interrupt number.

 * @dev_id: The device context pointer.

 *

 * This function is the HBA device-level interrupt handler to device with

 * SLI-3 interface spec, called from the PCI layer when either MSI or

 * Pin-IRQ interrupt mode is enabled and there is an event in the HBA which

 * requires driver attention. This function invokes the slow-path interrupt

 * attention handling function and fast-path interrupt attention handling

 * function in turn to process the relevant HBA attention events. This

 * function is called without any lock held. It gets the hbalock to access

 * and update SLI data structures.

 *

 * This function returns IRQ_HANDLED when interrupt is handled, else it

 * returns IRQ_NONE.

	/*

	 * Get the driver's phba structure from the dev_id and

	 * assume the HBA is not interrupting.

 Check device state for handling interrupt */

 ERATT polling has handled ERATT */

 Indicate interrupt handler handles ERATT */

	/*

	 * If there is deferred error attention, do not check for any interrupt.

 Clear attention sources except link and error attentions */

 flush */

	/*

	 * Invokes slow-path host attention interrupt handling as appropriate.

 status of events with mailbox and link attention */

 status of events with ELS ring */

	/*

	 * Invoke fast-path host attention interrupt handling as appropriate.

 status of events with FCP ring */

 status of events with extra ring */

 Return device-level interrupt handling status */

 lpfc_sli_intr_handler */

/**

 * lpfc_sli4_els_xri_abort_event_proc - Process els xri abort event

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked by the worker thread to process all the pending

 * SLI4 els abort xri events.

 First, declare the els xri abort event has been handled */

 Now, handle all the els xri abort events */

 Get the first event from the head of the event queue */

 Notify aborted XRI for ELS work queue */

 Free the event processed back to the free pool */

/**

 * lpfc_sli4_iocb_param_transfer - Transfer pIocbOut and cmpl status to pIocbIn

 * @phba: pointer to lpfc hba data structure

 * @pIocbIn: pointer to the rspiocbq

 * @pIocbOut: pointer to the cmdiocbq

 * @wcqe: pointer to the complete wcqe

 *

 * This routine transfers the fields of a command iocbq to a response iocbq

 * by copying all the IOCB fields from command iocbq and transferring the

 * completion status information from the complete wcqe.

 Map WCQE parameters into irspiocb parameters */

 Convert BG errors for completion status */

 Guard Check failed */

 App Tag Check failed */

 Ref Tag Check failed */

 Check to see if there was any good data before the error */

		/*

		* Set ALL the error bits to indicate we don't know what

		* type of error it is.

 Pick up HBA exchange busy condition */

/**

 * lpfc_sli4_els_wcqe_to_rspiocbq - Get response iocbq from els wcqe

 * @phba: Pointer to HBA context object.

 * @irspiocbq: Pointer to work-queue completion queue entry.

 *

 * This routine handles an ELS work-queue completion event and construct

 * a pseudo response ELS IODBQ from the SLI4 ELS WCQE for the common

 * discovery engine to handle.

 *

 * Return: Pointer to the receive IOCBQ, NULL otherwise.

 Look up the ELS command IOCB and create pseudo response IOCB */

 Put the iocb back on the txcmplq */

 Fake the irspiocbq and copy necessary response information */

 Allocate a new internal CQ_EVENT entry */

 Move the CQE into the event */

/**

 * lpfc_sli4_sp_handle_async_event - Handle an asynchronous event

 * @phba: Pointer to HBA context object.

 * @mcqe: Pointer to mailbox completion queue entry.

 *

 * This routine process a mailbox completion queue entry with asynchronous

 * event.

 *

 * Return: true if work posted to worker thread, otherwise false.

 Set the async event flag */

/**

 * lpfc_sli4_sp_handle_mbox_event - Handle a mailbox completion event

 * @phba: Pointer to HBA context object.

 * @mcqe: Pointer to mailbox completion queue entry.

 *

 * This routine process a mailbox completion queue entry with mailbox

 * completion event.

 *

 * Return: true if work posted to worker thread, otherwise false.

 If not a mailbox complete MCQE, out by checking mailbox consume */

 Get the reference to the active mbox command */

 Reset heartbeat timer */

 Move mbox data to caller's mailbox region, do endian swapping */

	/*

	 * For mcqe errors, conditionally move a modified error code to

	 * the mbox so that the error will not be missed.

			/* Reg_LOGIN of dflt RPI was successful. Mark the

			 * node as having an UNREG_LOGIN in progress to stop

			 * an unsolicited PLOGI from the same NPortId from

			 * starting another mailbox transaction.

			/* No reference taken here.  This is a default

			 * RPI reg/immediate unreg cycle. The reference was

			 * taken in the reg rpi path and is released when

			 * this mailbox completes.

 Do NOT queue MBX_HEARTBEAT to the worker thread for processing. */

 Release the mailbox command posting token */

 Post the next mbox command, if there is one */

 Process cmpl now */

 There is mailbox completion work to queue to the worker thread */

 Release the mailbox command posting token */

 Setting active mailbox pointer need to be in sync to flag clear */

 Wake up worker thread to post the next pending mailbox command */

/**

 * lpfc_sli4_sp_handle_mcqe - Process a mailbox completion queue entry

 * @phba: Pointer to HBA context object.

 * @cq: Pointer to associated CQ

 * @cqe: Pointer to mailbox completion queue entry.

 *

 * This routine process a mailbox completion queue entry, it invokes the

 * proper mailbox complete handling or asynchronous event handling routine

 * according to the MCQE's async bit.

 *

 * Return: true if work posted to worker thread, otherwise false.

 Copy the mailbox MCQE and convert endian order as needed */

 Invoke the proper event handling routine */

/**

 * lpfc_sli4_sp_handle_els_wcqe - Handle els work-queue completion event

 * @phba: Pointer to HBA context object.

 * @cq: Pointer to associated CQ

 * @wcqe: Pointer to work-queue completion queue entry.

 *

 * This routine handles an ELS work-queue completion event.

 *

 * Return: true if work posted to worker thread, otherwise false.

 Check for response status */

 Log the error status */

 Get an irspiocbq for later ELS response processing use */

 Save off the slow-path queue event for work thread to process */

/**

 * lpfc_sli4_sp_handle_rel_wcqe - Handle slow-path WQ entry consumed event

 * @phba: Pointer to HBA context object.

 * @wcqe: Pointer to work-queue completion queue entry.

 *

 * This routine handles slow-path WQ entry consumed event by invoking the

 * proper WQ release routine to the slow-path WQ.

 sanity check on queue memory */

 Check for the slow-path ELS work queue */

/**

 * lpfc_sli4_sp_handle_abort_xri_wcqe - Handle a xri abort event

 * @phba: Pointer to HBA context object.

 * @cq: Pointer to a WQ completion queue.

 * @wcqe: Pointer to work-queue completion queue entry.

 *

 * This routine handles an XRI abort event.

 *

 * Return: true if work posted to worker thread, otherwise false.

 Notify aborted XRI for NVME work queue */

 NVME LS uses ELS resources */

 Set the els xri abort event flag */

/**

 * lpfc_sli4_sp_handle_rcqe - Process a receive-queue completion queue entry

 * @phba: Pointer to HBA context object.

 * @rcqe: Pointer to receive-queue completion queue entry.

 *

 * This routine process a receive-queue completion queue entry.

 *

 * Return: true if work posted to worker thread, otherwise false.

 sanity check on queue memory */

 Handle MDS Loopback frames */

 save off the frame for the work thread to process */

 Frame received */

 Post more buffers if possible */

/**

 * lpfc_sli4_sp_handle_cqe - Process a slow path completion queue entry

 * @phba: Pointer to HBA context object.

 * @cq: Pointer to the completion queue.

 * @cqe: Pointer to a completion queue entry.

 *

 * This routine process a slow-path work-queue or receive queue completion queue

 * entry.

 *

 * Return: true if work posted to worker thread, otherwise false.

 Copy the work queue CQE and convert endian order if needed */

 Check and process for different type of WCQE and dispatch */

 Process the WQ/RQ complete event */

 Process the WQ release event */

 Process the WQ XRI abort event */

 Process the RQ event */

/**

 * lpfc_sli4_sp_handle_eqe - Process a slow-path event queue entry

 * @phba: Pointer to HBA context object.

 * @eqe: Pointer to fast-path event queue entry.

 * @speq: Pointer to slow-path event queue.

 *

 * This routine process a event queue entry from the slow-path event queue.

 * It will check the MajorCode and MinorCode to determine this is for a

 * completion event on a completion queue, if not, an error shall be logged

 * and just return. Otherwise, it will get to the corresponding completion

 * queue and process all the entries on that completion queue, rearm the

 * completion queue, and then return.

 *

 Get the reference to the corresponding CQ */

 Save EQ associated with this CQ */

/**

 * __lpfc_sli4_process_cq - Process elements of a CQ

 * @phba: Pointer to HBA context object.

 * @cq: Pointer to CQ to be processed

 * @handler: Routine to process each cqe

 * @delay: Pointer to usdelay to set in case of rescheduling of the handler

 * @poll_mode: Polling mode we were called from

 *

 * This routine processes completion queue entries in a CQ. While a valid

 * queue element is found, the handler is called. During processing checks

 * are made for periodic doorbell writes to let the hardware know of

 * element consumption.

 *

 * If the max limit on cqes to process is hit, or there are no more valid

 * entries, the loop stops. If we processed a sufficient number of elements,

 * meaning there is sufficient load, rather than rearming and generating

 * another interrupt, a cq rescheduling delay will be set. A delay of 0

 * indicates no rescheduling.

 *

 * Returns True if work scheduled, False otherwise.

 default - no reschedule */

 Process all the entries to the CQ */

 Note: complete the irq_poll softirq before rearming CQ */

 Track the max number of CQEs processed in 1 EQ */

 Catch the no cq entry condition */

/**

 * __lpfc_sli4_sp_process_cq - Process a slow-path event queue entry

 * @cq: pointer to CQ to process

 *

 * This routine calls the cq processing routine with a handler specific

 * to the type of queue bound to it.

 *

 * The CQ routine returns two values: the first is the calling status,

 * which indicates whether work was queued to the  background discovery

 * thread. If true, the routine should wakeup the discovery thread;

 * the second is the delay parameter. If non-zero, rather than rearming

 * the CQ and yet another interrupt, the CQ handler should be queued so

 * that it is processed in a subsequent polling action. The value of

 * the delay indicates when to reschedule it.

 Process and rearm the CQ */

 wake up worker thread if there are works to be done */

/**

 * lpfc_sli4_sp_process_cq - slow-path work handler when started by

 *   interrupt

 * @work: pointer to work element

 *

 * translates from the work handler and calls the slow-path handler.

/**

 * lpfc_sli4_dly_sp_process_cq - slow-path work handler when started by timer

 * @work: pointer to work element

 *

 * translates from the work handler and calls the slow-path handler.

/**

 * lpfc_sli4_fp_handle_fcp_wcqe - Process fast-path work queue completion entry

 * @phba: Pointer to HBA context object.

 * @cq: Pointer to associated CQ

 * @wcqe: Pointer to work-queue completion queue entry.

 *

 * This routine process a fast-path work queue completion entry from fast-path

 * event queue for FCP command response completion.

 Check for response status */

		/* If resource errors reported from HBA, reduce queue

		 * depth of the SCSI device.

 Log the cmpl status */

 Look up the FCP command IOCB and create pseudo response IOCB */

 For FCP the flag is cleared in wqe_cmpl */

 Pass the cmd_iocb and the wcqe to the upper layer */

 Only SLI4 non-IO commands stil use IOCB */

 Fake the irspiocb and copy necessary response information */

 Pass the cmd_iocb and the rsp state to the upper layer */

/**

 * lpfc_sli4_fp_handle_rel_wcqe - Handle fast-path WQ entry consumed event

 * @phba: Pointer to HBA context object.

 * @cq: Pointer to completion queue.

 * @wcqe: Pointer to work-queue completion queue entry.

 *

 * This routine handles an fast-path WQ entry consumed event by invoking the

 * proper WQ release routine to the slow-path WQ.

 Check for fast-path FCP work queue release */

 Report warning log message if no match found */

/**

 * lpfc_sli4_nvmet_handle_rcqe - Process a receive-queue completion queue entry

 * @phba: Pointer to HBA context object.

 * @cq: Pointer to completion queue.

 * @rcqe: Pointer to receive-queue completion queue entry.

 *

 * This routine process a receive-queue completion queue entry.

 *

 * Return: true if work posted to worker thread, otherwise false.

 sanity check on queue memory */

 Just some basic sanity checks on FCP Command frame */

 0 byte swapped is still 0 */

 Post more buffers if possible */

/**

 * lpfc_sli4_fp_handle_cqe - Process fast-path work queue completion entry

 * @phba: adapter with cq

 * @cq: Pointer to the completion queue.

 * @cqe: Pointer to fast-path completion queue entry.

 *

 * This routine process a fast-path work queue completion entry from fast-path

 * event queue for FCP command response completion.

 *

 * Return: true if work posted to worker thread, otherwise false.

 Copy the work queue CQE and convert endian order if needed */

 Check and process for different type of WCQE and dispatch */

 Process the WQ complete event */

 Process the WQ release event */

 Process the WQ XRI abort event */

/**

 * lpfc_sli4_sched_cq_work - Schedules cq work

 * @phba: Pointer to HBA context object.

 * @cq: Pointer to CQ

 * @cqid: CQ ID

 *

 * This routine checks the poll mode of the CQ corresponding to

 * cq->chann, then either schedules a softirq or queue_work to complete

 * cq work.

 *

 * queue_work path is taken if in NVMET mode, or if poll_mode is in

 * LPFC_QUEUE_WORK mode.  Otherwise, softirq path is taken.

 *

 CGN mgmt is mutually exclusive from softirq processing */

/**

 * lpfc_sli4_hba_handle_eqe - Process a fast-path event queue entry

 * @phba: Pointer to HBA context object.

 * @eq: Pointer to the queue structure.

 * @eqe: Pointer to fast-path event queue entry.

 *

 * This routine process a event queue entry from the fast-path event queue.

 * It will check the MajorCode and MinorCode to determine this is for a

 * completion event on a completion queue, if not, an error shall be logged

 * and just return. Otherwise, it will get to the corresponding completion

 * queue and process all the entries on the completion queue, rearm the

 * completion queue, and then return.

 Get the reference to the corresponding CQ */

 Use the fast lookup method first */

 Next check for NVMET completion */

 Process NVMET unsol rcv */

 Process NVME unsol rcv */

 Otherwise this is a Slow path event */

/**

 * __lpfc_sli4_hba_process_cq - Process a fast-path event queue entry

 * @cq: Pointer to CQ to be processed

 * @poll_mode: Enum lpfc_poll_state to determine poll mode

 *

 * This routine calls the cq processing routine with the handler for

 * fast path CQEs.

 *

 * The CQ routine returns two values: the first is the calling status,

 * which indicates whether work was queued to the  background discovery

 * thread. If true, the routine should wakeup the discovery thread;

 * the second is the delay parameter. If non-zero, rather than rearming

 * the CQ and yet another interrupt, the CQ handler should be queued so

 * that it is processed in a subsequent polling action. The value of

 * the delay indicates when to reschedule it.

 process and rearm the CQ */

 wake up worker thread if there are works to be done */

/**

 * lpfc_sli4_hba_process_cq - fast-path work handler when started by

 *   interrupt

 * @work: pointer to work element

 *

 * translates from the work handler and calls the fast-path handler.

/**

 * lpfc_sli4_dly_hba_process_cq - fast-path work handler when started by timer

 * @work: pointer to work element

 *

 * translates from the work handler and calls the fast-path handler.

/**

 * lpfc_sli4_hba_intr_handler - HBA interrupt handler to SLI-4 device

 * @irq: Interrupt number.

 * @dev_id: The device context pointer.

 *

 * This function is directly called from the PCI layer as an interrupt

 * service routine when device with SLI-4 interface spec is enabled with

 * MSI-X multi-message interrupt mode and there is a fast-path FCP IOCB

 * ring event in the HBA. However, when the device is enabled with either

 * MSI or Pin-IRQ interrupt mode, this function is called as part of the

 * device-level interrupt handler. When the PCI slot is in error recovery

 * or the HBA is undergoing initialization, the interrupt handler will not

 * process the interrupt. The SCSI FCP fast-path ring event are handled in

 * the intrrupt context. This function is called without any lock held.

 * It gets the hbalock to access and update SLI data structures. Note that,

 * the FCP EQ to FCP CQ are one-to-one map such that the FCP EQ index is

 * equal to that of FCP CQ index.

 *

 * The link attention and ELS ring attention events are handled

 * by the worker thread. The interrupt handler signals the worker thread

 * and returns for these events. This function is called without any lock

 * held. It gets the hbalock to access and update SLI data structures.

 *

 * This function returns IRQ_HANDLED when interrupt is handled else it

 * returns IRQ_NONE.

 Get the driver's phba structure from the dev_id */

 Get to the EQ struct associated with this vector */

 Check device state for handling interrupt */

 Check again for link_state with lock held */

 Flush, clear interrupt, and rearm the EQ */

 process and rearm the EQ */

 MSI-X treated interrupt served as no EQ share INT */

 Non MSI-X treated on interrupt as EQ share INT */

 lpfc_sli4_hba_intr_handler */

/**

 * lpfc_sli4_intr_handler - Device-level interrupt handler for SLI-4 device

 * @irq: Interrupt number.

 * @dev_id: The device context pointer.

 *

 * This function is the device-level interrupt handler to device with SLI-4

 * interface spec, called from the PCI layer when either MSI or Pin-IRQ

 * interrupt mode is enabled and there is an event in the HBA which requires

 * driver attention. This function invokes the slow-path interrupt attention

 * handling function and fast-path interrupt attention handling function in

 * turn to process the relevant HBA attention events. This function is called

 * without any lock held. It gets the hbalock to access and update SLI data

 * structures.

 *

 * This function returns IRQ_HANDLED when interrupt is handled, else it

 * returns IRQ_NONE.

 Get the driver's phba structure from the dev_id */

	/*

	 * Invoke fast-path host attention interrupt handling as appropriate.

 lpfc_sli4_intr_handler */

	/*

	 * Unlocking an irq is one of the entry point to check

	 * for re-schedule, but we are good for io submission

	 * path as midlayer does a get_cpu to glue us in. Flush

	 * out the invalidate queue so we can see the updated

	 * value for flag.

		/* We will not likely get the completion for the caller

		 * during this iteration but i guess that's fine.

		 * Future io's coming on this eq should be able to

		 * pick it up.  As for the case of single io's, they

		 * will be handled through a sched from polling timer

		 * function which is currently triggered every 1msec.

 kickstart slowpath processing if needed */

	/* Disable slowpath processing for this eq.  Kick start the eq

	 * by RE-ARMING the eq's ASAP

	/*

	 * currently this function is only called during a hotplug

	 * event and the cpu on which this function is executing

	 * is going offline.  By now the hotplug has instructed

	 * the scheduler to remove this cpu from cpu active mask.

	 * So we don't need to work about being put aside by the

	 * scheduler for a high priority process.  Yes, the inte-

	 * rrupts could come but they are known to retire ASAP.

 Disable polling in the fastpath */

 flush out the store buffer */

	/*

	 * Add this eq to the polling list and start polling. For

	 * a grace period both interrupt handler and poller will

	 * try to process the eq _but_ that's fine.  We have a

	 * synchronization mechanism in place (queue_claimed) to

	 * deal with it.  This is just a draining phase for int-

	 * errupt handler (not eq's) as we have guranteed through

	 * barrier that all the CPUs have seen the new CQ_POLLED

	 * state. which will effectively disable the REARMING of

	 * the EQ.  The whole idea is eq's die off eventually as

	 * we are not rearming EQ's anymore.

	/* Kick start for the pending io's in h/w.

	 * Once we switch back to interrupt processing on a eq

	 * the io path completion will only arm eq's when it

	 * receives a completion.  But since eq's are in disa-

	 * rmed state it doesn't receive a completion.  This

	 * creates a deadlock scenaro.

/**

 * lpfc_sli4_queue_free - free a queue structure and associated memory

 * @queue: The queue structure to free.

 *

 * This function frees a queue structure and the DMAable memory used for

 * the host resident queue. This function must be called after destroying the

 * queue on the HBA.

/**

 * lpfc_sli4_queue_alloc - Allocate and initialize a queue structure

 * @phba: The HBA that this queue is being created on.

 * @page_size: The size of a queue page

 * @entry_size: The size of each queue entry for this queue.

 * @entry_count: The number of entries that this queue will handle.

 * @cpu: The cpu that will primarily utilize this queue.

 *

 * This function allocates a queue structure and the DMAable memory used for

 * the host resident queue. This function must be called before creating the

 * queue on the HBA.

 If needed, Adjust page count to match the max the adapter supports */

	/* Set queue parameters now.  If the system cannot provide memory

	 * resources, the free routine needs to know what was allocated.

 use lpfc_sli4_qe to index a paritcular entry in this page */

 notify_interval will be set during q creation */

/**

 * lpfc_dual_chute_pci_bar_map - Map pci base address register to host memory

 * @phba: HBA structure that indicates port to create a queue on.

 * @pci_barset: PCI BAR set flag.

 *

 * This function shall perform iomap of the specified PCI BAR address to host

 * memory address if not already done so and return it. The returned host

 * memory address can be NULL.

/**

 * lpfc_modify_hba_eq_delay - Modify Delay Multiplier on EQs

 * @phba: HBA structure that EQs are on.

 * @startq: The starting EQ index to modify

 * @numq: The number of EQs (consecutive indexes) to modify

 * @usdelay: amount of delay

 *

 * This function revises the EQ delay on 1 or more EQs. The EQ delay

 * is set either by writing to a register (if supported by the SLI Port)

 * or by mailbox command. The mailbox command allows several EQs to be

 * updated at once.

 *

 * The @phba struct is used to send a mailbox command to HBA. The @startq

 * is used to get the starting EQ index to change. The @numq value is

 * used to specify how many consecutive EQ indexes, starting at EQ index,

 * are to be changed. This function is asynchronous and will wait for any

 * mailbox commands to finish before returning.

 *

 * On success this function will return a zero. If unable to allocate

 * enough memory this function will return -ENOMEM. If a mailbox command

 * fails this function will return -ENXIO. Note: on ENXIO, some EQs may

 * have had their delay multipler changed.

 set values by EQ_DELAY register if supported */

 Otherwise, set values by mailbox cmd */

 Calculate delay multiper from maximum interrupt per second */

/**

 * lpfc_eq_create - Create an Event Queue on the HBA

 * @phba: HBA structure that indicates port to create a queue on.

 * @eq: The queue structure to use to create the event queue.

 * @imax: The maximum interrupt per second limit.

 *

 * This function creates an event queue, as detailed in @eq, on a port,

 * described by @phba by sending an EQ_CREATE mailbox command to the HBA.

 *

 * The @phba struct is used to send mailbox command to HBA. The @eq struct

 * is used to get the entry count and entry size that are necessary to

 * determine the number of pages to allocate and use for this queue. This

 * function will send the EQ_CREATE mailbox command to the HBA to setup the

 * event queue. This function is asynchronous and will wait for the mailbox

 * command to finish before continuing.

 *

 * On success this function will return a zero. If unable to allocate enough

 * memory this function will return -ENOMEM. If the queue create mailbox command

 * fails this function will return -ENXIO.

 sanity check on queue memory */

 Use version 2 of CREATE_EQ if eqav is set */

 don't setup delay multiplier using EQ_CREATE */

 otherwise default to smallest count */

/**

 * lpfc_cq_create - Create a Completion Queue on the HBA

 * @phba: HBA structure that indicates port to create a queue on.

 * @cq: The queue structure to use to create the completion queue.

 * @eq: The event queue to bind this completion queue to.

 * @type: Type of queue (EQ, GCQ, MCQ, WCQ, etc).

 * @subtype: Functional purpose of the queue (MBOX, IO, ELS, NVMET, etc).

 *

 * This function creates a completion queue, as detailed in @wq, on a port,

 * described by @phba by sending a CQ_CREATE mailbox command to the HBA.

 *

 * The @phba struct is used to send mailbox command to HBA. The @cq struct

 * is used to get the entry count and entry size that are necessary to

 * determine the number of pages to allocate and use for this queue. The @eq

 * is used to indicate which event queue to bind this completion queue to. This

 * function will send the CQ_CREATE mailbox command to the HBA to setup the

 * completion queue. This function is asynchronous and will wait for the mailbox

 * command to finish before continuing.

 *

 * On success this function will return a zero. If unable to allocate enough

 * memory this function will return -ENOMEM. If the queue create mailbox command

 * fails this function will return -ENXIO.

 sanity check on queue memory */

 otherwise default to smallest count */

 The IOCTL status is embedded in the mailbox subheader. */

 link the cq onto the parent eq child list */

 Set up completion queue's type and subtype */

/**

 * lpfc_cq_create_set - Create a set of Completion Queues on the HBA for MRQ

 * @phba: HBA structure that indicates port to create a queue on.

 * @cqp: The queue structure array to use to create the completion queues.

 * @hdwq: The hardware queue array  with the EQ to bind completion queues to.

 * @type: Type of queue (EQ, GCQ, MCQ, WCQ, etc).

 * @subtype: Functional purpose of the queue (MBOX, IO, ELS, NVMET, etc).

 *

 * This function creates a set of  completion queue, s to support MRQ

 * as detailed in @cqp, on a port,

 * described by @phba by sending a CREATE_CQ_SET mailbox command to the HBA.

 *

 * The @phba struct is used to send mailbox command to HBA. The @cq struct

 * is used to get the entry count and entry size that are necessary to

 * determine the number of pages to allocate and use for this queue. The @eq

 * is used to indicate which event queue to bind this completion queue to. This

 * function will send the CREATE_CQ_SET mailbox command to the HBA to setup the

 * completion queue. This function is asynchronous and will wait for the mailbox

 * command to finish before continuing.

 *

 * On success this function will return a zero. If unable to allocate enough

 * memory this function will return -ENOMEM. If the queue create mailbox command

 * fails this function will return -ENXIO.

 sanity check on queue memory */

 otherwise default to smallest */

 link the cq onto the parent eq child list */

 Set up completion queue's type and subtype */

 The IOCTL status is embedded in the mailbox subheader. */

/**

 * lpfc_mq_create_fb_init - Send MCC_CREATE without async events registration

 * @phba: HBA structure that indicates port to create a queue on.

 * @mq: The queue structure to use to create the mailbox queue.

 * @mbox: An allocated pointer to type LPFC_MBOXQ_t

 * @cq: The completion queue to associate with this cq.

 *

 * This function provides failback (fb) functionality when the

 * mq_create_ext fails on older FW generations.  It's purpose is identical

 * to mq_create_ext otherwise.

 *

 * This routine cannot fail as all attributes were previously accessed and

 * initialized in mq_create_ext.

/**

 * lpfc_mq_create - Create a mailbox Queue on the HBA

 * @phba: HBA structure that indicates port to create a queue on.

 * @mq: The queue structure to use to create the mailbox queue.

 * @cq: The completion queue to associate with this cq.

 * @subtype: The queue's subtype.

 *

 * This function creates a mailbox queue, as detailed in @mq, on a port,

 * described by @phba by sending a MQ_CREATE mailbox command to the HBA.

 *

 * The @phba struct is used to send mailbox command to HBA. The @cq struct

 * is used to get the entry count and entry size that are necessary to

 * determine the number of pages to allocate and use for this queue. This

 * function will send the MQ_CREATE mailbox command to the HBA to setup the

 * mailbox queue. This function is asynchronous and will wait for the mailbox

 * command to finish before continuing.

 *

 * On success this function will return a zero. If unable to allocate enough

 * memory this function will return -ENOMEM. If the queue create mailbox command

 * fails this function will return -ENXIO.

 sanity check on queue memory */

 otherwise default to smallest count */

 The IOCTL status is embedded in the mailbox subheader. */

 link the mq onto the parent cq child list */

/**

 * lpfc_wq_create - Create a Work Queue on the HBA

 * @phba: HBA structure that indicates port to create a queue on.

 * @wq: The queue structure to use to create the work queue.

 * @cq: The completion queue to bind this work queue to.

 * @subtype: The subtype of the work queue indicating its functionality.

 *

 * This function creates a work queue, as detailed in @wq, on a port, described

 * by @phba by sending a WQ_CREATE mailbox command to the HBA.

 *

 * The @phba struct is used to send mailbox command to HBA. The @wq struct

 * is used to get the entry count and entry size that are necessary to

 * determine the number of pages to allocate and use for this queue. The @cq

 * is used to indicate which completion queue to bind this work queue to. This

 * function will send the WQ_CREATE mailbox command to the HBA to setup the

 * work queue. This function is asynchronous and will wait for the mailbox

 * command to finish before continuing.

 *

 * On success this function will return a zero. If unable to allocate enough

 * memory this function will return -ENOMEM. If the queue create mailbox command

 * fails this function will return -ENXIO.

 sanity check on queue memory */

 wqv is the earliest version supported, NOT the latest */

 Request DPP by default */

 The IOCTL status is embedded in the mailbox subheader. */

 Check if DPP was honored by the firmware */

 Enable combined writes for DPP aperture */

 link the wq onto the parent cq child list */

/**

 * lpfc_rq_create - Create a Receive Queue on the HBA

 * @phba: HBA structure that indicates port to create a queue on.

 * @hrq: The queue structure to use to create the header receive queue.

 * @drq: The queue structure to use to create the data receive queue.

 * @cq: The completion queue to bind this work queue to.

 * @subtype: The subtype of the work queue indicating its functionality.

 *

 * This function creates a receive buffer queue pair , as detailed in @hrq and

 * @drq, on a port, described by @phba by sending a RQ_CREATE mailbox command

 * to the HBA.

 *

 * The @phba struct is used to send mailbox command to HBA. The @drq and @hrq

 * struct is used to get the entry count that is necessary to determine the

 * number of pages to use for this queue. The @cq is used to indicate which

 * completion queue to bind received buffers that are posted to these queues to.

 * This function will send the RQ_CREATE mailbox command to the HBA to setup the

 * receive queue pair. This function is asynchronous and will wait for the

 * mailbox command to finish before continuing.

 *

 * On success this function will return a zero. If unable to allocate enough

 * memory this function will return -ENOMEM. If the queue create mailbox command

 * fails this function will return -ENXIO.

 sanity check on queue memory */

 otherwise default to smallest count */

 The IOCTL status is embedded in the mailbox subheader. */

 now create the data queue */

 otherwise default to smallest count */

 The IOCTL status is embedded in the mailbox subheader. */

 link the header and data RQs onto the parent cq child list */

/**

 * lpfc_mrq_create - Create MRQ Receive Queues on the HBA

 * @phba: HBA structure that indicates port to create a queue on.

 * @hrqp: The queue structure array to use to create the header receive queues.

 * @drqp: The queue structure array to use to create the data receive queues.

 * @cqp: The completion queue array to bind these receive queues to.

 * @subtype: Functional purpose of the queue (MBOX, IO, ELS, NVMET, etc).

 *

 * This function creates a receive buffer queue pair , as detailed in @hrq and

 * @drq, on a port, described by @phba by sending a RQ_CREATE mailbox command

 * to the HBA.

 *

 * The @phba struct is used to send mailbox command to HBA. The @drq and @hrq

 * struct is used to get the entry count that is necessary to determine the

 * number of pages to use for this queue. The @cq is used to indicate which

 * completion queue to bind received buffers that are posted to these queues to.

 * This function will send the RQ_CREATE mailbox command to the HBA to setup the

 * receive queue pair. This function is asynchronous and will wait for the

 * mailbox command to finish before continuing.

 *

 * On success this function will return a zero. If unable to allocate enough

 * memory this function will return -ENOMEM. If the queue create mailbox command

 * fails this function will return -ENXIO.

 sanity check on array memory */

 sanity check on queue memory */

 The IOCTL status is embedded in the mailbox subheader. */

 Initialize all RQs with associated queue id */

/**

 * lpfc_eq_destroy - Destroy an event Queue on the HBA

 * @phba: HBA structure that indicates port to destroy a queue on.

 * @eq: The queue structure associated with the queue to destroy.

 *

 * This function destroys a queue, as detailed in @eq by sending an mailbox

 * command, specific to the type of queue, to the HBA.

 *

 * The @eq struct is used to get the queue ID of the queue to destroy.

 *

 * On success this function will return a zero. If the queue destroy mailbox

 * command fails this function will return -ENXIO.

 sanity check on queue memory */

 The IOCTL status is embedded in the mailbox subheader. */

 Remove eq from any list */

/**

 * lpfc_cq_destroy - Destroy a Completion Queue on the HBA

 * @phba: HBA structure that indicates port to destroy a queue on.

 * @cq: The queue structure associated with the queue to destroy.

 *

 * This function destroys a queue, as detailed in @cq by sending an mailbox

 * command, specific to the type of queue, to the HBA.

 *

 * The @cq struct is used to get the queue ID of the queue to destroy.

 *

 * On success this function will return a zero. If the queue destroy mailbox

 * command fails this function will return -ENXIO.

 sanity check on queue memory */

 The IOCTL status is embedded in the mailbox subheader. */

 Remove cq from any list */

/**

 * lpfc_mq_destroy - Destroy a Mailbox Queue on the HBA

 * @phba: HBA structure that indicates port to destroy a queue on.

 * @mq: The queue structure associated with the queue to destroy.

 *

 * This function destroys a queue, as detailed in @mq by sending an mailbox

 * command, specific to the type of queue, to the HBA.

 *

 * The @mq struct is used to get the queue ID of the queue to destroy.

 *

 * On success this function will return a zero. If the queue destroy mailbox

 * command fails this function will return -ENXIO.

 sanity check on queue memory */

 The IOCTL status is embedded in the mailbox subheader. */

 Remove mq from any list */

/**

 * lpfc_wq_destroy - Destroy a Work Queue on the HBA

 * @phba: HBA structure that indicates port to destroy a queue on.

 * @wq: The queue structure associated with the queue to destroy.

 *

 * This function destroys a queue, as detailed in @wq by sending an mailbox

 * command, specific to the type of queue, to the HBA.

 *

 * The @wq struct is used to get the queue ID of the queue to destroy.

 *

 * On success this function will return a zero. If the queue destroy mailbox

 * command fails this function will return -ENXIO.

 sanity check on queue memory */

 Remove wq from any list */

/**

 * lpfc_rq_destroy - Destroy a Receive Queue on the HBA

 * @phba: HBA structure that indicates port to destroy a queue on.

 * @hrq: The queue structure associated with the queue to destroy.

 * @drq: The queue structure associated with the queue to destroy.

 *

 * This function destroys a queue, as detailed in @rq by sending an mailbox

 * command, specific to the type of queue, to the HBA.

 *

 * The @rq struct is used to get the queue ID of the queue to destroy.

 *

 * On success this function will return a zero. If the queue destroy mailbox

 * command fails this function will return -ENXIO.

 sanity check on queue memory */

 The IOCTL status is embedded in the mailbox subheader. */

/**

 * lpfc_sli4_post_sgl - Post scatter gather list for an XRI to HBA

 * @phba: The virtual port for which this call being executed.

 * @pdma_phys_addr0: Physical address of the 1st SGL page.

 * @pdma_phys_addr1: Physical address of the 2nd SGL page.

 * @xritag: the xritag that ties this io to the SGL pages.

 *

 * This routine will post the sgl pages for the IO that has the xritag

 * that is in the iocbq structure. The xritag is assigned during iocbq

 * creation and persists for as long as the driver is loaded.

 * if the caller has fewer than 256 scatter gather segments to map then

 * pdma_phys_addr1 should be 0.

 * If the caller needs to map more than 256 scatter gather segment then

 * pdma_phys_addr1 should be a valid physical address.

 * physical address for SGLs must be 64 byte aligned.

 * If you are going to map 2 SGL's then the first one must have 256 entries

 * the second sgl can have between 1 and 256 entries.

 *

 * Return codes:

 * 	0 - Success

 * 	-ENXIO, -ENOMEM - Failure

 The IOCTL status is embedded in the mailbox subheader. */

/**

 * lpfc_sli4_alloc_xri - Get an available rpi in the device's range

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to post rpi header templates to the

 * HBA consistent with the SLI-4 interface spec.  This routine

 * posts a SLI4_PAGE_SIZE memory region to the port to hold up to

 * SLI4_PAGE_SIZE modulo 64 rpi context headers.

 *

 * Returns

 *	A nonzero rpi defined as rpi_base <= rpi < max_rpi if successful

 *	LPFC_RPI_ALLOC_ERROR if no rpis are available.

	/*

	 * Fetch the next logical xri.  Because this index is logical,

	 * the driver starts at 0 each time.

/**

 * __lpfc_sli4_free_xri - Release an xri for reuse.

 * @phba: pointer to lpfc hba data structure.

 * @xri: xri to release.

 *

 * This routine is invoked to release an xri to the pool of

 * available rpis maintained by the driver.

/**

 * lpfc_sli4_free_xri - Release an xri for reuse.

 * @phba: pointer to lpfc hba data structure.

 * @xri: xri to release.

 *

 * This routine is invoked to release an xri to the pool of

 * available rpis maintained by the driver.

/**

 * lpfc_sli4_next_xritag - Get an xritag for the io

 * @phba: Pointer to HBA context object.

 *

 * This function gets an xritag for the iocb. If there is no unused xritag

 * it will return 0xffff.

 * The function returns the allocated xritag if successful, else returns zero.

 * Zero is not a valid xritag.

 * The caller is not required to hold any lock.

/**

 * lpfc_sli4_post_sgl_list - post a block of ELS sgls to the port.

 * @phba: pointer to lpfc hba data structure.

 * @post_sgl_list: pointer to els sgl entry list.

 * @post_cnt: number of els sgl entries on the list.

 *

 * This routine is invoked to post a block of driver's sgl pages to the

 * HBA using non-embedded mailbox command. No Lock is held. This routine

 * is only called when the driver is loading and after all IO has been

 * stopped.

 Allocate DMA memory and set up the non-embedded mailbox command */

 Set up the SGL pages in the non-embedded DMA pages */

 Set up the sge entry */

 Keep the first xritag on the list */

 Complete initialization and perform endian conversion. */

/**

 * lpfc_sli4_post_io_sgl_block - post a block of nvme sgl list to firmware

 * @phba: pointer to lpfc hba data structure.

 * @nblist: pointer to nvme buffer list.

 * @count: number of scsi buffers on the list.

 *

 * This routine is invoked to post a block of @count scsi sgl pages from a

 * SCSI buffer list @nblist to the HBA using non-embedded mailbox command.

 * No Lock is held.

 *

 Calculate the requested length of the dma memory */

 Allocate DMA memory and set up the non-embedded mailbox command */

 Get the first SGE entry from the non-embedded DMA memory */

 Set up the SGL pages in the non-embedded DMA pages */

 Set up the sge entry */

 Keep the first xritag on the list */

 Perform endian conversion if necessary */

/**

 * lpfc_sli4_post_io_sgl_list - Post blocks of nvme buffer sgls from a list

 * @phba: pointer to lpfc hba data structure.

 * @post_nblist: pointer to the nvme buffer list.

 * @sb_count: number of nvme buffers.

 *

 * This routine walks a list of nvme buffers that was passed in. It attempts

 * to construct blocks of nvme buffer sgls which contains contiguous xris and

 * uses the non-embedded SGL block post mailbox commands to post to the port.

 * For single NVME buffer sgl with non-contiguous xri, if any, it shall use

 * embedded SGL post mailbox command for posting. The @post_nblist passed in

 * must be local list, thus no lock is needed when manipulate the list.

 *

 * Returns: 0 = failure, non-zero number of successfully posted buffers.

 sanity check */

 a hole in xri block, form a sgl posting block */

 prepare list for next posting block */

 prepare list for next posting block */

 enough sgls for non-embed sgl mbox command */

 end of repost sgl list condition for NVME buffers */

 last sgl posting block */

 last single sgl with non-contiguous xri */

 Post error.  Buffer unavailable. */

 Post success. Bffer available. */

 success, put on NVME buffer sgl list */

 continue until a nembed page worth of sgls */

 post block of NVME buffer list sgls */

 don't reset xirtag due to hole in xri block */

 reset NVME buffer post count for next round of posting */

 put posted NVME buffer-sgl posted on NVME buffer sgl list */

 Post error.  Mark buffer unavailable. */

 Post success, Mark buffer available. */

 Push NVME buffers with sgl posted to the available list */

/**

 * lpfc_fc_frame_check - Check that this frame is a valid frame to handle

 * @phba: pointer to lpfc_hba struct that the frame was received on

 * @fc_hdr: A pointer to the FC Header data (In Big Endian Format)

 *

 * This function checks the fields in the @fc_hdr to see if the FC frame is a

 * valid type of frame that the LPFC driver will handle. This function will

 * return a zero if the frame is a valid frame or a non zero value when the

 * frame does not pass the check.

  make rctl_names static to save stack space */

 uncategorized information */

 solicited data */

 unsolicited control */

 solicited control or reply */

 unsolicited data */

 data descriptor */

 unsolicited command */

 command status */

 extended link services request */

 extended link services reply */

 FC-4 ELS request */

 FC-4 ELS reply */

 basic link service NOP */

 basic link service abort */

 remove connection */

 basic accept */

 basic reject */

 acknowledge_1 */

 acknowledge_0 */

 port reject */

 fabric reject */

 port busy */

 fabric busy to data frame */

 fabric busy to link control frame */

 link credit reset */

 MDS Diagnostics */

 end */

 Virtual Fabric tagging Header */

/**

 * lpfc_fc_hdr_get_vfi - Get the VFI from an FC frame

 * @fc_hdr: A pointer to the FC Header data (In Big Endian Format)

 *

 * This function processes the FC header to retrieve the VFI from the VF

 * header, if one exists. This function will return the VFI if one exists

 * or 0 if no VSAN Header exists.

/**

 * lpfc_fc_frame_to_vport - Finds the vport that a frame is destined to

 * @phba: Pointer to the HBA structure to search for the vport on

 * @fc_hdr: A pointer to the FC Header data (In Big Endian Format)

 * @fcfi: The FC Fabric ID that the frame came from

 * @did: Destination ID to match against

 *

 * This function searches the @phba for a vport that matches the content of the

 * @fc_hdr passed in and the @fcfi. This function uses the @fc_hdr to fetch the

 * VFI, if the Virtual Fabric Tagging Header exists, and the DID. This function

 * returns the matching vport pointer or NULL if unable to match frame to a

 * vport.

/**

 * lpfc_update_rcv_time_stamp - Update vport's rcv seq time stamp

 * @vport: The vport to work on.

 *

 * This function updates the receive sequence time stamp for this vport. The

 * receive sequence time stamp indicates the time that the last frame of the

 * the sequence that has been idle for the longest amount of time was received.

 * the driver uses this time stamp to indicate if any received sequences have

 * timed out.

 get the oldest sequence on the rcv list */

/**

 * lpfc_cleanup_rcv_buffers - Cleans up all outstanding receive sequences.

 * @vport: The vport that the received sequences were sent to.

 *

 * This function cleans up all outstanding received sequences. This is called

 * by the driver when a link event or user action invalidates all the received

 * sequences.

 start with the oldest sequence on the rcv list */

/**

 * lpfc_rcv_seq_check_edtov - Cleans up timed out receive sequences.

 * @vport: The vport that the received sequences were sent to.

 *

 * This function determines whether any received sequences have timed out by

 * first checking the vport's rcv_buffer_time_stamp. If this time_stamp

 * indicates that there is at least one timed out sequence this routine will

 * go through the received sequences one at a time from most inactive to most

 * active to determine which ones need to be cleaned up. Once it has determined

 * that a sequence needs to be cleaned up it will simply free up the resources

 * without sending an abort.

 start with the oldest sequence on the rcv list */

/**

 * lpfc_fc_frame_add - Adds a frame to the vport's list of received sequences

 * @vport: pointer to a vitural port

 * @dmabuf: pointer to a dmabuf that describes the hdr and data of the FC frame

 *

 * This function searches through the existing incomplete sequences that have

 * been sent to this @vport. If the frame matches one of the incomplete

 * sequences then the dbuf in the @dmabuf is added to the list of frames that

 * make up that sequence. If no sequence is found that matches this frame then

 * the function will add the hbuf in the @dmabuf to the @vport's rcv_buffer_list

 * This function returns a pointer to the first dmabuf in the sequence list that

 * the frame was linked to.

 Use the hdr_buf to find the sequence that this frame belongs to */

 found a pending sequence that matches this frame */

		/*

		 * This indicates first frame received for this sequence.

		 * Queue the buffer on the vport's rcv_buffer_list.

 move this sequence to the tail to indicate a young sequence */

 find the correct place in the sequence to insert this frame */

		/*

		 * If the frame's sequence count is greater than the frame on

		 * the list then insert the frame right after this frame

/**

 * lpfc_sli4_abort_partial_seq - Abort partially assembled unsol sequence

 * @vport: pointer to a vitural port

 * @dmabuf: pointer to a dmabuf that describes the FC sequence

 *

 * This function tries to abort from the partially assembed sequence, described

 * by the information from basic abbort @dmabuf. It checks to see whether such

 * partially assembled sequence held by the driver. If so, it shall free up all

 * the frames from the partially assembled sequence.

 *

 * Return

 * true  -- if there is matching partially assembled sequence present and all

 *          the frames freed with the sequence;

 * false -- if there is no matching partially assembled sequence present so

 *          nothing got aborted in the lower layer driver

 Use the hdr_buf to find the sequence that matches this frame */

 found a pending sequence that matches this frame */

 Free up all the frames from the partially assembled sequence */

/**

 * lpfc_sli4_abort_ulp_seq - Abort assembled unsol sequence from ulp

 * @vport: pointer to a vitural port

 * @dmabuf: pointer to a dmabuf that describes the FC sequence

 *

 * This function tries to abort from the assembed sequence from upper level

 * protocol, described by the information from basic abbort @dmabuf. It

 * checks to see whether such pending context exists at upper level protocol.

 * If so, it shall clean up the pending context.

 *

 * Return

 * true  -- if there is matching pending context of the sequence cleaned

 *          at ulp;

 * false -- if there is no matching pending context of the sequence present

 *          at ulp.

 Accepting abort at ulp with SLI4 only */

 Register all caring upper level protocols to attend abort */

/**

 * lpfc_sli4_seq_abort_rsp_cmpl - BLS ABORT RSP seq abort iocb complete handler

 * @phba: Pointer to HBA context object.

 * @cmd_iocbq: pointer to the command iocbq structure.

 * @rsp_iocbq: pointer to the response iocbq structure.

 *

 * This function handles the sequence abort response iocb command complete

 * event. It properly releases the memory allocated to the sequence abort

 * accept iocb.

 Failure means BLS ABORT RSP did not get delivered to remote node*/

/**

 * lpfc_sli4_xri_inrange - check xri is in range of xris owned by driver.

 * @phba: Pointer to HBA context object.

 * @xri: xri id in transaction.

 *

 * This function validates the xri maps to the known range of XRIs allocated an

 * used by the driver.

/**

 * lpfc_sli4_seq_abort_rsp - bls rsp to sequence abort

 * @vport: pointer to a virtual port.

 * @fc_hdr: pointer to a FC frame header.

 * @aborted: was the partially assembled receive sequence successfully aborted

 *

 * This function sends a basic response to a previous unsol sequence abort

 * event after aborting the sequence handling.

 Put ndlp onto pport node list */

 Allocate buffer for rsp iocb */

 Extract the F_CTL field from FC_HDR */

 Fill in the rest of iocb fields */

		/* Exchange responder sent the abort so we

		 * own the oxid.

	/* For BA_ABTS from exchange responder, if the logical xri with

	 * the oxid maps to the FCP XRI range, the port no longer has

	 * that exchange context, send a BLS_RJT. Override the IOCB for

	 * a BA_RJT.

	/* If BA_ABTS failed to abort a partially assembled receive sequence,

	 * the driver no longer has that exchange, send a BLS_RJT. Override

	 * the IOCB for a BA_RJT.

		/* ABTS sent by responder to CT exchange, construction

		 * of BA_ACC will use OX_ID from ABTS for the XRI_TAG

		 * field and RX_ID from ABTS for RX_ID field.

		/* ABTS sent by initiator to CT exchange, construction

		 * of BA_ACC will need to allocate a new XRI as for the

		 * XRI_TAG field.

 Xmit CT abts response on exchange <xid> */

/**

 * lpfc_sli4_handle_unsol_abort - Handle sli-4 unsolicited abort event

 * @vport: Pointer to the vport on which this sequence was received

 * @dmabuf: pointer to a dmabuf that describes the FC sequence

 *

 * This function handles an SLI-4 unsolicited abort event. If the unsolicited

 * receive sequence is only partially assembed by the driver, it shall abort

 * the partially assembled frames for the sequence. Otherwise, if the

 * unsolicited receive sequence has been completely assembled and passed to

 * the Upper Layer Protocol (ULP), it then mark the per oxid status for the

 * unsolicited sequence has been aborted. After that, it will issue a basic

 * accept to accept the abort.

 Make a copy of fc_hdr before the dmabuf being released */

 ABTS by responder to exchange, no cleanup needed */

 ABTS by initiator to exchange, need to do cleanup */

 Respond with BA_ACC or BA_RJT accordingly */

/**

 * lpfc_seq_complete - Indicates if a sequence is complete

 * @dmabuf: pointer to a dmabuf that describes the FC sequence

 *

 * This function checks the sequence, starting with the frame described by

 * @dmabuf, to see if all the frames associated with this sequence are present.

 * the frames associated with this sequence are linked to the @dmabuf using the

 * dbuf list. This function looks for two major things. 1) That the first frame

 * has a sequence count of zero. 2) There is a frame with last frame of sequence

 * set. 3) That there are no holes in the sequence count. The function will

 * return 1 when the sequence is complete, otherwise it will return 0.

 make sure first fame of sequence has a sequence count of zero */

 If last frame of sequence we can return success. */

 If there is a hole in the sequence count then fail. */

 If last frame of sequence we can return success. */

/**

 * lpfc_prep_seq - Prep sequence for ULP processing

 * @vport: Pointer to the vport on which this sequence was received

 * @seq_dmabuf: pointer to a dmabuf that describes the FC sequence

 *

 * This function takes a sequence, described by a list of frames, and creates

 * a list of iocbq structures to describe the sequence. This iocbq list will be

 * used to issue to the generic unsolicited sequence handler. This routine

 * returns a pointer to the first iocbq in the list. If the function is unable

 * to allocate an iocbq then it throw out the received frames that were not

 * able to be described and return a pointer to the first iocbq. If unable to

 * allocate any iocbqs (including the first) this function will return NULL.

 remove from receive buffer list */

 get the Remote Port's SID */

 Get an iocbq struct to fill in. */

 Initialize the first IOCB. */

 Check FC Header to see what TYPE of frame we are rcv'ing */

 iocbq is prepped for internal consumption.  Physical vpi. */

 put the first buffer into the first IOCBq */

	/*

	 * Each IOCBq can have two Buffers assigned, so go through the list

	 * of buffers for this sequence and save two buffers in each IOCBq

 We need to get the size out of the right CQE */

 We need to get the size out of the right CQE */

 Free the sequence's header buffer */

 Free iocb created in lpfc_prep_seq */

 Send the received frame back */

 Queue cq event and wakeup worker thread to process it */

 Allocate buffer for command payload */

 copyin the payload */

 fill in BDE's for command */

	/*

	 * Setup rest of the iocb as though it were a WQE

	 * Build the SEND_FRAME WQE

/**

 * lpfc_sli4_handle_received_buffer - Handle received buffers from firmware

 * @phba: Pointer to HBA context object.

 * @dmabuf: Pointer to a dmabuf that describes the FC sequence.

 *

 * This function is called with no lock held. This function processes all

 * the received buffers and gives it to upper layers when a received buffer

 * indicates that it is the final frame in the sequence. The interrupt

 * service routine processes received buffers at interrupt contexts.

 * Worker thread calls lpfc_sli4_handle_received_buffer, which will call the

 * appropriate receive function when the final frame in a sequence is received.

 Process each received buffer */

 Handle MDS Loopback frames */

 check to see if this a valid type of frame */

 Handle MDS Loopback frames */

 d_id this frame is directed to */

 throw out the frame */

 vport is registered unless we rcv a FLOGI directed to Fabric_DID */

		/*

		 * Throw out the frame if we are not pt2pt.

		 * The pt2pt protocol allows for discovery frames

		 * to be received without a registered VPI.

 Handle the basic abort sequence (BA_ABTS) event */

 Link this frame */

 unable to add frame to vport - throw it out */

 If not last frame in sequence continue processing frames. */

 Send the complete sequence to the upper layer protocol */

/**

 * lpfc_sli4_post_all_rpi_hdrs - Post the rpi header memory region to the port

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to post rpi header templates to the

 * HBA consistent with the SLI-4 interface spec.  This routine

 * posts a SLI4_PAGE_SIZE memory region to the port to hold up to

 * SLI4_PAGE_SIZE modulo 64 rpi context headers.

 *

 * This routine does not require any locks.  It's usage is expected

 * to be driver load or reset recovery when the driver is

 * sequential.

 *

 * Return codes

 * 	0 - successful

 *      -EIO - The mailbox failed to complete successfully.

 * 	When this error occurs, the driver is not guaranteed

 *	to have any rpi regions posted to the device and

 *	must either attempt to repost the regions or take a

 *	fatal error.

 SLI4 ports that support extents do not require RPI headers. */

		/*

		 * Assign the rpi headers a physical rpi only if the driver

		 * has not initialized those resources.  A port reset only

		 * needs the headers posted.

/**

 * lpfc_sli4_post_rpi_hdr - Post an rpi header memory region to the port

 * @phba: pointer to lpfc hba data structure.

 * @rpi_page:  pointer to the rpi memory region.

 *

 * This routine is invoked to post a single rpi header to the

 * HBA consistent with the SLI-4 interface spec.  This memory region

 * maps up to 64 rpi context regions.

 *

 * Return codes

 * 	0 - successful

 * 	-ENOMEM - No available memory

 *      -EIO - The mailbox failed to complete successfully.

 SLI4 ports that support extents do not require RPI headers. */

 The port is notified of the header region via a mailbox command. */

 Post all rpi memory regions to the port. */

 Post the physical rpi to the port for this rpi header. */

		/*

		 * The next_rpi stores the next logical module-64 rpi value used

		 * to post physical rpis in subsequent rpi postings.

/**

 * lpfc_sli4_alloc_rpi - Get an available rpi in the device's range

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to post rpi header templates to the

 * HBA consistent with the SLI-4 interface spec.  This routine

 * posts a SLI4_PAGE_SIZE memory region to the port to hold up to

 * SLI4_PAGE_SIZE modulo 64 rpi context headers.

 *

 * Returns

 * 	A nonzero rpi defined as rpi_base <= rpi < max_rpi if successful

 * 	LPFC_RPI_ALLOC_ERROR if no rpis are available.

	/*

	 * Fetch the next logical rpi.  Because this index is logical,

	 * the  driver starts at 0 each time.

	/*

	 * Don't try to allocate more rpi header regions if the device limit

	 * has been exhausted.

	/*

	 * RPI header postings are not required for SLI4 ports capable of

	 * extents.

	/*

	 * If the driver is running low on rpi resources, allocate another

	 * page now.  Note that the next_rpi value is used because

	 * it represents how many are actually in use whereas max_rpi notes

	 * how many are supported max by the device.

/**

 * __lpfc_sli4_free_rpi - Release an rpi for reuse.

 * @phba: pointer to lpfc hba data structure.

 * @rpi: rpi to free

 *

 * This routine is invoked to release an rpi to the pool of

 * available rpis maintained by the driver.

	/*

	 * if the rpi value indicates a prior unreg has already

	 * been done, skip the unreg.

/**

 * lpfc_sli4_free_rpi - Release an rpi for reuse.

 * @phba: pointer to lpfc hba data structure.

 * @rpi: rpi to free

 *

 * This routine is invoked to release an rpi to the pool of

 * available rpis maintained by the driver.

/**

 * lpfc_sli4_remove_rpis - Remove the rpi bitmask region

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to remove the memory region that

 * provided rpi via a bitmask.

/**

 * lpfc_sli4_resume_rpi - Remove the rpi bitmask region

 * @ndlp: pointer to lpfc nodelist data structure.

 * @cmpl: completion call-back.

 * @arg: data to load as MBox 'caller buffer information'

 *

 * This routine is invoked to remove the memory region that

 * provided rpi via a bitmask.

 The port is notified of the header region via a mailbox command. */

	/* If cmpl assigned, then this nlp_get pairs with

	 * lpfc_mbx_cmpl_resume_rpi.

	 *

	 * Else cmpl is NULL, then this nlp_get pairs with

	 * lpfc_sli_def_mbox_cmpl.

 Post all rpi memory regions to the port. */

/**

 * lpfc_sli4_init_vpi - Initialize a vpi with the port

 * @vport: Pointer to the vport for which the vpi is being initialized

 *

 * This routine is invoked to activate a vpi with the port.

 *

 * Returns:

 *    0 success

 *    -Evalue otherwise

/**

 * lpfc_mbx_cmpl_add_fcf_record - add fcf mbox completion handler.

 * @phba: pointer to lpfc hba data structure.

 * @mboxq: Pointer to mailbox object.

 *

 * This routine is invoked to manually add a single FCF record. The caller

 * must pass a completely initialized FCF_Record.  This routine takes

 * care of the nonembedded mailbox operations.

 The IOCTL status is embedded in the mailbox subheader. */

/**

 * lpfc_sli4_add_fcf_record - Manually add an FCF Record.

 * @phba: pointer to lpfc hba data structure.

 * @fcf_record:  pointer to the initialized fcf record to add.

 *

 * This routine is invoked to manually add a single FCF record. The caller

 * must pass a completely initialized FCF_Record.  This routine takes

 * care of the nonembedded mailbox operations.

 Allocate DMA memory and set up the non-embedded mailbox command */

	/*

	 * Get the first SGE entry from the non-embedded DMA memory.  This

	 * routine only uses a single SGE.

	/*

	 * Configure the FCF record for FCFI 0.  This is the driver's

	 * hardcoded default and gets used in nonFIP mode.

	/*

	 * Copy the fcf_index and the FCF Record Data. The data starts after

	 * the FCoE header plus word10. The data copy needs to be endian

	 * correct.

/**

 * lpfc_sli4_build_dflt_fcf_record - Build the driver's default FCF Record.

 * @phba: pointer to lpfc hba data structure.

 * @fcf_record:  pointer to the fcf record to write the default data.

 * @fcf_index: FCF table entry index.

 *

 * This routine is invoked to build the driver's default FCF record.  The

 * values used are hardcoded.  This routine handles memory initialization.

 *

 Set the VLAN bit map */

/**

 * lpfc_sli4_fcf_scan_read_fcf_rec - Read hba fcf record for fcf scan.

 * @phba: pointer to lpfc hba data structure.

 * @fcf_index: FCF table entry offset.

 *

 * This routine is invoked to scan the entire FCF table by reading FCF

 * record and processing it one at a time starting from the @fcf_index

 * for initial FCF discovery or fast FCF failover rediscovery.

 *

 * Return 0 if the mailbox command is submitted successfully, none 0

 * otherwise.

 Construct the read FCF record mailbox command */

 Issue the mailbox command asynchronously */

 Reset eligible FCF count for new scan */

 FCF scan failed, clear FCF_TS_INPROG flag */

/**

 * lpfc_sli4_fcf_rr_read_fcf_rec - Read hba fcf record for roundrobin fcf.

 * @phba: pointer to lpfc hba data structure.

 * @fcf_index: FCF table entry offset.

 *

 * This routine is invoked to read an FCF record indicated by @fcf_index

 * and to use it for FLOGI roundrobin FCF failover.

 *

 * Return 0 if the mailbox command is submitted successfully, none 0

 * otherwise.

 Construct the read FCF record mailbox command */

 Issue the mailbox command asynchronously */

/**

 * lpfc_sli4_read_fcf_rec - Read hba fcf record for update eligible fcf bmask.

 * @phba: pointer to lpfc hba data structure.

 * @fcf_index: FCF table entry offset.

 *

 * This routine is invoked to read an FCF record indicated by @fcf_index to

 * determine whether it's eligible for FLOGI roundrobin failover list.

 *

 * Return 0 if the mailbox command is submitted successfully, none 0

 * otherwise.

 Construct the read FCF record mailbox command */

 Issue the mailbox command asynchronously */

/**

 * lpfc_check_next_fcf_pri_level

 * @phba: pointer to the lpfc_hba struct for this port.

 * This routine is called from the lpfc_sli4_fcf_rr_next_index_get

 * routine when the rr_bmask is empty. The FCF indecies are put into the

 * rr_bmask based on their priority level. Starting from the highest priority

 * to the lowest. The most likely FCF candidate will be in the highest

 * priority group. When this routine is called it searches the fcf_pri list for

 * next lowest priority group and repopulates the rr_bmask with only those

 * fcf_indexes.

 * returns:

 * 1=success 0=failure

 Verify the priority list has 2 or more entries */

 Empty rr list */

	/*

	 * Clear the rr_bmask and set all of the bits that are at this

	 * priority.

		/*

		 * the 1st priority that has not FLOGI failed

		 * will be the highest.

	/*

	 * if next_fcf_pri was not set above and the list is not empty then

	 * we have failed flogis on all of them. So reset flogi failed

	 * and start at the beginning.

			/*

			 * the 1st priority that has not FLOGI failed

			 * will be the highest.

/**

 * lpfc_sli4_fcf_rr_next_index_get - Get next eligible fcf record index

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is to get the next eligible FCF record index in a round

 * robin fashion. If the next eligible FCF record index equals to the

 * initial roundrobin FCF record index, LPFC_FCOE_FCF_NEXT_NONE (0xFFFF)

 * shall be returned, otherwise, the next eligible FCF record's index

 * shall be returned.

 Search start from next bit of currently registered FCF index */

 Determine the next fcf index to check */

 Wrap around condition on phba->fcf.fcf_rr_bmask */

		/*

		 * If we have wrapped then we need to clear the bits that

		 * have been tested so that we can detect when we should

		 * change the priority level.

 Check roundrobin failover list empty condition */

		/*

		 * If next fcf index is not found check if there are lower

		 * Priority level fcf's in the fcf_priority list.

		 * Set up the rr_bmask with all of the avaiable fcf bits

		 * at that level and continue the selection process.

/**

 * lpfc_sli4_fcf_rr_index_set - Set bmask with eligible fcf record index

 * @phba: pointer to lpfc hba data structure.

 * @fcf_index: index into the FCF table to 'set'

 *

 * This routine sets the FCF record index in to the eligible bmask for

 * roundrobin failover search. It checks to make sure that the index

 * does not go beyond the range of the driver allocated bmask dimension

 * before setting the bit.

 *

 * Returns 0 if the index bit successfully set, otherwise, it returns

 * -EINVAL.

 Set the eligible FCF record index bmask */

/**

 * lpfc_sli4_fcf_rr_index_clear - Clear bmask from eligible fcf record index

 * @phba: pointer to lpfc hba data structure.

 * @fcf_index: index into the FCF table to 'clear'

 *

 * This routine clears the FCF record index from the eligible bmask for

 * roundrobin failover search. It checks to make sure that the index

 * does not go beyond the range of the driver allocated bmask dimension

 * before clearing the bit.

 Clear the eligible FCF record index bmask */

/**

 * lpfc_mbx_cmpl_redisc_fcf_table - completion routine for rediscover FCF table

 * @phba: pointer to lpfc hba data structure.

 * @mbox: An allocated pointer to type LPFC_MBOXQ_t

 *

 * This routine is the completion routine for the rediscover FCF table mailbox

 * command. If the mailbox command returned failure, it will try to stop the

 * FCF rediscover wait timer.

			/*

			 * CVL event triggered FCF rediscover request failed,

			 * last resort to re-try current registered FCF entry.

			/*

			 * DEAD FCF event triggered FCF rediscover request

			 * failed, last resort to fail over as a link down

			 * to FCF registration.

		/*

		 * Start FCF rediscovery wait timer for pending FCF

		 * before rescan FCF record table.

/**

 * lpfc_sli4_redisc_fcf_table - Request to rediscover entire FCF table by port.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is invoked to request for rediscovery of the entire FCF table

 * by the port.

 Cancel retry delay timers to all vports before FCF rediscover */

 Set count to 0 for invalidating the entire FCF database */

 Issue the mailbox command asynchronously */

/**

 * lpfc_sli4_fcf_dead_failthrough - Failthrough routine to fcf dead event

 * @phba: pointer to lpfc hba data structure.

 *

 * This function is the failover routine as a last resort to the FCF DEAD

 * event when driver failed to perform fast FCF failover.

	/*

	 * Last resort as FCF DEAD event failover will treat this as

	 * a link down, but save the link state because we don't want

	 * it to be changed to Link Down unless it is already down.

 Unregister FCF if no devices connected to it */

/**

 * lpfc_sli_get_config_region23 - Get sli3 port region 23 data.

 * @phba: pointer to lpfc hba data structure.

 * @rgn23_data: pointer to configure region 23 data.

 *

 * This function gets SLI3 port configure region 23 data through memory dump

 * mailbox command. When it successfully retrieves data, the size of the data

 * will be returned, otherwise, 0 will be returned.

		/*

		 * dump mem may return a zero when finished or we got a

		 * mailbox error, either way we are done.

/**

 * lpfc_sli4_get_config_region23 - Get sli4 port region 23 data.

 * @phba: pointer to lpfc hba data structure.

 * @rgn23_data: pointer to configure region 23 data.

 *

 * This function gets SLI4 port configure region 23 data through memory dump

 * mailbox command. When it successfully retrieves data, the size of the data

 * will be returned, otherwise, 0 will be returned.

/**

 * lpfc_sli_read_link_ste - Read region 23 to decide if link is disabled.

 * @phba: pointer to lpfc hba data structure.

 *

 * This function read region 23 and parse TLV for port status to

 * decide if the user disaled the port. If the TLV indicates the

 * port is disabled, the hba_flag is set accordingly.

 Get adapter Region 23 data */

 Check the region signature first */

 Check the data structure version */

 Parse TLV entries in the region */

		/*

		 * If the TLV is not driver specific TLV or driver id is

		 * not linux driver id, skip the record.

 Driver found a driver specific TLV in the config region */

		/*

		 * Search for configured port state sub-TLV.

 This HBA contains PORT_STE configured */

/**

 * lpfc_log_fw_write_cmpl - logs firmware write completion status

 * @phba: pointer to lpfc hba data structure

 * @shdr_status: wr_object rsp's status field

 * @shdr_add_status: wr_object rsp's add_status field

 * @shdr_add_status_2: wr_object rsp's add_status_2 field

 * @shdr_change_status: wr_object rsp's change_status field

 * @shdr_csf: wr_object rsp's csf bit

 *

 * This routine is intended to be called after a firmware write completes.

 * It will log next action items to be performed by the user to instantiate

 * the newly downloaded firmware or reason for incompatibility.

/**

 * lpfc_wr_object - write an object to the firmware

 * @phba: HBA structure that indicates port to create a queue on.

 * @dmabuf_list: list of dmabufs to write to the port.

 * @size: the total byte value of the objects to write to the port.

 * @offset: the current offset to be used to start the transfer.

 *

 * This routine will create a wr_object mailbox command to send to the port.

 * the mailbox command will be constructed using the dma buffers described in

 * @dmabuf_list to create a list of BDEs. This routine will fill in as many

 * BDEs that the imbedded mailbox can support. The @offset variable will be

 * used to indicate the starting offset of the transfer and will also return

 * the offset after the write object mailbox has completed. @size is used to

 * determine the end of the object and whether the eof bit should be set.

 *

 * Return 0 is successful and offset will contain the the new offset to use

 * for the next write.

 * Return negative value for error cases.

 The IOCTL status is embedded in the mailbox subheader. */

/**

 * lpfc_cleanup_pending_mbox - Free up vport discovery mailbox commands.

 * @vport: pointer to vport data structure.

 *

 * This function iterate through the mailboxq and clean up all REG_LOGIN

 * and REG_VPI mailbox commands associated with the vport. This function

 * is called when driver want to restart discovery of the vport due to

 * a Clear Virtual Link event.

 Clean up internally queued mailbox commands with the vport */

 Clean up active mailbox command with the vport */

 Put reference count for delayed processing */

 Unregister the RPI when mailbox complete */

 Cleanup any mailbox completions which are not yet processed */

			/*

			 * If this mailox is already processed or it is

			 * for another vport ignore it.

 Unregister the RPI when mailbox complete */

 Release the cleaned-up mailbox commands */

 Release the ndlp with the cleaned-up active mailbox command */

/**

 * lpfc_drain_txq - Drain the txq

 * @phba: Pointer to HBA context object.

 *

 * This function attempt to submit IOCBs on the txq

 * to the adapter.  For SLI4 adapters, the txq contains

 * ELS IOCBs that have been deferred because the there

 * are no SGLs.  This congestion can occur with large

 * vport counts during node discovery.

 MDS WQE are posted only to first WQ*/

		/* The xri and iocb resources secured,

		 * attempt to issue request

 Failed means we can't issue and need to cancel */

 Cancel all the IOCBs that cannot be issued */

/**

 * lpfc_wqe_bpl2sgl - Convert the bpl/bde to a sgl.

 * @phba: Pointer to HBA context object.

 * @pwqeq: Pointer to command WQE.

 * @sglq: Pointer to the scatter gather queue object.

 *

 * This routine converts the bpl or bde that is in the WQE

 * to a sgl list for the sli4 hardware. The physical address

 * of the bpl/bde is converted back to a virtual address.

 * If the WQE contains a BPL then the list of BDE's is

 * converted to sli4_sge's. If the WQE contains a single

 * BDE then it is converted to a single sli_sge.

 * The WQE is still in cpu endianness so the contents of

 * the bpl can be used without byte swapping.

 *

 * Returns valid XRI = Success, NO_XRI = Failure.

 accumulated offset in the sg request list */

 number of sg reply entries inbound from firmware */

		/* The addrHigh and addrLow fields within the WQE

		 * have not been byteswapped yet so there is no

		 * need to swap them back.

 Should already be byte swapped. */

			/* swap the size field back to the cpu so we

			 * can assign it to the sgl.

			/* The offsets in the sgl need to be accumulated

			 * separately for the request and reply lists.

			 * The request is always first, the reply follows.

 add up the reply sg entries */

 first inbound? reset the offset */

		/* The addrHigh and addrLow fields of the BDE have not

		 * been byteswapped yet so they need to be swapped

		 * before putting them in the sgl.

/**

 * lpfc_sli4_issue_wqe - Issue an SLI4 Work Queue Entry (WQE)

 * @phba: Pointer to HBA context object.

 * @qp: Pointer to HDW queue.

 * @pwqe: Pointer to command WQE.

 NVME_LS and NVME_LS ABTS requests. */

 NVME_FCREQ and NVME_ABTS requests */

 Get the IO distribution (hba_wqidx) for WQ assignment. */

 NVMET requests */

 Get the IO distribution (hba_wqidx) for WQ assignment. */

/**

 * lpfc_sli4_issue_abort_iotag - SLI-4 WQE init & issue for the Abort

 * @phba: Pointer to HBA context object.

 * @cmdiocb: Pointer to driver command iocb object.

 * @cmpl: completion function.

 *

 * Fill the appropriate fields for the abort WQE and call

 * internal routine lpfc_sli4_issue_wqe to send the WQE

 * This function is called with hbalock held and no ring_lock held.

 *

 * RETURNS 0 - SUCCESS

	/*

	 * The scsi command can not be in txq and it is in flight because the

	 * pCmd is still pointing at the SCSI command we have to abort. There

	 * is no need to search the txcmplq. Just send an abort to the FW.

 Indicate the IO is being aborted by the driver. */

 ABTS WQE must go to the same WQ as the WQE to be aborted */

/**

 * lpfc_snapshot_mxp - Snapshot pbl, pvt and busy count

 * @phba: pointer to lpfc hba data structure.

 * @hwqid: belong to which HWQ.

 *

 * The purpose of this routine is to take a snapshot of pbl, pvt and busy count

 * 15 seconds after a test case is running.

 *

 * The user should call lpfc_debugfs_multixripools_write before running a test

 * case to clear stat_snapshot_taken. Then the user starts a test case. During

 * test case is running, stat_snapshot_taken is incremented by 1 every time when

 * this routine is called from heartbeat timer. When stat_snapshot_taken is

 * equal to LPFC_MXP_SNAPSHOT_TAKEN, a snapshot is taken.

/**

 * lpfc_adjust_pvt_pool_count - Adjust private pool count

 * @phba: pointer to lpfc hba data structure.

 * @hwqid: belong to which HWQ.

 *

 * This routine moves some XRIs from private to public pool when private pool

 * is not busy.

 Private pool is busy */

		/* Private pool is not busy.

		 * Move XRIs from private to public pool.

/**

 * lpfc_adjust_high_watermark - Adjust high watermark

 * @phba: pointer to lpfc hba data structure.

 * @hwqid: belong to which HWQ.

 *

 * This routine sets high watermark as number of outstanding XRIs,

 * but make sure the new value is between xri_limit/2 and xri_limit.

/**

 * lpfc_move_xri_pvt_to_pbl - Move some XRIs from private to public pool

 * @phba: pointer to lpfc hba data structure.

 * @hwqid: belong to which HWQ.

 *

 * This routine is called from hearbeat timer when pvt_pool is idle.

 * All free XRIs are moved from private to public pool on hwqid with 2 steps.

 * The first step moves (all - low_watermark) amount of XRIs.

 * The second step moves the rest of XRIs.

		/* Step 1: move (all - low_watermark) from pvt_pool

		 * to pbl_pool

 Move low watermark of bufs from pvt_pool to tmp_list */

 Move all bufs from pvt_pool to pbl_pool */

 Move all bufs from tmp_list to pvt_pool */

 Step 2: move the rest from pvt_pool to pbl_pool */

/**

 * _lpfc_move_xri_pbl_to_pvt - Move some XRIs from public to private pool

 * @phba: pointer to lpfc hba data structure

 * @qp: pointer to HDW queue

 * @pbl_pool: specified public free XRI pool

 * @pvt_pool: specified private free XRI pool

 * @count: number of XRIs to move

 *

 * This routine tries to move some free common bufs from the specified pbl_pool

 * to the specified pvt_pool. It might move less than count XRIs if there's not

 * enough in public pool.

 *

 * Return:

 *   true - if XRIs are successfully moved from the specified pbl_pool to the

 *          specified pvt_pool

 *   false - if the specified pbl_pool is empty or locked by someone else

 Move a batch of XRIs from public to private pool */

/**

 * lpfc_move_xri_pbl_to_pvt - Move some XRIs from public to private pool

 * @phba: pointer to lpfc hba data structure.

 * @hwqid: belong to which HWQ.

 * @count: number of XRIs to move

 *

 * This routine tries to find some free common bufs in one of public pools with

 * Round Robin method. The search always starts from local hwqid, then the next

 * HWQ which was found last time (rrb_next_hwqid). Once a public pool is found,

 * a batch of free common bufs are moved to private pool on hwqid.

 * It might move less than count XRIs if there's not enough in public pool.

 Check if local pbl_pool is available */

 Get the next hwqid which was found last time */

 Go to next hwq */

 Check if the public free xri pool is available */

 Exit while-loop if success or all hwqid are checked */

 Starting point for the next time */

 stats: all public pools are empty*/

/**

 * lpfc_keep_pvt_pool_above_lowwm - Keep pvt_pool above low watermark

 * @phba: pointer to lpfc hba data structure.

 * @hwqid: belong to which HWQ.

 *

 * This routine get a batch of XRIs from pbl_pool if pvt_pool is less than

 * low watermark.

/**

 * lpfc_release_io_buf - Return one IO buf back to free pool

 * @phba: pointer to lpfc hba data structure.

 * @lpfc_ncmd: IO buf to be returned.

 * @qp: belong to which HWQ.

 *

 * This routine returns one IO buf back to free pool. If this is an urgent IO,

 * the IO buf is returned to expedite pool. If cfg_xri_rebalancing==1,

 * the IO buf is returned to pbl_pool or pvt_pool based on watermark and

 * xri_limit.  If cfg_xri_rebalancing==0, the IO buf is returned to

 * lpfc_io_buf_list_put.

 MUST zero fields if buffer is reused by another protocol */

 Return to expedite pool */

		/* Avoid invalid access if an IO sneaks in and is being rejected

		 * just _after_ xri pools are destroyed in lpfc_offline.

		 * Nothing much can be done at this point.

		/* XRI goes to either public or private free xri pool

		 *     based on watermark and xri_limit

/**

 * lpfc_get_io_buf_from_private_pool - Get one free IO buf from private pool

 * @phba: pointer to lpfc hba data structure.

 * @qp: pointer to HDW queue

 * @pvt_pool: pointer to private pool data structure.

 * @ndlp: pointer to lpfc nodelist data structure.

 *

 * This routine tries to get one free IO buf from private pool.

 *

 * Return:

 *   pointer to one free IO buf - if private pool is not empty

 *   NULL - if private pool is empty

/**

 * lpfc_get_io_buf_from_expedite_pool - Get one free IO buf from expedite pool

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine tries to get one free IO buf from expedite pool.

 *

 * Return:

 *   pointer to one free IO buf - if expedite pool is not empty

 *   NULL - if expedite pool is empty

/**

 * lpfc_get_io_buf_from_multixri_pools - Get one free IO bufs

 * @phba: pointer to lpfc hba data structure.

 * @ndlp: pointer to lpfc nodelist data structure.

 * @hwqid: belong to which HWQ

 * @expedite: 1 means this request is urgent.

 *

 * This routine will do the following actions and then return a pointer to

 * one free IO buf.

 *

 * 1. If private free xri count is empty, move some XRIs from public to

 *    private pool.

 * 2. Get one XRI from private free xri pool.

 * 3. If we fail to get one from pvt_pool and this is an expedite request,

 *    get one free xri from expedite pool.

 *

 * Note: ndlp is only used on SCSI side for RRQ testing.

 *       The caller should pass NULL for ndlp on NVME side.

 *

 * Return:

 *   pointer to one free IO buf - if private pool is not empty

 *   NULL - if private pool is empty

 If pvt_pool is empty, move some XRIs from public to private pool */

 Get one XRI from private free xri pool */

		/* If we fail to get one from pvt_pool and this is an expedite

		 * request, get one free xri from expedite pool.

/**

 * lpfc_get_io_buf - Get one IO buffer from free pool

 * @phba: The HBA for which this call is being executed.

 * @ndlp: pointer to lpfc nodelist data structure.

 * @hwqid: belong to which HWQ

 * @expedite: 1 means this request is urgent.

 *

 * This routine gets one IO buffer from free pool. If cfg_xri_rebalancing==1,

 * removes a IO buffer from multiXRI pools. If cfg_xri_rebalancing==0, removes

 * a IO buffer from head of @hdwq io_buf_list and returns to caller.

 *

 * Note: ndlp is only used on SCSI side for RRQ testing.

 *       The caller should pass NULL for ndlp on NVME side.

 *

 * Return codes:

 *   NULL - Error

 *   Pointer to lpfc_io_buf - Success

/**

 * lpfc_read_object - Retrieve object data from HBA

 * @phba: The HBA for which this call is being executed.

 * @rdobject: Pathname of object data we want to read.

 * @datap: Pointer to where data will be copied to.

 * @datasz: size of data area

 *

 * This routine is limited to object sizes of LPFC_BPL_SIZE (1024) or less.

 * The data will be truncated if datasz is not large enough.

 * Version 1 is not supported with Embedded mbox cmd, so we must use version 0.

 * Returns the actual bytes read from the object.

 sanity check on queue memory */

 Success */

 Detect the port config file exists but is empty */

/**

 * lpfc_get_sgl_per_hdwq - Get one SGL chunk from hdwq's pool

 * @phba: The HBA for which this call is being executed.

 * @lpfc_buf: IO buf structure to append the SGL chunk

 *

 * This routine gets one SGL chunk buffer from hdwq's SGL chunk pool,

 * and will allocate an SGL chunk if the pool is empty.

 *

 * Return codes:

 *   NULL - Error

 *   Pointer to sli4_hybrid_sgl - Success

 break off 1 chunk from the sgl_list */

 allocate more */

/**

 * lpfc_put_sgl_per_hdwq - Put one SGL chunk into hdwq pool

 * @phba: The HBA for which this call is being executed.

 * @lpfc_buf: IO buf structure with the SGL chunk

 *

 * This routine puts one SGL chunk buffer into hdwq's SGL chunk pool.

 *

 * Return codes:

 *   0 - Success

 *   -EINVAL - Error

/**

 * lpfc_free_sgl_per_hdwq - Free all SGL chunks of hdwq pool

 * @phba: phba object

 * @hdwq: hdwq to cleanup sgl buff resources on

 *

 * This routine frees all SGL chunks of hdwq SGL chunk pool.

 *

 * Return codes:

 *   None

 Free sgl pool */

/**

 * lpfc_get_cmd_rsp_buf_per_hdwq - Get one CMD/RSP buffer from hdwq

 * @phba: The HBA for which this call is being executed.

 * @lpfc_buf: IO buf structure to attach the CMD/RSP buffer

 *

 * This routine gets one CMD/RSP buffer from hdwq's CMD/RSP pool,

 * and will allocate an CMD/RSP buffer if the pool is empty.

 *

 * Return codes:

 *   NULL - Error

 *   Pointer to fcp_cmd_rsp_buf - Success

 break off 1 chunk from the list */

 allocate more */

/**

 * lpfc_put_cmd_rsp_buf_per_hdwq - Put one CMD/RSP buffer into hdwq pool

 * @phba: The HBA for which this call is being executed.

 * @lpfc_buf: IO buf structure with the CMD/RSP buf

 *

 * This routine puts one CMD/RSP buffer into executing CPU's CMD/RSP pool.

 *

 * Return codes:

 *   0 - Success

 *   -EINVAL - Error

/**

 * lpfc_free_cmd_rsp_buf_per_hdwq - Free all CMD/RSP chunks of hdwq pool

 * @phba: phba object

 * @hdwq: hdwq to cleanup cmd rsp buff resources on

 *

 * This routine frees all CMD/RSP buffers of hdwq's CMD/RSP buf pool.

 *

 * Return codes:

 *   None

 Free cmd_rsp buf pool */

/*******************************************************************

 * This file is part of the Emulex Linux Device Driver for         *

 * Fibre Channel Host Bus Adapters.                                *

 * Copyright (C) 2017-2021 Broadcom. All Rights Reserved. The term *

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.  *

 * Copyright (C) 2007-2015 Emulex.  All rights reserved.           *

 * EMULEX and SLI are trademarks of Emulex.                        *

 * www.broadcom.com                                                *

 *                                                                 *

 * This program is free software; you can redistribute it and/or   *

 * modify it under the terms of version 2 of the GNU General       *

 * Public License as published by the Free Software Foundation.    *

 * This program is distributed in the hope that it will be useful. *

 * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *

 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *

 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *

 * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *

 * TO BE LEGALLY INVALID.  See the GNU General Public License for  *

 * more details, a copy of which can be found in the file COPYING  *

 * included with this package.                                     *

/*

 * debugfs interface

 *

 * To access this interface the user should:

 * # mount -t debugfs none /sys/kernel/debug

 *

 * The lpfc debugfs directory hierarchy is:

 * /sys/kernel/debug/lpfc/fnX/vportY

 * where X is the lpfc hba function unique_id

 * where Y is the vport VPI on that hba

 *

 * Debugging services available per vport:

 * discovery_trace

 * This is an ACSII readable file that contains a trace of the last

 * lpfc_debugfs_max_disc_trc events that happened on a specific vport.

 * See lpfc_debugfs.h for different categories of  discovery events.

 * To enable the discovery trace, the following module parameters must be set:

 * lpfc_debugfs_enable=1         Turns on lpfc debugfs filesystem support

 * lpfc_debugfs_max_disc_trc=X   Where X is the event trace depth for

 *                               EACH vport. X MUST also be a power of 2.

 * lpfc_debugfs_mask_disc_trc=Y  Where Y is an event mask as defined in

 *                               lpfc_debugfs.h .

 *

 * slow_ring_trace

 * This is an ACSII readable file that contains a trace of the last

 * lpfc_debugfs_max_slow_ring_trc events that happened on a specific HBA.

 * To enable the slow ring trace, the following module parameters must be set:

 * lpfc_debugfs_enable=1         Turns on lpfc debugfs filesystem support

 * lpfc_debugfs_max_slow_ring_trc=X   Where X is the event trace depth for

 *                               the HBA. X MUST also be a power of 2.

 This MUST be a power of 2 */

 This MUST be a power of 2 */

 This MUST be a power of 2 */

 iDiag */

/**

 * lpfc_debugfs_disc_trc_data - Dump discovery logging to a buffer

 * @vport: The vport to gather the log info from.

 * @buf: The buffer to dump log into.

 * @size: The maximum amount of data to process.

 *

 * Description:

 * This routine gathers the lpfc discovery debugfs data from the @vport and

 * dumps it to @buf up to @size number of bytes. It will start at the next entry

 * in the log and process the log until the end of the buffer. Then it will

 * gather from the beginning of the log and process until the current entry.

 *

 * Notes:

 * Discovery logging will be disabled while while this routine dumps the log.

 *

 * Return Value:

 * This routine returns the amount of bytes that were dumped into @buf and will

 * not exceed @size.

/**

 * lpfc_debugfs_slow_ring_trc_data - Dump slow ring logging to a buffer

 * @phba: The HBA to gather the log info from.

 * @buf: The buffer to dump log into.

 * @size: The maximum amount of data to process.

 *

 * Description:

 * This routine gathers the lpfc slow ring debugfs data from the @phba and

 * dumps it to @buf up to @size number of bytes. It will start at the next entry

 * in the log and process the log until the end of the buffer. Then it will

 * gather from the beginning of the log and process until the current entry.

 *

 * Notes:

 * Slow ring logging will be disabled while while this routine dumps the log.

 *

 * Return Value:

 * This routine returns the amount of bytes that were dumped into @buf and will

 * not exceed @size.

/**

 * lpfc_debugfs_hbqinfo_data - Dump host buffer queue info to a buffer

 * @phba: The HBA to gather host buffer info from.

 * @buf: The buffer to dump log into.

 * @size: The maximum amount of data to process.

 *

 * Description:

 * This routine dumps the host buffer queue info from the @phba to @buf up to

 * @size number of bytes. A header that describes the current hbq state will be

 * dumped to @buf first and then info on each hbq entry will be dumped to @buf

 * until @size bytes have been dumped or all the hbq info has been dumped.

 *

 * Notes:

 * This routine will rotate through each configured HBQ each time called.

 *

 * Return Value:

 * This routine returns the amount of bytes that were dumped into @buf and will

 * not exceed @size.

 toggle between multiple hbqs, if any */

 First calculate if slot has an associated posted buffer */

 Get the Buffer info for the posted buffer */

/**

 * lpfc_debugfs_commonxripools_data - Dump Hardware Queue info to a buffer

 * @phba: The HBA to gather host buffer info from.

 * @buf: The buffer to dump log into.

 * @size: The maximum amount of data to process.

 *

 * Description:

 * This routine dumps the Hardware Queue info from the @phba to @buf up to

 * @size number of bytes. A header that describes the current hdwq state will be

 * dumped to @buf first and then info on each hdwq entry will be dumped to @buf

 * until @size bytes have been dumped or all the hdwq info has been dumped.

 *

 * Notes:

 * This routine will rotate through each configured Hardware Queue each

 * time called.

 *

 * Return Value:

 * This routine returns the amount of bytes that were dumped into @buf and will

 * not exceed @size.

/**

 * lpfc_debugfs_multixripools_data - Display multi-XRI pools information

 * @phba: The HBA to gather host buffer info from.

 * @buf: The buffer to dump log into.

 * @size: The maximum amount of data to process.

 *

 * Description:

 * This routine displays current multi-XRI pools information including XRI

 * count in public, private and txcmplq. It also displays current high and

 * low watermark.

 *

 * Return Value:

 * This routine returns the amount of bytes that were dumped into @buf and will

 * not exceed @size.

	/*

	 * Pbl: Current number of free XRIs in public pool

	 * Pvt: Current number of free XRIs in private pool

	 * Busy: Current number of outstanding XRIs

	 * HWM: Current high watermark

	 * pvt_empty: Incremented by 1 when IO submission fails (no xri)

	 * pbl_empty: Incremented by 1 when all pbl_pool are empty during

	 *            IO submission

	/*

	 * MAXH: Max high watermark seen so far

	 * above_lmt: Incremented by 1 if xri_owned > xri_limit during

	 *            IO submission

	 * below_lmt: Incremented by 1 if xri_owned <= xri_limit  during

	 *            IO submission

	 * locPbl_hit: Incremented by 1 if successfully get a batch of XRI from

	 *             local pbl_pool

	 * othPbl_hit: Incremented by 1 if successfully get a batch of XRI from

	 *             other pbl_pool

	/*

	 * sPbl: snapshot of Pbl 15 sec after stat gets cleared

	 * sPvt: snapshot of Pvt 15 sec after stat gets cleared

	 * sBusy: snapshot of Busy 15 sec after stat gets cleared

/**

 * lpfc_debugfs_lockstat_data - Dump Hardware Queue info to a buffer

 * @phba: The HBA to gather host buffer info from.

 * @buf: The buffer to dump log into.

 * @size: The maximum amount of data to process.

 *

 * Description:

 * This routine dumps the Hardware Queue info from the @phba to @buf up to

 * @size number of bytes. A header that describes the current hdwq state will be

 * dumped to @buf first and then info on each hdwq entry will be dumped to @buf

 * until @size bytes have been dumped or all the hdwq info has been dumped.

 *

 * Notes:

 * This routine will rotate through each configured Hardware Queue each

 * time called.

 *

 * Return Value:

 * This routine returns the amount of bytes that were dumped into @buf and will

 * not exceed @size.

/**

 * lpfc_debugfs_dumpHBASlim_data - Dump HBA SLIM info to a buffer

 * @phba: The HBA to gather SLIM info from.

 * @buf: The buffer to dump log into.

 * @size: The maximum amount of data to process.

 *

 * Description:

 * This routine dumps the current contents of HBA SLIM for the HBA associated

 * with @phba to @buf up to @size bytes of data. This is the raw HBA SLIM data.

 *

 * Notes:

 * This routine will only dump up to 1024 bytes of data each time called and

 * should be called multiple times to dump the entire HBA SLIM.

 *

 * Return Value:

 * This routine returns the amount of bytes that were dumped into @buf and will

 * not exceed @size.

 Set it up for the next time */

/**

 * lpfc_debugfs_dumpHostSlim_data - Dump host SLIM info to a buffer

 * @phba: The HBA to gather Host SLIM info from.

 * @buf: The buffer to dump log into.

 * @size: The maximum amount of data to process.

 *

 * Description:

 * This routine dumps the current contents of host SLIM for the host associated

 * with @phba to @buf up to @size bytes of data. The dump will contain the

 * Mailbox, PCB, Rings, and Registers that are located in host memory.

 *

 * Return Value:

 * This routine returns the amount of bytes that were dumped into @buf and will

 * not exceed @size.

/**

 * lpfc_debugfs_nodelist_data - Dump target node list to a buffer

 * @vport: The vport to gather target node info from.

 * @buf: The buffer to dump log into.

 * @size: The maximum amount of data to process.

 *

 * Description:

 * This routine dumps the current target node list associated with @vport to

 * @buf up to @size bytes of data. Each node entry in the dump will contain a

 * node state, DID, WWPN, WWNN, RPI, flags, type, and other useful fields.

 *

 * Return Value:

 * This routine returns the amount of bytes that were dumped into @buf and will

 * not exceed @size.

 Port state is only one of two values for now. */

 Port state is only one of two values for now. */

 local short-hand pointer. */

 Port state is only one of two values for now. */

 Tab in to show lport ownership. */

 An NVME rport can have multiple roles. */

 Terminate the string. */

/**

 * lpfc_debugfs_nvmestat_data - Dump target node list to a buffer

 * @vport: The vport to gather target node info from.

 * @buf: The buffer to dump log into.

 * @size: The maximum amount of data to process.

 *

 * Description:

 * This routine dumps the NVME statistics associated with @vport

 *

 * Return Value:

 * This routine returns the amount of bytes that were dumped into @buf and will

 * not exceed @size.

 Calculate outstanding IOs */

 Limit to 32, debugfs display buffer limitation */

/**

 * lpfc_debugfs_scsistat_data - Dump target node list to a buffer

 * @vport: The vport to gather target node info from.

 * @buf: The buffer to dump log into.

 * @size: The maximum amount of data to process.

 *

 * Description:

 * This routine dumps the SCSI statistics associated with @vport

 *

 * Return Value:

 * This routine returns the amount of bytes that were dumped into @buf and will

 * not exceed @size.

	/*

	 * Segment 1 - Time from Last FCP command cmpl is handed

	 * off to NVME Layer to start of next command.

	 * Segment 2 - Time from Driver receives a IO cmd start

	 * from NVME Layer to WQ put is done on IO cmd.

	 * Segment 3 - Time from Driver WQ put is done on IO cmd

	 * to MSI-X ISR for IO cmpl.

	 * Segment 4 - Time from MSI-X ISR for IO cmpl to when

	 * cmpl is handled off to the NVME Layer.

 5 ms - for sequential IOs only */

 Calculate times relative to start of IO */

/**

 * lpfc_debugfs_ioktime_data - Dump target node list to a buffer

 * @vport: The vport to gather target node info from.

 * @buf: The buffer to dump log into.

 * @size: The maximum amount of data to process.

 *

 * Description:

 * This routine dumps the NVME statistics associated with @vport

 *

 * Return Value:

 * This routine returns the amount of bytes that were dumped into @buf and will

 * not exceed @size.

 Initiator */

 NVME Target */

/**

 * lpfc_debugfs_nvmeio_trc_data - Dump NVME IO trace list to a buffer

 * @phba: The phba to gather target node info from.

 * @buf: The buffer to dump log into.

 * @size: The maximum amount of data to process.

 *

 * Description:

 * This routine dumps the NVME IO trace associated with @phba

 *

 * Return Value:

 * This routine returns the amount of bytes that were dumped into @buf and will

 * not exceed @size.

 trace MUST bhe off to continue */

/**

 * lpfc_debugfs_hdwqstat_data - Dump I/O stats to a buffer

 * @vport: The vport to gather target node info from.

 * @buf: The buffer to dump log into.

 * @size: The maximum amount of data to process.

 *

 * Description:

 * This routine dumps the NVME + SCSI statistics associated with @vport

 *

 * Return Value:

 * This routine returns the amount of bytes that were dumped into @buf and will

 * not exceed @size.

 Only display for this HDWQ */

 Only display non-zero counters */

 Print HDWQ string only the first time */

 Check if nothing to display */

/**

 * lpfc_debugfs_disc_trc - Store discovery trace log

 * @vport: The vport to associate this trace string with for retrieval.

 * @mask: Log entry classification.

 * @fmt: Format string to be displayed when dumping the log.

 * @data1: 1st data parameter to be applied to @fmt.

 * @data2: 2nd data parameter to be applied to @fmt.

 * @data3: 3rd data parameter to be applied to @fmt.

 *

 * Description:

 * This routine is used by the driver code to add a debugfs log entry to the

 * discovery trace buffer associated with @vport. Only entries with a @mask that

 * match the current debugfs discovery mask will be saved. Entries that do not

 * match will be thrown away. @fmt, @data1, @data2, and @data3 are used like

 * printf when displaying the log.

/**

 * lpfc_debugfs_slow_ring_trc - Store slow ring trace log

 * @phba: The phba to associate this trace string with for retrieval.

 * @fmt: Format string to be displayed when dumping the log.

 * @data1: 1st data parameter to be applied to @fmt.

 * @data2: 2nd data parameter to be applied to @fmt.

 * @data3: 3rd data parameter to be applied to @fmt.

 *

 * Description:

 * This routine is used by the driver code to add a debugfs log entry to the

 * discovery trace buffer associated with @vport. @fmt, @data1, @data2, and

 * @data3 are used like printf when displaying the log.

/**

 * lpfc_debugfs_nvme_trc - Store NVME/NVMET trace log

 * @phba: The phba to associate this trace string with for retrieval.

 * @fmt: Format string to be displayed when dumping the log.

 * @data1: 1st data parameter to be applied to @fmt.

 * @data2: 2nd data parameter to be applied to @fmt.

 * @data3: 3rd data parameter to be applied to @fmt.

 *

 * Description:

 * This routine is used by the driver code to add a debugfs log entry to the

 * nvme trace buffer associated with @phba. @fmt, @data1, @data2, and

 * @data3 are used like printf when displaying the log.

/**

 * lpfc_debugfs_disc_trc_open - Open the discovery trace log

 * @inode: The inode pointer that contains a vport pointer.

 * @file: The file pointer to attach the log output.

 *

 * Description:

 * This routine is the entry point for the debugfs open file operation. It gets

 * the vport from the i_private field in @inode, allocates the necessary buffer

 * for the log, fills the buffer from the in-memory log for this vport, and then

 * returns a pointer to that log in the private_data field in @file.

 *

 * Returns:

 * This function returns zero if successful. On error it will return a negative

 * error value.

 Round to page boundary */

/**

 * lpfc_debugfs_slow_ring_trc_open - Open the Slow Ring trace log

 * @inode: The inode pointer that contains a vport pointer.

 * @file: The file pointer to attach the log output.

 *

 * Description:

 * This routine is the entry point for the debugfs open file operation. It gets

 * the vport from the i_private field in @inode, allocates the necessary buffer

 * for the log, fills the buffer from the in-memory log for this vport, and then

 * returns a pointer to that log in the private_data field in @file.

 *

 * Returns:

 * This function returns zero if successful. On error it will return a negative

 * error value.

 Round to page boundary */

/**

 * lpfc_debugfs_hbqinfo_open - Open the hbqinfo debugfs buffer

 * @inode: The inode pointer that contains a vport pointer.

 * @file: The file pointer to attach the log output.

 *

 * Description:

 * This routine is the entry point for the debugfs open file operation. It gets

 * the vport from the i_private field in @inode, allocates the necessary buffer

 * for the log, fills the buffer from the in-memory log for this vport, and then

 * returns a pointer to that log in the private_data field in @file.

 *

 * Returns:

 * This function returns zero if successful. On error it will return a negative

 * error value.

 Round to page boundary */

/**

 * lpfc_debugfs_multixripools_open - Open the multixripool debugfs buffer

 * @inode: The inode pointer that contains a hba pointer.

 * @file: The file pointer to attach the log output.

 *

 * Description:

 * This routine is the entry point for the debugfs open file operation. It gets

 * the hba from the i_private field in @inode, allocates the necessary buffer

 * for the log, fills the buffer from the in-memory log for this hba, and then

 * returns a pointer to that log in the private_data field in @file.

 *

 * Returns:

 * This function returns zero if successful. On error it will return a negative

 * error value.

 Round to page boundary */

/**

 * lpfc_debugfs_lockstat_open - Open the lockstat debugfs buffer

 * @inode: The inode pointer that contains a vport pointer.

 * @file: The file pointer to attach the log output.

 *

 * Description:

 * This routine is the entry point for the debugfs open file operation. It gets

 * the vport from the i_private field in @inode, allocates the necessary buffer

 * for the log, fills the buffer from the in-memory log for this vport, and then

 * returns a pointer to that log in the private_data field in @file.

 *

 * Returns:

 * This function returns zero if successful. On error it will return a negative

 * error value.

 Round to page boundary */

 Check if copying will go over size and a '\0' char */

/**

 * lpfc_debugfs_ras_log_open - Open the RAS log debugfs buffer

 * @inode: The inode pointer that contains a vport pointer.

 * @file: The file pointer to attach the log output.

 *

 * Description:

 * This routine is the entry point for the debugfs open file operation. It gets

 * the vport from the i_private field in @inode, allocates the necessary buffer

 * for the log, fills the buffer from the in-memory log for this vport, and then

 * returns a pointer to that log in the private_data field in @file.

 *

 * Returns:

 * This function returns zero if successful. On error it will return a negative

 * error value.

/**

 * lpfc_debugfs_dumpHBASlim_open - Open the Dump HBA SLIM debugfs buffer

 * @inode: The inode pointer that contains a vport pointer.

 * @file: The file pointer to attach the log output.

 *

 * Description:

 * This routine is the entry point for the debugfs open file operation. It gets

 * the vport from the i_private field in @inode, allocates the necessary buffer

 * for the log, fills the buffer from the in-memory log for this vport, and then

 * returns a pointer to that log in the private_data field in @file.

 *

 * Returns:

 * This function returns zero if successful. On error it will return a negative

 * error value.

 Round to page boundary */

/**

 * lpfc_debugfs_dumpHostSlim_open - Open the Dump Host SLIM debugfs buffer

 * @inode: The inode pointer that contains a vport pointer.

 * @file: The file pointer to attach the log output.

 *

 * Description:

 * This routine is the entry point for the debugfs open file operation. It gets

 * the vport from the i_private field in @inode, allocates the necessary buffer

 * for the log, fills the buffer from the in-memory log for this vport, and then

 * returns a pointer to that log in the private_data field in @file.

 *

 * Returns:

 * This function returns zero if successful. On error it will return a negative

 * error value.

 Round to page boundary */

/**

 * lpfc_debugfs_nodelist_open - Open the nodelist debugfs file

 * @inode: The inode pointer that contains a vport pointer.

 * @file: The file pointer to attach the log output.

 *

 * Description:

 * This routine is the entry point for the debugfs open file operation. It gets

 * the vport from the i_private field in @inode, allocates the necessary buffer

 * for the log, fills the buffer from the in-memory log for this vport, and then

 * returns a pointer to that log in the private_data field in @file.

 *

 * Returns:

 * This function returns zero if successful. On error it will return a negative

 * error value.

 Round to page boundary */

/**

 * lpfc_debugfs_lseek - Seek through a debugfs file

 * @file: The file pointer to seek through.

 * @off: The offset to seek to or the amount to seek by.

 * @whence: Indicates how to seek.

 *

 * Description:

 * This routine is the entry point for the debugfs lseek file operation. The

 * @whence parameter indicates whether @off is the offset to directly seek to,

 * or if it is a value to seek forward or reverse by. This function figures out

 * what the new offset of the debugfs file will be and assigns that value to the

 * f_pos field of @file.

 *

 * Returns:

 * This function returns the new offset if successful and returns a negative

 * error if unable to process the seek.

/**

 * lpfc_debugfs_read - Read a debugfs file

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the data to.

 * @nbytes: The number of bytes to read.

 * @ppos: The position in the file to start reading from.

 *

 * Description:

 * This routine reads data from from the buffer indicated in the private_data

 * field of @file. It will start reading at @ppos and copy up to @nbytes of

 * data to @buf.

 *

 * Returns:

 * This function returns the amount of data that was read (this could be less

 * than @nbytes if the end of the file was reached) or a negative error value.

/**

 * lpfc_debugfs_release - Release the buffer used to store debugfs file data

 * @inode: The inode pointer that contains a vport pointer. (unused)

 * @file: The file pointer that contains the buffer to release.

 *

 * Description:

 * This routine frees the buffer that was allocated when the debugfs file was

 * opened.

 *

 * Returns:

 * This function returns zero.

/**

 * lpfc_debugfs_multixripools_write - Clear multi-XRI pools statistics

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the user data from.

 * @nbytes: The number of bytes to get.

 * @ppos: The position in the file to start reading from.

 *

 * Description:

 * This routine clears multi-XRI pools statistics when buf contains "clear".

 *

 * Return Value:

 * It returns the @nbytges passing in from debugfs user space when successful.

 * In case of error conditions, it returns proper error code back to the user

 * space.

 Round to page boundary */

 Round to page boundary */

 Round to page boundary */

 Round to page boundary */

 We must be off to allocate the trace buffer */

 If not on or off, the parameter is the trace buffer size */

 It must be a power of 2 - round down */

 If one previously exists, free it */

 Allocate new trace buffer and initialize */

 Round to page boundary */

/*

 * ---------------------------------

 * iDiag debugfs file access methods

 * ---------------------------------

 *

 * All access methods are through the proper SLI4 PCI function's debugfs

 * iDiag directory:

 *

 *     /sys/kernel/debug/lpfc/fn<#>/iDiag

/**

 * lpfc_idiag_cmd_get - Get and parse idiag debugfs comands from user space

 * @buf: The pointer to the user space buffer.

 * @nbytes: The number of bytes in the user space buffer.

 * @idiag_cmd: pointer to the idiag command struct.

 *

 * This routine reads data from debugfs user space buffer and parses the

 * buffer for getting the idiag command and arguments. The while space in

 * between the set of data is used as the parsing separator.

 *

 * This routine returns 0 when successful, it returns proper error code

 * back to the user space in error conditions.

 The opcode must present */

/**

 * lpfc_idiag_open - idiag open debugfs

 * @inode: The inode pointer that contains a pointer to phba.

 * @file: The file pointer to attach the file operation.

 *

 * Description:

 * This routine is the entry point for the debugfs open file operation. It

 * gets the reference to phba from the i_private field in @inode, it then

 * allocates buffer for the file operation, performs the necessary PCI config

 * space read into the allocated buffer according to the idiag user command

 * setup, and then returns a pointer to buffer in the private_data field in

 * @file.

 *

 * Returns:

 * This function returns zero if successful. On error it will return an

 * negative error value.

/**

 * lpfc_idiag_release - Release idiag access file operation

 * @inode: The inode pointer that contains a vport pointer. (unused)

 * @file: The file pointer that contains the buffer to release.

 *

 * Description:

 * This routine is the generic release routine for the idiag access file

 * operation, it frees the buffer that was allocated when the debugfs file

 * was opened.

 *

 * Returns:

 * This function returns zero.

 Free the buffers to the file operation */

/**

 * lpfc_idiag_cmd_release - Release idiag cmd access file operation

 * @inode: The inode pointer that contains a vport pointer. (unused)

 * @file: The file pointer that contains the buffer to release.

 *

 * Description:

 * This routine frees the buffer that was allocated when the debugfs file

 * was opened. It also reset the fields in the idiag command struct in the

 * case of command for write operation.

 *

 * Returns:

 * This function returns zero.

 Free the buffers to the file operation */

/**

 * lpfc_idiag_pcicfg_read - idiag debugfs read pcicfg

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the data to.

 * @nbytes: The number of bytes to read.

 * @ppos: The position in the file to start reading from.

 *

 * Description:

 * This routine reads data from the @phba pci config space according to the

 * idiag command, and copies to user @buf. Depending on the PCI config space

 * read command setup, it does either a single register read of a byte

 * (8 bits), a word (16 bits), or a dword (32 bits) or browsing through all

 * registers from the 4K extended PCI config space.

 *

 * Returns:

 * This function returns the amount of data that was read (this could be less

 * than @nbytes if the end of the file was reached) or a negative error value.

 This is a user read operation */

 Read single PCI config space register */

 byte (8 bits) */

 word (16 bits) */

 double word (32 bits) */

 browse all */

 illegal count */

 Browse all PCI config space registers */

 Read PCI config space */

 Set up the offset for next portion of pci cfg read */

/**

 * lpfc_idiag_pcicfg_write - Syntax check and set up idiag pcicfg commands

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the user data from.

 * @nbytes: The number of bytes to get.

 * @ppos: The position in the file to start reading from.

 *

 * This routine get the debugfs idiag command struct from user space and

 * then perform the syntax check for PCI config space read or write command

 * accordingly. In the case of PCI config space read command, it sets up

 * the command in the idiag command struct for the debugfs read operation.

 * In the case of PCI config space write operation, it executes the write

 * operation into the PCI config space accordingly.

 *

 * It returns the @nbytges passing in from debugfs user space when successful.

 * In case of error conditions, it returns proper error code back to the user

 * space.

 This is a user write operation */

 Sanity check on PCI config read command line arguments */

 Read command from PCI config space, set up command fields */

 Starting offset to browse */

 Sanity check on PCI config write command line arguments */

 Write command to PCI config space, read-modify-write */

 Sanity checks */

 All other opecodes are illegal for now */

/**

 * lpfc_idiag_baracc_read - idiag debugfs pci bar access read

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the data to.

 * @nbytes: The number of bytes to read.

 * @ppos: The position in the file to start reading from.

 *

 * Description:

 * This routine reads data from the @phba pci bar memory mapped space

 * according to the idiag command, and copies to user @buf.

 *

 * Returns:

 * This function returns the amount of data that was read (this could be less

 * than @nbytes if the end of the file was reached) or a negative error value.

 This is a user read operation */

 Read single PCI bar space register */

 Browse all PCI bar space registers */

 Read PCI bar memory mapped space */

 Set up the offset for next portion of pci bar read */

/**

 * lpfc_idiag_baracc_write - Syntax check and set up idiag bar access commands

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the user data from.

 * @nbytes: The number of bytes to get.

 * @ppos: The position in the file to start reading from.

 *

 * This routine get the debugfs idiag command struct from user space and

 * then perform the syntax check for PCI bar memory mapped space read or

 * write command accordingly. In the case of PCI bar memory mapped space

 * read command, it sets up the command in the idiag command struct for

 * the debugfs read operation. In the case of PCI bar memorpy mapped space

 * write operation, it executes the write operation into the PCI bar memory

 * mapped space accordingly.

 *

 * It returns the @nbytges passing in from debugfs user space when successful.

 * In case of error conditions, it returns proper error code back to the user

 * space.

 This is a user write operation */

 Sanity check on PCI config read command line arguments */

 Starting offset to browse */

 Starting offset to browse */

 Sanity check on PCI bar write command line arguments */

 Write command to PCI bar space, read-modify-write */

 All other opecodes are illegal for now */

 Reset max counter */

 NVMET CQset */

 Reset max counter */

 RQ header */

/**

 * lpfc_idiag_queinfo_read - idiag debugfs read queue information

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the data to.

 * @nbytes: The number of bytes to read.

 * @ppos: The position in the file to start reading from.

 *

 * Description:

 * This routine reads data from the @phba SLI4 PCI function queue information,

 * and copies to user @buf.

 * This routine only returns 1 EQs worth of information. It remembers the last

 * EQ read and jumps to the next EQ. Thus subsequent calls to queInfo will

 * retrieve all EQs allocated for the phba.

 *

 * Returns:

 * This function returns the amount of data that was read (this could be less

 * than @nbytes if the end of the file was reached) or a negative error value.

 Fast-path event queue */

 Fast-path EQ */

 Reset max counter */

 will dump both fcp and nvme cqs/wqs for the eq */

 Only EQ 0 has slow path CQs configured */

 Slow-path mailbox CQ */

 Slow-path MBOX MQ */

 Slow-path ELS response CQ */

 Reset max counter */

 Slow-path ELS WQ */

 Slow-path NVME LS response CQ */

 Reset max counter */

 Slow-path NVME LS WQ */

/**

 * lpfc_idiag_que_param_check - queue access command parameter sanity check

 * @q: The pointer to queue structure.

 * @index: The index into a queue entry.

 * @count: The number of queue entries to access.

 *

 * Description:

 * The routine performs sanity check on device queue access method commands.

 *

 * Returns:

 * This function returns -EINVAL when fails the sanity check, otherwise, it

 * returns 0.

 Only support single entry read or browsing */

/**

 * lpfc_idiag_queacc_read_qe - read a single entry from the given queue index

 * @pbuffer: The pointer to buffer to copy the read data into.

 * @len: Length of the buffer.

 * @pque: The pointer to the queue to be read.

 * @index: The index into the queue entry.

 *

 * Description:

 * This routine reads out a single entry from the given queue's index location

 * and copies it into the buffer provided.

 *

 * Returns:

 * This function returns 0 when it fails, otherwise, it returns the length of

 * the data read into the buffer provided.

/**

 * lpfc_idiag_queacc_read - idiag debugfs read port queue

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the data to.

 * @nbytes: The number of bytes to read.

 * @ppos: The position in the file to start reading from.

 *

 * Description:

 * This routine reads data from the @phba device queue memory according to the

 * idiag command, and copies to user @buf. Depending on the queue dump read

 * command setup, it does either a single queue entry read or browing through

 * all entries of the queue.

 *

 * Returns:

 * This function returns the amount of data that was read (this could be less

 * than @nbytes if the end of the file was reached) or a negative error value.

 This is a user read operation */

 Browse the queue starting from index */

 Read a single entry from the queue */

 Browse all entries from the queue */

 Set up the offset for next portion of pci cfg read */

/**

 * lpfc_idiag_queacc_write - Syntax check and set up idiag queacc commands

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the user data from.

 * @nbytes: The number of bytes to get.

 * @ppos: The position in the file to start reading from.

 *

 * This routine get the debugfs idiag command struct from user space and then

 * perform the syntax check for port queue read (dump) or write (set) command

 * accordingly. In the case of port queue read command, it sets up the command

 * in the idiag command struct for the following debugfs read operation. In

 * the case of port queue write operation, it executes the write operation

 * into the port queue entry accordingly.

 *

 * It returns the @nbytges passing in from debugfs user space when successful.

 * In case of error conditions, it returns proper error code back to the user

 * space.

 This is a user write operation */

 Get and sanity check on command feilds */

 Sanity check on command line arguments */

 HBA event queue */

 Sanity check */

 MBX complete queue */

 Sanity check */

 ELS complete queue */

 Sanity check */

 NVME LS complete queue */

 Sanity check */

 FCP complete queue */

 Sanity check */

 MBX work queue */

 Sanity check */

 ELS work queue */

 Sanity check */

 NVME LS work queue */

 Sanity check */

 FCP/SCSI work queue */

 Sanity check */

 HDR queue */

 Sanity check */

 DAT queue */

 Sanity check */

 Additional sanity checks on write operation */

 Clean out command structure on command error out */

/**

 * lpfc_idiag_drbacc_read_reg - idiag debugfs read a doorbell register

 * @phba: The pointer to hba structure.

 * @pbuffer: The pointer to the buffer to copy the data to.

 * @len: The length of bytes to copied.

 * @drbregid: The id to doorbell registers.

 *

 * Description:

 * This routine reads a doorbell register and copies its content to the

 * user buffer pointed to by @pbuffer.

 *

 * Returns:

 * This function returns the amount of data that was copied into @pbuffer.

/**

 * lpfc_idiag_drbacc_read - idiag debugfs read port doorbell

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the data to.

 * @nbytes: The number of bytes to read.

 * @ppos: The position in the file to start reading from.

 *

 * Description:

 * This routine reads data from the @phba device doorbell register according

 * to the idiag command, and copies to user @buf. Depending on the doorbell

 * register read command setup, it does either a single doorbell register

 * read or dump all doorbell registers.

 *

 * Returns:

 * This function returns the amount of data that was read (this could be less

 * than @nbytes if the end of the file was reached) or a negative error value.

 This is a user read operation */

/**

 * lpfc_idiag_drbacc_write - Syntax check and set up idiag drbacc commands

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the user data from.

 * @nbytes: The number of bytes to get.

 * @ppos: The position in the file to start reading from.

 *

 * This routine get the debugfs idiag command struct from user space and then

 * perform the syntax check for port doorbell register read (dump) or write

 * (set) command accordingly. In the case of port queue read command, it sets

 * up the command in the idiag command struct for the following debugfs read

 * operation. In the case of port doorbell register write operation, it

 * executes the write operation into the port doorbell register accordingly.

 *

 * It returns the @nbytges passing in from debugfs user space when successful.

 * In case of error conditions, it returns proper error code back to the user

 * space.

 This is a user write operation */

 Sanity check on command line arguments */

 Perform the write access operation */

 flush */

 Clean out command structure on command error out */

/**

 * lpfc_idiag_ctlacc_read_reg - idiag debugfs read a control registers

 * @phba: The pointer to hba structure.

 * @pbuffer: The pointer to the buffer to copy the data to.

 * @len: The length of bytes to copied.

 * @ctlregid: The id to doorbell registers.

 *

 * Description:

 * This routine reads a control register and copies its content to the

 * user buffer pointed to by @pbuffer.

 *

 * Returns:

 * This function returns the amount of data that was copied into @pbuffer.

/**

 * lpfc_idiag_ctlacc_read - idiag debugfs read port and device control register

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the data to.

 * @nbytes: The number of bytes to read.

 * @ppos: The position in the file to start reading from.

 *

 * Description:

 * This routine reads data from the @phba port and device registers according

 * to the idiag command, and copies to user @buf.

 *

 * Returns:

 * This function returns the amount of data that was read (this could be less

 * than @nbytes if the end of the file was reached) or a negative error value.

 This is a user read operation */

/**

 * lpfc_idiag_ctlacc_write - Syntax check and set up idiag ctlacc commands

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the user data from.

 * @nbytes: The number of bytes to get.

 * @ppos: The position in the file to start reading from.

 *

 * This routine get the debugfs idiag command struct from user space and then

 * perform the syntax check for port and device control register read (dump)

 * or write (set) command accordingly.

 *

 * It returns the @nbytges passing in from debugfs user space when successful.

 * In case of error conditions, it returns proper error code back to the user

 * space.

 This is a user write operation */

 Sanity check on command line arguments */

 Perform the write access operation */

 flush */

 Clean out command structure on command error out */

/**

 * lpfc_idiag_mbxacc_get_setup - idiag debugfs get mailbox access setup

 * @phba: Pointer to HBA context object.

 * @pbuffer: Pointer to data buffer.

 *

 * Description:

 * This routine gets the driver mailbox access debugfs setup information.

 *

 * Returns:

 * This function returns the amount of data that was read (this could be less

 * than @nbytes if the end of the file was reached) or a negative error value.

/**

 * lpfc_idiag_mbxacc_read - idiag debugfs read on mailbox access

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the data to.

 * @nbytes: The number of bytes to read.

 * @ppos: The position in the file to start reading from.

 *

 * Description:

 * This routine reads data from the @phba driver mailbox access debugfs setup

 * information.

 *

 * Returns:

 * This function returns the amount of data that was read (this could be less

 * than @nbytes if the end of the file was reached) or a negative error value.

 This is a user read operation */

/**

 * lpfc_idiag_mbxacc_write - Syntax check and set up idiag mbxacc commands

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the user data from.

 * @nbytes: The number of bytes to get.

 * @ppos: The position in the file to start reading from.

 *

 * This routine get the debugfs idiag command struct from user space and then

 * perform the syntax check for driver mailbox command (dump) and sets up the

 * necessary states in the idiag command struct accordingly.

 *

 * It returns the @nbytges passing in from debugfs user space when successful.

 * In case of error conditions, it returns proper error code back to the user

 * space.

 This is a user write operation */

 Sanity check on command line arguments */

 condition for stop mailbox dump */

 Clean out command structure on command error out */

 Clean out command structure on command error out */

/**

 * lpfc_idiag_extacc_avail_get - get the available extents information

 * @phba: pointer to lpfc hba data structure.

 * @pbuffer: pointer to internal buffer.

 * @len: length into the internal buffer data has been copied.

 *

 * Description:

 * This routine is to get the available extent information.

 *

 * Returns:

 * overall length of the data read into the internal buffer.

/**

 * lpfc_idiag_extacc_alloc_get - get the allocated extents information

 * @phba: pointer to lpfc hba data structure.

 * @pbuffer: pointer to internal buffer.

 * @len: length into the internal buffer data has been copied.

 *

 * Description:

 * This routine is to get the allocated extent information.

 *

 * Returns:

 * overall length of the data read into the internal buffer.

/**

 * lpfc_idiag_extacc_drivr_get - get driver extent information

 * @phba: pointer to lpfc hba data structure.

 * @pbuffer: pointer to internal buffer.

 * @len: length into the internal buffer data has been copied.

 *

 * Description:

 * This routine is to get the driver extent information.

 *

 * Returns:

 * overall length of the data read into the internal buffer.

/**

 * lpfc_idiag_extacc_write - Syntax check and set up idiag extacc commands

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the user data from.

 * @nbytes: The number of bytes to get.

 * @ppos: The position in the file to start reading from.

 *

 * This routine get the debugfs idiag command struct from user space and then

 * perform the syntax check for extent information access commands and sets

 * up the necessary states in the idiag command struct accordingly.

 *

 * It returns the @nbytges passing in from debugfs user space when successful.

 * In case of error conditions, it returns proper error code back to the user

 * space.

 This is a user write operation */

 Clean out command structure on command error out */

/**

 * lpfc_idiag_extacc_read - idiag debugfs read access to extent information

 * @file: The file pointer to read from.

 * @buf: The buffer to copy the data to.

 * @nbytes: The number of bytes to read.

 * @ppos: The position in the file to start reading from.

 *

 * Description:

 * This routine reads data from the proper extent information according to

 * the idiag command, and copies to user @buf.

 *

 * Returns:

 * This function returns the amount of data that was read (this could be less

 * than @nbytes if the end of the file was reached) or a negative error value.

 This is a user read operation */

 Dump the first 32 bytes */

 Table is getting updated */

/*

 * File operations for the iDiag debugfs

/* lpfc_idiag_mbxacc_dump_bsg_mbox - idiag debugfs dump bsg mailbox command

 * @phba: Pointer to HBA context object.

 * @dmabuf: Pointer to a DMA buffer descriptor.

 *

 * Description:

 * This routine dump a bsg pass-through non-embedded mailbox command with

 * external buffer.

 dump buffer content */

 Clean out command structure on reaching dump count */

/* lpfc_idiag_mbxacc_dump_issue_mbox - idiag debugfs dump issue mailbox command

 * @phba: Pointer to HBA context object.

 * @dmabuf: Pointer to a DMA buffer descriptor.

 *

 * Description:

 * This routine dump a pass-through non-embedded mailbox command from issue

 * mailbox command.

 dump buffer content */

 Clean out command structure on reaching dump count */

/**

 * lpfc_debugfs_initialize - Initialize debugfs for a vport

 * @vport: The vport pointer to initialize.

 *

 * Description:

 * When Debugfs is configured this routine sets up the lpfc debugfs file system.

 * If not already created, this routine will create the lpfc directory, and

 * lpfcX directory (for this HBA), and vportX directory for this vport. It will

 * also create each file used to access lpfc specific debugfs information.

 Setup lpfc root directory */

 Setup funcX directory for specific HBA PCI function */

 Multi-XRI pools */

 Congestion Info Buffer */

 RX Monitor */

 RAS log */

 Setup hbqinfo */

 Setup lockstat */

 Setup dumpHBASlim */

 Setup dumpHostSlim */

 Setup DIF Error Injections */

 Setup slow ring trace */

 Change to be a power of 2 */

 Change to be a power of 2 */

 Allocate trace buffer and initialize */

 Change to be a power of 2 */

	/*

	 * The following section is for additional directories/files for the

	 * physical port.

	/*

	 * iDiag debugfs root entry points for SLI4 device only

 Initialize iDiag data structure */

 iDiag read PCI config space */

 iDiag PCI BAR access */

 iDiag get PCI function queue information */

 iDiag access PCI function queue */

 iDiag access PCI function doorbell registers */

 iDiag access PCI function control registers */

 iDiag access mbox commands */

 iDiag extents access commands */

/**

 * lpfc_debugfs_terminate -  Tear down debugfs infrastructure for this vport

 * @vport: The vport pointer to remove from debugfs.

 *

 * Description:

 * When Debugfs is configured this routine removes debugfs file system elements

 * that are specific to this vport. It also checks to see if there are any

 * users left for the debugfs directories associated with the HBA and driver. If

 * this is the last user of the HBA directory or driver directory then it will

 * remove those from the debugfs infrastructure as well.

 discovery_trace */

 nodelist */

 nvmestat */

 scsistat */

 ioktime */

 hdwqstat */

 vportX */

 multixripools*/

 hbqinfo */

 lockstat */

 HBASlim */

 HostSlim */

 InjErrLBA */

 InjErrWWPN */

 writeGuard */

 writeApp */

 writeRef */

 readGuard */

 readApp */

 readRef */

 slow_ring_trace */

		/*

		 * iDiag release

 iDiag extAcc */

 iDiag mbxAcc */

 iDiag ctlAcc */

 iDiag drbAcc */

 iDiag queAcc */

 iDiag queInfo */

 iDiag barAcc */

 iDiag pciCfg */

 Finally remove the iDiag debugfs root */

 fnX */

 lpfc */

/*

 * Driver debug utility routines outside of debugfs. The debug utility

 * routines implemented here is intended to be used in the instrumented

 * debug driver for debugging host or port issues.

/**

 * lpfc_debug_dump_all_queues - dump all the queues with a hba

 * @phba: Pointer to HBA context object.

 *

 * This function dumps entries of all the queues asociated with the @phba.

	/*

	 * Dump Work Queues (WQs)

	/*

	 * Dump Complete Queues (CQs)

	/*

	 * Dump Event Queues (EQs)

/*******************************************************************

 * This file is part of the Emulex Linux Device Driver for         *

 * Fibre Channel Host Bus Adapters.                                *

 * Copyright (C) 2017-2021 Broadcom. All Rights Reserved. The term *

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.  *

 * Copyright (C) 2004-2016 Emulex.  All rights reserved.           *

 * EMULEX and SLI are trademarks of Emulex.                        *

 * www.broadcom.com                                                *

 * Portions Copyright (C) 2004-2005 Christoph Hellwig              *

 *                                                                 *

 * This program is free software; you can redistribute it and/or   *

 * modify it under the terms of version 2 of the GNU General       *

 * Public License as published by the Free Software Foundation.    *

 * This program is distributed in the hope that it will be useful. *

 * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *

 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *

 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *

 * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *

 * TO BE LEGALLY INVALID.  See the GNU General Public License for  *

 * more details, a copy of which can be found in the file COPYING  *

 * included with this package.                                     *

 NVME initiator-based functions */

/**

 * lpfc_nvme_create_queue -

 * @pnvme_lport: Transport localport that LS is to be issued from

 * @qidx: An cpu index used to affinitize IO queues and MSIX vectors.

 * @qsize: Size of the queue in bytes

 * @handle: An opaque driver handle used in follow-up calls.

 *

 * Driver registers this routine to preallocate and initialize any

 * internal data structures to bind the @qidx to its internal IO queues.

 * A hardware queue maps (qidx) to a specific driver MSI-X vector/EQ/CQ/WQ.

 *

 * Return value :

 *   0 - Success

 *   -EINVAL - Unsupported input value.

 *   -ENOMEM - Could not alloc necessary memory

	/*

	 * NVME qidx == 0 is the admin queue, so both admin queue

	 * and first IO queue will use MSI-X vector and associated

	 * EQ/CQ/WQ at index 0. After that they are sequentially assigned.

 IO queue */

 Admin queue */

/**

 * lpfc_nvme_delete_queue -

 * @pnvme_lport: Transport localport that LS is to be issued from

 * @qidx: An cpu index used to affinitize IO queues and MSIX vectors.

 * @handle: An opaque driver handle from lpfc_nvme_create_queue

 *

 * Driver registers this routine to free

 * any internal data structures to bind the @qidx to its internal

 * IO queues.

 *

 * Return value :

 *   0 - Success

 *   TODO:  What are the failure codes.

 release any threads waiting for the unreg to complete */

/* lpfc_nvme_remoteport_delete

 *

 * @remoteport: Pointer to an nvme transport remoteport instance.

 *

 * This is a template downcall.  NVME transport calls this function

 * when it has completed the unregistration of a previously

 * registered remoteport.

 *

 * Return value :

 * None

	/* Remove this rport from the lport's list - memory is owned by the

	 * transport. Remove the ndlp reference for the NVME transport before

	 * calling state machine to remove the node.

	/* The register rebind might have occurred before the delete

	 * downcall.  Guard against this race.

	/* On a devloss timeout event, one more put is executed provided the

	 * NVME and SCSI rport unregister requests are complete.  If the vport

	 * is unloading, this extra put is executed by lpfc_drop_node.

/**

 * lpfc_nvme_handle_lsreq - Process an unsolicited NVME LS request

 * @phba: pointer to lpfc hba data structure.

 * @axchg: pointer to exchange context for the NVME LS request

 *

 * This routine is used for processing an asychronously received NVME LS

 * request. Any remaining validation is done and the LS is then forwarded

 * to the nvme-fc transport via nvme_fc_rcv_ls_req().

 *

 * The calling sequence should be: nvme_fc_rcv_ls_req() -> (processing)

 * -> lpfc_nvme_xmt_ls_rsp/cmp -> req->done.

 * __lpfc_nvme_xmt_ls_rsp_cmp should free the allocated axchg.

 *

 * Returns 0 if LS was handled and delivered to the transport

 * Returns 1 if LS failed to be handled and should be dropped

/**

 * __lpfc_nvme_ls_req_cmp - Generic completion handler for a NVME

 *        LS request.

 * @phba: Pointer to HBA context object

 * @vport: The local port that issued the LS

 * @cmdwqe: Pointer to driver command WQE object.

 * @wcqe: Pointer to driver response CQE object.

 *

 * This function is the generic completion handler for NVME LS requests.

 * The function updates any states and statistics, calls the transport

 * ls_req done() routine, then tears down the command and buffers used

 * for the LS request.

 Allocate buffer for  command WQE */

 Initialize only 64 bytes */

 Save for completion so we can release these resources */

 Fill in payload, bp points to frame payload */

 FC spec states we need 3 * ratov for CT requests */

 For this command calculate the xmit length of the request bde. */

 Words 0 - 2 */

 Word 3 */

 Word 4 */

 Word 5 */

 Word 6 */

 Word 7 */

 Word 8 */

 Word 9 */

 Word 10 */

 Word 11 */

 Issue GEN REQ WQE for NPORT <did> */

/**

 * __lpfc_nvme_ls_req - Generic service routine to issue an NVME LS request

 * @vport: The local port issuing the LS

 * @ndlp: The remote port to send the LS to

 * @pnvme_lsreq: Pointer to LS request structure from the transport

 * @gen_req_cmp: Completion call-back

 *

 * Routine validates the ndlp, builds buffers and sends a GEN_REQUEST

 * WQE to perform the LS operation.

 *

 * Return value :

 *   0 - Success

 *   non-zero: various error codes, in form of -Exxx

	/*

	 * there are two dma buf in the request, actually there is one and

	 * the second one is just the start address + cmd size.

	 * Before calling lpfc_nvme_gen_req these buffers need to be wrapped

	 * in a lpfc_dmabuf struct. When freeing we just free the wrapper

	 * because the nvem layer owns the data bufs.

	 * We do not have to break these packets open, we don't care what is

	 * in them. And we do not have to look at the resonse data, we only

	 * care that we got a response. All of the caring is going to happen

	 * in the nvme-fc layer.

/**

 * lpfc_nvme_ls_req - Issue an NVME Link Service request

 * @pnvme_lport: Transport localport that LS is to be issued from.

 * @pnvme_rport: Transport remoteport that LS is to be sent to.

 * @pnvme_lsreq: the transport nvme_ls_req structure for the LS

 *

 * Driver registers this routine to handle any link service request

 * from the nvme_fc transport to a remote nvme-aware port.

 *

 * Return value :

 *   0 - Success

 *   non-zero: various error codes, in form of -Exxx

/**

 * __lpfc_nvme_ls_abort - Generic service routine to abort a prior

 *         NVME LS request

 * @vport: The local port that issued the LS

 * @ndlp: The remote port the LS was sent to

 * @pnvme_lsreq: Pointer to LS request structure from the transport

 *

 * The driver validates the ndlp, looks for the LS, and aborts the

 * LS if found.

 *

 * Returns:

 * 0 : if LS found and aborted

 * non-zero: various error conditions in form -Exxx

	/*

	 * Lock the ELS ring txcmplq and look for the wqe that matches

	 * this ELS. If found, issue an abort on the wqe.

		/*

		 * unless the failure is due to having already sent

		 * the response, an abort will be generated for the

		 * exchange if the rsp can't be sent.

/**

 * lpfc_nvme_ls_abort - Abort a prior NVME LS request

 * @pnvme_lport: Transport localport that LS is to be issued from.

 * @pnvme_rport: Transport remoteport that LS is to be sent to.

 * @pnvme_lsreq: the transport nvme_ls_req structure for the LS

 *

 * Driver registers this routine to abort a NVME LS request that is

 * in progress (from the transports perspective).

 Fix up the existing sgls for NVME IO. */

	/*

	 * Get a local pointer to the built-in wqe and correct

	 * the cmd size to match NVME's 96 bytes and fix

	 * the dma address.

	/*

	 * Adjust the FCP_CMD and FCP_RSP DMA data and sge_len to

	 * match NVME.  NVME sends 96 bytes. Also, use the

	 * nvme commands command and response dma addresses

	 * rather than the virtual memory to ease the restore

	 * operation.

 Word 0-2 - NVME CMND IU (embedded payload) */

 Word 16 */

 Word 10  - dbde is 0, wqes is 1 in template */

		/*

		 * Embed the payload in the last half of the WQE

		 * WQE words 16-30 get the NVME CMD IU payload

		 *

		 * WQE words 16-19 get payload Words 1-4

		 * WQE words 20-21 get payload Words 6-7

		 * WQE words 22-29 get payload Words 16-23

 WQE ptr */

 payload ptr */

 Skip Word 0 in payload */

 Word 1 */

 Word 2 */

 Word 3 */

 Word 4 */

 Skip Word 5 in payload */

 Word 6 */

 Word 7 */

 Skip Words 8-15 in payload */

 Word 16 */

 Word 17 */

 Word 18 */

 Word 19 */

 Word 20 */

 Word 21 */

 Word 22 */

 Word 23 */

 Word 0-2 - NVME CMND IU Inline BDE */

 Word 10 */

 Setup the physical region for the FCP RSP */

/*

 * lpfc_nvme_io_cmd_wqe_cmpl - Complete an NVME-over-FCP IO

 *

 * Driver registers this routine as it io request handler.  This

 * routine issues an fcp WQE with data from the @lpfc_nvme_fcpreq

 * data structure to the rport indicated in @lpfc_nvme_rport.

 *

 * Return value :

 *   0 - Success

 *   TODO: What are the failure codes.

 Sanity check on return of outstanding command */

 Guard against abort handler being called at same time */

 Release the lpfc_ncmd regardless of the missing elements. */

	/*

	 * Catch race where our node has transitioned, but the

	 * transport is still transitioning.

 For this type of CQE, we need to rebuild the rsp */

		/*

		 * Get Command Id from cmd to plug into response. This

		 * code is not needed in the next NVME Transport drop.

		/*

		 * RSN is in CQE word 2

		 * SQHD is in CQE Word 3 bits 15:0

		 * Cmd Specific info is in CQE Word 1

		 * and in CQE Word 0 bits 15:0

 Now lets build the NVME ERSP IU */

		/* For NVME, the only failure path that results in an

		 * IO error is when the adapter rejects it.  All other

		 * conditions are a success case and resolved by the

		 * transport.

		 * IOSTAT_FCP_RSP_ERROR means:

		 * 1. Length of data received doesn't match total

		 *    transfer length in WQE

		 * 2. If the RSP payload does NOT match these cases:

		 *    a. RSP length 12/24 bytes and all zeros

		 *    b. NVME ERSP

 Check if this is really an ERSP */

 Let fall through to set command final state. */

 pick up SLI4 exhange busy condition */

	/* Update stats and complete the IO.  There is

	 * no need for dma unprep because the nvme_transport

	 * owns the dma address.

	/* NVME targets need completion held off until the abort exchange

	 * completes unless the NVME Rport is getting unregistered.

 Check if IO qualified for CMF */

 Used when calculating average latency */

 Call release with XB=1 to queue the IO into the abort list. */

/**

 * lpfc_nvme_prep_io_cmd - Issue an NVME-over-FCP IO

 * @vport: pointer to a host virtual N_Port data structure

 * @lpfc_ncmd: Pointer to lpfc scsi command

 * @pnode: pointer to a node-list data structure

 * @cstat: pointer to the control status structure

 *

 * Driver registers this routine as it io request handler.  This

 * routine issues an fcp WQE with data from the @lpfc_nvme_fcpreq

 * data structure to the rport indicated in @lpfc_nvme_rport.

 *

 * Return value :

 *   0 - Success

 *   TODO: What are the failure codes.

	/*

	 * There are three possibilities here - use scatter-gather segment, use

	 * the single mapping, or neither.

 From the iwrite template, initialize words 7 - 11 */

 Word 4 */

 Word 5 */

 From the iread template, initialize words 7 - 11 */

 Word 4 */

 Word 5 */

 For a CMF Managed port, iod must be zero'ed */

 From the icmnd template, initialize words 4 - 11 */

	/*

	 * Finish initializing those WQE fields that are independent

	 * of the nvme_cmnd request_buffer

 Word 3 */

 Word 6 */

 Word 8 */

 Word 9 */

 Word 10 */

 Words 13 14 15 are for PBDE support */

/**

 * lpfc_nvme_prep_io_dma - Issue an NVME-over-FCP IO

 * @vport: pointer to a host virtual N_Port data structure

 * @lpfc_ncmd: Pointer to lpfc scsi command

 *

 * Driver registers this routine as it io request handler.  This

 * routine issues an fcp WQE with data from the @lpfc_nvme_fcpreq

 * data structure to the rport indicated in @lpfc_nvme_rport.

 *

 * Return value :

 *   0 - Success

 *   TODO: What are the failure codes.

 Fix up the command and response DMA stuff. */

	/*

	 * There are three possibilities here - use scatter-gather segment, use

	 * the single mapping, or neither.

		/*

		 * Jump over the cmd and rsp SGEs.  The fix routine

		 * has already adjusted for this.

		/*

		 * The driver established a maximum scatter-gather segment count

		 * during probe that limits the number of sg elements in any

		 * single nvme command.  Just run through the seg_cnt and format

		 * the sge's.

 for tracking the segment boundaries */

 expand the segment */

 set LSP type */

 PBDE support for first data SGE only */

 Words 13-15 */

 Word 11 - set PBDE bit */

 Word 11 - PBDE bit disabled by default template */

		/* For this clause to be valid, the payload_length

		 * and sg_cnt must zero.

/**

 * lpfc_nvme_fcp_io_submit - Issue an NVME-over-FCP IO

 * @pnvme_lport: Pointer to the driver's local port data

 * @pnvme_rport: Pointer to the rport getting the @lpfc_nvme_ereq

 * @hw_queue_handle: Driver-returned handle in lpfc_nvme_create_queue

 * @pnvme_fcreq: IO request from nvme fc to driver.

 *

 * Driver registers this routine as it io request handler.  This

 * routine issues an fcp WQE with data from the @lpfc_nvme_fcpreq

 * data structure to the rport indicated in @lpfc_nvme_rport.

 *

 * Return value :

 *   0 - Success

 *   TODO: What are the failure codes.

	/* Validate pointers. LLDD fault handling with transport does

	 * have timing races.

	/*

	 * Catch race where our node has transitioned, but the

	 * transport is still transitioning.

 The remote node has to be a mapped target or it's an error. */

	/* Currently only NVME Keep alive commands should be expedited

	 * if the driver runs out of a resource. These should only be

	 * issued on the admin queue, qidx 0

 Check if IO qualifies for CMF */

 Get start time for IO latency */

	/* The node is shared with FCP IO, make sure the IO pending count does

	 * not exceed the programmed depth.

 Lookup Hardware Queue index based on fcp_io_sched module parameter */

	/*

	 * Store the data needed by the driver to issue, abort, and complete

	 * an IO.

	 * Do not let the IO hang out forever.  There is no midlayer issuing

	 * an abort so inform the FW of the maximum IO pending time.

	/*

	 * Issue the IO on the WQ indicated by index in the hw_queue_handle.

	 * This identfier was create in our hardware queue create callback

	 * routine. The driver now is dependent on the IO queue steering from

	 * the transport.  We are trusting the upper NVME layers know which

	 * index to use and that they have affinitized a CPU to this hardware

	 * queue. A hardware queue maps to a driver MSI-X vector/EQ/CQ/WQ.

/**

 * lpfc_nvme_abort_fcreq_cmpl - Complete an NVME FCP abort request.

 * @phba: Pointer to HBA context object

 * @cmdiocb: Pointer to command iocb object.

 * @abts_cmpl: Pointer to wcqe complete object.

 *

 * This is the callback function for any NVME FCP IO that was aborted.

 *

 * Return value:

 *   None

/**

 * lpfc_nvme_fcp_abort - Issue an NVME-over-FCP ABTS

 * @pnvme_lport: Pointer to the driver's local port data

 * @pnvme_rport: Pointer to the rport getting the @lpfc_nvme_ereq

 * @hw_queue_handle: Driver-returned handle in lpfc_nvme_create_queue

 * @pnvme_fcreq: IO request from nvme fc to driver.

 *

 * Driver registers this routine as its nvme request io abort handler.  This

 * routine issues an fcp Abort WQE with data from the @lpfc_nvme_fcpreq

 * data structure to the rport indicated in @lpfc_nvme_rport.  This routine

 * is executed asynchronously - one the target is validated as "MAPPED" and

 * ready for IO, the driver issues the abort request and returns.

 *

 * Return value:

 *   None

	/* Validate pointers. LLDD fault handling with transport does

	 * have timing races.

 Announce entry to new IO submit field. */

	/* If the hba is getting reset, this flag is set.  It is

	 * cleared when the reset is complete and rings reestablished.

 driver queued commands are in process of being flushed */

 Guard against IO completion being called at same time */

	/*

	 * The lpfc_nbuf and the mapped nvme_fcreq in the driver's

	 * state must match the nvme_fcreq passed by the nvme

	 * transport.  If they don't match, it is likely the driver

	 * has already completed the NVME IO and the nvme transport

	 * has not seen it yet.

 Don't abort IOs no longer on the pending queue. */

 Outstanding abort is in progress */

 Make sure HBA is alive */

 Declare and initialization an instance of the FC NVME template. */

 initiator-based functions */

	/* Sizes of additional private data for data structures.

	 * No use for the last two sizes at this time.

/*

 * lpfc_get_nvme_buf - Get a nvme buffer from io_buf_list of the HBA

 *

 * This routine removes a nvme buffer from head of @hdwq io_buf_list

 * and returns to caller.

 *

 * Return codes:

 *   NULL - Error

 *   Pointer to lpfc_nvme_buf - Success

		/* Setup key fields in buffer that may have been changed

		 * if other protocols used this buffer.

		/* Rsp SGE will be filled in when we rcv an IO

		 * from the NVME Layer to be sent.

		 * The cmd is going to be embedded so we need a SKIP SGE.

 Fill in word 3 / sgl_len during cmd submission */

 Initialize 64 bytes only */

/**

 * lpfc_release_nvme_buf: Return a nvme buffer back to hba nvme buf list.

 * @phba: The Hba for which this call is being executed.

 * @lpfc_ncmd: The nvme buffer which is being released.

 *

 * This routine releases @lpfc_ncmd nvme buffer by adding it to tail of @phba

 * lpfc_io_buf_list list. For SLI4 XRI's are tied to the nvme buffer

 * and cannot be reused for at least RA_TOV amount of time if it was

 * aborted.

/**

 * lpfc_nvme_create_localport - Create/Bind an nvme localport instance.

 * @vport: the lpfc_vport instance requesting a localport.

 *

 * This routine is invoked to create an nvme localport instance to bind

 * to the nvme_fc_transport.  It is called once during driver load

 * like lpfc_create_shost after all other services are initialized.

 * It requires a vport, vpi, and wwns at call time.  Other localport

 * parameters are modified as the driver's FCID and the Fabric WWN

 * are established.

 *

 * Return codes

 *      0 - successful

 *      -ENOMEM - no heap memory available

 *      other values - from nvme registration upcall

	/* Initialize this localport instance.  The vport wwn usage ensures

	 * that NPIV is accounted for.

	/* We need to tell the transport layer + 1 because it takes page

	 * alignment into account. When space for the SGL is allocated we

	 * allocate + 3, one for cmd, one for rsp and one for this alignment

	/* Advertise how many hw queues we support based on cfg_hdw_queue,

	 * which will not exceed cpu count.

	/* localport is allocated from the stack, but the registration

	 * call allocates heap memory as well as the private area.

 Private is our lport size declared in the template. */

/* lpfc_nvme_lport_unreg_wait - Wait for the host to complete an lport unreg.

 *

 * The driver has to wait for the host nvme transport to callback

 * indicating the localport has successfully unregistered all

 * resources.  Since this is an uninterruptible wait, loop every ten

 * seconds and print a message indicating no progress.

 *

 * An uninterruptible wait is used because of the risk of transport-to-

 * driver state mismatch.

	/* Host transport has to clean up and confirm requiring an indefinite

	 * wait. Print a message if a 10 second wait expires and renew the

	 * wait. This is unexpected.

/**

 * lpfc_nvme_destroy_localport - Destroy lpfc_nvme bound to nvme transport.

 * @vport: pointer to a host virtual N_Port data structure

 *

 * This routine is invoked to destroy all lports bound to the phba.

 * The lport memory was allocated by the nvme fc transport and is

 * released there.  This routine ensures all rports bound to the

 * lport have been disconnected.

 *

	/* lport's rport list is clear.  Unregister

	 * lport and release resources.

	/* Wait for completion.  This either blocks

	 * indefinitely or succeeds

	/* Regardless of the unregister upcall response, clear

	 * nvmei_support.  All rports are unregistered and the

	 * driver will clean up.

	/* NVME rports are not preserved across devloss.

	 * Just register this instance.  Note, rpinfo->dev_loss_tmo

	 * is left 0 to indicate accept transport defaults.  The

	 * driver communicates port role capabilities consistent

	 * with the PRLI response data.

		/* If the ndlp already has an nrport, this is just

		 * a resume of the existing rport.  Else this is a

		 * new rport.

		/* Guard against an unregister/reregister

		 * race that leaves the WAIT flag set.

			/* Sever the ndlp<->rport association

			 * before dropping the ndlp ref from

			 * register.

			/* Reference only removed if previous NDLP is no longer

			 * active. It might be just a swap and removing the

			 * reference would cause a premature cleanup.

 Clean bind the rport to the ndlp. */

/*

 * lpfc_nvme_rescan_port - Check to see if we should rescan this remoteport

 *

 * If the ndlp represents an NVME Target, that we are logged into,

 * ping the NVME FC Transport layer to initiate a device rescan

 * on this remote NPort.

 Only rescan if we are an NVME target in the MAPPED state */

/* lpfc_nvme_unregister_port - unbind the DID and port_role from this rport.

 *

 * There is no notion of Devloss or rport recovery from the current

 * nvme_transport perspective.  Loss of an rport just means IO cannot

 * be sent and recovery is completely up to the initator.

 * For now, the driver just unbinds the DID and port_role so that

 * no further IO can be issued.  Changes are planned for later.

 *

 * Notes - the ndlp reference count is not decremented here since

 * since there is no nvme_transport api for devloss.  Node ref count

 * is only adjusted in driver unload.

	/* This is fundamental error.  The localport is always

	 * available until driver unload.  Just exit.

	/* Sanity check ndlp type.  Only call for NVME ports. Don't

	 * clear any rport state until the transport calls back.

		/* No concern about the role change on the nvme remoteport.

		 * The transport will update it.

		/* Don't let the host nvme transport keep sending keep-alives

		 * on this remoteport. Vport is unloading, no recovery. The

		 * return values is ignored.  The upcall is a courtesy to the

		 * transport.

		/* The driver no longer knows if the nrport memory is valid.

		 * because the controller teardown process has begun and

		 * is asynchronous.  Break the binding in the ndlp. Also

		 * remove the register ndlp reference to setup node release.

/**

 * lpfc_sli4_nvme_pci_offline_aborted - Fast-path process of NVME xri abort

 * @phba: pointer to lpfc hba data structure.

 * @lpfc_ncmd: The nvme job structure for the request being aborted.

 *

 * This routine is invoked by the worker thread to process a SLI4 fast-path

 * NVME aborted xri.  Aborted NVME IO commands are completed to the transport

 * here.

	/* Aborted NVME commands are required to not complete

	 * before the abort exchange command fully completes.

	 * Once completed, it is available via the put list.

/**

 * lpfc_sli4_nvme_xri_aborted - Fast-path process of NVME xri abort

 * @phba: pointer to lpfc hba data structure.

 * @axri: pointer to the fcp xri abort wcqe structure.

 * @lpfc_ncmd: The nvme job structure for the request being aborted.

 *

 * This routine is invoked by the worker thread to process a SLI4 fast-path

 * NVME aborted xri.  Aborted NVME IO commands are completed to the transport

 * here.

	/* Aborted NVME commands are required to not complete

	 * before the abort exchange command fully completes.

	 * Once completed, it is available via the put list.

/**

 * lpfc_nvme_wait_for_io_drain - Wait for all NVME wqes to complete

 * @phba: Pointer to HBA context object.

 *

 * This function flushes all wqes in the nvme rings and frees all resources

 * in the txcmplq. This function does not issue abort wqes for the IO

 * commands in txcmplq, they will just be returned with

 * IOERR_SLI_DOWN. This function is invoked with EEH when device's PCI

 * slot has been permanently disabled.

	/* Cycle through all IO rings and make sure all outstanding

	 * WQEs have been removed from the txcmplqs.

 Retrieve everything on the txcmplq */

			/* The sleep is 10mS.  Every ten seconds,

			 * dump a message.  Something is wrong.

 Make sure HBA is alive */

 For abort iocb just return, IO iocb will do a done call */

 xb is 0 */

 Call release with XB=1 to queue the IO into the abort list. */

/*******************************************************************

 * This file is part of the Emulex Linux Device Driver for         *

 * Fibre Channel Host Bus Adapters.                                *

 * Copyright (C) 2017-2021 Broadcom. All Rights Reserved. The term *

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.     *

 * Copyright (C) 2004-2016 Emulex.  All rights reserved.           *

 * EMULEX and SLI are trademarks of Emulex.                        *

 * www.broadcom.com                                                *

 * Portions Copyright (C) 2004-2005 Christoph Hellwig              *

 *                                                                 *

 * This program is free software; you can redistribute it and/or   *

 * modify it under the terms of version 2 of the GNU General       *

 * Public License as published by the Free Software Foundation.    *

 * This program is distributed in the hope that it will be useful. *

 * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *

 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *

 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *

 * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *

 * TO BE LEGALLY INVALID.  See the GNU General Public License for  *

 * more details, a copy of which can be found in the file COPYING  *

 * included with this package.                                     *

 Called to verify a rcv'ed ADISC was intended for us. */

 First, we MUST have a RPI registered */

	/* Compare the ADISC rsp WWNN / WWPN matches our internal node

	 * table entry for that node.

 we match, return success */

	/*

	 * The receive data field size and buffer-to-buffer receive data field

	 * size entries are 16 bits but are represented as two 8-bit fields in

	 * the driver data structure to account for rsvd bits and other control

	 * bits.  Reconstruct and compare the fields as a 16-bit values before

	 * correcting the byte values.

	/*

	 * Preserve the upper four bits of the MSB from the PLOGI response.

	 * These bits contain the Buffer-to-Buffer State Change Number

	 * from the target and need to be passed to the FW.

	/* For lpfc_els_abort, context2 could be zero'ed to delay

	 * freeing associated memory till after ABTS completes.

 Force ulpStatus error since we are returning NULL ptr */

/*

 * Free resources / clean up outstanding I/Os

 * associated with a LPFC_NODELIST entry. This

 * routine effectively results in a "software abort".

 In case of error recovery path, we might have a NULL pring here */

 Abort outstanding I/O on NPort <nlp_DID> */

 Clean up all fabric IOs first.*/

	/*

	 * Lock the ELS ring txcmplq for SLI3/SLI4 and build a local list

	 * of all ELS IOs that need an ABTS.  The IOs need to stay on the

	 * txcmplq so that the abort operation completes them successfully.

 Add to abort_list on on NDLP match. */

 Abort the targeted IOs and remove them from the abort list. */

 Make sure HBA is alive */

 Now process the txq */

 Check to see if iocb matches the nport we are looking for */

 Cancel all the IOCBs from the completions list */

/* lpfc_defer_plogi_acc - Issue PLOGI ACC after reg_login completes

 * @phba: pointer to lpfc hba data structure.

 * @login_mbox: pointer to REG_RPI mailbox object

 *

 * The ACC for a rcv'ed PLOGI is deferred until AFTER the REG_RPI completes

		/* Now that REG_RPI completed successfully,

		 * we can now proceed with sending the PLOGI ACC.

 Now process the REG_RPI cmpl */

 Reject this request because invalid parameters */

 PLOGI chkparm OK */

 if already logged in, do implicit logout */

		/* For initiators, lpfc_plogi_confirm_nport skips fabric did.

		 * For target mode, execute implicit logo.

		 * Fabric nodes go into NPR.

			/* Clear ndlp info, since follow up PRLI may have

			 * updated ndlp information

 Notify transport of connectivity loss to trigger cleanup. */

 rport needs to be unregistered first */

 Check for Nport to NPort pt2pt protocol */

 rcv'ed PLOGI decides what our NPortId will be */

		/* If there is an outstanding FLOGI, abort it now.

		 * The remote NPort is not going to ACC our FLOGI

		 * if its already issuing a PLOGI for pt2pt mode.

		 * This indicates our FLOGI was dropped; however, we

		 * must have ACCed the remote NPorts FLOGI to us

		 * to make it here.

 E_D_TOV ticks are in nanoseconds */

		/*

		 * For pt-to-pt, use the larger EDTOV

		 * RATOV = 2 * EDTOV

		/* Issue CONFIG_LINK for SLI3 or REG_VFI for SLI4,

		 * to account for updated TOV's / parameters

 Save info from cmd IOCB to be used in rsp after all mbox completes */

 Registering an existing RPI behaves differently for SLI3 vs SLI4 */

	/* Issue REG_LOGIN first, before ACCing the PLOGI, thus we will

	 * always be deferring the ACC.

	/*

	 * If there is an outstanding PLOGI issued, abort it before

	 * sending ACC rsp for received PLOGI. If pending plogi

	 * is not canceled here, the plogi will be rejected by

	 * remote port and will be retried. On a configuration with

	 * single discovery thread, this will cause a huge delay in

	 * discovery. Also this will cause multiple state machines

	 * running in parallel for this node.

	 * This only applies to a fabric environment.

 software abort outstanding PLOGI */

 no deferred ACC */

		/* This is an NPIV SLI4 instance that does not need to register

		 * a default RPI.

			/* In order to preserve RPIs, we want to cleanup

			 * the default RPI the firmware created to rcv

			 * this ELS request. The only way to do this is

			 * to register, then unregister the RPI.

	/* So the order here should be:

	 * SLI3 pt2pt

	 *   Issue CONFIG_LINK mbox

	 *   CONFIG_LINK cmpl

	 * SLI4 pt2pt

	 *   Issue REG_VFI mbox

	 *   REG_VFI cmpl

	 * SLI4

	 *   Issue UNREG RPI mbx

	 *   UNREG RPI cmpl

	 * Issue REG_RPI mbox

	 * REG RPI cmpl

	 * Issue PLOGI ACC

	 * PLOGI ACC cmpl

 For PLOGI ACC */

 Start the ball rolling by issuing REG_LOGIN here */

/**

 * lpfc_mbx_cmpl_resume_rpi - Resume RPI completion routine

 * @phba: pointer to lpfc hba data structure.

 * @mboxq: pointer to mailbox object

 *

 * This routine is invoked to issue a completion to a rcv'ed

 * ADISC or PDISC after the paused RPI has been resumed.

 This nlp_put pairs with lpfc_sli4_resume_rpi */

		/*

		 * As soon as  we send ACC, the remote NPort can

		 * start sending us data. Thus, for SLI4 we must

		 * resume the RPI before the ACC goes out.

 Save info from cmd IOCB used in rsp */

 Save the ELS cmd */

		/* If we are authenticated, move to the proper state.

		 * It is possible an ADISC arrived and the remote nport

		 * is already in MAPPED or UNMAPPED state.  Catch this

		 * condition and don't set the nlp_state again because

		 * it causes an unnecessary transport unregister/register.

		 *

		 * Nodes marked for ADISC will move MAPPED or UNMAPPED state

		 * after issuing ADISC

 Reject this request because invalid parameters */

 1 sec timeout */

 Put ndlp in NPR state with 1 sec timeout for plogi, ACC logo */

	/* Only call LOGO ACC for first LOGO, this avoids sending unnecessary

	 * PLOGIs during LOGO storms from a device.

	/* This clause allows the initiator to ACC the LOGO back to the

	 * Fabric Domain Controller.  It does deliberately skip all other

	 * steps because some fabrics send RDP requests after logging out

	 * from the initiator.

 Notify transport of connectivity loss to trigger cleanup. */

		/*

		 * Don't re-instantiate if vport is marked for deletion.

		 * If we are here first then vport_delete is going to wait

		 * for discovery to complete.

			/*

			 * If there are other active VLinks present,

			 * re-instantiate the Vlink using FDISC.

		/* Only try to re-login if this is NOT a Fabric Node

		 * AND the remote NPORT is a FCP/NVME Target or we

		 * are in pt2pt mode. NLP_STE_ADISC_ISSUE is a special

		 * case for LOGO as a response to ADISC behavior.

 Unregister from backend, could have been skipped due to ADISC */

	/* The driver has to wait until the ACC completes before it continues

	 * processing the LOGO.  The action will resume in

	 * lpfc_cmpl_els_logo_acc routine. Since part of processing includes an

	 * unreg_login, the driver waits so the ACC does not get aborted.

 Must be a NVME PRLI */

 Initiator mode. */

		/* If this driver is in nvme target mode, set the ndlp's fc4

		 * type to NVME provided the PRLI response claims NVME FC4

		 * type.  Target mode does not issue gft_id so doesn't get

		 * the fc4 type set until now.

		/* Fabric Controllers send FCP PRLI as an initiator but should

		 * not get recognized as FCP type and registered with transport.

 We need to update the rport role values */

 Check config parameter use-adisc or FCP-2 */

/**

 * lpfc_release_rpi - Release a RPI by issuing unreg_login mailbox cmd.

 * @phba : Pointer to lpfc_hba structure.

 * @vport: Pointer to lpfc_vport structure.

 * @ndlp: Pointer to lpfc_nodelist structure.

 * @rpi  : rpi to be release.

 *

 * This function will send a unreg_login mailbox command to the firmware

 * to release a rpi.

	/* If there is already an UNREG in progress for this ndlp,

	 * no need to queue up another one.

 Release the RPI if reglogin completing */

	/* This transition is only legal if we previously

	 * rcv'ed a PLOGI. Since we don't want 2 discovery threads

	 * working on the same NPortID, do nothing for this thread

	 * to stop it.

 Start of Discovery State Machine routines */

	/* For a PLOGI, we only accept if our portname is less

	 * than the remote portname.

		/* Reject this request because the remote node will accept

 Check if there are more PLOGIs to be sent */

 If our portname was less */

 Retrieve RPI from LOGO IOCB. RPI is used for CMD_ABORT_XRI_CN */

 software abort outstanding PLOGI */

 software abort outstanding PLOGI */

 Put ndlp in npr state set plogi timer for 1 sec */

 Recovery from PLOGI collision logic */

 Some switches have FDMI servers returning 0 for WWN */

 PLOGI chkparm OK */

 E_D_TOV ticks are in nanoseconds */

		/*

		 * Use the larger EDTOV

		 * RATOV = 2 * EDTOV for pt-to-pt

 Issue config_link / reg_vfi to account for updated TOV's */

 Fabric Controller Node needs these parameters. */

		/* decrement node reference count to the failed mbox

		 * command

	/*

	** In case the node reference counter does not go to zero, ensure that

	** the stale state for the node is not processed.

 Release the RPI */

 software abort outstanding PLOGI */

	/* Don't do anything that will mess up processing of the

	 * previous RSCN.

 software abort outstanding PLOGI */

 software abort outstanding ADISC */

 software abort outstanding ADISC */

 Treat like rcv logo */

 1 sec timeout */

 Stay in state and retry. */

 software abort outstanding ADISC */

	/* Don't do anything that will mess up processing of the

	 * previous RSCN.

 software abort outstanding ADISC */

		/* NVME Target mode.  Handle and respond to the PRLI and

		 * transition to UNMAPPED provided the RPI has completed

		 * registration.

			/* RPI registration has not completed. Reject the PRLI

			 * to prevent an illegal state transition when the

			 * rpi registration does complete.

 Initiator mode. */

 cleanup any ndlp on mbox q waiting for reglogin cmpl */

 software abort if any GID_FT is outstanding */

 RegLogin failed */

		/*

		 * If RegLogin failed due to lack of HBA resources do not

		 * retry discovery.

 Put ndlp in npr state set plogi timer for 1 sec */

 SLI4 ports have preallocated logical rpis. */

 Only if we are not a fabric nport do we issue PRLI */

		/* The driver supports FCP and NVME concurrently.  If the

		 * ndlp's nlp_fc4_type is still zero, the driver doesn't

		 * know what PRLI to send yet.  Figure that out now and

		 * call PRLI depending on the outcome.

			/* If we are pt2pt, there is no Fabric to determine

			 * the FC4 type of the remote nport. So if NVME

			 * is configured try it.

 We need to update the localport also */

			/* If we are only configured for FCP, the driver

			 * should just issue PRLI for FCP. Otherwise issue

			 * GFT_ID to determine if remote port supports NVME.

		/* Only Fabric ports should transition. NVME target

		 * must complete PRLI.

	/* Don't do anything that will mess up processing of the

	 * previous RSCN.

	/* If we are a target we won't immediately transition into PRLI,

	 * so if REG_LOGIN already completed we don't need to ignore it.

 Software abort outstanding PRLI before sending acc */

/* This routine is envoked when we rcv a PRLO request from a nport

 * we are logged into.  We should send back a PRLO rsp setting the

 * appropriate bits.

 * NEXT STATE = PRLI_ISSUE

	/* A solicited PRLI is either FCP or NVME.  The PRLI cmd/rsp

	 * format is different so NULL the two PRLI types so that the

	 * driver correctly gets the correct context.

 Adjust the nlp_type accordingly if the PRLI failed */

 We can't set the DSM state till BOTH PRLIs complete */

 Complete setting up the remote ndlp personality. */

 Target driver cannot solicit NVME FB. */

			/* Complete the nvme target roles.  The transport

			 * needs to know if the rport is capable of

			 * discovery in addition to its role.

			/*

			 * If prli_fba is set, the Target supports FirstBurst.

			 * If prli_fb_sz is 0, the FirstBurst size is unlimited,

			 * otherwise it defines the actual size supported by

			 * the NVME Target.

				/* Both sides support FB. The target's first

				 * burst size is a 512 byte encoded value.

 Expressed in units of 512 bytes */

	/* The ndlp state cannot move to MAPPED or UNMAPPED before all PRLIs

	 * are complete.

/*! lpfc_device_rm_prli_issue

 *

 * \pre

 * \post

 * \param   phba

 * \param   ndlp

 * \param   arg

 * \param   evt

 * \return  uint32_t

 *

 * \b Description:

 *    This routine is envoked when we a request to remove a nport we are in the

 *    process of PRLIing. We should software abort outstanding prli, unreg

 *    login, send a logout. We will change node state to UNUSED_NODE, put it

 *    on plogi list so it can be freed when LOGO completes.

 *

 software abort outstanding PLOGI */

/*! lpfc_device_recov_prli_issue

 *

 * \pre

 * \post

 * \param   phba

 * \param   ndlp

 * \param   arg

 * \param   evt

 * \return  uint32_t

 *

 * \b Description:

 *    The routine is envoked when the state of a device is unknown, like

 *    during a link down. We should remove the nodelist entry from the

 *    unmapped list, issue a UNREG_LOGIN, do a software abort of the

 *    outstanding PRLI command, then free the node entry.

	/* Don't do anything that will mess up processing of the

	 * previous RSCN.

 software abort outstanding PRLI */

	/*

	 * DevLoss has timed out and is calling for Device Remove.

	 * In this case, abort the LOGO and cleanup the ndlp

 software abort outstanding PLOGI */

	/*

	 * Device Recovery events have no meaning for a node with a LOGO

	 * outstanding.  The LOGO has to complete first and handle the

	 * node from that point.

 flush the target */

 Treat like rcv logo */

 Ignore PLOGI if we have an outstanding LOGO */

 send PLOGI immediately, move to PLOGI issue state */

		/*

		 * ADISC nodes will be handled in regular discovery path after

		 * receiving response from NS.

		 *

		 * For other nodes, Send PLOGI to trigger an implicit LOGO.

	/*

	 * Do not start discovery if discovery is about to start

	 * or discovery in progress for this node. Starting discovery

	 * here will affect the counting of discovery threads.

		/*

		 * ADISC nodes will be handled in regular discovery path after

		 * receiving response from NS.

		 *

		 * For other nodes, Send PLOGI to trigger an implicit LOGO.

 For the fabric port just clear the fc flags. */

 SLI4 ports have preallocated logical rpis. */

	/* Don't do anything that will mess up processing of the

	 * previous RSCN.

 This next section defines the NPort Discovery State Machine */

/* There are 4 different double linked lists nodelist entries can reside on.

 * The plogi list and adisc list are used when Link Up discovery or RSCN

 * processing is needed. Each list holds the nodes that we will send PLOGI

 * or ADISC on. These lists will keep track of what nodes will be effected

 * by an RSCN, or a Link Up (Typically, all nodes are effected on Link Up).

 * The unmapped_list will contain all nodes that we have successfully logged

 * into at the Fibre Channel level. The mapped_list will contain all nodes

 * that are mapped FCP targets.

/*

 * The bind list is a list of undiscovered (potentially non-existent) nodes

 * that we have saved binding information on. This information is used when

 * nodes transition from the unmapped to the mapped list.

/* For UNUSED_NODE state, the node has just been allocated .

 * For PLOGI_ISSUE and REG_LOGIN_ISSUE, the node is on

 * the PLOGI list. For REG_LOGIN_COMPL, the node is taken off the PLOGI list

 * and put on the unmapped list. For ADISC processing, the node is taken off

 * the ADISC list and placed on either the mapped or unmapped list (depending

 * on its previous state). Once on the unmapped list, a PRLI is issued and the

 * state changed to PRLI_ISSUE. When the PRLI completion occurs, the state is

 * changed to UNMAPPED_NODE. If the completion indicates a mapped

 * node, the node is taken off the unmapped list. The binding list is checked

 * for a valid binding, or a binding is automatically assigned. If binding

 * assignment is unsuccessful, the node is left on the unmapped list. If

 * binding assignment is successful, the associated binding list entry (if

 * any) is removed, and the node is placed on the mapped list.

/*

 * For a Link Down, all nodes on the ADISC, PLOGI, unmapped or mapped

 * lists will receive a DEVICE_RECOVERY event. If the linkdown or devloss timers

 * expire, all effected nodes will receive a DEVICE_RM event.

/*

 * For a Link Up or RSCN, all nodes will move from the mapped / unmapped lists

 * to either the ADISC or PLOGI list.  After a Nameserver query or ALPA loopmap

 * check, additional nodes may be added or removed (via DEVICE_RM) to / from

 * the PLOGI or ADISC lists. Once the PLOGI and ADISC lists are populated,

 * we will first process the ADISC list.  32 entries are processed initially and

 * ADISC is initited for each one.  Completions / Events for each node are

 * funnelled thru the state machine.  As each node finishes ADISC processing, it

 * starts ADISC for any nodes waiting for ADISC processing. If no nodes are

 * waiting, and the ADISC list count is identically 0, then we are done. For

 * Link Up discovery, since all nodes on the PLOGI list are UNREG_LOGIN'ed, we

 * can issue a CLEAR_LA and reenable Link Events. Next we will process the PLOGI

 * list.  32 entries are processed initially and PLOGI is initited for each one.

 * Completions / Events for each node are funnelled thru the state machine.  As

 * each node finishes PLOGI processing, it starts PLOGI for any nodes waiting

 * for PLOGI processing. If no nodes are waiting, and the PLOGI list count is

 * indentically 0, then we are done. We have now completed discovery / RSCN

 * handling. Upon completion, ALL nodes should be on either the mapped or

 * unmapped lists.

 Action routine                  Event       Current State  */

 RCV_PLOGI   UNUSED_NODE    */

 RCV_PRLI        */

 RCV_LOGO        */

 RCV_ADISC       */

 RCV_PDISC       */

 RCV_PRLO        */

 CMPL_PLOGI      */

 CMPL_PRLI       */

 CMPL_LOGO       */

 CMPL_ADISC      */

 CMPL_REG_LOGIN  */

 DEVICE_RM       */

 DEVICE_RECOVERY */

 RCV_PLOGI   PLOGI_ISSUE    */

 RCV_PRLI        */

 RCV_LOGO        */

 RCV_ADISC       */

 RCV_PDISC       */

 RCV_PRLO        */

 CMPL_PLOGI      */

 CMPL_PRLI       */

 CMPL_LOGO       */

 CMPL_ADISC      */

 CMPL_REG_LOGIN  */

 DEVICE_RM       */

 DEVICE_RECOVERY */

 RCV_PLOGI   ADISC_ISSUE    */

 RCV_PRLI        */

 RCV_LOGO        */

 RCV_ADISC       */

 RCV_PDISC       */

 RCV_PRLO        */

 CMPL_PLOGI      */

 CMPL_PRLI       */

 CMPL_LOGO       */

 CMPL_ADISC      */

 CMPL_REG_LOGIN  */

 DEVICE_RM       */

 DEVICE_RECOVERY */

 RCV_PLOGI  REG_LOGIN_ISSUE */

 RCV_PLOGI       */

 RCV_LOGO        */

 RCV_ADISC       */

 RCV_PDISC       */

 RCV_PRLO        */

 CMPL_PLOGI      */

 CMPL_PRLI       */

 CMPL_LOGO       */

 CMPL_ADISC      */

 CMPL_REG_LOGIN  */

 DEVICE_RM       */

 DEVICE_RECOVERY */

 RCV_PLOGI   PRLI_ISSUE     */

 RCV_PRLI        */

 RCV_LOGO        */

 RCV_ADISC       */

 RCV_PDISC       */

 RCV_PRLO        */

 CMPL_PLOGI      */

 CMPL_PRLI       */

 CMPL_LOGO       */

 CMPL_ADISC      */

 CMPL_REG_LOGIN  */

 DEVICE_RM       */

 DEVICE_RECOVERY */

 RCV_PLOGI   LOGO_ISSUE     */

 RCV_PRLI        */

 RCV_LOGO        */

 RCV_ADISC       */

 RCV_PDISC       */

 RCV_PRLO        */

 CMPL_PLOGI      */

 CMPL_PRLI       */

 CMPL_LOGO       */

 CMPL_ADISC      */

 CMPL_REG_LOGIN  */

 DEVICE_RM       */

 DEVICE_RECOVERY */

 RCV_PLOGI   UNMAPPED_NODE  */

 RCV_PRLI        */

 RCV_LOGO        */

 RCV_ADISC       */

 RCV_PDISC       */

 RCV_PRLO        */

 CMPL_PLOGI      */

 CMPL_PRLI       */

 CMPL_LOGO       */

 CMPL_ADISC      */

 CMPL_REG_LOGIN  */

 DEVICE_RM       */

 DEVICE_RECOVERY */

 RCV_PLOGI   MAPPED_NODE    */

 RCV_PRLI        */

 RCV_LOGO        */

 RCV_ADISC       */

 RCV_PDISC       */

 RCV_PRLO        */

 CMPL_PLOGI      */

 CMPL_PRLI       */

 CMPL_LOGO       */

 CMPL_ADISC      */

 CMPL_REG_LOGIN  */

 DEVICE_RM       */

 DEVICE_RECOVERY */

 RCV_PLOGI   NPR_NODE    */

 RCV_PRLI        */

 RCV_LOGO        */

 RCV_ADISC       */

 RCV_PDISC       */

 RCV_PRLO        */

 CMPL_PLOGI      */

 CMPL_PRLI       */

 CMPL_LOGO       */

 CMPL_ADISC      */

 CMPL_REG_LOGIN  */

 DEVICE_RM       */

 DEVICE_RECOVERY */

 DSM in event <evt> on NPort <nlp_DID> in state <cur_state> */

 DSM out state <rc> on NPort <nlp_DID> */

 Decrement the ndlp reference count held for this function */

/*******************************************************************

 * This file is part of the Emulex Linux Device Driver for         *

 * Fibre Channel Host Bus Adapters.                                *

 * Copyright (C) 2017-2021 Broadcom. All Rights Reserved. The term *

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.     *

 * Copyright (C) 2004-2014 Emulex.  All rights reserved.           *

 * EMULEX and SLI are trademarks of Emulex.                        *

 * www.broadcom.com                                                *

 * Portions Copyright (C) 2004-2005 Christoph Hellwig              *

 *                                                                 *

 * This program is free software; you can redistribute it and/or   *

 * modify it under the terms of version 2 of the GNU General       *

 * Public License as published by the Free Software Foundation.    *

 * This program is distributed in the hope that it will be useful. *

 * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *

 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *

 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *

 * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *

 * TO BE LEGALLY INVALID.  See the GNU General Public License for  *

 * more details, a copy of which can be found in the file COPYING  *

 * included with this package.                                     *

 max elements in MBUF safety pool */

 max elem in non-DMA safety pool */

 max elements in device data pool */

 max elements in non-DMA  pool */

 max elements in MBX non-DMA pool */

/**

 * lpfc_mem_alloc - create and allocate all PCI and memory pools

 * @phba: HBA to allocate pools for

 * @align: alignment requirement for blocks; must be a power of two

 *

 * Description: Creates and allocates PCI pools lpfc_mbuf_pool,

 * lpfc_hrb_pool.  Creates and allocates kmalloc-backed mempools

 * for LPFC_MBOXQ_t and lpfc_nodelist.  Also allocates the VPI bitmask.

 *

 * Notes: Not interrupt-safe.  Must be called with no locks held.  If any

 * allocation fails, frees all successfully allocated memory before returning.

 *

 * Returns:

 *   0 on success

 *   -ENOMEM on failure (if any memory allocations fail)

/**

 * lpfc_mem_free - Frees memory allocated by lpfc_mem_alloc

 * @phba: HBA to free memory for

 *

 * Description: Free the memory allocated by lpfc_mem_alloc routine. This

 * routine is a the counterpart of lpfc_mem_alloc.

 *

 * Returns: None

 Free HBQ pools */

 Free NLP memory pool */

 Free mbox memory pool */

 Free MBUF memory pool */

 Free Device Data memory pool */

 Ensure all objects have been returned to the pool */

/**

 * lpfc_mem_free_all - Frees all PCI and driver memory

 * @phba: HBA to free memory for

 *

 * Description: Free memory from PCI and driver memory pools and also those

 * used : lpfc_sg_dma_buf_pool, lpfc_mbuf_pool, lpfc_hrb_pool. Frees

 * kmalloc-backed mempools for LPFC_MBOXQ_t and lpfc_nodelist. Also frees

 * the VPI bitmask.

 *

 * Returns: None

 Free memory used in mailbox queue back to mailbox memory pool */

 Free memory used in mailbox cmpl list back to mailbox memory pool */

 Free the active mailbox command back to the mailbox memory pool */

 Free and destroy all the allocated memory pools */

 Free DMA buffer memory pool */

 Free Congestion Data buffer */

 Free RX table */

 Free the iocb lookup array */

/**

 * lpfc_mbuf_alloc - Allocate an mbuf from the lpfc_mbuf_pool PCI pool

 * @phba: HBA which owns the pool to allocate from

 * @mem_flags: indicates if this is a priority (MEM_PRI) allocation

 * @handle: used to return the DMA-mapped address of the mbuf

 *

 * Description: Allocates a DMA-mapped buffer from the lpfc_mbuf_pool PCI pool.

 * Allocates from generic dma_pool_alloc function first and if that fails and

 * mem_flags has MEM_PRI set (the only defined flag), returns an mbuf from the

 * HBA's pool.

 *

 * Notes: Not interrupt-safe.  Must be called with no locks held.  Takes

 * phba->hbalock.

 *

 * Returns:

 *   pointer to the allocated mbuf on success

 *   NULL on failure

/**

 * __lpfc_mbuf_free - Free an mbuf from the lpfc_mbuf_pool PCI pool (locked)

 * @phba: HBA which owns the pool to return to

 * @virt: mbuf to free

 * @dma: the DMA-mapped address of the lpfc_mbuf_pool to be freed

 *

 * Description: Returns an mbuf lpfc_mbuf_pool to the lpfc_mbuf_safety_pool if

 * it is below its max_count, frees the mbuf otherwise.

 *

 * Notes: Must be called with phba->hbalock held to synchronize access to

 * lpfc_mbuf_safety_pool.

 *

 * Returns: None

/**

 * lpfc_mbuf_free - Free an mbuf from the lpfc_mbuf_pool PCI pool (unlocked)

 * @phba: HBA which owns the pool to return to

 * @virt: mbuf to free

 * @dma: the DMA-mapped address of the lpfc_mbuf_pool to be freed

 *

 * Description: Returns an mbuf lpfc_mbuf_pool to the lpfc_mbuf_safety_pool if

 * it is below its max_count, frees the mbuf otherwise.

 *

 * Notes: Takes phba->hbalock.  Can be called with or without other locks held.

 *

 * Returns: None

/**

 * lpfc_nvmet_buf_alloc - Allocate an nvmet_buf from the

 * lpfc_sg_dma_buf_pool PCI pool

 * @phba: HBA which owns the pool to allocate from

 * @mem_flags: indicates if this is a priority (MEM_PRI) allocation

 * @handle: used to return the DMA-mapped address of the nvmet_buf

 *

 * Description: Allocates a DMA-mapped buffer from the lpfc_sg_dma_buf_pool

 * PCI pool.  Allocates from generic dma_pool_alloc function.

 *

 * Returns:

 *   pointer to the allocated nvmet_buf on success

 *   NULL on failure

/**

 * lpfc_nvmet_buf_free - Free an nvmet_buf from the lpfc_sg_dma_buf_pool

 * PCI pool

 * @phba: HBA which owns the pool to return to

 * @virt: nvmet_buf to free

 * @dma: the DMA-mapped address of the lpfc_sg_dma_buf_pool to be freed

 *

 * Returns: None

/**

 * lpfc_els_hbq_alloc - Allocate an HBQ buffer

 * @phba: HBA to allocate HBQ buffer for

 *

 * Description: Allocates a DMA-mapped HBQ buffer from the lpfc_hrb_pool PCI

 * pool along a non-DMA-mapped container for it.

 *

 * Notes: Not interrupt-safe.  Must be called with no locks held.

 *

 * Returns:

 *   pointer to HBQ on success

 *   NULL on failure

/**

 * lpfc_els_hbq_free - Frees an HBQ buffer allocated with lpfc_els_hbq_alloc

 * @phba: HBA buffer was allocated for

 * @hbqbp: HBQ container returned by lpfc_els_hbq_alloc

 *

 * Description: Frees both the container and the DMA-mapped buffer returned by

 * lpfc_els_hbq_alloc.

 *

 * Notes: Can be called with or without locks held.

 *

 * Returns: None

/**

 * lpfc_sli4_rb_alloc - Allocate an SLI4 Receive buffer

 * @phba: HBA to allocate a receive buffer for

 *

 * Description: Allocates a DMA-mapped receive buffer from the lpfc_hrb_pool PCI

 * pool along a non-DMA-mapped container for it.

 *

 * Notes: Not interrupt-safe.  Must be called with no locks held.

 *

 * Returns:

 *   pointer to HBQ on success

 *   NULL on failure

/**

 * lpfc_sli4_rb_free - Frees a receive buffer

 * @phba: HBA buffer was allocated for

 * @dmab: DMA Buffer container returned by lpfc_sli4_hbq_alloc

 *

 * Description: Frees both the container and the DMA-mapped buffers returned by

 * lpfc_sli4_rb_alloc.

 *

 * Notes: Can be called with or without locks held.

 *

 * Returns: None

/**

 * lpfc_sli4_nvmet_alloc - Allocate an SLI4 Receive buffer

 * @phba: HBA to allocate a receive buffer for

 *

 * Description: Allocates a DMA-mapped receive buffer from the lpfc_hrb_pool PCI

 * pool along a non-DMA-mapped container for it.

 *

 * Returns:

 *   pointer to HBQ on success

 *   NULL on failure

/**

 * lpfc_sli4_nvmet_free - Frees a receive buffer

 * @phba: HBA buffer was allocated for

 * @dmab: DMA Buffer container returned by lpfc_sli4_rbq_alloc

 *

 * Description: Frees both the container and the DMA-mapped buffers returned by

 * lpfc_sli4_nvmet_alloc.

 *

 * Notes: Can be called with or without locks held.

 *

 * Returns: None

/**

 * lpfc_in_buf_free - Free a DMA buffer

 * @phba: HBA buffer is associated with

 * @mp: Buffer to free

 *

 * Description: Frees the given DMA buffer in the appropriate way given if the

 * HBA is running in SLI3 mode with HBQs enabled.

 *

 * Notes: Takes phba->hbalock.  Can be called with or without other locks held.

 *

 * Returns: None

 Check whether HBQ is still in use */

/**

 * lpfc_rq_buf_free - Free a RQ DMA buffer

 * @phba: HBA buffer is associated with

 * @mp: Buffer to free

 *

 * Description: Frees the given DMA buffer in the appropriate way given by

 * reposting it to its associated RQ so it can be reused.

 *

 * Notes: Takes phba->hbalock.  Can be called with or without other locks held.

 *

 * Returns: None

/*******************************************************************

 * This file is part of the Emulex Linux Device Driver for         *

 * Fibre Channel Host Bus Adapters.                                *

 * Copyright (C) 2017-2021 Broadcom. All Rights Reserved. The term *

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.     *

 * Copyright (C) 2004-2016 Emulex.  All rights reserved.           *

 * EMULEX and SLI are trademarks of Emulex.                        *

 * www.broadcom.com                                                *

 * Portions Copyright (C) 2004-2005 Christoph Hellwig              *

 *                                                                 *

 * This program is free software; you can redistribute it and/or   *

 * modify it under the terms of version 2 of the GNU General       *

 * Public License as published by the Free Software Foundation.    *

 * This program is distributed in the hope that it will be useful. *

 * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *

 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *

 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *

 * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *

 * TO BE LEGALLY INVALID.  See the GNU General Public License for  *

 * more details, a copy of which can be found in the file COPYING  *

 * included with this package.                                     *

/**

 * lpfc_dump_static_vport - Dump HBA's static vport information.

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 * @offset: offset for dumping vport info.

 *

 * The dump mailbox command provides a method for the device driver to obtain

 * various types of information from the HBA device.

 *

 * This routine prepares the mailbox command for dumping list of static

 * vports to be created.

 Setup to dump vport info region */

 For SLI3 HBAs data is embedded in mailbox */

 For SLI4 HBAs driver need to allocate memory */

 save address for completion */

/**

 * lpfc_down_link - Bring down HBAs link.

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * This routine prepares a mailbox command to bring down HBA link.

/**

 * lpfc_dump_mem - Prepare a mailbox command for reading a region.

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 * @offset: offset into the region.

 * @region_id: config region id.

 *

 * The dump mailbox command provides a method for the device driver to obtain

 * various types of information from the HBA device.

 *

 * This routine prepares the mailbox command for dumping HBA's config region.

 Setup to dump VPD region */

/**

 * lpfc_dump_wakeup_param - Prepare mailbox command for retrieving wakeup params

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * This function create a dump memory mailbox command to dump wake up

 * parameters.

 Save context so that we can restore after memset */

 Setup to dump VPD region */

/**

 * lpfc_read_nv - Prepare a mailbox command for reading HBA's NVRAM param

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The read NVRAM mailbox command returns the HBA's non-volatile parameters

 * that are used as defaults when the Fibre Channel link is brought on-line.

 *

 * This routine prepares the mailbox command for reading information stored

 * in the HBA's NVRAM. Specifically, the HBA's WWNN and WWPN.

/**

 * lpfc_config_async - Prepare a mailbox command for enabling HBA async event

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 * @ring: ring number for the asynchronous event to be configured.

 *

 * The asynchronous event enable mailbox command is used to enable the

 * asynchronous event posting via the ASYNC_STATUS_CN IOCB response and

 * specifies the default ring to which events are posted.

 *

 * This routine prepares the mailbox command for enabling HBA asynchronous

 * event support on a IOCB ring.

/**

 * lpfc_heart_beat - Prepare a mailbox command for heart beat

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The heart beat mailbox command is used to detect an unresponsive HBA, which

 * is defined as any device where no error attention is sent and both mailbox

 * and rings are not processed.

 *

 * This routine prepares the mailbox command for issuing a heart beat in the

 * form of mailbox command to the HBA. The timely completion of the heart

 * beat mailbox command indicates the health of the HBA.

/**

 * lpfc_read_topology - Prepare a mailbox command for reading HBA topology

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 * @mp: DMA buffer memory for reading the link attention information into.

 *

 * The read topology mailbox command is issued to read the link topology

 * information indicated by the HBA port when the Link Event bit of the Host

 * Attention (HSTATT) register is set to 1 (For SLI-3) or when an FC Link

 * Attention ACQE is received from the port (For SLI-4). A Link Event

 * Attention occurs based on an exception detected at the Fibre Channel link

 * interface.

 *

 * This routine prepares the mailbox command for reading HBA link topology

 * information. A DMA memory has been set aside and address passed to the

 * HBA through @mp for the HBA to DMA link attention information into the

 * memory as part of the execution of the mailbox command.

 *

 * Return codes

 *    0 - Success (currently always return 0)

	/* Save address for later completion and set the owner to host so that

	 * the FW knows this mailbox is available for processing.

/**

 * lpfc_clear_la - Prepare a mailbox command for clearing HBA link attention

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The clear link attention mailbox command is issued to clear the link event

 * attention condition indicated by the Link Event bit of the Host Attention

 * (HSTATT) register. The link event attention condition is cleared only if

 * the event tag specified matches that of the current link event counter.

 * The current event tag is read using the read link attention event mailbox

 * command.

 *

 * This routine prepares the mailbox command for clearing HBA link attention

 * information.

/**

 * lpfc_config_link - Prepare a mailbox command for configuring link on a HBA

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The configure link mailbox command is used before the initialize link

 * mailbox command to override default value and to configure link-oriented

 * parameters such as DID address and various timers. Typically, this

 * command would be used after an F_Port login to set the returned DID address

 * and the fabric timeout values. This command is not valid before a configure

 * port command has configured the HBA port.

 *

 * This routine prepares the mailbox command for configuring link on a HBA.

	/* NEW_FEATURE

	 * SLI-2, Coalescing Response Feature.

/**

 * lpfc_config_msi - Prepare a mailbox command for configuring msi-x

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The configure MSI-X mailbox command is used to configure the HBA's SLI-3

 * MSI-X multi-message interrupt vector association to interrupt attention

 * conditions.

 *

 * Return codes

 *    0 - Success

 *    -EINVAL - Failure

 Sanity check */

 Clear mailbox command fields */

	/*

	 * SLI-3, Message Signaled Interrupt Fearure.

 Multi-message attention configuration */

	/*

	 * Set up message number to HA bit association

 RA0 (FCP Ring) */

 RA1 (Other Protocol Extra Ring) */

  __LITTLE_ENDIAN_BITFIELD */

 RA0 (FCP Ring) */

 RA1 (Other Protocol Extra Ring) */

 Multi-message interrupt autoclear configuration*/

 For now, HBA autoclear does not work reliably, disable it */

 Set command and owner bit */

/**

 * lpfc_init_link - Prepare a mailbox command for initialize link on a HBA

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 * @topology: the link topology for the link to be initialized to.

 * @linkspeed: the link speed for the link to be initialized to.

 *

 * The initialize link mailbox command is used to initialize the Fibre

 * Channel link. This command must follow a configure port command that

 * establishes the mode of operation.

 *

 * This routine prepares the mailbox command for initializing link on a HBA

 * with the specified link topology and speed.

 Topology handling for ASIC_GEN_NUM 0xC and later */

 Enable asynchronous ABTS responses from firmware */

	/* NEW_FEATURE

	 * Setting up the link speed

/**

 * lpfc_read_sparam - Prepare a mailbox command for reading HBA parameters

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 * @vpi: virtual N_Port identifier.

 *

 * The read service parameter mailbox command is used to read the HBA port

 * service parameters. The service parameters are read into the buffer

 * specified directly by a BDE in the mailbox command. These service

 * parameters may then be used to build the payload of an N_Port/F_POrt

 * login request and reply (LOGI/ACC).

 *

 * This routine prepares the mailbox command for reading HBA port service

 * parameters. The DMA memory is allocated in this function and the addresses

 * are populated into the mailbox command for the HBA to DMA the service

 * parameters into.

 *

 * Return codes

 *    0 - Success

 *    1 - DMA memory allocation failed

 Get a buffer to hold the HBAs Service Parameters */

 READ_SPARAM: no buffers */

 save address for completion */

/**

 * lpfc_unreg_did - Prepare a mailbox command for unregistering DID

 * @phba: pointer to lpfc hba data structure.

 * @vpi: virtual N_Port identifier.

 * @did: remote port identifier.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The unregister DID mailbox command is used to unregister an N_Port/F_Port

 * login for an unknown RPI by specifying the DID of a remote port. This

 * command frees an RPI context in the HBA port. This has the effect of

 * performing an implicit N_Port/F_Port logout.

 *

 * This routine prepares the mailbox command for unregistering a remote

 * N_Port/F_Port (DID) login.

/**

 * lpfc_read_config - Prepare a mailbox command for reading HBA configuration

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The read configuration mailbox command is used to read the HBA port

 * configuration parameters. This mailbox command provides a method for

 * seeing any parameters that may have changed via various configuration

 * mailbox commands.

 *

 * This routine prepares the mailbox command for reading out HBA configuration

 * parameters.

/**

 * lpfc_read_lnk_stat - Prepare a mailbox command for reading HBA link stats

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The read link status mailbox command is used to read the link status from

 * the HBA. Link status includes all link-related error counters. These

 * counters are maintained by the HBA and originated in the link hardware

 * unit. Note that all of these counters wrap.

 *

 * This routine prepares the mailbox command for reading out HBA link status.

/**

 * lpfc_reg_rpi - Prepare a mailbox command for registering remote login

 * @phba: pointer to lpfc hba data structure.

 * @vpi: virtual N_Port identifier.

 * @did: remote port identifier.

 * @param: pointer to memory holding the server parameters.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 * @rpi: the rpi to use in the registration (usually only used for SLI4.

 *

 * The registration login mailbox command is used to register an N_Port or

 * F_Port login. This registration allows the HBA to cache the remote N_Port

 * service parameters internally and thereby make the appropriate FC-2

 * decisions. The remote port service parameters are handed off by the driver

 * to the HBA using a descriptor entry that directly identifies a buffer in

 * host memory. In exchange, the HBA returns an RPI identifier.

 *

 * This routine prepares the mailbox command for registering remote port login.

 * The function allocates DMA buffer for passing the service parameters to the

 * HBA with the mailbox command.

 *

 * Return codes

 *    0 - Success

 *    1 - DMA memory allocation failed

 Get a buffer to hold NPorts Service Parameters */

 REG_LOGIN: no buffers */

 Copy param's into a new buffer */

 save address for completion */

/**

 * lpfc_unreg_login - Prepare a mailbox command for unregistering remote login

 * @phba: pointer to lpfc hba data structure.

 * @vpi: virtual N_Port identifier.

 * @rpi: remote port identifier

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The unregistration login mailbox command is used to unregister an N_Port

 * or F_Port login. This command frees an RPI context in the HBA. It has the

 * effect of performing an implicit N_Port/F_Port logout.

 *

 * This routine prepares the mailbox command for unregistering remote port

 * login.

 *

 * For SLI4 ports, the rpi passed to this function must be the physical

 * rpi value, not the logical index.

/**

 * lpfc_sli4_unreg_all_rpis - unregister all RPIs for a vport on SLI4 HBA.

 * @vport: pointer to a vport object.

 *

 * This routine sends mailbox command to unregister all active RPIs for

 * a vport.

		/*

		 * For SLI4 functions, the rpi field is overloaded for

		 * the vport context unreg all.  This routine passes

		 * 0 for the rpi field in lpfc_unreg_login for compatibility

		 * with SLI3 and then overrides the rpi field with the

		 * expected value for SLI4.

/**

 * lpfc_reg_vpi - Prepare a mailbox command for registering vport identifier

 * @vport: pointer to a vport object.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The registration vport identifier mailbox command is used to activate a

 * virtual N_Port after it has acquired an N_Port_ID. The HBA validates the

 * N_Port_ID against the information in the selected virtual N_Port context

 * block and marks it active to allow normal processing of IOCB commands and

 * received unsolicited exchanges.

 *

 * This routine prepares the mailbox command for registering a virtual N_Port.

	/*

	 * Set the re-reg VPI bit for f/w to update the MAC address.

/**

 * lpfc_unreg_vpi - Prepare a mailbox command for unregistering vport id

 * @phba: pointer to lpfc hba data structure.

 * @vpi: virtual N_Port identifier.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The unregistration vport identifier mailbox command is used to inactivate

 * a virtual N_Port. The driver must have logged out and unregistered all

 * remote N_Ports to abort any activity on the virtual N_Port. The HBA will

 * unregisters any default RPIs associated with the specified vpi, aborting

 * any active exchanges. The HBA will post the mailbox response after making

 * the virtual N_Port inactive.

 *

 * This routine prepares the mailbox command for unregistering a virtual

 * N_Port.

/**

 * lpfc_config_pcb_setup - Set up IOCB rings in the Port Control Block (PCB)

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine sets up and initializes the IOCB rings in the Port Control

 * Block (PCB).

		/* A ring MUST have both cmd and rsp entries defined to be

 Command ring setup for ring */

 Response ring setup for ring */

/**

 * lpfc_read_rev - Prepare a mailbox command for reading HBA revision

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The read revision mailbox command is used to read the revision levels of

 * the HBA components. These components include hardware units, resident

 * firmware, and available firmware. HBAs that supports SLI-3 mode of

 * operation provide different response information depending on the version

 * requested by the driver.

 *

 * This routine prepares the mailbox command for reading HBA revision

 * information.

 Request SLI3 info */

/**

 * lpfc_build_hbq_profile2 - Set up the HBQ Selection Profile 2

 * @hbqmb: pointer to the HBQ configuration data structure in mailbox command.

 * @hbq_desc: pointer to the HBQ selection profile descriptor.

 *

 * The Host Buffer Queue (HBQ) Selection Profile 2 specifies that the HBA

 * tests the incoming frames' R_CTL/TYPE fields with works 10:15 and performs

 * the Sequence Length Test using the fields in the Selection Profile 2

 * extension in words 20:31.

/**

 * lpfc_build_hbq_profile3 - Set up the HBQ Selection Profile 3

 * @hbqmb: pointer to the HBQ configuration data structure in mailbox command.

 * @hbq_desc: pointer to the HBQ selection profile descriptor.

 *

 * The Host Buffer Queue (HBQ) Selection Profile 3 specifies that the HBA

 * tests the incoming frame's R_CTL/TYPE fields with words 10:15 and performs

 * the Sequence Length Test and Byte Field Test using the fields in the

 * Selection Profile 3 extension in words 20:31.

/**

 * lpfc_build_hbq_profile5 - Set up the HBQ Selection Profile 5

 * @hbqmb: pointer to the HBQ configuration data structure in mailbox command.

 * @hbq_desc: pointer to the HBQ selection profile descriptor.

 *

 * The Host Buffer Queue (HBQ) Selection Profile 5 specifies a header HBQ. The

 * HBA tests the initial frame of an incoming sequence using the frame's

 * R_CTL/TYPE fields with words 10:15 and performs the Sequence Length Test

 * and Byte Field Test using the fields in the Selection Profile 5 extension

 * words 20:31.

/**

 * lpfc_config_hbq - Prepare a mailbox command for configuring an HBQ

 * @phba: pointer to lpfc hba data structure.

 * @id: HBQ identifier.

 * @hbq_desc: pointer to the HBA descriptor data structure.

 * @hbq_entry_index: index of the HBQ entry data structures.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The configure HBQ (Host Buffer Queue) mailbox command is used to configure

 * an HBQ. The configuration binds events that require buffers to a particular

 * ring and HBQ based on a selection profile.

 *

 * This routine prepares the mailbox command for configuring an HBQ.

 # entries in HBQ */

	hbqmb->recvNotify = hbq_desc->rn;             /* Receive

	hbqmb->numMask    = hbq_desc->mask_count;     /* # R_CTL/TYPE masks

	hbqmb->profile    = hbq_desc->profile;	      /* Selection profile:

						       * 0 = all,

	hbqmb->ringMask   = hbq_desc->ring_mask;      /* Binds HBQ to a ring

						       * e.g. Ring0=b0001,

	hbqmb->headerLen  = hbq_desc->headerLen;      /* 0 if not profile 4

	hbqmb->logEntry   = hbq_desc->logEntry;       /* Set to 1 if this

						       * HBQ will be used

						       * for LogEntry

				/* Copy info for profiles 2,3,5. Other

				 * profiles this area is reserved

 Return if no rctl / type masks for this HBQ */

 Otherwise we setup specific rctl / type masks for this HBQ */

/**

 * lpfc_config_ring - Prepare a mailbox command for configuring an IOCB ring

 * @phba: pointer to lpfc hba data structure.

 * @ring: ring number/index

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The configure ring mailbox command is used to configure an IOCB ring. This

 * configuration binds from one to six of HBA RC_CTL/TYPE mask entries to the

 * ring. This is used to map incoming sequences to a particular ring whose

 * RC_CTL/TYPE mask entry matches that of the sequence. The driver should not

 * attempt to configure a ring whose number is greater than the number

 * specified in the Port Control Block (PCB). It is an error to issue the

 * configure ring command more than once with the same ring number. The HBA

 * returns an error if the driver attempts this.

 *

 * This routine prepares the mailbox command for configuring IOCB ring.

 Is this ring configured for a specific profile */

 Otherwise we setup specific rctl / type masks for this ring */

/**

 * lpfc_config_port - Prepare a mailbox command for configuring port

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The configure port mailbox command is used to identify the Port Control

 * Block (PCB) in the driver memory. After this command is issued, the

 * driver must not access the mailbox in the HBA without first resetting

 * the HBA. The HBA may copy the PCB information to internal storage for

 * subsequent use; the driver can not change the PCB information unless it

 * resets the HBA.

 *

 * This routine prepares the mailbox command for configuring port.

 Always Host Group Pointer is in SLIM */

 If HBA supports SLI=3 ask for it */

 configure BlockGuard */

 Request HBQs */

 Command Ring Polling */

 If this is an SLI3 port, configure async status notification. */

 Now setup pcb */

 Setup Mailbox pointers */

	/*

	 * Setup Host Group ring pointer.

	 *

	 * For efficiency reasons, the ring get/put pointers can be

	 * placed in adapter memory (SLIM) rather than in host memory.

	 * This allows firmware to avoid PCI reads/writes when updating

	 * and checking pointers.

	 *

	 * The firmware recognizes the use of SLIM memory by comparing

	 * the address of the get/put pointers structure with that of

	 * the SLIM BAR (BAR0).

	 *

	 * Caution: be sure to use the PCI config space value of BAR0/BAR1

	 * (the hardware's view of the base address), not the OS's

	 * value of pci_resource_start() as the OS value may be a cookie

	 * for ioremap/iomap.

	/*

	 * Set up HGP - Port Memory

	 *

	 * The port expects the host get/put pointers to reside in memory

	 * following the "non-diagnostic" mode mailbox (32 words, 0x80 bytes)

	 * area of SLIM.  In SLI-2 mode, there's an additional 16 reserved

	 * words (0x40 bytes).  This area is not reserved if HBQs are

	 * configured in SLI-3.

	 *

	 * CR0Put    - SLI2(no HBQs) = 0xc0, With HBQs = 0x80

	 * RR0Get                      0xc4              0x84

	 * CR1Put                      0xc8              0x88

	 * RR1Get                      0xcc              0x8c

	 * CR2Put                      0xd0              0x90

	 * RR2Get                      0xd4              0x94

	 * CR3Put                      0xd8              0x98

	 * RR3Get                      0xdc              0x9c

	 *

	 * Reserved                    0xa0-0xbf

	 *    If HBQs configured:

	 *                         HBQ 0 Put ptr  0xc0

	 *                         HBQ 1 Put ptr  0xc4

	 *                         HBQ 2 Put ptr  0xc8

	 *                         ......

	 *                         HBQ(M-1)Put Pointer 0xc0+(M-1)*4

	 *

 Always Host Group Pointer is in SLIM */

 mask off BAR0's flag bits 0 - 3 */

 write HGP data to SLIM at the required longword offset */

 Setup Port Group offset */

 Use callback routine to setp rings in the pcb */

 special handling for LC HBAs */

 Swap PCB if needed */

/**

 * lpfc_kill_board - Prepare a mailbox command for killing board

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * The kill board mailbox command is used to tell firmware to perform a

 * graceful shutdown of a channel on a specified board to prepare for reset.

 * When the kill board mailbox command is received, the ER3 bit is set to 1

 * in the Host Status register and the ER Attention bit is set to 1 in the

 * Host Attention register of the HBA function that received the kill board

 * command.

 *

 * This routine prepares the mailbox command for killing the board in

 * preparation for a graceful shutdown.

/**

 * lpfc_mbox_put - Put a mailbox cmd into the tail of driver's mailbox queue

 * @phba: pointer to lpfc hba data structure.

 * @mbq: pointer to the driver internal queue element for mailbox command.

 *

 * Driver maintains a internal mailbox command queue implemented as a linked

 * list. When a mailbox command is issued, it shall be put into the mailbox

 * command queue such that they shall be processed orderly as HBA can process

 * one mailbox command at a time.

/**

 * lpfc_mbox_get - Remove a mailbox cmd from the head of driver's mailbox queue

 * @phba: pointer to lpfc hba data structure.

 *

 * Driver maintains a internal mailbox command queue implemented as a linked

 * list. When a mailbox command is issued, it shall be put into the mailbox

 * command queue such that they shall be processed orderly as HBA can process

 * one mailbox command at a time. After HBA finished processing a mailbox

 * command, the driver will remove a pending mailbox command from the head of

 * the mailbox command queue and send to the HBA for processing.

 *

 * Return codes

 *    pointer to the driver internal queue element for mailbox command.

/**

 * __lpfc_mbox_cmpl_put - Put mailbox cmd into mailbox cmd complete list

 * @phba: pointer to lpfc hba data structure.

 * @mbq: pointer to the driver internal queue element for mailbox command.

 *

 * This routine put the completed mailbox command into the mailbox command

 * complete list. This is the unlocked version of the routine. The mailbox

 * complete list is used by the driver worker thread to process mailbox

 * complete callback functions outside the driver interrupt handler.

/**

 * lpfc_mbox_cmpl_put - Put mailbox command into mailbox command complete list

 * @phba: pointer to lpfc hba data structure.

 * @mbq: pointer to the driver internal queue element for mailbox command.

 *

 * This routine put the completed mailbox command into the mailbox command

 * complete list. This is the locked version of the routine. The mailbox

 * complete list is used by the driver worker thread to process mailbox

 * complete callback functions outside the driver interrupt handler.

 This function expects to be called from interrupt context */

/**

 * lpfc_mbox_cmd_check - Check the validality of a mailbox command

 * @phba: pointer to lpfc hba data structure.

 * @mboxq: pointer to the driver internal queue element for mailbox command.

 *

 * This routine is to check whether a mailbox command is valid to be issued.

 * This check will be performed by both the mailbox issue API when a client

 * is to issue a mailbox command to the mailbox transport.

 *

 * Return 0 - pass the check, -ENODEV - fail the check

	/* Mailbox command that have a completion handler must also have a

	 * vport specified.

/**

 * lpfc_mbox_dev_check - Check the device state for issuing a mailbox command

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is to check whether the HBA device is ready for posting a

 * mailbox command. It is used by the mailbox transport API at the time the

 * to post a mailbox command to the device.

 *

 * Return 0 - pass the check, -ENODEV - fail the check

 If the PCI channel is in offline state, do not issue mbox */

 If the HBA is in error state, do not issue mbox */

/**

 * lpfc_mbox_tmo_val - Retrieve mailbox command timeout value

 * @phba: pointer to lpfc hba data structure.

 * @mboxq: pointer to the driver internal queue element for mailbox command.

 *

 * This routine retrieves the proper timeout value according to the mailbox

 * command code.

 *

 * Return codes

 *    Timeout value to be used for the given mailbox command

 0x03 */

 0x17 */

 0x1B */

 0x1C */

 0x1D */

 0x32 */

 0x81 */

 0x98 */

 0x9C */

 0xA5 */

 0x9b */

/**

 * lpfc_sli4_mbx_sge_set - Set a sge entry in non-embedded mailbox command

 * @mbox: pointer to lpfc mbox command.

 * @sgentry: sge entry index.

 * @phyaddr: physical address for the sge

 * @length: Length of the sge.

 *

 * This routine sets up an entry in the non-embedded mailbox command at the sge

 * index location.

/**

 * lpfc_sli4_mbx_sge_get - Get a sge entry from non-embedded mailbox command

 * @mbox: pointer to lpfc mbox command.

 * @sgentry: sge entry index.

 * @sge: pointer to lpfc mailbox sge to load into.

 *

 * This routine gets an entry from the non-embedded mailbox command at the sge

 * index location.

/**

 * lpfc_sli4_mbox_cmd_free - Free a sli4 mailbox command

 * @phba: pointer to lpfc hba data structure.

 * @mbox: pointer to lpfc mbox command.

 *

 * This routine frees SLI4 specific mailbox command for sending IOCTL command.

 For embedded mbox command, just free the mbox command */

 For non-embedded mbox command, we need to free the pages first */

 There is nothing we can do if there is no sge address array */

 Each non-embedded DMA memory was allocated in the length of a page */

 Free the sge address array memory */

 Finally, free the mailbox command itself */

/**

 * lpfc_sli4_config - Initialize the  SLI4 Config Mailbox command

 * @phba: pointer to lpfc hba data structure.

 * @mbox: pointer to lpfc mbox command.

 * @subsystem: The sli4 config sub mailbox subsystem.

 * @opcode: The sli4 config sub mailbox command opcode.

 * @length: Length of the sli4 config mailbox command (including sub-header).

 * @emb: True if embedded mbox command should be setup.

 *

 * This routine sets up the header fields of SLI4 specific mailbox command

 * for sending IOCTL command.

 *

 * Return: the actual length of the mbox command allocated (mostly useful

 *         for none embedded mailbox command).

 Set up SLI4 mailbox command header fields */

 Set up SLI4 ioctl command header fields */

 Setup for the embedded mbox command */

 Set up main header fields */

 Set up sub-header fields following main header */

 Setup for the non-embedded mbox command */

 Allocate record for keeping SGE virtual addresses */

		/* The DMA memory is always allocated in the length of a

		 * page even though the last SGE might not fill up to a

		 * page, this is used as a priori size of SLI4_PAGE_SIZE for

		 * the later DMA memory free.

 In case of malloc fails, proceed with whatever we have */

 Keep the first page for later sub-header construction */

 Set up main header fields in mailbox command */

 Set up sub-header fields into the first page */

 The sub-header is in DMA memory, which needs endian converstion */

/**

 * lpfc_sli4_mbox_rsrc_extent - Initialize the opcode resource extent.

 * @phba: pointer to lpfc hba data structure.

 * @mbox: pointer to an allocated lpfc mbox resource.

 * @exts_count: the number of extents, if required, to allocate.

 * @rsrc_type: the resource extent type.

 * @emb: true if LPFC_SLI4_MBX_EMBED. false if LPFC_SLI4_MBX_NEMBED.

 *

 * This routine completes the subcommand header for SLI4 resource extent

 * mailbox commands.  It is called after lpfc_sli4_config.  The caller must

 * pass an allocated mailbox and the attributes required to initialize the

 * mailbox correctly.

 *

 * Return: the actual length of the mbox command allocated.

 Set up SLI4 ioctl command header fields */

 Get the first SGE entry from the non-embedded DMA memory */

	/*

	 * The resource type is common to all extent Opcodes and resides in the

	 * same position.

 This is DMA data.  Byteswap is required. */

 Complete the initialization for the particular Opcode. */

 Initialization is complete.*/

/**

 * lpfc_sli_config_mbox_subsys_get - Get subsystem from a sli_config mbox cmd

 * @phba: pointer to lpfc hba data structure.

 * @mbox: pointer to lpfc mbox command queue entry.

 *

 * This routine gets the subsystem from a SLI4 specific SLI_CONFIG mailbox

 * command. If the mailbox command is not MBX_SLI4_CONFIG (0x9B) or if the

 * sub-header is not present, subsystem LPFC_MBOX_SUBSYSTEM_NA (0x0) shall

 * be returned.

 For embedded mbox command, get opcode from embedded sub-header*/

 For non-embedded mbox command, get opcode from first dma page */

/**

 * lpfc_sli_config_mbox_opcode_get - Get opcode from a sli_config mbox cmd

 * @phba: pointer to lpfc hba data structure.

 * @mbox: pointer to lpfc mbox command queue entry.

 *

 * This routine gets the opcode from a SLI4 specific SLI_CONFIG mailbox

 * command. If the mailbox command is not MBX_SLI4_CONFIG (0x9B) or if

 * the sub-header is not present, opcode LPFC_MBOX_OPCODE_NA (0x0) be

 * returned.

 For embedded mbox command, get opcode from embedded sub-header*/

 For non-embedded mbox command, get opcode from first dma page */

/**

 * lpfc_sli4_mbx_read_fcf_rec - Allocate and construct read fcf mbox cmd

 * @phba: pointer to lpfc hba data structure.

 * @mboxq: pointer to lpfc mbox command.

 * @fcf_index: index to fcf table.

 *

 * This routine routine allocates and constructs non-embedded mailbox command

 * for reading a FCF table entry referred by @fcf_index.

 *

 * Return: pointer to the mailbox command constructed if successful, otherwise

 * NULL.

 Set up READ_FCF SLI4_CONFIG mailbox-ioctl command */

	/* Get the first SGE entry from the non-embedded DMA memory. This

	 * routine only uses a single SGE.

 Set up command fields */

 Perform necessary endian conversion */

/**

 * lpfc_request_features: Configure SLI4 REQUEST_FEATURES mailbox

 * @phba: pointer to lpfc hba data structure.

 * @mboxq: pointer to lpfc mbox command.

 *

 * This routine sets up the mailbox for an SLI4 REQUEST_FEATURES

 * mailbox command.

 Set up SLI4 mailbox command header fields */

 Set up host requested features. */

 Enable DIF (block guard) only if configured to do so. */

 Enable NPIV only if configured to do so. */

 iaab/iaar NOT set for now */

 Enable Application Services Header for appheader VMID */

/**

 * lpfc_init_vfi - Initialize the INIT_VFI mailbox command

 * @mbox: pointer to lpfc mbox command to initialize.

 * @vport: Vport associated with the VF.

 *

 * This routine initializes @mbox to all zeros and then fills in the mailbox

 * fields from @vport. INIT_VFI configures virtual fabrics identified by VFI

 * in the context of an FCF. The driver issues this command to setup a VFI

 * before issuing a FLOGI to login to the VSAN. The driver should also issue a

 * REG_VFI after a successful VSAN login.

/**

 * lpfc_reg_vfi - Initialize the REG_VFI mailbox command

 * @mbox: pointer to lpfc mbox command to initialize.

 * @vport: vport associated with the VF.

 * @phys: BDE DMA bus address used to send the service parameters to the HBA.

 *

 * This routine initializes @mbox to all zeros and then fills in the mailbox

 * fields from @vport, and uses @buf as a DMAable buffer to send the vport's

 * fc service parameters to the HBA for this VFI. REG_VFI configures virtual

 * fabrics identified by VFI in the context of an FCF.

 Only FC supports upd bit */

/**

 * lpfc_init_vpi - Initialize the INIT_VPI mailbox command

 * @phba: pointer to the hba structure to init the VPI for.

 * @mbox: pointer to lpfc mbox command to initialize.

 * @vpi: VPI to be initialized.

 *

 * The INIT_VPI mailbox command supports virtual N_Ports. The driver uses the

 * command to activate a virtual N_Port. The HBA assigns a MAC address to use

 * with the virtual N Port.  The SLI Host issues this command before issuing a

 * FDISC to connect to the Fabric. The SLI Host should issue a REG_VPI after a

 * successful virtual NPort login.

/**

 * lpfc_unreg_vfi - Initialize the UNREG_VFI mailbox command

 * @mbox: pointer to lpfc mbox command to initialize.

 * @vport: vport associated with the VF.

 *

 * The UNREG_VFI mailbox command causes the SLI Host to put a virtual fabric

 * (logical NPort) into the inactive state. The SLI Host must have logged out

 * and unregistered all remote N_Ports to abort any activity on the virtual

 * fabric. The SLI Port posts the mailbox response after marking the virtual

 * fabric inactive.

/**

 * lpfc_sli4_dump_cfg_rg23 - Dump sli4 port config region 23

 * @phba: pointer to the hba structure containing.

 * @mbox: pointer to lpfc mbox command to initialize.

 *

 * This function create a SLI4 dump mailbox command to dump configure

 * region 23.

 dump config region 23 failed to allocate memory */

 save address for completion */

 We don't need dma buffer for link stat. */

 save address for completion */

/*

 * lpfc_sli4_dump_page_a0 - Dump sli4 read SFP Diagnostic.

 * @phba: pointer to the hba structure containing.

 * @mbox: pointer to lpfc mbox command to initialize.

 *

 * This function create a SLI4 dump mailbox command to dump configure

 * type 3 page 0xA0.

 save address for completion */

/**

 * lpfc_reg_fcfi - Initialize the REG_FCFI mailbox command

 * @phba: pointer to the hba structure containing the FCF index and RQ ID.

 * @mbox: pointer to lpfc mbox command to initialize.

 *

 * The REG_FCFI mailbox command supports Fibre Channel Forwarders (FCFs). The

 * SLI Host uses the command to activate an FCF after it has acquired FCF

 * information via a READ_FCF mailbox command. This mailbox command also is used

 * to indicate where received unsolicited frames from this FCF will be sent. By

 * default this routine will set up the FCF to forward all unsolicited frames

 * the the RQ ID passed in the @phba. This can be overridden by the caller for

 * more complicated setups.

 Match everything - rq_id0 */

 addr mode is bit wise inverted value of fcf addr_mode */

 This is ONLY for NVMET MRQ == 1 */

 Match type FCP - rq_id0 */

 Match everything else - rq_id1 */

/**

 * lpfc_reg_fcfi_mrq - Initialize the REG_FCFI_MRQ mailbox command

 * @phba: pointer to the hba structure containing the FCF index and RQ ID.

 * @mbox: pointer to lpfc mbox command to initialize.

 * @mode: 0 to register FCFI, 1 to register MRQs

 *

 * The REG_FCFI_MRQ mailbox command supports Fibre Channel Forwarders (FCFs).

 * The SLI Host uses the command to activate an FCF after it has acquired FCF

 * information via a READ_FCF mailbox command. This mailbox command also is used

 * to indicate where received unsolicited frames from this FCF will be sent. By

 * default this routine will set up the FCF to forward all unsolicited frames

 * the the RQ ID passed in the @phba. This can be overridden by the caller for

 * more complicated setups.

 This is ONLY for MRQ */

 Match NVME frames of type FCP (protocol NVME) - rq_id0 */

 NVME connection id */

 rq_id0 */

 Match everything - rq_id1 */

/**

 * lpfc_unreg_fcfi - Initialize the UNREG_FCFI mailbox command

 * @mbox: pointer to lpfc mbox command to initialize.

 * @fcfi: FCFI to be unregistered.

 *

 * The UNREG_FCFI mailbox command supports Fibre Channel Forwarders (FCFs).

 * The SLI Host uses the command to inactivate an FCFI.

/**

 * lpfc_resume_rpi - Initialize the RESUME_RPI mailbox command

 * @mbox: pointer to lpfc mbox command to initialize.

 * @ndlp: The nodelist structure that describes the RPI to resume.

 *

 * The RESUME_RPI mailbox command is used to restart I/O to an RPI after a

 * link event.

/*******************************************************************

 * This file is part of the Emulex Linux Device Driver for         *

 * Fibre Channel Host Bus Adapters.                                *

 * Copyright (C) 2017-2021 Broadcom. All Rights Reserved. The term *

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.     *

 * Copyright (C) 2004-2016 Emulex.  All rights reserved.           *

 * EMULEX and SLI are trademarks of Emulex.                        *

 * www.broadcom.com                                                *

 *                                                                 *

 * This program is free software; you can redistribute it and/or   *

 * modify it under the terms of version 2 of the GNU General       *

 * Public License as published by the Free Software Foundation.    *

 * This program is distributed in the hope that it will be useful. *

 * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *

 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *

 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *

 * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *

 * TO BE LEGALLY INVALID.  See the GNU General Public License for  *

 * more details, a copy of which can be found in the file COPYING  *

 * included with this package.                                     *

/*

 * Fibre Channel SCSI LAN Device Driver CT support: FC Generic Services FC-GS

 FDMI Port Speed definitions - FC-GS-7 */

 1G FC */

 2G FC */

 4G FC */

 10G FC */

 8G FC */

 16G FC */

 32G FC */

 20G FC */

 40G FC */

 128G FC */

 64G FC */

 256G FC */

 Unknown */

 10G E */

 40G E */

 100G E */

 25G E */

 50G E */

 400G E */

/**

 * lpfc_ct_unsol_cmpl : Completion callback function for unsol ct commands

 * @phba : pointer to lpfc hba data structure.

 * @cmdiocb : pointer to lpfc command iocb data structure.

 * @rspiocb : pointer to lpfc response iocb data structure.

 *

 * This routine is the callback function for issuing unsol ct reject command.

 * The memory allocated in the reject command path is freed up here.

/**

 * lpfc_ct_reject_event - Issue reject for unhandled CT MIB commands

 * @ndlp: pointer to a node-list data structure.

 * @ct_req: pointer to the CT request data structure.

 * @rx_id: rx_id of the received UNSOL CT command

 * @ox_id: ox_id of the UNSOL CT command

 *

 * This routine is invoked by the lpfc_ct_handle_mibreq routine for sending

 * a reject response. Reject response is sent for the unhandled commands.

 fill in BDEs for command */

 Allocate buffer for Buffer ptr list */

 Save for completion so we can release these resources */

 Xri / rx_id */

/**

 * lpfc_ct_handle_mibreq - Process an unsolicited CT MIB request data buffer

 * @phba: pointer to lpfc hba data structure.

 * @ctiocbq: pointer to lpfc CT command iocb data structure.

 *

 * This routine is used for processing the IOCB associated with a unsolicited

 * CT MIB request. It first determines whether there is an existing ndlp that

 * matches the DID from the unsolicited IOCB. If not, it will return.

 Ignore traffic received during vport shutdown */

/**

 * lpfc_ct_unsol_event - Process an unsolicited event from a ct sli ring

 * @phba: pointer to lpfc hba data structure.

 * @pring: pointer to a SLI ring.

 * @ctiocbq: pointer to lpfc ct iocb data structure.

 *

 * This routine is used to process an unsolicited event received from a SLI

 * (Service Level Interface) ring. The actual processing of the data buffer

 * associated with the unsolicited event is done by invoking appropriate routine

 * after properly set up the iocb buffer from the SLI ring on which the

 * unsolicited event was received.

 Not enough posted buffers; Try posting more buffers */

	/* If there are no BDEs associated

	 * with this IOCB, there is nothing to do.

/**

 * lpfc_ct_handle_unsol_abort - ct upper level protocol abort handler

 * @phba: Pointer to HBA context object.

 * @dmabuf: pointer to a dmabuf that describes the FC sequence

 *

 * This function serves as the upper level protocol abort handler for CT

 * protocol.

 *

 * Return 1 if abort has been handled, 0 otherwise.

 CT upper level goes through BSG */

 We get chunks of FCELSSIZE */

 Allocate buffer for rsp payload */

 Queue it to a linked list */

 build buffer ptr list for IOCB */

 I/O job is complete so context is now invalid*/

/*

 * lpfc_gen_req - Build and issue a GEN_REQUEST command  to the SLI Layer

 * @vport: pointer to a host virtual N_Port data structure.

 * @bmp: Pointer to BPL for SLI command

 * @inp: Pointer to data buffer for response data.

 * @outp: Pointer to data buffer that hold the CT command.

 * @cmpl: completion routine to call when command completes

 * @ndlp: Destination NPort nodelist entry

 *

 * This function as the final part for issuing a CT command.

 Allocate buffer for  command iocb */

 Save for completion so we can release these resources */

 Fill in payload, bp points to frame payload */

 Fill in rest of iocb */

 FC spec states we need 3 * ratov for CT requests */

 For GEN_REQUEST64_CR, use the RPI */

 Issue GEN REQ IOCB for NPORT <did> */

/*

 * lpfc_ct_cmd - Build and issue a CT command

 * @vport: pointer to a host virtual N_Port data structure.

 * @inmp: Pointer to data buffer for response data.

 * @bmp: Pointer to BPL for SLI command

 * @ndlp: Destination NPort nodelist entry

 * @cmpl: completion routine to call when command completes

 *

 * This function is called for issuing a CT command.

 Skip past ct request */

 Put buffer(s) for ct rsp in bpl */

	/*

	 * Form the CT IOCB.  The total number of BDEs in this IOCB

	 * is the single command plus response count from

	 * lpfc_alloc_ct_rsp.

 By default, the driver expects to support FCP FC4 */

			/* if ndlp needs to be discovered and prior

			 * state of ndlp hit devloss, change state to

			 * allow rediscovery.

			/*

			 * This NPortID was previously a FCP/NVMe target,

			 * Don't even bother to send GFF_ID.

	/*

	 * To conserve rpi's, filter out addresses for other

	 * vports on the same physical HBAs.

 FCPI/NVMEI path. Process Did */

 NVMET path.  NVMET only cares about NVMEI nodes. */

 subtract length of CT header */

 Loop through entire NameServer list of DIDs */

 Get next DID from NameServer List */

	/* All GID_FT entries processed.  If the driver is running in

	 * in target mode, put impacted nodes into recovery and drop

	 * the RPI to flush outstanding IO.

 First save ndlp, before we overwrite it */

 we pass cmdiocb to state machine which needs rspiocb as well */

 Ignore response if link flipped after this request was made */

 Don't bother processing response if vport is being torn down. */

		/* This is a GID_FT completing so the gidft_inp counter was

		 * incremented before the GID_FT was issued to the wire.

		/*

		 * Skip processing the NS response

		 * Re-issue the NS cmd

 Check for retry */

 CT command is being retried */

 Unable to send NS cmd */

 Good status, continue checking */

 NameServer Rsp Error */

 NameServer Rsp Error */

 Link up / RSCN discovery */

		/*

		 * The driver has cycled through all Nports in the RSCN payload.

		 * Complete the handling by cleaning up and marking the

		 * current driver state.

 RSCN still */

 First save ndlp, before we overwrite it */

 we pass cmdiocb to state machine which needs rspiocb as well */

 Ignore response if link flipped after this request was made */

 Don't bother processing response if vport is being torn down. */

		/* This is a GID_PT completing so the gidft_inp counter was

		 * incremented before the GID_PT was issued to the wire.

		/*

		 * Skip processing the NS response

		 * Re-issue the NS cmd

 Check for retry */

 CT command is being retried */

 Unable to send NS cmd */

 Good status, continue checking */

 NameServer Rsp Error */

 NameServer Rsp Error */

 Link up / RSCN discovery */

		/*

		 * The driver has cycled through all Nports in the RSCN payload.

		 * Complete the handling by cleaning up and marking the

		 * current driver state.

 RSCN still */

 Ignore response if link flipped after this request was made */

 Good status, continue checking */

 Check for retry */

					/* We don't increment the retry

					 * count for this case.

 CT command is being retried */

 success */

 This is a target port, unregistered port, or the GFF_ID failed */

 Link up / RSCN discovery */

		/*

		 * The driver has cycled through all Nports in the RSCN payload.

		 * Complete the handling by cleaning up and marking the

		 * current driver state.

 RSCN still */

 Ignore response if link flipped after this request was made */

 Preserve the nameserver node to release the reference. */

 Good status, continue checking */

		/* Lookup the NPort_ID queried in the GFT_ID and find the

		 * driver's local node.  It's an error if the driver

		 * doesn't have one.

			/* The bitmask value for FCP and NVME FCP types is

			 * the same because they are 32 bits distant from

			 * each other in word0 and word0.

 If fc4 type is still unknown, then LOGO */

 First save ndlp, before we overwrite it */

 we pass cmdiocb to state machine which needs rspiocb as well */

 RFT request completes status <ulpStatus> CmdRsp <CmdRsp> */

 even if it fails we will act as though it succeeded. */

/*

 * Although the symbolic port name is thought to be an integer

 * as of January 18, 2016, leave it as a string until more of

 * the record state becomes defined.

	/*

	 * Use the lpfc board number as the Symbolic Port

	 * Name object.  NPIV is not in play so this integer

	 * value is sufficient and unique per FC-ID.

 Note :- OS name is "Linux" */

/*

 * This routine will return the FC4 Type associated with the CT

 * GID_FT command.

/*

 * lpfc_ns_cmd

 * Description:

 *    Issue Cmd to NameServer

 *       SLI_CTNS_GID_FT

 *       LI_CTNS_RFT_ID

 fill in BDEs for command */

 Allocate buffer for command payload */

 Allocate buffer for Buffer ptr list */

 NameServer Req */

 Register FC4 FCP type if enabled.  */

		/* Register NVME type if enabled.  Defined LE and swapped.

		 * rsvd[0] is used as word1 because of the hard-coded

		 * word0 usage in the ct_request data structure.

 Implement DA_ID Nameserver request */

		/* The driver always supports FC_TYPE_FCP.  However, the

		 * caller can specify NVME (type x28) as well.  But only

		 * these that FC4 type is supported.

	/* The lpfc_ct_cmd/lpfc_get_req shall increment ndlp reference count

	 * to hold ndlp reference for the corresponding callback function.

 On success, The cmpl function will free the buffers */

/**

 * lpfc_cmpl_ct_disc_fdmi - Handle a discovery FDMI completion

 * @phba: Pointer to HBA context object.

 * @cmdiocb: Pointer to the command IOCBQ.

 * @rspiocb: Pointer to the response IOCBQ.

 *

 * This function to handle the completion of a driver initiated FDMI

 * CT command issued during discovery.

 Look for a retryable error */

				/* Driver aborted this IO.  No retry as error

				 * is likely Offline->Online or some adapter

				 * error.  Recovery will try again.

 Retry the same FDMI command */

 Check for a CT LS_RJT response */

 FDMI rsp failed */

 Should we fallback to FDMI-2 / FDMI-1 ? */

 Fallback to FDMI-1 */

 Start over */

 Fallback to FDMI-1 */

 Start over */

 Retry the same command */

 No retry on Vendor, RPA only done on physical port */

 Fallback to FDMI-1 */

 Start over */

 Retry the same command */

	/*

	 * On success, need to cycle thru FDMI registration for discovery

	 * DHBA -> DPRT -> RHBA -> RPA  (physical port)

	 * DPRT -> RPRT (vports)

 mi is only for the phyical port, no vports */

 CGN is only for the physical port, no vports */

/**

 * lpfc_fdmi_change_check - Check for changed FDMI parameters

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * Check how many mapped NPorts we are connected to

 * Check if our hostname changed

 * Called from hbeat timeout routine to check if any FDMI parameters

 * changed. If so, re-register those Attributes.

 Must be connected to a Fabric */

 Check if system hostname changed */

		/* Since this effects multiple HBA and PORT attributes, we need

		 * de-register and go thru the whole FDMI registration cycle.

		 * DHBA -> DPRT -> RHBA -> RPA  (physical port)

		 * DPRT -> RPRT (vports)

 For extra Vendor RPA */

		/* Since this code path registers all the port attributes

		 * we can just return without further checking.

 Check if the number of mapped NPorts changed */

 Routines for all individual HBA attributes */

	/* This string MUST be consistent with other FC platforms

	 * supported by Broadcom.

 Convert JEDEC ID to ascii for hardware version */

 Nothing is defined for this currently */

 Each driver instance corresponds to a single port */

 Driver doesn't have access to this information */

 Routines for all individual PORT attributes */

 Type 0x8 - FCP */

 Type 0x20 - CT */

 Check to see if Firmware supports NVME and on physical port */

 Type 0x28 - NVME */

 FCoE links support only one speed */

 Type 0x8 - FCP */

 Type 0x20 - CT */

 Check to see if NVME is configured or not */

 Type 0x28 - NVME */

 Link Up - operational */

 SRIOV (type 3) is not supported */

 NPIV */

 Physical */

 RHBA attribute jump table */

 Action routine                 Mask bit     Attribute type */

 bit0     RHBA_NODENAME           */

 bit1     RHBA_MANUFACTURER       */

 bit2     RHBA_SERIAL_NUMBER      */

 bit3     RHBA_MODEL              */

 bit4     RHBA_MODEL_DESCRIPTION  */

 bit5     RHBA_HARDWARE_VERSION   */

 bit6     RHBA_DRIVER_VERSION     */

 bit7     RHBA_OPTION_ROM_VERSION */

 bit8     RHBA_FIRMWARE_VERSION   */

 bit9     RHBA_OS_NAME_VERSION    */

 bit10    RHBA_MAX_CT_PAYLOAD_LEN */

 bit11    RHBA_SYM_NODENAME       */

 bit12    RHBA_VENDOR_INFO        */

 bit13    RHBA_NUM_PORTS          */

 bit14    RHBA_FABRIC_WWNN        */

 bit15    RHBA_BIOS_VERSION       */

 bit16    RHBA_BIOS_STATE         */

 bit17    RHBA_VENDOR_ID          */

 RPA / RPRT attribute jump table */

 Action routine                   Mask bit   Attribute type */

 bit0   RPRT_SUPPORT_FC4_TYPES  */

 bit1   RPRT_SUPPORTED_SPEED    */

 bit2   RPRT_PORT_SPEED         */

 bit3   RPRT_MAX_FRAME_SIZE     */

 bit4   RPRT_OS_DEVICE_NAME     */

 bit5   RPRT_HOST_NAME          */

 bit6   RPRT_NODENAME           */

 bit7   RPRT_PORTNAME           */

 bit8   RPRT_SYM_PORTNAME       */

 bit9   RPRT_PORT_TYPE          */

 bit10  RPRT_SUPPORTED_CLASS    */

 bit11  RPRT_FABRICNAME         */

 bit12  RPRT_ACTIVE_FC4_TYPES   */

 bit13  RPRT_PORT_STATE         */

 bit14  RPRT_DISC_PORT          */

 bit15  RPRT_PORT_ID            */

 bit16  RPRT_SMART_SERVICE      */

 bit17  RPRT_SMART_GUID         */

 bit18  RPRT_SMART_VERSION      */

 bit19  RPRT_SMART_MODEL        */

 bit20  RPRT_SMART_PORT_INFO    */

 bit21  RPRT_SMART_QOS          */

 bit22  RPRT_SMART_SECURITY     */

 bit23  RPRT_VENDOR_MI          */

/**

 * lpfc_fdmi_cmd - Build and send a FDMI cmd to the specified NPort

 * @vport: pointer to a host virtual N_Port data structure.

 * @ndlp: ndlp to send FDMI cmd to (if NULL use FDMI_DID)

 * @cmdcode: FDMI command to send

 * @new_mask: Mask of HBA or PORT Attributes to send

 *

 * Builds and sends a FDMI command using the CT subsystem.

 called from discovery */

 fill in BDEs for command */

 Allocate buffer for command payload */

 Allocate buffer for Buffer ptr list */

 FDMI request */

 First populate the CT_IU preamble */

 Next fill in the specific FDMI cmd information */

 HBA Identifier */

 Registered Port List */

 One entry (port) per adapter */

 point to the HBA attribute block */

 Mask will dictate what attributes to build in the request */

 Total size */

 HBA Identifier */

 Mask will dictate what attributes to build in the request */

 Total size */

	/*

	 * The lpfc_ct_cmd/lpfc_get_req shall increment ndlp reference count

	 * to hold ndlp reference for the corresponding callback function.

 Issue FDMI request failed */

/**

 * lpfc_delayed_disc_tmo - Timeout handler for delayed discovery timer.

 * @t: Context object of the timer.

 *

 * This function set the WORKER_DELAYED_DISC_TMO flag and wake up

 * the worker thread.

/**

 * lpfc_delayed_disc_timeout_handler - Function called by worker thread to

 *      handle delayed discovery.

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This function start nport discovery of the vport.

 Check for a CT LS_RJT response */

 If DALLAPP_ID failed retry later */

 Set IN USE flag */

 for all elements in the hash table */

/**

 * lpfc_vmid_cmd - Build and send a FDMI cmd to the specified NPort

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdcode: application server command code to send

 * @vmid: pointer to vmid info structure

 *

 * Builds and sends a FDMI command using the CT subsystem.

 fill in BDEs for command */

 Allocate buffer for command payload */

 Allocate buffer for Buffer ptr list */

 First populate the CT_IU preamble */

	/* The lpfc_ct_cmd/lpfc_get_req shall increment ndlp reference count

	 * to hold ndlp reference for the corresponding callback function.

 Issue CT request failed */

/*******************************************************************

 * This file is part of the Emulex Linux Device Driver for         *

 * Fibre Channel Host Bus Adapters.                                *

 * Copyright (C) 2017-2021 Broadcom. All Rights Reserved. The term *

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.     *

 * Copyright (C) 2004-2016 Emulex.  All rights reserved.           *

 * EMULEX and SLI are trademarks of Emulex.                        *

 * www.broadcom.com                                                *

 * Portions Copyright (C) 2004-2005 Christoph Hellwig              *

 *                                                                 *

 * This program is free software; you can redistribute it and/or   *

 * modify it under the terms of version 2 of the GNU General       *

 * Public License as published by the Free Software Foundation.    *

 * This program is distributed in the hope that it will be useful. *

 * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *

 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *

 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *

 * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *

 * TO BE LEGALLY INVALID.  See the GNU General Public License for  *

 * more details, a copy of which can be found in the file COPYING  *

 * included with this package.                                     *

 Checksum */

 Opaque storage */

 Target LBA or indirect LBA */

/**

 * lpfc_sli4_set_rsp_sgl_last - Set the last bit in the response sge.

 * @phba: Pointer to HBA object.

 * @lpfc_cmd: lpfc scsi command object pointer.

 *

 * This function is called from the lpfc_prep_task_mgmt_cmd function to

 * set the last bit in the response sge entry.

/**

 * lpfc_update_stats - Update statistical data for the command completion

 * @vport: The virtual port on which this call is executing.

 * @lpfc_cmd: lpfc scsi command object pointer.

 *

 * This function is called when there is a command completion and this

 * function updates the statistical data for the command completion.

 check array subscript bounds */

/**

 * lpfc_rampdown_queue_depth - Post RAMP_DOWN_QUEUE event to worker thread

 * @phba: The Hba for which this call is being executed.

 *

 * This routine is called when there is resource error in driver or firmware.

 * This routine posts WORKER_RAMP_DOWN_QUEUE event for @phba. This routine

 * posts at most 1 event each second. This routine wakes up worker thread of

 * @phba to process WORKER_RAM_DOWN_EVENT event.

 *

 * This routine should be called with no lock held.

/**

 * lpfc_ramp_down_queue_handler - WORKER_RAMP_DOWN_QUEUE event handler

 * @phba: The Hba for which this call is being executed.

 *

 * This routine is called to  process WORKER_RAMP_DOWN_QUEUE event for worker

 * thread.This routine reduces queue depth for all scsi device on each vport

 * associated with @phba.

	/*

	 * The error and success command counters are global per

	 * driver instance.  If another handler has already

	 * operated on this error event, just exit.

/**

 * lpfc_scsi_dev_block - set all scsi hosts to block state

 * @phba: Pointer to HBA context object.

 *

 * This function walks vport list and set each SCSI host to block state

 * by invoking fc_remote_port_delete() routine. This function is invoked

 * with EEH when device's PCI slot has been permanently disabled.

/**

 * lpfc_new_scsi_buf_s3 - Scsi buffer allocator for HBA with SLI3 IF spec

 * @vport: The virtual port for which this call being executed.

 * @num_to_alloc: The requested number of buffers to allocate.

 *

 * This routine allocates a scsi buffer for device with SLI-3 interface spec,

 * the scsi buffer contains all the necessary information needed to initiate

 * a SCSI I/O. The non-DMAable buffer region contains information to build

 * the IOCB. The DMAable region contains memory for the FCP CMND, FCP RSP,

 * and the initial BPL. In addition to allocating memory, the FCP CMND and

 * FCP RSP BDEs are setup in the BPL and the BPL BDE is setup in the IOCB.

 *

 * Return codes:

 *   int - number of scsi buffers that were allocated.

 *   0 = failure, less than num_to_alloc is a partial failure.

		/*

		 * Get memory from the pci pool to map the virt space to pci

		 * bus space for an I/O.  The DMA buffer includes space for the

		 * struct fcp_cmnd, struct fcp_rsp and the number of bde's

		 * necessary to support the sg_tablesize.

 Allocate iotag for psb->cur_iocbq. */

 Initialize local short-hand pointers. */

		/*

		 * The first two bdes are the FCP_CMD and FCP_RSP. The balance

		 * are sg list bdes.  Initialize the first two and leave the

		 * rest for queuecommand.

 Setup the physical region for the FCP RSP */

		/*

		 * Since the IOCB for the FCP I/O is built into this

		 * lpfc_scsi_buf, initialize it with all known data now.

 fill in immediate fcp command BDE */

 fill in response BDE */

 Put it back into the SCSI buffer list */

/**

 * lpfc_sli4_vport_delete_fcp_xri_aborted -Remove all ndlp references for vport

 * @vport: pointer to lpfc vport data structure.

 *

 * This routine is invoked by the vport cleanup for deletions and the cleanup

 * for an ndlp on removal.

/**

 * lpfc_sli4_io_xri_aborted - Fast-path process of fcp xri abort

 * @phba: pointer to lpfc hba data structure.

 * @axri: pointer to the fcp xri abort wcqe structure.

 * @idx: index into hdwq

 *

 * This routine is invoked by the worker thread to process a SLI4 fast-path

 * FCP or NVME aborted xri.

				/* The sdev is not guaranteed to be valid post

				 * scsi_done upcall.

				/*

				 * We expect there is an abort thread waiting

				 * for command completion wake up the thread.

/**

 * lpfc_get_scsi_buf_s3 - Get a scsi buffer from lpfc_scsi_buf_list of the HBA

 * @phba: The HBA for which this call is being executed.

 * @ndlp: pointer to a node-list data structure.

 * @cmnd: Pointer to scsi_cmnd data structure.

 *

 * This routine removes a scsi buffer from head of @phba lpfc_scsi_buf_list list

 * and returns to caller.

 *

 * Return codes:

 *   NULL - Error

 *   Pointer to lpfc_scsi_buf - Success

/**

 * lpfc_get_scsi_buf_s4 - Get a scsi buffer from io_buf_list of the HBA

 * @phba: The HBA for which this call is being executed.

 * @ndlp: pointer to a node-list data structure.

 * @cmnd: Pointer to scsi_cmnd data structure.

 *

 * This routine removes a scsi buffer from head of @hdwq io_buf_list

 * and returns to caller.

 *

 * Return codes:

 *   NULL - Error

 *   Pointer to lpfc_scsi_buf - Success

	/* Setup key fields in buffer that may have been changed

	 * if other protocols used this buffer.

	/*

	 * The first two SGEs are the FCP_CMD and FCP_RSP.

	 * The balance are sg list bdes. Initialize the

	 * first two and leave the rest for queuecommand.

 Setup the physical region for the FCP RSP */

/**

 * lpfc_get_scsi_buf - Get a scsi buffer from lpfc_scsi_buf_list of the HBA

 * @phba: The HBA for which this call is being executed.

 * @ndlp: pointer to a node-list data structure.

 * @cmnd: Pointer to scsi_cmnd data structure.

 *

 * This routine removes a scsi buffer from head of @phba lpfc_scsi_buf_list list

 * and returns to caller.

 *

 * Return codes:

 *   NULL - Error

 *   Pointer to lpfc_scsi_buf - Success

/**

 * lpfc_release_scsi_buf_s3 - Return a scsi buffer back to hba scsi buf list

 * @phba: The Hba for which this call is being executed.

 * @psb: The scsi buffer which is being released.

 *

 * This routine releases @psb scsi buffer by adding it to tail of @phba

 * lpfc_scsi_buf_list list.

/**

 * lpfc_release_scsi_buf_s4: Return a scsi buffer back to hba scsi buf list.

 * @phba: The Hba for which this call is being executed.

 * @psb: The scsi buffer which is being released.

 *

 * This routine releases @psb scsi buffer by adding it to tail of @hdwq

 * io_buf_list list. For SLI4 XRI's are tied to the scsi buffer

 * and cannot be reused for at least RA_TOV amount of time if it was

 * aborted.

/**

 * lpfc_release_scsi_buf: Return a scsi buffer back to hba scsi buf list.

 * @phba: The Hba for which this call is being executed.

 * @psb: The scsi buffer which is being released.

 *

 * This routine releases @psb scsi buffer by adding it to tail of @phba

 * lpfc_scsi_buf_list list.

/**

 * lpfc_fcpcmd_to_iocb - copy the fcp_cmd data into the IOCB

 * @data: A pointer to the immediate command data portion of the IOCB.

 * @fcp_cmnd: The FCP Command that is provided by the SCSI layer.

 *

 * The routine copies the entire FCP command from @fcp_cmnd to @data while

 * byte swapping the data to big endian format for transmission on the wire.

/**

 * lpfc_scsi_prep_dma_buf_s3 - DMA mapping for scsi buffer to SLI3 IF spec

 * @phba: The Hba for which this call is being executed.

 * @lpfc_cmd: The scsi buffer which is going to be mapped.

 *

 * This routine does the pci dma mapping for scatter-gather list of scsi cmnd

 * field of @lpfc_cmd for device with SLI-3 interface spec. This routine scans

 * through sg elements and format the bde. This routine also initializes all

 * IOCB fields which are dependent on scsi command request buffer.

 *

 * Return codes:

 *   1 - Error

 *   0 - Success

	/*

	 * There are three possibilities here - use scatter-gather segment, use

	 * the single mapping, or neither.  Start the lpfc command prep by

	 * bumping the bpl beyond the fcp_cmnd and fcp_rsp regions to the first

	 * data bde entry.

		/*

		 * The driver stores the segment count returned from dma_map_sg

		 * because this a count of dma-mappings used to map the use_sg

		 * pages.  They are not guaranteed to be the same for those

		 * architectures that implement an IOMMU.

		/*

		 * The driver established a maximum scatter-gather segment count

		 * during probe that limits the number of sg elements in any

		 * single scsi command.  Just run through the seg_cnt and format

		 * the bde's.

		 * When using SLI-3 the driver will try to fit all the BDEs into

		 * the IOCB. If it can't then the BDEs get added to a BPL as it

		 * does for SLI-2 mode.

	/*

	 * Finish initializing those IOCB fields that are dependent on the

	 * scsi_cmnd request_buffer.  Note that for SLI-2 the bdeSize is

	 * explicitly reinitialized and for SLI-3 the extended bde count is

	 * explicitly reinitialized since all iocb memory resources are reused.

			/*

			 * The extended IOCB format can only fit 3 BDE or a BPL.

			 * This I/O has more than 3 BDE so the 1st data bde will

			 * be a BPL that is filled in here.

 ebde count includes the response bde and data bpl */

 ebde count includes the response bde and data bdes */

	/*

	 * Due to difference in data length between DIF/non-DIF paths,

	 * we need to set word 4 of IOCB here

 Return BG_ERR_INIT if error injection is detected by Initiator */

 Return BG_ERR_TGT if error injection is detected by Target */

 Return BG_ERR_SWAP if swapping CSUM<-->CRC is required for error injection */

/*

 * Return BG_ERR_CHECK if disabling Guard/Ref/App checking is required for

 * error injection

/**

 * lpfc_bg_err_inject - Determine if we should inject an error

 * @phba: The Hba for which this call is being executed.

 * @sc: The SCSI command to examine

 * @reftag: (out) BlockGuard reference tag for transmitted data

 * @apptag: (out) BlockGuard application tag for transmitted data

 * @new_guard: (in) Value to replace CRC with if needed

 *

 * Returns BG_ERR_* bit mask or 0 if request ignored

 s/g prot entry */

 First check if we need to match the LBA */

 Make sure we have the right LBA if one is specified */

 Next check if we need to match the remote NPortID or WWPN */

 Make sure we have the right NPortID if one is specified */

		/*

		 * Make sure we have the right WWPN if one is specified.

		 * wwn[0] should be a non-zero NAA in a good WWPN.

 Setup a ptr to the protection data if the SCSI host provides it */

 Should we change the Reference Tag */

					/*

					 * For WRITE_PASS, force the error

					 * to be sent on the wire. It should

					 * be detected by the Target.

					 * If blockoff != 0 error will be

					 * inserted in middle of the IO.

					/*

					 * Save the old ref_tag so we can

					 * restore it on completion.

				/*

				 * For WRITE_INSERT, force the error

				 * to be sent on the wire. It should be

				 * detected by the Target.

 DEADBEEF will be the reftag on the wire */

				/*

				 * For WRITE_STRIP and WRITE_PASS,

				 * force the error on data

				 * being copied from SLI-Host to SLI-Port.

				/*

				 * For READ_STRIP and READ_PASS, force the

				 * error on data being read off the wire. It

				 * should force an IO error to the driver.

 Should we change the Application Tag */

					/*

					 * For WRITE_PASS, force the error

					 * to be sent on the wire. It should

					 * be detected by the Target.

					 * If blockoff != 0 error will be

					 * inserted in middle of the IO.

					/*

					 * Save the old app_tag so we can

					 * restore it on completion.

				/*

				 * For WRITE_INSERT, force the

				 * error to be sent on the wire. It should be

				 * detected by the Target.

 DEAD will be the apptag on the wire */

				/*

				 * For WRITE_STRIP and WRITE_PASS,

				 * force the error on data

				 * being copied from SLI-Host to SLI-Port.

				/*

				 * For READ_STRIP and READ_PASS, force the

				 * error on data being read off the wire. It

				 * should force an IO error to the driver.

 Should we change the Guard Tag */

				/*

				 * For WRITE_INSERT, force the

				 * error to be sent on the wire. It should be

				 * detected by the Target.

 Signals the caller to swap CRC->CSUM */

				/*

				 * For WRITE_STRIP and WRITE_PASS,

				 * force the error on data

				 * being copied from SLI-Host to SLI-Port.

 Signals the caller to swap CRC->CSUM */

				/*

				 * For READ_STRIP and READ_PASS, force the

				 * error on data being read off the wire. It

				 * should force an IO error to the driver.

 Signals the caller to swap CRC->CSUM */

/**

 * lpfc_sc_to_bg_opcodes - Determine the BlockGuard opcodes to be used with

 * the specified SCSI command.

 * @phba: The Hba for which this call is being executed.

 * @sc: The SCSI command to examine

 * @txop: (out) BlockGuard operation for transmitted data

 * @rxop: (out) BlockGuard operation for received data

 *

 * Returns: zero on success; non-zero if tx and/or rx op cannot be determined

 *

/**

 * lpfc_bg_err_opcodes - reDetermine the BlockGuard opcodes to be used with

 * the specified SCSI command in order to force a guard tag error.

 * @phba: The Hba for which this call is being executed.

 * @sc: The SCSI command to examine

 * @txop: (out) BlockGuard operation for transmitted data

 * @rxop: (out) BlockGuard operation for received data

 *

 * Returns: zero on success; non-zero if tx and/or rx op cannot be determined

 *

/**

 * lpfc_bg_setup_bpl - Setup BlockGuard BPL with no protection data

 * @phba: The Hba for which this call is being executed.

 * @sc: pointer to scsi command we're working on

 * @bpl: pointer to buffer list for protection groups

 * @datasegcnt: number of segments of data that have been dma mapped

 *

 * This function sets up BPL buffer list for protection groups of

 * type LPFC_PG_TYPE_NO_DIF

 *

 * This is usually used when the HBA is instructed to generate

 * DIFs and insert them into data stream (or strip DIF from

 * incoming data stream)

 *

 * The buffer list consists of just one protection group described

 * below:

 *                                +-------------------------+

 *   start of prot group  -->     |          PDE_5          |

 *                                +-------------------------+

 *                                |          PDE_6          |

 *                                +-------------------------+

 *                                |         Data BDE        |

 *                                +-------------------------+

 *                                |more Data BDE's ... (opt)|

 *                                +-------------------------+

 *

 *

 * Note: Data s/g buffers have been dma mapped

 *

 * Returns the number of BDEs added to the BPL.

 s/g data entry */

 extract some info from the scsi command for pde*/

 setup PDE5 with what we have */

 Endianness conversion if necessary for PDE5 */

 advance bpl and increment bde count */

 setup PDE6 with the rest of the info */

	/*

	 * We only need to check the data on READs, for WRITEs

	 * protection data is automatically generated, not checked.

 Endianness conversion if necessary for PDE6 */

 advance bpl and increment bde count */

 assumption: caller has already run dma_map_sg on command data */

/**

 * lpfc_bg_setup_bpl_prot - Setup BlockGuard BPL with protection data

 * @phba: The Hba for which this call is being executed.

 * @sc: pointer to scsi command we're working on

 * @bpl: pointer to buffer list for protection groups

 * @datacnt: number of segments of data that have been dma mapped

 * @protcnt: number of segment of protection data that have been dma mapped

 *

 * This function sets up BPL buffer list for protection groups of

 * type LPFC_PG_TYPE_DIF

 *

 * This is usually used when DIFs are in their own buffers,

 * separate from the data. The HBA can then by instructed

 * to place the DIFs in the outgoing stream.  For read operations,

 * The HBA could extract the DIFs and place it in DIF buffers.

 *

 * The buffer list for this type consists of one or more of the

 * protection groups described below:

 *                                    +-------------------------+

 *   start of first prot group  -->   |          PDE_5          |

 *                                    +-------------------------+

 *                                    |          PDE_6          |

 *                                    +-------------------------+

 *                                    |      PDE_7 (Prot BDE)   |

 *                                    +-------------------------+

 *                                    |        Data BDE         |

 *                                    +-------------------------+

 *                                    |more Data BDE's ... (opt)|

 *                                    +-------------------------+

 *   start of new  prot group  -->    |          PDE_5          |

 *                                    +-------------------------+

 *                                    |          ...            |

 *                                    +-------------------------+

 *

 * Note: It is assumed that both data and protection s/g buffers have been

 *       mapped for DMA

 *

 * Returns the number of BDEs added to the BPL.

 s/g data entry */

 s/g prot entry */

 extract some info from the scsi command */

 Check to see if we ran out of space */

 setup PDE5 with what we have */

 Endianness conversion if necessary for PDE5 */

 advance bpl and increment bde count */

 setup PDE6 with the rest of the info */

 Endianness conversion if necessary for PDE6 */

 advance bpl and increment bde count */

 setup the first BDE that points to protection buffer */

 must be integer multiple of the DIF block length */

 check if this pde is crossing the 4K boundary; if so split */

 setup BDE's for data blocks associated with DIF data */

 total bytes processed for current prot grp */

 Check to see if we ran out of space */

 we can use this whole buffer */

 must split this buffer with next prot grp */

 Move to the next s/g segment if possible */

 update the reference tag */

 are we done ? */

 advance to next prot buffer */

 update the reference tag */

 if we're here, we have a bug */

/**

 * lpfc_bg_setup_sgl - Setup BlockGuard SGL with no protection data

 * @phba: The Hba for which this call is being executed.

 * @sc: pointer to scsi command we're working on

 * @sgl: pointer to buffer list for protection groups

 * @datasegcnt: number of segments of data that have been dma mapped

 * @lpfc_cmd: lpfc scsi command object pointer.

 *

 * This function sets up SGL buffer list for protection groups of

 * type LPFC_PG_TYPE_NO_DIF

 *

 * This is usually used when the HBA is instructed to generate

 * DIFs and insert them into data stream (or strip DIF from

 * incoming data stream)

 *

 * The buffer list consists of just one protection group described

 * below:

 *                                +-------------------------+

 *   start of prot group  -->     |         DI_SEED         |

 *                                +-------------------------+

 *                                |         Data SGE        |

 *                                +-------------------------+

 *                                |more Data SGE's ... (opt)|

 *                                +-------------------------+

 *

 *

 * Note: Data s/g buffers have been dma mapped

 *

 * Returns the number of SGEs added to the SGL.

 s/g data entry */

 extract some info from the scsi command for pde*/

 setup DISEED with what we have */

 Endianness conversion if necessary */

	/*

	 * We only need to check the data on READs, for WRITEs

	 * protection data is automatically generated, not checked.

 setup DISEED with the rest of the info */

 Endianness conversion if necessary for DISEED */

 advance bpl and increment sge count */

 assumption: caller has already run dma_map_sg on command data */

 clear it */

 do we need to expand the segment */

 set LSP type */

/**

 * lpfc_bg_setup_sgl_prot - Setup BlockGuard SGL with protection data

 * @phba: The Hba for which this call is being executed.

 * @sc: pointer to scsi command we're working on

 * @sgl: pointer to buffer list for protection groups

 * @datacnt: number of segments of data that have been dma mapped

 * @protcnt: number of segment of protection data that have been dma mapped

 * @lpfc_cmd: lpfc scsi command object pointer.

 *

 * This function sets up SGL buffer list for protection groups of

 * type LPFC_PG_TYPE_DIF

 *

 * This is usually used when DIFs are in their own buffers,

 * separate from the data. The HBA can then by instructed

 * to place the DIFs in the outgoing stream.  For read operations,

 * The HBA could extract the DIFs and place it in DIF buffers.

 *

 * The buffer list for this type consists of one or more of the

 * protection groups described below:

 *                                    +-------------------------+

 *   start of first prot group  -->   |         DISEED          |

 *                                    +-------------------------+

 *                                    |      DIF (Prot SGE)     |

 *                                    +-------------------------+

 *                                    |        Data SGE         |

 *                                    +-------------------------+

 *                                    |more Data SGE's ... (opt)|

 *                                    +-------------------------+

 *   start of new  prot group  -->    |         DISEED          |

 *                                    +-------------------------+

 *                                    |          ...            |

 *                                    +-------------------------+

 *

 * Note: It is assumed that both data and protection s/g buffers have been

 *       mapped for DMA

 *

 * Returns the number of SGEs added to the SGL.

 s/g data entry */

 s/g prot entry */

 extract some info from the scsi command */

 Check to see if we ran out of space */

 DISEED and DIF have to be together */

 set LSP type */

 setup DISEED with what we have */

 Endianness conversion if necessary */

			/*

			 * When in this mode, the hardware will replace

			 * the guard tag from the host with a

			 * newly generated good CRC for the wire.

			 * Switch to raw mode here to avoid this

			 * behavior. What the host sends gets put on the wire.

 setup DISEED with the rest of the info */

 Endianness conversion if necessary for DISEED */

 advance sgl and increment bde count */

 setup the first BDE that points to protection buffer */

 must be integer multiple of the DIF block length */

 Now setup DIF SGE */

 check if DIF SGE is crossing the 4K boundary; if so split */

 setup SGE's for data blocks associated with DIF data */

 total bytes processed for current prot grp */

 Check to see if we ran out of space */

 set LSP type */

 we can use this whole buffer */

					/* must split this buffer with next

					 * prot grp

 Move to the next s/g segment if possible */

 update the reference tag */

 are we done ? */

 mark the last SGL */

 advance to next prot buffer */

 update the reference tag */

 if we're here, we have a bug */

/**

 * lpfc_prot_group_type - Get prtotection group type of SCSI command

 * @phba: The Hba for which this call is being executed.

 * @sc: pointer to scsi command we're working on

 *

 * Given a SCSI command that supports DIF, determine composition of protection

 * groups involved in setting up buffer lists

 *

 * Returns: Protection group type (with or without DIF)

 *

/**

 * lpfc_bg_scsi_adjust_dl - Adjust SCSI data length for BlockGuard

 * @phba: The Hba for which this call is being executed.

 * @lpfc_cmd: The scsi buffer which is going to be adjusted.

 *

 * Adjust the data length to account for how much data

 * is actually on the wire.

 *

 * returns the adjusted data length

 Check if there is protection data on the wire */

 Read check for protection data */

 Write check for protection data */

	/*

	 * If we are in DIF Type 1 mode every data block has a 8 byte

	 * DIF (trailer) attached to it. Must ajust FCP data length

	 * to account for the protection data.

/**

 * lpfc_bg_scsi_prep_dma_buf_s3 - DMA mapping for scsi buffer to SLI3 IF spec

 * @phba: The Hba for which this call is being executed.

 * @lpfc_cmd: The scsi buffer which is going to be prep'ed.

 *

 * This is the protection/DIF aware version of

 * lpfc_scsi_prep_dma_buf(). It may be a good idea to combine the

 * two functions eventually, but for now, it's here.

 * RETURNS 0 - SUCCESS,

 *         1 - Failed DMA map, retry.

 *         2 - Invalid scsi cmd or prot-type. Do not rety.

	/*

	 * Start the lpfc command prep by bumping the bpl beyond fcp_cmnd

	 *  fcp_rsp regions to the first data bde entry

		/*

		 * The driver stores the segment count returned from dma_map_sg

		 * because this a count of dma-mappings used to map the use_sg

		 * pages.  They are not guaranteed to be the same for those

		 * architectures that implement an IOMMU.

 First check if data segment count from SCSI Layer is good */

 Here we need to add a PDE5 and PDE6 to the count */

 we should have 2 or more entries in buffer list */

			/*

			 * This type indicates that protection buffers are

			 * passed to the driver, so that needs to be prepared

			 * for DMA

			/*

			 * There is a minimun of 4 BPLs used for every

			 * protection data segment.

 we should have 3 or more entries in buffer list */

	/*

	 * Finish initializing those IOCB fields that are dependent on the

	 * scsi_cmnd request_buffer.  Note that the bdeSize is explicitly

	 * reinitialized since all iocb memory resources are used many times

	 * for transmit, receive, and continuation bpl's.

	/*

	 * Due to difference in data length between DIF/non-DIF paths,

	 * we need to set word 4 of IOCB here

	/*

	 * For First burst, we may need to adjust the initial transfer

	 * length for DIF

/*

 * This function calcuates the T10 DIF guard tag

 * on the specified data using a CRC algorithmn

 * using crc_t10dif.

/*

 * This function calcuates the T10 DIF guard tag

 * on the specified data using a CSUM algorithmn

 * using ip_compute_csum.

/*

 * This function examines the protection data to try to determine

 * what type of T10-DIF error occurred.

 s/g prot entry */

 s/g data entry */

 First check to see if there is protection data to examine */

 Currently the driver just supports ref_tag and guard_tag checking */

 Setup a ptr to the protection data provided by the SCSI host */

		/*

		 * We will only try to verify guard tag if the segment

		 * data length is a multiple of the blksize.

				/*

				 * First check to see if a protection data

				 * check is valid

 First Guard Tag checking */

 Reference Tag checking */

 App Tag checking */

				/*

				 * Are we at the end of the Data segment?

				 * The data segment is only used for Guard

				 * tag checking.

 Goto the next Protection data segment */

/*

 * This function checks for BlockGuard errors detected by

 * the HBA.  In case of errors, the ASC/ASCQ fields in the

 * sense buffer will be set accordingly, paired with

 * ILLEGAL_REQUEST to signal to the kernel that the HBA

 * detected corruption.

 *

 * Returns:

 *  0 - No error found

 *  1 - BlockGuard error found

 * -1 - Internal error (bad profile, ...etc)

 Guard Check failed */

 AppTag Check failed */

 RefTag Check failed */

 Check to see if there was any good data before the error */

		/*

		 * Set ALL the error bits to indicate we don't know what

		 * type of error it is.

		/*

		 * setup sense data descriptor 0 per SPC-4 as an information

		 * field, and put the failing LBA in it.

		 * This code assumes there was also a guard/app/ref tag error

		 * indication.

 Additional sense length */

 Information descriptor type */

 Additional descriptor length */

 Validity bit */

 bghm is a "on the wire" FC frame based count */

 Descriptor Information */

 No error was reported - problem in FW? */

 Calculate what type of error it was */

/*

 * This function checks for BlockGuard errors detected by

 * the HBA.  In case of errors, the ASC/ASCQ fields in the

 * sense buffer will be set accordingly, paired with

 * ILLEGAL_REQUEST to signal to the kernel that the HBA

 * detected corruption.

 *

 * Returns:

 *  0 - No error found

 *  1 - BlockGuard error found

 * -1 - Internal error (bad profile, ...etc)

		/*

		 * setup sense data descriptor 0 per SPC-4 as an information

		 * field, and put the failing LBA in it.

		 * This code assumes there was also a guard/app/ref tag error

		 * indication.

 Additional sense length */

 Information descriptor type */

 Additional descriptor length */

 Validity bit */

 bghm is a "on the wire" FC frame based count */

 Descriptor Information */

 No error was reported - problem in FW? */

 Calculate what type of error it was */

/**

 * lpfc_scsi_prep_dma_buf_s4 - DMA mapping for scsi buffer to SLI4 IF spec

 * @phba: The Hba for which this call is being executed.

 * @lpfc_cmd: The scsi buffer which is going to be mapped.

 *

 * This routine does the pci dma mapping for scatter-gather list of scsi cmnd

 * field of @lpfc_cmd for device with SLI-4 interface spec.

 *

 * Return codes:

 *	2 - Error - Do not retry

 *	1 - Error - Retry

 *	0 - Success

	/*

	 * There are three possibilities here - use scatter-gather segment, use

	 * the single mapping, or neither.  Start the lpfc command prep by

	 * bumping the bpl beyond the fcp_cmnd and fcp_rsp regions to the first

	 * data bde entry.

		/*

		 * The driver stores the segment count returned from dma_map_sg

		 * because this a count of dma-mappings used to map the use_sg

		 * pages.  They are not guaranteed to be the same for those

		 * architectures that implement an IOMMU.

 clear the last flag in the fcp_rsp map entry */

		/*

		 * The driver established a maximum scatter-gather segment count

		 * during probe that limits the number of sg elements in any

		 * single scsi command.  Just run through the seg_cnt and format

		 * the sge's.

		 * When using SLI-3 the driver will try to fit all the BDEs into

		 * the IOCB. If it can't then the BDEs get added to a BPL as it

		 * does for SLI-2 mode.

 for tracking segment boundaries */

 do we need to expand the segment */

 set LSP type */

		/* PBDE support for first data SGE only.

		 * For FCoE, we key off Performance Hints.

		 * For FC, we key off lpfc_enable_pbde.

 Words 13-15 */

 Word 11 - set PBDE bit */

 Word 11 - PBDE bit disabled by default template */

 set the last flag in the fcp_rsp map entry */

	/*

	 * Finish initializing those IOCB fields that are dependent on the

	 * scsi_cmnd request_buffer.  Note that for SLI-2 the bdeSize is

	 * explicitly reinitialized.

	 * all iocb memory resources are reused.

 Set first-burst provided it was successfully negotiated */

 Word 4 & 5 */

 Word 4 */

	/*

	 * If the OAS driver feature is enabled and the lun is enabled for

	 * OAS, set the oas iocb related flags.

 Word 10 */

/**

 * lpfc_bg_scsi_prep_dma_buf_s4 - DMA mapping for scsi buffer to SLI4 IF spec

 * @phba: The Hba for which this call is being executed.

 * @lpfc_cmd: The scsi buffer which is going to be mapped.

 *

 * This is the protection/DIF aware version of

 * lpfc_scsi_prep_dma_buf(). It may be a good idea to combine the

 * two functions eventually, but for now, it's here

 * Return codes:

 *	2 - Error - Do not retry

 *	1 - Error - Retry

 *	0 - Success

	/*

	 * Start the lpfc command prep by bumping the sgl beyond fcp_cmnd

	 *  fcp_rsp regions to the first data sge entry

		/*

		 * The driver stores the segment count returned from dma_map_sg

		 * because this a count of dma-mappings used to map the use_sg

		 * pages.  They are not guaranteed to be the same for those

		 * architectures that implement an IOMMU.

 clear the last flag in the fcp_rsp map entry */

 First check if data segment count from SCSI Layer is good */

 Here we need to add a DISEED to the count */

 we should have 2 or more entries in buffer list */

			/*

			 * This type indicates that protection buffers are

			 * passed to the driver, so that needs to be prepared

			 * for DMA

			/*

			 * There is a minimun of 3 SGEs used for every

			 * protection data segment.

 we should have 3 or more entries in buffer list */

 Set first-burst provided it was successfully negotiated */

 Word 4 & 5 */

 Word 4 */

	/*

	 * If the OAS driver feature is enabled and the lun is enabled for

	 * OAS, set the oas iocb related flags.

 Word 10 */

 Word 7. DIF Flags */

/**

 * lpfc_scsi_prep_dma_buf - Wrapper function for DMA mapping of scsi buffer

 * @phba: The Hba for which this call is being executed.

 * @lpfc_cmd: The scsi buffer which is going to be mapped.

 *

 * This routine wraps the actual DMA mapping function pointer from the

 * lpfc_hba struct.

 *

 * Return codes:

 *	1 - Error

 *	0 - Success

/**

 * lpfc_bg_scsi_prep_dma_buf - Wrapper function for DMA mapping of scsi buffer

 * using BlockGuard.

 * @phba: The Hba for which this call is being executed.

 * @lpfc_cmd: The scsi buffer which is going to be mapped.

 *

 * This routine wraps the actual DMA mapping function pointer from the

 * lpfc_hba struct.

 *

 * Return codes:

 *	1 - Error

 *	0 - Success

/**

 * lpfc_scsi_prep_cmnd_buf - Wrapper function for IOCB/WQE mapping of scsi

 * buffer

 * @vport: Pointer to vport object.

 * @lpfc_cmd: The scsi buffer which is going to be mapped.

 * @tmo: Timeout value for IO

 *

 * This routine initializes IOCB/WQE data structure from scsi command

 *

 * Return codes:

 *	1 - Error

 *	0 - Success

/**

 * lpfc_send_scsi_error_event - Posts an event when there is SCSI error

 * @phba: Pointer to hba context object.

 * @vport: Pointer to vport object.

 * @lpfc_cmd: Pointer to lpfc scsi command which reported the error.

 * @fcpi_parm: FCP Initiator parameter.

 *

 * This function posts an event when there is a SCSI command reporting

 * error from the scsi device.

 If there is queuefull or busy condition send a scsi event */

		/*

		 * If status is good or resid does not match with fcp_param and

		 * there is valid fcpi_parm, then there is a read_check error

/**

 * lpfc_scsi_unprep_dma_buf - Un-map DMA mapping of SG-list for dev

 * @phba: The HBA for which this call is being executed.

 * @psb: The scsi buffer which is going to be un-mapped.

 *

 * This routine does DMA un-mapping of scatter gather list of scsi command

 * field of @lpfc_cmd for device with SLI-3 interface spec.

	/*

	 * There are only two special cases to consider.  (1) the scsi command

	 * requested scatter-gather usage or (2) the scsi command allocated

	 * a request buffer, but did not request use_sg.  There is a third

	 * case, but it does not require resource deallocation.

/**

 * lpfc_unblock_requests - allow further commands to be queued.

 * @phba: pointer to phba object

 *

 * For single vport, just call scsi_unblock_requests on physical port.

 * For multiple vports, send scsi_unblock_requests for all the vports.

/**

 * lpfc_block_requests - prevent further commands from being queued.

 * @phba: pointer to phba object

 *

 * For single vport, just call scsi_block_requests on physical port.

 * For multiple vports, send scsi_block_requests for all the vports.

/**

 * lpfc_update_cmf_cmpl - Adjust CMF counters for IO completion

 * @phba: The HBA for which this call is being executed.

 * @time: The latency of the IO that completed (in ns)

 * @size: The size of the IO that completed

 * @shost: SCSI host the IO completed on (NULL for a NVME IO)

 *

 * The routine adjusts the various Burst and Bandwidth counters used in

 * Congestion management and E2E. If time is set to LPFC_CGN_NOT_SENT,

 * that means the IO was never issued to the HBA, so this routine is

 * just being called to cleanup the counter from a previous

 * lpfc_update_cmf_cmd call.

 lat is ns coming in, save latency in us */

 round it */

/**

 * lpfc_update_cmf_cmd - Adjust CMF counters for IO submission

 * @phba: The HBA for which this call is being executed.

 * @size: The size of the IO that will be issued

 *

 * The routine adjusts the various Burst and Bandwidth counters used in

 * Congestion management and E2E.

 At this point we are either LPFC_CFG_MANAGED or LPFC_CFG_MONITOR */

/**

 * lpfc_handle_fcp_err - FCP response handler

 * @vport: The virtual port for which this call is being executed.

 * @lpfc_cmd: Pointer to lpfc_io_buf data structure.

 * @fcpi_parm: FCP Initiator parameter.

 *

 * This routine is called to process response IOCB with status field

 * IOSTAT_FCP_RSP_ERROR. This routine sets result field of scsi command

 * based upon SCSI and FCP error.

	/*

	 *  If this is a task management command, there is no

	 *  scsi packet associated with this lpfc_cmd.  The driver

	 *  consumes it.

 special handling for under run conditions */

 don't log under runs if fcp set... */

 unless operator says so */

		/*

		 * If there is an under run, check if under run reported by

		 * storage array is same as the under run reported by HBA.

		 * If this is not same, there is a dropped frame.

		/*

		 * The cmnd->underflow is the minimum number of bytes that must

		 * be transferred for this command.  Provided a sense condition

		 * is not present, make sure the actual amount transferred is at

		 * least the underflow value or fail.

	/*

	 * Check SLI validation that all the transfer was actually done

	 * (fcpi_parm should be zero). Apply check only to reads.

		/* There is some issue with the LPe12000 that causes it

		 * to miscalculate the fcpi_parm and falsely trip this

		 * recovery logic.  Detect this case and don't error when true.

			/* Fabric dropped a data frame. Fail any successful

			 * command in which we detected dropped frames.

			 * A status of good or some check conditions could

			 * be considered a successful command.

/**

 * lpfc_fcp_io_cmd_wqe_cmpl - Complete a FCP IO

 * @phba: The hba for which this call is being executed.

 * @pwqeIn: The command WQE for the scsi cmnd.

 * @wcqe: Pointer to driver response CQE object.

 *

 * This routine assigns scsi command result by looking into response WQE

 * status field appropriately. This routine handles QUEUE FULL condition as

 * well by ramping down device queue depth.

 Sanity check on return of outstanding command */

		/* TOREMOVE - currently this flag is checked during

		 * the release of lpfc_iocbq. Remove once we move

		 * to lpfc_wqe_job construct.

		 *

		 * This needs to be done outside buf_lock

 Guard against abort handler being called at same time */

 Sanity check on return of outstanding command */

		/*

		 * Used to restore any changes to protection

		 * data for error injection.

			/* This I/O was aborted by the target, we don't

			 * know the rxid and because we did not send the

			 * ABTS we cannot generate and RRQ.

				/*

				 * This is a response for a BG enabled

				 * cmd. Parse BG error

 Check if IO qualified for CMF */

 Used when calculating average latency */

 The sdev is not guaranteed to be valid post scsi_done upcall. */

	/*

	 * If there is an abort thread waiting for command completion

	 * wake up the thread.

/**

 * lpfc_scsi_cmd_iocb_cmpl - Scsi cmnd IOCB completion routine

 * @phba: The Hba for which this call is being executed.

 * @pIocbIn: The command IOCBQ for the scsi cmnd.

 * @pIocbOut: The response IOCBQ for the scsi cmnd.

 *

 * This routine assigns scsi command result by looking into response IOCB

 * status field appropriately. This routine handles QUEUE FULL condition as

 * well by ramping down device queue depth.

 Guard against abort handler being called at same time */

 Sanity check on return of outstanding command */

 pick up SLI4 exchange busy status from HBA */

		/*

		 * Used to restore any changes to protection

		 * data for error injection.

 Call FCP RSP handler to determine result */

					/*

					 * This is a response for a BG enabled

					 * cmd. Parse BG error

				/* This IO was aborted by the target, we don't

				 * know the rxid and because we did not send the

				 * ABTS we cannot generate and RRQ.

 The sdev is not guaranteed to be valid post scsi_done upcall. */

	/*

	 * If there is an abort thread waiting for command completion

	 * wake up the thread.

/**

 * lpfc_scsi_prep_cmnd_buf_s3 - SLI-3 IOCB init for the IO

 * @vport: Pointer to vport object.

 * @lpfc_cmd: The scsi buffer which is going to be prep'ed.

 * @tmo: timeout value for the IO

 *

 * Based on the data-direction of the command, initialize IOCB

 * in the I/O buffer. Fill in the IOCB fields which are independent

 * of the scsi buffer

 *

 * RETURNS 0 - SUCCESS,

	/*

	 * There are three possibilities here - use scatter-gather segment, use

	 * the single mapping, or neither.  Start the lpfc command prep by

	 * bumping the bpl beyond the fcp_cmnd and fcp_rsp regions to the first

	 * data bde entry.

	/*

	 * Finish initializing those IOCB fields that are independent

	 * of the scsi_cmnd request_buffer

/**

 * lpfc_scsi_prep_cmnd_buf_s4 - SLI-4 WQE init for the IO

 * @vport: Pointer to vport object.

 * @lpfc_cmd: The scsi buffer which is going to be prep'ed.

 * @tmo: timeout value for the IO

 *

 * Based on the data-direction of the command copy WQE template

 * to I/O buffer WQE. Fill in the WQE fields which are independent

 * of the scsi buffer

 *

 * RETURNS 0 - SUCCESS,

 Initialize 64 bytes only */

	/*

	 * There are three possibilities here - use scatter-gather segment, use

	 * the single mapping, or neither.

 From the iwrite template, initialize words 7 -  11 */

 From the iread template, initialize words 7 - 11 */

 Word 7 */

 For a CMF Managed port, iod must be zero'ed */

 From the icmnd template, initialize words 4 - 11 */

 Word 7 */

	/*

	 * Finish initializing those WQE fields that are independent

	 * of the request_buffer

 Word 3 */

 Word 6 */

 Word 7*/

 Word 8 */

 Word 9 */

/**

 * lpfc_scsi_prep_cmnd - Wrapper func for convert scsi cmnd to FCP info unit

 * @vport: The virtual port for which this call is being executed.

 * @lpfc_cmd: The scsi command which needs to send.

 * @pnode: Pointer to lpfc_nodelist.

 *

 * This routine initializes fcp_cmnd and iocb data structure from scsi command

 * to transfer for device with SLI3 interface spec.

 clear task management bits */

/**

 * lpfc_scsi_prep_task_mgmt_cmd - Convert SLI3 scsi TM cmd to FCP info unit

 * @vport: The virtual port for which this call is being executed.

 * @lpfc_cmd: Pointer to lpfc_io_buf data structure.

 * @lun: Logical unit number.

 * @task_mgmt_cmd: SCSI task management command.

 *

 * This routine creates FCP information unit corresponding to @task_mgmt_cmd

 * for device with SLI-3 interface spec.

 *

 * Return codes:

 *   0 - Error

 *   1 - Success

 Clear out any old data in the FCP command area */

 ulpTimeout is only one byte */

		/*

		 * Do not timeout the command at the firmware level.

		 * The driver will provide the timeout mechanism.

/**

 * lpfc_scsi_api_table_setup - Set up scsi api function jump table

 * @phba: The hba struct for which this call is being executed.

 * @dev_grp: The HBA PCI-Device group number.

 *

 * This routine sets up the SCSI interface API function jump table in @phba

 * struct.

 * Returns: 0 - success, -ENODEV - failure.

/**

 * lpfc_tskmgmt_def_cmpl - IOCB completion routine for task management command

 * @phba: The Hba for which this call is being executed.

 * @cmdiocbq: Pointer to lpfc_iocbq data structure.

 * @rspiocbq: Pointer to lpfc_iocbq data structure.

 *

 * This routine is IOCB completion routine for device reset and target reset

 * routine. This routine release scsi buffer associated with lpfc_cmd.

/**

 * lpfc_check_pci_resettable - Walks list of devices on pci_dev's bus to check

 *                             if issuing a pci_bus_reset is possibly unsafe

 * @phba: lpfc_hba pointer.

 *

 * Description:

 * Walks the bus_list to ensure only PCI devices with Emulex

 * vendor id, device ids that support hot reset, and only one occurrence

 * of function 0.

 *

 * Returns:

 * -EBADSLT,  detected invalid device

 *      0,    successful

 Walk the list of devices on the pci_dev's bus */

 Check for Emulex Vendor ID */

 Check for valid Emulex Device ID */

		/* Check for only one function 0 ID to ensure only one HBA on

		 * secondary bus

/**

 * lpfc_info - Info entry point of scsi_host_template data structure

 * @host: The scsi host for which this call is being executed.

 *

 * This routine provides module information about hba.

 *

 * Reutrn code:

 *   Pointer to char - Success.

 Model Description */

 PCI Info */

 Port Number */

 Link Speed */

 PCI resettable */

/**

 * lpfc_poll_rearm_timer - Routine to modify fcp_poll timer of hba

 * @phba: The Hba for which this call is being executed.

 *

 * This routine modifies fcp_poll_timer  field of @phba by cfg_poll_tmo.

 * The default value of cfg_poll_tmo is 10 milliseconds.

/**

 * lpfc_poll_start_timer - Routine to start fcp_poll_timer of HBA

 * @phba: The Hba for which this call is being executed.

 *

 * This routine starts the fcp_poll_timer of @phba.

/**

 * lpfc_poll_timeout - Restart polling timer

 * @t: Timer construct where lpfc_hba data structure pointer is obtained.

 *

 * This routine restarts fcp_poll timer, when FCP ring  polling is enable

 * and FCP Ring interrupt is disable.

/*

 * lpfc_get_vmid_from_hashtable - search the UUID in the hash table

 * @vport: The virtual port for which this call is being executed.

 * @hash: calculated hash value

 * @buf: uuid associated with the VE

 * Return the VMID entry associated with the UUID

 * Make sure to acquire the appropriate lock before invoking this routine.

/*

 * lpfc_put_vmid_in_hashtable - put the VMID in the hash table

 * @vport: The virtual port for which this call is being executed.

 * @hash - calculated hash value

 * @vmp: Pointer to a VMID entry representing a VM sending I/O

 *

 * This routine will insert the newly acquired VMID entity in the hash table.

 * Make sure to acquire the appropriate lock before invoking this routine.

/*

 * lpfc_vmid_hash_fn - create a hash value of the UUID

 * @vmid: uuid associated with the VE

 * @len: length of the VMID string

 * Returns the calculated hash value

/*

 * lpfc_vmid_update_entry - update the vmid entry in the hash table

 * @vport: The virtual port for which this call is being executed.

 * @cmd: address of scsi cmd descriptor

 * @vmp: Pointer to a VMID entry representing a VM sending I/O

 * @tag: VMID tag

 update the last access timestamp in the table */

/*

 * lpfc_vmid_get_appid - get the VMID associated with the UUID

 * @vport: The virtual port for which this call is being executed.

 * @uuid: UUID associated with the VE

 * @cmd: address of scsi_cmd descriptor

 * @tag: VMID tag

 * Returns status of the function

 check if QFPA is complete */

 search if the UUID has already been mapped to the VMID */

 search for the VMID in the table */

 if found, check if its already registered  */

 else if register or dereg request has already been sent */

 Hence VMID tag will not be added for this I/O */

 The VMID was not found in the hashtable. At this point, */

 drop the read lock first before proceeding further */

 start the process to obtain one as per the */

 type of the VMID indicated */

 while the read lock was released, in case the entry was */

 added by other context or is in process of being added */

 else search and allocate a free slot in the hash table */

 Add the vmid and register */

 if type priority tag, get next available VMID */

 allocate the per cpu variable for holding */

 the last access time stamp only if VMID is enabled */

 complete transaction with switch */

 finally, enable the idle timer once */

/*

 * lpfc_is_command_vm_io - get the UUID from blk cgroup

 * @cmd: Pointer to scsi_cmnd data structure

 * Returns UUID if present, otherwise NULL

/**

 * lpfc_queuecommand - scsi_host_template queuecommand entry point

 * @shost: kernel scsi host pointer.

 * @cmnd: Pointer to scsi_cmnd data structure.

 *

 * Driver registers this routine to scsi midlayer to submit a @cmd to process.

 * This routine prepares an IOCB from scsi command and provides to firmware.

 * The @done callback is invoked after driver finished processing the command.

 *

 * Return value :

 *   0 - Success

 *   SCSI_MLQUEUE_HOST_BUSY - Block all devices served by this host temporarily.

 sanity check on references */

	/*

	 * Catch race where our node has transitioned, but the

	 * transport is still transitioning.

 Check if IO qualifies for CMF */

 Latency start time saved in rx_cmd_start later in routine */

	/*

	 * Store the midlayer's command structure for the completion phase

	 * and complete the command initialization.

 check the necessary and sufficient condition to support VMID */

 is the I/O generated by a VM, get the associated virtual */

 entity id */

 Issue I/O to adapter */

/*

 * lpfc_vmid_vport_cleanup - cleans up the resources associated with a vport

 * @vport: The virtual port for which this call is being executed.

/**

 * lpfc_abort_handler - scsi_host_template eh_abort_handler entry point

 * @cmnd: Pointer to scsi_cmnd data structure.

 *

 * This routine aborts @cmnd pending in base driver.

 *

 * Return code :

 *   0x2003 - Error

 *   0x2002 - Success

 driver queued commands are in process of being flushed */

 Guard against IO completion being called at same time */

 the command is in process of being cancelled */

	/*

	 * If pCmd field of the corresponding lpfc_io_buf structure

	 * points to a different SCSI command, then the driver has

	 * already completed this command, but the midlayer did not

	 * see the completion before the eh fired. Just return SUCCESS.

 abort issued in recovery is still in progress */

 Make sure HBA is alive */

 Indicate the IO is not being aborted by the driver. */

 no longer need the lock after this point */

	/*

	 * iocb_flag is set to LPFC_DRIVER_ABORTED before we wait

	 * for abort to complete.

/**

 * lpfc_check_fcp_rsp - check the returned fcp_rsp to see if task failed

 * @vport: The virtual port for which this call is being executed.

 * @lpfc_cmd: Pointer to lpfc_io_buf data structure.

 *

 * This routine checks the FCP RSP INFO to see if the tsk mgmt command succeded

 *

 * Return code :

 *   0x2003 - Error

 *   0x2002 - Success

		/* If FCP_RSP_LEN_VALID bit is one, then the FCP_RSP_LEN

		 * field specifies the number of valid bytes of FCP_RSP_INFO.

		 * The FCP_RSP_LEN field shall be set to 0x04 or 0x08

 TM rejected */

 TM failed */

 TM to invalid LU! */

/**

 * lpfc_send_taskmgmt - Generic SCSI Task Mgmt Handler

 * @vport: The virtual port for which this call is being executed.

 * @cmnd: Pointer to scsi_cmnd data structure.

 * @tgt_id: Target ID of remote device.

 * @lun_id: Lun number for the TMF

 * @task_mgmt_cmd: type of TMF to send

 *

 * This routine builds and sends a TMF (SCSI Task Mgmt Function) to

 * a remote port.

 *

 * Return Code:

 *   0x2003 - Error

 *   0x2002 - Success.

 if ulpStatus != IOCB_SUCCESS, then status == IOCB_SUCCESS */

				/* Something in the FCP_RSP was invalid.

/**

 * lpfc_chk_tgt_mapped -

 * @vport: The virtual port to check on

 * @cmnd: Pointer to scsi_cmnd data structure.

 *

 * This routine delays until the scsi target (aka rport) for the

 * command exists (is present and logged in) or we declare it non-existent.

 *

 * Return code :

 *  0x2003 - Error

 *  0x2002 - Success

	/*

	 * If target is not in a MAPPED state, delay until

	 * target is rediscovered or devloss timeout expires.

/**

 * lpfc_reset_flush_io_context -

 * @vport: The virtual port (scsi_host) for the flush context

 * @tgt_id: If aborting by Target contect - specifies the target id

 * @lun_id: If aborting by Lun context - specifies the lun id

 * @context: specifies the context level to flush at.

 *

 * After a reset condition via TMF, we need to flush orphaned i/o

 * contexts from the adapter. This routine aborts any contexts

 * outstanding, then waits for their completions. The wait is

 * bounded by devloss_tmo though.

 *

 * Return code :

 *  0x2003 - Error

 *  0x2002 - Success

/**

 * lpfc_device_reset_handler - scsi_host_template eh_device_reset entry point

 * @cmnd: Pointer to scsi_cmnd data structure.

 *

 * This routine does a device reset by sending a LUN_RESET task management

 * command.

 *

 * Return code :

 *  0x2003 - Error

 *  0x2002 - Success

	/*

	 * We have to clean up i/o as : they may be orphaned by the TMF;

	 * or if the TMF failed, they may be in an indeterminate state.

	 * So, continue on.

	 * We will report success if all the i/o aborts successfully.

/**

 * lpfc_target_reset_handler - scsi_host_template eh_target_reset entry point

 * @cmnd: Pointer to scsi_cmnd data structure.

 *

 * This routine does a target reset by sending a TARGET_RESET task management

 * command.

 *

 * Return code :

 *  0x2003 - Error

 *  0x2002 - Success

 Issue LOGO, if no LOGO is outstanding */

	/*

	 * We have to clean up i/o as : they may be orphaned by the TMF;

	 * or if the TMF failed, they may be in an indeterminate state.

	 * So, continue on.

	 * We will report success if all the i/o aborts successfully.

/**

 * lpfc_bus_reset_handler - scsi_host_template eh_bus_reset_handler entry point

 * @cmnd: Pointer to scsi_cmnd data structure.

 *

 * This routine does target reset to all targets on @cmnd->device->host.

 * This emulates Parallel SCSI Bus Reset Semantics.

 *

 * Return code :

 *  0x2003 - Error

 *  0x2002 - Success

	/*

	 * Since the driver manages a single bus device, reset all

	 * targets known to the driver.  Should any target reset

	 * fail, this routine returns failure to the midlayer.

 Search for mapped node by target ID */

	/*

	 * We have to clean up i/o as : they may be orphaned by the TMFs

	 * above; or if any of the TMFs failed, they may be in an

	 * indeterminate state.

	 * We will report success if all the i/o aborts successfully.

/**

 * lpfc_host_reset_handler - scsi_host_template eh_host_reset_handler entry pt

 * @cmnd: Pointer to scsi_cmnd data structure.

 *

 * This routine does host reset to the adaptor port. It brings the HBA

 * offline, performs a board restart, and then brings the board back online.

 * The lpfc_offline calls lpfc_sli_hba_down which will abort and local

 * reject all outstanding SCSI commands to the host and error returned

 * back to SCSI mid-level. As this will be SCSI mid-level's last resort

 * of error handling, it will only return error if resetting of the adapter

 * is not successful; in all other cases, will return success.

 *

 * Return code :

 *  0x2003 - Error

 *  0x2002 - Success

 Wait for successful restart of adapter */

/**

 * lpfc_slave_alloc - scsi_host_template slave_alloc entry point

 * @sdev: Pointer to scsi_device.

 *

 * This routine populates the cmds_per_lun count + 2 scsi_bufs into  this host's

 * globally available list of scsi buffers. This routine also makes sure scsi

 * buffer is not allocated more than HBA limit conveyed to midlayer. This list

 * of scsi buffer exists for the lifetime of the driver.

 *

 * Return codes:

 *   non-0 - Error

 *   0 - Success

		/*

		 * Check to see if the device data structure for the lun

		 * exists.  If not, create one.

 For SLI4, all IO buffers are pre-allocated */

 This code path is now ONLY for SLI3 adapters */

	/*

	 * Populate the cmds_per_lun count scsi_bufs into this host's globally

	 * available list of scsi buffers.  Don't allocate more than the

	 * HBA limit conveyed to the midlayer via the host structure.  The

	 * formula accounts for the lun_queue_depth + error handlers + 1

	 * extra.  This list of scsi bufs exists for the lifetime of the driver.

 If allocated buffers are enough do nothing */

 Allow some exchanges to be available always to complete discovery */

 Allow some exchanges to be available always to complete discovery */

/**

 * lpfc_slave_configure - scsi_host_template slave_configure entry point

 * @sdev: Pointer to scsi_device.

 *

 * This routine configures following items

 *   - Tag command queuing support for @sdev if supported.

 *   - Enable SLI polling for fcp ring if ENABLE_FCP_RING_POLLING flag is set.

 *

 * Return codes:

 *   0 - Success

/**

 * lpfc_slave_destroy - slave_destroy entry point of SHT data structure

 * @sdev: Pointer to scsi_device.

 *

 * This routine sets @sdev hostatdata filed to null.

/**

 * lpfc_create_device_data - creates and initializes device data structure for OAS

 * @phba: Pointer to host bus adapter structure.

 * @vport_wwpn: Pointer to vport's wwpn information

 * @target_wwpn: Pointer to target's wwpn information

 * @lun: Lun on target

 * @pri: Priority

 * @atomic_create: Flag to indicate if memory should be allocated using the

 *		  GFP_ATOMIC flag or not.

 *

 * This routine creates a device data structure which will contain identifying

 * information for the device (host wwpn, target wwpn, lun), state of OAS,

 * whether or not the corresponding lun is available by the system,

 * and pointer to the rport data.

 *

 * Return codes:

 *   NULL - Error

 *   Pointer to lpfc_device_data - Success

 Attempt to create the device data to contain lun info */

/**

 * lpfc_delete_device_data - frees a device data structure for OAS

 * @phba: Pointer to host bus adapter structure.

 * @lun_info: Pointer to device data structure to free.

 *

 * This routine frees the previously allocated device data structure passed.

 *

/**

 * __lpfc_get_device_data - returns the device data for the specified lun

 * @phba: Pointer to host bus adapter structure.

 * @list: Point to list to search.

 * @vport_wwpn: Pointer to vport's wwpn information

 * @target_wwpn: Pointer to target's wwpn information

 * @lun: Lun on target

 *

 * This routine searches the list passed for the specified lun's device data.

 * This function does not hold locks, it is the responsibility of the caller

 * to ensure the proper lock is held before calling the function.

 *

 * Return codes:

 *   NULL - Error

 *   Pointer to lpfc_device_data - Success

 Check to see if the lun is already enabled for OAS. */

/**

 * lpfc_find_next_oas_lun - searches for the next oas lun

 * @phba: Pointer to host bus adapter structure.

 * @vport_wwpn: Pointer to vport's wwpn information

 * @target_wwpn: Pointer to target's wwpn information

 * @starting_lun: Pointer to the lun to start searching for

 * @found_vport_wwpn: Pointer to the found lun's vport wwpn information

 * @found_target_wwpn: Pointer to the found lun's target wwpn information

 * @found_lun: Pointer to the found lun.

 * @found_lun_status: Pointer to status of the found lun.

 * @found_lun_pri: Pointer to priority of the found lun.

 *

 * This routine searches the luns list for the specified lun

 * or the first lun for the vport/target.  If the vport wwpn contains

 * a zero value then a specific vport is not specified. In this case

 * any vport which contains the lun will be considered a match.  If the

 * target wwpn contains a zero value then a specific target is not specified.

 * In this case any target which contains the lun will be considered a

 * match.  If the lun is found, the lun, vport wwpn, target wwpn and lun status

 * are returned.  The function will also return the next lun if available.

 * If the next lun is not found, starting_lun parameter will be set to

 * NO_MORE_OAS_LUN.

 *

 * Return codes:

 *   non-0 - Error

 *   0 - Success

 Search for lun or the lun closet in value */

/**

 * lpfc_enable_oas_lun - enables a lun for OAS operations

 * @phba: Pointer to host bus adapter structure.

 * @vport_wwpn: Pointer to vport's wwpn information

 * @target_wwpn: Pointer to target's wwpn information

 * @lun: Lun

 * @pri: Priority

 *

 * This routine enables a lun for oas operations.  The routines does so by

 * doing the following :

 *

 *   1) Checks to see if the device data for the lun has been created.

 *   2) If found, sets the OAS enabled flag if not set and returns.

 *   3) Otherwise, creates a device data structure.

 *   4) If successfully created, indicates the device data is for an OAS lun,

 *   indicates the lun is not available and add to the list of luns.

 *

 * Return codes:

 *   false - Error

 *   true - Success

 Check to see if the device data for the lun has been created */

 Create an lun info structure and add to list of luns */

/**

 * lpfc_disable_oas_lun - disables a lun for OAS operations

 * @phba: Pointer to host bus adapter structure.

 * @vport_wwpn: Pointer to vport's wwpn information

 * @target_wwpn: Pointer to target's wwpn information

 * @lun: Lun

 * @pri: Priority

 *

 * This routine disables a lun for oas operations.  The routines does so by

 * doing the following :

 *

 *   1) Checks to see if the device data for the lun is created.

 *   2) If present, clears the flag indicating this lun is for OAS.

 *   3) If the lun is not available by the system, the device data is

 *   freed.

 *

 * Return codes:

 *   false - Error

 *   true - Success

 Check to see if the lun is available. */

/*******************************************************************

 * This file is part of the Emulex Linux Device Driver for         *

 * Fibre Channel Host Bus Adapters.                                *

 * Copyright (C) 2017-2021 Broadcom. All Rights Reserved. The term *

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.     *

 * Copyright (C) 2004-2016 Emulex.  All rights reserved.           *

 * EMULEX and SLI are trademarks of Emulex.                        *

 * www.broadcom.com                                                *

 * Portions Copyright (C) 2004-2005 Christoph Hellwig              *

 *                                                                 *

 * This program is free software; you can redistribute it and/or   *

 * modify it under the terms of version 2 of the GNU General       *

 * Public License as published by the Free Software Foundation.    *

 * This program is distributed in the hope that it will be useful. *

 * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *

 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *

 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *

 * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *

 * TO BE LEGALLY INVALID.  See the GNU General Public License for  *

 * more details, a copy of which can be found in the file COPYING  *

 * included with this package.                                     *

		/*

		 * When the transport defines fc_vport_set state we will replace

		 * this code with the following line

 fc_vport_set_state(fc_vport, new_state); */

 for all the error states we will set the invternal state to FAILED */

 do nothing */

 Start at bit 1 because vpi zero is reserved for the physical port */

	/*

	 * Grab buffer pointer and clear context1 so we can use

	 * lpfc_sli_issue_box_wait

				/* ensure that IEEE format 1 addresses

				 * contain zeros in bits 59-48

 If they match, return not unique */

/**

 * lpfc_discovery_wait - Wait for driver discovery to quiesce

 * @vport: The virtual port for which this call is being executed.

 *

 * This driver calls this routine specifically from lpfc_vport_delete

 * to enforce a synchronous execution of vport

 * delete relative to discovery activities.  The

 * lpfc_vport_delete routine should not return until it

 * can reasonably guarantee that discovery has quiesced.

 * Post FDISC LOGO, the driver must wait until its SAN teardown is

 * complete and all resources recovered before allowing

 * cleanup.

 *

 * This routine does not require any locks held.

	/*

	 * The time constraint on this loop is a balance between the

	 * fabric RA_TOV value and dev_loss tmo.  The driver's

	 * devloss_tmo is 10 giving this loop a 3x multiplier minimally.

 Base case.  Wait variants satisfied.  Break out */

 NPIV is not supported if HBA has NVME Target enabled */

 Assign an unused board number */

 Create binary sysfs attribute for vport */

 Set the DFT_LUN_Q_DEPTH accordingly */

 Only the physical port can support NVME for now */

 At this point we are fully registered with SCSI Layer.  */

 Setup appropriate attribute masks */

	/*

	 * In SLI4, the vpi must be activated before it can be used

	 * by the port.

		/*

		 * Driver cannot INIT_VPI now. Set the flags to

		 * init_vpi when reg_vfi complete.

	/* Use the Physical nodes Fabric NDLP to determine if the link is

	 * up and ready to FDISC.

	/* Mark all nodes for discovery so we can remove them by

	 * calling lpfc_cleanup_rpis(vport, 1)

	/*

	 * Completion of unreg_vpi (lpfc_mbx_cmpl_unreg_vpi) does the

	 * scsi_host_put() to release the vport.

	/* Use the Physical nodes Fabric NDLP to determine if the link is

	 * up and ready to FDISC.

 If the vport is a static vport fail the deletion. */

	/*

	 * If we are not unloading the driver then prevent the vport_delete

	 * from happening until after this vport's discovery is finished.

	/*

	 * Take early refcount for outstanding I/O requests we schedule during

	 * delete processing for unreg_vpi.  Always keep this before

	 * scsi_remove_host() as we can no longer obtain a reference through

	 * scsi_host_get() after scsi_host_remove as shost is set to SHOST_DEL.

 Remove FC host to break driver binding. */

 Send the DA_ID and Fabric LOGO to cleanup Nameserver entries. */

 Send DA_ID and wait for a completion. */

		/*

		 * If the vpi is not registered, then a valid FDISC doesn't

		 * exist and there is no need for a ELS LOGO.  Just cleanup

		 * the ndlp.

 Issue a Fabric LOGO to cleanup fabric resources. */

 Remove scsi host now.  The nodes are cleaned up. */

		/*

		 * Completion of unreg_vpi (lpfc_mbx_cmpl_unreg_vpi)

		 * does the scsi_host_put() to release the vport.

/**

 * lpfc_vport_reset_stat_data - Reset the statistical data for the vport

 * @vport: Pointer to vport object.

 *

 * This function resets the statistical data for the vport. This function

 * is called with the host_lock held

/**

 * lpfc_alloc_bucket - Allocate data buffer required for statistical data

 * @vport: Pointer to vport object.

 *

 * This function allocates data buffer required for all the FC

 * nodes of the vport to collect statistical data.

/**

 * lpfc_free_bucket - Free data buffer required for statistical data

 * @vport: Pointer to vport object.

 *

 * Th function frees statistical data buffer of all the FC

 * nodes of the vport.

/*******************************************************************

 * This file is part of the Emulex Linux Device Driver for         *

 * Fibre Channel Host Bus Adapters.                                *

 * Copyright (C) 2017-2021 Broadcom. All Rights Reserved. The term *

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.     *

 * Copyright (C) 2004-2016 Emulex.  All rights reserved.           *

 * EMULEX and SLI are trademarks of Emulex.                        *

 * www.broadcom.com                                                *

 * Portions Copyright (C) 2004-2005 Christoph Hellwig              *

 *                                                                 *

 * This program is free software; you can redistribute it and/or   *

 * modify it under the terms of version 2 of the GNU General       *

 * Public License as published by the Free Software Foundation.    *

 * This program is distributed in the hope that it will be useful. *

 * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *

 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *

 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *

 * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *

 * TO BE LEGALLY INVALID.  See the GNU General Public License for  *

 * more details, a copy of which can be found in the file COPYING  *

 * included with this package.                                     *

 See Fibre Channel protocol T11 FC-LS for details */

/**

 * lpfc_els_chk_latt - Check host link attention event for a vport

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine checks whether there is an outstanding host link

 * attention event during the discovery process with the @vport. It is done

 * by reading the HBA's Host Attention (HA) register. If there is any host

 * link attention events during this @vport's discovery process, the @vport

 * shall be marked as FC_ABORT_DISCOVERY, a host link attention clear shall

 * be issued if the link state is not already in host link cleared state,

 * and a return code shall indicate whether the host link attention event

 * had happened.

 *

 * Note that, if either the host link is in state LPFC_LINK_DOWN or @vport

 * state in LPFC_VPORT_READY, the request for checking host link attention

 * event will be ignored and a return code shall indicate no host link

 * attention event had happened.

 *

 * Return codes

 *   0 - no host link attention event happened

 *   1 - host link attention event happened

 Read the HBA Host Attention Register */

 Pending Link Event during Discovery */

	/* CLEAR_LA should re-enable link attention events and

	 * we should then immediately take a LATT event. The

	 * LATT processing should call lpfc_linkdown() which

	 * will cleanup any left over in-progress discovery

	 * events.

/**

 * lpfc_prep_els_iocb - Allocate and prepare a lpfc iocb data structure

 * @vport: pointer to a host virtual N_Port data structure.

 * @expectRsp: flag indicating whether response is expected.

 * @cmdSize: size of the ELS command.

 * @retry: number of retries to the command IOCB when it fails.

 * @ndlp: pointer to a node-list data structure.

 * @did: destination identifier.

 * @elscmd: the ELS command code.

 *

 * This routine is used for allocating a lpfc-IOCB data structure from

 * the driver lpfc-IOCB free-list and prepare the IOCB with the parameters

 * passed into the routine for discovery state machine to issue an Extended

 * Link Service (ELS) commands. It is a generic lpfc-IOCB allocation

 * and preparation routine that is used by all the discovery state machine

 * routines and the ELS command-specific fields will be later set up by

 * the individual discovery machine routines after calling this routine

 * allocating and preparing a generic IOCB data structure. It fills in the

 * Buffer Descriptor Entries (BDEs), allocates buffers for both command

 * payload and response payload (if expected). The reference count on the

 * ndlp is incremented by 1 and the reference to the ndlp is put into

 * context1 of the IOCB data structure for this IOCB to hold the ndlp

 * reference for the command's callback function to access later.

 *

 * Return code

 *   Pointer to the newly allocated/prepared els iocb data structure

 *   NULL - when els iocb data structure allocation/preparation failed

 Allocate buffer for  command iocb */

	/*

	 * If this command is for fabric controller and HBA running

	 * in FIP mode send FLOGI, FDISC and LOGO as FIP frames.

 fill in BDEs for command */

 Allocate buffer for command payload */

 Allocate buffer for response payload */

 Allocate buffer for Buffer ptr list */

 DID */

 DID */

	/*

	 * If we have NPIV enabled, we want to send ELS traffic by VPI.

	 * For SLI4, since the driver controls VPIs we also want to include

	 * all ELS pt2pt protocol traffic as well.

 For ELS_REQUEST64_CR, use the VPI by default */

 The CT field must be 0=INVALID_RPI for the ECHO cmd */

 context = invalid RPI */

 context = VPI */

 Xmit ELS command <elsCmd> to remote NPORT <did> */

 Xmit ELS response <elsCmd> to remote NPORT <did> */

/**

 * lpfc_issue_fabric_reglogin - Issue fabric registration login for a vport

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine issues a fabric registration login for a @vport. An

 * active ndlp node with Fabric_DID must already exist for this @vport.

 * The routine invokes two mailbox commands to carry out fabric registration

 * login through the HBA firmware: the first mailbox command requests the

 * HBA to perform link configuration for the @vport; and the second mailbox

 * command requests the HBA to perform the actual fabric registration login

 * with the @vport.

 *

 * Return code

 *   0 - successfully issued fabric registration login for @vport

 *   -ENXIO -- failed to issue fabric registration login for @vport

	/* increment the reference count on ndlp to hold reference

	 * for the callback routine.

	/* decrement the reference count on ndlp just incremented

	 * for the failed mbox command.

/**

 * lpfc_issue_reg_vfi - Register VFI for this vport's fabric login

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine issues a REG_VFI mailbox for the vfi, vpi, fcfi triplet for

 * the @vport. This mailbox command is necessary for SLI4 port only.

 *

 * Return code

 *   0 - successfully issued REG_VFI for @vport

 *   A failure code otherwise.

 move forward in case of SLI4 FC port loopback test and pt2pt mode */

 Supply CSP's only if we are fabric connect or pt-to-pt connect */

/**

 * lpfc_issue_unreg_vfi - Unregister VFI for this vport's fabric login

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine issues a UNREG_VFI mailbox with the vfi, vpi, fcfi triplet for

 * the @vport. This mailbox command is necessary for SLI4 port only.

 *

 * Return code

 *   0 - successfully issued REG_VFI for @vport

 *   A failure code otherwise.

/**

 * lpfc_check_clean_addr_bit - Check whether assigned FCID is clean.

 * @vport: pointer to a host virtual N_Port data structure.

 * @sp: pointer to service parameter data structure.

 *

 * This routine is called from FLOGI/FDISC completion handler functions.

 * lpfc_check_clean_addr_bit return 1 when FCID/Fabric portname/ Fabric

 * node nodename is changed in the completion service parameter else return

 * 0. This function also set flag in the vport data structure to delay

 * NP_Port discovery after the FLOGI/FDISC completion if Clean address bit

 * in FLOGI/FDISC response is cleared and FCID/Fabric portname/ Fabric

 * node nodename is changed in the completion service parameter.

 *

 * Return code

 *   0 - FCID and Fabric Nodename and Fabric portname is not changed.

 *   1 - FCID or Fabric Nodename or Fabric portname is changed.

 *

	/*

	 * Word 1 Bit 31 in common service parameter is overloaded.

	 * Word 1 Bit 31 in FLOGI request is multiple NPort request

	 * Word 1 Bit 31 in FLOGI response is clean address bit

	 *

	 * If fabric parameter is changed and clean address bit is

	 * cleared delay nport discovery if

	 * - vport->fc_prevDID != 0 (not initial discovery) OR

	 * - lpfc_delay_discovery module parameter is set.

/**

 * lpfc_cmpl_els_flogi_fabric - Completion function for flogi to a fabric port

 * @vport: pointer to a host virtual N_Port data structure.

 * @ndlp: pointer to a node-list data structure.

 * @sp: pointer to service parameter data structure.

 * @irsp: pointer to the IOCB within the lpfc response IOCB.

 *

 * This routine is invoked by the lpfc_cmpl_els_flogi() completion callback

 * function to handle the completion of a Fabric Login (FLOGI) into a fabric

 * port in a fabric topology. It properly sets up the parameters to the @ndlp

 * from the IOCB response. It also check the newly assigned N_Port ID to the

 * @vport against the previously assigned N_Port ID. If it is different from

 * the previously assigned Destination ID (DID), the lpfc_unreg_rpi() routine

 * is invoked on all the remaining nodes with the @vport to unregister the

 * Remote Port Indicators (RPIs). Finally, the lpfc_issue_fabric_reglogin()

 * is invoked to register login to the fabric.

 *

 * Return code

 *   0 - Success (currently, always return 0)

 E_D_TOV ticks are in nanoseconds */

 Reset FDMI attribute masks based on config parameter */

 Setup appropriate attribute masks */

			/* Because we asked f/w for NPIV it still expects us

	/*

	 * For FC we need to do some special processing because of the SLI

	 * Port's default settings of the Common Service Parameters.

 If physical FC port changed, unreg VFI and ALL VPIs / RPIs */

 This should just update the VFI CSPs*/

		/* If our NportID changed, we need to ensure all

		 * remaining NPORTs get unreg_login'ed.

		/*

		 * For SLI3 and SLI4, the VPI needs to be reregistered in

		 * response to this fabric parameter change event.

			/*

			 * Driver needs to re-reg VPI in order for f/w

			 * to update the MAC address.

/**

 * lpfc_cmpl_els_flogi_nport - Completion function for flogi to an N_Port

 * @vport: pointer to a host virtual N_Port data structure.

 * @ndlp: pointer to a node-list data structure.

 * @sp: pointer to service parameter data structure.

 *

 * This routine is invoked by the lpfc_cmpl_els_flogi() completion callback

 * function to handle the completion of a Fabric Login (FLOGI) into an N_Port

 * in a point-to-point topology. First, the @vport's N_Port Name is compared

 * with the received N_Port Name: if the @vport's N_Port Name is greater than

 * the received N_Port Name lexicographically, this node shall assign local

 * N_Port ID (PT2PT_LocalID: 1) and remote N_Port ID (PT2PT_RemoteID: 2) and

 * will send out Port Login (PLOGI) with the N_Port IDs assigned. Otherwise,

 * this node shall just wait for the remote node to issue PLOGI and assign

 * N_Port IDs.

 *

 * Return code

 *   0 - Success

 *   -ENXIO - Fail

 If we are pt2pt with another NPort, force NPIV off! */

 If physical FC port changed, unreg VFI and ALL VPIs / RPIs */

 This side will initiate the PLOGI */

		/*

		 * N_Port ID cannot be 0, set our Id to LocalID

		 * the other side will be RemoteID.

 not equal */

		/* Decrement ndlp reference count indicating that ndlp can be

		 * safely released when other references to it are done.

			/*

			 * Cannot find existing Fabric ndlp, so allocate a

			 * new one

 Set state will put ndlp onto node list if not already done */

		/* This side will wait for the PLOGI, decrement ndlp reference

		 * count indicating that ndlp can be released when other

		 * references to it are done.

 Start discovery - this should just do CLEAR_LA */

/**

 * lpfc_cmpl_els_flogi - Completion callback function for flogi

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

 * This routine is the top-level completion callback function for issuing

 * a Fabric Login (FLOGI) command. If the response IOCB reported error,

 * the lpfc_els_retry() routine shall be invoked to retry the FLOGI. If

 * retry has been made (either immediately or delayed with lpfc_els_retry()

 * returning 1), the command IOCB will be released and function returned.

 * If the retry attempt has been given up (possibly reach the maximum

 * number of retries), one additional decrement of ndlp reference shall be

 * invoked before going out after releasing the command IOCB. This will

 * actually release the remote node (Note, lpfc_els_free_iocb() will also

 * invoke one decrement of ndlp reference count). If no error reported in

 * the IOCB status, the command Port ID field is used to determine whether

 * this is a point-to-point topology or a fabric topology: if the Port ID

 * field is assigned, it is a fabric topology; otherwise, it is a

 * point-to-point topology. The routine lpfc_cmpl_els_flogi_fabric() or

 * lpfc_cmpl_els_flogi_nport() shall be invoked accordingly to handle the

 * specific topology completion conditions.

 Check to see if link went down during discovery */

		/* One additional decrement on node reference count to

		 * trigger the release of the node

		/*

		 * In case of FIP mode, perform roundrobin FCF failover

		 * due to new FCF discovery

 FLOGI failure */

 Check for retry */

 If this is not a loop open failure, bail out */

 FLOGI failed, so there is no fabric */

		/* If private loop, then allow max outstanding els to be

		 * LPFC_MAX_DISC_THREADS (32). Scanning in the case of no

		 * alpa map would take too long otherwise.

 Do not register VFI if the driver aborted FLOGI */

	/*

	 * The FLogI succeeded.  Sync the data for the CPU before

	 * accessing it.

 FLOGI completes successfully */

		/*

		 * If Common Service Parameters indicate Nport

		 * we are point to point, if Fport we are Fabric.

 reset */

 Mark the FCF discovery process done */

 reset */

		/*

		 * In a p2p topology, it is possible that discovery has

		 * already progressed, and this completion can be ignored.

		 * Recheck the indicated topology.

 FLOGI failed, so just use loop map to make discovery list */

 Start discovery */

 If FLOGI failed enable link interrupt. */

/**

 * lpfc_cmpl_els_link_down - Completion callback function for ELS command

 *                           aborted during a link down

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

/**

 * lpfc_issue_els_flogi - Issue an flogi iocb command for a vport

 * @vport: pointer to a host virtual N_Port data structure.

 * @ndlp: pointer to a node-list data structure.

 * @retry: number of retries to the command IOCB.

 *

 * This routine issues a Fabric Login (FLOGI) Request ELS command

 * for a @vport. The initiator service parameters are put into the payload

 * of the FLOGI Request IOCB and the top-level callback function pointer

 * to lpfc_cmpl_els_flogi() routine is put to the IOCB completion callback

 * function field. The lpfc_issue_fabric_iocb routine is invoked to send

 * out FLOGI ELS command with one outstanding fabric IOCB at a time.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the FLOGI ELS command.

 *

 * Return code

 *   0 - successfully issued flogi iocb for @vport

 *   1 - failed to issue flogi iocb for @vport

 For FLOGI request, remainder of payload is service parameters */

 Setup CSPs accordingly for Fabric */

 Determine if switch supports priority tagging */

 lpfc_vmid_host_uuid is combination of wwpn and wwnn */

 FLOGI needs to be 3 for WQE FCFI */

 Set the fcfi to the fcfi we registered with */

 Can't do SLI4 class2 without support sequence coalescing */

 Historical, setting sequential-delivery bit for SLI3 */

 For FLOGI, Let FLOGI rsp set the NPortID for VPI 0 */

 Check for a deferred FLOGI ACC condition */

 Send deferred FLOGI ACC */

/**

 * lpfc_els_abort_flogi - Abort all outstanding flogi iocbs

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine aborts all the outstanding Fabric Login (FLOGI) IOCBs

 * with a @phba. This routine walks all the outstanding IOCBs on the txcmplq

 * list and issues an abort IOCB commond on each outstanding IOCB that

 * contains a active Fabric_DID ndlp. Note that this function is to issue

 * the abort IOCB command on all the outstanding IOCBs, thus when this

 * function returns, it does not guarantee all the IOCBs are actually aborted.

 *

 * Return code

 *   0 - Successfully issued abort iocb on all outstanding flogis (Always 0)

 Abort outstanding I/O on NPort <nlp_DID> */

	/*

	 * Check the txcmplq for an iocb that matches the nport the driver is

	 * searching for.

 Make sure HBA is alive */

/**

 * lpfc_initial_flogi - Issue an initial fabric login for a vport

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine issues an initial Fabric Login (FLOGI) for the @vport

 * specified. It first searches the ndlp with the Fabric_DID (0xfffffe) from

 * the @vport's ndlp list. If no such ndlp found, it will create an ndlp and

 * put it into the @vport's ndlp list. If an inactive ndlp found on the list,

 * it will just be enabled and made active. The lpfc_issue_els_flogi() routine

 * is then invoked with the @vport and the ndlp to perform the FLOGI for the

 * @vport.

 *

 * Return code

 *   0 - failed to issue initial flogi for @vport

 *   1 - successfully issued initial flogi for @vport

 First look for the Fabric ndlp */

 Cannot find existing Fabric ndlp, so allocate a new one */

 Set the node type */

 Put ndlp onto node list */

		/* This decrement of reference count to node shall kick off

		 * the release of the node.

/**

 * lpfc_initial_fdisc - Issue an initial fabric discovery for a vport

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine issues an initial Fabric Discover (FDISC) for the @vport

 * specified. It first searches the ndlp with the Fabric_DID (0xfffffe) from

 * the @vport's ndlp list. If no such ndlp found, it will create an ndlp and

 * put it into the @vport's ndlp list. If an inactive ndlp found on the list,

 * it will just be enabled and made active. The lpfc_issue_els_fdisc() routine

 * is then invoked with the @vport and the ndlp to perform the FDISC for the

 * @vport.

 *

 * Return code

 *   0 - failed to issue initial fdisc for @vport

 *   1 - successfully issued initial fdisc for @vport

 First look for the Fabric ndlp */

 Cannot find existing Fabric ndlp, so allocate a new one */

 NPIV is only supported in Fabrics. */

 Put ndlp onto node list */

		/* decrement node reference count to trigger the release of

		 * the node.

/**

 * lpfc_more_plogi - Check and issue remaining plogis for a vport

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine checks whether there are more remaining Port Logins

 * (PLOGI) to be issued for the @vport. If so, it will invoke the routine

 * lpfc_els_disc_plogi() to go through the Node Port Recovery (NPR) nodes

 * to issue ELS PLOGIs up to the configured discover threads with the

 * @vport (@vport->cfg_discovery_threads). The function also decrement

 * the @vport's num_disc_node by 1 if it is not already 0.

 Continue discovery with <num_disc_nodes> PLOGIs to go */

 Check to see if there are more PLOGIs to be sent */

 go thru NPR nodes and issue any remaining ELS PLOGIs */

/**

 * lpfc_plogi_confirm_nport - Confirm plogi wwpn matches stored ndlp

 * @phba: pointer to lpfc hba data structure.

 * @prsp: pointer to response IOCB payload.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine checks and indicates whether the WWPN of an N_Port, retrieved

 * from a PLOGI, matches the WWPN that is stored in the @ndlp for that N_POrt.

 * The following cases are considered N_Port confirmed:

 * 1) The N_Port is a Fabric ndlp; 2) The @ndlp is on vport list and matches

 * the WWPN of the N_Port logged into; 3) The @ndlp is not on vport list but

 * it does not have WWPN assigned either. If the WWPN is confirmed, the

 * pointer to the @ndlp will be returned. If the WWPN is not confirmed:

 * 1) if there is a node on vport list other than the @ndlp with the same

 * WWPN of the N_Port PLOGI logged into, the lpfc_unreg_rpi() will be invoked

 * on that node to release the RPI associated with the node; 2) if there is

 * no node found on vport list with the same WWPN of the N_Port PLOGI logged

 * into, a new node shall be allocated (or activated). In either case, the

 * parameters of the @ndlp shall be copied to the new_ndlp, the @ndlp shall

 * be released and the new_ndlp shall be put on to the vport node list and

 * its pointer returned as the confirmed node.

 *

 * Note that before the @ndlp got "released", the keepDID from not-matching

 * or inactive "new_ndlp" on the vport node list is assigned to the nlp_DID

 * of the @ndlp. This is because the release of @ndlp is actually to put it

 * into an inactive state on the vport node list and the vport node list

 * management algorithm does not allow two node with a same DID.

 *

 * Return code

 *   pointer to the PLOGI N_Port @ndlp

	/* Fabric nodes can have the same WWPN so we don't bother searching

	 * by WWPN.  Just return the ndlp that was given to us.

	/* Now we find out if the NPort we are logging into, matches the WWPN

	 * we have for that ndlp. If not, we have some work to do.

 return immediately if the WWPN matches ndlp */

	/*

	 * Unregister from backend if not done yet. Could have been skipped

	 * due to ADISC

	/* At this point in this routine, we know new_ndlp will be

	 * returned. however, any previous GID_FTs that were done

	 * would have updated nlp_fc4_type in ndlp, so we must ensure

	 * new_ndlp has the right value.

 Lock both ndlps */

 if new_ndlp had NLP_UNREG_INP set, keep it */

 if new_ndlp had NLP_RPI_REGISTERED set, keep it */

	/*

	 * Retain the DROPPED flag. This will take care of the init

	 * refcount when affecting the state change

 if ndlp had NLP_UNREG_INP set, keep it */

 if ndlp had NLP_RPI_REGISTERED set, keep it */

	/*

	 * Retain the DROPPED flag. This will take care of the init

	 * refcount when affecting the state change

 Set nlp_states accordingly */

 interchange the nvme remoteport structs */

 Move this back to NPR state */

		/* The new_ndlp is replacing ndlp totally, so we need

		 * to put ndlp on UNUSED list and try to free it.

		/* Two ndlps cannot have the same did on the nodelist.

		 * Note: for this case, ndlp has a NULL WWPN so setting

		 * the nlp_fc4_type isn't required.

		/* Two ndlps cannot have the same did and the fc4

		 * type must be transferred because the ndlp is in

		 * flight.

		/* Since we are switching over to the new_ndlp,

		 * reset the old ndlp state

	/*

	 * If ndlp is not associated with any rport we can drop it here else

	 * let dev_loss_tmo_callbk trigger DEVICE_RM event

/**

 * lpfc_end_rscn - Check and handle more rscn for a vport

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine checks whether more Registration State Change

 * Notifications (RSCNs) came in while the discovery state machine was in

 * the FC_RSCN_MODE. If so, the lpfc_els_handle_rscn() routine will be

 * invoked to handle the additional RSCNs for the @vport. Otherwise, the

 * FC_RSCN_MODE bit will be cleared with the @vport to mark as the end of

 * handling the RSCNs.

		/*

		 * Check to see if more RSCNs came in while we were

		 * processing this one.

/**

 * lpfc_cmpl_els_rrq - Completion handled for els RRQs.

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

 * This routine will call the clear rrq function to free the rrq and

 * clear the xri's bit in the ndlp's xri_bitmap. If the ndlp does not

 * exist then the clear_rrq is still called because the rrq needs to

 * be freed.

 we pass cmdiocb to state machine which needs rspiocb as well */

 rrq completes to NPort <nlp_DID> */

 Check for retry */

 RRQ failed Don't print the vport to vport rjts */

/**

 * lpfc_cmpl_els_plogi - Completion callback function for plogi

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

 * This routine is the completion callback function for issuing the Port

 * Login (PLOGI) command. For PLOGI completion, there must be an active

 * ndlp on the vport node list that matches the remote node ID from the

 * PLOGI response IOCB. If such ndlp does not exist, the PLOGI is simply

 * ignored and command IOCB released. The PLOGI response IOCB status is

 * checked for error conditions. If there is error status reported, PLOGI

 * retry shall be attempted by invoking the lpfc_els_retry() routine.

 * Otherwise, the lpfc_plogi_confirm_nport() routine shall be invoked on

 * the ndlp and the NLP_EVT_CMPL_PLOGI state to the Discover State Machine

 * (DSM) is set for this PLOGI completion. Finally, it checks whether

 * there are additional N_Port nodes with the vport that need to perform

 * PLOGI. If so, the lpfc_more_plogi() routine is invoked to issue addition

 * PLOGIs.

 we pass cmdiocb to state machine which needs rspiocb as well */

	/* Since ndlp can be freed in the disc state machine, note if this node

	 * is being used during discovery.

 PLOGI completes to NPort <nlp_DID> */

 Check to see if link went down during discovery */

 Check for retry */

 ELS command is being retried */

 PLOGI failed Don't print the vport to vport rjts */

 Do not call DSM for lpfc_els_abort'ed ELS cmds */

		/* If a PLOGI collision occurred, the node needs to continue

		 * with the reglogin process.

		/* No PLOGI collision and the node is not registered with the

		 * scsi or nvme transport. It is no longer an active node. Just

		 * start the device remove process.

 Good status, call state machine */

 if the dest port supports VMID, mark it in ndlp */

 Check to see if there are more PLOGIs to be sent */

 Release the reference on the original I/O request. */

/**

 * lpfc_issue_els_plogi - Issue an plogi iocb command for a vport

 * @vport: pointer to a host virtual N_Port data structure.

 * @did: destination port identifier.

 * @retry: number of retries to the command IOCB.

 *

 * This routine issues a Port Login (PLOGI) command to a remote N_Port

 * (with the @did) for a @vport. Before issuing a PLOGI to a remote N_Port,

 * the ndlp with the remote N_Port DID must exist on the @vport's ndlp list.

 * This routine constructs the proper fields of the PLOGI IOCB and invokes

 * the lpfc_sli_issue_iocb() routine to send out PLOGI ELS command.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding

 * the ndlp and the reference to ndlp will be stored into the context1 field

 * of the IOCB for the completion callback function to the PLOGI ELS command.

 *

 * Return code

 *   0 - Successfully issued a plogi for @vport

 *   1 - failed to issue a plogi for @vport

	/* Defer the processing of the issue PLOGI until after the

	 * outstanding UNREG_RPI mbox command completes, unless we

	 * are going offline. This logic does not apply for Fabric DIDs

 We can only defer 1st PLOGI */

 For PLOGI request, remainder of payload is service parameters */

	/*

	 * If we are a N-port connected to a Fabric, fix-up paramm's so logins

	 * to device on remote loops work.

 Check if the destination port supports VMID */

	/* If our firmware supports this feature, convey that

	 * information to the target using the vendor specific field.

/**

 * lpfc_cmpl_els_prli - Completion callback function for prli

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

 * This routine is the completion callback function for a Process Login

 * (PRLI) ELS command. The PRLI response IOCB status is checked for error

 * status. If there is error status reported, PRLI retry shall be attempted

 * by invoking the lpfc_els_retry() routine. Otherwise, the state

 * NLP_EVT_CMPL_PRLI is sent to the Discover State Machine (DSM) for this

 * ndlp to mark the PRLI completion.

 we pass cmdiocb to state machine which needs rspiocb as well */

 Driver supports multiple FC4 types.  Counters matter. */

 PRLI completes to NPort <nlp_DID> */

 Check to see if link went down during discovery */

 Check for retry */

 ELS command is being retried */

		/* If we don't send GFT_ID to Fabric, a PRLI error

		 * could be expected.

 PRLI failed */

 Do not call DSM for lpfc_els_abort'ed ELS cmds */

		/*

		 * For P2P topology, retain the node so that PLOGI can be

		 * attempted on it again.

		/* As long as this node is not registered with the SCSI

		 * or NVMe transport and no other PRLIs are outstanding,

		 * it is no longer an active node.  Otherwise devloss

		 * handles the final cleanup.

		/* Good status, call state machine.  However, if another

		 * PRLI is outstanding, don't call the state machine

		 * because final disposition to Mapped or Unmapped is

		 * completed there.

/**

 * lpfc_issue_els_prli - Issue a prli iocb command for a vport

 * @vport: pointer to a host virtual N_Port data structure.

 * @ndlp: pointer to a node-list data structure.

 * @retry: number of retries to the command IOCB.

 *

 * This routine issues a Process Login (PRLI) ELS command for the

 * @vport. The PRLI service parameters are set up in the payload of the

 * PRLI Request command and the pointer to lpfc_cmpl_els_prli() routine

 * is put to the IOCB completion callback func field before invoking the

 * routine lpfc_sli_issue_iocb() to send out PRLI command.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the PRLI ELS command.

 *

 * Return code

 *   0 - successfully issued prli iocb command for @vport

 *   1 - failed to issue prli iocb command for @vport

	/*

	 * If we are in RSCN mode, the FC4 types supported from a

	 * previous GFT_ID command may not be accurate. So, if we

	 * are a NVME Initiator, always look for the possibility of

	 * the remote NPort beng a NVME Target.

	/* This routine will issue 1 or 2 PRLIs, so zero all the ndlp

	 * fields here before any of them can complete.

 Payload is 4 + 16 = 20 x14 bytes. */

 Payload is 4 + 20 = 24 x18 bytes. */

	/* SLI3 ports don't support NVME.  If this rport is a strict NVME

	 * FC4 type, implicitly LOGO.

 For PRLI request, remainder of payload is service parameters */

		/* Remainder of payload is FCP PRLI parameter page.

		 * Note: this data structure is defined as

		 * BE/LE in the structure definition so no

		 * byte swap call is made.

		/*

		 * If our firmware version is 3.20 or later,

		 * set the following bits for FC-TAPE support.

 For FCP support */

 Remove FCP type - processed. */

		/* Remainder of payload is NVME PRLI parameter page.

		 * This data structure is the newer definition that

		 * uses bf macros so a byte swap is required.

 Should be 0 */

 Only initiators request first burst. */

 Remove NVME type - processed. */

	/* The vport counters are used for lpfc_scan_finished, but

	 * the ndlp is used to track outstanding PRLIs for different

	 * FC4 types.

	/* The driver supports 2 FC4 types.  Make sure

	 * a PRLI is issued for all types before exiting.

/**

 * lpfc_rscn_disc - Perform rscn discovery for a vport

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine performs Registration State Change Notification (RSCN)

 * discovery for a @vport. If the @vport's node port recovery count is not

 * zero, it will invoke the lpfc_els_disc_plogi() to perform PLOGI for all

 * the nodes that need recovery. If none of the PLOGI were needed through

 * the lpfc_els_disc_plogi() routine, the lpfc_end_rscn() routine shall be

 * invoked to check and handle possible more RSCN came in during the period

 * of processing the current ones.

 RSCN discovery */

 go thru NPR nodes and issue ELS PLOGIs */

/**

 * lpfc_adisc_done - Complete the adisc phase of discovery

 * @vport: pointer to lpfc_vport hba data structure that finished all ADISCs.

 *

 * This function is called when the final ADISC is completed during discovery.

 * This function handles clearing link attention or issuing reg_vpi depending

 * on whether npiv is enabled. This function also kicks off the PLOGI phase of

 * discovery.

 * This function is called with no locks held.

	/*

	 * For NPIV, cmpl_reg_vpi will set port_state to READY,

	 * and continue discovery.

		/*

		 * If link is down, clear_la and reg_vpi will be done after

		 * flogi following a link up event

		/* The ADISCs are complete.  Doesn't matter if they

		 * succeeded or failed because the ADISC completion

		 * routine guarantees to call the state machine and

		 * the RPI is either unregistered (failed ADISC response)

		 * or the RPI is still valid and the node is marked

		 * mapped for a target.  The exchanges should be in the

		 * correct state. This code is specific to SLI3.

	/*

	* For SLI2, we need to set port_state to READY

	* and continue discovery.

 If we get here, there is nothing to ADISC */

 go thru NPR list, issue ELS PLOGIs */

/**

 * lpfc_more_adisc - Issue more adisc as needed

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine determines whether there are more ndlps on a @vport

 * node list need to have Address Discover (ADISC) issued. If so, it will

 * invoke the lpfc_els_disc_adisc() routine to issue ADISC on the @vport's

 * remaining nodes which need to have ADISC sent.

 Continue discovery with <num_disc_nodes> ADISCs to go */

 Check to see if there are more ADISCs to be sent */

 go thru NPR nodes and issue any remaining ELS ADISCs */

/**

 * lpfc_cmpl_els_adisc - Completion callback function for adisc

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

 * This routine is the completion function for issuing the Address Discover

 * (ADISC) command. It first checks to see whether link went down during

 * the discovery process. If so, the node will be marked as node port

 * recovery for issuing discover IOCB by the link attention handler and

 * exit. Otherwise, the response status is checked. If error was reported

 * in the response status, the ADISC command shall be retried by invoking

 * the lpfc_els_retry() routine. Otherwise, if no error was reported in

 * the response status, the state machine is invoked to set transition

 * with respect to NLP_EVT_CMPL_ADISC event.

 we pass cmdiocb to state machine which needs rspiocb as well */

	/* Since ndlp can be freed in the disc state machine, note if this node

	 * is being used during discovery.

 ADISC completes to NPort <nlp_DID> */

 Check to see if link went down during discovery */

 Check for retry */

 ELS command is being retried */

 ADISC failed */

		/* As long as this node is not registered with the SCSI or NVMe

		 * transport, it is no longer an active node. Otherwise

		 * devloss handles the final cleanup.

 Good status, call state machine */

 Check to see if there are more ADISCs to be sent */

/**

 * lpfc_issue_els_adisc - Issue an address discover iocb to an node on a vport

 * @vport: pointer to a virtual N_Port data structure.

 * @ndlp: pointer to a node-list data structure.

 * @retry: number of retries to the command IOCB.

 *

 * This routine issues an Address Discover (ADISC) for an @ndlp on a

 * @vport. It prepares the payload of the ADISC ELS command, updates the

 * and states of the ndlp, and invokes the lpfc_sli_issue_iocb() routine

 * to issue the ADISC ELS command.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the ADISC ELS command.

 *

 * Return code

 *   0 - successfully issued adisc

 *   1 - failed to issue adisc

 For ADISC request, remainder of payload is service parameters */

 Fill in ADISC payload */

/**

 * lpfc_cmpl_els_logo - Completion callback function for logo

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

 * This routine is the completion function for issuing the ELS Logout (LOGO)

 * command. If no error status was reported from the LOGO response, the

 * state machine of the associated ndlp shall be invoked for transition with

 * respect to NLP_EVT_CMPL_LOGO event.

 we pass cmdiocb to state machine which needs rspiocb as well */

 LOGO completes to NPort <nlp_DID> */

	/* The LOGO will not be retried on failure.  A LOGO was

	 * issued to the remote rport and a ACC or RJT or no Answer are

	 * all acceptable.  Note the failure and move forward with

	 * discovery.  The PLOGI will retry.

 LOGO failed */

 Do not call DSM for lpfc_els_abort'ed ELS cmds */

 Call state machine. This will unregister the rpi if needed. */

	/* The driver sets this flag for an NPIV instance that doesn't want to

	 * log into the remote port.

 Presume the node was released. */

 Driver is done with the IO.  */

	/* At this point, the LOGO processing is complete. NOTE: For a

	 * pt2pt topology, we are assuming the NPortID will only change

	 * on link up processing. For a LOGO / PLOGI initiated by the

	 * Initiator, we are assuming the NPortID is not going to change.

	/*

	 * If the node is a target, the handling attempts to recover the port.

	 * For any other port type, the rpi is unregistered as an implicit

	 * LOGO.

	/* Cleanup path for failed REG_RPI handling. If REG_RPI fails, the

	 * driver sends a LOGO to the rport to cleanup.  For fabric and

	 * initiator ports cleanup the node as long as it the node is not

	 * register with the transport.

/**

 * lpfc_issue_els_logo - Issue a logo to an node on a vport

 * @vport: pointer to a virtual N_Port data structure.

 * @ndlp: pointer to a node-list data structure.

 * @retry: number of retries to the command IOCB.

 *

 * This routine constructs and issues an ELS Logout (LOGO) iocb command

 * to a remote node, referred by an @ndlp on a @vport. It constructs the

 * payload of the IOCB, properly sets up the @ndlp state, and invokes the

 * lpfc_sli_issue_iocb() routine to send out the LOGO ELS command.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the LOGO ELS command.

 *

 * Callers of this routine are expected to unregister the RPI first

 *

 * Return code

 *   0 - successfully issued logo

 *   1 - failed to issue logo

 Fill in LOGO payload */

/**

 * lpfc_cmpl_els_cmd - Completion callback function for generic els command

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

 * This routine is a generic completion callback function for ELS commands.

 * Specifically, it is the callback function which does not need to perform

 * any command specific operations. It is currently used by the ELS command

 * issuing routines for RSCN, lpfc_issue_els_rscn, and the ELS Fibre Channel

 * Address Resolution Protocol Response (FARPR) routine, lpfc_issue_els_farpr().

 * Other than certain debug loggings, this callback function simply invokes the

 * lpfc_els_chk_latt() routine to check whether link went down during the

 * discovery process.

 ELS cmd tag <ulpIoTag> completes */

 Check to see if link went down during discovery */

/**

 * lpfc_reg_fab_ctrl_node - RPI register the fabric controller node.

 * @vport: pointer to lpfc_vport data structure.

 * @fc_ndlp: pointer to the fabric controller (0xfffffd) node.

 *

 * This routine registers the rpi assigned to the fabric controller

 * NPort_ID (0xfffffd) with the port and moves the node to UNMAPPED

 * state triggering a registration with the SCSI transport.

 *

 * This routine is single out because the fabric controller node

 * does not receive a PLOGI.  This routine is consumed by the

 * SCR and RDF ELS commands.  Callers are expected to qualify

 * with SLI4 first.

 Success path. Exit. */

/**

 * lpfc_cmpl_els_disc_cmd - Completion callback function for Discovery ELS cmd

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

 * This routine is a generic completion callback function for Discovery ELS cmd.

 * Currently used by the ELS command issuing routines for the ELS State Change

 * Request (SCR), lpfc_issue_els_scr() and the ELS RDF, lpfc_issue_els_rdf().

 * These commands will be retried once only for ELS timeout errors.

 ELS cmd tag <ulpIoTag> completes */

 Only 1 retry for ELS Timeout only */

 save ndlp refcnt */

 must be called before checking uplStatus and returning */

 ELS discovery cmd completes with error */

	/* The RDF response doesn't have any impact on the running driver

	 * but the notification descriptors are dumped here for support.

 Check to see if link went down during discovery */

/**

 * lpfc_issue_els_scr - Issue a scr to an node on a vport

 * @vport: pointer to a host virtual N_Port data structure.

 * @retry: retry counter for the command IOCB.

 *

 * This routine issues a State Change Request (SCR) to a fabric node

 * on a @vport. The remote node is Fabric Controller (0xfffffd). It

 * first search the @vport node list to find the matching ndlp. If no such

 * ndlp is found, a new ndlp shall be created for this (SCR) purpose. An

 * IOCB is allocated, payload prepared, and the lpfc_sli_issue_iocb()

 * routine is invoked to send the SCR IOCB.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the SCR ELS command.

 *

 * Return code

 *   0 - Successfully issued scr command

 *   1 - Failed to issue scr command

 For SCR, remainder of payload is SCR parameter page */

/**

 * lpfc_issue_els_rscn - Issue an RSCN to the Fabric Controller (Fabric)

 *   or the other nport (pt2pt).

 * @vport: pointer to a host virtual N_Port data structure.

 * @retry: number of retries to the command IOCB.

 *

 * This routine issues a RSCN to the Fabric Controller (DID 0xFFFFFD)

 *  when connected to a fabric, or to the remote port when connected

 *  in point-to-point mode. When sent to the Fabric Controller, it will

 *  replay the RSCN to registered recipients.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the RSCN ELS command.

 *

 * Return code

 *   0 - Successfully issued RSCN command

 *   1 - Failed to issue RSCN command

 Not supported for private loop */

 find any mapped nport - that would be the other nport */

 find the fabric controller node */

 if one didn't exist, make one */

 appears that page flags must be 0 for fabric to broadcast RSCN */

	/* This will cause the callback-function lpfc_cmpl_els_cmd to

	 * trigger the release of node.

/**

 * lpfc_issue_els_farpr - Issue a farp to an node on a vport

 * @vport: pointer to a host virtual N_Port data structure.

 * @nportid: N_Port identifier to the remote node.

 * @retry: number of retries to the command IOCB.

 *

 * This routine issues a Fibre Channel Address Resolution Response

 * (FARPR) to a node on a vport. The remote node N_Port identifier (@nportid)

 * is passed into the function. It first search the @vport node list to find

 * the matching ndlp. If no such ndlp is found, a new ndlp shall be created

 * for this (FARPR) purpose. An IOCB is allocated, payload prepared, and the

 * lpfc_sli_issue_iocb() routine is invoked to send the FARPR ELS command.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the FARPR ELS command.

 *

 * Return code

 *   0 - Successfully issued farpr command

 *   1 - Failed to issue farpr command

 Fill in FARPR payload */

		/* The additional lpfc_nlp_put will cause the following

		 * lpfc_els_free_iocb routine to trigger the release of

		 * the node.

	/* This will cause the callback-function lpfc_cmpl_els_cmd to

	 * trigger the release of the node.

 Don't release reference count as RDF is likely outstanding */

/**

 * lpfc_issue_els_rdf - Register for diagnostic functions from the fabric.

 * @vport: pointer to a host virtual N_Port data structure.

 * @retry: retry counter for the command IOCB.

 *

 * This routine issues an ELS RDF to the Fabric Controller to register

 * for diagnostic functions.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the RDF ELS command.

 *

 * Return code

 *   0 - Successfully issued rdf command

 *   1 - Failed to issue rdf command

 RDF ELS is not required on an NPIV VN_Port. */

 Configure the payload for the supported FPIN events. */

 /**

  * lpfc_els_rcv_rdf - Receive RDF ELS request from the fabric.

  * @vport: pointer to a host virtual N_Port data structure.

  * @cmdiocb: pointer to lpfc command iocb data structure.

  * @ndlp: pointer to a node-list data structure.

  *

  * A received RDF implies a possible change to fabric supported diagnostic

  * functions.  This routine sends LS_ACC and then has the Nx_Port issue a new

  * RDF request to reregister for supported diagnostic functions.

  *

  * Return code

  *   0 - Success

  *   -EIO - Failed to process received RDF

 Send LS_ACC */

 Issue new RDF for reregistering */

/**

 * lpfc_least_capable_settings - helper function for EDC rsp processing

 * @phba: pointer to lpfc hba data structure.

 * @pcgd: pointer to congestion detection descriptor in EDC rsp.

 *

 * This helper routine determines the least capable setting for

 * congestion signals, signal freq, including scale, from the

 * congestion detection descriptor in the EDC rsp.  The routine

 * sets @phba values in preparation for a set_featues mailbox.

 Get rsp signal and frequency capabilities.  */

 If the Fport does not support signals. Set FPIN only */

	/* Apply the xmt scale to the xmt cycle to get the correct frequency.

	 * Adapter default is 100 millisSeconds.  Convert all xmt cycle values

	 * to milliSeconds.

 Convenient shorthand. */

 Choose the least capable frequency. */

	/* Should be some common signals support. Settle on least capable

	 * signal and adjust FPIN values. Initialize defaults to ease the

	 * decision.

 Update signal frequency in congestion info buffer */

	/* Frequency (in ms) Signal Warning/Signal Congestion Notifications

	 * are received by the HBA

/**

 * lpfc_cmpl_els_edc - Completion callback function for EDC

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

 * This routine is the completion callback function for issuing the Exchange

 * Diagnostic Capabilities (EDC) command. The driver issues an EDC to

 * notify the FPort of its Congestion and Link Fault capabilities.  This

 * routine parses the FPort's response and decides on the least common

 * values applicable to both FPort and NPort for Warnings and Alarms that

 * are communicated via hardware signals.

 ELS cmd tag <ulpIoTag> completes */

 Need to clear signal values, send features MB and RDF with FPIN. */

 ELS cmd tag <ulpIoTag> completes */

	/*

	 * Payload length in bytes is the response descriptor list

	 * length minus the 12 bytes of Link Service Request

	 * Information descriptor in the reply.

	/*

	 * cycle through EDC diagnostic descriptors to find the

	 * congestion signaling capability descriptor

			/* Compare driver and Fport capabilities and choose

			 * least common.

 Check to see if link went down during discovery */

 We are assuming cgd was zero'ed before calling this routine */

 Configure the congestion detection capability */

 Descriptor len doesn't include the tag or len fields. */

	/* xmt_signal_capability already set to EDC_CG_SIG_NOTSUPPORTED.

	 * xmt_signal_frequency.count already set to 0.

	 * xmt_signal_frequency.units already set to 0.

		/* rcv_signal_capability already set to EDC_CG_SIG_NOTSUPPORTED.

		 * rcv_signal_frequency.count already set to 0.

		 * rcv_signal_frequency.units already set to 0.

 rcv_signal_capability left 0 thus no support */

	/* We start negotiation with lpfc_fabric_cgn_frequency, after

	 * the completion we settle on the higher frequency.

 /**

  * lpfc_issue_els_edc - Exchange Diagnostic Capabilities with the fabric.

  * @vport: pointer to a host virtual N_Port data structure.

  * @retry: retry counter for the command iocb.

  *

  * This routine issues an ELS EDC to the F-Port Controller to communicate

  * this N_Port's support of hardware signals in its Congestion

  * Capabilities Descriptor.

  *

  * Note: This routine does not check if one or more signals are

  * set in the cgn_reg_signal parameter.  The caller makes the

  * decision to enforce cgn_reg_signal as nonzero or zero depending

  * on the conditions.  During Fabric requests, the driver

  * requires cgn_reg_signals to be nonzero.  But a dynamic request

  * to set the congestion mode to OFF from Monitor or Manage

  * would correctly issue an EDC with no signals enabled to

  * turn off switch functionality and then update the FW.

  *

  * Return code

  *   0 - Successfully issued edc command

  *   1 - Failed to issue edc command

 If HBA doesn't support signals, drop into RDF */

 Configure the payload for the supported Diagnostics capabilities. */

		/* The additional lpfc_nlp_put will cause the following

		 * lpfc_els_free_iocb routine to trigger the rlease of

		 * the node.

/**

 * lpfc_cancel_retry_delay_tmo - Cancel the timer with delayed iocb-cmd retry

 * @vport: pointer to a host virtual N_Port data structure.

 * @nlp: pointer to a node-list data structure.

 *

 * This routine cancels the timer with a delayed IOCB-command retry for

 * a @vport's @ndlp. It stops the timer for the delayed function retrial and

 * removes the ELS retry event if it presents. In addition, if the

 * NLP_NPR_2B_DISC bit is set in the @nlp's nlp_flag bitmap, ADISC IOCB

 * commands are sent for the @vport's nodes that require issuing discovery

 * ADISC.

 Decrement nlp reference count held for the delayed retry */

 Check if there are more ADISCs to be sent */

 Check if there are more PLOGIs to be sent */

/**

 * lpfc_els_retry_delay - Timer function with a ndlp delayed function timer

 * @t: pointer to the timer function associated data (ndlp).

 *

 * This routine is invoked by the ndlp delayed-function timer to check

 * whether there is any pending ELS retry event(s) with the node. If not, it

 * simply returns. Otherwise, if there is at least one ELS delayed event, it

 * adds the delayed events to the HBA work list and invokes the

 * lpfc_worker_wake_up() routine to wake up worker thread to process the

 * event. Note that lpfc_nlp_get() is called before posting the event to

 * the work list to hold reference count of ndlp so that it guarantees the

 * reference to ndlp will still be available when the worker thread gets

 * to the event associated with the ndlp.

	/* We need to hold the node by incrementing the reference

	 * count until the queued work is done

/**

 * lpfc_els_retry_delay_handler - Work thread handler for ndlp delayed function

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine is the worker-thread handler for processing the @ndlp delayed

 * event(s), posted by the lpfc_els_retry_delay() routine. It simply retrieves

 * the last ELS command from the associated ndlp and invokes the proper ELS

 * function according to the delayed ELS command to retry the command.

	/*

	 * If a discovery event readded nlp_delayfunc after timer

	 * firing and before processing the timer, cancel the

	 * nlp_delayfunc.

/**

 * lpfc_link_reset - Issue link reset

 * @vport: pointer to a virtual N_Port data structure.

 *

 * This routine performs link reset by sending INIT_LINK mailbox command.

 * For SLI-3 adapter, link attention interrupt is enabled before issuing

 * INIT_LINK mailbox command.

 *

 * Return code

 *   0 - Link reset initiated successfully

 *   1 - Failed to initiate link reset

 Enable Link attention interrupts */

 flush */

/**

 * lpfc_els_retry - Make retry decision on an els command iocb

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

 * This routine makes a retry decision on an ELS command IOCB, which has

 * failed. The following ELS IOCBs use this function for retrying the command

 * when previously issued command responsed with error status: FLOGI, PLOGI,

 * PRLI, ADISC and FDISC. Based on the ELS command type and the

 * returned error status, it makes the decision whether a retry shall be

 * issued for the command, and whether a retry shall be made immediately or

 * delayed. In the former case, the corresponding ELS command issuing-function

 * is called to retry the command. In the later case, the ELS command shall

 * be posted to the ndlp delayed event and delayed function timer set to the

 * ndlp for the delayed command issusing.

 *

 * Return code

 *   0 - No retry of els command is made

 *   1 - Immediate or delayed retry of els command is made

	/* Note: context2 may be 0 for internal driver abort

	 * of delays ELS command.

 We should only hit this case for retrying PLOGI */

			/* This IO was aborted by the target, we don't

			 * know the rxid and because we did not send the

			 * ABTS we cannot generate and RRQ.

 All command's retry policy */

 HBA out of resources */

 Continue forever if plogi to */

 the nameserver fails */

 Reset the Link */

			/* Retry ELS PLOGI command?

			 * Possibly the rport just wasn't ready.

 No retry if state change */

 Fabric / Remote NPort out of resources */

		/* Added for Vendor specifc support

		 * Just keep retrying for these Rsn / Exp codes

			/* The driver has a VALID PLOGI but the rport has

			 * rejected the PRLI - can't do it now.  Delay

			 * for 1 second and try again.

			 *

			 * However, if explanation is REQ_UNSUPPORTED there's

			 * no point to retry PRLI.

 Legacy bug fix code for targets with PLOGI delays. */

 FDISC retry policy */

			/* There are some cases where switches return this

			 * error when they are not ready and should be returning

			 * Logical Busy. We should delay every time.

			/* lpfc nvmet returns this type of LS_RJT when it

			 * receives an FCP PRLI because lpfc nvmet only

			 * support NVME.  ELS request is terminated for FCP4

			 * on this rport.

			/* Do not give up. Retry PLOGI one more time and attempt

			 * link reset if PLOGI fails again.

 FLOGI retry policy */

 retry FLOGI forever */

 retry FDISCs every second up to devloss */

 Stop retrying PLOGI and FDISC if in FCF discovery */

 Retry ELS command <elsCmd> to remote NPORT <did> */

 Don't reset timer for no resources */

 If discovery / RSCN timer is running, reset it */

 delay is specified in milliseconds */

 No retry ELS command <elsCmd> to remote NPORT <did> */

/**

 * lpfc_els_free_data - Free lpfc dma buffer and data structure with an iocb

 * @phba: pointer to lpfc hba data structure.

 * @buf_ptr1: pointer to the lpfc DMA buffer data structure.

 *

 * This routine releases the lpfc DMA (Direct Memory Access) buffer(s)

 * associated with a command IOCB back to the lpfc DMA buffer pool. It first

 * checks to see whether there is a lpfc DMA buffer associated with the

 * response of the command IOCB. If so, it will be released before releasing

 * the lpfc DMA buffer associated with the IOCB itself.

 *

 * Return code

 *   0 - Successfully released lpfc DMA buffer (currently, always return 0)

 Free the response before processing the command. */

/**

 * lpfc_els_free_bpl - Free lpfc dma buffer and data structure with bpl

 * @phba: pointer to lpfc hba data structure.

 * @buf_ptr: pointer to the lpfc dma buffer data structure.

 *

 * This routine releases the lpfc Direct Memory Access (DMA) buffer

 * associated with a Buffer Pointer List (BPL) back to the lpfc DMA buffer

 * pool.

 *

 * Return code

 *   0 - Successfully released lpfc DMA buffer (currently, always return 0)

/**

 * lpfc_els_free_iocb - Free a command iocb and its associated resources

 * @phba: pointer to lpfc hba data structure.

 * @elsiocb: pointer to lpfc els command iocb data structure.

 *

 * This routine frees a command IOCB and its associated resources. The

 * command IOCB data structure contains the reference to various associated

 * resources, these fields must be set to NULL if the associated reference

 * not present:

 *   context1 - reference to ndlp

 *   context2 - reference to cmd

 *   context2->next - reference to rsp

 *   context3 - reference to bpl

 *

 * It first properly decrements the reference count held on ndlp for the

 * IOCB completion callback function. If LPFC_DELAY_MEM_FREE flag is not

 * set, it invokes the lpfc_els_free_data() routine to release the Direct

 * Memory Access (DMA) buffers associated with the IOCB. Otherwise, it

 * adds the DMA buffer the @phba data structure for the delayed release.

 * If reference to the Buffer Pointer List (BPL) is present, the

 * lpfc_els_free_bpl() routine is invoked to release the DMA memory

 * associated with BPL. Finally, the lpfc_sli_release_iocbq() routine is

 * invoked to release the IOCB data structure back to @phba IOCBQ list.

 *

 * Return code

 *   0 - Success (currently, always return 0)

 The I/O iocb is complete.  Clear the context1 data. */

 context2  = cmd,  context2->next = rsp, context3 = bpl */

			/* Firmware could still be in progress of DMAing

			 * payload, so don't free data buffer till after

			 * a hbeat.

/**

 * lpfc_cmpl_els_logo_acc - Completion callback function to logo acc response

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

 * This routine is the completion callback function to the Logout (LOGO)

 * Accept (ACC) Response ELS command. This routine is invoked to indicate

 * the completion of the LOGO process. It invokes the lpfc_nlp_not_used() to

 * release the ndlp if it has the last reference remaining (reference count

 * is 1). If succeeded (meaning ndlp released), it sets the IOCB context1

 * field to NULL to inform the following lpfc_els_free_iocb() routine no

 * ndlp reference count needs to be decremented. Otherwise, the ndlp

 * reference use-count shall be decremented by the lpfc_els_free_iocb()

 * routine. Finally, the lpfc_els_free_iocb() is invoked to release the

 * IOCB data structure.

 ACC to LOGO completes to NPort <nlp_DID> */

	/* This clause allows the LOGO ACC to complete and free resources

	 * for the Fabric Domain Controller.  It does deliberately skip

	 * the unreg_rpi and release rpi because some fabrics send RDP

	 * requests after logging out from the initiator.

		/* If PLOGI is being retried, PLOGI completion will cleanup the

		 * node. The NLP_NPR_2B_DISC flag needs to be retained to make

		 * progress on nodes discovered from last RSCN.

 NPort Recovery mode or node is just allocated */

			/* A LOGO is completing and the node is in NPR state.

			 * If this a fabric node that cleared its transport

			 * registration, release the rpi.

			/* Indicate the node has already released, should

			 * not reference to it from within lpfc_els_free_iocb.

	/*

	 * The driver received a LOGO from the rport and has ACK'd it.

	 * At this point, the driver is done so release the IOCB

/**

 * lpfc_mbx_cmpl_dflt_rpi - Completion callbk func for unreg dflt rpi mbox cmd

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * This routine is the completion callback function for unregister default

 * RPI (Remote Port Index) mailbox command to the @phba. It simply releases

 * the associated lpfc Direct Memory Access (DMA) buffer back to the pool and

 * decrements the ndlp reference count held for this completion callback

 * function. After that, it invokes the lpfc_nlp_not_used() to check

 * whether there is only one reference left on the ndlp. If so, it will

 * perform one more decrement and trigger the release of the ndlp.

		/* This ends the default/temporary RPI cleanup logic for this

		 * ndlp and the node and rpi needs to be released. Free the rpi

		 * first on an UNREG_LOGIN and then release the final

		 * references.

/**

 * lpfc_cmpl_els_rsp - Completion callback function for els response iocb cmd

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

 * This routine is the completion callback function for ELS Response IOCB

 * command. In normal case, this callback function just properly sets the

 * nlp_flag bitmap in the ndlp data structure, if the mbox command reference

 * field in the command IOCB is not NULL, the referred mailbox command will

 * be send out, and then invokes the lpfc_els_free_iocb() routine to release

 * the IOCB.

 Check to see if link went down during discovery */

 ELS response tag <ulpIoTag> completes */

			/* Increment reference count to ndlp to hold the

			 * reference to ndlp for the callback function.

			/* Decrement the ndlp reference count we

			 * set for this failed mailbox command.

 ELS rsp: Cannot issue reg_login for <NPortid> */

	/* An SLI4 NPIV instance wants to drop the node at this point under

	 * these conditions and release the RPI.

 Release the originating I/O reference. */

/**

 * lpfc_els_rsp_acc - Prepare and issue an acc response iocb command

 * @vport: pointer to a host virtual N_Port data structure.

 * @flag: the els command code to be accepted.

 * @oldiocb: pointer to the original lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 * @mbox: pointer to the driver internal queue element for mailbox command.

 *

 * This routine prepares and issues an Accept (ACC) response IOCB

 * command. It uses the @flag to properly set up the IOCB field for the

 * specific ACC response command to be issued and invokes the

 * lpfc_sli_issue_iocb() routine to send out ACC response IOCB. If a

 * @mbox pointer is passed in, it will be put into the context_un.mbox

 * field of the IOCB for the completion callback function to issue the

 * mailbox command to the HBA later when callback is invoked.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the corresponding

 * response ELS IOCB command.

 *

 * Return code

 *   0 - Successfully issued acc response

 *   1 - Failed to issue acc response

 Xri / rx_id */

 Xri / rx_id */

 Copy the received service parameters back */

 Clear the F_Port bit */

 Mark all class service parameters as invalid */

 Copy our worldwide names */

			/* If our firmware supports this feature, convey that

			 * info to the target using the vendor specific field.

 Xri / rx_id */

 Xri / rx_id */

 FC-LS-5 specifies desc_list_len shall be set to 12 */

 FC-LS-5 specifies LS REQ Information descriptor */

 Xmit ELS ACC response tag <ulpIoTag> */

/**

 * lpfc_els_rsp_reject - Prepare and issue a rjt response iocb command

 * @vport: pointer to a virtual N_Port data structure.

 * @rejectError: reject response to issue

 * @oldiocb: pointer to the original lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 * @mbox: pointer to the driver internal queue element for mailbox command.

 *

 * This routine prepares and issue an Reject (RJT) response IOCB

 * command. If a @mbox pointer is passed in, it will be put into the

 * context_un.mbox field of the IOCB for the completion callback function

 * to issue to the HBA later.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the reject response

 * ELS IOCB command.

 *

 * Return code

 *   0 - Successfully issued reject response

 *   1 - Failed to issue reject response

 Xri / rx_id */

 Xmit ELS RJT <err> response tag <ulpIoTag> */

	/* The NPIV instance is rejecting this unsolicited ELS. Make sure the

	 * node's assigned RPI gets released provided this node is not already

	 * registered with the transport.

 /**

  * lpfc_issue_els_edc_rsp - Exchange Diagnostic Capabilities with the fabric.

  * @vport: pointer to a host virtual N_Port data structure.

  * @cmdiocb: pointer to the original lpfc command iocb data structure.

  * @ndlp: NPort to where rsp is directed

  *

  * This routine issues an EDC ACC RSP to the F-Port Controller to communicate

  * this N_Port's support of hardware signals in its Congestion

  * Capabilities Descriptor.

  *

  * Return code

  *   0 - Successfully issued edc rsp command

  *   1 - Failed to issue edc rsp command

 Xri / rx_id */

 Xmit ELS ACC response tag <ulpIoTag> */

/**

 * lpfc_els_rsp_adisc_acc - Prepare and issue acc response to adisc iocb cmd

 * @vport: pointer to a virtual N_Port data structure.

 * @oldiocb: pointer to the original lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine prepares and issues an Accept (ACC) response to Address

 * Discover (ADISC) ELS command. It simply prepares the payload of the IOCB

 * and invokes the lpfc_sli_issue_iocb() routine to send out the command.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the ADISC Accept response

 * ELS IOCB command.

 *

 * Return code

 *   0 - Successfully issued acc adisc response

 *   1 - Failed to issue adisc acc response

 Xri / rx_id */

 Xmit ADISC ACC response tag <ulpIoTag> */

 Xmit ELS ACC response tag <ulpIoTag> */

/**

 * lpfc_els_rsp_prli_acc - Prepare and issue acc response to prli iocb cmd

 * @vport: pointer to a virtual N_Port data structure.

 * @oldiocb: pointer to the original lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine prepares and issues an Accept (ACC) response to Process

 * Login (PRLI) ELS command. It simply prepares the payload of the IOCB

 * and invokes the lpfc_sli_issue_iocb() routine to send out the command.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the PRLI Accept response

 * ELS IOCB command.

 *

 * Return code

 *   0 - Successfully issued acc prli response

 *   1 - Failed to issue acc prli response

	/* Need the incoming PRLI payload to determine if the ACC is for an

	 * FC4 or NVME PRLI type.  The PRLI type is at word 1.

 PRLI type payload is at byte 3 for FCP or NVME. */

 Xri / rx_id */

 Xmit PRLI ACC response tag <ulpIoTag> */

 For PRLI, remainder of payload is PRLI parameter page */

		/*

		 * If the remote port is a target and our firmware version

		 * is 3.20 or later, set the following bits for FC-TAPE

		 * support.

 Respond with an NVME PRLI Type */

 Should be 0 */

				/* TBD.  Target mode needs to post buffers

				 * that support the configured first burst

				 * byte size.

/**

 * lpfc_els_rsp_rnid_acc - Issue rnid acc response iocb command

 * @vport: pointer to a virtual N_Port data structure.

 * @format: rnid command format.

 * @oldiocb: pointer to the original lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine issues a Request Node Identification Data (RNID) Accept

 * (ACC) response. It constructs the RNID ACC response command according to

 * the proper @format and then calls the lpfc_sli_issue_iocb() routine to

 * issue the response.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function.

 *

 * Return code

 *   0 - Successfully issued acc rnid response

 *   1 - Failed to issue acc rnid response

 Xri / rx_id */

 Xmit RNID ACC response tag <ulpIoTag> */

/**

 * lpfc_els_clear_rrq - Clear the rq that this rrq describes.

 * @vport: pointer to a virtual N_Port data structure.

 * @iocb: pointer to the lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * Return

/**

 * lpfc_els_rsp_echo_acc - Issue echo acc response

 * @vport: pointer to a virtual N_Port data structure.

 * @data: pointer to echo data to return in the accept.

 * @oldiocb: pointer to the original lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * Return code

 *   0 - Successfully issued acc echo response

 *   1 - Failed to issue acc echo response

	/* The accumulated length can exceed the BPL_SIZE.  For

	 * now, use this as the limit

 Xri / rx_id */

 Xmit ECHO ACC response tag <ulpIoTag> */

/**

 * lpfc_els_disc_adisc - Issue remaining adisc iocbs to npr nodes of a vport

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine issues Address Discover (ADISC) ELS commands to those

 * N_Ports which are in node port recovery state and ADISC has not been issued

 * for the @vport. Each time an ELS ADISC IOCB is issued by invoking the

 * lpfc_issue_els_adisc() routine, the per @vport number of discover count

 * (num_disc_nodes) shall be incremented. If the num_disc_nodes reaches a

 * pre-configured threshold (cfg_discovery_threads), the @vport fc_flag will

 * be marked with FC_NLP_MORE bit and the process of issuing remaining ADISC

 * IOCBs quit for later pick up. On the other hand, after walking through

 * all the ndlps with the @vport and there is none ADISC IOCB issued, the

 * @vport fc_flag shall be cleared with FC_NLP_MORE bit indicating there is

 * no more ADISC need to be sent.

 *

 * Return code

 *    The number of N_Ports with adisc issued.

 go thru NPR nodes and issue any remaining ELS ADISCs */

			/* This node was marked for ADISC but was not picked

			 * for discovery. This is possible if the node was

			 * missing in gidft response.

			 *

			 * At time of marking node for ADISC, we skipped unreg

			 * from backend

/**

 * lpfc_els_disc_plogi - Issue plogi for all npr nodes of a vport before adisc

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine issues Port Login (PLOGI) ELS commands to all the N_Ports

 * which are in node port recovery state, with a @vport. Each time an ELS

 * ADISC PLOGI IOCB is issued by invoking the lpfc_issue_els_plogi() routine,

 * the per @vport number of discover count (num_disc_nodes) shall be

 * incremented. If the num_disc_nodes reaches a pre-configured threshold

 * (cfg_discovery_threads), the @vport fc_flag will be marked with FC_NLP_MORE

 * bit set and quit the process of issuing remaining ADISC PLOGIN IOCBs for

 * later pick up. On the other hand, after walking through all the ndlps with

 * the @vport and there is none ADISC PLOGI IOCB issued, the @vport fc_flag

 * shall be cleared with the FC_NLP_MORE bit indicating there is no more ADISC

 * PLOGI need to be sent.

 *

 * Return code

 *   The number of N_Ports with plogi issued.

 go thru NPR nodes and issue any remaining ELS PLOGIs */

 check if its short WL */

 check if its SFP+ */

 check if its OPTICAL */

 Point to Point */

 This will change once we know the true size of the RDP payload */

 Update Alarm and Warning */

 For RDP payload */

 Now that we know the true size of the payload, update the BPL */

	/* This reference put is for the original unsolicited RDP. If the

	 * iocb prep failed, there is no reference to remove.

/*

 * lpfc_els_rcv_rdp - Process an unsolicited RDP ELS.

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine processes an unsolicited RDP(Read Diagnostic Parameters)

 * IOCB. First, the payload of the unsolicited RDP is checked.

 * Then it will (1) send MBX_DUMP_MEMORY, Embedded DMP_LMSD sub command TYPE-3

 * for Page A0, (2) send MBX_DUMP_MEMORY, DMP_LMSD for Page A2,

 * (3) send MBX_READ_LNK_STAT to get link stat, (4) Call lpfc_els_rdp_cmpl

 * gather all data and send RDP response.

 *

 * Return code

 *   0 - Sent the acc response

 *   1 - Sent the reject response.

 Decrement the ndlp reference count from previous mbox command */

 Reserved */

	/*

	 *	Check bv1s bit before issuing the mailbox

	 *	if bv1s == 1, LCB V1 supported

	 *	else, LCB V0 supported

 COMMON_SET_BEACON_CONFIG_V1 */

 COMMON_SET_BEACON_CONFIG_V0 */

/**

 * lpfc_els_rcv_lcb - Process an unsolicited LCB

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine processes an unsolicited LCB(LINK CABLE BEACON) IOCB.

 * First, the payload of the unsolicited LCB is checked.

 * Then based on Subcommand beacon will either turn on or off.

 *

 * Return code

 * 0 - Sent the acc response

 * 1 - Sent the reject response.

/**

 * lpfc_els_flush_rscn - Clean up any rscn activities with a vport

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine cleans up any Registration State Change Notification

 * (RSCN) activity with a @vport. Note that the fc_rscn_flush flag of the

 * @vport together with the host_lock is used to prevent multiple thread

 * trying to access the RSCN array on a same @vport at the same time.

 Another thread is walking fc_rscn_id_list on this vport */

 Indicate we are walking lpfc_els_flush_rscn on this vport */

 Indicate we are done walking this fc_rscn_id_list */

/**

 * lpfc_rscn_payload_check - Check whether there is a pending rscn to a did

 * @vport: pointer to a host virtual N_Port data structure.

 * @did: remote destination port identifier.

 *

 * This routine checks whether there is any pending Registration State

 * Configuration Notification (RSCN) to a @did on @vport.

 *

 * Return code

 *   None zero - The @did matched with a pending rscn

 *   0 - not able to match @did with a pending rscn

 Never match fabric nodes for RSCNs */

 If we are doing a FULL RSCN rediscovery, match everything */

 Another thread is walking fc_rscn_id_list on this vport */

 Indicate we are walking fc_rscn_id_list on this vport */

 take off word 0 */

 Indicate we are done with walking fc_rscn_id_list on this vport */

 Indicate we are done with walking fc_rscn_id_list on this vport */

/**

 * lpfc_rscn_recovery_check - Send recovery event to vport nodes matching rscn

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine sends recovery (NLP_EVT_DEVICE_RECOVERY) event to the

 * state machine for a @vport's nodes that are with pending RSCN (Registration

 * State Change Notification).

 *

 * Return code

 *   0 - Successful (currently alway return 0)

 Move all affected nodes by pending RSCNs to NPR state. */

 NVME Target mode does not do RSCN Recovery. */

		/* If we are in the process of doing discovery on this

		 * NPort, let it continue on its own.

/**

 * lpfc_send_rscn_event - Send an RSCN event to management application

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 *

 * lpfc_send_rscn_event sends an RSCN netlink event to management

 * applications.

/**

 * lpfc_els_rcv_rscn - Process an unsolicited rscn iocb

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine processes an unsolicited RSCN (Registration State Change

 * Notification) IOCB. First, the payload of the unsolicited RSCN is walked

 * to invoke fc_host_post_event() routine to the FC transport layer. If the

 * discover state machine is about to begin discovery, it just accepts the

 * RSCN and the discovery process will satisfy the RSCN. If this RSCN only

 * contains N_Port IDs for other vports on this HBA, it just accepts the

 * RSCN and ignore processing it. If the state machine is in the recovery

 * state, the fc_rscn_id_list of this @vport is walked and the

 * lpfc_rscn_recovery_check() routine is invoked to send recovery event for

 * all nodes that match RSCN payload. Otherwise, the lpfc_els_handle_rscn()

 * routine is invoked to handle the RSCN event.

 *

 * Return code

 *   0 - Just sent the acc response

 *   1 - Sent the acc response and waited for name server completion

 take off word 0 */

 RSCN received */

 Send an RSCN event to the management application */

 Check if RSCN is coming from a direct-connected remote NPort */

 If so, just ACC it, no other action needed for now */

		/* Check to see if we need to NVME rescan this target

		 * remoteport.

	/* If we are about to begin discovery, just ACC the RSCN.

	 * Discovery processing will satisfy it.

	/* If this RSCN just contains NPortIDs for other vports on this HBA,

	 * just ACC and ignore it.

 ALL NPortIDs in RSCN are on HBA */

 Another thread is walking fc_rscn_id_list on this vport */

 Send back ACC */

 Indicate we are walking fc_rscn_id_list on this vport */

 Get the array count after successfully have the token */

	/* If we are already processing an RSCN, save the received

	 * RSCN payload buffer, cmdiocb->context2 to process later.

 Restart disctmo if its already running */

				/* If we zero, cmdiocb->context2, the calling

				 * routine will not try to free it.

 Deferred RSCN */

 ReDiscovery RSCN */

 Indicate we are done walking fc_rscn_id_list on this vport */

 Send back ACC */

 send RECOVERY event for ALL nodes that match RSCN payload */

 Indicate we are done walking fc_rscn_id_list on this vport */

	/*

	 * If we zero, cmdiocb->context2, the calling routine will

	 * not try to free it.

 Send back ACC */

 send RECOVERY event for ALL nodes that match RSCN payload */

/**

 * lpfc_els_handle_rscn - Handle rscn for a vport

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine handles the Registration State Configuration Notification

 * (RSCN) for a @vport. If login to NameServer does not exist, a new ndlp shall

 * be created and a Port Login (PLOGI) to the NameServer is issued. Otherwise,

 * if the ndlp to NameServer exists, a Common Transport (CT) command to the

 * NameServer shall be issued. If CT command to the NameServer fails to be

 * issued, the lpfc_els_flush_rscn() routine shall be invoked to clean up any

 * RSCN activities with the @vport.

 *

 * Return code

 *   0 - Cleaned up rscn on the @vport

 *   1 - Wait for plogi to name server before proceed

 Ignore RSCN if the port is being torn down. */

 Start timer for RSCN processing */

 RSCN processed */

 To process RSCN, first compare RSCN data with NameServer */

		/* Good ndlp, issue CT Request to NameServer.  Need to

		 * know how many gidfts were issued.  If none, then just

		 * flush the RSCN.  Otherwise, the outstanding requests

		 * need to complete.

 Nameserver login in question.  Revalidate. */

		/* Wait for NameServer login cmpl before we can

		 * continue

/**

 * lpfc_els_rcv_flogi - Process an unsolicited flogi iocb

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine processes Fabric Login (FLOGI) IOCB received as an ELS

 * unsolicited event. An unsolicited FLOGI can be received in a point-to-

 * point topology. As an unsolicited FLOGI should not be received in a loop

 * mode, any unsolicited FLOGI received in loop mode shall be ignored. The

 * lpfc_check_sparm() routine is invoked to check the parameters in the

 * unsolicited FLOGI. If parameters validation failed, the routine

 * lpfc_els_rsp_reject() shall be called with reject reason code set to

 * LSEXP_SPARM_OPTIONS to reject the FLOGI. Otherwise, the Port WWN in the

 * FLOGI shall be compared with the Port WWN of the @vport to determine who

 * will initiate PLOGI. The higher lexicographical value party shall has

 * higher priority (as the winning port) and will initiate PLOGI and

 * communicate Port_IDs (Addresses) for both nodes in PLOGI. The result

 * of this will be marked in the @vport fc_flag field with FC_PT2PT_PLOGI

 * and then the lpfc_els_rsp_acc() routine is invoked to accept the FLOGI.

 *

 * Return code

 *   0 - Successfully processed the unsolicited flogi

 *   1 - Failed to process the unsolicited flogi

 FLOGI received */

 We should never receive a FLOGI in loop mode, ignore it */

		/* An FLOGI ELS command <elsCmd> was received from DID <did> in

	/*

	 * If our portname is greater than the remote portname,

	 * then we initiate Nport login.

		/* abort the flogi coming back to ourselves

		 * due to external loopback on the port.

 greater than */

		/* If we have the high WWPN we can assign our own

		 * myDID; otherwise, we have to WAIT for a PLOGI

		 * from the remote NPort to find out what it

		 * will be.

	/*

	 * The vport state should go to LPFC_FLOGI only

	 * AFTER we issue a FLOGI, not receive one.

	/* Acking an unsol FLOGI.  Count 1 for link bounce

	 * work-around.

	/*

	 * We temporarily set fc_myDID to make it look like we are

	 * a Fabric. This is done just so we end up with the right

	 * did / sid on the FLOGI ACC rsp.

 Defer ACC response until AFTER we issue a FLOGI */

 Send back ACC */

 Now lets put fc_myDID back to what its supposed to be */

/**

 * lpfc_els_rcv_rnid - Process an unsolicited rnid iocb

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine processes Request Node Identification Data (RNID) IOCB

 * received as an ELS unsolicited event. Only when the RNID specified format

 * 0x0 or 0xDF (Topology Discovery Specific Node Identification Data)

 * present, this routine will invoke the lpfc_els_rsp_rnid_acc() routine to

 * Accept (ACC) the RNID ELS command. All the other RNID formats are

 * rejected by invoking the lpfc_els_rsp_reject() routine.

 *

 * Return code

 *   0 - Successfully processed rnid iocb (currently always return 0)

 RNID received */

 Send back ACC */

 Reject this request because format not supported */

/**

 * lpfc_els_rcv_echo - Process an unsolicited echo iocb

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * Return code

 *   0 - Successfully processed echo iocb (currently always return 0)

 skip over first word of echo command to find echo data */

/**

 * lpfc_els_rcv_lirr - Process an unsolicited lirr iocb

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine processes a Link Incident Report Registration(LIRR) IOCB

 * received as an ELS unsolicited event. Currently, this function just invokes

 * the lpfc_els_rsp_reject() routine to reject the LIRR IOCB unconditionally.

 *

 * Return code

 *   0 - Successfully processed lirr iocb (currently always return 0)

 For now, unconditionally reject this command */

/**

 * lpfc_els_rcv_rrq - Process an unsolicited rrq iocb

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine processes a Reinstate Recovery Qualifier (RRQ) IOCB

 * received as an ELS unsolicited event. A request to RRQ shall only

 * be accepted if the Originator Nx_Port N_Port_ID or the Responder

 * Nx_Port N_Port_ID of the target Exchange is the same as the

 * N_Port_ID of the Nx_Port that makes the request. If the RRQ is

 * not accepted, an LS_RJT with reason code "Unable to perform

 * command request" and reason code explanation "Invalid Originator

 * S_ID" shall be returned. For now, we just unconditionally accept

 * RRQ from the target.

/**

 * lpfc_els_rsp_rls_acc - Completion callbk func for MBX_READ_LNK_STAT mbox cmd

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * This routine is the completion callback function for the MBX_READ_LNK_STAT

 * mailbox command. This callback function is to actually send the Accept

 * (ACC) response to a Read Link Status (RLS) unsolicited IOCB event. It

 * collects the link statistics from the completion of the MBX_READ_LNK_STAT

 * mailbox command, constructs the RLS response with the link statistics

 * collected, and then invokes the lpfc_sli_issue_iocb() routine to send ACC

 * response to the RLS.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the RLS Accept Response

 * ELS IOCB command.

 *

 Decrement the ndlp reference count from previous mbox command */

 Skip past command */

 Xmit ELS RLS ACC response tag <ulpIoTag> */

/**

 * lpfc_els_rcv_rls - Process an unsolicited rls iocb

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine processes Read Link Status (RLS) IOCB received as an

 * ELS unsolicited event. It first checks the remote port state. If the

 * remote port is not in NLP_STE_UNMAPPED_NODE state or NLP_STE_MAPPED_NODE

 * state, it invokes the lpfc_els_rsl_reject() routine to send the reject

 * response. Otherwise, it issue the MBX_READ_LNK_STAT mailbox command

 * for reading the HBA link statistics. It is for the callback function,

 * lpfc_els_rsp_rls_acc(), set to the MBX_READ_LNK_STAT mailbox command

 * to actually sending out RPL Accept (ACC) response.

 *

 * Return codes

 *   0 - Successfully processed rls iocb (currently always return 0)

 reject the unsolicited RLS request and done with it */

 rx_id */

 Mbox completion will send ELS Response */

		/* Decrement reference count used for the failed mbox

		 * command.

 issue rejection response */

/**

 * lpfc_els_rcv_rtv - Process an unsolicited rtv iocb

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine processes Read Timout Value (RTV) IOCB received as an

 * ELS unsolicited event. It first checks the remote port state. If the

 * remote port is not in NLP_STE_UNMAPPED_NODE state or NLP_STE_MAPPED_NODE

 * state, it invokes the lpfc_els_rsl_reject() routine to send the reject

 * response. Otherwise, it sends the Accept(ACC) response to a Read Timeout

 * Value (RTV) unsolicited IOCB event.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the RTV Accept Response

 * ELS IOCB command.

 *

 * Return codes

 *   0 - Successfully processed rtv iocb (currently always return 0)

 reject the unsolicited RTV request and done with it */

 Skip past command */

 use the command's xri in the response */

 Xri / rx_id */

 populate RTV payload */

 report msecs */

 Field is for FC ONLY */

 Xmit ELS RLS ACC response tag <ulpIoTag> */

 issue rejection response */

/* lpfc_issue_els_rrq - Process an unsolicited rrq iocb

 * @vport: pointer to a host virtual N_Port data structure.

 * @ndlp: pointer to a node-list data structure.

 * @did: DID of the target.

 * @rrq: Pointer to the rrq struct.

 *

 * Build a ELS RRQ command and send it to the target. If the issue_iocb is

 * Successful the the completion handler will clear the RRQ.

 *

 * Return codes

 *   0 - Successfully sent rrq els iocb.

 *   1 - Failed to send rrq els iocb.

 If ndlp is not NULL, we will bump the reference count on it */

 For RRQ request, remainder of payload is Exchange IDs */

/**

 * lpfc_send_rrq - Sends ELS RRQ if needed.

 * @phba: pointer to lpfc hba data structure.

 * @rrq: pointer to the active rrq.

 *

 * This routine will call the lpfc_issue_els_rrq if the rrq is

 * still active for the xri. If this function returns a failure then

 * the caller needs to clean up the RRQ by calling lpfc_clr_active_rrq.

 *

 * Returns 0 Success.

 *         1 Failure.

/**

 * lpfc_els_rsp_rpl_acc - Issue an accept rpl els command

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdsize: size of the ELS command.

 * @oldiocb: pointer to the original lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine issuees an Accept (ACC) Read Port List (RPL) ELS command.

 * It is to be called by the lpfc_els_rcv_rpl() routine to accept the RPL.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the RPL Accept Response

 * ELS command.

 *

 * Return code

 *   0 - Successfully issued ACC RPL ELS command

 *   1 - Failed to issue ACC RPL ELS command

 Xri / rx_id */

 Setup the RPL ACC payload */

 Xmit ELS RPL ACC response tag <ulpIoTag> */

/**

 * lpfc_els_rcv_rpl - Process an unsolicited rpl iocb

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine processes Read Port List (RPL) IOCB received as an ELS

 * unsolicited event. It first checks the remote port state. If the remote

 * port is not in NLP_STE_UNMAPPED_NODE and NLP_STE_MAPPED_NODE states, it

 * invokes the lpfc_els_rsp_reject() routine to send reject response.

 * Otherwise, this routine then invokes the lpfc_els_rsp_rpl_acc() routine

 * to accept the RPL.

 *

 * Return code

 *   0 - Successfully processed rpl iocb (currently always return 0)

 issue rejection response */

 rejected the unsolicited RPL request and done with it */

 We support only one port */

/**

 * lpfc_els_rcv_farp - Process an unsolicited farp request els command

 * @vport: pointer to a virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine processes Fibre Channel Address Resolution Protocol

 * (FARP) Request IOCB received as an ELS unsolicited event. Currently,

 * the lpfc driver only supports matching on WWPN or WWNN for FARP. As such,

 * FARP_MATCH_PORT flag and FARP_MATCH_NODE flag are checked against the

 * Match Flag in the FARP request IOCB: if FARP_MATCH_PORT flag is set, the

 * remote PortName is compared against the FC PortName stored in the @vport

 * data structure; if FARP_MATCH_NODE flag is set, the remote NodeName is

 * compared against the FC NodeName stored in the @vport data structure.

 * If any of these matches and the FARP_REQUEST_FARPR flag is set in the

 * FARP request IOCB Response Flag, the lpfc_issue_els_farpr() routine is

 * invoked to send out FARP Response to the remote node. Before sending the

 * FARP Response, however, the FARP_REQUEST_PLOGI flag is check in the FARP

 * request IOCB Response Flag and, if it is set, the lpfc_issue_els_plogi()

 * routine is invoked to log into the remote port first.

 *

 * Return code

 *   0 - Either the FARP Match Mode not supported or successfully processed

 FARP-REQ received from DID <did> */

 We will only support match on WWPN or WWNN */

 If this FARP command is searching for my portname */

 If this FARP command is searching for my nodename */

 Log back into the node before sending the FARP. */

 Send a FARP response to that node */

/**

 * lpfc_els_rcv_farpr - Process an unsolicited farp response iocb

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine processes Fibre Channel Address Resolution Protocol

 * Response (FARPR) IOCB received as an ELS unsolicited event. It simply

 * invokes the lpfc_els_rsp_acc() routine to the remote node to accept

 * the FARP response request.

 *

 * Return code

 *   0 - Successfully processed FARPR IOCB (currently always return 0)

 FARP-RSP received from DID <did> */

 ACCEPT the Farp resp request */

/**

 * lpfc_els_rcv_fan - Process an unsolicited fan iocb command

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @fan_ndlp: pointer to a node-list data structure.

 *

 * This routine processes a Fabric Address Notification (FAN) IOCB

 * command received as an ELS unsolicited event. The FAN ELS command will

 * only be processed on a physical port (i.e., the @vport represents the

 * physical port). The fabric NodeName and PortName from the FAN IOCB are

 * compared against those in the phba data structure. If any of those is

 * different, the lpfc_initial_flogi() routine is invoked to initialize

 * Fabric Login (FLOGI) to the fabric to start the discover over. Otherwise,

 * if both of those are identical, the lpfc_issue_fabric_reglogin() routine

 * is invoked to register login to the fabric.

 *

 * Return code

 *   0 - Successfully processed fan iocb (currently always return 0).

 FAN received; Fan does not have a reply sequence */

 This port has switched fabrics. FLOGI is required */

 FAN verified - skip FLOGI */

/**

 * lpfc_els_rcv_edc - Process an unsolicited EDC iocb

 * @vport: pointer to a host virtual N_Port data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * Return code

 *   0 - Successfully processed echo iocb (currently always return 0)

 No signal support unless there is a congestion descriptor */

	/*

	 * cycle through EDC diagnostic descriptors to find the

	 * congestion signaling capability descriptor

 No action for Link Fault descriptor for now */

			/* We start negotiation with lpfc_fabric_cgn_frequency.

			 * When we process the EDC, we will settle on the

			 * higher frequency.

 Need to send back an ACC */

/**

 * lpfc_els_timeout - Handler funciton to the els timer

 * @t: timer context used to obtain the vport.

 *

 * This routine is invoked by the ELS timer after timeout. It posts the ELS

 * timer timeout event by setting the WORKER_ELS_TMO bit to the work port

 * event bitmap and then invokes the lpfc_worker_wake_up() routine to wake

 * up the worker thread. It is for the worker thread to invoke the routine

 * lpfc_els_timeout_handler() to work on the posted event WORKER_ELS_TMO.

/**

 * lpfc_els_timeout_handler - Process an els timeout event

 * @vport: pointer to a virtual N_Port data structure.

 *

 * This routine is the actual handler function that processes an ELS timeout

 * event. It walks the ELS ring to get and abort all the IOCBs (except the

 * ABORT/CLOSE/FARP/FARPR/FDISC), which are associated with the @vport by

 * invoking the lpfc_sli_issue_abort_iotag() routine.

 Make sure HBA is alive */

/**

 * lpfc_els_flush_cmd - Clean up the outstanding els commands to a vport

 * @vport: pointer to a host virtual N_Port data structure.

 *

 * This routine is used to clean up all the outstanding ELS commands on a

 * @vport. It first aborts the @vport by invoking lpfc_fabric_abort_vport()

 * routine. After that, it walks the ELS transmit queue to remove all the

 * IOCBs with the @vport other than the QUE_RING and ABORT/CLOSE IOCBs. For

 * the IOCBs with a non-NULL completion callback function, the callback

 * function will be invoked with the status set to IOSTAT_LOCAL_REJECT and

 * un.ulpWord[4] set to IOERR_SLI_ABORTED. For IOCBs with a NULL completion

 * callback function, the IOCB will simply be released. Finally, it walks

 * the ELS transmit completion queue to issue an abort IOCB to any transmit

 * completion queue IOCB that is associated with the @vport and is not

 * an IOCB from libdfc (i.e., the management plane IOCBs that are not

 * part of the discovery state machine) out to HBA by invoking the

 * lpfc_sli_issue_abort_iotag() routine. Note that this function issues the

 * abort IOCB to any transmit completion queueed IOCB, it does not guarantee

 * the IOCBs are aborted when this function returns.

	/*

	 * For SLI3, only the hbalock is required.  But SLI4 needs to coordinate

	 * with the ring insert operation.  Because lpfc_sli_issue_abort_iotag

	 * ultimately grabs the ring_lock, the driver must splice the list into

	 * a working list and release the locks before calling the abort.

 Bail out if we've no ELS wq, like in PCI error recovery case. */

 First we need to issue aborts to outstanding cmds on txcmpl */

		/* On the ELS ring we can have ELS_REQUESTs or

		 * GEN_REQUESTs waiting for a response.

			/* If the link is down when flushing ELS commands

			 * the firmware will not complete them till after

			 * the link comes back up. This may confuse

			 * discovery for the new link up, so we need to

			 * change the compl routine to just clean up the iocb

			 * and avoid any retry logic.

 Abort each txcmpl iocb on aborted list and remove the dlist links. */

 Make sure HBA is alive */

	/* No need to abort the txq list,

	 * just queue them up for lpfc_sli_cancel_iocbs

 Do not flush out the QUE_RING and ABORT/CLOSE iocbs */

 The same holds true for any FLOGI/FDISC on the fabric_iocb_list */

 Cancel all the IOCBs from the completions list */

/**

 * lpfc_els_flush_all_cmd - Clean up all the outstanding els commands to a HBA

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine is used to clean up all the outstanding ELS commands on a

 * @phba. It first aborts the @phba by invoking the lpfc_fabric_abort_hba()

 * routine. After that, it walks the ELS transmit queue to remove all the

 * IOCBs to the @phba other than the QUE_RING and ABORT/CLOSE IOCBs. For

 * the IOCBs with the completion callback function associated, the callback

 * function will be invoked with the status set to IOSTAT_LOCAL_REJECT and

 * un.ulpWord[4] set to IOERR_SLI_ABORTED. For IOCBs without the completion

 * callback function associated, the IOCB will simply be released. Finally,

 * it walks the ELS transmit completion queue to issue an abort IOCB to any

 * transmit completion queue IOCB that is not an IOCB from libdfc (i.e., the

 * management plane IOCBs that are not part of the discovery state machine)

 * out to HBA by invoking the lpfc_sli_issue_abort_iotag() routine.

/**

 * lpfc_send_els_failure_event - Posts an ELS command failure event

 * @phba: Pointer to hba context object.

 * @cmdiocbp: Pointer to command iocb which reported error.

 * @rspiocbp: Pointer to response iocb which reported error.

 *

 * This function sends an event when there is an ELS command

 * failure.

/**

 * lpfc_send_els_event - Posts unsolicited els event

 * @vport: Pointer to vport object.

 * @ndlp: Pointer FC node object.

 * @payload: ELS command code type.

 *

 * This function posts an event when there is an incoming

 * unsolicited ELS command.

 Copy the WWPN in the LOGO payload */

/**

 * lpfc_display_fpin_wwpn - Display WWPNs accessible by the attached port

 * @phba: Pointer to phba object.

 * @wwnlist: Pointer to list of WWPNs in FPIN payload

 * @cnt: count of WWPNs in FPIN payload

 *

 * This routine is called by LI and PC descriptors.

 * Limit the number of WWPNs displayed to 6 log messages, 6 per log message

 Are we on the last WWPN */

 Extract the next WWPN from the payload */

		/* Log a message if we are on the last WWPN

		 * or if we hit the max allowed per message.

 Check if we reached the last WWPN */

 Limit the number of log message displayed per FPIN */

 Start over with next log message */

/**

 * lpfc_els_rcv_fpin_li - Process an FPIN Link Integrity Event.

 * @phba: Pointer to phba object.

 * @tlv:  Pointer to the Link Integrity Notification Descriptor.

 *

 * This function processes a Link Integrity FPIN event by logging a message.

/**

 * lpfc_els_rcv_fpin_del - Process an FPIN Delivery Event.

 * @phba: Pointer to hba object.

 * @tlv:  Pointer to the Delivery Notification Descriptor TLV

 *

 * This function processes a Delivery FPIN event by logging a message.

 Skip over desc_tag/desc_len header to payload */

/**

 * lpfc_els_rcv_fpin_peer_cgn - Process a FPIN Peer Congestion Event.

 * @phba: Pointer to hba object.

 * @tlv:  Pointer to the Peer Congestion Notification Descriptor TLV

 *

 * This function processes a Peer Congestion FPIN event by logging a message.

/**

 * lpfc_els_rcv_fpin_cgn - Process an FPIN Congestion notification

 * @phba: Pointer to hba object.

 * @tlv:  Pointer to the Congestion Notification Descriptor TLV

 *

 * This function processes an FPIN Congestion Notifiction.  The notification

 * could be an Alarm or Warning.  This routine feeds that data into driver's

 * running congestion algorithm. It also processes the FPIN by

 * logging a message. It returns 1 to indicate deliver this message

 * to the upper layer or 0 to indicate don't deliver it.

	/* The driver only takes action on a Credit Stall or Oversubscription

	 * event type to engage the IO algorithm.  The driver prints an

	 * unmaskable message only for Lost Credit and Credit Stall.

	 * TODO: Still need to have definition of host action on clear,

	 *       lost credit and device specific event types.

 Take action here for an Alarm event */

 Track of alarm cnt for cgn_info */

 Track of alarm cnt for SYNC_WQE */

 Take action here for a Warning event */

 Track of warning cnt for cgn_info */

 Track of warning cnt for SYNC_WQE */

 Save frequency in ms */

				/* Don't deliver to upper layer since

				 * driver took action on this tlv.

 Change the log level to unmaskable for the following event types. */

 FPINs handled only if we are in the right discovery state */

 make sure there is the full fpin header */

	/* Sanity check descriptor length. The desc_len value does not

	 * include space for the ELS command and the desc_len fields.

 process each descriptor separately */

 If descriptor is bad, drop the rest of the data */

		/* Sanity check descriptor length. The desc_len value does not

		 * include space for the desc_tag and the desc_len fields.

		/* Format payload such that the FPIN delivered to the

		 * upper layer is a single descriptor FPIN.

		/* Adjust the length so that it only reflects a

		 * single descriptor FPIN.

 the entire FPIN */

 Send every descriptor individually to the upper layer */

/**

 * lpfc_els_unsol_buffer - Process an unsolicited event data buffer

 * @phba: pointer to lpfc hba data structure.

 * @pring: pointer to a SLI ring.

 * @vport: pointer to a host virtual N_Port data structure.

 * @elsiocb: pointer to lpfc els command iocb data structure.

 *

 * This routine is used for processing the IOCB associated with a unsolicited

 * event. It first determines whether there is an existing ndlp that matches

 * the DID from the unsolicited IOCB. If not, it will create a new one with

 * the DID from the unsolicited IOCB. The ELS command from the unsolicited

 * IOCB is then used to invoke the proper routine and to set up proper state

 * of the discovery state machine.

 Check to see if link went down during discovery */

 Ignore traffic received during vport shutdown. */

 If NPort discovery is delayed drop incoming ELS */

 Cannot find existing Fabric ndlp, so allocate a new one */

	/*

	 * Do not process any unsolicited ELS commands

	 * if the ndlp is in DEV_LOSS

 ELS command <elsCmd> received from NPORT <did> */

 reject till our FLOGI completes or PLOGI assigned DID via PT2PT */

			/* Our DID needs to be updated before registering

			 * the vfi. This is done in lpfc_rcv_plogi but

			 * that is called after the reg_vfi.

 If Nport discovery is delayed, reject PLOGIs */

		/* If the driver believes fabric discovery is done and is ready,

		 * bounce the link.  There is some descrepancy.

 receive this due to exchange closed */

 There are no replies, so no rjt codes */

 Accept RDF only from fabric controller */

 Unsupported ELS command, reject */

 Unknown ELS command <elsCmd> received from NPORT <did> */

 check if need to LS_RJT received ELS cmd */

 Remove the reference from above for new nodes. */

 Release the reference on this elsiocb, not the ndlp. */

	/* Special case.  Driver received an unsolicited command that

	 * unsupportable given the driver's current state.  Reset the

	 * link and start over.

/**

 * lpfc_els_unsol_event - Process an unsolicited event from an els sli ring

 * @phba: pointer to lpfc hba data structure.

 * @pring: pointer to a SLI ring.

 * @elsiocb: pointer to lpfc els iocb data structure.

 *

 * This routine is used to process an unsolicited event received from a SLI

 * (Service Level Interface) ring. The actual processing of the data buffer

 * associated with the unsolicited event is done by invoking the routine

 * lpfc_els_unsol_buffer() after properly set up the iocb buffer from the

 * SLI ring on which the unsolicited event was received.

 Not enough posted buffers; Try posting more buffers */

	/* If there are no BDEs associated

	 * with this IOCB, there is nothing to do.

	/* type of ELS cmd is first 32bit word

	 * in packet

	/*

	 * The different unsolicited event handlers would tell us

	 * if they are done with "mp" by setting context2 to NULL.

 RCV_ELS64_CX provide for 2 BDEs - process 2nd if included */

 free mp if we are done with it */

	/* If this is the first time, allocate an ndlp and initialize

	 * it. Otherwise, make sure the node is enabled and then do the

	 * login.

/**

 * lpfc_do_scr_ns_plogi - Issue a plogi to the name server for scr

 * @phba: pointer to lpfc hba data structure.

 * @vport: pointer to a virtual N_Port data structure.

 *

 * This routine issues a Port Login (PLOGI) to the Name Server with

 * State Change Request (SCR) for a @vport. This routine will create an

 * ndlp for the Name Server associated to the @vport if such node does

 * not already exist. The PLOGI to Name Server is issued by invoking the

 * lpfc_issue_els_plogi() routine. If Fabric-Device Management Interface

 * (FDMI) is configured to the @vport, a FDMI node will be created and

 * the PLOGI to FDMI is issued by invoking lpfc_issue_els_plogi() routine.

	/*

	 * If lpfc_delay_discovery parameter is set and the clean address

	 * bit is cleared and fc fabric parameters chenged, delay FC NPort

	 * discovery.

/**

 * lpfc_cmpl_reg_new_vport - Completion callback function to register new vport

 * @phba: pointer to lpfc hba data structure.

 * @pmb: pointer to the driver internal queue element for mailbox command.

 *

 * This routine is the completion callback function to register new vport

 * mailbox command. If the new vport mailbox command completes successfully,

 * the fabric registration login shall be performed on physical port (the

 * new vport created is actually a physical port, with VPI 0) or the port

 * login to Name Server for State Change Request (SCR) will be performed

 * on virtual port (real virtual port, with VPI greater than 0).

 unsupported feature */

 max_vpi exceeded */

 Link event since CLEAR_LA */

 giving up on vport registration */

 If reg_vpi fail with invalid VPI status, re-init VPI */

 Try to recover from this error */

				/*

				 * If the physical port is instantiated using

				 * FDISC, do not start vport discovery.

	/* Now, we decrement the ndlp reference count held for this

	 * callback function

/**

 * lpfc_register_new_vport - Register a new vport with a HBA

 * @phba: pointer to lpfc hba data structure.

 * @vport: pointer to a host virtual N_Port data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine registers the @vport as a new virtual port with a HBA.

 * It is done through a registering vpi mailbox command.

			/* mailbox command not success, decrement ndlp

			 * reference count for this command

/**

 * lpfc_cancel_all_vport_retry_delay_timer - Cancel all vport retry delay timer

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine cancels the retry delay timers to all the vports.

 Treat this failure as linkdown for all vports */

/**

 * lpfc_retry_pport_discovery - Start timer to retry FLOGI.

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine abort all pending discovery commands and

 * start a timer to retry FLOGI for the physical port

 * discovery.

 Cancel the all vports retry delay retry timers */

 If fabric require FLOGI, then re-instantiate physical login */

/**

 * lpfc_fabric_login_reqd - Check if FLOGI required.

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to FDISC command iocb.

 * @rspiocb: pointer to FDISC response iocb.

 *

 * This routine checks if a FLOGI is reguired for FDISC

 * to succeed.

/**

 * lpfc_cmpl_els_fdisc - Completion function for fdisc iocb command

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

 * This routine is the completion callback function to a Fabric Discover

 * (FDISC) ELS command. Since all the FDISC ELS commands are issued

 * single threaded, each FDISC completion callback function will reset

 * the discovery timer for all vports such that the timers will not get

 * unnecessary timeout. The function checks the FDISC IOCB status. If error

 * detected, the vport will be set to FC_VPORT_FAILED state. Otherwise,the

 * vport will set to FC_VPORT_ACTIVE state. It then checks whether the DID

 * assigned to the vport has been changed with the completion of the FDISC

 * command. If so, both RPI (Remote Port Index) and VPI (Virtual Port Index)

 * are unregistered from the HBA, and then the lpfc_register_new_vport()

 * routine is invoked to register new vport with the HBA. Otherwise, the

 * lpfc_do_scr_ns_plogi() routine is invoked to issue a PLOGI to the Name

 * Server for State Change Request (SCR).

	/* Since all FDISCs are being single threaded, we

	 * must reset the discovery timer for ALL vports

	 * waiting to send FDISC when one completes.

 Check for retry */

 FDISC failed */

		/* If our NportID changed, we need to ensure all

		 * remaining NPORTs get unreg_login'ed so we can

		 * issue unreg_vpi.

		/*

		 * Driver needs to re-reg VPI in order for f/w

		 * to update the MAC address.

	/* The FDISC completed successfully. Move the fabric ndlp to

	 * UNMAPPED state and register with the transport.

 Cancel discovery timer */

/**

 * lpfc_issue_els_fdisc - Issue a fdisc iocb command

 * @vport: pointer to a virtual N_Port data structure.

 * @ndlp: pointer to a node-list data structure.

 * @retry: number of retries to the command IOCB.

 *

 * This routine prepares and issues a Fabric Discover (FDISC) IOCB to

 * a remote node (@ndlp) off a @vport. It uses the lpfc_issue_fabric_iocb()

 * routine to issue the IOCB, which makes sure only one outstanding fabric

 * IOCB will be sent off HBA at any given time.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the FDISC ELS command.

 *

 * Return code

 *   0 - Successfully issued fdisc iocb command

 *   1 - Failed to issue fdisc iocb command

	/*

	 * SLI3 ports require a different context type value than SLI4.

	 * Catch SLI3 ports here and override the prep.

 CSP Word 1 */

 Setup CSPs accordingly for Fabric */

 CSP Word 2 */

 CSP Word 3 */

 CSP Word 4 */

 Port Name */

 Node Name */

 Node Name */

/**

 * lpfc_cmpl_els_npiv_logo - Completion function with vport logo

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

 * This routine is the completion callback function to the issuing of a LOGO

 * ELS command off a vport. It frees the command IOCB and then decrement the

 * reference count held on ndlp for this completion function, indicating that

 * the reference to the ndlp is no long needed. Note that the

 * lpfc_els_free_iocb() routine decrements the ndlp reference held for this

 * callback function and an additional explicit ndlp reference decrementation

 * will trigger the actual release of the ndlp.

 NPIV LOGO completes to NPort <nlp_DID> */

 Safe to release resources now. */

/**

 * lpfc_issue_els_npiv_logo - Issue a logo off a vport

 * @vport: pointer to a virtual N_Port data structure.

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine issues a LOGO ELS command to an @ndlp off a @vport.

 *

 * Note that the ndlp reference count will be incremented by 1 for holding the

 * ndlp and the reference to ndlp will be stored into the context1 field of

 * the IOCB for the completion callback function to the LOGO ELS command.

 *

 * Return codes

 *   0 - Successfully issued logo off the @vport

 *   1 - Failed to issue logo off the @vport

 Fill in LOGO payload */

/**

 * lpfc_fabric_block_timeout - Handler function to the fabric block timer

 * @t: timer context used to obtain the lpfc hba.

 *

 * This routine is invoked by the fabric iocb block timer after

 * timeout. It posts the fabric iocb block timeout event by setting the

 * WORKER_FABRIC_BLOCK_TMO bit to work port event bitmap and then invokes

 * lpfc_worker_wake_up() routine to wake up the worker thread. It is for

 * the worker thread to invoke the lpfc_unblock_fabric_iocbs() on the

 * posted event WORKER_FABRIC_BLOCK_TMO.

/**

 * lpfc_resume_fabric_iocbs - Issue a fabric iocb from driver internal list

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine issues one fabric iocb from the driver internal list to

 * the HBA. It first checks whether it's ready to issue one fabric iocb to

 * the HBA (whether there is no outstanding fabric iocb). If so, it shall

 * remove one pending fabric iocb from the driver internal list and invokes

 * lpfc_sli_issue_iocb() routine to send the fabric iocb to the HBA.

 Post any pending iocb to the SLI layer */

 Increment fabric iocb count to hold the position */

/**

 * lpfc_unblock_fabric_iocbs - Unblock issuing fabric iocb command

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine unblocks the  issuing fabric iocb command. The function

 * will clear the fabric iocb block bit and then invoke the routine

 * lpfc_resume_fabric_iocbs() to issue one of the pending fabric iocb

 * from the driver internal fabric iocb list.

/**

 * lpfc_block_fabric_iocbs - Block issuing fabric iocb command

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine blocks the issuing fabric iocb for a specified amount of

 * time (currently 100 ms). This is done by set the fabric iocb block bit

 * and set up a timeout timer for 100ms. When the block bit is set, no more

 * fabric iocb will be issued out of the HBA.

 Start a timer to unblock fabric iocbs after 100ms */

/**

 * lpfc_cmpl_fabric_iocb - Completion callback function for fabric iocb

 * @phba: pointer to lpfc hba data structure.

 * @cmdiocb: pointer to lpfc command iocb data structure.

 * @rspiocb: pointer to lpfc response iocb data structure.

 *

 * This routine is the callback function that is put to the fabric iocb's

 * callback function pointer (iocb->iocb_cmpl). The original iocb's callback

 * function pointer has been stored in iocb->fabric_iocb_cmpl. This callback

 * function first restores and invokes the original iocb's callback function

 * and then invokes the lpfc_resume_fabric_iocbs() routine to issue the next

 * fabric bound iocb from the driver internal fabric iocb list onto the wire.

 Post any pending iocbs to HBA */

/**

 * lpfc_issue_fabric_iocb - Issue a fabric iocb command

 * @phba: pointer to lpfc hba data structure.

 * @iocb: pointer to lpfc command iocb data structure.

 *

 * This routine is used as the top-level API for issuing a fabric iocb command

 * such as FLOGI and FDISC. To accommodate certain switch fabric, this driver

 * function makes sure that only one fabric bound iocb will be outstanding at

 * any given time. As such, this function will first check to see whether there

 * is already an outstanding fabric iocb on the wire. If so, it will put the

 * newly issued iocb onto the driver internal fabric iocb list, waiting to be

 * issued later. Otherwise, it will issue the iocb on the wire and update the

 * fabric iocb count it indicate that there is one fabric iocb on the wire.

 *

 * Note, this implementation has a potential sending out fabric IOCBs out of

 * order. The problem is caused by the construction of the "ready" boolen does

 * not include the condition that the internal fabric IOCB list is empty. As

 * such, it is possible a fabric IOCB issued by this routine might be "jump"

 * ahead of the fabric IOCBs in the internal list.

 *

 * Return code

 *   IOCB_SUCCESS - either fabric iocb put on the list or issued successfully

 *   IOCB_ERROR - failed to issue fabric iocb

 Increment fabric iocb count to hold the position */

/**

 * lpfc_fabric_abort_vport - Abort a vport's iocbs from driver fabric iocb list

 * @vport: pointer to a virtual N_Port data structure.

 *

 * This routine aborts all the IOCBs associated with a @vport from the

 * driver internal fabric IOCB list. The list contains fabric IOCBs to be

 * issued to the ELS IOCB ring. This abort function walks the fabric IOCB

 * list, removes each IOCB associated with the @vport off the list, set the

 * status field to IOSTAT_LOCAL_REJECT, and invokes the callback function

 * associated with the IOCB.

 Cancel all the IOCBs from the completions list */

/**

 * lpfc_fabric_abort_nport - Abort a ndlp's iocbs from driver fabric iocb list

 * @ndlp: pointer to a node-list data structure.

 *

 * This routine aborts all the IOCBs associated with an @ndlp from the

 * driver internal fabric IOCB list. The list contains fabric IOCBs to be

 * issued to the ELS IOCB ring. This abort function walks the fabric IOCB

 * list, removes each IOCB associated with the @ndlp off the list, set the

 * status field to IOSTAT_LOCAL_REJECT, and invokes the callback function

 * associated with the IOCB.

 Cancel all the IOCBs from the completions list */

/**

 * lpfc_fabric_abort_hba - Abort all iocbs on driver fabric iocb list

 * @phba: pointer to lpfc hba data structure.

 *

 * This routine aborts all the IOCBs currently on the driver internal

 * fabric IOCB list. The list contains fabric IOCBs to be issued to the ELS

 * IOCB ring. This function takes the entire IOCB list off the fabric IOCB

 * list, removes IOCBs off the list, set the status field to

 * IOSTAT_LOCAL_REJECT, and invokes the callback function associated with

 * the IOCB.

 Cancel all the IOCBs from the completions list */

/**

 * lpfc_sli4_vport_delete_els_xri_aborted -Remove all ndlp references for vport

 * @vport: pointer to lpfc vport data structure.

 *

 * This routine is invoked by the vport cleanup for deletions and the cleanup

 * for an ndlp on removal.

			/* If the xri on the abts_els_sgl list is for the Fport

			 * node and the vport is unloading, the xri aborted wcqe

			 * likely isn't coming back.  Just release the sgl.

/**

 * lpfc_sli4_els_xri_aborted - Slow-path process of els xri abort

 * @phba: pointer to lpfc hba data structure.

 * @axri: pointer to the els xri abort wcqe structure.

 *

 * This routine is invoked by the worker thread to process a SLI4 slow-path

 * ELS aborted xri.

 Check if TXQ queue needs to be serviced */

/* lpfc_sli_abts_recover_port - Recover a port that failed a BLS_ABORT req.

 * @vport: pointer to virtual port object.

 * @ndlp: nodelist pointer for the impacted node.

 *

 * The driver calls this routine in response to an SLI4 XRI ABORT CQE

 * or an SLI3 ASYNC_STATUS_CN event from the port.  For either event,

 * the driver is required to send a LOGO to the remote node before it

 * attempts to recover its login to the remote node.

	/*

	 * The rport is not responding.  Remove the FCP-2 flag to prevent

	 * an ADISC in the follow-up recovery code.

 Set IN USE flag */

/*******************************************************************

 * This file is part of the Emulex Linux Device Driver for         *

 * Fibre Channel Host Bus Adapters.                                *

 * Copyright (C) 2017-2021 Broadcom. All Rights Reserved. The term *

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.     *

 * Copyright (C) 2009-2015 Emulex.  All rights reserved.           *

 * EMULEX and SLI are trademarks of Emulex.                        *

 * www.broadcom.com                                                *

 *                                                                 *

 * This program is free software; you can redistribute it and/or   *

 * modify it under the terms of version 2 of the GNU General       *

 * Public License as published by the Free Software Foundation.    *

 * This program is distributed in the hope that it will be useful. *

 * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *

 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *

 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *

 * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *

 * TO BE LEGALLY INVALID.  See the GNU General Public License for  *

 * more details, a copy of which can be found in the file COPYING  *

 * included with this package.                                     *

 Event type and waiter identifiers */

 next two flags are here for the auto-delete logic */

 seen and not seen events */

 driver data associated with the job */

 for BIU diags */

 extended mailbox data */

 from app */

 from app */

 from app */

 job waiting for this iocb to finish */

 Verify we can support the size specified */

 Determine the number of dma buffers to allocate */

 Allocate dma buffer and place in BPL passed */

 Allocate dma buffer  */

 Queue it to a linked list */

 Add buffer to buffer pointer list */

 Continue previous partial transfer of sg */

/**

 * lpfc_bsg_send_mgmt_cmd_cmp - lpfc_bsg_send_mgmt_cmd's completion handler

 * @phba: Pointer to HBA context object.

 * @cmdiocbq: Pointer to command iocb.

 * @rspiocbq: Pointer to response iocb.

 *

 * This function is the completion handler for iocbs issued using

 * lpfc_bsg_send_mgmt_cmd function. This function is called by the

 * ring event handler function without any lock held. This function

 * can be called from both worker thread context and interrupt

 * context. This function also can be called from another thread which

 * cleans up the SLI layer objects.

 * This function copies the contents of the response iocb to the

 * response iocb memory object provided by the caller of

 * lpfc_sli_issue_iocb_wait and then wakes up the thread which

 * sleeps for the iocb completion.

 Determine if job has been aborted */

 Prevent timeout handling from trying to abort job */

 Close the timeout handler abort window */

 Copy the completed data or set the error status */

 Complete the job if the job is still active */

/**

 * lpfc_bsg_send_mgmt_cmd - send a CT command from a bsg request

 * @job: fc_bsg_job to handle

 in case no data is transferred */

 allocate our bsg tracking structure */

 flush */

 make sure the I/O had not been completed yet */

 open up abort window to timeout handler */

 done for now */

 iocb failed so cleanup */

 make error code available to userspace */

/**

 * lpfc_bsg_rport_els_cmp - lpfc_bsg_rport_els's completion handler

 * @phba: Pointer to HBA context object.

 * @cmdiocbq: Pointer to command iocb.

 * @rspiocbq: Pointer to response iocb.

 *

 * This function is the completion handler for iocbs issued using

 * lpfc_bsg_rport_els_cmp function. This function is called by the

 * ring event handler function without any lock held. This function

 * can be called from both worker thread context and interrupt

 * context. This function also can be called from other thread which

 * cleans up the SLI layer objects.

 * This function copies the contents of the response iocb to the

 * response iocb memory object provided by the caller of

 * lpfc_sli_issue_iocb_wait and then wakes up the thread which

 * sleeps for the iocb completion.

 Determine if job has been aborted */

 Prevent timeout handling from trying to abort job  */

 Close the timeout handler abort window */

	/* Copy the completed job data or determine the job status if job is

	 * still active

 LS_RJT data returned in word 4 */

 Complete the job if the job is still active */

/**

 * lpfc_bsg_rport_els - send an ELS command from a bsg request

 * @job: fc_bsg_job to handle

 in case no data is transferred */

	/* verify the els command is not greater than the

	 * maximum ELS transfer size.

 allocate our bsg tracking structure */

	/* We will use the allocated dma buffers by prep els iocb for command

	 * and response to ensure if the job times out and the request is freed,

	 * we won't be dma into memory that is no longer allocated to for the

	 * request.

 Transfer the request payload to allocated command dma buffer */

 flush */

 make sure the I/O had not been completed/released */

 open up abort window to timeout handler */

 done for now */

 I/O issue failed.  Cleanup resources. */

 make error code available to userspace */

/**

 * lpfc_bsg_event_free - frees an allocated event structure

 * @kref: Pointer to a kref.

 *

 * Called from kref_put. Back cast the kref into an event structure address.

 * Free any events to get, delete associated nodes, free any events to see,

 * free any data then free the event itself.

/**

 * lpfc_bsg_event_ref - increments the kref for an event

 * @evt: Pointer to an event structure.

/**

 * lpfc_bsg_event_unref - Uses kref_put to free an event structure

 * @evt: Pointer to an event structure.

/**

 * lpfc_bsg_event_new - allocate and initialize a event structure

 * @ev_mask: Mask of events.

 * @ev_reg_id: Event reg id.

 * @ev_req_id: Event request id.

/**

 * diag_cmd_data_free - Frees an lpfc dma buffer extension

 * @phba: Pointer to HBA context object.

 * @mlist: Pointer to an lpfc dma buffer extension.

/*

 * lpfc_bsg_ct_unsol_event - process an unsolicited CT command

 *

 * This function is called when an unsolicited CT command is received.  It

 * forwards the event to any processes registered to receive CT events.

 take accumulated byte count from the last iocbq */

 Provide warning for over-run of the ct_ctx array */

 make error code available to userspace */

 complete the job back to userspace */

/**

 * lpfc_bsg_ct_unsol_abort - handler ct abort to management plane

 * @phba: Pointer to HBA context object.

 * @dmabuf: pointer to a dmabuf that describes the FC sequence

 *

 * This function handles abort to the CT command toward management plane

 * for SLI4 port.

 *

 * If the pending context of a CT command to management plane present, clears

 * such context and returns 1 for handled; otherwise, it returns 0 indicating

 * no context exists.

/**

 * lpfc_bsg_hba_set_event - process a SET_EVENT bsg vendor command

 * @job: SET_EVENT fc_bsg_job

 no event waiting struct yet - first call */

 for unsolicited command */

 for fc transport timeout callback*/

 call job done later */

/**

 * lpfc_bsg_hba_get_event - process a GET_EVENT bsg vendor command

 * @job: GET_EVENT fc_bsg_job

	/* The app may continue to ask for event data until it gets

	 * an error indicating that there isn't anymore

/**

 * lpfc_issue_ct_rsp_cmp - lpfc_issue_ct_rsp's completion handler

 * @phba: Pointer to HBA context object.

 * @cmdiocbq: Pointer to command iocb.

 * @rspiocbq: Pointer to response iocb.

 *

 * This function is the completion handler for iocbs issued using

 * lpfc_issue_ct_rsp_cmp function. This function is called by the

 * ring event handler function without any lock held. This function

 * can be called from both worker thread context and interrupt

 * context. This function also can be called from other thread which

 * cleans up the SLI layer objects.

 * This function copy the contents of the response iocb to the

 * response iocb memory object provided by the caller of

 * lpfc_sli_issue_iocb_wait and then wakes up the thread which

 * sleeps for the iocb completion.

 Determine if job has been aborted */

 Prevent timeout handling from trying to abort job  */

 Close the timeout handler abort window */

 Copy the completed job data or set the error status */

 Complete the job if the job is still active */

/**

 * lpfc_issue_ct_rsp - issue a ct response

 * @phba: Pointer to HBA context object.

 * @job: Pointer to the job object.

 * @tag: tag index value into the ports context exchange array.

 * @cmp: Pointer to a cmp dma buffer descriptor.

 * @bmp: Pointer to a bmp dma buffer descriptor.

 * @num_entry: Number of enties in the bde.

 allocate our bsg tracking structure */

 Allocate buffer for  command iocb */

 Fill in rest of iocb */

 Do not issue unsol response if oxid not marked as valid */

		/* get a refernece count so the ndlp doesn't go away while

		 * we respond

 The exchange is done, mark the entry as invalid */

 Xmit CT response on exchange <xid> */

 flush */

 make sure the I/O had not been completed/released */

 open up abort window to timeout handler */

 done for now */

 iocb failed so cleanup */

/**

 * lpfc_bsg_send_mgmt_rsp - process a SEND_MGMT_RESP bsg vendor command

 * @job: SEND_MGMT_RESP fc_bsg_job

 in case no data is transferred */

 done for now */

 make error code available to userspace */

/**

 * lpfc_bsg_diag_mode_enter - process preparing into device diag loopback mode

 * @phba: Pointer to HBA context object.

 *

 * This function is responsible for preparing driver for diag loopback

 * on device.

/**

 * lpfc_bsg_diag_mode_exit - exit process from device diag loopback mode

 * @phba: Pointer to HBA context object.

 *

 * This function is responsible for driver exit processing of setting up

 * diag loopback mode on device.

/**

 * lpfc_sli3_bsg_diag_loopback_mode - process an sli3 bsg vendor command

 * @phba: Pointer to HBA context object.

 * @job: LPFC_BSG_VENDOR_DIAG_MODE

 *

 * This function is responsible for placing an sli3  port into diagnostic

 * loopback mode in order to perform a diagnostic loopback test.

 * All new scsi requests are blocked, a small delay is used to allow the

 * scsi requests to complete then the link is brought down. If the link is

 * is placed in loopback mode then scsi requests are again allowed

 * so the scsi mid-layer doesn't give up on the port.

 * All of this is done in-line.

 no data to return just the return code */

 bring the link to diagnostic mode */

 wait for link down before proceeding */

 wait for the link attention interrupt */

	/*

	 * Let SLI layer release mboxq if mbox command completed after timeout.

 make error code available to userspace */

 complete the job back to userspace if no error */

/**

 * lpfc_sli4_bsg_set_link_diag_state - set sli4 link diag state

 * @phba: Pointer to HBA context object.

 * @diag: Flag for set link to diag or nomral operation state.

 *

 * This function is responsible for issuing a sli4 mailbox command for setting

 * link to either diag state or normal operation state.

/**

 * lpfc_sli4_bsg_set_loopback_mode - set sli4 internal loopback diagnostic

 * @phba: Pointer to HBA context object.

 * @mode: loopback mode to set

 * @link_no: link number for loopback mode to set

 *

 * This function is responsible for issuing a sli4 mailbox command for setting

 * up loopback diagnostic for a link.

/**

 * lpfc_sli4_diag_fcport_reg_setup - setup port registrations for diagnostic

 * @phba: Pointer to HBA context object.

 *

 * This function set up SLI4 FC port registrations for diagnostic run, which

 * includes all the rpis, vfi, and also vpi.

/**

 * lpfc_sli4_bsg_diag_loopback_mode - process an sli4 bsg vendor command

 * @phba: Pointer to HBA context object.

 * @job: LPFC_BSG_VENDOR_DIAG_MODE

 *

 * This function is responsible for placing an sli4 port into diagnostic

 * loopback mode in order to perform a diagnostic loopback test.

 no data to return just the return code */

 Unset the need disable bit */

 Check if we need to disable the loopback state */

 indicate we are in loobpack diagnostic mode */

 reset port to start frome scratch */

 bring the link to diagnostic mode */

 wait for link down before proceeding */

 set up loopback mode */

 Trunk is configured, but link is not in this trunk */

 Set the need disable bit */

 Trunk is configured, but link is not in this trunk */

 Set the need disable bit */

 wait for the link attention interrupt */

 port resource registration setup for loopback diagnostic */

 set up a none zero myDID for loopback test */

 wait for the port ready */

 clear loopback diagnostic mode */

 make error code available to userspace */

 complete the job back to userspace if no error */

/**

 * lpfc_bsg_diag_loopback_mode - bsg vendor command for diag loopback mode

 * @job: LPFC_BSG_VENDOR_DIAG_MODE

 *

 * This function is responsible for responding to check and dispatch bsg diag

 * command from the user to proper driver action routines.

/**

 * lpfc_sli4_bsg_diag_mode_end - sli4 bsg vendor command for ending diag mode

 * @job: LPFC_BSG_VENDOR_DIAG_MODE_END

 *

 * This function is responsible for responding to check and dispatch bsg diag

 * command from the user to proper driver action routines.

 clear loopback diagnostic mode */

 wait for link down before proceeding */

 there is nothing much we can do here */

 reset port resource registrations */

 make return code available to userspace */

 complete the job back to userspace if no error */

/**

 * lpfc_sli4_bsg_link_diag_test - sli4 bsg vendor command for diag link test

 * @job: LPFC_BSG_VENDOR_DIAG_LINK_TEST

 *

 * This function is to perform SLI4 diag link test request from the user

 * applicaiton.

 make error code available to userspace */

 complete the job back to userspace if no error */

/**

 * lpfcdiag_loop_self_reg - obtains a remote port login id

 * @phba: Pointer to HBA context object

 * @rpi: Pointer to a remote port login id

 *

 * This function obtains a remote port login id so the diag loopback test

 * can send and receive its own unsolicited CT command.

/**

 * lpfcdiag_loop_self_unreg - unregs from the rpi

 * @phba: Pointer to HBA context object

 * @rpi: Remote port login id

 *

 * This function unregisters the rpi obtained in lpfcdiag_loop_self_reg

 Allocate mboxq structure */

/**

 * lpfcdiag_loop_get_xri - obtains the transmit and receive ids

 * @phba: Pointer to HBA context object

 * @rpi: Remote port login id

 * @txxri: Pointer to transmit exchange id

 * @rxxri: Pointer to response exchabge id

 *

 * This function obtains the transmit and receive ids required to send

 * an unsolicited ct command with a payload. A special lpfc FsType and CmdRsp

 * flags are used to the unsolicted response handler is able to process

 * the ct command sent on the same port.

 release ref */

 delete */

/**

 * lpfc_bsg_dma_page_alloc - allocate a bsg mbox page sized dma buffers

 * @phba: Pointer to HBA context object

 *

 * This function allocates BSG_MBOX_SIZE (4KB) page size dma buffer and

 * returns the pointer to the buffer.

 allocate dma buffer struct */

 now, allocate dma buffer */

/**

 * lpfc_bsg_dma_page_free - free a bsg mbox page sized dma buffer

 * @phba: Pointer to HBA context object.

 * @dmabuf: Pointer to the bsg mbox page sized dma buffer descriptor.

 *

 * This routine just simply frees a dma buffer and its associated buffer

 * descriptor referred by @dmabuf.

/**

 * lpfc_bsg_dma_page_list_free - free a list of bsg mbox page sized dma buffers

 * @phba: Pointer to HBA context object.

 * @dmabuf_list: Pointer to a list of bsg mbox page sized dma buffer descs.

 *

 * This routine just simply frees all dma buffers and their associated buffer

 * descriptors referred by @dmabuf_list.

/**

 * diag_cmd_data_alloc - fills in a bde struct with dma buffers

 * @phba: Pointer to HBA context object

 * @bpl: Pointer to 64 bit bde structure

 * @size: Number of bytes to process

 * @nocopydata: Flag to copy user data into the allocated buffer

 *

 * This function allocates page size buffers and populates an lpfc_dmabufext.

 * If allowed the user data pointed to with indataptr is copied into the kernel

 * memory. The chained list of page size buffers is returned.

 We get chunks of 4K */

 allocate struct lpfc_dmabufext buffer header */

 Queue it to a linked list */

 allocate buffer */

 build buffer ptr list for IOCB */

/**

 * lpfcdiag_loop_post_rxbufs - post the receive buffers for an unsol CT cmd

 * @phba: Pointer to HBA context object

 * @rxxri: Receive exchange id

 * @len: Number of data bytes

 *

 * This function allocates and posts a data buffer of sufficient size to receive

 * an unsolicted CT command.

 Queue buffers for the receive exchange */

 The iocb was freed by lpfc_sli_issue_iocb */

/**

 * lpfc_bsg_diag_loopback_run - run loopback on a port by issue ct cmd to itself

 * @job: LPFC_BSG_VENDOR_DIAG_TEST fc_bsg_job

 *

 * This function receives a user data buffer to be transmitted and received on

 * the same port, the link must be up and in loopback mode prior

 * to being called.

 * 1. A kernel buffer is allocated to copy the user data into.

 * 2. The port registers with "itself".

 * 3. The transmit and receive exchange ids are obtained.

 * 4. The receive exchange id is posted.

 * 5. A new els loopback event is created.

 * 6. The command and response iocbs are allocated.

 * 7. The cmd iocb FsType is set to elx loopback and the CmdRsp to looppback.

 *

 * This function is meant to be called n times while the port is in loopback

 * so it is the apps responsibility to issue a reset to take the port out

 * of loopback mode.

 in case no data is returned return just the return code */

 plus the header */

		/*

		 * Allocate memory for ioctl data. If buffer is bigger than 64k,

		 * then we allocate 64k and re-use that buffer over and over to

		 * xfer the whole block. This is because Linux kernel has a

		 * problem allocating more than 120k of kernel space memory. Saw

		 * problem with GET_FCPTARGETMAPPING...

 Allocate memory for ioctl data */

 Build the XMIT_SEQUENCE iocb */

 skip over elx loopback header */

 release ref */

 delete */

 make error code available to userspace */

 complete the job back to userspace if no error */

/**

 * lpfc_bsg_get_dfc_rev - process a GET_DFC_REV bsg vendor command

 * @job: GET_DFC_REV fc_bsg_job

/**

 * lpfc_bsg_issue_mbox_cmpl - lpfc_bsg_issue_mbox mbox completion handler

 * @phba: Pointer to HBA context object.

 * @pmboxq: Pointer to mailbox command.

 *

 * This is completion handler function for mailbox commands issued from

 * lpfc_bsg_issue_mbox function. This function is called by the

 * mailbox event handler function with no lock held. This function

 * will wake up thread waiting on the wait queue pointed by context1

 * of the mailbox.

	/*

	 * The outgoing buffer is readily referred from the dma buffer,

	 * just need to get header part from mailboxq structure.

 Determine if job has been aborted */

 Prevent timeout handling from trying to abort job  */

 Copy the mailbox data to the job if it is still active */

 Complete the job if the job is still active */

/**

 * lpfc_bsg_check_cmd_access - test for a supported mailbox command

 * @phba: Pointer to HBA context object.

 * @mb: Pointer to a mailbox object.

 * @vport: Pointer to a vport object.

 *

 * Some commands require the port to be offline, some may not be called from

 * the application.

 return negative error values for bsg job */

 Offline only */

 ok */

/**

 * lpfc_bsg_mbox_ext_session_reset - clean up context of multi-buffer mbox session

 * @phba: Pointer to HBA context object.

 *

 * This is routine clean up and reset BSG handling of multi-buffer mbox

 * command session.

 free all memory, including dma buffers */

 multi-buffer write mailbox command pass-through complete */

/**

 * lpfc_bsg_issue_mbox_ext_handle_job - job handler for multi-buffer mbox cmpl

 * @phba: Pointer to HBA context object.

 * @pmboxq: Pointer to mailbox command.

 *

 * This is routine handles BSG job for mailbox commands completions with

 * multiple external buffers.

 Determine if job has been aborted */

 Prevent timeout handling from trying to abort job  */

	/*

	 * The outgoing buffer is readily referred from the dma buffer,

	 * just need to get header part from mailboxq structure.

 Copy the byte swapped response mailbox back to the user */

 if there is any non-embedded extended data copy that too */

 byte swap the extended data following the mailbox command */

 Complete the job if the job is still active */

 result for successful */

 state change */

/**

 * lpfc_bsg_issue_read_mbox_ext_cmpl - compl handler for multi-buffer read mbox

 * @phba: Pointer to HBA context object.

 * @pmboxq: Pointer to mailbox command.

 *

 * This is completion handler function for mailbox read commands with multiple

 * external buffers.

 handle the BSG job with mailbox command */

 free base driver mailbox structure memory */

 if the job is still active, call job done */

/**

 * lpfc_bsg_issue_write_mbox_ext_cmpl - cmpl handler for multi-buffer write mbox

 * @phba: Pointer to HBA context object.

 * @pmboxq: Pointer to mailbox command.

 *

 * This is completion handler function for mailbox write commands with multiple

 * external buffers.

 handle the BSG job with the mailbox command */

 free all memory, including dma buffers */

 if the job is still active, call job done */

 pointer to the start of mailbox command */

/**

 * lpfc_bsg_sli_cfg_read_cmd_ext - sli_config non-embedded mailbox cmd read

 * @phba: Pointer to HBA context object.

 * @job: Pointer to the job object.

 * @nemb_tp: Enumerate of non-embedded mailbox command type.

 * @dmabuf: Pointer to a DMA buffer descriptor.

 *

 * This routine performs SLI_CONFIG (0x9B) read mailbox command operation with

 * non-embedded external buffers.

 pointer to the start of mailbox command */

 sanity check on interface type for support */

 nemb_tp == nemb_hbd */

 before dma descriptor setup */

 reject non-embedded mailbox command with none external buffer */

 additional external read buffers */

 bsg tracking structure */

 mailbox command structure for base driver */

 for the first external buffer */

 for the rest of external buffer descriptors if any */

 after dma descriptor setup */

 construct base driver mbox command */

 multi-buffer handling context */

 callback for multi-buffer read mailbox command */

 context fields to callback function */

 state change */

	/*

	 * Non-embedded mailbox subcommand data gets byte swapped here because

	 * the lower level driver code only does the first 64 mailbox words.

/**

 * lpfc_bsg_sli_cfg_write_cmd_ext - sli_config non-embedded mailbox cmd write

 * @phba: Pointer to HBA context object.

 * @job: Pointer to the job object.

 * @nemb_tp: Enumerate of non-embedded mailbox command type.

 * @dmabuf: Pointer to a DMA buffer descriptor.

 *

 * This routine performs SLI_CONFIG (0x9B) write mailbox command operation with

 * non-embedded external buffers.

 pointer to the start of mailbox command */

 sanity check on interface type for support */

 nemb_tp == nemb_hbd */

 before dma buffer descriptor setup */

 for the first external buffer */

 after dma descriptor setup */

 log for looking forward */

 multi-buffer handling context */

 bsg tracking structure */

 mailbox command structure for base driver */

 callback for multi-buffer read mailbox command */

 context fields to callback function */

 state change */

 wait for additional external buffers */

/**

 * lpfc_bsg_handle_sli_cfg_mbox - handle sli-cfg mailbox cmd with ext buffer

 * @phba: Pointer to HBA context object.

 * @job: Pointer to the job object.

 * @dmabuf: Pointer to a DMA buffer descriptor.

 *

 * This routine handles SLI_CONFIG (0x9B) mailbox command with non-embedded

 * external buffers, including both 0x9B with non-embedded MSEs and 0x9B

 * with embedded subsystem 0x1 and opcodes with external HBDs.

 state change on new multi-buffer pass-through mailbox command */

 state reset on not handled new multi-buffer mailbox command */

/**

 * lpfc_bsg_mbox_ext_abort - request to abort mbox command with ext buffers

 * @phba: Pointer to HBA context object.

 *

 * This routine is for requesting to abort a pass-through mailbox command with

 * multiple external buffers due to error condition.

/**

 * lpfc_bsg_read_ebuf_get - get the next mailbox read external buffer

 * @phba: Pointer to HBA context object.

 * @job: Pointer to the job object.

 *

 * This routine extracts the next mailbox read external buffer back to

 * user space through BSG.

 after dma buffer descriptor setup */

/**

 * lpfc_bsg_write_ebuf_set - set the next mailbox write external buffer

 * @phba: Pointer to HBA context object.

 * @job: Pointer to the job object.

 * @dmabuf: Pointer to a DMA buffer descriptor.

 *

 * This routine sets up the next mailbox read external buffer obtained

 * from user space through BSG.

 set up external buffer descriptor and add to external buffer list */

 after write dma buffer */

 mailbox command structure for base driver */

 callback for multi-buffer write mailbox command */

 context fields to callback function */

 state change */

 wait for additional external buffers */

/**

 * lpfc_bsg_handle_sli_cfg_ebuf - handle ext buffer with sli-cfg mailbox cmd

 * @phba: Pointer to HBA context object.

 * @job: Pointer to the job object.

 * @dmabuf: Pointer to a DMA buffer descriptor.

 *

 * This routine handles the external buffer with SLI_CONFIG (0x9B) mailbox

 * command with multiple non-embedded external buffers.

 phba->mbox_ext_buf_ctx.mboxType == mbox_wr */

/**

 * lpfc_bsg_handle_sli_cfg_ext - handle sli-cfg mailbox with external buffer

 * @phba: Pointer to HBA context object.

 * @job: Pointer to the job object.

 * @dmabuf: Pointer to a DMA buffer descriptor.

 *

 * This routine checks and handles non-embedded multi-buffer SLI_CONFIG

 * (0x9B) mailbox commands and external buffers.

 mbox command with/without single external buffer */

 mbox command and first external buffer */

	/*

	 * handle additional external buffers

 check broken pipe conditions */

 all other cases, broken pipe */

/**

 * lpfc_bsg_issue_mbox - issues a mailbox command on behalf of an app

 * @phba: Pointer to HBA context object.

 * @job: Pointer to the job object.

 * @vport: Pointer to a vport object.

 *

 * Allocate a tracking object, mailbox command memory, get a mailbox

 * from the mailbox pool, copy the caller mailbox command.

 *

 * If offline and the sli is active we need to poll for the command (port is

 * being reset) and complete the job, otherwise issue the mailbox command and

 * let our completion handler finish the command.

 internal mailbox queue */

 shortcut to the pmboxq mailbox */

 a 4k buffer to hold the mb and extended data from/to the bsg */

 bsg data tracking structure */

 in case no data is transferred */

 sanity check to protect driver */

	/*

	 * Don't allow mailbox commands to be sent when blocked or when in

	 * the middle of discovery

 check if requested extended data lengths are valid */

 Get the mailbox command or external buffer from BSG */

 Handle possible SLI_CONFIG with non-embedded payloads */

 SLI_CONFIG_NOT_HANDLED for other mailbox commands */

 must be negative */

 allocate our bsg tracking structure */

	/* If HBA encountered an error attention, allow only DUMP

	 * or RESTART mailbox commands until the HBA is restarted.

 extended mailbox commands will need an extended buffer */

	/* biu diag will need a kernel buffer to transfer the data

	 * allocate our own buffer and setup the mailbox command to

	 * use ours

		/* transmit length cannot be greater than receive length or

		 * mailbox extension size

		/* receive length cannot be greater than mailbox

		 * extension size

 mode zero uses a bde like biu diags command */

		/* Let type 4 (well known data) through because the data is

		 * returned in varwords[4-8]

		 * otherwise check the recieve length and fetch the buffer addr

			/* rebuild the command for sli4 using our own buffers

			* like we do for biu diags

			/* receive length cannot be greater than mailbox

			 * extension size

 bde size cannot be greater than mailbox ext size */

 Handling non-embedded SLI_CONFIG mailbox command */

				/* rebuild the command for sli4 using our

				 * own buffers like we do for biu diags

				/* receive length cannot be greater than

				 * mailbox extension size

 setup wake call as IOCB callback */

 setup context field to pass wait_queue pointer to wake function */

 job finished, copy the data */

 not waiting mbox already done */

 job started */

 common exit for error or job completed inline */

/**

 * lpfc_bsg_mbox_cmd - process an fc bsg LPFC_BSG_VENDOR_MBOX command

 * @job: MBOX fc_bsg_job for LPFC_BSG_VENDOR_MBOX.

 mix-and-match backward compatibility */

 job done */

 job submitted, will complete later*/

 return zero, no error */

 some error occurred */

/**

 * lpfc_bsg_menlo_cmd_cmp - lpfc_menlo_cmd completion handler

 * @phba: Pointer to HBA context object.

 * @cmdiocbq: Pointer to command iocb.

 * @rspiocbq: Pointer to response iocb.

 *

 * This function is the completion handler for iocbs issued using

 * lpfc_menlo_cmd function. This function is called by the

 * ring event handler function without any lock held. This function

 * can be called from both worker thread context and interrupt

 * context. This function also can be called from another thread which

 * cleans up the SLI layer objects.

 * This function copies the contents of the response iocb to the

 * response iocb memory object provided by the caller of

 * lpfc_sli_issue_iocb_wait and then wakes up the thread which

 * sleeps for the iocb completion.

 Determine if job has been aborted */

 Prevent timeout handling from trying to abort job  */

 Copy the job data or set the failing status for the job */

		/* always return the xri, this would be used in the case

		 * of a menlo download to allow the data to be sent as a

		 * continuation of the exchange.

 Complete the job if active */

/**

 * lpfc_menlo_cmd - send an ioctl for menlo hardware

 * @job: fc_bsg_job to handle

 *

 * This function issues a gen request 64 CR ioctl for all menlo cmd requests,

 * all the command completions will return the xri for the command.

 * For menlo data requests a gen request 64 CX is used to continue the exchange

 * supplied in the menlo request header xri field.

 in case no data is returned return just the return code */

 allocate our bsg tracking structure */

 0xfe */

 Limited Edition */

 We want the firmware to timeout before we do */

 3 */

 0x0000FC0E */

 0 */

 done for now */

 make error code available to userspace */

/**

 * lpfc_check_fwlog_support: Check FW log support on the adapter

 * @phba: Pointer to HBA context object.

 *

 * Check if FW Logging support by the adapter

/**

 * lpfc_bsg_get_ras_config: Get RAS configuration settings

 * @job: fc_bsg_job to handle

 *

 * Get RAS configuration values set.

 Check FW log status */

 Current logging state */

 make error code available to userspace */

 complete the job back to userspace */

/**

 * lpfc_bsg_set_ras_config: Set FW logging parameters

 * @job: fc_bsg_job to handle

 *

 * Set log-level parameters for FW-logging in host memory

 Check FW log status */

 Check if already disabled */

 Disable logging */

action = LPFC_RASACTION_START_LOGGING*/

		/* Even though FW-logging is active re-initialize

		 * FW-logging with new log-level. Return status

		 * "Logging already Running" to caller.

 Enable logging */

 Check if FW-logging is re-initialized */

 make error code available to userspace */

 complete the job back to userspace */

/**

 * lpfc_bsg_get_ras_lwpd: Get log write position data

 * @job: fc_bsg_job to handle

 *

 * Get Offset/Wrap count of the log message written

 * in host memory

 Get lwpd offset */

 Get wrap count */

 make error code available to userspace */

 complete the job back to userspace */

/**

 * lpfc_bsg_get_ras_fwlog: Read FW log

 * @job: fc_bsg_job to handle

 *

 * Copy the FW log into the passed buffer.

 Logging to be stopped before reading */

 Allocate memory to read fw log*/

 For reset or size == 0 */

 We don't want to include the CRC at the end */

 Just copy back what we can */

 Allocate memory to read congestion info */

/**

 * lpfc_bsg_hst_vendor - process a vendor-specific fc_bsg_job

 * @job: fc_bsg_job to handle

 make error code available to userspace */

/**

 * lpfc_bsg_request - handle a bsg request from the FC transport

 * @job: bsg_job to handle

 make error code available to userspace */

/**

 * lpfc_bsg_timeout - handle timeout of a bsg request from the FC transport

 * @job: bsg_job that has timed out

 *

 * This function just aborts the job's IOCB.  The aborted IOCB will return to

 * the waiting function which will handle passing the error back to userspace

	/* if job's driver data is NULL, the command completed or is in the

	 * the process of completing.  In this case, return status to request

	 * so the timeout is retried.  This avoids double completion issues

	 * and the request will be pulled off the timer queue when the

	 * command's completion handler executes.  Otherwise, prevent the

	 * command's completion handler from executing the job done callback

	 * and continue processing to abort the outstanding the command.

		/* Check to see if IOCB was issued to the port or not. If not,

		 * remove it from the txq queue and call cancel iocbs.

		 * Otherwise, call abort iotag

 make sure the I/O abort window is still open */

 Update the ext buf ctx state if needed */

		/* Check to see if IOCB was issued to the port or not. If not,

		 * remove it from the txq queue and call cancel iocbs.

		 * Otherwise, call abort iotag.

	/* scsi transport fc fc_bsg_job_timeout expects a zero return code,

	 * otherwise an error message will be displayed on the console

	 * so always return success (zero)

/*******************************************************************

 * This file is part of the Emulex Linux Device Driver for         *

 * Fibre Channel Host Bus Adapters.                                *

 * Copyright (C) 2017-2021 Broadcom. All Rights Reserved. The term *

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.  *

 * Copyright (C) 2004-2016 Emulex.  All rights reserved.           *

 * EMULEX and SLI are trademarks of Emulex.                        *

 * www.broadcom.com                                                *

 * Portions Copyright (C) 2004-2005 Christoph Hellwig              *

 *                                                                 *

 * This program is free software; you can redistribute it and/or   *

 * modify it under the terms of version 2 of the GNU General       *

 * Public License as published by the Free Software Foundation.    *

 * This program is distributed in the hope that it will be useful. *

 * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *

 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *

 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *

 * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *

 * TO BE LEGALLY INVALID.  See the GNU General Public License for  *

 * more details, a copy of which can be found in the file COPYING  *

 * included with this package.                                     *

/*

 * Write key size should be multiple of 4. If write key is changed

 * make sure that library write key is also changed.

 map errcode */

 There is no such error code at index 0*/

/**

 * lpfc_jedec_to_ascii - Hex to ascii convertor according to JEDEC rules

 * @incr: integer to convert.

 * @hdw: ascii string holding converted integer plus a string terminator.

 *

 * Description:

 * JEDEC Joint Electron Device Engineering Council.

 * Convert a 32 bit integer composed of 8 nibbles into an 8 byte ascii

 * character string. The string is then terminated with a NULL in byte 9.

 * Hex 0-9 becomes ascii '0' to '9'.

 * Hex a-f becomes ascii '=' to 'B' capital B.

 *

 * Notes:

 * Coded for 32 bit integers only.

/**

 * lpfc_drvr_version_show - Return the Emulex driver string with version number

 * @dev: class unused variable.

 * @attr: device attribute, not used.

 * @buf: on return contains the module description text.

 *

 * Returns: size of formatted string.

/**

 * lpfc_enable_fip_show - Return the fip mode of the HBA

 * @dev: class unused variable.

 * @attr: device attribute, not used.

 * @buf: on return contains the module description text.

 *

 * Returns: size of formatted string.

 Port state is only one of two values for now. */

 Calculate outstanding IOs */

 Port state is only one of two values for now. */

 Port state is only one of two values for now. */

 Tab in to show lport ownership. */

 An NVME rport can have multiple roles. */

 host_lock is already unlocked. */

/**

 * lpfc_info_show - Return some pci info about the host in ascii

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains the formatted text from lpfc_info().

 *

 * Returns: size of formatted string.

/**

 * lpfc_serialnum_show - Return the hba serial number in ascii

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains the formatted text serial number.

 *

 * Returns: size of formatted string.

/**

 * lpfc_temp_sensor_show - Return the temperature sensor level

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains the formatted support level.

 *

 * Description:

 * Returns a number indicating the temperature sensor level currently

 * supported, zero or one in ascii.

 *

 * Returns: size of formatted string.

/**

 * lpfc_modeldesc_show - Return the model description of the hba

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains the scsi vpd model description.

 *

 * Returns: size of formatted string.

/**

 * lpfc_modelname_show - Return the model name of the hba

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains the scsi vpd model name.

 *

 * Returns: size of formatted string.

/**

 * lpfc_programtype_show - Return the program type of the hba

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains the scsi vpd program type.

 *

 * Returns: size of formatted string.

/**

 * lpfc_mlomgmt_show - Return the Menlo Maintenance sli flag

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains the Menlo Maintenance sli flag.

 *

 * Returns: size of formatted string.

/**

 * lpfc_vportnum_show - Return the port number in ascii of the hba

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains scsi vpd program type.

 *

 * Returns: size of formatted string.

/**

 * lpfc_fwrev_show - Return the firmware rev running in the hba

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains the scsi vpd program type.

 *

 * Returns: size of formatted string.

/**

 * lpfc_hdw_show - Return the jedec information about the hba

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains the scsi vpd program type.

 *

 * Returns: size of formatted string.

/**

 * lpfc_option_rom_version_show - Return the adapter ROM FCode version

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains the ROM and FCode ascii strings.

 *

 * Returns: size of formatted string.

/**

 * lpfc_link_state_show - Return the link state of the port

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains text describing the state of the link.

 *

 * Notes:

 * The switch statement has no default so zero will be returned.

 *

 * Returns: size of formatted string.

/**

 * lpfc_sli4_protocol_show - Return the fip mode of the HBA

 * @dev: class unused variable.

 * @attr: device attribute, not used.

 * @buf: on return contains the module description text.

 *

 * Returns: size of formatted string.

/**

 * lpfc_oas_supported_show - Return whether or not Optimized Access Storage

 *			    (OAS) is supported.

 * @dev: class unused variable.

 * @attr: device attribute, not used.

 * @buf: on return contains the module description text.

 *

 * Returns: size of formatted string.

/**

 * lpfc_link_state_store - Transition the link_state on an HBA port

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: one or more lpfc_polling_flags values.

 * @count: not used.

 *

 * Returns:

 * -EINVAL if the buffer is not "up" or "down"

 * return from link state change function if non-zero

 * length of the buf on success

/**

 * lpfc_num_discovered_ports_show - Return sum of mapped and unmapped vports

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: on return contains the sum of fc mapped and unmapped.

 *

 * Description:

 * Returns the ascii text number of the sum of the fc mapped and unmapped

 * vport counts.

 *

 * Returns: size of formatted string.

/**

 * lpfc_issue_lip - Misnomer, name carried over from long ago

 * @shost: Scsi_Host pointer.

 *

 * Description:

 * Bring the link down gracefully then re-init the link. The firmware will

 * re-init the fiber channel interface as required. Does not issue a LIP.

 *

 * Returns:

 * -EPERM port offline or management commands are being blocked

 * -ENOMEM cannot allocate memory for the mailbox command

 * -EIO error sending the mailbox command

 * zero for success

	/*

	 * If the link is offline, disabled or BLOCK_MGMT_IO

	 * it doesn't make any sense to allow issue_lip

 5 secs */

/**

 * lpfc_do_offline - Issues a mailbox command to bring the link down

 * @phba: lpfc_hba pointer.

 * @type: LPFC_EVT_OFFLINE, LPFC_EVT_WARM_START, LPFC_EVT_KILL.

 *

 * Notes:

 * Assumes any error from lpfc_do_offline() will be negative.

 * Can wait up to 5 seconds for the port ring buffers count

 * to reach zero, prints a warning if it is not zero and continues.

 * lpfc_workq_post_event() returns a non-zero return code if call fails.

 *

 * Returns:

 * -EIO error posting the event

 * zero for success

	/*

	 * If freeing the queues have already started, don't access them.

	 * Otherwise set FREE_WAIT to indicate that queues are being used

	 * to hold the freeing process until we finish.

	/* Wait a little for things to settle down, but not

	 * long enough for dev loss timeout to expire.

/**

 * lpfc_reset_pci_bus - resets PCI bridge controller's secondary bus of an HBA

 * @phba: lpfc_hba pointer.

 *

 * Description:

 * Issues a PCI secondary bus reset for the phba->pcidev.

 *

 * Notes:

 * First walks the bus_list to ensure only PCI devices with Emulex

 * vendor id, device ids that support hot reset, only one occurrence

 * of function 0, and all ports on the bus are in offline mode to ensure the

 * hot reset only affects one valid HBA.

 *

 * Returns:

 * -ENOTSUPP, cfg_enable_hba_reset must be of value 2

 * -ENODEV,   NULL ptr to pcidev

 * -EBADSLT,  detected invalid device

 * -EBUSY,    port is not in offline state

 *      0,    successful

 Walk the list of devices on the pci_dev's bus */

 Check port is offline */

 Issue PCI bus reset */

/**

 * lpfc_selective_reset - Offline then onlines the port

 * @phba: lpfc_hba pointer.

 *

 * Description:

 * If the port is configured to allow a reset then the hba is brought

 * offline then online.

 *

 * Notes:

 * Assumes any error from lpfc_do_offline() will be negative.

 * Do not make this function static.

 *

 * Returns:

 * lpfc_do_offline() return code if not zero

 * -EIO reset not configured or error posting the event

 * zero for success

/**

 * lpfc_issue_reset - Selectively resets an adapter

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: containing the string "selective".

 * @count: unused variable.

 *

 * Description:

 * If the buf contains the string "selective" then lpfc_selective_reset()

 * is called to perform the reset.

 *

 * Notes:

 * Assumes any error from lpfc_selective_reset() will be negative.

 * If lpfc_selective_reset() returns zero then the length of the buffer

 * is returned which indicates success

 *

 * Returns:

 * -EINVAL if the buffer does not contain the string "selective"

 * length of buf if lpfc-selective_reset() if the call succeeds

 * return value of lpfc_selective_reset() if the call fails

/**

 * lpfc_sli4_pdev_status_reg_wait - Wait for pdev status register for readyness

 * @phba: lpfc_hba pointer.

 *

 * Description:

 * SLI4 interface type-2 device to wait on the sliport status register for

 * the readyness after performing a firmware reset.

 *

 * Returns:

 * zero for success, -EPERM when port does not have privilege to perform the

 * reset, -EIO when port timeout from recovering from the reset.

 *

 * Note:

 * As the caller will interpret the return code by value, be careful in making

 * change or addition to return codes.

 verify if privileged for the request operation */

 wait for the SLI port firmware ready after firmware reset */

/**

 * lpfc_sli4_pdev_reg_request - Request physical dev to perform a register acc

 * @phba: lpfc_hba pointer.

 * @opcode: The sli4 config command opcode.

 *

 * Description:

 * Request SLI4 interface type-2 device to perform a physical register set

 * access.

 *

 * Returns:

 * zero for success

 Keep state if we need to restore back */

 Disable SR-IOV virtual functions if enabled */

 wait for the device to be quiesced before firmware reset */

 flush */

 delay driver action following IF_TYPE_2 reset */

 no privilege for reset */

 reset failed, there is nothing more we can do */

 keep the original port state */

 in any case, restore the virtual functions enabled as before */

 return proper error code */

/**

 * lpfc_nport_evt_cnt_show - Return the number of nport events

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: on return contains the ascii number of nport events.

 *

 * Returns: size of formatted string.

 Invalid  number */

 Invalid command */

 Disable */

 Enable two port trunk */

 Enable four port trunk */

/**

 * lpfc_board_mode_show - Return the state of the board

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: on return contains the state of the adapter.

 *

 * Returns: size of formatted string.

/**

 * lpfc_board_mode_store - Puts the hba in online, offline, warm or error state

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: containing one of the strings "online", "offline", "warm" or "error".

 * @count: unused variable.

 *

 * Returns:

 * -EACCES if enable hba reset not enabled

 * -EINVAL if the buffer does not contain a valid string (see above)

 * -EIO if lpfc_workq_post_event() or lpfc_do_offline() fails

 * buf length greater than zero indicates success

/**

 * lpfc_get_hba_info - Return various bits of informaton about the adapter

 * @phba: pointer to the adapter structure.

 * @mxri: max xri count.

 * @axri: available xri count.

 * @mrpi: max rpi count.

 * @arpi: available rpi count.

 * @mvpi: max vpi count.

 * @avpi: available vpi count.

 *

 * Description:

 * If an integer pointer for an count is not null then the value for the

 * count is returned.

 *

 * Returns:

 * zero on error

 * one for success

	/*

	 * prevent udev from issuing mailbox commands until the port is

	 * configured.

		/* Account for differences with SLI-3.  Get vpi count from

		 * mailbox data and subtract one for max vpi value.

 Limit the max we support */

 avail_vpi is only valid if link is up and ready */

/**

 * lpfc_max_rpi_show - Return maximum rpi

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: on return contains the maximum rpi count in decimal or "Unknown".

 *

 * Description:

 * Calls lpfc_get_hba_info() asking for just the mrpi count.

 * If lpfc_get_hba_info() returns zero (failure) the buffer text is set

 * to "Unknown" and the buffer length is returned, therefore the caller

 * must check for "Unknown" in the buffer to detect a failure.

 *

 * Returns: size of formatted string.

/**

 * lpfc_used_rpi_show - Return maximum rpi minus available rpi

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: containing the used rpi count in decimal or "Unknown".

 *

 * Description:

 * Calls lpfc_get_hba_info() asking for just the mrpi and arpi counts.

 * If lpfc_get_hba_info() returns zero (failure) the buffer text is set

 * to "Unknown" and the buffer length is returned, therefore the caller

 * must check for "Unknown" in the buffer to detect a failure.

 *

 * Returns: size of formatted string.

/**

 * lpfc_max_xri_show - Return maximum xri

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: on return contains the maximum xri count in decimal or "Unknown".

 *

 * Description:

 * Calls lpfc_get_hba_info() asking for just the mrpi count.

 * If lpfc_get_hba_info() returns zero (failure) the buffer text is set

 * to "Unknown" and the buffer length is returned, therefore the caller

 * must check for "Unknown" in the buffer to detect a failure.

 *

 * Returns: size of formatted string.

/**

 * lpfc_used_xri_show - Return maximum xpi minus the available xpi

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: on return contains the used xri count in decimal or "Unknown".

 *

 * Description:

 * Calls lpfc_get_hba_info() asking for just the mxri and axri counts.

 * If lpfc_get_hba_info() returns zero (failure) the buffer text is set

 * to "Unknown" and the buffer length is returned, therefore the caller

 * must check for "Unknown" in the buffer to detect a failure.

 *

 * Returns: size of formatted string.

/**

 * lpfc_max_vpi_show - Return maximum vpi

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: on return contains the maximum vpi count in decimal or "Unknown".

 *

 * Description:

 * Calls lpfc_get_hba_info() asking for just the mvpi count.

 * If lpfc_get_hba_info() returns zero (failure) the buffer text is set

 * to "Unknown" and the buffer length is returned, therefore the caller

 * must check for "Unknown" in the buffer to detect a failure.

 *

 * Returns: size of formatted string.

/**

 * lpfc_used_vpi_show - Return maximum vpi minus the available vpi

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: on return contains the used vpi count in decimal or "Unknown".

 *

 * Description:

 * Calls lpfc_get_hba_info() asking for just the mvpi and avpi counts.

 * If lpfc_get_hba_info() returns zero (failure) the buffer text is set

 * to "Unknown" and the buffer length is returned, therefore the caller

 * must check for "Unknown" in the buffer to detect a failure.

 *

 * Returns: size of formatted string.

/**

 * lpfc_npiv_info_show - Return text about NPIV support for the adapter

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: text that must be interpreted to determine if npiv is supported.

 *

 * Description:

 * Buffer will contain text indicating npiv is not suppoerted on the port,

 * the port is an NPIV physical port, or it is an npiv virtual port with

 * the id of the vport.

 *

 * Returns: size of formatted string.

/**

 * lpfc_poll_show - Return text about poll support for the adapter

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: on return contains the cfg_poll in hex.

 *

 * Notes:

 * cfg_poll should be a lpfc_polling_flags type.

 *

 * Returns: size of formatted string.

/**

 * lpfc_poll_store - Set the value of cfg_poll for the adapter

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: one or more lpfc_polling_flags values.

 * @count: not used.

 *

 * Notes:

 * buf contents converted to integer and checked for a valid value.

 *

 * Returns:

 * -EINVAL if the buffer connot be converted or is out of range

 * length of the buf on success

 flush */

 flush */

/**

 * lpfc_sriov_hw_max_virtfn_show - Return maximum number of virtual functions

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains the formatted support level.

 *

 * Description:

 * Returns the maximum number of virtual functions a physical function can

 * support, 0 will be returned if called on virtual function.

 *

 * Returns: size of formatted string.

/**

 * lpfc_enable_bbcr_set: Sets an attribute value.

 * @phba: pointer the the adapter structure.

 * @val: integer attribute value.

 *

 * Description:

 * Validates the min and max values then sets the

 * adapter config field if in the valid range. prints error message

 * and does not set the parameter if invalid.

 *

 * Returns:

 * zero on success

 * -EINVAL if val is invalid

/*

 * lpfc_param_show - Return a cfg attribute value in decimal

 *

 * Description:

 * Macro that given an attr e.g. hba_queue_depth expands

 * into a function with the name lpfc_hba_queue_depth_show.

 *

 * lpfc_##attr##_show: Return the decimal value of an adapters cfg_xxx field.

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: on return contains the attribute value in decimal.

 *

 * Returns: size of formatted string.

/*

 * lpfc_param_hex_show - Return a cfg attribute value in hex

 *

 * Description:

 * Macro that given an attr e.g. hba_queue_depth expands

 * into a function with the name lpfc_hba_queue_depth_show

 *

 * lpfc_##attr##_show: Return the hex value of an adapters cfg_xxx field.

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: on return contains the attribute value in hexadecimal.

 *

 * Returns: size of formatted string.

/*

 * lpfc_param_init - Initializes a cfg attribute

 *

 * Description:

 * Macro that given an attr e.g. hba_queue_depth expands

 * into a function with the name lpfc_hba_queue_depth_init. The macro also

 * takes a default argument, a minimum and maximum argument.

 *

 * lpfc_##attr##_init: Initializes an attribute.

 * @phba: pointer the the adapter structure.

 * @val: integer attribute value.

 *

 * Validates the min and max values then sets the adapter config field

 * accordingly, or uses the default if out of range and prints an error message.

 *

 * Returns:

 * zero on success

 * -EINVAL if default used

/*

 * lpfc_param_set - Set a cfg attribute value

 *

 * Description:

 * Macro that given an attr e.g. hba_queue_depth expands

 * into a function with the name lpfc_hba_queue_depth_set

 *

 * lpfc_##attr##_set: Sets an attribute value.

 * @phba: pointer the the adapter structure.

 * @val: integer attribute value.

 *

 * Description:

 * Validates the min and max values then sets the

 * adapter config field if in the valid range. prints error message

 * and does not set the parameter if invalid.

 *

 * Returns:

 * zero on success

 * -EINVAL if val is invalid

/*

 * lpfc_param_store - Set a vport attribute value

 *

 * Description:

 * Macro that given an attr e.g. hba_queue_depth expands

 * into a function with the name lpfc_hba_queue_depth_store.

 *

 * lpfc_##attr##_store: Set an sttribute value.

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: contains the attribute value in ascii.

 * @count: not used.

 *

 * Description:

 * Convert the ascii text number to an integer, then

 * use the lpfc_##attr##_set function to set the value.

 *

 * Returns:

 * -EINVAL if val is invalid or lpfc_##attr##_set() fails

 * length of buffer upon success.

/*

 * lpfc_vport_param_show - Return decimal formatted cfg attribute value

 *

 * Description:

 * Macro that given an attr e.g. hba_queue_depth expands

 * into a function with the name lpfc_hba_queue_depth_show

 *

 * lpfc_##attr##_show: prints the attribute value in decimal.

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: on return contains the attribute value in decimal.

 *

 * Returns: length of formatted string.

/*

 * lpfc_vport_param_hex_show - Return hex formatted attribute value

 *

 * Description:

 * Macro that given an attr e.g.

 * hba_queue_depth expands into a function with the name

 * lpfc_hba_queue_depth_show

 *

 * lpfc_##attr##_show: prints the attribute value in hexadecimal.

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: on return contains the attribute value in hexadecimal.

 *

 * Returns: length of formatted string.

/*

 * lpfc_vport_param_init - Initialize a vport cfg attribute

 *

 * Description:

 * Macro that given an attr e.g. hba_queue_depth expands

 * into a function with the name lpfc_hba_queue_depth_init. The macro also

 * takes a default argument, a minimum and maximum argument.

 *

 * lpfc_##attr##_init: validates the min and max values then sets the

 * adapter config field accordingly, or uses the default if out of range

 * and prints an error message.

 * @phba: pointer the the adapter structure.

 * @val: integer attribute value.

 *

 * Returns:

 * zero on success

 * -EINVAL if default used

/*

 * lpfc_vport_param_set - Set a vport cfg attribute

 *

 * Description:

 * Macro that given an attr e.g. hba_queue_depth expands

 * into a function with the name lpfc_hba_queue_depth_set

 *

 * lpfc_##attr##_set: validates the min and max values then sets the

 * adapter config field if in the valid range. prints error message

 * and does not set the parameter if invalid.

 * @phba: pointer the the adapter structure.

 * @val:	integer attribute value.

 *

 * Returns:

 * zero on success

 * -EINVAL if val is invalid

/*

 * lpfc_vport_param_store - Set a vport attribute

 *

 * Description:

 * Macro that given an attr e.g. hba_queue_depth

 * expands into a function with the name lpfc_hba_queue_depth_store

 *

 * lpfc_##attr##_store: convert the ascii text number to an integer, then

 * use the lpfc_##attr##_set function to set the value.

 * @cdev: class device that is converted into a Scsi_host.

 * @buf:	contains the attribute value in decimal.

 * @count: not used.

 *

 * Returns:

 * -EINVAL if val is invalid or lpfc_##attr##_set() fails

 * length of buffer upon success.

/**

 * lpfc_wwn_set - Convert string to the 8 byte WWN value.

 * @buf: WWN string.

 * @cnt: Length of string.

 * @wwn: Array to receive converted wwn value.

 *

 * Returns:

 * -EINVAL if the buffer does not contain a valid wwn

 * 0 success

 Count may include a LF at end of string */

 Validate and store the new name */

/**

 * lpfc_soft_wwn_enable_store - Allows setting of the wwn if the key is valid

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: containing the string lpfc_soft_wwn_key.

 * @count: must be size of lpfc_soft_wwn_key.

 *

 * Returns:

 * -EINVAL if the buffer does not contain lpfc_soft_wwn_key

 * length of buf indicates success

	/*

	 * We're doing a simple sanity check for soft_wwpn setting.

	 * We require that the user write a specific key to enable

	 * the soft_wwpn attribute to be settable. Once the attribute

	 * is written, the enable key resets. If further updates are

	 * desired, the key must be written again to re-enable the

	 * attribute.

	 *

	 * The "key" is not secret - it is a hardcoded string shown

	 * here. The intent is to protect against the random user or

	 * application that is just writing attributes.

 count may include a LF at end of string */

/**

 * lpfc_soft_wwpn_show - Return the cfg soft ww port name of the adapter

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: on return contains the wwpn in hexadecimal.

 *

 * Returns: size of formatted string.

/**

 * lpfc_soft_wwpn_store - Set the ww port name of the adapter

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: contains the wwpn in hexadecimal.

 * @count: number of wwpn bytes in buf

 *

 * Returns:

 * -EACCES hba reset not enabled, adapter over temp

 * -EINVAL soft wwn not enabled, count is invalid, invalid wwpn byte invalid

 * -EIO error taking adapter offline or online

 * value of count on success

 count may include a LF at end of string */

 lock setting wwpn, wwnn down */

 not able to set wwpn, unlock it */

/**

 * lpfc_soft_wwnn_show - Return the cfg soft ww node name for the adapter

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: on return contains the wwnn in hexadecimal.

 *

 * Returns: size of formatted string.

/**

 * lpfc_soft_wwnn_store - sets the ww node name of the adapter

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: contains the ww node name in hexadecimal.

 * @count: number of wwnn bytes in buf.

 *

 * Returns:

 * -EINVAL soft wwn not enabled, count is invalid, invalid wwnn byte invalid

 * value of count on success

 count may include a LF at end of string */

		/* Allow wwnn to be set many times, as long as the enable

		 * is set. However, once the wwpn is set, everything locks.

/**

 * lpfc_oas_tgt_show - Return wwpn of target whose luns maybe enabled for

 *		      Optimized Access Storage (OAS) operations.

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: buffer for passing information.

 *

 * Returns:

 * value of count

/**

 * lpfc_oas_tgt_store - Store wwpn of target whose luns maybe enabled for

 *		      Optimized Access Storage (OAS) operations.

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: buffer for passing information.

 * @count: Size of the data buffer.

 *

 * Returns:

 * -EINVAL count is invalid, invalid wwpn byte invalid

 * -EPERM oas is not supported by hba

 * value of count on success

 count may include a LF at end of string */

/**

 * lpfc_oas_priority_show - Return wwpn of target whose luns maybe enabled for

 *		      Optimized Access Storage (OAS) operations.

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: buffer for passing information.

 *

 * Returns:

 * value of count

/**

 * lpfc_oas_priority_store - Store wwpn of target whose luns maybe enabled for

 *		      Optimized Access Storage (OAS) operations.

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: buffer for passing information.

 * @count: Size of the data buffer.

 *

 * Returns:

 * -EINVAL count is invalid, invalid wwpn byte invalid

 * -EPERM oas is not supported by hba

 * value of count on success

 count may include a LF at end of string */

/**

 * lpfc_oas_vpt_show - Return wwpn of vport whose targets maybe enabled

 *		      for Optimized Access Storage (OAS) operations.

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: buffer for passing information.

 *

 * Returns:

 * value of count on success

/**

 * lpfc_oas_vpt_store - Store wwpn of vport whose targets maybe enabled

 *		      for Optimized Access Storage (OAS) operations.

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: buffer for passing information.

 * @count: Size of the data buffer.

 *

 * Returns:

 * -EINVAL count is invalid, invalid wwpn byte invalid

 * -EPERM oas is not supported by hba

 * value of count on success

 count may include a LF at end of string */

/**

 * lpfc_oas_lun_state_show - Return the current state (enabled or disabled)

 *			    of whether luns will be enabled or disabled

 *			    for Optimized Access Storage (OAS) operations.

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: buffer for passing information.

 *

 * Returns:

 * size of formatted string.

/**

 * lpfc_oas_lun_state_store - Store the state (enabled or disabled)

 *			    of whether luns will be enabled or disabled

 *			    for Optimized Access Storage (OAS) operations.

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: buffer for passing information.

 * @count: Size of the data buffer.

 *

 * Returns:

 * -EINVAL count is invalid, invalid wwpn byte invalid

 * -EPERM oas is not supported by hba

 * value of count on success

/**

 * lpfc_oas_lun_status_show - Return the status of the Optimized Access

 *                          Storage (OAS) lun returned by the

 *                          lpfc_oas_lun_show function.

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: buffer for passing information.

 *

 * Returns:

 * size of formatted string.

/**

 * lpfc_oas_lun_state_set - enable or disable a lun for Optimized Access Storage

 *			   (OAS) operations.

 * @phba: lpfc_hba pointer.

 * @vpt_wwpn: wwpn of the vport associated with the returned lun

 * @tgt_wwpn: wwpn of the target associated with the returned lun

 * @lun: the fc lun for setting oas state.

 * @oas_state: the oas state to be set to the lun.

 * @pri: priority

 *

 * Returns:

 * SUCCESS : 0

 * -EPERM OAS is not enabled or not supported by this port.

 *

/**

 * lpfc_oas_lun_get_next - get the next lun that has been enabled for Optimized

 *			  Access Storage (OAS) operations.

 * @phba: lpfc_hba pointer.

 * @vpt_wwpn: wwpn of the vport associated with the returned lun

 * @tgt_wwpn: wwpn of the target associated with the returned lun

 * @lun_status: status of the lun returned lun

 * @lun_pri: priority of the lun returned lun

 *

 * Returns the first or next lun enabled for OAS operations for the vport/target

 * specified.  If a lun is found, its vport wwpn, target wwpn and status is

 * returned.  If the lun is not found, NOT_OAS_ENABLED_LUN is returned.

 *

 * Return:

 * lun that is OAS enabled for the vport/target

 * NOT_OAS_ENABLED_LUN when no oas enabled lun found.

/**

 * lpfc_oas_lun_state_change - enable/disable a lun for OAS operations

 * @phba: lpfc_hba pointer.

 * @vpt_wwpn: vport wwpn by reference.

 * @tgt_wwpn: target wwpn by reference.

 * @lun: the fc lun for setting oas state.

 * @oas_state: the oas state to be set to the oas_lun.

 * @pri: priority

 *

 * This routine enables (OAS_LUN_ENABLE) or disables (OAS_LUN_DISABLE)

 * a lun for OAS operations.

 *

 * Return:

 * SUCCESS: 0

 * -ENOMEM: failed to enable an lun for OAS operations

 * -EPERM: OAS is not enabled

/**

 * lpfc_oas_lun_show - Return oas enabled luns from a chosen target

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: buffer for passing information.

 *

 * This routine returns a lun enabled for OAS each time the function

 * is called.

 *

 * Returns:

 * SUCCESS: size of formatted string.

 * -EFAULT: target or vport wwpn was not set properly.

 * -EPERM: oas is not enabled.

/**

 * lpfc_oas_lun_store - Sets the OAS state for lun

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: buffer for passing information.

 * @count: size of the formatting string

 *

 * This function sets the OAS state for lun.  Before this function is called,

 * the vport wwpn, target wwpn, and oas state need to be set.

 *

 * Returns:

 * SUCCESS: size of formatted string.

 * -EFAULT: target or vport wwpn was not set properly.

 * -EPERM: oas is not enabled.

 * size of formatted string.

/*

 * lpfc_fcp_wait_abts_rsp: Modifies criteria for reporting completion of

 * aborted IO.

 * The range is [0,1]. Default value is 0

 *      0, IO completes after ABTS issued (default).

 *      1, IO completes after receipt of ABTS response or timeout.

/*

# lpfc_enable_rrq: Track XRI/OXID reuse after IO failures

#	0x0 = disabled, XRI/OXID use not tracked.

#	0x1 = XRI/OXID reuse is timed with ratov, RRQ sent.

#	0x2 = XRI/OXID reuse is timed with ratov, No RRQ sent.

/*

# lpfc_suppress_link_up:  Bring link up at initialization

#            0x0  = bring link up (issue MBX_INIT_LINK)

#            0x1  = do NOT bring link up at initialization(MBX_INIT_LINK)

#            0x2  = never bring up link

# Default value is 0.

/*

# lpfc_cnt: Number of IOCBs allocated for ELS, CT, and ABTS

#       1 - (1024)

#       2 - (2048)

#       3 - (3072)

#       4 - (4096)

#       5 - (5120)

/*

# lpfc_nodev_tmo: If set, it will hold all I/O errors on devices that disappear

# until the timer expires. Value range is [0,255]. Default value is 30.

/**

 * lpfc_nodev_tmo_show - Return the hba dev loss timeout value

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains the dev loss timeout in decimal.

 *

 * Returns: size of formatted string.

/**

 * lpfc_nodev_tmo_init - Set the hba nodev timeout value

 * @vport: lpfc vport structure pointer.

 * @val: contains the nodev timeout value.

 *

 * Description:

 * If the devloss tmo is already set then nodev tmo is set to devloss tmo,

 * a kernel error message is printed and zero is returned.

 * Else if val is in range then nodev tmo and devloss tmo are set to val.

 * Otherwise nodev tmo is set to the default value.

 *

 * Returns:

 * zero if already set or if val is in range

 * -EINVAL val out of range

/**

 * lpfc_update_rport_devloss_tmo - Update dev loss tmo value

 * @vport: lpfc vport structure pointer.

 *

 * Description:

 * Update all the ndlp's dev loss tmo with the vport devloss tmo value.

/**

 * lpfc_nodev_tmo_set - Set the vport nodev tmo and devloss tmo values

 * @vport: lpfc vport structure pointer.

 * @val: contains the tmo value.

 *

 * Description:

 * If the devloss tmo is already set or the vport dev loss tmo has changed

 * then a kernel error message is printed and zero is returned.

 * Else if val is in range then nodev tmo and devloss tmo are set to val.

 * Otherwise nodev tmo is set to the default value.

 *

 * Returns:

 * zero if already set or if val is in range

 * -EINVAL val out of range

		/*

		 * For compat: set the fc_host dev loss so new rports

		 * will get the value.

/*

# lpfc_devloss_tmo: If set, it will hold all I/O errors on devices that

# disappear until the timer expires. Value range is [0,255]. Default

# value is 30.

/**

 * lpfc_devloss_tmo_set - Sets vport nodev tmo, devloss tmo values, changed bit

 * @vport: lpfc vport structure pointer.

 * @val: contains the tmo value.

 *

 * Description:

 * If val is in a valid range then set the vport nodev tmo,

 * devloss tmo, also set the vport dev loss tmo changed flag.

 * Else a kernel error message is printed.

 *

 * Returns:

 * zero if val is in range

 * -EINVAL val out of range

/*

 * lpfc_suppress_rsp: Enable suppress rsp feature is firmware supports it

 * lpfc_suppress_rsp = 0  Disable

 * lpfc_suppress_rsp = 1  Enable (default)

 *

/*

 * lpfc_nvmet_mrq: Specify number of RQ pairs for processing NVMET cmds

 * lpfc_nvmet_mrq = 0  driver will calcualte optimal number of RQ pairs

 * lpfc_nvmet_mrq = 1  use a single RQ pair

 * lpfc_nvmet_mrq >= 2  use specified RQ pairs for MRQ

 *

/*

 * lpfc_nvmet_mrq_post: Specify number of RQ buffer to initially post

 * to each NVMET RQ. Range 64 to 2048, default is 512.

/*

 * lpfc_enable_fc4_type: Defines what FC4 types are supported.

 * Supported Values:  1 - register just FCP

 *                    3 - register both FCP and NVME

 * Supported values are [1,3]. Default value is 3

/*

# lpfc_log_verbose: Only turn this flag on if you are willing to risk being

# deluged with LOTS of information.

# You can set a bit mask to record specific types of verbose messages:

# See lpfc_logmsh.h for definitions.

/*

# lpfc_enable_da_id: This turns on the DA_ID CT command that deregisters

# objects that have been registered with the nameserver after login.

/*

# lun_queue_depth:  This parameter is used to limit the number of outstanding

# commands per FCP LUN.

/*

# tgt_queue_depth:  This parameter is used to limit the number of outstanding

# commands per target port. Value range is [10,65535]. Default value is 65535.

/**

 * lpfc_tgt_queue_depth_set: Sets an attribute value.

 * @vport: lpfc vport structure pointer.

 * @val: integer attribute value.

 *

 * Description: Sets the parameter to the new value.

 *

 * Returns:

 * zero on success

 * -EINVAL if val is invalid

 Next loop thru nodelist and change cmd_qdepth */

/*

# hba_queue_depth:  This parameter is used to limit the number of outstanding

# commands per lpfc HBA. Value range is [32,8192]. If this parameter

# value is greater than the maximum number of exchanges supported by the HBA,

# then maximum number of exchanges supported by the HBA is used to determine

# the hba_queue_depth.

/*

# peer_port_login:  This parameter allows/prevents logins

# between peer ports hosted on the same physical port.

# When this parameter is set 0 peer ports of same physical port

# are not allowed to login to each other.

# When this parameter is set 1 peer ports of same physical port

# are allowed to login to each other.

# Default value of this parameter is 0.

/*

# restrict_login:  This parameter allows/prevents logins

# between Virtual Ports and remote initiators.

# When this parameter is not set (0) Virtual Ports will accept PLOGIs from

# other initiators and will attempt to PLOGI all remote ports.

# When this parameter is set (1) Virtual Ports will reject PLOGIs from

# remote ports and will not attempt to PLOGI to other initiators.

# This parameter does not restrict to the physical port.

# This parameter does not restrict logins to Fabric resident remote ports.

# Default value of this parameter is 1.

/**

 * lpfc_restrict_login_init - Set the vport restrict login flag

 * @vport: lpfc vport structure pointer.

 * @val: contains the restrict login value.

 *

 * Description:

 * If val is not in a valid range then log a kernel error message and set

 * the vport restrict login to one.

 * If the port type is physical clear the restrict login flag and return.

 * Else set the restrict login flag to val.

 *

 * Returns:

 * zero if val is in range

 * -EINVAL val out of range

/**

 * lpfc_restrict_login_set - Set the vport restrict login flag

 * @vport: lpfc vport structure pointer.

 * @val: contains the restrict login value.

 *

 * Description:

 * If val is not in a valid range then log a kernel error message and set

 * the vport restrict login to one.

 * If the port type is physical and the val is not zero log a kernel

 * error message, clear the restrict login flag and return zero.

 * Else set the restrict login flag to val.

 *

 * Returns:

 * zero if val is in range

 * -EINVAL val out of range

/*

# Some disk devices have a "select ID" or "select Target" capability.

# From a protocol standpoint "select ID" usually means select the

# Fibre channel "ALPA".  In the FC-AL Profile there is an "informative

# annex" which contains a table that maps a "select ID" (a number

# between 0 and 7F) to an ALPA.  By default, for compatibility with

# older drivers, the lpfc driver scans this table from low ALPA to high

# ALPA.

#

# Turning on the scan-down variable (on  = 1, off = 0) will

# cause the lpfc driver to use an inverted table, effectively

# scanning ALPAs from high to low. Value range is [0,1]. Default value is 1.

#

# (Note: This "select ID" functionality is a LOOP ONLY characteristic

# and will not work across a fabric. Also this parameter will take

# effect only in the case when ALPA map is not available.)

/*

# lpfc_topology:  link topology for init link

#            0x0  = attempt loop mode then point-to-point

#            0x01 = internal loopback mode

#            0x02 = attempt point-to-point mode only

#            0x04 = attempt loop mode only

#            0x06 = attempt point-to-point mode then loop

# Set point-to-point mode if you want to run as an N_Port.

# Set loop mode if you want to run as an NL_Port. Value range is [0,0x6].

# Default value is 0.

/**

 * lpfc_topology_store - Set the adapters topology field

 * @dev: class device that is converted into a scsi_host.

 * @attr:device attribute, not used.

 * @buf: buffer for passing information.

 * @count: size of the data buffer.

 *

 * Description:

 * If val is in a valid range then set the adapter's topology field and

 * issue a lip; if the lip fails reset the topology to the old value.

 *

 * If the value is not in range log a kernel error message and return an error.

 *

 * Returns:

 * zero if val is in range and lip okay

 * non-zero return value from lpfc_issue_lip()

 * -EINVAL val out of range

		/*

		 * The 'topology' is not a configurable parameter if :

		 *   - persistent topology enabled

		 *   - ASIC_GEN_NUM >= 0xC, with no private loop support

/**

 * lpfc_static_vport_show: Read callback function for

 *   lpfc_static_vport sysfs file.

 * @dev: Pointer to class device object.

 * @attr: device attribute structure.

 * @buf: Data buffer.

 *

 * This function is the read call back function for

 * lpfc_static_vport sysfs file. The lpfc_static_vport

 * sysfs file report the mageability of the vport.

/*

 * Sysfs attribute to control the statistical data collection.

/**

 * lpfc_stat_data_ctrl_store - write call back for lpfc_stat_data_ctrl sysfs file

 * @dev: Pointer to class device.

 * @attr: Unused.

 * @buf: Data buffer.

 * @count: Size of the data buffer.

 *

 * This function get called when a user write to the lpfc_stat_data_ctrl

 * sysfs file. This function parse the command written to the sysfs file

 * and take appropriate action. These commands are used for controlling

 * driver statistical data collection.

 * Following are the command this function handles.

 *

 *    setbucket <bucket_type> <base> <step>

 *			       = Set the latency buckets.

 *    destroybucket            = destroy all the buckets.

 *    start                    = start data collection

 *    stop                     = stop data collection

 *    reset                    = reset the collected data

 Ignore this token - this is command token */

 Block the data collection for every vport */

 Block and reset data collection */

 Set the bucket attributes */

 Unblock data collection */

 If no buckets configured return error */

/**

 * lpfc_stat_data_ctrl_show - Read function for lpfc_stat_data_ctrl sysfs file

 * @dev: Pointer to class device.

 * @attr: Unused.

 * @buf: Data buffer.

 *

 * This function is the read call back function for

 * lpfc_stat_data_ctrl sysfs file. This function report the

 * current statistical data collection state.

/*

 * Sysfs attribute to control the statistical data collection.

/*

 * lpfc_drvr_stat_data: sysfs attr to get driver statistical data.

/*

 * Each Bucket takes 11 characters and 1 new line + 17 bytes WWN

 * for each target.

/**

 * sysfs_drvr_stat_data_read - Read function for lpfc_drvr_stat_data attribute

 * @filp: sysfs file

 * @kobj: Pointer to the kernel object

 * @bin_attr: Attribute object

 * @buf: Buffer pointer

 * @off: File offset

 * @count: Buffer size

 *

 * This function is the read call back function for lpfc_drvr_stat_data

 * sysfs file. This function export the statistical data to user

 * applications.

 Print the WWN */

/*

# lpfc_link_speed: Link speed selection for initializing the Fibre Channel

# connection.

# Value range is [0,16]. Default value is 0.

/**

 * lpfc_link_speed_store - Set the adapters link speed

 * @dev: Pointer to class device.

 * @attr: Unused.

 * @buf: Data buffer.

 * @count: Size of the data buffer.

 *

 * Description:

 * If val is in a valid range then set the adapter's link speed field and

 * issue a lip; if the lip fails reset the link speed to the old value.

 *

 * Notes:

 * If the value is not in range log a kernel error message and return an error.

 *

 * Returns:

 * zero if val is in range and lip okay.

 * non-zero return value from lpfc_issue_lip()

 * -EINVAL val out of range

/**

 * lpfc_link_speed_init - Set the adapters link speed

 * @phba: lpfc_hba pointer.

 * @val: link speed value.

 *

 * Description:

 * If val is in a valid range then set the adapter's link speed field.

 *

 * Notes:

 * If the value is not in range log a kernel error message, clear the link

 * speed and return an error.

 *

 * Returns:

 * zero if val saved.

 * -EINVAL val out of range

/*

# lpfc_aer_support: Support PCIe device Advanced Error Reporting (AER)

#       0  = aer disabled or not supported

#       1  = aer supported and enabled (default)

# Value range is [0,1]. Default value is 1.

/**

 * lpfc_aer_support_store - Set the adapter for aer support

 *

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: containing enable or disable aer flag.

 * @count: unused variable.

 *

 * Description:

 * If the val is 1 and currently the device's AER capability was not

 * enabled, invoke the kernel's enable AER helper routine, trying to

 * enable the device's AER capability. If the helper routine enabling

 * AER returns success, update the device's cfg_aer_support flag to

 * indicate AER is supported by the device; otherwise, if the device

 * AER capability is already enabled to support AER, then do nothing.

 *

 * If the val is 0 and currently the device's AER support was enabled,

 * invoke the kernel's disable AER helper routine. After that, update

 * the device's cfg_aer_support flag to indicate AER is not supported

 * by the device; otherwise, if the device AER capability is already

 * disabled from supporting AER, then do nothing.

 *

 * Returns:

 * length of the buf on success if val is in range the intended mode

 * is supported.

 * -EINVAL if val out of range or intended mode is not supported.

/**

 * lpfc_aer_cleanup_state - Clean up aer state to the aer enabled device

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: containing flag 1 for aer cleanup state.

 * @count: unused variable.

 *

 * Description:

 * If the @buf contains 1 and the device currently has the AER support

 * enabled, then invokes the kernel AER helper routine

 * pci_aer_clear_nonfatal_status() to clean up the uncorrectable

 * error status register.

 *

 * Notes:

 *

 * Returns:

 * -EINVAL if the buf does not contain the 1 or the device is not currently

 * enabled with the AER support.

/**

 * lpfc_sriov_nr_virtfn_store - Enable the adapter for sr-iov virtual functions

 *

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: containing the string the number of vfs to be enabled.

 * @count: unused variable.

 *

 * Description:

 * When this api is called either through user sysfs, the driver shall

 * try to enable or disable SR-IOV virtual functions according to the

 * following:

 *

 * If zero virtual function has been enabled to the physical function,

 * the driver shall invoke the pci enable virtual function api trying

 * to enable the virtual functions. If the nr_vfn provided is greater

 * than the maximum supported, the maximum virtual function number will

 * be used for invoking the api; otherwise, the nr_vfn provided shall

 * be used for invoking the api. If the api call returned success, the

 * actual number of virtual functions enabled will be set to the driver

 * cfg_sriov_nr_virtfn; otherwise, -EINVAL shall be returned and driver

 * cfg_sriov_nr_virtfn remains zero.

 *

 * If none-zero virtual functions have already been enabled to the

 * physical function, as reflected by the driver's cfg_sriov_nr_virtfn,

 * -EINVAL will be returned and the driver does nothing;

 *

 * If the nr_vfn provided is zero and none-zero virtual functions have

 * been enabled, as indicated by the driver's cfg_sriov_nr_virtfn, the

 * disabling virtual function api shall be invoded to disable all the

 * virtual functions and driver's cfg_sriov_nr_virtfn shall be set to

 * zero. Otherwise, if zero virtual function has been enabled, do

 * nothing.

 *

 * Returns:

 * length of the buf on success if val is in range the intended mode

 * is supported.

 * -EINVAL if val out of range or intended mode is not supported.

 Sanity check on user data */

 Request disabling virtual functions */

 Request enabling virtual functions */

/**

 * lpfc_request_firmware_upgrade_store - Request for Linux generic firmware upgrade

 *

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: containing the string the number of vfs to be enabled.

 * @count: unused variable.

 *

 * Description:

 *

 * Returns:

 * length of the buf on success if val is in range the intended mode

 * is supported.

 * -EINVAL if val out of range or intended mode is not supported.

 Sanity check on user data */

/**

 * lpfc_request_firmware_upgrade_init - Enable initial linux generic fw upgrade

 * @phba: lpfc_hba pointer.

 * @val: 0 or 1.

 *

 * Description:

 * Set the initial Linux generic firmware upgrade enable or disable flag.

 *

 * Returns:

 * zero if val saved.

 * -EINVAL val out of range

/**

 * lpfc_force_rscn_store

 *

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: unused string

 * @count: unused variable.

 *

 * Description:

 * Force the switch to send a RSCN to all other NPorts in our zone

 * If we are direct connect pt2pt, build the RSCN command ourself

 * and send to the other NPort. Not supported for private loop.

 *

 * Returns:

 * 0      - on success

 * -EIO   - if command is not sent

/*

 * lpfc_force_rscn: Force an RSCN to be sent to all remote NPorts

 * connected to  the HBA.

 *

 * Value range is any ascii value

/**

 * lpfc_force_rscn_init - Force an RSCN to be sent to all remote NPorts

 * @phba: lpfc_hba pointer.

 * @val: unused value.

 *

 * Returns:

 * zero if val saved.

/**

 * lpfc_fcp_imax_store

 *

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: string with the number of fast-path FCP interrupts per second.

 * @count: unused variable.

 *

 * Description:

 * If val is in a valid range [636,651042], then set the adapter's

 * maximum number of fast-path FCP interrupts per second.

 *

 * Returns:

 * length of the buf on success if val is in range the intended mode

 * is supported.

 * -EINVAL if val out of range or intended mode is not supported.

 fcp_imax is only valid for SLI4 */

 Sanity check on user data */

	/*

	 * Value range for the HBA is [5000,5000000]

	 * The value for each EQ depends on how many EQs are configured.

	 * Allow value == 0

/*

# lpfc_fcp_imax: The maximum number of fast-path FCP interrupts per second

# for the HBA.

#

# Value range is [5,000 to 5,000,000]. Default value is 50,000.

/**

 * lpfc_fcp_imax_init - Set the initial sr-iov virtual function enable

 * @phba: lpfc_hba pointer.

 * @val: link speed value.

 *

 * Description:

 * If val is in a valid range [636,651042], then initialize the adapter's

 * maximum number of fast-path FCP interrupts per second.

 *

 * Returns:

 * zero if val saved.

 * -EINVAL val out of range

/**

 * lpfc_cq_max_proc_limit_store

 *

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: string with the cq max processing limit of cqes

 * @count: unused variable.

 *

 * Description:

 * If val is in a valid range, then set value on each cq

 *

 * Returns:

 * The length of the buf: if successful

 * -ERANGE: if val is not in the valid range

 * -EINVAL: if bad value format or intended mode is not supported.

 cq_max_proc_limit is only valid for SLI4 */

 Sanity check on user data */

 set the values on the cq's */

 Get the EQ corresponding to the IRQ vector */

/*

 * lpfc_cq_max_proc_limit: The maximum number CQE entries processed in an

 *   itteration of CQ processing.

/*

 * lpfc_cq_poll_threshold: Set the threshold of CQE completions in a

 *   single handler call which should request a polled completion rather

 *   than re-enabling interrupts.

/**

 * lpfc_cq_max_proc_limit_init - Set the initial cq max_proc_limit

 * @phba: lpfc_hba pointer.

 * @val: entry limit

 *

 * Description:

 * If val is in a valid range, then initialize the adapter's maximum

 * value.

 *

 * Returns:

 *  Always returns 0 for success, even if value not always set to

 *  requested value. If value out of range or not supported, will fall

 *  back to default.

/**

 * lpfc_fcp_cpu_map_show - Display current driver CPU affinity

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains text describing the state of the link.

 *

 * Returns: size of formatted string.

 display max number of CPUs keeping some margin */

/**

 * lpfc_fcp_cpu_map_store - Change CPU affinity of driver vectors

 * @dev: class device that is converted into a Scsi_host.

 * @attr: device attribute, not used.

 * @buf: one or more lpfc_polling_flags values.

 * @count: not used.

 *

 * Returns:

 * -EINVAL  - Not implemented yet.

/*

# lpfc_fcp_cpu_map: Defines how to map CPUs to IRQ vectors

# for the HBA.

#

# Value range is [0 to 1]. Default value is LPFC_HBA_CPU_MAP (1).

#	0 - Do not affinitze IRQ vectors

#	1 - Affintize HBA vectors with respect to each HBA

#	    (start with CPU0 for each HBA)

# This also defines how Hardware Queues are mapped to specific CPUs.

/**

 * lpfc_fcp_cpu_map_init - Set the initial sr-iov virtual function enable

 * @phba: lpfc_hba pointer.

 * @val: link speed value.

 *

 * Description:

 * If val is in a valid range [0-2], then affinitze the adapter's

 * MSIX vectors.

 *

 * Returns:

 * zero if val saved.

 * -EINVAL val out of range

/*

# lpfc_fcp_class:  Determines FC class to use for the FCP protocol.

# Value range is [2,3]. Default value is 3.

/*

# lpfc_use_adisc: Use ADISC for FCP rediscovery instead of PLOGI. Value range

# is [0,1]. Default value is 1.

/*

# lpfc_first_burst_size: First burst size to use on the NPorts

# that support first burst.

# Value range is [0,65536]. Default value is 0.

/*

* lpfc_nvmet_fb_size: NVME Target mode supported first burst size.

* When the driver is configured as an NVME target, this value is

* communicated to the NVME initiator in the PRLI response.  It is

* used only when the lpfc_nvme_enable_fb and lpfc_nvmet_support

* parameters are set and the target is sending the PRLI RSP.

* Parameter supported on physical port only - no NPIV support.

* Value range is [0,65536]. Default value is 0.

/*

 * lpfc_nvme_enable_fb: Enable NVME first burst on I and T functions.

 * For the Initiator (I), enabling this parameter means that an NVMET

 * PRLI response with FBA enabled and an FB_SIZE set to a nonzero value will be

 * processed by the initiator for subsequent NVME FCP IO.

 * Currently, this feature is not supported on the NVME target

 * Value range is [0,1]. Default value is 0 (disabled).

/*

# lpfc_max_scsicmpl_time: Use scsi command completion time to control I/O queue

# depth. Default value is 0. When the value of this parameter is zero the

# SCSI command completion time is not used for controlling I/O queue depth. When

# the parameter is set to a non-zero value, the I/O queue depth is controlled

# to limit the I/O completion time to the parameter value.

# The value is set in milliseconds.

/*

# lpfc_ack0: Use ACK0, instead of ACK1 for class 2 acknowledgement. Value

# range is [0,1]. Default value is 0.

/*

# lpfc_xri_rebalancing: enable or disable XRI rebalancing feature

# range is [0,1]. Default value is 1.

/*

 * lpfc_io_sched: Determine scheduling algrithmn for issuing FCP cmds

 * range is [0,1]. Default value is 0.

 * For [0], FCP commands are issued to Work Queues based on upper layer

 * hardware queue index.

 * For [1], FCP commands are issued to a Work Queue associated with the

 *          current CPU.

 *

 * LPFC_FCP_SCHED_BY_HDWQ == 0

 * LPFC_FCP_SCHED_BY_CPU == 1

 *

 * The driver dynamically sets this to 1 (BY_CPU) if it's able to set up cpu

 * affinity for FCP/NVME I/Os through Work Queues associated with the current

 * CPU. Otherwise, the default 0 (Round Robin) scheduling of FCP/NVME I/Os

 * through WQs will be used.

/*

 * lpfc_ns_query: Determine algrithmn for NameServer queries after RSCN

 * range is [0,1]. Default value is 0.

 * For [0], GID_FT is used for NameServer queries after RSCN (default)

 * For [1], GID_PT is used for NameServer queries after RSCN

 *

/*

# lpfc_fcp2_no_tgt_reset: Determine bus reset behavior

# range is [0,1]. Default value is 0.

# For [0], bus reset issues target reset to ALL devices

# For [1], bus reset issues target reset to non-FCP2 devices

/*

# lpfc_cr_delay & lpfc_cr_count: Default values for I/O colaesing

# cr_delay (msec) or cr_count outstanding commands. cr_delay can take

# value [0,63]. cr_count can take value [1,255]. Default value of cr_delay

# is 0. Default value of cr_count is 1. The cr_count feature is disabled if

# cr_delay is set to 0.

/*

# lpfc_multi_ring_support:  Determines how many rings to spread available

# cmd/rsp IOCB entries across.

# Value range is [1,2]. Default value is 1.

/*

# lpfc_multi_ring_rctl:  If lpfc_multi_ring_support is enabled, this

# identifies what rctl value to configure the additional ring for.

# Value range is [1,0xff]. Default value is 4 (Unsolicated Data).

/*

# lpfc_multi_ring_type:  If lpfc_multi_ring_support is enabled, this

# identifies what type value to configure the additional ring for.

# Value range is [1,0xff]. Default value is 5 (LLC/SNAP).

/*

# lpfc_enable_SmartSAN: Sets up FDMI support for SmartSAN

#       0  = SmartSAN functionality disabled (default)

#       1  = SmartSAN functionality enabled

# This parameter will override the value of lpfc_fdmi_on module parameter.

# Value range is [0,1]. Default value is 0.

/*

# lpfc_fdmi_on: Controls FDMI support.

#       0       No FDMI support

#       1       Traditional FDMI support (default)

# Traditional FDMI support means the driver will assume FDMI-2 support;

# however, if that fails, it will fallback to FDMI-1.

# If lpfc_enable_SmartSAN is set to 1, the driver ignores lpfc_fdmi_on.

# If lpfc_enable_SmartSAN is set 0, the driver uses the current value of

# lpfc_fdmi_on.

# Value range [0,1]. Default value is 1.

/*

# Specifies the maximum number of ELS cmds we can have outstanding (for

# discovery). Value range is [1,64]. Default value = 32.

/*

# lpfc_max_luns: maximum allowed LUN ID. This is the highest LUN ID that

#    will be scanned by the SCSI midlayer when sequential scanning is

#    used; and is also the highest LUN ID allowed when the SCSI midlayer

#    parses REPORT_LUN responses. The lpfc driver has no LUN count or

#    LUN ID limit, but the SCSI midlayer requires this field for the uses

#    above. The lpfc driver limits the default value to 255 for two reasons.

#    As it bounds the sequential scan loop, scanning for thousands of luns

#    on a target can take minutes of wall clock time.  Additionally,

#    there are FC targets, such as JBODs, that only recognize 8-bits of

#    LUN ID. When they receive a value greater than 8 bits, they chop off

#    the high order bits. In other words, they see LUN IDs 0, 256, 512,

#    and so on all as LUN ID 0. This causes the linux kernel, which sees

#    valid responses at each of the LUN IDs, to believe there are multiple

#    devices present, when in fact, there is only 1.

#    A customer that is aware of their target behaviors, and the results as

#    indicated above, is welcome to increase the lpfc_max_luns value.

#    As mentioned, this value is not used by the lpfc driver, only the

#    SCSI midlayer.

# Value range is [0,65535]. Default value is 255.

# NOTE: The SCSI layer might probe all allowed LUN on some old targets.

/*

# lpfc_poll_tmo: .Milliseconds driver will wait between polling FCP ring.

# Value range is [1,255], default value is 10.

/*

# lpfc_task_mgmt_tmo: Maximum time to wait for task management commands

# to complete in seconds. Value range is [5,180], default value is 60.

/*

# lpfc_use_msi: Use MSI (Message Signaled Interrupts) in systems that

#		support this feature

#       0  = MSI disabled

#       1  = MSI enabled

#       2  = MSI-X enabled (default)

# Value range is [0,2]. Default value is 2.

/*

 * lpfc_nvme_oas: Use the oas bit when sending NVME/NVMET IOs

 *

 *      0  = NVME OAS disabled

 *      1  = NVME OAS enabled

 *

 * Value range is [0,1]. Default value is 0.

/*

 * lpfc_nvme_embed_cmd: Use the oas bit when sending NVME/NVMET IOs

 *

 *      0  = Put NVME Command in SGL

 *      1  = Embed NVME Command in WQE (unless G7)

 *      2 =  Embed NVME Command in WQE (force)

 *

 * Value range is [0,2]. Default value is 1.

/*

 * lpfc_fcp_mq_threshold: Set the maximum number of Hardware Queues

 * the driver will advertise it supports to the SCSI layer.

 *

 *      0    = Set nr_hw_queues by the number of CPUs or HW queues.

 *      1,256 = Manually specify nr_hw_queue value to be advertised,

 *

 * Value range is [0,256]. Default value is 8.

/*

 * lpfc_hdw_queue: Set the number of Hardware Queues the driver

 * will advertise it supports to the NVME and  SCSI layers. This also

 * will map to the number of CQ/WQ pairs the driver will create.

 *

 * The NVME Layer will try to create this many, plus 1 administrative

 * hardware queue. The administrative queue will always map to WQ 0

 * A hardware IO queue maps (qidx) to a specific driver CQ/WQ.

 *

 *      0    = Configure the number of hdw queues to the number of active CPUs.

 *      1,256 = Manually specify how many hdw queues to use.

 *

 * Value range is [0,256]. Default value is 0.

/**

 * lpfc_cpumask_irq_mode_init - initalizes cpumask of phba based on

 *				irq_chann_mode

 * @phba: Pointer to HBA context object.

 Check if we're a NUMA architecture */

 If AMD architecture, then default is NUMA_MODE */

 If Intel architecture, then default is no hyperthread mode */

/*

 * lpfc_irq_chann: Set the number of IRQ vectors that are available

 * for Hardware Queues to utilize.  This also will map to the number

 * of EQ / MSI-X vectors the driver will create. This should never be

 * more than the number of Hardware Queues

 *

 *	0		= Configure number of IRQ Channels to:

 *			  if AMD architecture, number of CPUs on HBA's NUMA node

 *			  if Intel architecture, number of physical CPUs.

 *			  otherwise, number of active CPUs.

 *	[1,256]		= Manually specify how many IRQ Channels to use.

 *

 * Value range is [0,256]. Default value is [0].

/* lpfc_irq_chann_init - Set the hba irq_chann initial value

 * @phba: lpfc_hba pointer.

 * @val: contains the initial value

 *

 * Description:

 * Validates the initial value is within range and assigns it to the

 * adapter. If not in range, an error message is posted and the

 * default value is assigned.

 *

 * Returns:

 * zero if value is in range and is set

 * -EINVAL if value was out of range

 Check if default setting was passed */

			/* If no hyperthread mode, then set hdwq count to

			 * aff_mask weight as well

/**

 * lpfc_irq_chann_show - Display value of irq_chann

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains a string with the list sizes

 *

 * Returns: size of formatted string.

/*

# lpfc_enable_hba_reset: Allow or prevent HBA resets to the hardware.

#       0  = HBA resets disabled

#       1  = HBA resets enabled (default)

#       2  = HBA reset via PCI bus reset enabled

# Value range is [0,2]. Default value is 1.

/*

# lpfc_enable_hba_heartbeat: Disable HBA heartbeat timer..

#       0  = HBA Heartbeat disabled

#       1  = HBA Heartbeat enabled (default)

# Value range is [0,1]. Default value is 1.

/*

# lpfc_EnableXLane: Enable Express Lane Feature

#      0x0   Express Lane Feature disabled

#      0x1   Express Lane Feature enabled

# Value range is [0,1]. Default value is 0.

/*

# lpfc_XLanePriority:  Define CS_CTL priority for Express Lane Feature

#       0x0 - 0x7f  = CS_CTL field in FC header (high 7 bits)

# Value range is [0x0,0x7f]. Default value is 0

/*

# lpfc_enable_bg: Enable BlockGuard (Emulex's Implementation of T10-DIF)

#       0  = BlockGuard disabled (default)

#       1  = BlockGuard enabled

# Value range is [0,1]. Default value is 0.

/*

# lpfc_prot_mask:

#	- Bit mask of host protection capabilities used to register with the

#	  SCSI mid-layer

# 	- Only meaningful if BG is turned on (lpfc_enable_bg=1).

#	- Allows you to ultimately specify which profiles to use

#	- Default will result in registering capabilities for all profiles.

#	- SHOST_DIF_TYPE1_PROTECTION	1

#		HBA supports T10 DIF Type 1: HBA to Target Type 1 Protection

#	- SHOST_DIX_TYPE0_PROTECTION	8

#		HBA supports DIX Type 0: Host to HBA protection only

#	- SHOST_DIX_TYPE1_PROTECTION	16

#		HBA supports DIX Type 1: Host to HBA  Type 1 protection

#

/*

# lpfc_prot_guard:

#	- Bit mask of protection guard types to register with the SCSI mid-layer

#	- Guard types are currently either 1) T10-DIF CRC 2) IP checksum

#	- Allows you to ultimately specify which profiles to use

#	- Default will result in registering capabilities for all guard types

#

/*

 * Delay initial NPort discovery when Clean Address bit is cleared in

 * FLOGI/FDISC accept and FCID/Fabric name/Fabric portname is changed.

 * This parameter can have value 0 or 1.

 * When this parameter is set to 0, no delay is added to the initial

 * discovery.

 * When this parameter is set to non-zero value, initial Nport discovery is

 * delayed by ra_tov seconds when Clean Address bit is cleared in FLOGI/FDISC

 * accept and FCID/Fabric name/Fabric portname is changed.

 * Driver always delay Nport discovery for subsequent FLOGI/FDISC completion

 * when Clean Address bit is cleared in FLOGI/FDISC

 * accept and FCID/Fabric name/Fabric portname is changed.

 * Default value is 0.

/*

 * lpfc_sg_seg_cnt - Initial Maximum DMA Segment Count

 * This value can be set to values between 64 and 4096. The default value

 * is 64, but may be increased to allow for larger Max I/O sizes. The scsi

 * and nvme layers will allow I/O sizes up to (MAX_SEG_COUNT * SEG_SIZE).

 * Because of the additional overhead involved in setting up T10-DIF,

 * this parameter will be limited to 128 if BlockGuard is enabled under SLI4

 * and will be limited to 512 if BlockGuard is enabled under SLI3.

/**

 * lpfc_sg_seg_cnt_show - Display the scatter/gather list sizes

 *    configured for the adapter

 * @dev: class converted to a Scsi_host structure.

 * @attr: device attribute, not used.

 * @buf: on return contains a string with the list sizes

 *

 * Returns: size of formatted string.

/**

 * lpfc_sg_seg_cnt_init - Set the hba sg_seg_cnt initial value

 * @phba: lpfc_hba pointer.

 * @val: contains the initial value

 *

 * Description:

 * Validates the initial value is within range and assigns it to the

 * adapter. If not in range, an error message is posted and the

 * default value is assigned.

 *

 * Returns:

 * zero if value is in range and is set

 * -EINVAL if value was out of range

/*

 * lpfc_enable_mds_diags: Enable MDS Diagnostics

 *       0  = MDS Diagnostics disabled (default)

 *       1  = MDS Diagnostics enabled

 * Value range is [0,1]. Default value is 0.

/*

 * lpfc_ras_fwlog_buffsize: Firmware logging host buffer size

 *	0 = Disable firmware logging (default)

 *	[1-4] = Multiple of 1/4th Mb of host memory for FW logging

 * Value range [0..4]. Default value is 0

	/* For disable logging: stop the logs and free the DMA.

	 * For ras_fwlog_buffsize size change we still need to free and

	 * reallocate the DMA in lpfc_sli4_ras_fwlog_init.

/*

 * lpfc_ras_fwlog_level: Firmware logging verbosity level

 * Valid only if firmware logging is enabled

 * 0(Least Verbosity) 4 (most verbosity)

 * Value range is [0..4]. Default value is 0

/*

 * lpfc_ras_fwlog_func: Firmware logging enabled on function number

 * Default function which has RAS support : 0

 * Value Range is [0..7].

 * FW logging is a global action and enablement is via a specific

 * port.

/*

 * lpfc_enable_bbcr: Enable BB Credit Recovery

 *       0  = BB Credit Recovery disabled

 *       1  = BB Credit Recovery enabled (default)

 * Value range is [0,1]. Default value is 1.

 Signaling module parameters */

 100 ms default */

 10 sec default */

 0 - only use FPINs, 1 - Use signals if avail  */

/*

 * lpfc_enable_dpp: Enable DPP on G7

 *       0  = DPP on G7 disabled

 *       1  = DPP on G7 enabled (default)

 * Value range is [0,1]. Default value is 1.

/*

 * lpfc_enable_mi: Enable FDMI MIB

 *       0  = disabled

 *       1  = enabled (default)

 * Value range is [0,1].

/*

 * lpfc_max_vmid: Maximum number of VMs to be tagged. This is valid only if

 * either vmid_app_header or vmid_priority_tagging is enabled.

 *       4 - 255  = vmid support enabled for 4-255 VMs

 *       Value range is [4,255].

/*

 * lpfc_vmid_inactivity_timeout: Inactivity timeout duration in hours

 *       0  = Timeout is disabled

 * Value range is [0,24].

/*

 * lpfc_vmid_app_header: Enable App Header VMID support

 *       0  = Support is disabled (default)

 *       1  = Support is enabled

 * Value range is [0,1].

/*

 * lpfc_vmid_priority_tagging: Enable Priority Tagging VMID support

 *       0  = Support is disabled (default)

 *       1  = Allow supported targets only

 *       2  = Allow all targets

 * Value range is [0,2].

/**

 * sysfs_ctlreg_write - Write method for writing to ctlreg

 * @filp: open sysfs file

 * @kobj: kernel kobject that contains the kernel class device.

 * @bin_attr: kernel attributes passed to us.

 * @buf: contains the data to be written to the adapter IOREG space.

 * @off: offset into buffer to beginning of data.

 * @count: bytes to transfer.

 *

 * Description:

 * Accessed via /sys/class/scsi_host/hostxxx/ctlreg.

 * Uses the adapter io control registers to send buf contents to the adapter.

 *

 * Returns:

 * -ERANGE off and count combo out of range

 * -EINVAL off, count or buff address invalid

 * -EPERM adapter is offline

 * value of count, buf contents written

 This is to protect HBA registers from accidental writes. */

/**

 * sysfs_ctlreg_read - Read method for reading from ctlreg

 * @filp: open sysfs file

 * @kobj: kernel kobject that contains the kernel class device.

 * @bin_attr: kernel attributes passed to us.

 * @buf: if successful contains the data from the adapter IOREG space.

 * @off: offset into buffer to beginning of data.

 * @count: bytes to transfer.

 *

 * Description:

 * Accessed via /sys/class/scsi_host/hostxxx/ctlreg.

 * Uses the adapter io control registers to read data into buf.

 *

 * Returns:

 * -ERANGE off and count combo out of range

 * -EINVAL off, count or buff address invalid

 * value of count, buf contents read

/**

 * sysfs_mbox_write - Write method for writing information via mbox

 * @filp: open sysfs file

 * @kobj: kernel kobject that contains the kernel class device.

 * @bin_attr: kernel attributes passed to us.

 * @buf: contains the data to be written to sysfs mbox.

 * @off: offset into buffer to beginning of data.

 * @count: bytes to transfer.

 *

 * Description:

 * Deprecated function. All mailbox access from user space is performed via the

 * bsg interface.

 *

 * Returns:

 * -EPERM operation not permitted

/**

 * sysfs_mbox_read - Read method for reading information via mbox

 * @filp: open sysfs file

 * @kobj: kernel kobject that contains the kernel class device.

 * @bin_attr: kernel attributes passed to us.

 * @buf: contains the data to be read from sysfs mbox.

 * @off: offset into buffer to beginning of data.

 * @count: bytes to transfer.

 *

 * Description:

 * Deprecated function. All mailbox access from user space is performed via the

 * bsg interface.

 *

 * Returns:

 * -EPERM operation not permitted

/**

 * lpfc_alloc_sysfs_attr - Creates the ctlreg and mbox entries

 * @vport: address of lpfc vport structure.

 *

 * Return codes:

 * zero on success

 * error return code from sysfs_create_bin_file()

 Virtual ports do not need ctrl_reg and mbox */

/**

 * lpfc_free_sysfs_attr - Removes the ctlreg and mbox entries

 * @vport: address of lpfc vport structure.

 Virtual ports do not need ctrl_reg and mbox */

/*

 * Dynamic FC Host Attributes Support

/**

 * lpfc_get_host_symbolic_name - Copy symbolic name into the scsi host

 * @shost: kernel scsi host pointer.

/**

 * lpfc_get_host_port_id - Copy the vport DID into the scsi host port id

 * @shost: kernel scsi host pointer.

 note: fc_myDID already in cpu endianness */

/**

 * lpfc_get_host_port_type - Set the value of the scsi host port type

 * @shost: kernel scsi host pointer.

/**

 * lpfc_get_host_port_state - Set the value of the scsi host port state

 * @shost: kernel scsi host pointer.

 Links up, reports port state accordingly */

/**

 * lpfc_get_host_speed - Set the value of the scsi host speed

 * @shost: kernel scsi host pointer.

/**

 * lpfc_get_host_fabric_name - Set the value of the scsi host fabric name

 * @shost: kernel scsi host pointer.

 fabric is local port if there is no F/FL_Port */

/**

 * lpfc_get_stats - Return statistical information about the adapter

 * @shost: kernel scsi host pointer.

 *

 * Notes:

 * NULL on error for link down, no mbox pool, sli2 active,

 * management not allowed, memory allocation error, or mbox error.

 *

 * Returns:

 * NULL for error

 * address of the adapter host statistics

	/*

	 * prevent udev from issuing mailbox commands until the port is

	 * configured.

	/*

	 * The MBX_READ_STATUS returns tx_k_bytes which has to

	 * converted to words

/**

 * lpfc_reset_stats - Copy the adapter link stats information

 * @shost: kernel scsi host pointer.

 reset request */

/*

 * The LPFC driver treats linkdown handling as target loss events so there

 * are no sysfs handlers for link_down_tmo.

/**

 * lpfc_get_node_by_target - Return the nodelist for a target

 * @starget: kernel scsi target pointer.

 *

 * Returns:

 * address of the node list if found

 * NULL target not found

 Search for this, mapped, target ID */

/**

 * lpfc_get_starget_port_id - Set the target port id to the ndlp DID or -1

 * @starget: kernel scsi target pointer.

/**

 * lpfc_get_starget_node_name - Set the target node name

 * @starget: kernel scsi target pointer.

 *

 * Description: Set the target node name to the ndlp node name wwn or zero.

/**

 * lpfc_get_starget_port_name - Set the target port name

 * @starget: kernel scsi target pointer.

 *

 * Description:  set the target port name to the ndlp port name wwn or zero.

/**

 * lpfc_set_rport_loss_tmo - Set the rport dev loss tmo

 * @rport: fc rport address.

 * @timeout: new value for dev loss tmo.

 *

 * Description:

 * If timeout is non zero set the dev_loss_tmo to timeout, else set

 * dev_loss_tmo to one.

/*

 * lpfc_rport_show_function - Return rport target information

 *

 * Description:

 * Macro that uses field to generate a function with the name lpfc_show_rport_

 *

 * lpfc_show_rport_##field: returns the bytes formatted in buf

 * @cdev: class converted to an fc_rport.

 * @buf: on return contains the target_field or zero.

 *

 * Returns: size of formatted string.

/**

 * lpfc_set_vport_symbolic_name - Set the vport's symbolic name

 * @fc_vport: The fc_vport who's symbolic name has been changed.

 *

 * Description:

 * This function is called by the transport after the @fc_vport's symbolic name

 * has been changed. This function re-registers the symbolic name with the

 * switch to propagate the change into the fabric if the vport is active.

/**

 * lpfc_hba_log_verbose_init - Set hba's log verbose level

 * @phba: Pointer to lpfc_hba struct.

 * @verbose: Verbose level to set.

 *

 * This function is called by the lpfc_get_cfgparam() routine to set the

 * module lpfc_log_verbose into the @phba cfg_log_verbose for use with

 * log message according to the module's lpfc_log_verbose parameter setting

 * before hba port or vport created.

 fixed attributes the driver supports */

 dynamic attributes the driver supports */

 active_fc4s is shown but doesn't change (thus no get function) */

	/*

	 * The LPFC driver treats linkdown handling as target loss events

	 * so there are no sysfs handlers for link_down_tmo.

 fixed attributes the driver supports */

 dynamic attributes the driver supports */

 active_fc4s is shown but doesn't change (thus no get function) */

	/*

	 * The LPFC driver treats linkdown handling as target loss events

	 * so there are no sysfs handlers for link_down_tmo.

/**

 * lpfc_get_hba_function_mode - Used to determine the HBA function in FCoE

 * Mode

 * @phba: lpfc_hba pointer.

 If the adapter supports FCoE mode */

 for others, clear the flag */

/**

 * lpfc_get_cfgparam - Used during probe_one to init the adapter structure

 * @phba: lpfc_hba pointer.

 VMID Inits */

 Get the function mode */

 BlockGuard allowed for FC only. */

 If set, clear the BlockGuard support param */

 Initialize first burst. Target vs Initiator are different. */

 100 ms default */

 NVME only supported on SLI4 */

 We MUST have FCP support */

 A value of 0 means use the number of CPUs found in the system */

/**

 * lpfc_nvme_mod_param_dep - Adjust module parameter value based on

 * dependencies between protocols and roles.

 * @phba: lpfc_hba pointer.

 Adjust lpfc_nvmet_mrq to avoid running out of WQE slots */

 Not NVME Target mode.  Turn off Target parameters. */

/**

 * lpfc_get_vport_cfgparam - Used during port create, init the vport structure

 * @vport: lpfc_vport pointer.

/*******************************************************************

 * This file is part of the Emulex Linux Device Driver for         *

 * Fibre Channel Host Bus Adapters.                                *

 * Copyright (C) 2017-2021 Broadcom. All Rights Reserved. The term *

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.     *

 * Copyright (C) 2004-2016 Emulex.  All rights reserved.           *

 * EMULEX and SLI are trademarks of Emulex.                        *

 * www.broadcom.com                                                *

 * Portions Copyright (C) 2004-2005 Christoph Hellwig              *

 *                                                                 *

 * This program is free software; you can redistribute it and/or   *

 * modify it under the terms of version 2 of the GNU General       *

 * Public License as published by the Free Software Foundation.    *

 * This program is distributed in the hope that it will be useful. *

 * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *

 * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *

 * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *

 * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *

 * TO BE LEGALLY INVALID.  See the GNU General Public License for  *

 * more details, a copy of which can be found in the file COPYING  *

 * included with this package.                                     *

 Setup WQE templates for NVME IOs */

 TSEND template */

 Word 0, 1, 2 - BDE is variable */

 Word 3 - payload_offset_len is zero */

 Word 4 - relative_offset is variable */

 Word 5 - is zero */

 Word 6 - ctxt_tag, xri_tag is variable */

 Word 7 - wqe_ar is variable */

 Word 8 - abort_tag is variable */

 Word 9  - reqtag, rcvoxid is variable */

 Word 10 - wqes, xc is variable */

 Word 11 - sup, irsp, irsplen is variable */

 Word 12 - fcp_data_len is variable */

 Word 13, 14, 15 - PBDE is zero */

 TRECEIVE template */

 Word 0, 1, 2 - BDE is variable */

 Word 3 */

 Word 4 - relative_offset is variable */

 Word 5 - is zero */

 Word 6 - ctxt_tag, xri_tag is variable */

 Word 7 */

 Word 8 - abort_tag is variable */

 Word 9  - reqtag, rcvoxid is variable */

 Word 10 - xc is variable */

 Word 11 - pbde is variable */

 Word 12 - fcp_data_len is variable */

 Word 13, 14, 15 - PBDE is variable */

 TRSP template */

 Word 0, 1, 2 - BDE is variable */

 Word 3 - response_len is variable */

 Word 4, 5 - is zero */

 Word 6 - ctxt_tag, xri_tag is variable */

 Word 7 */

 wqe_ar */

 Word 8 - abort_tag is variable */

 Word 9  - reqtag is variable */

 Word 10 wqes, xc is variable */

 Word 11 irsp, irsplen is variable */

 Word 12, 13, 14, 15 - is zero */

/**

 * __lpfc_nvme_xmt_ls_rsp_cmp - Generic completion handler for the

 *         transmission of an NVME LS response.

 * @phba: Pointer to HBA context object.

 * @cmdwqe: Pointer to driver command WQE object.

 * @wcqe: Pointer to driver response CQE object.

 *

 * The function is called from SLI ring event handler with no

 * lock held. The function frees memory resources used for the command

 * used to send the NVME LS RSP.

/**

 * lpfc_nvmet_xmt_ls_rsp_cmp - Completion handler for LS Response

 * @phba: Pointer to HBA context object.

 * @cmdwqe: Pointer to driver command WQE object.

 * @wcqe: Pointer to driver response CQE object.

 *

 * The function is called from SLI ring event handler with no

 * lock held. This function is the completion handler for NVME LS commands

 * The function updates any states and statistics, then calls the

 * generic completion handler to free resources.

/**

 * lpfc_nvmet_ctxbuf_post - Repost a NVMET RQ DMA buffer and clean up context

 * @phba: HBA buffer is associated with

 * @ctx_buf: ctx buffer context

 *

 * Description: Frees the given DMA buffer in the appropriate way given by

 * reposting it to its associated RQ so it can be reused.

 *

 * Notes: Takes phba->hbalock.  Can be called with or without other locks held.

 *

 * Returns: None

 check if freed in another path whilst acquiring lock */

 repost */

 NOTE: isr time stamp is stale when context is re-assigned*/

 Indicate that a replacement buffer has been posted */

	/*

	 * Use the CPU context list, from the MRQ the IO was received on

	 * (ctxp->idx), to save context structure.

	/*

	 * Segment 1 - Time from FCP command received by MSI-X ISR

	 * to FCP command is passed to NVME Layer.

	 * Segment 2 - Time from FCP command payload handed

	 * off to NVME Layer to Driver receives a Command op

	 * from NVME Layer.

	 * Segment 3 - Time from Driver receives a Command op

	 * from NVME Layer to Command is put on WQ.

	 * Segment 4 - Time from Driver WQ put is done

	 * to MSI-X ISR for Command cmpl.

	 * Segment 5 - Time from MSI-X ISR for Command cmpl to

	 * Command cmpl is passed to NVME Layer.

	 * Segment 6 - Time from Command cmpl is passed to NVME

	 * Layer to Driver receives a RSP op from NVME Layer.

	 * Segment 7 - Time from Driver receives a RSP op from

	 * NVME Layer to WQ put is done on TRSP FCP Status.

	 * Segment 8 - Time from Driver WQ put is done on TRSP

	 * FCP Status to MSI-X ISR for TRSP cmpl.

	 * Segment 9 - Time from MSI-X ISR for TRSP cmpl to

	 * TRSP cmpl is passed to NVME Layer.

	 * Segment 10 - Time from FCP command received by

	 * MSI-X ISR to command is completed on wire.

	 * (Segments 1 thru 8) for READDATA / WRITEDATA

	 * (Segments 1 thru 4) for READDATA_RSP

 For auto rsp commands seg6 thru seg10 will be 0 */

/**

 * lpfc_nvmet_xmt_fcp_op_cmp - Completion handler for FCP Response

 * @phba: Pointer to HBA context object.

 * @cmdwqe: Pointer to driver command WQE object.

 * @wcqe: Pointer to driver response CQE object.

 *

 * The function is called from SLI ring event handler with no

 * lock held. This function is the completion handler for NVME FCP commands

 * The function frees memory resources used for the NVME commands.

 pick up SLI4 exhange busy condition */

 Sanity check */

 lpfc_nvmet_xmt_fcp_release() will recycle the context */

/**

 * __lpfc_nvme_xmt_ls_rsp - Generic service routine to issue transmit

 *         an NVME LS rsp for a prior NVME LS request that was received.

 * @axchg: pointer to exchange context for the NVME LS request the response

 *         is for.

 * @ls_rsp: pointer to the transport LS RSP that is to be sent

 * @xmt_ls_rsp_cmp: completion routine to call upon RSP transmit done

 *

 * This routine is used to format and send a WQE to transmit a NVME LS

 * Response.  The response is for a prior NVME LS request that was

 * received and posted to the transport.

 *

 * Returns:

 *  0 : if response successfully transmit

 *  non-zero : if response failed to transmit, of the form -Exxx.

 Save numBdes for bpl2sgl */

	/*

	 * Note: although we're using stack space for the dmabuf, the

	 * call to lpfc_sli4_issue_wqe is synchronous, so it will not

	 * be referenced after it returns back to this routine.

 clear to be sure there's no reference */

		/*

		 * Okay to repost buffer here, but wait till cmpl

		 * before freeing ctxp and iocbq.

 Give back resources */

	/*

	 * As transport doesn't track completions of responses, if the rsp

	 * fails to send, the transport will effectively ignore the rsp

	 * and consider the LS done. However, the driver has an active

	 * exchange open for the LS - so be sure to abort the exchange

	 * if the response isn't sent.

/**

 * lpfc_nvmet_xmt_ls_rsp - Transmit NVME LS response

 * @tgtport: pointer to target port that NVME LS is to be transmit from.

 * @ls_rsp: pointer to the transport LS RSP that is to be sent

 *

 * Driver registers this routine to transmit responses for received NVME

 * LS requests.

 *

 * This routine is used to format and send a WQE to transmit a NVME LS

 * Response. The ls_rsp is used to reverse-map the LS to the original

 * NVME LS request sequence, which provides addressing information for

 * the remote port the LS to be sent to, as well as the exchange id

 * that is the LS is bound to.

 *

 * Returns:

 *  0 : if response successfully transmit

 *  non-zero : if response failed to transmit, of the form -Exxx.

		/*

		 * unless the failure is due to having already sent

		 * the response, an abort will be generated for the

		 * exchange if the rsp can't be sent.

 Setup the hdw queue if not already set */

 Setup cpu for cmpl check */

 Sanity check */

		/*

		 * WQ was full, so queue nvmewqeq to be sent after

		 * WQE release CQE

 Give back resources */

 release any threads waiting for the unreg to complete */

	/* Since iaab/iaar are NOT set, we need to check

	 * if the firmware is in process of aborting IO

	/* A state of LPFC_NVME_STE_RCV means we have just received

	 * the NVME command and have not started processing it.

	 * (by issuing any IO WQEs on this exchange yet)

 let the abort path do the real release */

 Free the nvmebuf since a new buffer already replaced it */

/**

 * lpfc_nvmet_ls_req_cmp - completion handler for a nvme ls request

 * @phba: Pointer to HBA context object

 * @cmdwqe: Pointer to driver command WQE object.

 * @wcqe: Pointer to driver response CQE object.

 *

 * This function is the completion handler for NVME LS requests.

 * The function updates any states and statistics, then calls the

 * generic completion handler to finish completion of the request.

/**

 * lpfc_nvmet_ls_req - Issue an Link Service request

 * @targetport: pointer to target instance registered with nvmet transport.

 * @hosthandle: hosthandle set by the driver in a prior ls_rqst_rcv.

 *               Driver sets this value to the ndlp pointer.

 * @pnvme_lsreq: the transport nvme_ls_req structure for the LS

 *

 * Driver registers this routine to handle any link service request

 * from the nvme_fc transport to a remote nvme-aware port.

 *

 * Return value :

 *   0 - Success

 *   non-zero: various error codes, in form of -Exxx

/**

 * lpfc_nvmet_ls_abort - Abort a prior NVME LS request

 * @targetport: Transport targetport, that LS was issued from.

 * @hosthandle: hosthandle set by the driver in a prior ls_rqst_rcv.

 *               Driver sets this value to the ndlp pointer.

 * @pnvme_lsreq: the transport nvme_ls_req structure for LS to be aborted

 *

 * Driver registers this routine to abort an NVME LS request that is

 * in progress (from the transports perspective).

 optional features */

 sizes of additional private data for data structures */

 The first context list, MRQ 0 CPU 0 */

 Cycle the the entire CPU context list for every MRQ */

	/*

	 * Assuming X CPUs in the system, and Y MRQs, allocate some

	 * lpfc_nvmet_ctx_info structures as follows:

	 *

	 * cpu0/mrq0 cpu1/mrq0 ... cpuX/mrq0

	 * cpu0/mrq1 cpu1/mrq1 ... cpuX/mrq1

	 * ...

	 * cpuX/mrqY cpuX/mrqY ... cpuX/mrqY

	 *

	 * Each line represents a MRQ "silo" containing an entry for

	 * every CPU.

	 *

	 * MRQ X is initially assumed to be associated with CPU X, thus

	 * contexts are initially distributed across all MRQs using

	 * the MRQ index (N) as follows cpuN/mrqN. When contexts are

	 * freed, the are freed to the MRQ silo based on the CPU number

	 * of the IO completion. Thus a context that was allocated for MRQ A

	 * whose IO completed on CPU B will be freed to cpuB/mrqA.

	/*

	 * Setup the next CPU context info ptr for each MRQ.

	 * MRQ 0 will cycle thru CPUs 0 - X separately from

	 * MRQ 1 cycling thru CPUs 0 - X, and so on.

	/* For all nvmet xris, allocate resources needed to process a

	 * received command on a per xri basis.

 Initialize WQE */

		/*

		 * Add ctx to MRQidx context list. Our initial assumption

		 * is MRQidx will be associated with CPUidx. This association

		 * can change on the fly.

 Spread ctx structures evenly across all MRQs */

	/* We need to tell the transport layer + 1 because it takes page

	 * alignment into account. When space for the SGL is allocated we

	 * allocate + 3, one for cmd, one for rsp and one for this alignment

/**

 * lpfc_sli4_nvmet_xri_aborted - Fast-path process of nvmet xri abort

 * @phba: pointer to lpfc hba data structure.

 * @axri: pointer to the nvmet xri abort wcqe structure.

 *

 * This routine is invoked by the worker thread to process a SLI4 fast-path

 * NVMET aborted xri.

		/* Check if we already received a free context call

		 * and we have completed processing an abort situation.

		/*

		 *  Abort already done by FW, so BA_ACC sent.

		 *  However, the transport may be unaware.

 Respond with BA_ACC accordingly */

 check the wait list */

 match by oxid and s_id */

 free buffer since already posted a new DMA buffer to RQ */

 Respond with BA_ACC accordingly */

 check active list */

 Notify the transport */

 Respond with BA_RJT accordingly */

 Fake an ABORT error code back to cmpl routine */

 Checking for a specific IO to flush */

 Flush all IOs */

	/*

	 * Some WQE slots are available, so try to re-issue anything

	 * on the WQ wqfull_list.

 WQ was full again, so put it back on the list */

/**

 * lpfc_nvmet_handle_lsreq - Process an NVME LS request

 * @phba: pointer to lpfc hba data structure.

 * @axchg: pointer to exchange context for the NVME LS request

 *

 * This routine is used for processing an asychronously received NVME LS

 * request. Any remaining validation is done and the LS is then forwarded

 * to the nvmet-fc transport via nvmet_fc_rcv_ls_req().

 *

 * The calling sequence should be: nvmet_fc_rcv_ls_req() -> (processing)

 * -> lpfc_nvmet_xmt_ls_rsp/cmp -> req->done.

 * lpfc_nvme_xmt_ls_rsp_cmp should free the allocated axchg.

 *

 * Returns 0 if LS was handled and delivered to the transport

 * Returns 1 if LS failed to be handled and should be dropped

	/*

	 * Driver passes the ndlp as the hosthandle argument allowing

	 * the transport to generate LS requests for any associateions

	 * that are created.

	/*

	 * The calling sequence should be:

	 * nvmet_fc_rcv_fcp_req->lpfc_nvmet_xmt_fcp_op/cmp- req->done

	 * lpfc_nvmet_xmt_fcp_op_cmp should free the allocated ctxp.

	 * When we return from nvmet_fc_rcv_fcp_req, all relevant info

	 * the NVME command / FC header is stored.

	 * A buffer has already been reposted for this IO, so just free

	 * the nvmebuf.

 Process FCP command */

 repost */

 Processing of FCP command is deferred */

		/*

		 * Post a replacement DMA buffer to RQ and defer

		 * freeing rcv buffer till .defer_rcv callback

	/*

	 * The current_infop for the MRQ a NVME command IU was received

	 * on is empty. Our goal is to replenish this MRQs context

	 * list from a another CPUs.

	 *

	 * First we need to pick a context list to start looking on.

	 * nvmet_ctx_start_cpu has available context the last time

	 * we needed to replenish this CPU where nvmet_ctx_next_cpu

	 * is just the next sequential CPU for this MRQ.

 Just take the entire context list, if there are any */

 Otherwise, move on to the next CPU for this MRQ */

 Nothing found, all contexts for the MRQ are in-flight */

/**

 * lpfc_nvmet_unsol_fcp_buffer - Process an unsolicited event data buffer

 * @phba: pointer to lpfc hba data structure.

 * @idx: relative index of MRQ vector

 * @nvmebuf: pointer to lpfc nvme command HBQ data structure.

 * @isr_timestamp: in jiffies.

 * @cqflag: cq processing information regarding workload.

 *

 * This routine is used for processing the WQE associated with a unsolicited

 * event. It first determines whether there is an existing ndlp that matches

 * the DID from the unsolicited WQE. If not, it will create a new one with

 * the DID from the unsolicited WQE. The ELS command from the unsolicited

 * WQE is then used to invoke the proper routine and to set up proper state

 * of the discovery state machine.

	/*

	 * Get a pointer to the context list for this MRQ based on

	 * the CPU this MRQ IRQ is associated with. If the CPU association

	 * changes from our initial assumption, the context list could

	 * be empty, thus it would need to be replenished with the

	 * context list from another CPU for this MRQ.

 Queue this NVME IO to process later */

 Post a brand new DMA buffer to RQ */

 check for cq processing load */

/**

 * lpfc_nvmet_unsol_fcp_event - Process an unsolicited event from an nvme nport

 * @phba: pointer to lpfc hba data structure.

 * @idx: relative index of MRQ vector

 * @nvmebuf: pointer to received nvme data structure.

 * @isr_timestamp: in jiffies.

 * @cqflag: cq processing information regarding workload.

 *

 * This routine is used to process an unsolicited event received from a SLI

 * (Service Level Interface) ring. The actual processing of the data buffer

 * associated with the unsolicited event is done by invoking the routine

 * lpfc_nvmet_unsol_fcp_buffer() after properly set up the buffer from the

 * SLI RQ on which the unsolicited event was received.

/**

 * lpfc_nvmet_prep_ls_wqe - Allocate and prepare a lpfc wqe data structure

 * @phba: pointer to a host N_Port data structure.

 * @ctxp: Context info for NVME LS Request

 * @rspbuf: DMA buffer of NVME command.

 * @rspsize: size of the NVME command.

 *

 * This routine is used for allocating a lpfc-WQE data structure from

 * the driver lpfc-WQE free-list and prepare the WQE with the parameters

 * passed into the routine for discovery state machine to issue an Extended

 * Link Service (NVME) commands. It is a generic lpfc-WQE allocation

 * and preparation routine that is used by all the discovery state machine

 * routines and the NVME command-specific fields will be later set up by

 * the individual discovery machine routines after calling this routine

 * allocating and preparing a generic WQE data structure. It fills in the

 * Buffer Descriptor Entries (BDEs), allocates buffers for both command

 * payload and response payload (if expected). The reference count on the

 * ndlp is incremented by 1 and the reference to the ndlp is put into

 * context1 of the WQE data structure for this WQE to hold the ndlp

 * reference for the command's callback function to access later.

 *

 * Return code

 *   Pointer to the newly allocated/prepared nvme wqe data structure

 *   NULL - when nvme wqe data structure allocation/preparation failed

 Allocate buffer for  command wqe */

 prevent preparing wqe with NULL ndlp reference */

 Words 0 - 2 */

 Word 3 */

 Word 4 */

 Word 5 */

 Word 6 */

 Word 7 */

 Word 8 */

 Word 9 */

 Needs to be set by caller */

 Word 10 */

 Word 11 */

 Word 12 */

 Xmit NVMET response to remote NPORT <did> */

 Allocate buffer for  command wqe */

 create new XRI */

 Sanity check */

 From the tsend template, initialize words 7 - 11 */

 Words 0 - 2 : The first sg segment */

 Word 3 */

 Word 4 */

 Word 5 */

 Word 6 */

 Word 7 - set ar later */

 Word 8 */

 Word 9 */

 Word 10 - set wqes later, in template xc=1 */

 Word 12 */

 Setup 2 SKIP SGEs */

 In template ar=1 wqes=0 sup=0 irsp=0 irsplen=0 */

 In template ar=1 wqes=0 sup=0 irsp=0 irsplen=0 */

 From the treceive template, initialize words 3 - 11 */

 Words 0 - 2 : First SGE is skipped, set invalid BDE type */

 Word 4 */

 Word 6 */

 Word 7 */

 Word 8 */

 Word 9 */

 Word 10 - in template xc=1 */

 Word 11 - check for pbde */

 Word 11 - PBDE bit already preset by template */

 Overwrite default template setting */

 Word 12 */

 Setup 2 SKIP SGEs */

 From the treceive template, initialize words 4 - 11 */

 Words 0 - 2 */

 Word 3 */

 Word 6 */

 Word 7 */

 Word 8 */

 Word 9 */

 Word 10 */

 Word 11 */

 In template wqes=0 irsp=0 irsplen=0 - good response */

 Bad response - embed it */

 Word 12 */

 Use rspbuf, NOT sg list */

 decrement sgl ptr backwards once to first data sge */

 Words 13-15 (PBDE) */

/**

 * lpfc_nvmet_sol_fcp_abort_cmp - Completion handler for ABTS

 * @phba: Pointer to HBA context object.

 * @cmdwqe: Pointer to driver command WQE object.

 * @wcqe: Pointer to driver response CQE object.

 *

 * The function is called from SLI ring event handler with no

 * lock held. This function is the completion handler for NVME ABTS for FCP cmds

 * The function frees memory resources used for the NVME commands.

	/* Check if we already received a free context call

	 * and we have completed processing an abort situation.

	/*

	 * if transport has released ctx, then can reuse it. Otherwise,

	 * will be recycled by transport release call.

 This is the iocbq for the abort, not the command */

	/* Since iaab/iaar are NOT set, there is no work left.

	 * For LPFC_NVME_XBUSY, lpfc_sli4_nvmet_xri_aborted

	 * should have been called already.

/**

 * lpfc_nvmet_unsol_fcp_abort_cmp - Completion handler for ABTS

 * @phba: Pointer to HBA context object.

 * @cmdwqe: Pointer to driver command WQE object.

 * @wcqe: Pointer to driver response CQE object.

 *

 * The function is called from SLI ring event handler with no

 * lock held. This function is the completion handler for NVME ABTS for FCP cmds

 * The function frees memory resources used for the NVME commands.

 if context is clear, related io alrady complete */

 Sanity check */

	/* Check if we already received a free context call

	 * and we have completed processing an abort situation.

	/*

	 * if transport has released ctx, then can reuse it. Otherwise,

	 * will be recycled by transport release call.

	/* Since iaab/iaar are NOT set, there is no work left.

	 * For LPFC_NVME_XBUSY, lpfc_sli4_nvmet_xri_aborted

	 * should have been called already.

/**

 * lpfc_nvmet_xmt_ls_abort_cmp - Completion handler for ABTS

 * @phba: Pointer to HBA context object.

 * @cmdwqe: Pointer to driver command WQE object.

 * @wcqe: Pointer to driver response CQE object.

 *

 * The function is called from SLI ring event handler with no

 * lock held. This function is the completion handler for NVME ABTS for LS cmds

 * The function frees memory resources used for the NVME commands.

 No failure to an ABTS request. */

	/*

	 * Since we zero the whole WQE, we need to ensure we set the WQE fields

	 * that were initialized in lpfc_sli4_nvmet_alloc.

 Word 5 */

 Word 6 */

 Word 7 */

 Word 8 */

 Word 9 */

 Needs to be set by caller */

 Word 10 */

 Word 11 */

 hba_wqidx should already be setup from command we are aborting */

/**

 * lpfc_nvmet_prep_abort_wqe - set up 'abort' work queue entry.

 * @pwqeq: Pointer to command iocb.

 * @xritag: Tag that  uniqely identifies the local exchange resource.

 * @opt: Option bits -

 *		bit 0 = inhibit sending abts on the link

 *

 * This function is called with hbalock held.

	/* WQEs are reused.  Clear stale data and set key fields to

	 * zero like ia, iaab, iaar, xri_tag, and ctxt_tag.

 Abort specified xri tag, with the mask deliberately zeroed */

 Abort the I/O associated with this outstanding exchange ID. */

 iotag for the wqe completion. */

 No failure to an ABTS request. */

 Issue ABTS for this WQE based on iotag */

 No failure to an ABTS request. */

 Announce entry to new IO submit field. */

	/* If the hba is getting reset, this flag is set.  It is

	 * cleared when the reset is complete and rings reestablished.

 driver queued commands are in process of being flushed */

 Outstanding abort is in progress */

 Ready - mark outstanding as aborted by driver. */

 ABTS WQE must go to the same WQ as the WQE to be aborted */

/**

 * lpfc_nvme_unsol_ls_issue_abort - issue ABTS on an exchange received

 *        via async frame receive where the frame is not handled.

 * @phba: pointer to adapter structure

 * @ctxp: pointer to the asynchronously received received sequence

 * @sid: address of the remote port to send the ABTS to

 * @xri: oxid value to for the ABTS (other side's exchange id).

 Issue ABTS for this WQE based on iotag */

 No failure to an ABTS request. */

/**

 * lpfc_nvmet_invalidate_host

 *

 * @phba: pointer to the driver instance bound to an adapter port.

 * @ndlp: pointer to an lpfc_nodelist type

 *

 * This routine upcalls the nvmet transport to invalidate an NVME

 * host to which this target instance had active connections.

	/* Do not invalidate any nodes that do not have a hosthandle.

	 * The host_release callbk will cause a node reference

	 * count imbalance and a crash.

 Need to get the nvmet_fc_target_port pointer here.*/

 SPDX-License-Identifier: (GPL-2.0 OR MPL-1.1)

/*

 * Driver for Future Domain-compatible PCMCIA SCSI cards

 * Copyright 2019 Ondrej Zary

 *

 * The initial developer of the original code is David A. Hinds

 * <dahinds@users.sourceforge.net>.  Portions created by David A. Hinds

 * are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.

/*======================================================================



    A driver for the Qlogic SCSI card



    qlogic_cs.c 1.79 2000/06/12 21:27:26



    The contents of this file are subject to the Mozilla Public

    License Version 1.1 (the "License"); you may not use this file

    except in compliance with the License. You may obtain a copy of

    the License at http://www.mozilla.org/MPL/



    Software distributed under the License is distributed on an "AS

    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or

    implied. See the License for the specific language governing

    rights and limitations under the License.



    The initial developer of the original code is David A. Hinds

    <dahinds@users.sourceforge.net>.  Portions created by David A. Hinds

    are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.



    Alternatively, the contents of this file may be used under the

    terms of the GNU General Public License version 2 (the "GPL"), in which

    case the provisions of the GPL are applicable instead of the

    above.  If you wish to allow the use of your version of this file

    only under the terms of the GPL and not to allow others to use

    your version of this file under the MPL, indicate your decision

    by deleting the provisions above and replace them with the notice

    and other provisions required by the GPL.  If you do not delete

    the provisions above, a recipient may use your version of this

    file under either the MPL or the GPL.

    

/* Set the following to 2 to use normal interrupt (active high/totempole-

 * tristate), otherwise use 0 (REQUIRED FOR PCMCIA) for active low, open

 * drain

====================================================================*/

 type of chip */

 registered host structure */

 if no ID, use 7 */

 Create new SCSI device */

 qlogic_attach */

====================================================================*/

 qlogic_detach */

====================================================================*/

 set ATAcmd */

 The KXL-810AN has a bigger IO port window */

 qlogic_config */

====================================================================*/

====================================================================*/

 Ugggglllyyyy!!! */

 these conflict with other cards! */

 PCMCIA_DEVICE_PROD_ID123("MACNICA", "MIRACLE SCSI", "mPS100", 0x20841b68, 0xf8dedaeb, 0x89f7fafb), */

 PCMCIA_DEVICE_PROD_ID123("MACNICA", "MIRACLE SCSI", "mPS100", 0x20841b68, 0xf8dedaeb, 0x89f7fafb), */

/*======================================================================



    NinjaSCSI-3 / NinjaSCSI-32Bi PCMCIA SCSI host adapter card driver

      By: YOKOTA Hiroshi <yokota@netlab.is.tsukuba.ac.jp>



    Ver.2.8   Support 32bit MMIO mode

              Support Synchronous Data Transfer Request (SDTR) mode

    Ver.2.0   Support 32bit PIO mode

    Ver.1.1.2 Fix for scatter list buffer exceeds

    Ver.1.1   Support scatter list

    Ver.0.1   Initial version



    This software may be used and distributed according to the terms of

    the GNU General Public License.



/***********************************************************************

    This driver is for these PCcards.



	I-O DATA PCSC-F	 (Workbit NinjaSCSI-3)

			"WBT", "NinjaSCSI-3", "R1.0"

	I-O DATA CBSC-II (Workbit NinjaSCSI-32Bi in 16bit mode)

			"IO DATA", "CBSC16	 ", "1"



====================================================================*/

 Parameters that can be set with 'insmod' */

 Release IO ports after configuration? */

	.eh_abort_handler	 = nsp_eh_abort,*/

 attach <-> detect glue */

/*

 * debug, error print

 */

**********************************************************/

/*====================================================

 * Clenaup parameters and call done() functions.

 * You must be set SCpnt->result before call this function.

unsigned int host_id = SCpnt->device->host->this_id;*/

unsigned int base    = SCpnt->device->host->io_port;*/

nsp_dbg(NSP_DEBUG_QUEUECOMMAND, "before CurrentSC=0x%p", data->CurrentSC);

	/* XXX: pcmcia-cs generates SCSI command with "scsi_info" utility.

	/* setup scratch area

	   SCp.ptr		: buffer pointer

	   SCp.this_residual	: buffer length

	   SCp.buffer		: next buffer

	   SCp.buffers_residual : left buffers in list

nsp_dbg(NSP_DEBUG_QUEUECOMMAND, "out");

/*

 * setup PIO FIFO transfer mode and enable/disable to data out

nsp_dbg(NSP_DEBUG_DATA_IO, "enabled=%d", enabled);

 setup sync data */

/*

 * Initialize Ninja hardware

 block all interrupts */

 setup SCSI interface */

 setup fifo asic */

 requires 2 times!! */

 enable interrupts and ack them */

/*

 * Start selection phase

nsp_dbg(NSP_DEBUG_RESELECTION, "in");

nsp_dbg(NSP_DEBUG_RESELECTION, "bus busy");

 start arbitration */

nsp_dbg(NSP_DEBUG_RESELECTION, "start arbit");

 XXX: what a stupid chip! */

nsp_dbg(NSP_DEBUG_RESELECTION, "arbit=%d, wait_count=%d", arbit, wait_count);

 hold 1.2us */

nsp_dbg(NSP_DEBUG_RESELECTION, "arbit fail");

 assert select line */

nsp_dbg(NSP_DEBUG_RESELECTION, "assert SEL line");

 wait 2.4us */

 wait >1.2us */

udelay(1);*/ 
 check selection timeout */

 20MB	  50ns*/

 10MB	 100ns*/ 

 7.5MB 150ns*/ 

 5MB	 200ns*/

 10MB	 100ns*/ 

 7.5MB 150ns*/ 

 5MB	 200ns*/

/*

 * setup synchronous data transfer mode

	unsigned char	       lun    = SCpnt->device->lun;

		/*

		 * No proper period/offset found

/*

 * start ninja hardware timer

nsp_dbg(NSP_DEBUG_INTR, "in SCpnt=0x%p, time=%d", SCpnt, time);

/*

 * wait for bus phase change

nsp_dbg(NSP_DEBUG_INTR, "in");

/*

 * expect Ninja Irq

nsp_dbg(NSP_DEBUG_INTR, "current_phase=0x%x, mask=0x%x", current_phase, mask);

nsp_dbg(NSP_DEBUG_INTR, "ret -1");

nsp_dbg(NSP_DEBUG_INTR, "ret 0 found scsi signal");

nsp_dbg(NSP_DEBUG_INTR, "ret 1 phase=0x%x", phase);

nsp_dbg(NSP_DEBUG_INTR, "timeout");

/*

 * transfer SCSI message

nsp_dbg(NSP_DEBUG_DATA_IO, "in");

 if last byte, negate ATN */

 read & write message */

/*

 * get extra SCSI data from fifo

nsp_dbg(NSP_DEBUG_DATA_IO, "in");

nsp_dbg(NSP_DEBUG_DATA_IO, "not use bypass quirk");

	/*

	 * XXX: NSP_QUIRK

	 * data phase skip only occures in case of SCSI_LOW_READ

/*

 * accept reselection

nsp_hw_data *data = (nsp_hw_data *)SCpnt->device->host->hostdata;

/*

 * count how many data transferd

 required this! */

nsp_dbg(NSP_DEBUG_DATA_IO, "count=0x%x", count);

 fifo size */

/*

 * read data in DATA IN phase

nsp_dbg(NSP_DEBUG_DATA_IO, "ptr=0x%p this=0x%x ocount=0x%x res=0x%x", SCpnt->SCp.ptr, SCpnt->SCp.this_residual, ocount, res);

 if some data available ? */

 phase changed? */

nsp_dbg(NSP_DEBUG_DATA_IO, " wait for data this=%d", SCpnt->SCp.this_residual);

 align 4 */

 align 4 */

nsp_dbg(NSP_DEBUG_DATA_IO, "ptr=0x%p this_residual=0x%x ocount=0x%x", SCpnt->SCp.ptr, SCpnt->SCp.this_residual, ocount);

 go to next scatter list if available */

nsp_dbg(NSP_DEBUG_DATA_IO, "scatterlist next timeout=%d", time_out);

nsp_dbg(NSP_DEBUG_DATA_IO, "page: 0x%p, off: 0x%x", SCpnt->SCp.buffer->page, SCpnt->SCp.buffer->offset);

/*

 * write data in DATA OUT phase

 Put back pointer */

 write all data? */

nsp_dbg(NSP_DEBUG_DATA_IO, "ptr=0x%p this=0x%x res=0x%x", SCpnt->SCp.ptr, SCpnt->SCp.this_residual, res);

 align 4 */

 align 4 */

 go to next scatter list if available */

nsp_dbg(NSP_DEBUG_DATA_IO, "scatterlist next");

/*

 * setup synchronous/asynchronous data transfer mode

	unsigned char  lun    = SCpnt->device->lun;

nsp_dbg(NSP_DEBUG_DATA_IO, "in SCpnt=0x%p", SCpnt);

 setup synch transfer registers */

 setup pdma fifo */

 clear ack counter */

/*

 * interrupt handler

nsp_dbg(NSP_DEBUG_INTR, "dev_id=0x%p", dev_id);

nsp_dbg(NSP_DEBUG_INTR, "host=0x%p", ((scsi_info_t *)dev_id)->host);

nsp_dbg(NSP_DEBUG_INTR, "&nsp_data_base=0x%p, dev_id=0x%p", &nsp_data_base, dev_id);

nsp_dbg(NSP_DEBUG_INTR, "base=0x%x", base);

	/*

	 * interrupt check

nsp_dbg(NSP_DEBUG_INTR, "irq_status=0x%x", irq_status);

nsp_dbg(NSP_DEBUG_INTR, "no irq/shared irq");

	/* XXX: IMPORTANT

	 * Do not read an irq_phase register if no scsi phase interrupt.

	 * Unless, you should lose a scsi phase interrupt.

nsp_dbg(NSP_DEBUG_INTR, "irq_phase=0x%x", irq_phase);

	/*

	 * timer interrupt handler (scsi vs timer interrupts)

nsp_dbg(NSP_DEBUG_INTR, "timercount=%d", data->TimerCount);

nsp_dbg(NSP_DEBUG_INTR, "stop timer");

nsp_dbg(NSP_DEBUG_INTR, "timer start");

	/*

	 * parse hardware SCSI irq reasons register

show_phase(tmpSC);

 *sync_neg = SYNC_NOT_YET;

nsp_dbg(NSP_DEBUG_INTR, "selection count=%d", data->SelectionTimeOut);

 attention assert */

nsp_dbg(NSP_DEBUG_INTR, "attention assert");

nsp_dbg(NSP_DEBUG_INTR, "phase reselect");

 *sync_neg = SYNC_NOT_YET;

	/*

	 * SCSI sequencer

nsp_dbg(NSP_DEBUG_INTR, "start scsi seq");

 normal disconnect */

		//*sync_neg       = SYNC_NOT_YET;



		/* all command complete and return status */

		if (tmpSC->SCp.Message == COMMAND_COMPLETE) {

			tmpSC->result = (DID_OK		             << 16) |

					((tmpSC->SCp.Message & 0xff) <<  8) |

					((tmpSC->SCp.Status  & 0xff) <<  0);

			nsp_dbg(NSP_DEBUG_INTR, "command complete result=0x%x", tmpSC->result);

			nsp_scsi_done(tmpSC);



			return IRQ_HANDLED;

		}



		return IRQ_HANDLED;

	}





	/* check unexpected bus free state */

	if (phase == 0) {

		nsp_msg(KERN_DEBUG, "unexpected bus free. irq_status=0x%x, phase=0x%x, irq_phase=0x%x", irq_status, phase, irq_phase);



		*sync_neg       = SYNC_NG;

		tmpSC->result   = DID_ERROR << 16;

		nsp_scsi_done(tmpSC);

		return IRQ_HANDLED;

	}



	switch (phase & BUSMON_PHASE_MASK) {

	case BUSPHASE_COMMAND:

		nsp_dbg(NSP_DEBUG_INTR, "BUSPHASE_COMMAND");

		if ((phase & BUSMON_REQ) == 0) {

			nsp_dbg(NSP_DEBUG_INTR, "REQ == 0");

			return IRQ_HANDLED;

		}



		tmpSC->SCp.phase = PH_COMMAND;



		nsp_nexus(tmpSC);



		/* write scsi command */

		nsp_dbg(NSP_DEBUG_INTR, "cmd_len=%d", tmpSC->cmd_len);

		nsp_index_write(base, COMMANDCTRL, CLEAR_COMMAND_POINTER);

		for (i = 0; i < tmpSC->cmd_len; i++) {

			nsp_index_write(base, COMMANDDATA, tmpSC->cmnd[i]);

		}

		nsp_index_write(base, COMMANDCTRL, CLEAR_COMMAND_POINTER | AUTO_COMMAND_GO);

		break;



	case BUSPHASE_DATA_OUT:

		nsp_dbg(NSP_DEBUG_INTR, "BUSPHASE_DATA_OUT");



		tmpSC->SCp.phase        = PH_DATA;

		tmpSC->SCp.have_data_in = IO_OUT;



		nsp_pio_write(tmpSC);



		break;



	case BUSPHASE_DATA_IN:

		nsp_dbg(NSP_DEBUG_INTR, "BUSPHASE_DATA_IN");



		tmpSC->SCp.phase        = PH_DATA;

		tmpSC->SCp.have_data_in = IO_IN;



		nsp_pio_read(tmpSC);



		break;



	case BUSPHASE_STATUS:

		nsp_dataphase_bypass(tmpSC);

		nsp_dbg(NSP_DEBUG_INTR, "BUSPHASE_STATUS");



		tmpSC->SCp.phase = PH_STATUS;



		tmpSC->SCp.Status = nsp_index_read(base, SCSIDATAWITHACK);

		nsp_dbg(NSP_DEBUG_INTR, "message=0x%x status=0x%x", tmpSC->SCp.Message, tmpSC->SCp.Status);



		break;



	case BUSPHASE_MESSAGE_OUT:

		nsp_dbg(NSP_DEBUG_INTR, "BUSPHASE_MESSAGE_OUT");

		if ((phase & BUSMON_REQ) == 0) {

			goto timer_out;

		}



		tmpSC->SCp.phase = PH_MSG_OUT;



*sync_neg = SYNC_NOT_YET;

*/

*/

*/

nsp_dbg(NSP_DEBUG_INTR, "sync target=%d,lun=%d",target,lun);

nsp_dbg(NSP_DEBUG_INTR, "sync ok, %d %d", data->MsgBuffer[3], data->MsgBuffer[4]);

*/

 search last messeage byte */

nsp_dbg(NSP_DEBUG_INTR, "out");

 NSP_DEBUG */

----------------------------------------------------------------*/

 look for ninja3 card and init if found			  */

----------------------------------------------------------------*/

 registered host structure */

 detect done. */

----------------------------------------------------------------*/

 return info string						  */

----------------------------------------------------------------*/

---------------------------------------------------------------*/

 error handler                                                 */

---------------------------------------------------------------*/

/*

static int nsp_eh_abort(struct scsi_cmnd *SCpnt)

{

	nsp_dbg(NSP_DEBUG_BUSRESET, "SCpnt=0x%p", SCpnt);



	return nsp_eh_bus_reset(SCpnt);

 100ms */

 dummy read */

/**********************************************************************

  PCMCIA functions

 Create new SCSI device */

 nsp_cs_attach */

 nsp_cs_detach */

 This reserves IO space but doesn't actually enable it */

 If we got this far, we're cool! */

 Set port and IRQ */

 nsp_cs_config */

 Unlink the device chain */

 nsp_cs_release */

/*======================================================================*

 *	module entry point

 end */

/*========================================================================

    Debug routines for nsp_cs

      By: YOKOTA Hiroshi <yokota@netlab.is.tsukuba.ac.jp>



    This software may be used and distributed according to the terms of

    the GNU General Public License.

 $Id: nsp_debug.c,v 1.3 2003/07/26 14:21:09 elca Exp $ */

/*

 * Show the command data of a command

 00-03 */ "Test Unit Ready", "Rezero Unit", unknown, "Request Sense",

 04-07 */ "Format Unit", "Read Block Limits", unknown, "Reassign Blocks",

 08-0d */ "Read (6)", unknown, "Write (6)", "Seek (6)", unknown, unknown,

 0e-12 */ unknown, "Read Reverse", "Write Filemarks", "Space", "Inquiry",  

 13-16 */ unknown, "Recover Buffered Data", "Mode Select", "Reserve",

 17-1b */ "Release", "Copy", "Erase", "Mode Sense", "Start/Stop Unit",

 1c-1d */ "Receive Diagnostic", "Send Diagnostic", 

 1e-1f */ "Prevent/Allow Medium Removal", unknown,

 20-22 */  unknown, unknown, unknown,

 23-28 */ unknown, unknown, "Read Capacity", unknown, unknown, "Read (10)",

 29-2d */ unknown, "Write (10)", "Seek (10)", unknown, unknown,

 2e-31 */ "Write Verify","Verify", "Search High", "Search Equal",

 32-34 */ "Search Low", "Set Limits", "Prefetch or Read Position", 

 35-37 */ "Synchronize Cache","Lock/Unlock Cache", "Read Defect Data",

 38-3c */ "Medium Scan", "Compare","Copy Verify", "Write Buffer", "Read Buffer",

 3d-3f */ "Update Block", "Read Long",  "Write Long",

 40-41 */ "Change Definition", "Write Same", 

 42-48 */ "Read Sub-Ch(cd)", "Read TOC", "Read Header(cd)", "Play Audio(cd)", unknown, "Play Audio MSF(cd)", "Play Audio Track/Index(cd)", 

 49-4f */ "Play Track Relative(10)(cd)", unknown, "Pause/Resume(cd)", "Log Select", "Log Sense", unknown, unknown,

 50-55 */ unknown, unknown, unknown, unknown, unknown, "Mode Select (10)",

 56-5b */ unknown, unknown, unknown, unknown, "Mode Sense (10)", unknown,

 5c-5f */ unknown, unknown, unknown,

printk(KERN_DEBUG "%s ", __func__);*/

 vender specific */

 end */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

*  sym53c500_cs.c	Bob Tracy (rct@frus.com)

*

*  A rewrite of the pcmcia-cs add-on driver for newer (circa 1997)

*  New Media Bus Toaster PCMCIA SCSI cards using the Symbios Logic

*  53c500 controller: intended for use with 2.6 and later kernels.

*  The pcmcia-cs add-on version of this driver is not supported

*  beyond 2.4.  It consisted of three files with history/copyright

*  information as follows:

*

*  SYM53C500.h

*	Bob Tracy (rct@frus.com)

*	Original by Tom Corner (tcorner@via.at).

*	Adapted from NCR53c406a.h which is Copyrighted (C) 1994

*	Normunds Saumanis (normunds@rx.tech.swh.lv)

*

*  SYM53C500.c

*	Bob Tracy (rct@frus.com)

*	Original driver by Tom Corner (tcorner@via.at) was adapted

*	from NCR53c406a.c which is Copyrighted (C) 1994, 1995, 1996 

*	Normunds Saumanis (normunds@fi.ibm.com)

*

*  sym53c500.c

*	Bob Tracy (rct@frus.com)

*	Original by Tom Corner (tcorner@via.at) was adapted from a

*	driver for the Qlogic SCSI card written by

*	David Hinds (dhinds@allegro.stanford.edu).

/*

*  Set this to 0 if you encounter kernel lockups while transferring 

*  data in PIO mode.  Note this can be changed via "sysfs".

 =============== End of user configurable parameters ============== */

 ================================================================== */

 Synchronous transfer mode */

 Default configuration */

 ID=7 */

 FE SCSI2 */

 CDB */

 ANE */

 ? changed from b6= AA PI SIE POL */

 added for SYM53C500 t. corner */

 Hardware Registers: offsets from io_port (base) */

 Control Register Set 0 */

 transfer counter lsb */

 transfer counter msb */

 scsi fifo register */

 command register */

 status register */

 selection/reselection bus id */

 interrupt status register */

 select/reselect timeout reg */

 sequence step register */

 synchronous transfer period */

 indicates # of bytes in fifo */

 synchronous offset register */

 configuration register */

 clock conversion register */

 #define TESTREG	0x0A */		
 configuration 2 register */

 configuration 3 register */

 configuration 4 register */

 transfer counter high */

 #define FIFO_BOTTOM	0x0F */		
 Control Register Set 1 */

 #define JUMPER_SENSE	0x00 */		
 #define SRAM_PTR	0x01 */		
 #define SRAM_DATA	0x02 */		
 PIO FIFO registers (r/w) */

 #define PIO_FIFO1	0x05 */		
 #define PIO_FIFO2	0x06 */		
 #define PIO_FIFO3	0x07 */		
 PIO status (r/w) */

 #define ATA_CMD	0x09 */		
 #define ATA_ERR	0x0A */		
 PIO flag interrupt enable (r/w) */

 configuration 5 register */

 #define SIGNATURE	0x0E */		
 #define CONFIG6	0x0F */		
 select register set 0 */

 select register set 1 */

 Chip commands */

 ================================================================== */

/*

*  Repository for per-instance host data.

 ================================================================== */

 REG0(io_port); */

 clock conversion factor */

 Selection timeout */

 Synchronous transfer period */

 synchronous mode */  

 REG0(io_port); */

 required after reset */

 current scsi fifo size */

 VDEB(printk("pio_status=%x\n", i)); */

 fifo empty */

 fifo 1/3 full */

 fifo 2/3 full */

 fifo full */

 fifo empty and interrupt occurred */

 current scsi fifo size */

 VDEB(printk("pio_status=%x\n", i)); */

 error */

 SYM53C500_DEBUG */

 SCSI reset intr */

 Parity error */

 Gross error */

 Disconnect */

 Unexpected disconnect */

 Command complete, return status and message */

 scsi phase */

 DATA-OUT */

 Target requesting info transfer */

 Max transfer size */

 DATA-IN */

 Target requesting info transfer */

 Max transfer size */

 COMMAND */

 STATUS */

 Reserved */

 Reserved */

 MESSAGE-OUT */

 Reject the message */

 MESSAGE-IN */

 Reject message */

	/*

	*  Do this before releasing/freeing resources.

	/*

	*  Interrupts getting hosed on card removal.  Try

	*  the following code, mostly from qlogicfas.c.

 SYM53C500_release */

 We are locked here already by the mid layer */

 set destination */

 reset the fifos */

 heads */

 sectors */

 cylinders */

 big disk */

/*

*  SCSI HBA device attributes we want to

*  make available via sysfs.

/*

*  scsi_host_template initializer

	/*

	*  That's the trouble with copying liberally from another driver.

	*  Some things probably aren't relevant, and I suspect this entire

	*  section dealing with manufacturer IDs can be scrapped.	--rct

 set ATAcmd */

	/*

	*  irq_level == 0 implies tpnt->can_queue == 0, which

	*  is not supported in 2.6.  Thus, only irq_level > 0

	*  will be allowed.

	*

	*  Possible port_base values are as follows:

	*

	*	0x130, 0x230, 0x280, 0x290,

	*	0x320, 0x330, 0x340, 0x350

	/*

	*  Note fast_pio is set to USE_FAST_PIO by

	*  default, but can be changed via "sysfs".

 SYM53C500_config */

 See earlier comment about manufacturer IDs. */

	/*

	 *  If things don't work after a "resume",

	 *  this is a good place to start looking.

 SYM53C500_detach */

 Create new SCSI device */

 SYM53C500_attach */

/*==========================================================================

  NinjaSCSI-3 message handler

      By: YOKOTA Hiroshi <yokota@netlab.is.tsukuba.ac.jp>



   This software may be used and distributed according to the terms of

   the GNU General Public License.

 $Id: nsp_message.c,v 1.6 2003/07/26 14:21:09 elca Exp $ */

	/*

	 * XXX: NSP QUIRK

	 * NSP invoke interrupts only in the case of scsi phase changes,

	 * therefore we should poll the scsi phase here to catch 

	 * the next "msg in" if exists (no scsi phase changes).

 read data */

 assert ACK */

 deassert ACK */

 catch a next signal */

	/*

	 * XXX: NSP QUIRK

	 * NSP invoke interrupts only in the case of scsi phase changes,

	 * therefore we should poll the scsi phase here to catch 

	 * the next "msg out" if exists (no scsi phase changes).

 catch a next signal */

 end */

/*======================================================================



    A driver for Adaptec AHA152X-compatible PCMCIA SCSI cards.



    This driver supports the Adaptec AHA-1460, the New Media Bus

    Toaster, and the New Media Toast & Jam.

    

    aha152x_cs.c 1.54 2000/06/12 21:27:25



    The contents of this file are subject to the Mozilla Public

    License Version 1.1 (the "License"); you may not use this file

    except in compliance with the License. You may obtain a copy of

    the License at http://www.mozilla.org/MPL/



    Software distributed under the License is distributed on an "AS

    IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or

    implied. See the License for the specific language governing

    rights and limitations under the License.



    The initial developer of the original code is David A. Hinds

    <dahinds@users.sourceforge.net>.  Portions created by David A. Hinds

    are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.



    Alternatively, the contents of this file may be used under the

    terms of the GNU General Public License version 2 (the "GPL"), in which

    case the provisions of the GPL are applicable instead of the

    above.  If you wish to allow the use of your version of this file

    only under the terms of the GPL and not to allow others to use

    your version of this file under the MPL, indicate your decision

    by deleting the provisions above and replace them with the notice

    and other provisions required by the GPL.  If you do not delete

    the provisions above, a recipient may use your version of this

    file under either the MPL or the GPL.

    

====================================================================*/

 Parameters that can be set with 'insmod' */

 SCSI bus setup options */

====================================================================*/

 Create new SCSI device */

 aha152x_attach */

====================================================================*/

 Unlink device structure, free bits */

 aha152x_detach */

====================================================================*/

 For New Media T&J, look for a SCSI window */

 Set configuration options for the aha152x driver */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Marvell 88SE64xx hardware specific

 *

 * Copyright 2007 Red Hat, Inc.

 * Copyright 2008 Marvell. <kewei@marvell.com>

 * Copyright 2009-2011 Marvell. <yuxiangl@marvell.com>

 disable auto port detection */

 make sure interrupts are masked immediately (paranoia) */

 Reset Controller */

 make sure interrupts are masked immediately (paranoia) */

 Reset Controller */

 global reset, incl. COMRESET/H_RESET_N (self-clearing) */

 wait for reset to finish; timeout is just a guess */

 Init Chip */

 make sure RST is set; HBA_RST /should/ have done that for us */

 write to device control _AND_ device status register */

 reset control */

 MVS_PCS */

 init phys */

 enable auto port detection */

 set phy local SAS address */

 should set little endian SAS address to 64xx chip */

 set select registers */

 clear phy int status */

 set phy int mask */

 little endian for open address and command table, etc. */

 reset CMD queue */

	/*

	 * the max count is 0x1ff, while our max slot is 0x200,

	 * it will make count 0.

 ladies and gentlemen, start your engines */

 enable CMD/CMPL_Q/RESP mode */

 enable completion queue interrupt */

 Enable SRS interrupt */

 clear CMD_CMPLT ASAP */

	/*

	 * the max count is 0x1ff, while our max slot is 0x200,

	 * it will make count 0.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Marvell 88SE64xx/88SE94xx main function

 *

 * Copyright 2007 Red Hat, Inc.

 * Copyright 2008 Marvell. <kewei@marvell.com>

 * Copyright 2009-2011 Marvell. <yuxiangl@marvell.com>

 direct attached SAS device */

Nothing*/

	/*

	 * DMA-map SMP request, response buffers

 must be in dwords */

	/*

	 * arrange MVS_SLOT_BUF_SZ-sized DMA buffer according to our needs

 region 1: command table area (MVS_SSP_CMD_SZ bytes) ***** */

 region 2: open address frame area (MVS_OAF_SZ bytes) ********* */

 region 3: PRD table *********************************** */

 region 4: status buffer (larger the PRD, smaller this buf) ****** */

	/*

	 * Fill in TX ring and command slot header

 generate open address frame hdr (first 12 bytes) */

 initiator, SMP, ftype 1h */

 SAS SPEC */

 fill in PRD (scatter/gather) table, if any */

	/*

	 * arrange MVS_SLOT_BUF_SZ-sized DMA buffer according to our needs

 region 1: command table area (MVS_ATA_CMD_SZ bytes) ************** */

 region 2: open address frame area (MVS_OAF_SZ bytes) ********* */

 used for STP.  unused for SATA? */

 region 3: PRD table ********************************************* */

 region 4: status buffer (larger the PRD, smaller this buf) ****** */

 request, response lengths */

 C=1: update ATA cmd reg */

 fill in command FIS and ATAPI CDB */

 generate open address frame hdr (first 12 bytes) */

 initiator, STP, ftype 1h */

 fill in PRD (scatter/gather) table, if any */

	/*

	 * arrange MVS_SLOT_BUF_SZ-sized DMA buffer according to our needs

 region 1: command table area (MVS_SSP_CMD_SZ bytes) ************** */

 region 2: open address frame area (MVS_OAF_SZ bytes) ********* */

 region 3: PRD table ********************************************* */

 region 4: status buffer (larger the PRD, smaller this buf) ****** */

 request, response lengths */

 generate open address frame hdr (first 12 bytes) */

 initiator, SSP, ftype 1h */

 fill in SSP frame header (Command Table.SSP frame header) */

 fill in IU for TASK and Command Frame */

 fill in PRD (scatter/gather) table, if any */

		/*

		 * libsas will use dev->port, should

		 * not call task_done for sata

 do nothing */

 direct attached SAS device */

 Even TMF timed out, return direct. */

			/* no error, but return the number of bytes of

/*  Standard mandates link reset for ATA  (type 0)

 mandatory SAM-3 */

 If failed, fall-through I_T_Nexus reset */

 optional SAM-3 */

 The task is still in Lun, release it then */

 The task is not in Lun or failed, reset the phy */

  mandatory SAM-3, still need free task/slot info */

 if successful, clear the task and callback forwards.*/

 Descriptor format */

 Response Code	*/

 Sense Key */

 ASC	*/

 ASCQ	*/

 Response Code	*/

 Sense Key */

 Additional Sense Length */

 ASC */

 ASCQ */

 race condition*/

 when no device attaching, go ahead and complete by error handling*/

	/*

	 * error info record present; slot->response is 32 bit aligned but may

	 * not be 64 bit aligned, so check for zero in two 32 bit reads

 hw says status == 0, datapres == 0 */

 response frame present */

 clean cmpl queue in case request is already finished */

	/*

	* events is port event now ,

	* we need check the interrupt status which belongs to per port.

 whether driver is going to handle hot plug */

	/* the first dword in the RX ring is special: it contains

	 * a mirror of the hardware's RX producer index, so that

	 * we don't have to stall the CPU reading that register.

	 * The actual RX ring is offset by one dword, due to this.

 h/w hasn't touched RX ring yet */

	/* The CMPL_Q may come late, read from register and try again

	* note: if coalescing is enabled,

	* it will need to read from register every time for sure

 increment our internal RX consumer pointer */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Marvell 88SE64xx/88SE94xx pci init

 *

 * Copyright 2007 Red Hat, Inc.

 * Copyright 2008 Marvell. <kewei@marvell.com>

 * Copyright 2009-2011 Marvell. <yuxiangl@marvell.com>

	/*

	 * alloc and init our DMA areas

 Initialize tags */

		/*

		 * ioremap main and peripheral registers

 Marvell 9480/9485 (any vendor/model) */

 OCZ RevoDrive3 */

 OCZ RevoDrive3/zDriveR4 (exact model unknown) */

 OCZ RevoDrive3/zDriveR4 (exact model unknown) */

 OCZ RevoDrive3/zDriveR4 (exact model unknown) */

 OCZ RevoDrive3/zDriveR4 (exact model unknown) */

 OCZ RevoDrive3/zDriveR4 (exact model unknown) */

 OCZ RevoDrive3/zDriveR4 (exact model unknown) */

 OCZ RevoDrive3/zDriveR4 (exact model unknown) */

 OCZ RevoDrive3/zDriveR4 (exact model unknown) */

 OCZ RevoDrive3/zDriveR4 (exact model unknown) */

 terminate list */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Marvell 88SE94xx hardware specific

 *

 * Copyright 2007 Red Hat, Inc.

 * Copyright 2008 Marvell. <kewei@marvell.com>

 * Copyright 2009-2011 Marvell. <yuxiangl@marvell.com>

	/* Remap information for B0 chip:

	*

	* R0Ch -> R118h[15:0] (Adapted DFE F3 - F5 coefficient)

	* R0Dh -> R118h[31:16] (Generation 1 Setting 0)

	* R0Eh -> R11Ch[15:0]  (Generation 1 Setting 1)

	* R0Fh -> R11Ch[31:16] (Generation 2 Setting 0)

	* R10h -> R120h[15:0]  (Generation 2 Setting 1)

	* R11h -> R120h[31:16] (Generation 3 Setting 0)

	* R12h -> R124h[15:0]  (Generation 3 Setting 1)

	* R13h -> R124h[31:16] (Generation 4 Setting 0 (Reserved))

 A0 has a different set of registers */

 loop 3 times, set Gen 1, Gen 2, Gen 3 */

		/* Set:

		*

		* Transmitter Emphasis Enable

		* Transmitter Emphasis Amplitude

		* Transmitter Amplitude

 Set Transmitter Amplitude Adjust */

 Don't run this if A0/B0 */

 FFE Resistor and Capacitor */

	/* R10Ch DFE Resolution Control/Squelch and FFE Setting

	 *

	 * FFE_FORCE            [7]

	 * FFE_RES_SEL          [6:4]

	 * FFE_CAP_SEL          [3:0]

 Read from HBA_Info_Page */

	/* R064h PHY Mode Register 1

	 *

	 * DFE_DIS		18

 Hard coding */

 No defines in HBA_Info_Page */

	/* R110h DFE F0-F1 Coefficient Control/DFE Update Control

	 *

	 * DFE_UPDATE_EN        [11:6]

	 * DFE_FX_FORCE         [5:0]

 Hard coding */

 No defines in HBA_Info_Page */

	/* R1A0h Interface and Digital Reference Clock Control/Reserved_50h

	 *

	 * FFE_TRAIN_EN         3

 Hard coding */

 No defines in HBA_Info_Page */

Notice: this function must be called when phy is disabled*/

 support 1.5 Gbps */

 support 1.5, 3.0 Gbps */

 support 1.5, 3.0, 6.0 Gbps */

set default phy_rate = 6Gbps*/

 100kHz clock */

 (66 * 0,121 Hz?)*/

 3*4 data bits / PDU */

 Init Chip */

 make sure RST is set; HBA_RST /should/ have done that for us */

 disable Multiplexing, enable phy implemented */

 set 6G/3G/1.5G, multiplexing, without SSC */

 set 6G/3G/1.5G, multiplexing, with and without SSC */

 reset control */

 MVS_PCS */

 init phys */

 disable non data frame retry */

 set LED blink when IO*/

 set phy local SAS address */

 set select registers */

 clear phy int status */

 set phy int mask */

 little endian for open address and command table, etc. */

 reset CMD queue */

	/*

	 * the max count is 0x1ff, while our max slot is 0x200,

	 * it will make count 0.

 default interrupt coalescing time is 128us */

 ladies and gentlemen, start your engines */

 enable CMD/CMPL_Q/RESP mode */

 enable completion queue interrupt */

 tune STP performance */

 This can improve expander large block size seq write performance */

	/* change the connection open-close behavior (bit 9)

 set bit0 to 0 to enable retry for no_dest reject case */

 Enable SRS interrupt */

 enable spin up bit */

	/*

	 * the max count is 0x1ff, while our max slot is 0x200,

	 * it will make count 0.

 maximum supported bits = hosts * 4 drives * 3 bits */

 select host */

 drive number on host */

 bit offset of drive */

			/*

			* if bit is set then create a mask with the first

			* bit of the drive set in the mask ...

			/*

			* ... and then shift it to the right position based

			* on the led type (activity/id/fail)

 activity */

 hardwire activity bit to SOF */

 id */

 fail */

 SPDX-License-Identifier: GPL-2.0

/*

 *    driver for Microchip PQI-based storage controllers

 *    Copyright (c) 2019-2021 Microchip Technology Inc. and its subsidiaries

 *    Copyright (c) 2016-2018 Microsemi Corporation

 *    Copyright (c) 2016 PMC-Sierra, Inc.

 *

 *    Questions/Comments/Bugfixes to storagedev@microchip.com

 *

 for flags argument to pqi_submit_raid_request_synchronous() */

 also used for RAID 10 */

 also used for RAID 50 */

 also used for RAID 60 */

 also used for RAID 1+0 Triple */

 benignly racy */

 benignly racy */

 helper functions for pqi_send_scsi_raid_request */

	/*

	 * Tack the controller itself onto the end of the logical device list.

 The specified device is the controller. */

	/*

	 * Defer target and LUN assignment for non-controller physical devices

	 * because the SAS transport layer will make these assignments later.

 RAID 50/60 */

/*

 * Use vendor-specific VPD to determine online/offline status of a volume.

 Send an inquiry to the device to see what it is. */

/*

 * Prevent adding drive to OS for some corner cases such as a drive

 * undergoing a sanitize operation. Some OSes will continue to poll

 * the drive until the sanitize completes, which can take hours,

 * resulting in long bootup delays. Commands such as TUR, READ_CAP

 * are allowed, but READ/WRITE cause check condition. So the OS

 * cannot check/read the partition table.

 * Note: devices that have completed sanitize must be re-enabled

 *       using the management utility.

 Assume keep online */

 Do not check controllers. */

 Do not check LVs. */

 Assume not offline */

 Check for SANITIZE in progress using TUR */

 Assume not offline */

 Assume not offline */

		/*

		 * Check for sanitize in progress: asc:0x04, ascq: 0x1b

 Keep device offline */

 Assumes the SCSI device list lock is held. */

 Assumes the SCSI device list lock is held. */

 By definition, the scsi3addr and wwid fields are already the same. */

 To prevent this from being freed later. */

/*

 * Called when exposing a new device to the OS fails in order to re-adjust

 * our internal SCSI device list to match the SCSI ML's view.

 Allow the device structure to be freed later. */

	/*

	 * The idea here is to do as little work as possible while holding the

	 * spinlock.  That's why we go to great pains to defer anything other

	 * than updating the internal device list until after we release the

	 * spinlock.

 Assume that all devices in the existing list have gone away. */

			/*

			 * The newly found device is already in the existing

			 * device list.

			/*

			 * The newly found device is NOT in the existing device

			 * list.

			/*

			 * The original device has gone away and we need to add

			 * the new device.

 Process all devices that have gone away. */

 Process all new devices. */

 To prevent this device structure from being freed later. */

	/*

	 * If OFA is in progress and there are devices that need to be deleted,

	 * allow any pending reset operations to continue and unblock any SCSI

	 * requests before removal.

 Remove all devices that have gone away. */

	/*

	 * Notify the SCSI ML if the queue depth of any existing device has

	 * changed.

 Expose any new devices. */

	/*

	 * Only support the HBA controller itself as a RAID

	 * controller.  If it's a RAID controller other than

	 * the HBA itself (an external RAID controller, for

	 * example), we don't support it.

 Ignore all masked devices. */

		/*

		 * We need this buffer for calls to pqi_get_physical_disk_info()

		 * below.  We allocate it here instead of inside

		 * pqi_get_physical_disk_info() because it's a fairly large

		 * buffer.

 Do not present disks that the OS cannot fully probe */

 Gather information about the device. */

 Returns TRUE if scan is finished. */

	/*

	 * Set the encryption tweak values based on logical block address.

	 * If the block size is 512, the tweak value is equal to the LBA.

	 * For other block sizes, tweak value is (LBA * block size) / 512.

/*

 * Attempt to perform RAID bypass mapping for a logical volume I/O.

 Check for valid opcode, get LBA and block count. */

 Process via normal I/O path. */

 Check for invalid block or wraparound. */

 Calculate stripe information for the request. */

 Used as a divisor in many calculations */

 If this isn't a single row/column then give to the controller. */

 Proceeding with driver mapping. */

 Used as a divisor in many calculations */

 RAID 50/60 */

 Verify first and last block are in same RAID group. */

 Verify request is in a single row of RAID 5/6. */

 Verify request is in a single column. */

 Request is eligible. */

		/*

		 * p_parity_it_nexus and q_parity_it_nexus are pointers to the

		 * parity entries inside the device's raid_map.

		 *

		 * A device's RAID map is bounded by: number of RAID disks squared.

		 *

		 * The devices RAID map size is checked during device

		 * initialization.

 Build the new CDB for the physical disk I/O. */

 Handle differing logical/physical block sizes. */

 LOGICAL UNIT FAILURE */

www.t10.org/lists/asc-num.htm#ASC_3E */

		/*

		 * Note that the I/O request structure CANNOT BE TOUCHED after

		 * returning from the I/O completion callback!

	/*

	 * This write notifies the controller that an IU is available to be

	 * processed.

	/*

	 * Initialize the backpointers to the controller structure in

	 * each operational queue group structure.

	/*

	 * Assign IDs to all operational queues.  Note that the IDs

	 * assigned to operational IQs are independent of the IDs

	 * assigned to operational OQs.

	/*

	 * Assign MSI-X table entry indexes to all queues.  Note that the

	 * interrupt for the event queue is shared with the first queue group.

	/*

	 * The offset registers are not initialized to the correct

	 * offsets until *after* the create admin queue pair command

	 * completes successfully.

	/*

	 * This write notifies the controller that an IU is available to be

	 * processed.

		/*

		 * This write notifies the controller that one or more IUs are

		 * available to be processed.

	/*

	 * Wait for other admin queue updates such as;

	 * config table changes, OFA memory updates, ...

	/*

	 * Create OQ (Outbound Queue - device to host queue) to dedicate

	 * to events.

	/*

	 * Create IQ (Inbound Queue - host to device queue) for

	 * RAID path.

	/*

	 * Create IQ (Inbound Queue - host to device queue) for

	 * Advanced I/O (AIO) path.

	/*

	 * Designate the 2nd IQ as the AIO path.  By default, all IQs are

	 * assumed to be for RAID path I/O unless we change the queue's

	 * property.

	/*

	 * Create OQ (Outbound Queue - device to host queue).

/*

 * Calculate required resources that are sized based on max. outstanding

 * requests and max. transfer size.

 +1 to cover when the buffer is not page-aligned. */

	/*

	 * Make sure that the max. inbound IU length is an even multiple

	 * of our inbound element length.

 Add one because one element in each queue is unusable. */

 Subtract 1 to leave room for chain marker. */

 The direction is always write. */

 The direction is always write. */

/*

 * This function gets called just before we hand the completed SCSI request

 * back to the SML.

 Check writes only. */

 Check for RAID 5/6 streams. */

	/*

	 * If controller does not support AIO RAID{5,6} writes, need to send

	 * requests down non-AIO path.

		/*

		 * Check for adjacent request or request is within

		 * the previous request.

 unused entry */

 Find entry with oldest last accessed time. */

 Set LRU entry. */

	/*

	 * This is necessary because the SML doesn't zero out this field during

	 * error recovery.

/*

 * Reset all controller settings that can be initialized during the processing

 * of the PQI Configuration Table.

	/*

	 * Copy the config table contents from I/O memory space into the

	 * temporary buffer.

	/*

	 * We process the firmware feature section after all other sections

	 * have been processed so that the feature bit callbacks can take

	 * into account the settings configured by other sections.

 Switches the controller from PQI mode back into SIS mode. */

/*

 * If the controller isn't already in SIS mode, this function forces it into

 * SIS mode.

	/*

	 * Wait until the controller is ready to start accepting SIS

	 * commands.

	/*

	 * Get the controller properties.  This allows us to determine

	 * whether or not it supports PQI mode.

	/*

	 * If the function we are about to call succeeds, the

	 * controller will transition from legacy SIS mode

	 * into PQI mode.

 Wait for the controller to complete the SIS -> PQI transition. */

 From here on, we are running in PQI mode. */

 Supported features not returned correctly. */

 Register with the SCSI subsystem. */

	/*

	 * Wait until the controller is ready to start accepting SIS

	 * commands.

	/*

	 * Get the controller properties.  This allows us to determine

	 * whether or not it supports PQI mode.

	/*

	 * If the function we are about to call succeeds, the

	 * controller will transition from legacy SIS mode

	 * into PQI mode.

 Wait for the controller to complete the SIS -> PQI transition. */

 From here on, we are running in PQI mode. */

 Increase the PCIe completion timeout. */

 Enable bus mastering. */

 IO command from SML */

 Non-IO cmd or driver initiated*/

	/*

	 * Write all data in the controller's battery-backed cache to

	 * storage.

 Define the PCI IDs for the controllers that we support. */

 SPDX-License-Identifier: GPL-2.0

/*

 *    driver for Microchip PQI-based storage controllers

 *    Copyright (c) 2019-2021 Microchip Technology Inc. and its subsidiaries

 *    Copyright (c) 2016-2018 Microsemi Corporation

 *    Copyright (c) 2016 PMC-Sierra, Inc.

 *

 *    Questions/Comments/Bugfixes to storagedev@microchip.com

 *

 legacy SIS interface commands */

 for submission of legacy SIS commands */

 used with SIS_CMD_GET_ADAPTER_PROPERTIES command */

 used with SIS_CMD_INIT_BASE_STRUCT_ADDRESS command */

 for use with SIS_CMD_INIT_BASE_STRUCT_ADDRESS command */

 revision of this structure */

 reserved */

 lower 32 bits of physical memory */

 buffer for PQI error response */

 data */

 upper 32 bits of physical */

 memory buffer for PQI */

 error response data */

 length of each PQI error */

 response buffer element */

 in bytes */

 total number of PQI error */

 response buffers available */

 used for passing command parameters/results when issuing SIS commands */

 mailboxes 0-5 */

 Write the command to mailbox 0. */

	/*

	 * Write the command parameters to mailboxes 1-4 (mailbox 5 is not used

	 * when sending a command to the controller).

 Clear the command doorbell. */

 Disable doorbell interrupts by masking all interrupts. */

	/*

	 * Force the completion of the interrupt mask register write before

	 * submitting the command.

 Submit the command to the controller. */

	/*

	 * Poll for command completion.  Note that the call to msleep() is at

	 * the top of the loop in order to give the controller time to start

	 * processing the command before we start polling.

 Read the command status from mailbox 0. */

	/*

	 * The command completed successfully, so save the command status and

	 * read the values returned in mailboxes 1-5.

/*

 * This function verifies that we are talking to a controller that speaks PQI.

 SPDX-License-Identifier: GPL-2.0

/*

 *    driver for Microchip PQI-based storage controllers

 *    Copyright (c) 2019-2021 Microchip Technology Inc. and its subsidiaries

 *    Copyright (c) 2016-2018 Microsemi Corporation

 *    Copyright (c) 2016 PMC-Sierra, Inc.

 *

 *    Questions/Comments/Bugfixes to storagedev@microchip.com

 *

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright(c) 2007 - 2009 Intel Corporation. All rights reserved.

 *

 * Maintained at www.Open-FCoE.org

 Performance tuning parameters for fcoe */

 fcoe host list */

 must only by accessed under the RTNL mutex */

 Function Prototypes */

 fcoe_syfs control interface handlers */

 notification function for packets from net device */

 notification function for DCB events */

/**

 * fcoe_interface_setup() - Setup a FCoE interface

 * @fcoe:   The new FCoE interface

 * @netdev: The net device that the fcoe interface is on

 *

 * Returns : 0 for success

 * Locking: must be called with the RTNL mutex held

 Let LLD initialize for FCoE */

 Do not support for bonding device */

	/* look for SAN MAC address, if multiple SAN MACs exist, only

 setup Source Mac Address */

	/*

	 * Add FCoE MAC address as second unicast MAC address

	 * or enter promiscuous mode if not capable of listening

	 * for multiple unicast MACs.

	/*

	 * setup the receive function from ethernet driver

	 * on the ethertype for the given device

/**

 * fcoe_interface_create() - Create a FCoE interface on a net device

 * @netdev: The net device to create the FCoE interface on

 * @fip_mode: The mode to use for FIP

 *

 * Returns: pointer to a struct fcoe_interface or NULL on error

	/*

	 * Initialize FIP.

/**

 * fcoe_interface_remove() - remove FCoE interface from netdev

 * @fcoe: The FCoE interface to be cleaned up

 *

 * Caller must be holding the RTNL mutex

	/*

	 * Don't listen for Ethernet packets anymore.

	 * synchronize_net() ensures that the packet handlers are not running

	 * on another CPU. dev_remove_pack() would do that, this calls the

	 * unsyncronized version __dev_remove_pack() to avoid multiple delays.

 Delete secondary MAC addresses */

 Tell the LLD we are done w/ FCoE */

/**

 * fcoe_interface_cleanup() - Clean up a FCoE interface

 * @fcoe: The FCoE interface to be cleaned up

 Release the self-reference taken during fcoe_interface_create() */

 tear-down the FCoE controller */

/**

 * fcoe_fip_recv() - Handler for received FIP frames

 * @skb:      The receive skb

 * @netdev:   The associated net device

 * @ptype:    The packet_type structure which was used to register this handler

 * @orig_dev: The original net_device the skb was received on.

 *	      (in case dev is a bond)

 *

 * Returns: 0 for success

/**

 * fcoe_fip_vlan_recv() - Handler for received FIP VLAN discovery frames

 * @skb:      The receive skb

 * @netdev:   The associated net device

 * @ptype:    The packet_type structure which was used to register this handler

 * @orig_dev: The original net_device the skb was received on.

 *	      (in case dev is a bond)

 *

 * Returns: 0 for success

/**

 * fcoe_port_send() - Send an Ethernet-encapsulated FIP/FCoE frame

 * @port: The FCoE port

 * @skb: The FIP/FCoE packet to be sent

/**

 * fcoe_fip_send() - Send an Ethernet-encapsulated FIP frame

 * @fip: The FCoE controller

 * @skb: The FIP packet to be sent

	/*

	 * Use default VLAN for FIP VLAN discovery protocol

/**

 * fcoe_update_src_mac() - Update the Ethernet MAC filters

 * @lport: The local port to update the source MAC on

 * @addr:  Unicast MAC address to add

 *

 * Remove any previously-set unicast MAC filter.

 * Add secondary FCoE MAC address filter for our OUI.

/**

 * fcoe_get_src_mac() - return the Ethernet source address for an lport

 * @lport: libfc lport

/**

 * fcoe_lport_config() - Set up a local port

 * @lport: The local port to be setup

 *

 * Returns: 0 for success

 lport fc_lport related configuration */

 offload related configuration */

/*

 * fcoe_netdev_features_change - Updates the lport's offload flags based

 * on the LLD netdev's FCoE feature flags

/**

 * fcoe_netdev_config() - Set up net devive for SW FCoE

 * @lport:  The local port that is associated with the net device

 * @netdev: The associated net device

 *

 * Must be called after fcoe_lport_config() as it will use local port mutex

 *

 * Returns: 0 for success

 Setup lport private data to point to fcoe softc */

 Figure out the VLAN ID, if any */

	/*

	 * Determine max frame size based on underlying device and optional

	 * user-configured limit.  If the MFS is too low, fcoe_link_ok()

	 * will return 0, so do this first.

 offload features support */

/**

 * fcoe_shost_config() - Set up the SCSI host associated with a local port

 * @lport: The local port

 * @dev:   The device associated with the SCSI host

 *

 * Must be called after fcoe_lport_config() and fcoe_netdev_config()

 *

 * Returns: 0 for success

 lport scsi host config */

 add the new host to the SCSI-ml */

/**

 * fcoe_fdmi_info() - Get FDMI related info from net devive for SW FCoE

 * @lport:  The local port that is associated with the net device

 * @netdev: The associated net device

 *

 * Must be called after fcoe_shost_config() as it will use local port mutex

 *

 No FDMI state m/c for NPIV ports */

 Enable FDMI lport states */

/**

 * fcoe_oem_match() - The match routine for the offloaded exchange manager

 * @fp: The I/O frame

 *

 * This routine will be associated with an exchange manager (EM). When

 * the libfc exchange handling code is looking for an EM to use it will

 * call this routine and pass it the frame that it wishes to send. This

 * routine will return True if the associated EM is to be used and False

 * if the echange code should continue looking for an EM.

 *

 * The offload EM that this routine is associated with will handle any

 * packets that are for SCSI read requests.

 *

 * This has been enhanced to work when FCoE stack is operating in target

 * mode.

 *

 * Returns: True for read types I/O, otherwise returns false.

/**

 * fcoe_em_config() - Allocate and configure an exchange manager

 * @lport: The local port that the new EM will be associated with

 *

 * Returns: 0 on success

	/*

	 * Check if need to allocate an em instance for

	 * offload exchange ids to be shared across all VN_PORTs/lport.

	/*

	 * Reuse existing offload em instance in case

	 * it is already allocated on real eth device

	/*

	 * Exclude offload EM xid range from next EM xid range.

/**

 * fcoe_if_destroy() - Tear down a SW FCoE instance

 * @lport: The local port to be destroyed

 *

 * Locking: Must be called with the RTNL mutex held.

 *

 Logout of the fabric */

 Cleanup the fc_lport */

 Stop the transmit retry timer */

 Free existing transmit skbs */

 Free queued packets for the per-CPU receive threads */

 Detach from the scsi-ml */

 Destroy lport scsi_priv */

 There are no more rports or I/O, free the EM */

 Free memory used by statistical counters */

	/*

	 * Release the Scsi_Host for vport but hold on to

	 * master lport until it fcoe interface fully cleaned-up.

/**

 * fcoe_ddp_setup() - Call a LLD's ddp_setup through the net device

 * @lport: The local port to setup DDP for

 * @xid:   The exchange ID for this DDP transfer

 * @sgl:   The scatterlist describing this transfer

 * @sgc:   The number of sg items

 *

 * Returns: 0 if the DDP context was not configured

/**

 * fcoe_ddp_target() - Call a LLD's ddp_target through the net device

 * @lport: The local port to setup DDP for

 * @xid:   The exchange ID for this DDP transfer

 * @sgl:   The scatterlist describing this transfer

 * @sgc:   The number of sg items

 *

 * Returns: 0 if the DDP context was not configured

/**

 * fcoe_ddp_done() - Call a LLD's ddp_done through the net device

 * @lport: The local port to complete DDP on

 * @xid:   The exchange ID for this DDP transfer

 *

 * Returns: the length of data that have been completed by DDP

/**

 * fcoe_if_create() - Create a FCoE instance on an interface

 * @fcoe:   The FCoE interface to create a local port on

 * @parent: The device pointer to be the parent in sysfs for the SCSI host

 * @npiv:   Indicates if the port is a vport or not

 *

 * Creates a fc_lport instance and a Scsi_Host instance and configure them.

 *

 * Returns: The allocated fc_lport or an error pointer

	/*

	 * parent is only a vport if npiv is 1,

	 * but we'll only use vport in that case so go ahead and set it

	/*

	 * Need to add the lport to the hostlist

	 * so we catch NETDEV_CHANGE events.

 configure a fc_lport including the exchange manager */

 configure lport network properties */

 configure lport scsi host properties */

 Initialize the library */

 Initialized FDMI information */

	/*

	 * fcoe_em_alloc() and fcoe_hostlist_add() both

	 * need to be atomic with respect to other changes to the

	 * hostlist since fcoe_em_alloc() looks for an existing EM

	 * instance on host list updated by fcoe_hostlist_add().

	 *

	 * This is currently handled through the fcoe_config_mutex

	 * begin held.

 lport exch manager allocation */

/**

 * fcoe_if_init() - Initialization routine for fcoe.ko

 *

 * Attaches the SW FCoE transport to the FC transport

 *

 * Returns: 0 on success

 attach to scsi transport */

/**

 * fcoe_if_exit() - Tear down fcoe.ko

 *

 * Detaches the SW FCoE transport from the FC transport

 *

 * Returns: 0 on success

/**

 * fcoe_select_cpu() - Selects CPU to handle post-processing of incoming

 *			command.

 *

 * This routine selects next CPU based on cpumask to distribute

 * incoming requests in round robin.

 *

 * Returns: int CPU number

/**

 * fcoe_rcv() - Receive packets from a net device

 * @skb:    The received packet

 * @netdev: The net device that the packet was received on

 * @ptype:  The packet type context

 * @olddev: The last device net device

 *

 * This routine is called by NET_RX_SOFTIRQ. It receives a packet, builds a

 * FC frame and passes the frame to libfc.

 *

 * Returns: 0 for success

	/*

	 * Check for minimum frame length, and make sure required FCoE

	 * and FC headers are pulled into the linear data area.

	/*

	 * In case the incoming frame's exchange is originated from

	 * the initiator, then received frame's exchange id is ANDed

	 * with fc_cpu_mask bits to get the same cpu on which exchange

	 * was originated, otherwise select cpu using rx exchange id

	 * or fcoe_select_cpu().

	/*

	 * We now have a valid CPU that we're targeting for

	 * this skb. We also have this receive thread locked,

	 * so we're free to queue skbs into it's queue.

	/*

	 * Note: We used to have a set of conditions under which we would

	 * call fcoe_recv_frame directly, rather than queuing to the rx list

	 * as it could save a few cycles, but doing so is prohibited, as

	 * fcoe_recv_frame has several paths that may sleep, which is forbidden

	 * in softirq context.

/**

 * fcoe_alloc_paged_crc_eof() - Allocate a page to be used for the trailer CRC

 * @skb:  The packet to be transmitted

 * @tlen: The total length of the trailer

 *

 * Returns: 0 for success

/**

 * fcoe_xmit() - Transmit a FCoE frame

 * @lport: The local port that the frame is to be transmitted for

 * @fp:	   The frame to be transmitted

 *

 * Return: 0 for success

 header length implies the version */

 trailer length */

 eth header, may include vlan */

 crc offload */

 copy port crc and eof to the skb buff */

 adjust skb network/transport offsets to match mac/fcoe/port */

 must set skb->dev before calling vlan_put_tag */

 fill up mac and fcoe headers */

 fcoe lso, mss is in max_payload which is non-zero for FCP data */

 update tx stats: regardless if LLD fails */

 send down to lld */

/**

 * fcoe_filter_frames() - filter out bad fcoe frames, i.e. bad CRC

 * @lport: The local port the frame was received on

 * @fp:	   The received frame

 *

 * Return: 0 on passing filtering checks

	/*

	 * We only check CRC if no offload is available and if it is

	 * it's solicited data, in which case, the FCP layer would

	 * check it during the copy.

/**

 * fcoe_recv_frame() - process a single received frame

 * @skb: frame to process

 check for skb_is_nonlinear is within skb_linearize */

	/*

	 * Frame length checks and setting up the header pointers

	 * was done in fcoe_rcv already.

 Copy out the CRC and EOF trailer for access */

/**

 * fcoe_receive_work() - The per-CPU worker

 * @work: The work struct

 *

/**

 * fcoe_dev_setup() - Setup the link change notification interface

/**

 * fcoe_dev_cleanup() - Cleanup the link change notification interface

/**

 * fcoe_device_notification() - Handler for net device events

 * @notifier: The context of the notification

 * @event:    The type of event

 * @ptr:      The net device that the event was on

 *

 * This function is called by the Ethernet driver in case of link change event.

 *

 * Returns: 0 for success

/**

 * fcoe_disable() - Disables a FCoE interface

 * @netdev  : The net_device object the Ethernet interface to create on

 *

 * Called from fcoe transport.

 *

 * Returns: 0 for success

 *

 * Deprecated: use fcoe_ctlr_enabled()

/**

 * fcoe_enable() - Enables a FCoE interface

 * @netdev  : The net_device object the Ethernet interface to create on

 *

 * Called from fcoe transport.

 *

 * Returns: 0 for success

/**

 * fcoe_ctlr_enabled() - Enable or disable an FCoE Controller

 * @cdev: The FCoE Controller that is being enabled or disabled

 *

 * fcoe_sysfs will ensure that the state of 'enabled' has

 * changed, so no checking is necessary here. This routine simply

 * calls fcoe_enable or fcoe_disable, both of which are deprecated.

 * When those routines are removed the functionality can be merged

 * here.

/**

 * fcoe_ctlr_mode() - Switch FIP mode

 * @ctlr_dev: The FCoE Controller that is being modified

 *

 * When the FIP mode has been changed we need to update

 * the multicast addresses to ensure we get the correct

 * frames.

/**

 * fcoe_destroy() - Destroy a FCoE interface

 * @netdev  : The net_device object the Ethernet interface to create on

 *

 * Called from fcoe transport

 *

 * Returns: 0 for success

/**

 * fcoe_destroy_work() - Destroy a FCoE port in a deferred work context

 * @work: Handle to the FCoE port to be destroyed

/**

 * fcoe_match() - Check if the FCoE is supported on the given netdevice

 * @netdev  : The net_device object the Ethernet interface to create on

 *

 * Called from fcoe transport.

 *

 * Returns: always returns true as this is the default FCoE transport,

 * i.e., support all netdevs.

/**

 * fcoe_dcb_create() - Initialize DCB attributes and hooks

 * @fcoe:   The new FCoE interface

 setup DCB priority attributes. */

/**

 * _fcoe_create() - (internal) Create a fcoe interface

 * @netdev  :   The net_device object the Ethernet interface to create on

 * @fip_mode:   The FIP mode for this creation

 * @link_state: The ctlr link state on creation

 *

 * Called from either the libfcoe 'create' module parameter

 * via fcoe_create or from fcoe_syfs's ctlr_create file.

 *

 * libfcoe's 'create' module parameter is deprecated so some

 * consolidation of code can be done when that interface is

 * removed.

 look for existing lport */

 Make this the "master" N_Port */

 setup DCB priority attributes. */

 start FIP Discovery and FLOGI */

	/*

	 * If the fcoe_ctlr_device is to be set to DISABLED

	 * it must be done after the lport is added to the

	 * hostlist, but before the rtnl_lock is released.

	 * This is because the rtnl_lock protects the

	 * hostlist that fcoe_device_notification uses. If

	 * the FCoE Controller is intended to be created

	 * DISABLED then 'enabled' needs to be considered

	 * handling link events. 'enabled' must be set

	 * before the lport can be found in the hostlist

	 * when a link up event is received.

/**

 * fcoe_create() - Create a fcoe interface

 * @netdev  : The net_device object the Ethernet interface to create on

 * @fip_mode: The FIP mode for this creation

 *

 * Called from fcoe transport

 *

 * Returns: 0 for success

/**

 * fcoe_ctlr_alloc() - Allocate a fcoe interface from fcoe_sysfs

 * @netdev: The net_device to be used by the allocated FCoE Controller

 *

 * This routine is called from fcoe_sysfs. It will start the fcoe_ctlr

 * in a link_down state. The allows the user an opportunity to configure

 * the FCoE Controller from sysfs before enabling the FCoE Controller.

 *

 * Creating in with this routine starts the FCoE Controller in Fabric

 * mode. The user can change to VN2VN or another mode before enabling.

/**

 * fcoe_link_ok() - Check if the link is OK for a local port

 * @lport: The local port to check link on

 *

 * Returns: 0 if link is UP and OK, -1 if not

 *

/**

 * fcoe_percpu_clean() - Clear all pending skbs for an local port

 * @lport: The local port whose skbs are to be cleared

 *

 * Must be called with fcoe_create_mutex held to single-thread completion.

 *

 * This flushes the pending skbs by flush the work item for each CPU. The work

 * item on each possible CPU is flushed because we may have used the per-CPU

 * struct of an offline CPU.

/**

 * fcoe_reset() - Reset a local port

 * @shost: The SCSI host associated with the local port to be reset

 *

 * Returns: Always 0 (return value required by FC transport template)

/**

 * fcoe_hostlist_lookup_port() - Find the FCoE interface associated with a net device

 * @netdev: The net device used as a key

 *

 * Locking: Must be called with the RNL mutex held.

 *

 * Returns: NULL or the FCoE interface

/**

 * fcoe_hostlist_lookup() - Find the local port associated with a

 *			    given net device

 * @netdev: The netdevice used as a key

 *

 * Locking: Must be called with the RTNL mutex held

 *

 * Returns: NULL or the local port

/**

 * fcoe_hostlist_add() - Add the FCoE interface identified by a local

 *			 port to the hostlist

 * @lport: The local port that identifies the FCoE interface to be added

 *

 * Locking: must be called with the RTNL mutex held

 *

 * Returns: 0 for success

/**

 * fcoe_hostlist_del() - Remove the FCoE interface identified by a local

 *			 port to the hostlist

 * @lport: The local port that identifies the FCoE interface to be added

 *

 * Locking: must be called with the RTNL mutex held

 *

/**

 * fcoe_init() - Initialize fcoe.ko

 *

 * Returns: 0 on success, or a negative value on failure

 register as a fcoe transport */

 Setup link change notification */

/**

 * fcoe_exit() - Clean up fcoe.ko

 *

 * Returns: 0 on success or a  negative value on failure

 releases the associated fcoe hosts */

	/*

	 * destroy_work's may be chained but destroy_workqueue()

	 * can take care of them. Just kill the fcoe_wq.

	/*

	 * Detaching from the scsi transport must happen after all

	 * destroys are done on the fcoe_wq. destroy_workqueue will

	 * enusre the fcoe_wq is flushed.

 detach from fcoe transport */

/**

 * fcoe_flogi_resp() - FCoE specific FLOGI and FDISC response handler

 * @seq: active sequence in the FLOGI or FDISC exchange

 * @fp: response frame, or error encoded in a pointer (timeout)

 * @arg: pointer to the fcoe_ctlr structure

 *

 * This handles MAC address management for FCoE, then passes control on to

 * the libfc FLOGI response handler.

 pre-FIP */

/**

 * fcoe_logo_resp() - FCoE specific LOGO response handler

 * @seq: active sequence in the LOGO exchange

 * @fp: response frame, or error encoded in a pointer (timeout)

 * @arg: pointer to the fcoe_ctlr structure

 *

 * This handles MAC address management for FCoE, then passes control on to

 * the libfc LOGO response handler.

/*

 * fcoe_elsct_send - FCoE specific ELS handler

 *

 * This does special case handling of FIP encapsualted ELS exchanges for FCoE,

 * using FCoE specific response handlers and passing the FIP controller as

 * the argument (the lport is still available from the exchange).

 *

 * Most of the work here is just handed off to the libfc routine.

 only hook onto fabric logouts, not port logouts */

/**

 * fcoe_vport_create() - create an fc_host/scsi_host for a vport

 * @vport: fc_vport object to create a new fc_host for

 * @disabled: start the new fc_host in a disabled state by default?

 *

 * Returns: 0 for success

/**

 * fcoe_vport_destroy() - destroy the fc_host/scsi_host for a vport

 * @vport: fc_vport object that is being destroyed

 *

 * Returns: 0 for success

/**

 * fcoe_vport_remove() - remove attached vports

 * @lport: lport for which the vports should be removed

 Loop through all the vports and mark them for deletion */

/**

 * fcoe_vport_disable() - change vport state

 * @vport: vport to bring online/offline

 * @disable: should the vport be disabled?

/**

 * fcoe_set_vport_symbolic_name() - append vport string to symbolic name

 * @vport: fc_vport with a new symbolic name string

 *

 * After generating a new symbolic name string, a new RSPN_ID request is

 * sent to the name server.  There is no response handler, so if it fails

 * for some reason it will not be retried.

/**

 * fcoe_set_port_id() - Callback from libfc when Port_ID is set.

 * @lport: the local port

 * @port_id: the port ID

 * @fp: the received frame, if any, that caused the port_id to be set.

 *

 * This routine handles the case where we received a FLOGI and are

 * entering point-to-point mode.  We need to call fcoe_ctlr_recv_flogi()

 * so it can set the non-mapped mode and gateway address.

 *

 * The FLOGI LS_ACC is handled by fcoe_flogi_resp().

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright(c) 2011 - 2012 Intel Corporation. All rights reserved.

 *

 * Maintained at www.Open-FCoE.org

/*

 * OK to include local libfcoe.h for debug_logging, but cannot include

 * <scsi/libfcoe.h> otherwise non-netdev based fcoe solutions would have

 * have to include more than fcoe_sysfs.h.

/*

 * fcoe_fcf_dev_loss_tmo: the default number of seconds that fcoe sysfs

 * should insulate the loss of a fcf.

 seconds */

/*

 * These are used by the fcoe_*_show_function routines, they

 * are intentionally placed in the .c file as they're not intended

 * for use throughout the code.

/*

 * dev_loss_tmo attribute

	/*

	 * Check for overflow; dev_loss_tmo is u32

	/*

	 * Check for overflow; dev_loss_tmo is u32

 Link Error Status Block (LESB) */

/**

 * fcoe_ctlr_device_release() - Release the FIP ctlr memory

 * @dev: Pointer to the FIP ctlr's embedded device

 *

 * Called when the last FIP ctlr reference is released.

/**

 * fcoe_fcf_device_release() - Release the FIP fcf memory

 * @dev: Pointer to the fcf's embedded device

 *

 * Called when the last FIP fcf reference is released.

/**

 * fcoe_ctlr_device_flush_work() - Flush a FIP ctlr's workqueue

 * @ctlr: Pointer to the FIP ctlr whose workqueue is to be flushed

/**

 * fcoe_ctlr_device_queue_work() - Schedule work for a FIP ctlr's workqueue

 * @ctlr: Pointer to the FIP ctlr who owns the devloss workqueue

 * @work:   Work to queue for execution

 *

 * Return value:

 *	1 on success / 0 already queued / < 0 for error

/**

 * fcoe_ctlr_device_flush_devloss() - Flush a FIP ctlr's devloss workqueue

 * @ctlr: Pointer to FIP ctlr whose workqueue is to be flushed

/**

 * fcoe_ctlr_device_queue_devloss_work() - Schedule work for a FIP ctlr's devloss workqueue

 * @ctlr: Pointer to the FIP ctlr who owns the devloss workqueue

 * @work:   Work to queue for execution

 * @delay:  jiffies to delay the work queuing

 *

 * Return value:

 *	1 on success / 0 already queued / < 0 for error

/**

 * fcoe_ctlr_device_add() - Add a FIP ctlr to sysfs

 * @parent:    The parent device to which the fcoe_ctlr instance

 *             should be attached

 * @f:         The LLD's FCoE sysfs function template pointer

 * @priv_size: Size to be allocated with the fcoe_ctlr_device for the LLD

 *

 * This routine allocates a FIP ctlr object with some additional memory

 * for the LLD. The FIP ctlr is initialized, added to sysfs and then

 * attributes are added to it.

/**

 * fcoe_ctlr_device_delete() - Delete a FIP ctlr and its subtree from sysfs

 * @ctlr: A pointer to the ctlr to be deleted

 *

 * Deletes a FIP ctlr and any fcfs attached

 * to it. Deleting fcfs will cause their childen

 * to be deleted as well.

 *

 * The ctlr is detached from sysfs and it's resources

 * are freed (work q), but the memory is not freed

 * until its last reference is released.

 *

 * This routine expects no locks to be held before

 * calling.

 *

 * TODO: Currently there are no callbacks to clean up LLD data

 * for a fcoe_fcf_device. LLDs must keep this in mind as they need

 * to clean up each of their LLD data for all fcoe_fcf_device before

 * calling fcoe_ctlr_device_delete.

 Remove any attached fcfs */

/**

 * fcoe_fcf_device_final_delete() - Final delete routine

 * @work: The FIP fcf's embedded work struct

 *

 * It is expected that the fcf has been removed from

 * the FIP ctlr's list before calling this routine.

	/*

	 * Cancel any outstanding timers. These should really exist

	 * only when rmmod'ing the LLDD and we're asking for

	 * immediate termination of the rports

/**

 * fip_timeout_deleted_fcf() - Delete a fcf when the devloss timer fires

 * @work: The FIP fcf's embedded work struct

 *

 * Removes the fcf from the FIP ctlr's list of fcfs and

 * queues the final deletion.

	/*

	 * If the fcf is deleted or reconnected before the timer

	 * fires the devloss queue will be flushed, but the state will

	 * either be CONNECTED or DELETED. If that is the case we

	 * cancel deleting the fcf.

/**

 * fcoe_fcf_device_delete() - Delete a FIP fcf

 * @fcf: Pointer to the fcf which is to be deleted

 *

 * Queues the FIP fcf on the devloss workqueue

 *

 * Expects the ctlr_attrs mutex to be held for fcf

 * state change.

	/*

	 * FCF will only be re-connected by the LLD calling

	 * fcoe_fcf_device_add, and it should be setting up

	 * priv then.

/**

 * fcoe_fcf_device_add() - Add a FCoE sysfs fcoe_fcf_device to the system

 * @ctlr:    The fcoe_ctlr_device that will be the fcoe_fcf_device parent

 * @new_fcf: A temporary FCF used for lookups on the current list of fcfs

 *

 * Expects to be called with the ctlr->lock held

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2008-2009 Cisco Systems, Inc.  All rights reserved.

 * Copyright (c) 2009 Intel Corporation.  All rights reserved.

 *

 * Maintained at www.Open-FCoE.org

 min keep alive (mS) */

 default keep alive (mS) */

/**

 * fcoe_ctlr_set_state() - Set and do debug printing for the new FIP state.

 * @fip: The FCoE controller

 * @state: The new state

/**

 * fcoe_ctlr_mtu_valid() - Check if a FCF's MTU is valid

 * @fcf: The FCF to check

 *

 * Return non-zero if FCF fcoe_size has been validated.

/**

 * fcoe_ctlr_fcf_usable() - Check if a FCF is usable

 * @fcf: The FCF to check

 *

 * Return non-zero if the FCF is usable.

/**

 * fcoe_ctlr_map_dest() - Set flag and OUI for mapping destination addresses

 * @fip: The FCoE controller

/**

 * fcoe_ctlr_init() - Initialize the FCoE Controller instance

 * @fip: The FCoE controller to initialize

 * @mode: FIP mode to set

/**

 * fcoe_sysfs_fcf_add() - Add a fcoe_fcf{,_device} to a fcoe_ctlr{,_device}

 * @new: The newly discovered FCF

 *

 * Called with fip->ctlr_mutex held

 default to unselected */

	/*

	 * If ctlr_dev doesn't exist then it means we're a libfcoe user

	 * who doesn't use fcoe_syfs and didn't allocate a fcoe_ctlr_device.

	 * fnic would be an example of a driver with this behavior. In this

	 * case we want to add the fcoe_fcf to the fcoe_ctlr list, but we

	 * don't want to make sysfs changes.

		/*

		 * The fcoe_sysfs layer can return a CONNECTED fcf that

		 * has a priv (fcf was never deleted) or a CONNECTED fcf

		 * that doesn't have a priv (fcf was deleted). However,

		 * libfcoe will always delete FCFs before trying to add

		 * them. This is ensured because both recv_adv and

		 * age_fcfs are protected by the the fcoe_ctlr's mutex.

		 * This means that we should never get a FCF with a

		 * non-NULL priv pointer.

/**

 * fcoe_sysfs_fcf_del() - Remove a fcoe_fcf{,_device} to a fcoe_ctlr{,_device}

 * @new: The FCF to be removed

 *

 * Called with fip->ctlr_mutex held

	/*

	 * If ctlr_dev doesn't exist then it means we're a libfcoe user

	 * who doesn't use fcoe_syfs and didn't allocate a fcoe_ctlr_device

	 * or a fcoe_fcf_device.

	 *

	 * fnic would be an example of a driver with this behavior. In this

	 * case we want to remove the fcoe_fcf from the fcoe_ctlr list (above),

	 * but we don't want to make sysfs changes.

/**

 * fcoe_ctlr_reset_fcfs() - Reset and free all FCFs for a controller

 * @fip: The FCoE controller whose FCFs are to be reset

 *

 * Called with &fcoe_ctlr lock held.

/**

 * fcoe_ctlr_destroy() - Disable and tear down a FCoE controller

 * @fip: The FCoE controller to tear down

 *

 * This is called by FCoE drivers before freeing the &fcoe_ctlr.

 *

 * The receive handler will have been deleted before this to guarantee

 * that no more recv_work will be scheduled.

 *

 * The timer routine will simply return once we set FIP_ST_DISABLED.

 * This guarantees that no further timeouts or work will be scheduled.

/**

 * fcoe_ctlr_announce() - announce new FCF selection

 * @fip: The FCoE controller

 *

 * Also sets the destination MAC for FCoE and control packets

 *

 * Called with neither ctlr_mutex nor ctlr_lock held.

/**

 * fcoe_ctlr_fcoe_size() - Return the maximum FCoE size required for VN_Port

 * @fip: The FCoE controller to get the maximum FCoE size from

 *

 * Returns the maximum packet size including the FCoE header and trailer,

 * but not including any Ethernet or VLAN headers.

	/*

	 * Determine the max FCoE frame size allowed, including

	 * FCoE header and trailer.

	 * Note:  lp->mfs is currently the payload size, not the frame size.

/**

 * fcoe_ctlr_solicit() - Send a FIP solicitation

 * @fip: The FCoE controller to send the solicitation on

 * @fcf: The destination FCF (if NULL, a multicast solicitation is sent)

/**

 * fcoe_ctlr_link_up() - Start FCoE controller

 * @fip: The FCoE controller to start

 *

 * Called from the LLD when the network link is ready.

/**

 * fcoe_ctlr_reset() - Reset a FCoE controller

 * @fip:       The FCoE controller to reset

/**

 * fcoe_ctlr_link_down() - Stop a FCoE controller

 * @fip: The FCoE controller to be stopped

 *

 * Returns non-zero if the link was up and now isn't.

 *

 * Called from the LLD when the network link is not ready.

 * There may be multiple calls while the link is down.

/**

 * fcoe_ctlr_send_keep_alive() - Send a keep-alive to the selected FCF

 * @fip:   The FCoE controller to send the FKA on

 * @lport: libfc fc_lport to send from

 * @ports: 0 for controller keep-alive, 1 for port keep-alive

 * @sa:	   The source MAC address

 *

 * A controller keep-alive is sent every fka_period (typically 8 seconds).

 * The source MAC is the native MAC address.

 *

 * A port keep-alive is sent every 90 seconds while logged in.

 * The source MAC is the assigned mapped source address.

 * The destination is the FCF's F-port.

/**

 * fcoe_ctlr_encaps() - Encapsulate an ELS frame for FIP, without sending it

 * @fip:   The FCoE controller for the ELS frame

 * @lport: The local port

 * @dtype: The FIP descriptor type for the frame

 * @skb:   The FCoE ELS frame including FC header but no FCoE headers

 * @d_id:  The destination port ID.

 *

 * Returns non-zero error code on failure.

 *

 * The caller must check that the length is a multiple of 4.

 *

 * The @skb must have enough headroom (28 bytes) and tailroom (8 bytes).

 * Headroom includes the FIP encapsulation description, FIP header, and

 * Ethernet header.  The tailroom is for the FIP MAC descriptor.

 len before push */

 FPMA only FLOGI.  Must leave the MAC desc zeroed. */

/**

 * fcoe_ctlr_els_send() - Send an ELS frame encapsulated by FIP if appropriate.

 * @fip:	FCoE controller.

 * @lport:	libfc fc_lport to send from

 * @skb:	FCoE ELS frame including FC header but no FCoE headers.

 *

 * Returns a non-zero error code if the frame should not be sent.

 * Returns zero if the caller should send the frame with FCoE encapsulation.

 *

 * The caller must check that the length is a multiple of 4.

 * The SKB must have enough headroom (28 bytes) and tailroom (8 bytes).

 * The the skb must also be an fc_frame.

 *

 * This is called from the lower-level driver with spinlocks held,

 * so we must not take a mutex here.

		/*

		 * If non-FIP, we may have gotten an SID by accepting an FLOGI

		 * from a point-to-point connection.  Switch to using

		 * the source mac based on the SID.  The destination

		 * MAC in this case would have been set by receiving the

		 * FLOGI.

/**

 * fcoe_ctlr_age_fcfs() - Reset and free all old FCFs for a controller

 * @fip: The FCoE controller to free FCFs on

 *

 * Called with lock held and preemption disabled.

 *

 * An FCF is considered old if we have missed two advertisements.

 * That is, there have been no valid advertisement from it for 2.5

 * times its keep-alive period.

 *

 * In addition, determine the time when an FCF selection can occur.

 *

 * Also, increment the MissDiscAdvCount when no advertisement is received

 * for the corresponding FCF for 1.5 * FKA_ADV_PERIOD (FC-BB-5 LESB).

 *

 * Returns the time in jiffies for the next call.

			/*

			 * Move to delete list so we can call

			 * fcoe_sysfs_fcf_del (which can sleep)

			 * after the put_cpu().

 Removes fcf from current list */

/**

 * fcoe_ctlr_parse_adv() - Decode a FIP advertisement into a new FCF entry

 * @fip: The FCoE controller receiving the advertisement

 * @skb: The received FIP advertisement frame

 * @fcf: The resulting FCF entry

 *

 * Returns zero on a valid parsed advertisement,

 * otherwise returns non zero value.

	/*

	 * mask of required descriptors. validating each one clears its bit.

 Drop Adv if there are duplicate critical descriptors */

 standard says ignore unknown descriptors >= 128 */

/**

 * fcoe_ctlr_recv_adv() - Handle an incoming advertisement

 * @fip: The FCoE controller receiving the advertisement

 * @skb: The received FIP packet

		/*

		 * Update the FCF's keep-alive descriptor flags.

		 * Other flag changes from new advertisements are

		 * ignored after a solicited advertisement is

		 * received and the FCF is selectable (usable).

	/*

	 * If this advertisement is not solicited and our max receive size

	 * hasn't been verified, send a solicited advertisement.

	/*

	 * If its been a while since we did a solicit, and this is

	 * the first advertisement we've received, do a multicast

	 * solicitation to gather as many advertisements as we can

	 * before selection occurs.

	/*

	 * Put this FCF at the head of the list for priority among equals.

	 * This helps in the case of an NPV switch which insists we use

	 * the FCF that answers multicast solicitations, not the others that

	 * are sending periodic multicast advertisements.

	/*

	 * If this is the first validated FCF, note the time and

	 * set a timer to trigger selection.

/**

 * fcoe_ctlr_recv_els() - Handle an incoming FIP encapsulated ELS frame

 * @fip: The FCoE controller which received the packet

 * @skb: The received FIP packet

 Drop ELS if there are duplicate critical descriptors */

			/*

			 * Some switch implementations send two MAC descriptors,

			 * with first MAC(granted_mac) being the FPMA, and the

			 * second one(fcoe_mac) is used as destination address

			 * for sending/receiving FCoE packets. FIP traffic is

			 * sent using fip_mac. For regular switches, both

			 * fip_mac and fcoe_mac would be the same.

 standard says ignore unknown descriptors >= 128 */

 retrying FLOGI so drop reject */

	/*

	 * Convert skb into an fc_frame containing only the ELS.

/**

 * fcoe_ctlr_recv_clr_vlink() - Handle an incoming link reset frame

 * @fip: The FCoE controller that received the frame

 * @skb: The received FIP packet

 *

 * There may be multiple VN_Port descriptors.

 * The overall length has already been checked.

		/*

		 * We are yet to select best FCF, but we got CVL in the

		 * meantime. reset the ctlr and let it rediscover the FCF

	/*

	 * If we've selected an FCF check that the CVL is from there to avoid

	 * processing CVLs from an unexpected source.  If it is from an

	 * unexpected source drop it on the floor.

	/*

	 * If we haven't logged into the fabric but receive a CVL we should

	 * reset everything and go back to solicitation.

	/*

	 * mask of required descriptors.  Validating each one clears its bit.

	/*

	 * Actually need to subtract 'sizeof(*mp) - sizeof(*wp)' from 'rlen'

	 * before determining max Vx_Port descriptor but a buggy FCF could have

	 * omitted either or both MAC Address and Name Identifier descriptors

 Drop CVL if there are duplicate critical descriptors */

 standard says ignore unknown descriptors >= 128 */

	/*

	 * reset only if all required descriptors were present and valid.

		/*

		 * No Vx_Port description. Clear all NPIV ports,

		 * followed by physical port

			/*

			 * 'port_id' is already validated, check MAC address and

			 * wwpn

				/*

				 * Physical port, defer processing till all

				 * listed NPIV ports are cleared

 NPIV port */

/**

 * fcoe_ctlr_recv() - Receive a FIP packet

 * @fip: The FCoE controller that received the packet

 * @skb: The received FIP packet

 *

 * This may be called from either NET_RX_SOFTIRQ or IRQ.

/**

 * fcoe_ctlr_recv_handler() - Receive a FIP frame

 * @fip: The FCoE controller that received the frame

 * @skb: The received FIP frame

 *

 * Returns non-zero if the frame is dropped.

 consumes skb */

/**

 * fcoe_ctlr_select() - Select the best FCF (if possible)

 * @fip: The FCoE controller

 *

 * Returns the selected FCF, or NULL if none are usable.

 *

 * If there are conflicting advertisements, no FCF can be chosen.

 *

 * If there is already a selected FCF, this will choose a better one or

 * an equivalent one that hasn't already been sent a FLOGI.

 *

 * Called with lock held.

/**

 * fcoe_ctlr_flogi_send_locked() - send FIP-encapsulated FLOGI to current FCF

 * @fip: The FCoE controller

 *

 * Returns non-zero error if it could not be sent.

 *

 * Called with ctlr_mutex and ctlr_lock held.

 * Caller must verify that fip->sel_fcf is not NULL.

	/*

	 * Clone and send the FLOGI request.  If clone fails, use original.

/**

 * fcoe_ctlr_flogi_retry() - resend FLOGI request to a new FCF if possible

 * @fip: The FCoE controller

 *

 * Returns non-zero error code if there's no FLOGI request to retry or

 * no alternate FCF available.

/**

 * fcoe_ctlr_flogi_send() - Handle sending of FIP FLOGI.

 * @fip: The FCoE controller that timed out

 *

 * Done here because fcoe_ctlr_els_send() can't get mutex.

 *

 * Called with ctlr_mutex held.  The caller must not hold ctlr_lock.

	/*

	 * If this FLOGI is being sent due to a timeout retry

	 * to the same FCF as before, select a different FCF if possible.

 XXX */

/**

 * fcoe_ctlr_timeout() - FIP timeout handler

 * @t: Timer context use to obtain the controller reference

/**

 * fcoe_ctlr_timer_work() - Worker thread function for timer work

 * @work: Handle to a FCoE controller

 *

 * Ages FCFs.  Triggers FCF selection if possible.

 * Sends keep-alives and resets.

 restart things with a solicitation */

/**

 * fcoe_ctlr_recv_work() - Worker thread function for receiving FIP frames

 * @recv_work: Handle to a FCoE controller

/**

 * fcoe_ctlr_recv_flogi() - Snoop pre-FIP receipt of FLOGI response

 * @fip: The FCoE controller

 * @lport: The local port

 * @fp:	 The FC frame to snoop

 *

 * Snoop potential response to FLOGI or even incoming FLOGI.

 *

 * The caller has checked that we are waiting for login as indicated

 * by fip->flogi_oxid != FC_XID_UNKNOWN.

 *

 * The caller is responsible for freeing the frame.

 * Fill in the granted_mac address.

 *

 * Return non-zero if the frame should not be delivered to libfc.

		/*

		 * FLOGI accepted.

		 * If the src mac addr is FC_OUI-based, then we mark the

		 * address_mode flag to use FC_OUI-based Ethernet DA.

		 * Otherwise we use the FCoE gateway addr

		/*

		 * Save source MAC for point-to-point responses.

/**

 * fcoe_wwn_from_mac() - Converts a 48-bit IEEE MAC address to a 64-bit FC WWN

 * @mac:    The MAC address to convert

 * @scheme: The scheme to use when converting

 * @port:   The port indicator for converting

 *

 * Returns: u64 fc world wide name

 The MAC is in NO, so flip only the low 48 bits */

/**

 * fcoe_ctlr_rport() - return the fcoe_rport for a given fc_rport_priv

 * @rdata: libfc remote port

/**

 * fcoe_ctlr_vn_send() - Send a FIP VN2VN Probe Request or Reply.

 * @fip: The FCoE controller

 * @sub: sub-opcode for probe request, reply, or advertisement.

 * @dest: The destination Ethernet MAC address

 * @min_len: minimum size of the Ethernet payload to be sent

	/*

	 * For claims, add FC-4 features.

	 * TBD: Add interface to get fc-4 types and features from libfc.

/**

 * fcoe_ctlr_vn_rport_callback - Event handler for rport events.

 * @lport: The lport which is receiving the event

 * @rdata: remote port private data

 * @event: The event that occurred

 *

 * Locking Note:  The rport lock must not be held when calling this function.

/**

 * fcoe_ctlr_disc_stop_locked() - stop discovery in VN2VN mode

 * @lport: The local port

 *

 * Called with ctlr_mutex held.

/**

 * fcoe_ctlr_disc_stop() - stop discovery in VN2VN mode

 * @lport: The local port

 *

 * Called through the local port template for discovery.

 * Called without the ctlr_mutex held.

/**

 * fcoe_ctlr_disc_stop_final() - stop discovery for shutdown in VN2VN mode

 * @lport: The local port

 *

 * Called through the local port template for discovery.

 * Called without the ctlr_mutex held.

/**

 * fcoe_ctlr_vn_restart() - VN2VN probe restart with new port_id

 * @fip: The FCoE controller

 *

 * Called with fcoe_ctlr lock held.

	/*

	 * Get proposed port ID.

	 * If this is the first try after link up, use any previous port_id.

	 * If there was none, use the low bits of the port_name.

	 * On subsequent tries, get the next random one.

	 * Don't use reserved IDs, use another non-zero value, just as random.

/**

 * fcoe_ctlr_vn_start() - Start in VN2VN mode

 * @fip: The FCoE controller

 *

 * Called with fcoe_ctlr lock held.

/**

 * fcoe_ctlr_vn_parse - parse probe request or response

 * @fip: The FCoE controller

 * @skb: incoming packet

 * @frport: parsed FCoE rport from the probe request

 *

 * Returns non-zero error number on error.

 * Does not consume the packet.

 standard says ignore unknown descriptors >= 128 */

/**

 * fcoe_ctlr_vn_send_claim() - send multicast FIP VN2VN Claim Notification.

 * @fip: The FCoE controller

 *

 * Called with ctlr_mutex held.

/**

 * fcoe_ctlr_vn_probe_req() - handle incoming VN2VN probe request.

 * @fip: The FCoE controller

 * @frport: parsed FCoE rport from the probe request

 *

 * Called with ctlr_mutex held.

		/*

		 * Decide whether to reply to the Probe.

		 * Our selected address is never a "recorded" one, so

		 * only reply if our WWPN is greater and the

		 * Probe's REC bit is not set.

		 * If we don't reply, we will change our address.

/**

 * fcoe_ctlr_vn_probe_reply() - handle incoming VN2VN probe reply.

 * @fip: The FCoE controller

 * @frport: parsed FCoE rport from the probe request

 *

 * Called with ctlr_mutex held.

/**

 * fcoe_ctlr_vn_add() - Add a VN2VN entry to the list, based on a claim reply.

 * @fip: The FCoE controller

 * @new: newly-parsed FCoE rport as a template for new rdata

 *

 * Called with ctlr_mutex held.

/**

 * fcoe_ctlr_vn_lookup() - Find VN remote port's MAC address

 * @fip: The FCoE controller

 * @port_id:  The port_id of the remote VN_node

 * @mac: buffer which will hold the VN_NODE destination MAC address, if found.

 *

 * Returns non-zero error if no remote port found.

/**

 * fcoe_ctlr_vn_claim_notify() - handle received FIP VN2VN Claim Notification

 * @fip: The FCoE controller

 * @new: newly-parsed FCoE rport as a template for new rdata

 *

 * Called with ctlr_mutex held.

/**

 * fcoe_ctlr_vn_claim_resp() - handle received Claim Response

 * @fip: The FCoE controller that received the frame

 * @new: newly-parsed FCoE rport from the Claim Response

 *

 * Called with ctlr_mutex held.

/**

 * fcoe_ctlr_vn_beacon() - handle received beacon.

 * @fip: The FCoE controller that received the frame

 * @new: newly-parsed FCoE rport from the Beacon

 *

 * Called with ctlr_mutex held.

	/*

	 * Beacon from a new neighbor.

	 * Send a claim notify if one hasn't been sent recently.

	 * Don't add the neighbor yet.

/**

 * fcoe_ctlr_vn_age() - Check for VN_ports without recent beacons

 * @fip: The FCoE controller

 *

 * Called with ctlr_mutex held.

 * Called only in state FIP_ST_VNMP_UP.

 * Returns the soonest time for next age-out or a time far in the future.

/**

 * fcoe_ctlr_vn_recv() - Receive a FIP frame

 * @fip: The FCoE controller that received the frame

 * @skb: The received FIP frame

 *

 * Returns non-zero if the frame is dropped.

 * Always consumes the frame.

/**

 * fcoe_ctlr_vlan_parse - parse vlan discovery request or response

 * @fip: The FCoE controller

 * @skb: incoming packet

 * @frport: parsed FCoE rport from the probe request

 *

 * Returns non-zero error number on error.

 * Does not consume the packet.

 standard says ignore unknown descriptors >= 128 */

/**

 * fcoe_ctlr_vlan_send() - Send a FIP VLAN Notification

 * @fip: The FCoE controller

 * @sub: sub-opcode for vlan notification or vn2vn vlan notification

 * @dest: The destination Ethernet MAC address

/**

 * fcoe_ctlr_vlan_disc_reply() - send FIP VLAN Discovery Notification.

 * @fip: The FCoE controller

 * @frport: The newly-parsed FCoE rport from the Discovery Request

 *

 * Called with ctlr_mutex held.

/**

 * fcoe_ctlr_vlan_recv - vlan request receive handler for VN2VN mode.

 * @fip: The FCoE controller

 * @skb: The received FIP packet

/**

 * fcoe_ctlr_disc_recv - discovery receive handler for VN2VN mode.

 * @lport: The local port

 * @fp: The received frame

 *

 * This should never be called since we don't see RSCNs or other

 * fabric-generated ELSes.

/*

 * fcoe_ctlr_disc_start - start discovery for VN2VN mode.

 *

 * This sets a flag indicating that remote ports should be created

 * and started for the peers we discover.  We use the disc_callback

 * pointer as that flag.  Peers already discovered are created here.

 *

 * The lport lock is held during this call. The callback must be done

 * later, without holding either the lport or discovery locks.

 * The fcoe_ctlr lock may also be held during this call.

/**

 * fcoe_ctlr_vn_disc() - report FIP VN_port discovery results after claim state.

 * @fip: The FCoE controller

 *

 * Starts the FLOGI and PLOGI login process to each discovered rport for which

 * we've received at least one beacon.

 * Performs the discovery complete callback.

/**

 * fcoe_ctlr_vn_timeout - timer work function for VN2VN mode.

 * @fip: The FCoE controller

		/*

		 * This may be invoked either by starting discovery so don't

		 * go to the next state unless it's been long enough.

 If port ID is new, notify local port after dropping ctlr_mutex */

/**

 * fcoe_ctlr_mode_set() - Set or reset the ctlr's mode

 * @lport: The local port to be (re)configured

 * @fip:   The FCoE controller whose mode is changing

 * @fip_mode: The new fip mode

 *

 * Note that the we shouldn't be changing the libfc discovery settings

 * (fc_disc_config) while an lport is going through the libfc state

 * machine. The mode can only be changed when a fcoe_ctlr device is

 * disabled, so that should ensure that this routine is only called

 * when nothing is happening.

/**

 * fcoe_libfc_config() - Sets up libfc related properties for local port

 * @lport:    The local port to configure libfc for

 * @fip:      The FCoE controller in use by the local port

 * @tt:       The libfc function template

 * @init_fcp: If non-zero, the FCP portion of libfc should be initialized

 *

 * Returns : 0 for success

 Set the function pointers set by the LLDD */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.

 *

 * Maintained at www.Open-FCoE.org

 notification function for packets from net device */

/**

 * fcoe_link_speed_update() - Update the supported and actual link speeds

 * @lport: The local port to update speeds for

 *

 * Returns: 0 if the ethtool query was successful

 *          -1 if the ethtool query failed

/**

 * __fcoe_get_lesb() - Get the Link Error Status Block (LESB) for a given lport

 * @lport: The local port to update speeds for

 * @fc_lesb: Pointer to the LESB to be filled up

 * @netdev: Pointer to the netdev that is associated with the lport

 *

 * Note, the Link Error Status Block (LESB) for FCoE is defined in FC-BB-6

 * Clause 7.11 in v1.04.

/**

 * fcoe_get_lesb() - Fill the FCoE Link Error Status Block

 * @lport: the local port

 * @fc_lesb: the link error status block

/**

 * fcoe_ctlr_get_lesb() - Get the Link Error Status Block (LESB) for a given

 * fcoe controller device

 * @ctlr_dev: The given fcoe controller device

 *

/**

 * fcoe_validate_vport_create() - Validate a vport before creating it

 * @vport: NPIV port to be created

 *

 * This routine is meant to add validation for a vport before creating it

 * via fcoe_vport_create().

 * Current validations are:

 *      - WWPN supplied is unique for given lport

 Check if the wwpn is not same as that of the lport */

 Check if there is any existing vport with same wwpn */

/**

 * fcoe_get_wwn() - Get the world wide name from LLD if it supports it

 * @netdev: the associated net device

 * @wwn: the output WWN

 * @type: the type of WWN (WWPN or WWNN)

 *

 * Returns: 0 for success

/**

 * fcoe_fc_crc() - Calculates the CRC for a given frame

 * @fp: The frame to be checksumed

 *

 * This uses crc32() routine to calculate the CRC for a frame

 *

 * Return: The 32 bit CRC value

/**

 * fcoe_start_io() - Start FCoE I/O

 * @skb: The packet to be transmitted

 *

 * This routine is called from the net device to start transmitting

 * FCoE packets.

 *

 * Returns: 0 for success

/**

 * fcoe_clean_pending_queue() - Dequeue a skb and free it

 * @lport: The local port to dequeue a skb on

/**

 * fcoe_check_wait_queue() - Attempt to clear the transmit backlog

 * @lport: The local port whose backlog is to be cleared

 * @skb: The received FIP packet

 *

 * This empties the wait_queue, dequeues the head of the wait_queue queue

 * and calls fcoe_start_io() for each packet. If all skb have been

 * transmitted it returns the qlen. If an error occurs it restores

 * wait_queue (to try again later) and returns -1.

 *

 * The wait_queue is used when the skb transmit fails. The failed skb

 * will go in the wait_queue which will be emptied by the timer function or

 * by the next skb transmit.

 keep qlen > 0 until fcoe_start_io succeeds */

 undo temporary increment above */

 undo temporary increment above */

/**

 * fcoe_queue_timer() - The fcoe queue timer

 * @t: Timer context use to obtain the FCoE port

 *

 * Calls fcoe_check_wait_queue on timeout

/**

 * fcoe_get_paged_crc_eof() - Allocate a page to be used for the trailer CRC

 * @skb:  The packet to be transmitted

 * @tlen: The total length of the trailer

 * @fps:  The fcoe context

 *

 * This routine allocates a page for frame trailers. The page is re-used if

 * there is enough room left on it for the current trailer. If there isn't

 * enough buffer left a new page is allocated for the trailer. Reference to

 * the page from this function as well as the skbs using the page fragments

 * ensure that the page is freed at the appropriate time.

 *

 * Returns: 0 for success

/**

 * fcoe_transport_lookup - find an fcoe transport that matches a netdev

 * @netdev: The netdev to look for from all attached transports

 *

 * Returns : ptr to the fcoe transport that supports this netdev or NULL

 * if not found.

 *

 * The ft_mutex should be held when this is called

/**

 * fcoe_transport_attach - Attaches an FCoE transport

 * @ft: The fcoe transport to be attached

 *

 * Returns : 0 for success

 Add default transport to the tail */

/**

 * fcoe_transport_detach - Detaches an FCoE transport

 * @ft: The fcoe transport to be attached

 *

 * Returns : 0 for success

 remove netdev mapping for this transport as it is going away */

/**

 * fcoe_netdev_map_lookup - find the fcoe transport that matches the netdev on which

 * it was created

 * @netdev: The net device that the FCoE interface is on

 *

 * Returns : ptr to the fcoe transport that supports this netdev or NULL

 * if not found.

 *

 * The ft_mutex should be held when this is called

/**

 * fcoe_if_to_netdev() - Parse a name buffer to get a net device

 * @buffer: The name of the net device

 *

 * Returns: NULL or a ptr to net_device

/**

 * libfcoe_device_notification() - Handler for net device events

 * @notifier: The context of the notification

 * @event:    The type of event

 * @ptr:      The net device that the event was on

 *

 * This function is called by the Ethernet driver in case of link change event.

 *

 * Returns: 0 for success

 pass to transport create */

 pass to transport destroy */

 required for successful return */

/**

 * fcoe_transport_create() - Create a fcoe interface

 * @buffer: The name of the Ethernet interface to create on

 * @kp:	    The associated kernel param

 *

 * Called from sysfs. This holds the ft_mutex while calling the

 * registered fcoe transport's create function.

 *

 * Returns: 0 for success

 pass to transport create */

/**

 * fcoe_transport_destroy() - Destroy a FCoE interface

 * @buffer: The name of the Ethernet interface to be destroyed

 * @kp:	    The associated kernel parameter

 *

 * Called from sysfs. This holds the ft_mutex while calling the

 * registered fcoe transport's destroy function.

 *

 * Returns: 0 for success

 pass to transport destroy */

/**

 * fcoe_transport_disable() - Disables a FCoE interface

 * @buffer: The name of the Ethernet interface to be disabled

 * @kp:	    The associated kernel parameter

 *

 * Called from sysfs.

 *

 * Returns: 0 for success

/**

 * fcoe_transport_enable() - Enables a FCoE interface

 * @buffer: The name of the Ethernet interface to be enabled

 * @kp:     The associated kernel parameter

 *

 * Called from sysfs.

 *

 * Returns: 0 for success

/**

 * libfcoe_init() - Initialization routine for libfcoe.ko

/**

 * libfcoe_exit() - Tear down libfcoe.ko

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

/**

 * All common (i.e. transport-independent) SLI-4 functions are implemented

 * in this file.

 Convert queue type enum (SLI_QTYPE_*) into a string */

/**

 * sli_config_cmd_init() - Write a SLI_CONFIG command to the provided buffer.

 *

 * @sli4: SLI context pointer.

 * @buf: Destination buffer for the command.

 * @length: Length in bytes of attached command.

 * @dma: DMA buffer for non-embedded commands.

 * Return: Command payload buffer.

 save pointer to DMA for BMBX dumping purposes */

/**

 * sli_cmd_common_create_cq() - Write a COMMON_CREATE_CQ V2 command.

 *

 * @sli4: SLI context pointer.

 * @buf: Destination buffer for the command.

 * @qmem: DMA memory for queue.

 * @eq_id: EQ id assosiated with this cq.

 * Return: status -EIO/0.

 First calculate number of pages and the mailbox cmd length */

 valid values for number of pages: 1, 2, 4, 8 (sec 4.4.3) */

 valid values for number of pages: 1, 2, 4 (sec 4.4.3) */

 valid values for number of pages: 1, 2, 4, 8 (sec 4.4.12) */

 valid values for number of pages(num_pages): 1-8 */

 Disable "no buffer warnings" to avoid Lancer bug */

 valid values for number of pages: 1-8 (sec 4.5.6) */

	/*

	 * RQE count is the total number of entries (note not lg2(# entries))

 Payload length must accommodate both request and response */

 Fill Payload fields */

		/* For prism, phase will be flipped after

		 * a sweep through eq and cq

 Limit to hwf the queue size per interrupt */

 sanity check */

 get queue size */

 Fill page addresses of all the CQs. */

 Align the queue DMA memory */

 Check if we got all requested CQs. */

 Fill the resp cq ids. */

 Payload length must accommodate both request and response */

	/*

	 * In RQ-pair, an RQ either contains the FC header

	 * (i.e. is_hdr == TRUE) or the payload.

	 *

	 * Don't ring doorbell for payload RQ

 Check if eqe is valid */

	/*

	 * For prism, the phase value will be used

	 * to check the validity of eq/cq entries.

	 * The value toggles after a complete sweep

	 * through the queue.

 Check if cqe is valid */

	/*

	 * For prism, the phase value will be used

	 * to check the validity of eq/cq entries.

	 * The value toggles after a complete sweep

	 * through the queue.

 Check if mqe is valid */

 Parse a CQ entry to retrieve the event type and the queue id */

 Suppress ABTS retries */

 figure out the ELS_ID value from the request buffer */

		/*

		 * Set SP here ... we haven't done a REG_VPI yet

		 * need to maybe not set this when we have

		 * completed VFI/VPI registrations ...

		 *

		 * Use the FC_ID of the SPORT if it has been allocated,

		 * otherwise use an S_ID of zero.

 WQE word 4 contains read transfer length */

		/*

		 * fill out fcp_cmnd buffer len and change resp buffer to be of

		 * type "skip" (note: response will still be written to sge[1]

		 * if necessary)

 WQE word 4 contains read transfer length */

		/*

		 * fill out fcp_cmnd buffer len and change resp buffer to be of

		 * type "skip" (note: response will still be written to sge[1]

		 * if necessary)

 WQE word 4 contains read transfer length */

 if data is a single physical address, use a BDE */

 WQE uses relative offset */

 The upper 7 bits of csctl is the priority */

 The upper 7 bits of csctl is the priority */

		/* TSEND64_WQE specifies first two SGE are skipped (3rd is

		 * valid)

 if data is a single physical address, use a BDE */

			/*

			 * TSEND64_WQE specifies first two SGE are skipped

			 * (i.e. 3rd is valid)

 WQE uses relative offset */

 The upper 7 bits of csctl is the priority */

 Copy FC header */

	/*

	 * Callers can either specify RPI or S_ID, but not both

	/* sequence initiative - this matches what is seen from

	 * FC switches in response to FCGS commands

 force transmit */

 exchange responder */

 last in seqence */

 Flag errors except for FCP_RSP_FAILURE */

 Flag errors */

 Retrieve the RQ index from the completion */

 Wait for the bootstrap mailbox to report "ready" */

 write buffer location to bootstrap mailbox register */

 wait for SLI Port to set ready bit */

 Submit a command to the bootstrap mailbox and check the status */

 check completion queue entry status */

 Port interprets zero in a field as "use default value" */

 Port interprets zero in a field as "use default value" */

 Attempt P2P but failover to FC-AL */

	/*

	 * If the VPI is valid, initialize it at the same time as

	 * the VFI

 override indicator */

 Set the port type value (ethernet=0, FC=1) for V1 commands */

 Setup to transfer xfer_size bytes to device */

 Setup to transfer xfer_size bytes to device */

	/*

	 * Firmware can split mbx completions into two MCQEs: first with only

	 * the "consumed" bit set and a second with the "complete" bit set.

	 * Thus, ignore MCQE unless "complete" is set.

 Determine if the chip FW is in a ready state */

 Initialize port, endian */

	/*

	 * Is firmware ready for operation?

	/*

	 * Reset port to a known state

	/* single, continguous DMA allocations will be called for each queue

	 * of size (max_qentries * queue entry size); since these can be large,

	 * check against the OS max DMA allocation size

	/*

	 * READ_CONFIG doesn't give the max number of MQ. Applications

	 * will typically want 1, but we may need another at some future

	 * date. Dummy up a "max" MQ count here.

 save count methods and masks for each queue type */

 now calculate max queue entries */

 max # of pages */

 bit map of available sizes */

 ignore HLM here. Use value from REQUEST_FEATURES */

 default to using pre-registered SGL's */

 Use the highest available WQE size. */

	/*

	 * Issue COMMON_GET_CNTL_ATTRIBUTES to get port_number. Temporarily

	 * uses VPD DMA buffer as the response won't fit in the embedded

	 * buffer.

 get additional attributes */

 Check that all VPD data was returned */

	/*

	 * Read the device configuration

	/*

	 * Read the SLI_INTF register to discover the register layout

	 * and other capability information

 driver only support SLI-4 */

	/*

	 * set the ASIC type and revision

 Fail if no matching asic type/rev was found */

	/*

	 * The bootstrap mailbox is equivalent to a MQ with a single 256 byte

	 * entry, a CQ with a single 16 byte entry, and no event queue.

	 * Alignment must be 16 bytes as the low order address bits in the

	 * address register are also control / status.

 4096 is arbitrary. What should this value actually be? */

 Note that failure isn't fatal in this specific case */

	/*

	 * Set one of fcpi(initiator), fcpt(target), fcpc(combined) to true

	 * in addition to any other desired features

 use performance hints if available */

	/*

	 * Firmware must be ready before issuing the reset.

 Lancer uses PHYDEV_CONTROL */

 wait for the FW to become ready after the reset */

		/*

		 * Figure out which extent contains the resource ID. I.e. find

		 * the extent such that

		 *   extent->base <= resource ID < extent->base + extent->size

		/*

		 * In the case of FW reset, this may be cleared

		 * but the force_free path will still attempt to

		 * free the resource. Prevent a NULL pointer access.

	/*

	 * Ensure that the port is ready AND the mailbox is

	 * ready before signaling that the dump is ready to go.

 payload size calculation */

 4 = xri_start + xri_count */

 xri_count = # of XRI's registered */

 sizeof(uint64_t) = physical address size */

 2 = # of physical addresses per page set */

		/*

		 * We can't fit more than 16 descriptors into an embedded mbox

		 * command, it has to be non-embedded

 Check if header templates needed */

 round up to a page */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

/*

 * NPORT

 *

 * Port object for physical port and NPIV ports.

/*

 * NPORT REFERENCE COUNTING

 *

 * A nport reference should be taken when:

 * - an nport is allocated

 * - a vport populates associated nport

 * - a remote node is allocated

 * - a unsolicited frame is processed

 * The reference should be dropped when:

 * - the unsolicited frame processesing is done

 * - the remote node is removed

 * - the vport is removed

 * - the nport is removed

 Find a nport, given the WWNN and WWPN */

 Return a failure if this nport has already been allocated */

 initialize refcount */

 Copy service parameters from domain */

 Update requested fc_id */

 Update the nport's service parameters for the new wwn's */

	/*

	 * if this is the "first" nport of the domain,

	 * then make it the "phys" nport

	/*

	 * if this is the physical nport,

	 * then clear it out of the domain

 Find a nport object, given an FC_ID */

 Set our lookup */

 Update our display_name */

 Register a nport, given an FC_ID */

		/*

		 * If this is a vport, logout of the fabric

		 * controller so that it deletes the vport

		 * on the switch.

 if link is down, don't send logo */

 sent LOGO, wait for response */

		/*

		 * failed to send LOGO,

		 * go ahead and cleanup node anyways

 Clear the nport reference in the vport specification */

 Flag this nport as shutting down */

 Remove the nport from the domain's lookup table */

 Not much we can do, free the nport anyways */

 sm: node list is not empty / shutdown nodes */

 the physical nport is attached */

 ignore */

 If wwpn is zero, then we'll let the f/w assign wwpn*/

 Update the nport's service parameters */

		/*

		 * if nport->fc_id is uninitialized,

		 * then request that the fabric node use FDISC

		 * to find an fc_id.

		 * Otherwise we're restoring vports, or we're in

		 * fabric emulation mode, so attach the fc_id

	/*

	 * This state is entered after the nport is allocated;

	 * it then waits for a fabric node

	 * FDISC to complete, which requests a nport attach.

	 * The nport attach complete is handled in this state.

 Find our fabric node, and forward this event */

 sm: / forward nport attach to fabric node */

		/*

		 * Update the vport (if its not the physical nport)

		 * parameters

 ignore these events - just wait for the all free event */

		/*

		 * Remove the nport from the domain's

		 * sparse vector lookup table

 Not much we can do, free the nport anyways */

 Ignore as we are waiting for the free CB */

 All done, free myself */

 Use the vport spec to find the associated vports and start them */

	/*

	 * Create a vport spec if we need to recreate

	 * this vport after a link up event

 walk the efc_vport_list and remove from there */

 No domain means no nport to look for */

 Shutdown this NPORT */

	/*

	 * walk the efc_vport_list and return failure

	 * if a valid(vport with non zero WWPN and WWNN) vport entry

	 * is already created

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

/*

 * Functions to build and send ELS/CT/BLS commands and responses.

 initialize refcount */

 populate generic io fields */

 now allocate DMA for request and response */

 initialize fields */

 add els structure to ELS IO list */

	/* Send list empty event if the IO allocator

	 * is disabled, and the list is empty

	 * If node->els_io_enabled was not checked,

	 * the event would be posted continually

 free ELS request and response buffers */

 Retry delay timer expired, retry the ELS request */

 set the response len element of els->rsp */

 set the response len element of els->rsp */

	/* FW returns the number of bytes received on the link in

	 * the WCQE, not the amount placed in the buffer; use this info to

	 * check if there was an overrun.

 Post event to ELS IO object */

 delay and retry if reason code is Logical Busy */

 Other error */

 update ELS request counter */

 Prepare the IO request details */

 Post node event */

 Other error */

 increment ELS completion counter */

 Prepare the IO request details */

 Build PLOGI request */

 Build FLOGI request */

 Build FDISC request */

 Build PRLI request */

 Build LOGO request */

 Build ADISC request */

 copy our port's service parameters to payload */

 Set Application header support bit if requested */

 copy our port's service parameters to payload */

 Go ahead and send the ELS_ACC */

 words */

	/* don't want further events that could come; e.g. abort requests

	 * from the node state machine; thus, disable state machine

 Prepare the IO request details */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

/*

 * LIBEFC LOCKING

 *

 * The critical sections protected by the efc's spinlock are quite broad and

 * may be improved upon in the future. The libefc code and its locking doesn't

 * influence the I/O path, so excessive locking doesn't impact I/O performance.

 *

 * The strategy is to lock whenever processing a request from user driver. This

 * means that the entry points into the libefc library are protected by efc

 * lock. So all the state machine transitions are protected.

 Create Node pool */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

 Clear the nport attached flag */

 Free the service parameters buffer */

 Free the SLI resources */

 Now inform the registered callbacks */

 Set the nport attached flag */

 If there is a pending free request, then handle it now */

 If there is a pending free request, then handle it now */

 Allocate memory for the service parameters */

	/*

	 * allocate a VPI object for the port and stores it in the

	 * indicator field of the port object.

		/*

		 * If the WWPN is NULL, fetch the default

		 * WWPN and WWNN before initializing the VPI

 domain NULL and wwpn non-NULL */

 register previously-allocated VPI with the device */

 Issue the UNREG_VPI command to free the assigned VPI context */

 Free the service parameters buffer */

 Free the SLI resources */

 Send alloc/attach ok to the physical nport */

 Now inform the registered callbacks */

	/*

	 * For FC, the HW alread registered an FCFI.

	 * Copy FCF information into the domain and jump to INIT_VFI.

 allocate memory for the service parameters */

 Check for invalid indicator */

 NULL SLI port indicates an unallocated remote node */

	/*

	 * If the attach count is non-zero, this RPI has already been reg'd.

	 * Otherwise, register the RPI

 Update a remote node object with the remote port's service params */

		/*

		 * In certain cases, a non-zero MQE status is OK (all must be

		 * true):

		 *   - node is attached

		 *   - status is 0x1400

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

/*

 * domain_sm Domain State Machine: States

 Accept domain callback events from the user driver */

 extract the fcf_wwn */

 lookup domain, or allocate a new one */

 Hold frames to clear the domain pointer from the xport lookup */

 initialize refcount */

 Register a callback to be called when the domain is freed */

		/*

		 * this can arise if an FLOGI fails on the NPORT,

		 * and the NPORT is shutdown

 save drec, mark domain_found_pending */

 unmark domain_found_pending */

 Allocate a nport and transition to __efc_nport_allocated */

		/* allocate struct efc_nport object for local port

		 * Note: drec->fc_id is ALPA from read_topology only if loop

		/*

		 * If the loop position map includes ALPA == 0,

		 * then we are in a public loop (NL_PORT)

		 * Note that the first element of the loopmap[]

		 * contains the count of elements, and if

		 * ALPA == 0 is present, it will occupy the first

		 * location after the count.

 Initiate HW domain alloc */

 Initiate HW domain alloc */

 Save the domain service parameters */

		/*

		 * Update the nport's service parameters,

		 * user might have specified non-default names

		/*

		 * Take the loop topology path,

		 * unless we are an NL_PORT (public loop)

			/*

			 * For loop, we already have our FC ID

			 * and don't need fabric login.

			 * Transition to the allocated state and

			 * post an event to attach to

			 * the domain. Note that this breaks the

			 * normal action/transition

			 * pattern here to avoid a race with the

			 * domain attach callback.

 sm: is_loop / domain_attach */

 alloc fabric node, send FLOGI */

 Accept frames */

 sm: / start fabric logins */

 Should not happen */

 Update nport lookup */

 Update display name for the nport */

 Issue domain attach call */

 sm: / domain_attach */

 Should not happen */

			/*

			 * if there are nports, transition to

			 * wait state and send shutdown to each

			 * nport

 no nports exist, free domain */

		/*

		 * Set domain notify pending state to avoid

		 * duplicate domain event post

 Mark as attached */

 Transition to ready */

 sm: / forward event to all nports and nodes */

 We have an FCFI, so we can accept frames */

		/*

		 * Notify all nodes that the domain attach request

		 * has completed

		 * Note: nport will have already received notification

		 * of nport attached as a result of the HW's port attach.

 Should not happen */

		/*

		 * Domain lost while waiting for an attach to complete,

		 * go to a state that waits for  the domain attach to

		 * complete, then handle domain lost

		/*

		 * In P2P we can get an attach request from

		 * the other FLOGI path, so drop this one

 start any pending vports */

			/*

			 * if there are nports, transition to wait state

			 * and send shutdown to each nport

 no nports exist, free domain */

 Should not happen */

 can happen during p2p */

 Assume that the domain is attached */

		/*

		 * Verify that the requested FC_ID

		 * is the same as the one we're working with

 Wait for nodes to free prior to the domain shutdown */

 sm: / efc_hw_domain_free */

 Request efc_hw_domain_free and wait for completion */

 sm: / domain_free */

			/*

			 * save fcf_wwn and drec from this domain,

			 * free current domain and allocate

			 * a new one with the same fcf_wwn

			 * could use a SLI-4 "re-register VPI"

			 * operation here?

			/*

			 * got a new domain; at this point,

			 * there are at least two domains

			 * once the req_domain_free flag is processed,

			 * the associated domain will be removed.

	/*

	 * Wait for the domain alloc/attach completion

	 * after receiving a domain lost.

			/*

			 * if there are nports, transition to

			 * wait state and send shutdown to each nport

 no nports exist, free domain */

		/* need to check for hold frames condition after each frame

		 * processed because any given frame could cause a transition

		 * to a state that holds frames

 Get next frame/sequence */

 now dispatch frame(s) to dispatch function */

	/*

	 * If we are holding frames or the domain is not yet registered or

	 * there's already frames on the pending list,

	 * then add the new frame to pending list

 immediately process pending frames */

		/*

		 * We are not holding frames and pending list is empty,

		 * just process frame. A non-zero return means the frame

		 * was not handled - so cleanup

 extract the s_id and d_id */

 Drop frame */

 p2p will use this case */

 Lookup the node given the remote s_id */

 If not found, then create a new node */

		/*

		 * If this is solicited data or control based on R_CTL and

		 * there is no node context, then we can drop the frame

 don't send PLOGI on efc_d_init entry */

 add frame to node's pending list */

 now dispatch frame to the node frame handler */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

/*

 * device_sm Node State Machine: Remote Device States

	/*

	 * Wait for backend session registration

	 * to complete before sending PRLI resp

 Handle shutdown events */

 call default event handler common to all nodes */

	/*

	 * State is entered when a node sends a delete initiator/target call

	 * to the target-server/initiator-client and needs to wait for that

	 * work to complete.

 These are expected events. */

		/*

		 * node has either been detached or is in the process

		 * of being detached,

		 * call common node's initiate cleanup function

 Can happen as ELS IO IO's complete */

 ignore shutdown events as we're already in shutdown path */

 have default shutdown event take precedence */

 don't care about domain_attach_ok */

 These are expected events. */

 Can happen as ELS IO IO's complete */

 ignore shutdown events as we're already in shutdown path */

 have default shutdown event take precedence */

 don't care about domain_attach_ok */

 assume no wait needed */

 make necessary delete upcall(s) */

 assume no wait needed */

		/* we've initiated the upcalls as needed, now kick off the node

		 * detach to precipitate the aborting of outstanding exchanges

		 * associated with said node

		 *

		 * Beware: if we've made upcall(s), we've already transitioned

		 * to a new state by the time we execute this.

		 * consider doing this before the upcalls?

			/* issue hw node free; don't care if succeeds right

			 * away or sometime later, will check node->attached

			 * later in shutdown process

 if neither initiator nor target, proceed to cleanup */

			/*

			 * node has either been detached or is in

			 * the process of being detached,

			 * call common node's initiate cleanup function

		/* Ignore, this can happen if an ELS is

		 * aborted while in a delay/retry state

 send PLOGI automatically if initiator */

 Save the OX_ID for sending LS_ACC sometime later */

 PLOGI ACC completions */

 LOGO response received, sent shutdown */

 sm: / post explicit logout */

		/* we're not attached and nport is p2p,

		 * need to attach

		/* we're not attached and nport is fabric, domain

		 * attach should have already been requested as part

		 * of the fabric state machine, wait for it

		/* Two possibilities:

		 * 1. received a PLOGI before our FLOGI has completed

		 *    (possible since completion comes in on another

		 *    CQ), thus we don't know what we're connected to

		 *    yet; transition to a state to wait for the

		 *    fabric node to tell us;

		 * 2. PLOGI received before link went down and we

		 * haven't performed domain attach yet.

		 * Note: we cannot distinguish between 1. and 2.

		 * so have to assume PLOGI

		 * was received after link back up.

	/*

	 * This state is entered when a node is instantiated,

	 * either having been discovered from a name services query,

	 * or having received a PLOGI/FLOGI.

		/* only send if we have initiator capability,

		 * and domain is attached

 T, or I+T */

 domain not attached; several possibilities: */

 domain already attached */

 sm: / save sparams, send FLOGI acc */

 send FC LS_ACC response, override s_id */

			/* most likely a frame left over from before a link

			 * down; drop and

			 * shut node down w/ "explicit logout" so pending

			 * frames are processed

			/* most likely a frame left over from before a link

			 * down; drop and shut node down w/ "explicit logout"

			 * so pending frames are processed

		/* note: problem, we're now expecting an ELS REQ completion

		 * from both the LOGO and PLOGI

			/* most likely a frame left over from before a

			 * link down; drop and

			 * shut node down w/ "explicit logout" so pending

			 * frames are processed

 Send LOGO */

			/*

			 * failed to send LOGO, go ahead and cleanup node

			 * anyways

 sent LOGO, wait for response */

 don't care about domain_attach_ok */

 T, or I+T */

		/* received PLOGI with svc parms, go ahead and attach node

		 * when PLOGI that was sent ultimately completes, it'll be a

		 * no-op

		 *

		 * If there is an outstanding PLOGI sent, can we set a flag

		 * to indicate that we don't want to retry it if it times out?

 sm: domain->attached / efc_node_attach */

 I, or I+T */

		/* sent PLOGI and before completion was seen, received the

		 * PRLI from the remote node (WCQEs and RCQEs come in on

		 * different queues and order of processing cannot be assumed)

		 * Save OXID so PRLI can be sent after the attach and continue

		 * to wait for PLOGI response

 why don't we do a shutdown here?? */

 PLOGI response received */

 Completion from PLOGI sent */

 sm: / save sparams, efc_node_attach */

 PLOGI response received */

 PLOGI failed, shutdown the node */

 Our PLOGI was rejected, this is ok in some cases */

		/* not logged in yet and outstanding PLOGI so don't send LOGO,

		 * just drop

		/*

		 * Since we've received a PRLI, we have a port login and will

		 * just need to wait for the PLOGI response to do the node

		 * attach and then we can send the LS_ACC for the PRLI. If,

		 * during this time, we receive FCP_CMNDs (which is possible

		 * since we've already sent a PRLI and our peer may have

		 * accepted). At this time, we are not waiting on any other

		 * unsolicited frames to continue with the login process. Thus,

		 * it will not hurt to hold frames here.

 PLOGI response received */

 Completion from PLOGI sent */

 sm: / save sparams, efc_node_attach */

 PLOGI response received */

 PLOGI failed, shutdown the node */

 sm: / efc_node_attach */

		/* At the time the PLOGI was received, the topology was unknown,

		 * so we didn't know which node would perform the domain attach:

		 * 1. The node from which the PLOGI was sent (p2p) or

		 * 2. The node to which the FLOGI was sent (fabric).

			/* if this is p2p, need to attach to the domain using

			 * the d_id from the PLOGI received

		/* else, if this is fabric, the domain attach

		 * should be performed by the fabric node (node sending FLOGI);

		 * just wait for attach to complete

 sm: / efc_node_attach */

 sm: send_plogi_acc is set / send PLOGI acc */

 Normal case for T, or I+T */

 Normal case for I */

 sm: send_plogi_acc is not set / send PLOGI acc */

 node attach failed, shutdown the node */

 Handle shutdown events */

 wait for any of these attach events and then shutdown */

 node attach failed, shutdown the node */

 ignore shutdown events as we're already in shutdown path */

 have default shutdown event take precedence */

 Normal case for I or I+T */

 sm: if enable_ini / send PRLI */

 can now expect ELS_REQ_OK/FAIL/RJT */

 Normal case for T or I+T */

Only FCP is supported*/

 PRLI response */

 Normal case for I or I+T */

 sm: / process PRLI payload */

 PRLI response failed */

 I, I+T, assume some link failure, shutdown node */

		/* PRLI rejected by remote

		 * Normal for I, I+T (connected to an I)

		 * Node doesn't want to be a target, stay here and wait for a

		 * PRLI from the remote node

		 * if it really wants to connect to us as target

 Normal T, I+T, target-server rejected the process login */

		/* This would be received only in the case where we sent

		 * LS_RJT for the PRLI, so

		 * do nothing.   (note: as T only we could shutdown the node)

		/*sm: / save sparams, set send_plogi_acc,

		 *post implicit logout

		 * Save plogi parameters

		/* Restart node attach with new service parameters,

		 * and send ACC

 I, T, I+T */

 sm: / send LOGO acc */

 sm: / post explicit logout */

		/* sm: / save sparams, set send_plogi_acc, post implicit

		 * logout

		 * Save plogi parameters

		/*

		 * Restart node attach with new service parameters,

		 * and send ACC

 T, I+T: remote initiator is slow to get started */

Only FCP is supported*/

 sm: / send PRLO acc */

 need implicit logout? */

 sm: / send LOGO acc */

 sm: / send ADISC acc */

 sm: / process ABTS */

 T, or I+T, PRLI accept completed ok */

 T, or I+T, PRLI accept failed to complete */

 two approaches, reauthenticate with PLOGI/PRLI, or ADISC */

 reauthenticate with PLOGI/PRLI */

 efc_node_transition(node, __efc_d_discovered, NULL); */

 reauthenticate with ADISC */

 sm: / send ADISC */

		/* sm: / save sparams, set send_plogi_acc, post implicit

		 * logout

		 * Save plogi parameters

		/*

		 * Restart node attach with new service parameters, and send

		 * ACC

		/* most likely a stale frame (received prior to link down),

		 * if attempt to send LOGO, will probably timeout and eat

		 * up 20s; thus, drop FCP_CMND

 I, T, I+T */

 sm: / send LOGO acc */

		/* received an LS_RJT, in this case, send shutdown

		 * (explicit logo) event which will unregister the node,

		 * and start over with PLOGI

 sm: / post explicit logout */

		/* In this case, we have the equivalent of an LS_RJT for

		 * the ADISC, so we need to abort the ADISC, and re-login

		 * with PLOGI

 sm: / request abort, send LOGO acc */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

/*

 * Generic state machine framework.

/**

 * efc_sm_post_event() - Post an event to a context.

 *

 * @ctx: State machine context

 * @evt: Event to post

 * @data: Event-specific data (if any)

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

 Find an FC node structure given the FC port ID */

 initialize refcount */

		/*

		 * Save the name server node. We will send fake RSCN event at

		 * the end to handle ignored RSCN event during node deletion

 Free HW resources */

 if the gidpt_delay_timer is still running, then delete it */

	/*

	 * If the node_list is empty,

	 * then post a ALL_CHILD_NODES_FREE event to the nport,

	 * after the lock is released.

	 * The nport may be free'd as a result of the event.

 sending fake RSCN event to name server node */

 Update node->wwpn/wwnn */

 take lock to protect node->rnode.attached */

	/*

	 * currently, only case for implicit logo is PLOGI

	 * recvd. Thus, node's ELS IO pending list won't be

	 * empty (PLOGI will be on it)

 Re-attach node with the same HW node resources */

 cleanup any pending LS_ACC ELSs */

	/*

	 * there are two scenarios where we want to keep

	 * this node alive:

	 * 1. there are pending frames that need to be

	 *    processed or

	 * 2. we're an initiator and the remote node is

	 *    a target and we need to re-authenticate

			/*

			 * we're an initiator and

			 * node shutting down is a target;

			 * we'll need to re-authenticate in

			 * initial state

		/*

		 * transition to __efc_d_init

		 * (will retain HW node resources)

		/*

		 * either pending frames exist or we are re-authenticating

		 * with PLOGI (or both); in either case, return to initial

		 * state

 else: let node shutdown occur */

 by default, we will be freeing node after we unwind */

			/* Node shutdown b/c of PLOGI received when node

			 * already logged in. We have PLOGI service

			 * parameters, so submit node attach; we won't be

			 * freeing this node

			/*

			 * shutdown due to link down,

			 * node going away (xport event) or

			 * nport shutdown, purge pending and

			 * proceed to cleanup node

 cleanup any pending LS_ACC ELSs */

 check to see if ELS requests, completions are quiesced */

 hw node detach already completed, proceed */

			/*

			 * hw node detach hasn't completed,

			 * transition and wait

	/*

	 * if ELS's have already been quiesced, will move to next state

	 * if ELS's have not been quiesced, abort them

 Node state machine: Wait for all ELSs to complete */

 all ELS IO's complete */

 don't care about domain_attach_ok */

 ignore shutdown events as we're already in shutdown path */

 have default shutdown event take precedence */

 node is officially no longer attached */

 As IOs and ELS IO's complete we expect to get these events */

 don't care about domain_attach_ok */

 ignore shutdown events as we're already in shutdown path */

 have default shutdown event take precedence */

 first check to see if no ELS IOs are outstanding */

 If there are any active IOS, Free them. */

 Can happen as ELS IO IO's complete */

 ignore shutdown events as we're already in shutdown path */

 have default shutdown event take precedence */

 don't care about domain_attach_ok */

	/*

	 * node->attached must be set appropriately

	 * for all node attach/detach events

	/*

	 * handle any ELS completions that

	 * other states either didn't care about

	 * or forgot about

	/*

	 * handle any ELS request completions that

	 * other states either didn't care about

	 * or forgot about

		/*

		 * Unsupported ELS was received,

		 * send LS_RJT, command not supported

 sm: / send ELS_RJT */

 if we didn't catch this in a state, send generic LS_RJT */

 sm: / send BA_ACC */

	/* If our event call depth is one and

	 * we're not holding frames

	 * then we can dispatch any pending frames.

	 * We don't want to allow the efc_process_node_pending()

	 * call to recurse.

	/*

	 * Free the node object if so requested,

	 * and we're at an event call depth of zero

	/*

	 * This state is entered when a state is "paused". When resumed, the

	 * node is transitioned to a previously saved state (node->ndoedb_state)

 find a matching event for the ELS command */

		/* need to check for hold frames condition after each frame

		 * processed because any given frame could cause a transition

		 * to a state that holds frames

 Get next frame/sequence */

 now dispatch frame(s) to dispatch function */

 Notify the node to resume */

 Notify the node to resume */

 Notify the node to resume */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

/*

 * This file implements remote node state machines for:

 * - Fabric logins.

 * - Fabric controller events.

 * - Name/directory services interaction.

 * - Point-to-point logins.

/*

 * fabric_sm Node State Machine: Fabric States

 * ns_sm Node State Machine: Name/Directory Services States

 * p2p_sm Node State Machine: Point-to-Point Node States

		/* issue hw node free; don't care if succeeds right away

		 * or sometime later, will check node->attached later in

		 * shutdown process

	/*

	 * node has either been detached or is in the process of being detached,

	 * call common node's initiate cleanup function

 call default event handler common to all nodes */

 send FLOGI */

	/*

	 * now loop through the nodes in the nport

	 * and send topology notification

 Check to see if the fabric is an F_PORT or and N_PORT */

 sm: if not nport / efc_domain_attach */

 ext_status has the fc_id, attach domain */

  sm: if nport and p2p_winner / efc_domain_attach */

				/*

				 * already attached,

				 * just send ATTACH_OK

			/*

			 * peer is p2p winner;

			 * PLOGI will be received on the

			 * remote SID=1 node;

			 * this node has served its purpose

		/*

		 * with these errors, we have no recovery,

		 * so shutdown the nport, leave the link

		 * up and the domain ready

 sm: / send FDISC */

 fc_id is in ext_status */

 sm: / efc_nport_attach */

 sm: / shutdown nport */

 Instantiate a name services node */

	/*

	 * for found ns, should we be transitioning from here?

	 * breaks transition only

	 *  1. from within state machine or

	 *  2. if after alloc

	/*

	 * for found ns, should we be transitioning from here?

	 * breaks transition only

	 *  1. from within state machine or

	 *  2. if after alloc

 sm: if enable_ini / start fabctl node */

 Instantiate the fabric controller (sends SCR) */

 sm: / send PLOGI */

 Save service parameters */

 sm: / save sparams, efc_node_attach */

 sm: / send RFTID */

 node attach failed, shutdown the node */

	/*

	 * if receive RSCN just ignore,

	 * we haven't sent GID_PT yet (ACC sent by fabctl node)

 wait for any of these attach events and then shutdown */

 ignore shutdown event as we're already in shutdown path */

 sm: / send RFFID */

	/*

	 * if receive RSCN just ignore,

	 * we haven't sent GID_PT yet (ACC sent by fabctl node)

	/*

	 * Waits for an RFFID response event;

	 * if rscn enabled, a GIDPT name services request is issued.

 sm: if enable_rscn / send GIDPT */

 if 'T' only, we're done, go to idle */

	/*

	 * if receive RSCN just ignore,

	 * we haven't sent GID_PT yet (ACC sent by fabctl node)

 Count the number of nodes */

 Allocate a buffer for all nodes */

 Fill buffer with fc_id of active nodes */

 update the active nodes buffer */

 Those remaining in the active_nodes[] are now gone ! */

		/*

		 * if we're an initiator and the remote node

		 * is a target, then post the node missing event.

		 * if we're target and we have enabled

		 * target RSCN, then post the node missing event.

 Don't create node for ourselves */

			/*

			 * send PLOGI automatically

			 * if initiator

	/*

	 * Wait for a GIDPT response from the name server. Process the FC_IDs

	 * that are reported by creating new remote ports, as needed.

 sm: / process GIDPT payload */

 not much we can do; will retry with the next RSCN */

 if receive RSCN here, queue up another discovery processing */

	/*

	 * Wait for RSCN received events (posted from the fabric controller)

	 * and restart the GIDPT name services query and processing.

 sm: / send GIDPT */

		/*

		 * If target RSCN processing is enabled,

		 * and this is target only (not initiator),

		 * and tgt_rscn_delay is non-zero,

		 * then we delay issuing the GID_PT

		/*

		 * Compute the delay time.

		 * Set to tgt_rscn_delay, if the time since last GIDPT

		 * is less than tgt_rscn_period, then use tgt_rscn_period.

 no need to login to fabric controller, just send SCR */

	/*

	 * Fabric controller node state machine:

	 * Wait for an SCR response from the fabric controller.

 Forward this event to the name-services node */

	/*

	 * Fabric controller node state machine: Ready.

	 * In this state, the fabric controller sends a RSCN, which is received

	 * by this node and is forwarded to the name services node object; and

	 * the RSCN LS_ACC is sent.

		/*

		 * sm: / process RSCN (forward to name services node),

		 * send LS_ACC

		/*

		 * this transient node (SID=0 (recv'd FLOGI)

		 * or DID=fabric (sent FLOGI))

		 * is the p2p winner, will use a separate node

		 * to send PLOGI to peer

			/*

			 * the "other" transient p2p node has

			 * already kicked off the

			 * new node from which PLOGI is sent

			/*

			 * create new node (SID=1, DID=2)

			 * from which to send PLOGI

 sm: / allocate p2p remote node */

		/*

		 * the transient node (SID=0 or DID=fabric)

		 * has served its purpose

			/*

			 * if this is the SID=0 node,

			 * move to the init state in case peer

			 * has restarted FLOGI discovery and FLOGI is pending

 don't send PLOGI on efc_d_init entry */

			/*

			 * if this is the DID=fabric node

			 * (we initiated FLOGI), shut it down

 sm: / send PLOGI */

 sm: send BA_ACC */

 sm: if p2p_winner / domain_attach */

			/* this node has served its purpose;

			 * we'll expect a PLOGI on a separate

			 * node (remote SID=0x1); return this node

			 * to init state in case peer

			 * restarts discovery -- it may already

			 * have (pending frames may exist).

 don't send PLOGI on efc_d_init entry */

		/*

		 * LS_ACC failed, possibly due to link down;

		 * shutdown node and wait

		 * for FLOGI discovery to restart

 sm: / send BA_ACC */

 sm: / save sparams, efc_node_attach */

 if we're in external loopback mode, just send LS_ACC */

			/*

			 * if this isn't external loopback,

			 * pass to default handler

 I, or I+T */

		/* sent PLOGI and before completion was seen, received the

		 * PRLI from the remote node (WCQEs and RCQEs come in on

		 * different queues and order of processing cannot be assumed)

		 * Save OXID so PRLI can be sent after the attach and continue

		 * to wait for PLOGI response

		/*

		 * Since we've received a PRLI, we have a port login and will

		 * just need to wait for the PLOGI response to do the node

		 * attach and then we can send the LS_ACC for the PRLI. If,

		 * during this time, we receive FCP_CMNDs (which is possible

		 * since we've already sent a PRLI and our peer may have

		 * accepted).

		 * At this time, we are not waiting on any other unsolicited

		 * frames to continue with the login process. Thus, it will not

		 * hurt to hold frames here.

 PLOGI response received */

 Completion from PLOGI sent */

 sm: / save sparams, efc_node_attach */

 PLOGI response received */

 PLOGI failed, shutdown the node */

 Can't happen in P2P */

 Normal case for I */

 sm: send_plogi_acc is not set / send PLOGI acc */

 node attach failed, shutdown the node */

 set nport flags to indicate p2p "winner" */

 no winner; only okay if external loopback enabled */

			/*

			 * External loopback mode enabled;

			 * local nport and remote node

			 * will be registered with an NPortID = 1;

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

 attempt to detemine the dump size for function 0 only. */

	/*

	 * efct_hw_init() relies on NULL pointers indicating that a structure

	 * needs allocation. If a structure is non-NULL, efct_hw_init() won't

	 * free/realloc that memory

 Create mailbox command ctx pool */

 Create mailbox request ctx pool for library callback */

	/*

	 * Set all the queue sizes to the maximum allowed.

	/*

	 * Adjust the size of the WQs so that the CQ is twice as big as

	 * the WQ to allow for 2 completions per IO. This allows us to

	 * handle multi-phase as well as aborts.

	/*

	 * The RQ assignment for RQ pair mode.

	/*

	 * Set io->done to NULL, to avoid any callbacks, should

	 * a completion be received for one of these IOs

 Restore the default */

 clear xbusy flag if WCQE[XB] is clear */

 get extended CQE status */

 release the count for re-posting the buffer */

 efct_hw_io_free(hw, io); */

		/*

		 * If we're not an originator IO, and XB is set, then issue

		 * abort for the IO from within the HW

			/*

			 * Because targets may send a response when the IO

			 * completes using the same XRI, we must wait for the

			 * XRI_ABORTED CQE to issue the IO callback

				/*

				 * latch status to return after abort is

				 * complete

				/*

				 * Already being aborted by someone else (ABTS

				 * perhaps). Just return original

				 * error.

				/* Failed to abort for some other reason, log

				 * error

 use latched status if exists */

 Restore default SGL */

 Create WQE buffs for IO */

 re-use existing IOs, including SGLs */

 Initialize the pool of HW IO objects */

 initialize IO fields */

 Assign a WQE buff */

 Allocate the request tag for this IO */

 Now for the fields that are initialized on each free */

 The XB flag isn't cleared on IO free, so init to zero */

		/* Copy address of SGL's into local sgls[] array, break

		 * out if the xri is not contiguous.

 Check that we have contiguous xri values */

 Add to tail if successful */

 build the set_features command */

	/*

	 * Set the filter match/mask values from hw's

	 * filter_def values

	/*

	 * Update the rq_id's of the FCF configuration

	 * (don't update more than the number of rq_cfg

	 * elements)

 Set the filter match/mask values from hw's filter_def values */

 Invoke REG_FCFI_MRQ */

	/*

	 * Since the hash is always bigger than the number of queues, then we

	 * never have to worry about an infinite loop.

 not used, claim the entry */

 build the set_features command */

	/*

	 * Make sure the command lists are empty. If this is start-of-day,

	 * they'll be empty since they were just initialized in efct_hw_setup.

	 * If we've just gone through a reset, the command and command pending

	 * lists should have been cleaned up as part of the reset

	 * (efct_hw_reset()).

 Free RQ buffers if prevously allocated */

	/*

	 * The IO queues must be initialized here for the reset case. The

	 * efct_hw_init_io() function will re-add the IOs to the free list.

	 * The cmd_head list should be OK since we free all entries in

	 * efct_hw_command_cancel() that is called in the efct_hw_reset().

	/* If we are in this function due to a reset, there may be stale items

	 * on lists that need to be removed.  Clean them up.

 If MRQ not required, Make sure we dont request feature. */

	/*

	 * Set FDT transfer hint, only works on Lancer

		/*

		 * Non-fatal error. In particular, we can disregard failure to

		 * set EFCT_HW_FDT_XFER_HINT on devices with legacy firmware

		 * that do not support EFCT_HW_FDT_XFER_HINT feature.

 zero the hashes */

 Allocate and p_st RQ buffers */

	/*

	 * Allocate the WQ request tag pool, if not previously allocated

	 * (the request tag value is 16 bits, thus the pool allocation size

	 * of 64k)

	/*

	 * Arming the EQ allows (e.g.) interrupts when CQ completions write EQ

	 * entries

	/*

	 * Initialize RQ hash

	/*

	 * Initialize WQ hash

	/*

	 * Arming the CQ allows (e.g.) MQ completions to write CQ entries

 Set RQ process limit*/

 record the fact that the queues are functional */

	/*

	 * Allocate a HW IOs for send frame.

 Initialize send frame sequence id */

 Allocate header buffers */

 Allocate payload buffers */

	/*

	 * In RQ pair mode, we MUST post the header and payload buffer at the

	 * same time.

 Free hw_rq buffers */

 Assumes lock held */

 Only submit MQE if there's room */

	/*

	 * If the chip is in an error state (UE'd) then reject this mailbox

	 * command.

	/*

	 * Send a mailbox command to the hardware, and either wait for

	 * a completion (EFCT_CMD_POLL) or get an optional asynchronous

	 * completion (EFCT_CMD_NOWAIT).

 Add to pending list */

 Submit as much of the pending list as we can */

 Post any pending requests */

	/*

	 * Manually clean up remaining commands. Note: since this calls

	 * efct_hw_command_process(), we'll also process the cmd_pending

	 * list, so no need to manually clean that out.

	/*

	 * Allocate a callback context (which includes the mbox cmd buffer),

	 * we need this to be persistent as the mbox cmd submission may be

	 * queued and executed later execution.

	/*

	 * When an IO is freed, depending on the exchange busy flag,

	 * move it to the correct list.

		/*

		 * add to wait_free list and wait for XRI_ABORTED CQEs to clean

		 * up

 IO not busy, add to free list */

 initialize IO fields */

 Restore default SGL */

 perform common cleanup */

 remove from in-use list */

 Clear / reset the scatter-gather list */

	/*

	 * Some IO types have underlying hardware requirements on the order

	 * of SGEs. Process all special entries here.

 populate host resident XFER_RDY buffer */

		/*

		 * For FCP_TSEND64, the first 2 entries are SKIP SGE's

		/*

		 * No skips, etc. for FCP_TRSP64

	/*

	 * Write skip entries

	/*

	 * Set last

	/*

	 * Always assume this is the last entry and mark as such.

	 * If this is not the first entry unset the "last SGE"

	 * indication for the previous entry

 Set first_data_bde if not previously set */

	/*

	 * For IOs that were aborted internally, we may need to issue the

	 * callback here depending on whether a XRI_ABORTED CQE is expected ot

	 * not. If the status is Local Reject/No XRI, then

	 * issue the callback now.

		/*

		 * Use latched status as this is always saved for an internal

		 * abort Note: We won't have both a done and abort_done

		 * function, so don't worry about

		 *       clobbering the len, status and ext fields.

 clear abort bit to indicate abort is complete */

 Free the WQ callback */

	/*

	 * Call efct_hw_io_free() because this releases the WQ reservation as

	 * well as doing the refcount put. Don't duplicate the code here.

 Suppress ABTS retries */

 take a reference on IO being aborted */

 command no longer active */

 Must have a valid WQ reference */

 efct_ref_get(): same function */

	/*

	 * Validation checks complete; now check to see if already being

	 * aborted, if not set the flag.

 efct_ref_get(): same function */

	/*

	 * If we got here, the possibilities are:

	 * - host owned xri

	 *	- io_to_abort->wq_index != U32_MAX

	 *		- submit ABORT_WQE to same WQ

	 * - port owned xri:

	 *	- rxri: io_to_abort->wq_index == U32_MAX

	 *		- submit ABORT_WQE to any WQ

	 *	- non-rxri

	 *		- io_to_abort->index != U32_MAX

	 *			- submit ABORT_WQE to same WQ

	 *		- io_to_abort->index == U32_MAX

	 *			- submit ABORT_WQE to any WQ

 Allocate a request tag for the abort portion of this IO */

	/*

	 * If the wqe is on the pending list, then set this wqe to be

	 * aborted when the IO's wqe is removed from the list.

	/* ABORT_WQE does not actually utilize an XRI on the Port,

	 * therefore, keep xbusy as-is to track the exchange's state,

	 * not the ABORT_WQE's state

 efct_ref_get(): same function */

 initialize reqtag pool lock */

	/*

	 * Since the hash is always bigger than the maximum number of Qs, then

	 * we never have to worry about an infinite loop. We will always find

	 * an unused entry.

	/*

	 * The caller should disable interrupts if they wish to prevent us

	 * from processing during a shutdown. The following states are defined:

	 *   EFCT_HW_STATE_UNINITIALIZED - No queues allocated

	 *   EFCT_HW_STATE_QUEUES_ALLOCATED - The state after a chip reset,

	 *                                    queues are cleared.

	 *   EFCT_HW_STATE_ACTIVE - Chip and queues are operational

	 *   EFCT_HW_STATE_RESET_IN_PROGRESS - reset, we still want completions

	 *   EFCT_HW_STATE_TEARDOWN_IN_PROGRESS - We still want mailbox

	 *                                        completions.

 Get pointer to struct hw_eq */

				/*

				 * Received a sentinel EQE indicating the

				 * EQ is full. Process all CQs

 Every so often, set the wqec bit to generate comsummed completions */

 Decrement WQ free count */

 Update free count with value passed in */

 completion type */

		/*

		 * The sign of status is significant. If status is:

		 * == 0 : call completed correctly and

		 * the CQE indicated success

		 * > 0 : call completed correctly and

		 * the CQE indicated an error

		 * < 0 : call failed and no information is available about the

		 * CQE

				/*

				 * Notification that an entry was consumed,

				 * but not completed

			/*

			 * Process MQ entry. Note there is no way to determine

			 * the MQ_ID from the completion entry.

 Submit any HW IOs that are on the WQ pending list */

 search IOs wait free list */

 IO lookup failure should never happen */

 mark IO as no longer busy */

	/*

	 * For IOs that were aborted internally, we need to issue any pending

	 * callback here.

		/*

		 * Use latched status as this is always saved for an internal

		 * abort

		/* if on wait_free list, caller has already freed IO;

		 * remove from wait_free list and add to free list.

		 * if on in-use list, already marked as no longer busy;

		 * just leave there and wait for caller to free.

 Process any remaining completions */

	/*

	 * Add IO to active io wqe list before submitting, in case the

	 * wcqe processing preempts this thread.

 non-negative return is success */

 failed to write wqe, remove from active wqe list */

/**

 * efct_els_hw_srrs_send() - Send a single request and response cmd.

 * @efc: efc library structure

 * @io: Discovery IO used to hold els and ct cmd context.

 *

 * This routine supports communication sequences consisting of a single

 * request and single response between two endpoints. Examples include:

 *  - Sending an ELS request.

 *  - Sending an ELS response - To send an ELS response, the caller must provide

 * the OX_ID from the received request.

 *  - Sending a FC Common Transport (FC-CT) request - To send a FC-CT request,

 * the caller must provide the R_CTL, TYPE, and DF_CTL

 * values to place in the FC frame header.

 *

 * Return: Status of the request.

 clear both SGE */

		/*

		 * Add IO to active io wqe list before submitting, in case the

		 * wcqe processing preempts this thread.

 non-negative return is success */

 failed to write wqe, remove from active wqe list */

	/*

	 * Save state needed during later stages

	/*

	 * Format the work queue entry used to send the IO

		/*

		 * Fill in the XFER_RDY for IF_TYPE 0 devices

		/*

		 * Add IO to active io wqe list before submitting, in case the

		 * wcqe processing preempts this thread.

 non-negative return is success */

 failed to write wqe, remove from active wqe list */

 populate the callback object */

 Fetch and populate request tag */

	/* Set XRI and RX_ID in the header based on which WQ, and which

	 * send_frame_io we are using

 Build the send frame WQE */

 Write to WQ */

 Fill overflow counts, mask starts from SLI4_READ_LNKSTAT_W02OF*/

 Send the HW command */

 Send the HW command to get the host stats */

	/*

	 * Allocate a callback context (which includes the mbox cmd buffer),

	 * we need this to be persistent as the mbox cmd submission may be

	 * queued and executed later execution.

 Build and send a NOP mailbox command */

 Write a portion of a firmware image to the device */

 Free buffer on error, since no callback is coming */

 Free buffer on error, since no callback is coming */

 Cancel Sliport Healthcheck */

 Cancel any remaining commands */

 Free rq buffers */

 record the fact that the queues are non-functional */

 free sequence free pool */

 free hw_wq_callback pool */

 Mark HW setup as not having been called */

		/*

		 * Because the FW reset leaves the FW in a non-running state,

		 * follow that with a regular reset.

	/*

	 * If the prev_state is already reset/teardown in progress,

	 * don't continue further

 Reset the chip */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

	/*

	 * During node shutdown, Lookup will be removed first,

	 * before announcing to backend. So, no new IOs will be allowed

 Find a target node, given s_id and d_id */

 extract the s_id and d_id */

 Process FCP command */

 Forward frame to discovery lib */

 Not handled */

	/*

	 * If we received less than FCP_CMND_IU bytes, assume that the frame is

	 * corrupted in some way and drop it.

	 * This was seen when jamming the FCTL

	 * fill bytes field.

 note, tgt_task_tag, hw_tag  set when HW io is allocated */

	/* The upper 7 bits of CS_CTL is the frame priority thru the SAN.

	 * Our assertion here is, the priority given to a frame containing

	 * the FCP cmd should be the priority given to ALL frames contained

	 * in that IO. Thus we need to save the incoming CS_CTL here.

 Free WQ completion callback */

 Free sequence */

 Build the FC header reusing the RQ header DMA buffer */

 send it back to whomever sent it to us */

	/*

	 * send_frame_seq_id is an atomic, we just let it increment,

	 * while storing only the low 8 bits to hdr->seq_id

 Allocate and fill in the send frame request context */

 Save sequence */

 Allocate a response payload DMA buffer from the heap */

 Copy the payload in */

 Send */

 construct task set full or busy response */

 send it using send_frame */

 perform FCP_CMND validation check(s) */

 Use SEND_FRAME to send task set full or busy */

 RQ pair, if we got here, SIT=1 */

		/*

		 * Can return failure for things like task set full and UAs,

		 * no need to treat as a dropped frame if rc != 0

 Find IO and attempt to take a reference on it */

		/* Got a reference on the IO. Hold it until backend

		 * is notified below

		/*

		 * Save the ox_id for the ABTS as the init_task_tag in our

		 * manufactured

		 * TMF IO object

 don't set tgt_task_tag, don't want to confuse with XRI */

		/*

		 * Save the rx_id from the ABTS as it is

		 * needed for the BLS response,

		 * regardless of the IO context's rx_id

 Call target server command abort */

		/*

		 * Backend will have taken an additional

		 * reference on the IO if needed;

		 * done with current reference.

		/*

		 * Either IO was not found or it has been

		 * freed between finding it

		 * and attempting to get the reference,

 Send a BA_RJT */

 If we got this far, SIT=1 */

 fill out generic fields */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

 Create EQ */

 Create one MQ */

 Create WQ */

 Create CQ set */

 Create RQ set */

 Init cpu_map array */

 Get a CPU mask for all CPUs affinitized to this vector */

 Loop through all CPUs associated with vector idx */

 Initialise CQS pointers to NULL */

 Initialise RQS pointers */

	/*

	 * Allocate an RQ object SET, where each element in set

	 * encapsulates 2 SLI queues (for rq pair)

 Header RQ */

 Data RQ */

 Free RQ tracker */

 rq_hdr lock also covers rqindex+1 queue */

 just get RQ buffer then return to chip */

 get RQ buffer */

 return to chip */

			/*

			 * since RQ buffers were not consumed, cannot return

			 * them to chip

 Update the RQ verification lookup tables */

 rq_hdr lock also covers payload / header->rqindex+1 queue */

	/*

	 * Note: The header must be posted last for buffer pair mode because

	 *       posting on the header queue posts the payload queue as well.

	 *       We do not ring the payload queue independently in RQ pair mode.

 ensure the indexes are the same */

 Update the lookup table */

	/*

	 * Post the data buffer first. Because in RQ pair mode, ringing the

	 * doorbell of the header ring will post the data buffer as well.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

 globals */

 Setup efct debugfs root directory */

 Create a directory for sessions in root */

 Remove session debugfs directory */

 remove root debugfs directory */

 Initialize io lists */

 Get FC link and host statistics perodically*/

			/*

			 * Initial state is offline. configured_link_state is

			 * set to online explicitly when port is brought online

 Determine port status based on link speed. */

 Create a completion to synchronize the stat reset process */

 First reset the link stats */

 Wait for completion to be signaled when the cmd completes */

 Undefined failure */

 Next reset the host stats */

 Wait for completion to be signaled when the cmd completes */

 Undefined failure */

 populate link supported speeds */

 save shost to initiator-client context */

 save efct information to shost LLD-specific space */

	/*

	 * Set initial can_queue value to the max SCSI IOs. This is the maximum

	 * global queue depth (as opposed to the per-LUN queue depth --

	 * .cmd_per_lun This may need to be adjusted for I+T mode.

 16-byte CDBs */

	/*

	 * can only accept (from mid-layer) as many SGEs as we've

	 * pre-registered

 attach FC Transport template to shost */

 get pci_dev structure and add host to SCSI ML */

 Set symbolic name for host port */

 Set host port supported classes */

 attach to appropriate scsi_tranport_* module */

 detach from scsi_transport_* */

 free resources associated with target-server and initiator-client */

Shutdown FC Statistics timer*/

 Bring the port on-line */

		/* if a PHYSDEV reset was performed (e.g. hw dump), will affect

		 * all PCI functions; orderly shutdown won't work,

		 * just force free

 Free up any saved virtual ports */

	/*

	 * Set wwnn for the port. This will be used instead of the default

	 * provided by FW.

 Retrieve arguments */

	/*

	 * Set wwpn for the port. This will be used instead of the default

	 * provided by FW.

 Retrieve arguments */

 Releasing FC transport */

 mbox returns kbyte count so we need to convert to words */

 mbox returns kbyte count so we need to convert to words */

 argument has no purpose for this action */

	/*

	 * Bring the link down gracefully then re-init the link.

	 * The firmware will re-initialize the Fibre Channel interface as

	 * required. It does not issue a LIP.

 save efct information to shost LLD-specific space */

 16-byte CDBs */

 can only accept (from mid-layer) as many SGEs as we've pre-regited*/

 attach FC Transport template to shost */

 get pci_dev structure and add host to SCSI ML */

 Set symbolic name for host port */

 Set host port supported classes */

 allocation lengths for host-specific data */

 should be sizeof(...) */

 remote port fixed attributes */

 target dynamic attributes */

 host fixed attributes */

 host dynamic attributes */

 active_fc4s is shown but doesn't change (thus no get function) */

 allocation lengths for host-specific data */

 should be sizeof(...) */

 remote port fixed attributes */

 target dynamic attributes */

 host fixed attributes */

 host dynamic attributes */

 active_fc4s is shown but doesn't change (thus no get function) */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

 initialize refcount */

 set generic fields */

 set type and name */

 Add to node's active_ios list */

 Call target server completion */

 Clear the callback before invoking the callback */

	/* if status was good, and auto-good-response was set,

	 * then callback target-server with IO_CMPL_RSP_SENT,

	 * otherwise send IO_CMPL

we have seen 0x0d(TX_DMA_FAILED err)*/

 target IO timed out */

 Target IO cancelled by HW */

 Initialize HW SGL */

 Add data SGE */

	/* Got a HW IO;

	 * update ini/tgt_task_tag with HW IO info and dispatch

 Copy WQ steering */

			/*

			 * If "IO to abort" does not have an

			 * associated HW IO, immediately make callback with

			 * success. The command must have been sent to

			 * the backend, but the data phase has not yet

			 * started, so we don't have a HW IO.

			 *

			 * Note: since the backend shims should be

			 * taking a reference on io_to_abort, it should not

			 * be possible to have been completed and freed by

			 * the backend before the abort got here.

 HW IO is valid, abort it */

			/*

			 * No HW IO available.Put IO back on

			 * the front of pending list

 Must drop the lock before dispatching the IO */

	/*

	 * We pulled an IO off the pending list,

	 * and either got an HW IO or don't need one

		/*

		 * Invoke the HW callback, but do so in the

		 * separate execution context,provided by the

		 * NOP mailbox completion processing context

		 * by using efct_hw_async_call()

 Guard against recursion */

 This function is already running.  Decrement and return. */

	/*

	 * If nothing was removed from the list,

	 * we might be in a case where we need to abort an

	 * active IO and the abort is on the pending list.

	 * Look for an abort we can dispatch.

			/* This IO has a HW IO, so it is

			 * active.  Dispatch the abort.

	/*

	 * if this IO already has a HW IO, then this is either

	 * not the first phase of the IO. Send it to the HW.

	/*

	 * We don't already have a HW IO associated with the IO. First check

	 * the pending list. If not empty, add IO to the tail and process the

	 * pending list.

		/*

		 * If this is a low latency request,

		 * the put at the front of the IO pending

		 * queue, otherwise put it at the end of the queue.

 process pending list */

	/*

	 * We don't have a HW IO associated with the IO and there's nothing

	 * on the pending list. Attempt to allocate a HW IO and dispatch it.

 Couldn't get a HW IO. Save this IO on the pending list */

 We successfully allocated a HW IO; dispatch to HW */

	/*

	 * For aborts, we don't need a HW IO, but we still want

	 * to pass through the pending list to preserve ordering.

	 * Thus, if the pending list is not empty, add this abort

	 * to the pending list and process the pending list.

 process pending list */

 nothing on pending list, dispatch abort */

	/* if this is the last data phase and there is no residual, enable

	 * auto-good-response

 save this transfer length */

	/* Adjust the transferred count to account for overrun

	 * when the residual is calculated in efct_scsi_send_resp

 Adjust the SGL size if there is overrun */

 Set latency and WQ steering */

 Always try auto resp */

 Set low latency queueing request */

 set residual status if necessary */

			/* FCP: if data transferred is less than the

			 * amount expected, then this is an underflow.

			 * If data transferred would have been greater

			 * than the amount expected this is an overflow

 BLS isn't really a "SCSI" concept, but use SCSI status */

 invoke callback */

 fill out IO structure with everything needed to send BA_ACC */

 generic io fields have already been populated */

 set type and BLS-specific fields */

 dispatch IO */

 fill out BLS Response-specific fields */

 fill out iparam fields */

 populate the FCP TMF response */

we have seen 0x15 (abort in progress)*/

 invoke callback */

 done with IO to abort,efct_ref_get(): efct_scsi_tgt_abort_io() */

 take a reference on IO being aborted */

 command no longer active */

	/*

	 * allocate a new IO to send the abort request. Use efct_io_alloc()

	 * directly, as we need an IO object that will not fail allocation

	 * due to allocations being disabled (in efct_scsi_io_alloc())

 Save the target server callback and argument */

 set generic fields */

 set type and abort-specific fields */

 now dispatch IO */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

/*

 * lio_wq is used to call the LIO backed during creation or deletion of

 * sessions. This brings serialization to the session management as we create

 * single threaded work queue.

 validate we have enough characters for WWPN */

		/* only physical nport should exist, free lio_nport

		 * allocated in efct_lio_make_nport

 command has been aborted, cleanup here */

 terminate the exchange */

 find current sg */

 do nothing */

 If command length is 0, send the response status */

 If there is residual, disable Auto Good Response */

 send check condition if an error occurred */

 Check for residual underrun or overrun */

 free struct efct_io only, no active se_cmd */

	/* Check for residual underrun or overrun, mark negitive value for

	 * underrun to recognize in HW

 Search for the HBA that has this WWPN */

	/* only physical nport should exist, free lio_nport allocated

	 * in efct_lio_make_nport.

 Get the max settings */

 initialize IO watermark fields */

	/* Check to see if it's belongs to vport,

	 * if not get physical port

	/*

	 * Format the FCP Initiator port_name into colon

	 * separated values to match the format by our explicit

	 * ConfigFS NodeACLs.

 update IO watermark: increment initiator count */

	/*

	 * Since LIO only supports initiator validation at thread level,

	 * we are open minded and accept all callers.

		/* base driver has sent back-to-back requests

		 * to unreg session with no intervening

		 * register

 first flag all session commands to complete */

 now wait for session commands to complete */

	/*

	 * update IO watermark: decrement initiator count

 set target timeout */

 Start items for efct_lio_tpg_attrib_cit */

 Register the top level struct config_item_type with TCM core */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

 driver-wide init for target-server */

 Allocate transport object and bring online */

	/*

	 * Firmware reset to activate the new firmware.

	 * Function 0 will update and load the new firmware

	 * during attach.

 terminate list */

 Fetch the Numa node id for this device */

 Allocate efct */

 Map all memory BARs */

		/*

		 * If the 64-bit attribute is set, both this BAR and the

		 * next form the complete address. Skip processing the

		 * next BAR.

	/*

	 * Initialize MSIX interrupts, note,

	 * efct_setup_msix() enables the interrupt

 Disable interrupt for now */

 Disable interrupt and pci device */

/**

 * efct_pci_io_error_detected - method for handling PCI I/O error

 * @pdev: pointer to PCI device.

 * @state: the current PCI connection state.

 *

 * This routine is registered to the PCI subsystem for error handling. This

 * function is called by the PCI subsystem after a PCI bus error affecting

 * this device has been detected. When this routine is invoked, it dispatches

 * device error detected handling routine, which will perform the proper

 * error detected operation.

 *

 * Return codes

 * PCI_ERS_RESULT_NEED_RESET - need to reset before recovery

 * PCI_ERS_RESULT_DISCONNECT - device could not be recovered

	/*

	 * As the new kernel behavior of pci_restore_state() API call clears

	 * device saved_state flag, need to save the restored state again.

 Perform device reset */

 Bring device to online*/

 Perform device reset */

 Bring device to online*/

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2021 Broadcom. All Rights Reserved. The term

 * “Broadcom” refers to Broadcom Inc. and/or its subsidiaries.

 IO pool lock */

 Total IOs allocated */

 Allocate the IO pool */

 initialize IO pool lock */

 Allocate a response buffer */

 Allocate SGL */

 Free an object used to track an IO */

 Find an I/O given it's node and ox_id */

/* bnx2i_hwi.c: QLogic NetXtreme II iSCSI driver.

 *

 * Copyright (c) 2006 - 2013 Broadcom Corporation

 * Copyright (c) 2007, 2008 Red Hat, Inc.  All rights reserved.

 * Copyright (c) 2007, 2008 Mike Christie

 * Copyright (c) 2014, QLogic Corporation

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 *

 * Written by: Anil Veerabhadrappa (anilgv@broadcom.com)

 * Previously Maintained by: Eddie Wai (eddie.wai@broadcom.com)

 * Maintained by: QLogic-Storage-Upstream@qlogic.com

/**

 * bnx2i_get_cid_num - get cid from ep

 * @ep: 	endpoint pointer

 *

 * Only applicable to 57710 family of devices

/**

 * bnx2i_adjust_qp_size - Adjust SQ/RQ/CQ size for 57710 device type

 * @hba: 		Adapter for which adjustments is to be made

 *

 * Only applicable to 57710 family of devices

	/* Adjust each queue size if the user selection does not

	 * yield integral num of page buffers

 adjust SQ */

 adjust CQ */

 adjust RQ */

/**

 * bnx2i_get_link_state - get network interface link state

 * @hba:	adapter instance pointer

 *

 * updates adapter structure flag based on netdev state

/**

 * bnx2i_iscsi_license_error - displays iscsi license related error message

 * @hba:		adapter instance pointer

 * @error_code:		error classification

 *

 * Puts out an error log when driver is unable to offload iscsi connection

 *	due to license restrictions

 iSCSI offload not supported on this device */

 iSCSI offload not supported on this LOM device */

/**

 * bnx2i_arm_cq_event_coalescing - arms CQ to enable EQ notification

 * @ep:		endpoint (transport identifier) structure

 * @action:	action, ARM or DISARM. For now only ARM_CQE is used

 *

 * Arm'ing CQ will enable chip to generate global EQ events inorder to interrupt

 *	the driver. EQ event is generated CQ index is hit or at least 1 CQ is

 *	outstanding and on chip timer expires

 Coalesce CQ entries only on 10G devices */

	/* Do not update CQ DB multiple times before firmware writes

	 * '0xFFFF' to CQDB->SQN field. Deviation may cause spurious

	 * interrupts and other unwanted results

/**

 * bnx2i_get_rq_buf - copy RQ buffer contents to driver buffer

 * @bnx2i_conn:		iscsi connection on which RQ event occurred

 * @ptr:		driver buffer to which RQ buffer contents is to

 *			be copied

 * @len:		length of valid data inside RQ buf

 *

 * Copies RQ buffer contents from shared (DMA'able) memory region to

 *	driver buffer. RQ is used to DMA unsolicitated iscsi pdu's and

 *	scsi sense info

 TODO : get doorbell register mapping */

/**

 * bnx2i_put_rq_buf - Replenish RQ buffer, if required ring on chip doorbell

 * @bnx2i_conn:	iscsi connection on which event to post

 * @count:	number of RQ buffer being posted to chip

 *

 * No need to ring hardware doorbell for 57710 family of devices

 no need to ring hardware doorbell for 57710 */

/**

 * bnx2i_ring_sq_dbell - Ring SQ doorbell to wake-up the processing engine

 * @bnx2i_conn:		iscsi connection to which new SQ entries belong

 * @count: 		number of SQ WQEs to post

 *

 * SQ DB is updated in host memory and TX Doorbell is rung for 57710 family

 *	of devices. For 5706/5708/5709 new SQ WQE count is written into the

 *	doorbell register

 flush SQ WQE memory before the doorbell is rung */

/**

 * bnx2i_ring_dbell_update_sq_params - update SQ driver parameters

 * @bnx2i_conn:	iscsi connection to which new SQ entries belong

 * @count:	number of SQ WQEs to post

 *

 * this routine will update SQ driver parameters and ring the doorbell

 Ring the doorbell */

/**

 * bnx2i_send_iscsi_login - post iSCSI login request MP WQE to hardware

 * @bnx2i_conn:	iscsi connection

 * @task: transport layer's command structure pointer which is requesting

 *	  a WQE to sent to chip for further processing

 *

 * prepare and post an iSCSI Login request WQE to CNIC firmware

 CQ# used for completion, 5771x only */

/**

 * bnx2i_send_iscsi_tmf - post iSCSI task management request MP WQE to hardware

 * @bnx2i_conn:	iscsi connection

 * @mtask:	driver command structure which is requesting

 *		a WQE to sent to chip for further processing

 *

 * prepare and post an iSCSI Login request WQE to CNIC firmware

			/*

			 * the iscsi layer must have completed the cmd while

			 * was starting up.

			 *

			 * Note: In the case of a SCSI cmd timeout, the task's

			 *       sc is still active; hence ctask->sc != 0

			 *       In this case, the task must be aborted

 CQ# used for completion, 5771x only */

/**

 * bnx2i_send_iscsi_text - post iSCSI text WQE to hardware

 * @bnx2i_conn:	iscsi connection

 * @mtask:	driver command structure which is requesting

 *		a WQE to sent to chip for further processing

 *

 * prepare and post an iSCSI Text request WQE to CNIC firmware

 CQ# used for completion, 5771x only */

/**

 * bnx2i_send_iscsi_scsicmd - post iSCSI scsicmd request WQE to hardware

 * @bnx2i_conn:	iscsi connection

 * @cmd:	driver command structure which is requesting

 *		a WQE to sent to chip for further processing

 *

 * prepare and post an iSCSI SCSI-CMD request WQE to CNIC firmware

 CQ# used for completion, 5771x only */

/**

 * bnx2i_send_iscsi_nopout - post iSCSI NOPOUT request WQE to hardware

 * @bnx2i_conn:		iscsi connection

 * @task:		transport layer's command structure pointer which is

 *                      requesting a WQE to sent to chip for further processing

 * @datap:		payload buffer pointer

 * @data_len:		payload data length

 * @unsol:		indicated whether nopout pdu is unsolicited pdu or

 *			in response to target's NOPIN w/ TTT != FFFFFFFF

 *

 * prepare and post a nopout request WQE to CNIC firmware

 57710 requires LUN field to be swapped */

 handle payload data, not required in first release */

 CQ# used for completion, 5771x only */

/**

 * bnx2i_send_iscsi_logout - post iSCSI logout request WQE to hardware

 * @bnx2i_conn:	iscsi connection

 * @task:	transport layer's command structure pointer which is

 *		requesting a WQE to sent to chip for further processing

 *

 * prepare and post logout request WQE to CNIC firmware

 CQ# used for completion, 5771x only */

/**

 * bnx2i_update_iscsi_conn - post iSCSI logout request WQE to hardware

 * @conn:	iscsi connection which requires iscsi parameter update

 *

 * sends down iSCSI Conn Update request to move iSCSI conn to FFP

 5771x requires conn context id to be passed as is */

/**

 * bnx2i_ep_ofld_timer - post iSCSI logout request WQE to hardware

 * @t:	timer context used to fetch the endpoint (transport

 *	handle) structure pointer

 *

 * routine to handle connection offload/destroy request timeout

/**

 * bnx2i_send_cmd_cleanup_req - send iscsi cmd context clean-up request

 * @hba:	adapter structure pointer

 * @cmd:	driver command structure which is requesting

 *		a WQE to sent to chip for further processing

 *

 * prepares and posts CONN_OFLD_REQ1/2 KWQE

 CQ# used for completion, 5771x only */

/**

 * bnx2i_send_conn_destroy - initiates iscsi connection teardown process

 * @hba:	adapter structure pointer

 * @ep:		endpoint (transport identifier) structure

 *

 * this routine prepares and posts CONN_OFLD_REQ1/2 KWQE to initiate

 * 	iscsi connection context clean-up process

 5771x requires conn context id to be passed as is */

/**

 * bnx2i_570x_send_conn_ofld_req - initiates iscsi conn context setup process

 * @hba: 		adapter structure pointer

 * @ep: 		endpoint (transport identifier) structure

 *

 * 5706/5708/5709 specific - prepares and posts CONN_OFLD_REQ1/2 KWQE

/**

 * bnx2i_5771x_send_conn_ofld_req - initiates iscsi connection context creation

 * @hba: 		adapter structure pointer

 * @ep: 		endpoint (transport identifier) structure

 *

 * 57710 specific - prepares and posts CONN_OFLD_REQ1/2 KWQE

 need if we decide to go with multiple KCQE's per conn */

/**

 * bnx2i_send_conn_ofld_req - initiates iscsi connection context setup process

 *

 * @hba: 		adapter structure pointer

 * @ep: 		endpoint (transport identifier) structure

 *

 * this routine prepares and posts CONN_OFLD_REQ1/2 KWQE

/**

 * setup_qp_page_tables - iscsi QP page table setup function

 * @ep:		endpoint (transport identifier) structure

 *

 * Sets up page tables for SQ/RQ/CQ, 1G/sec (5706/5708/5709) devices requires

 * 	64-bit address in big endian format. Whereas 10G/sec (57710) requires

 * 	PT in little endian format

 SQ page table */

 PTE is written in little endian format for 57710 */

			/* PTE is written in big endian format for

 RQ page table */

 PTE is written in little endian format for 57710 */

			/* PTE is written in big endian format for

 CQ page table */

 PTE is written in little endian format for 57710 */

			/* PTE is written in big endian format for

/**

 * bnx2i_alloc_qp_resc - allocates required resources for QP.

 * @hba:	adapter structure pointer

 * @ep:		endpoint (transport identifier) structure

 *

 * Allocate QP (transport layer for iSCSI connection) resources, DMA'able

 *	memory for SQ/RQ/CQ and page tables. EP structure elements such

 *	as producer/consumer indexes/pointers, queue sizes and page table

 *	contents are setup

 Allocate page table memory for SQ which is page aligned */

 Allocate memory area for actual SQ element */

 Allocate page table memory for CQ which is page aligned */

 Allocate memory area for actual CQ element */

 Invalidate all EQ CQE index, req only for 57710 */

 Allocate page table memory for RQ which is page aligned */

 Allocate memory area for actual RQ element */

/**

 * bnx2i_free_qp_resc - free memory resources held by QP

 * @hba:	adapter structure pointer

 * @ep:	endpoint (transport identifier) structure

 *

 * Free QP resources - SQ/RQ/CQ memory and page tables.

 Free SQ mem */

 Free RQ mem */

 Free CQ mem */

/**

 * bnx2i_send_fw_iscsi_init_msg - initiates initial handshake with iscsi f/w

 * @hba:	adapter structure pointer

 *

 * Send down iscsi_init KWQEs which initiates the initial handshake with the f/w

 * 	This results in iSCSi support validation and on-chip context manager

 * 	initialization.  Firmware completes this handshake with a CQE carrying

 * 	the result of iscsi support validation. Parameter carried by

 * 	iscsi init request determines the number of offloaded connection and

 * 	tolerance level for iscsi protocol violation this hba/chip can support

 CISCO MDS */

 HP MSA1510i */

 EMC */

/**

 * bnx2i_process_scsi_cmd_resp - this function handles scsi cmd completion.

 * @session:	iscsi session

 * @bnx2i_conn:	bnx2i connection

 * @cqe:	pointer to newly DMA'ed CQE entry for processing

 *

 * process SCSI CMD Response CQE & complete the request to SCSI-ML

/**

 * bnx2i_process_login_resp - this function handles iscsi login response

 * @session:		iscsi session pointer

 * @bnx2i_conn:		iscsi connection pointer

 * @cqe:		pointer to newly DMA'ed CQE entry for processing

 *

 * process Login Response CQE & complete it to open-iscsi user daemon

/**

 * bnx2i_process_text_resp - this function handles iscsi text response

 * @session:	iscsi session pointer

 * @bnx2i_conn:	iscsi connection pointer

 * @cqe:	pointer to newly DMA'ed CQE entry for processing

 *

 * process iSCSI Text Response CQE&  complete it to open-iscsi user daemon

/**

 * bnx2i_process_tmf_resp - this function handles iscsi TMF response

 * @session:		iscsi session pointer

 * @bnx2i_conn:		iscsi connection pointer

 * @cqe:		pointer to newly DMA'ed CQE entry for processing

 *

 * process iSCSI TMF Response CQE and wake up the driver eh thread.

/**

 * bnx2i_process_logout_resp - this function handles iscsi logout response

 * @session:		iscsi session pointer

 * @bnx2i_conn:		iscsi connection pointer

 * @cqe:		pointer to newly DMA'ed CQE entry for processing

 *

 * process iSCSI Logout Response CQE & make function call to

 * notify the user daemon.

/**

 * bnx2i_process_nopin_local_cmpl - this function handles iscsi nopin CQE

 * @session:		iscsi session pointer

 * @bnx2i_conn:		iscsi connection pointer

 * @cqe:		pointer to newly DMA'ed CQE entry for processing

 *

 * process iSCSI NOPIN local completion CQE, frees IIT and command structures

/**

 * bnx2i_unsol_pdu_adjust_rq - makes adjustments to RQ after unsol pdu is recvd

 * @bnx2i_conn:	iscsi connection

 *

 * Firmware advances RQ producer index for every unsolicited PDU even if

 *	payload data length is '0'. This function makes corresponding

 *	adjustments on the driver side to match this f/w behavior

/**

 * bnx2i_process_nopin_mesg - this function handles iscsi nopin CQE

 * @session:		iscsi session pointer

 * @bnx2i_conn:		iscsi connection pointer

 * @cqe:		pointer to newly DMA'ed CQE entry for processing

 *

 * process iSCSI target's proactive iSCSI NOPIN request

 this is a response to one of our nop-outs */

/**

 * bnx2i_process_async_mesg - this function handles iscsi async message

 * @session:		iscsi session pointer

 * @bnx2i_conn:		iscsi connection pointer

 * @cqe:		pointer to newly DMA'ed CQE entry for processing

 *

 * process iSCSI ASYNC Message

/**

 * bnx2i_process_reject_mesg - process iscsi reject pdu

 * @session:		iscsi session pointer

 * @bnx2i_conn:		iscsi connection pointer

 * @cqe:		pointer to newly DMA'ed CQE entry for processing

 *

 * process iSCSI REJECT message

/**

 * bnx2i_process_cmd_cleanup_resp - process scsi command clean-up completion

 * @session:		iscsi session pointer

 * @bnx2i_conn:		iscsi connection pointer

 * @cqe:		pointer to newly DMA'ed CQE entry for processing

 *

 * process command cleanup response CQE during conn shutdown or error recovery

/**

 * bnx2i_percpu_io_thread - thread per cpu for ios

 *

 * @arg:	ptr to bnx2i_percpu_info structure

 work allocated in the bh, freed here */

/**

 * bnx2i_queue_scsi_cmd_resp - queue cmd completion to the percpu thread

 * @session:		iscsi session

 * @bnx2i_conn:		bnx2i connection

 * @cqe:		pointer to newly DMA'ed CQE entry for processing

 *

 * this function is called by generic KCQ handler to queue all pending cmd

 * completion CQEs

 *

 * The implementation is to queue the cmd response based on the

 * last recorded command for the given connection.  The

 * cpu_id gets recorded upon task_xmit.  No out-of-order completion!

 Alloc and copy to the cqe */

/**

 * bnx2i_process_new_cqes - process newly DMA'ed CQE's

 * @bnx2i_conn:		bnx2i connection

 *

 * this function is called by generic KCQ handler to process all pending CQE's

			/* Run the kthread engine only for data cmds

		/* clear out in production version only, till beta keep opcode

		 * field intact, will be helpful in debugging (context dump)

		 * nopin->op_code = 0;

/**

 * bnx2i_fastpath_notification - process global event queue (KCQ)

 * @hba:		adapter structure pointer

 * @new_cqe_kcqe:	pointer to newly DMA'ed KCQE entry

 *

 * Fast path event notification handler, KCQ entry carries context id

 *	of the connection that has 1 or more pending CQ entries

/**

 * bnx2i_process_update_conn_cmpl - process iscsi conn update completion KCQE

 * @hba:		adapter structure pointer

 * @update_kcqe:	kcqe pointer

 *

 * CONN_UPDATE completion handler, this completes iSCSI connection FFP migration

/**

 * bnx2i_recovery_que_add_conn - add connection to recovery queue

 * @hba:		adapter structure pointer

 * @bnx2i_conn:		iscsi connection

 *

 * Add connection to recovery queue and schedule adapter eh worker

/**

 * bnx2i_process_tcp_error - process error notification on a given connection

 *

 * @hba: 		adapter structure pointer

 * @tcp_err: 		tcp error kcqe pointer

 *

 * handles tcp level error notifications from FW.

/**

 * bnx2i_process_iscsi_error - process error notification on a given connection

 * @hba:		adapter structure pointer

 * @iscsi_err:		iscsi error kcqe pointer

 *

 * handles iscsi error notifications from the FW. Firmware based in initial

 *	handshake classifies iscsi protocol / TCP rfc violation into either

 *	warning or error indications. If indication is of "Error" type, driver

 *	will initiate session recovery for that connection/session. For

 *	"Warning" type indication, driver will put out a system log message

 *	(there will be only one message for each type for the life of the

 *	session, this is to avoid un-necessarily overloading the system)

/**

 * bnx2i_process_conn_destroy_cmpl - process iscsi conn destroy completion

 * @hba:		adapter structure pointer

 * @conn_destroy:	conn destroy kcqe pointer

 *

 * handles connection destroy completion request.

/**

 * bnx2i_process_ofld_cmpl - process initial iscsi conn offload completion

 * @hba:		adapter structure pointer

 * @ofld_kcqe:		conn offload kcqe pointer

 *

 * handles initial connection offload completion, ep_connect() thread is

 *	woken-up to continue with LLP connect process

 error status code valid only for 5771x chipset */

/**

 * bnx2i_indicate_kcqe - process iscsi conn update completion KCQE

 * @context:		adapter structure pointer

 * @kcqe:		kcqe pointer

 * @num_cqe:		number of kcqes to process

 *

 * Generic KCQ event handler/dispatcher

/**

 * bnx2i_indicate_netevent - Generic netdev event handler

 * @context:	adapter structure pointer

 * @event:	event type

 * @vlan_id:	vlans id - associated vlan id with this event

 *

 * Handles four netdev events, NETDEV_UP, NETDEV_DOWN,

 *	NETDEV_GOING_DOWN and NETDEV_CHANGE

 Ignore all netevent coming from vlans */

/**

 * bnx2i_cm_connect_cmpl - process iscsi conn establishment completion

 * @cm_sk: 		cnic sock structure pointer

 *

 * function callback exported via bnx2i - cnic driver interface to

 *	indicate completion of option-2 TCP connect request.

/**

 * bnx2i_cm_close_cmpl - process tcp conn close completion

 * @cm_sk:	cnic sock structure pointer

 *

 * function callback exported via bnx2i - cnic driver interface to

 *	indicate completion of option-2 graceful TCP connect shutdown

/**

 * bnx2i_cm_abort_cmpl - process abortive tcp conn teardown completion

 * @cm_sk:	cnic sock structure pointer

 *

 * function callback exported via bnx2i - cnic driver interface to

 *	indicate completion of option-2 abortive TCP connect termination

/**

 * bnx2i_cm_remote_close - process received TCP FIN

 * @cm_sk:	cnic sock structure pointer

 *

 * function callback exported via bnx2i - cnic driver interface to indicate

 *	async TCP events such as FIN

/**

 * bnx2i_cm_remote_abort - process TCP RST and start conn cleanup

 * @cm_sk:	cnic sock structure pointer

 *

 * function callback exported via bnx2i - cnic driver interface to

 *	indicate async TCP events (RST) sent by the peer.

/*

 * bnx2i_cnic_cb - global template of bnx2i - cnic driver interface structure

 *			carrying callback function pointers

/**

 * bnx2i_map_ep_dbell_regs - map connection doorbell registers

 * @ep: bnx2i endpoint

 *

 * maps connection's SQ and RQ doorbell registers, 5706/5708/5709 hosts these

 *	register in BAR #0. Whereas in 57710 these register are accessed by

 *	mapping BAR #1

 5709 device in normal node and 5706/5708 devices */

/* bnx2i.c: QLogic NetXtreme II iSCSI driver.

 *

 * Copyright (c) 2006 - 2013 Broadcom Corporation

 * Copyright (c) 2007, 2008 Red Hat, Inc.  All rights reserved.

 * Copyright (c) 2007, 2008 Mike Christie

 * Copyright (c) 2014, QLogic Corporation

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 *

 * Written by: Anil Veerabhadrappa (anilgv@broadcom.com)

 * Previously Maintained by: Eddie Wai (eddie.wai@broadcom.com)

 * Maintained by: QLogic-Storage-Upstream@qlogic.com

/**

 * bnx2i_identify_device - identifies NetXtreme II device type

 * @hba: 		Adapter structure pointer

 * @dev:		Corresponding cnic device

 *

 * This function identifies the NX2 device type and sets appropriate

 *	queue mailbox register access method, 5709 requires driver to

 *	access MBOX regs using *bin* mode

/**

 * get_adapter_list_head - returns head of adapter list

/**

 * bnx2i_find_hba_for_cnic - maps cnic device instance to bnx2i adapter instance

 * @cnic:	pointer to cnic device instance

 *

/**

 * bnx2i_start - cnic callback to initialize & start adapter instance

 * @handle:	transparent handle pointing to adapter structure

 *

 * This function maps adapter structure to pcidev structure and initiates

 *	firmware handshake to enable/initialize on chip iscsi components

 * 	This bnx2i - cnic interface api callback is issued after following

 *	2 conditions are met -

 *	  a) underlying network interface is up (marked by event 'NETDEV_UP'

 *		from netdev

 *	  b) bnx2i adapter instance is registered

	/* On some bnx2x devices, it is possible that iSCSI is no

	 * longer supported after firmware is downloaded.  In that

	 * case, the iscsi_init_msg will return failure.

/**

 * bnx2i_chip_cleanup - local routine to handle chip cleanup

 * @hba:	Adapter instance to register

 *

 * Driver checks if adapter still has any active connections before

 *	executing the cleanup process

		/* Stage to force the disconnection

		 * This is the case where the daemon is either slow or

		 * not present

 Clean up the chip only */

/**

 * bnx2i_stop - cnic callback to shutdown adapter instance

 * @handle:	transparent handle pointing to adapter structure

 *

 * driver checks if adapter is already in shutdown mode, if not start

 *	the shutdown process

 check if cleanup happened in GOING_DOWN context */

	/* Wait for inflight offload connection tasks to complete before

	 * proceeding. Forcefully terminate all connection recovery in

	 * progress at the earliest, either in bind(), send_pdu(LOGIN),

	 * or conn_start()

	/* Wait for all endpoints to be torn down, Chip will be reset once

	 *  control returns to network driver. So it is required to cleanup and

	 * release all connection resources before returning from this routine.

	/* This flag should be cleared last so that ep_disconnect() gracefully

	 * cleans up connection context

/**

 * bnx2i_init_one - initialize an adapter instance and allocate memory resources

 * @hba:	bnx2i adapter instance

 * @cnic:	cnic device handle

 *

 * Global resource lock is held during critical sections below. This routine is

 *	called from either cnic_register_driver() or device hot plug context and

 *	and does majority of device specific initialization

 duplicate registration */

/**

 * bnx2i_ulp_init - initialize an adapter instance

 * @dev:	cnic device handle

 *

 * Called from cnic_register_driver() context to initialize all enumerated

 *	cnic devices. This routine allocate adapter structure and other

 *	device specific resources.

 Allocate a HBA structure for this device */

 Get PCI related information and update hba struct members */

/**

 * bnx2i_ulp_exit - shuts down adapter instance and frees all resources

 * @dev:	cnic device handle

 *

/**

 * bnx2i_get_stats - Retrieve various statistic from iSCSI offload

 * @handle:	bnx2i_hba

 *

 * function callback exported via bnx2i - cnic driver interface to

 *      retrieve various iSCSI offload related statistics.

/**

 * bnx2i_cpu_online - Create a receive thread for an online CPU

 *

 * @cpu:	cpu index for the online cpu

 bind thread to the cpu */

 Prevent any new work from being queued for this CPU */

 Free all work in the list */

/**

 * bnx2i_mod_init - module init entry point

 *

 * initialize any driver wide global data structures such as endpoint pool,

 *	tcp port manager/queue, sysfs. finally driver will register itself

 *	with the cnic module

 Create percpu kernel threads to handle iSCSI I/O completions */

/**

 * bnx2i_mod_exit - module cleanup/exit entry point

 *

 * Global resource lock and host adapter lock is held during critical sections

 *	in this function. Driver will browse through the adapter list, cleans-up

 *	each instance, unregisters iscsi transport name and finally driver will

 *	unregister itself with the cnic module

/* bnx2i_sysfs.c: QLogic NetXtreme II iSCSI driver.

 *

 * Copyright (c) 2004 - 2013 Broadcom Corporation

 * Copyright (c) 2014, QLogic Corporation

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 *

 * Written by: Anil Veerabhadrappa (anilgv@broadcom.com)

 * Previously Maintained by: Eddie Wai (eddie.wai@broadcom.com)

 * Maintained by: QLogic-Storage-Upstream@qlogic.com

/**

 * bnx2i_dev_to_hba - maps dev pointer to adapter struct

 * @dev:	device pointer

 *

 * Map device to hba structure

/**

 * bnx2i_show_sq_info - return(s currently configured send queue (SQ) size

 * @dev:	device pointer

 * @attr:	device attribute (unused)

 * @buf:	buffer to return current SQ size parameter

 *

 * Returns current SQ size parameter, this paramater determines the number

 * outstanding iSCSI commands supported on a connection

/**

 * bnx2i_set_sq_info - update send queue (SQ) size parameter

 * @dev:	device pointer

 * @attr:	device attribute (unused)

 * @buf:	buffer to return current SQ size parameter

 * @count:	parameter buffer size

 *

 * Interface for user to change shared queue size allocated for each conn

 * Must be within SQ limits and a power of 2. For the latter this is needed

 * because of how libiscsi preallocates tasks.

/**

 * bnx2i_show_ccell_info - returns command cell (HQ) size

 * @dev:	device pointer

 * @attr:	device attribute (unused)

 * @buf:	buffer to return current SQ size parameter

 *

 * returns per-connection TCP history queue size parameter

/**

 * bnx2i_set_ccell_info - set command cell (HQ) size

 * @dev:	device pointer

 * @attr:	device attribute (unused)

 * @buf:	buffer to return current SQ size parameter

 * @count:	parameter buffer size

 *

 * updates per-connection TCP history queue size parameter

/*

 * bnx2i_iscsi.c: QLogic NetXtreme II iSCSI driver.

 *

 * Copyright (c) 2006 - 2013 Broadcom Corporation

 * Copyright (c) 2007, 2008 Red Hat, Inc.  All rights reserved.

 * Copyright (c) 2007, 2008 Mike Christie

 * Copyright (c) 2014, QLogic Corporation

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 *

 * Written by: Anil Veerabhadrappa (anilgv@broadcom.com)

 * Previously Maintained by: Eddie Wai (eddie.wai@broadcom.com)

 * Maintained by: QLogic-Storage-Upstream@qlogic.com

/*

 * Global endpoint resource info

 protects global resources */

/**

 * bnx2i_get_write_cmd_bd_idx - identifies various BD bookmarks

 * @cmd:		iscsi cmd struct pointer

 * @buf_off:		absolute buffer offset

 * @start_bd_off:	u32 pointer to return the offset within the BD

 *			indicated by 'start_bd_idx' on which 'buf_off' falls

 * @start_bd_idx:	index of the BD on which 'buf_off' falls

 *

 * identifies & marks various bd info for scsi command's imm data,

 * unsolicited data and the first solicited data seq.

/**

 * bnx2i_setup_write_cmd_bd_info - sets up BD various information

 * @task:	transport layer's cmd struct pointer

 *

 * identifies & marks various bd info for scsi command's immediate data,

 * unsolicited data and first solicited data seq which includes BD start

 * index & BD buf off. his function takes into account iscsi parameter such

 * as immediate data and unsolicited data is support on this connection.

	/* if ImmediateData is turned off & IntialR2T is turned on,

	 * there will be no immediate or unsolicited data, just return.

 Immediate data */

/**

 * bnx2i_map_scsi_sg - maps IO buffer and prepares the BD table

 * @hba:	adapter instance

 * @cmd:	iscsi cmd struct pointer

 *

 * map SG list

/**

 * bnx2i_iscsi_map_sg_list - maps SG list

 * @cmd:	iscsi cmd struct pointer

 *

 * creates BD list table for the command

/**

 * bnx2i_iscsi_unmap_sg_list - unmaps SG list

 * @cmd:	iscsi cmd struct pointer

 *

 * unmap IO buffers and invalidate the BD table

/**

 * bnx2i_bind_conn_to_iscsi_cid - bind conn structure to 'iscsi_cid'

 * @hba:	pointer to adapter instance

 * @bnx2i_conn:	pointer to iscsi connection

 * @iscsi_cid:	iscsi context ID, range 0 - (MAX_CONN - 1)

 *

 * update iscsi cid table entry with connection pointer. This enables

 *	driver to quickly get hold of connection structure pointer in

 *	completion/interrupt thread using iscsi context ID

/**

 * bnx2i_get_conn_from_id - maps an iscsi cid to corresponding conn ptr

 * @hba:	pointer to adapter instance

 * @iscsi_cid:	iscsi context ID, range 0 - (MAX_CONN - 1)

/**

 * bnx2i_alloc_iscsi_cid - allocates a iscsi_cid from free pool

 * @hba:	pointer to adapter instance

/**

 * bnx2i_free_iscsi_cid - returns tcp port to free list

 * @hba: 		pointer to adapter instance

 * @iscsi_cid:		iscsi context ID to free

/**

 * bnx2i_setup_free_cid_que - sets up free iscsi cid queue

 * @hba:	pointer to adapter instance

 *

 * allocates memory for iscsi cid queue & 'cid - conn ptr' mapping table,

 * 	and initialize table attributes

/**

 * bnx2i_release_free_cid_que - releases 'iscsi_cid' queue resources

 * @hba:	pointer to adapter instance

/**

 * bnx2i_alloc_ep - allocates ep structure from global pool

 * @hba:	pointer to adapter instance

 *

 * routine allocates a free endpoint structure from global pool and

 *	a tcp port to be used for this connection.  Global resource lock,

 *	'bnx2i_resc_lock' is held while accessing shared global data structures

/**

 * bnx2i_free_ep - free endpoint

 * @ep:		pointer to iscsi endpoint structure

/**

 * bnx2i_alloc_bdt - allocates buffer descriptor (BD) table for the command

 * @hba:	adapter instance pointer

 * @session:	iscsi session pointer

 * @cmd:	iscsi command structure

/**

 * bnx2i_destroy_cmd_pool - destroys iscsi command pool and release BD table

 * @hba:	adapter instance pointer

 * @session:	iscsi session pointer

/**

 * bnx2i_setup_cmd_pool - sets up iscsi command pool for the session

 * @hba:	adapter instance pointer

 * @session:	iscsi session pointer

/**

 * bnx2i_setup_mp_bdt - allocate BD table resources

 * @hba:	pointer to adapter structure

 *

 * Allocate memory for dummy buffer and associated BD

 * table to be used by middle path (MP) requests

/**

 * bnx2i_free_mp_bdt - releases ITT back to free pool

 * @hba:	pointer to adapter instance

 *

 * free MP dummy buffer and associated BD table

/**

 * bnx2i_drop_session - notifies iscsid of connection error.

 * @cls_session:	iscsi cls session pointer

 *

 * This notifies iscsid that there is a error, so it can initiate

 * recovery.

 *

 * This relies on caller using the iscsi class iterator so the object

 * is refcounted and does not disapper from under us.

/**

 * bnx2i_ep_destroy_list_add - add an entry to EP destroy list

 * @hba:	pointer to adapter instance

 * @ep:		pointer to endpoint (transport identifier) structure

 *

 * EP destroy queue manager

/**

 * bnx2i_ep_destroy_list_del - add an entry to EP destroy list

 *

 * @hba: 		pointer to adapter instance

 * @ep: 		pointer to endpoint (transport identifier) structure

 *

 * EP destroy queue manager

/**

 * bnx2i_ep_ofld_list_add - add an entry to ep offload pending list

 * @hba:	pointer to adapter instance

 * @ep:		pointer to endpoint (transport identifier) structure

 *

 * pending conn offload completion queue manager

/**

 * bnx2i_ep_ofld_list_del - add an entry to ep offload pending list

 * @hba: 		pointer to adapter instance

 * @ep: 		pointer to endpoint (transport identifier) structure

 *

 * pending conn offload completion queue manager

/**

 * bnx2i_find_ep_in_ofld_list - find iscsi_cid in pending list of endpoints

 *

 * @hba: 		pointer to adapter instance

 * @iscsi_cid:		iscsi context ID to find

 *

/**

 * bnx2i_find_ep_in_destroy_list - find iscsi_cid in destroy list

 * @hba: 		pointer to adapter instance

 * @iscsi_cid:		iscsi context ID to find

 *

/**

 * bnx2i_ep_active_list_add - add an entry to ep active list

 * @hba:	pointer to adapter instance

 * @ep:		pointer to endpoint (transport identifier) structure

 *

 * current active conn queue manager

/**

 * bnx2i_ep_active_list_del - deletes an entry to ep active list

 * @hba:	pointer to adapter instance

 * @ep:		pointer to endpoint (transport identifier) structure

 *

 * current active conn queue manager

/**

 * bnx2i_setup_host_queue_size - assigns shost->can_queue param

 * @hba:	pointer to adapter instance

 * @shost:	scsi host pointer

 *

 * Initializes 'can_queue' parameter based on how many outstanding commands

 * 	the device can handle. Each device 5708/5709/57710 has different

 *	capabilities

/**

 * bnx2i_alloc_hba - allocate and init adapter instance

 * @cnic:	cnic device pointer

 *

 * allocate & initialize adapter structure and call other

 *	support routines to do per adapter initialization

 Get PCI related information and update hba struct members */

 different values for 5708/5709/57710 */

 SQ/RQ/CQ size can be changed via sysfx interface */

 5706/5708/5709 */

 5706/5708/5709 */

/**

 * bnx2i_free_hba- releases hba structure and resources held by the adapter

 * @hba:	pointer to adapter instance

 *

 * free adapter structure and call various cleanup routines.

/**

 * bnx2i_conn_free_login_resources - free DMA resources used for login process

 * @hba:		pointer to adapter instance

 * @bnx2i_conn:		iscsi connection pointer

 *

 * Login related resources, mostly BDT & payload DMA memory is freed

/**

 * bnx2i_conn_alloc_login_resources - alloc DMA resources for login/nop.

 * @hba:		pointer to adapter instance

 * @bnx2i_conn:		iscsi connection pointer

 *

 * Mgmt task DNA resources are allocated in this routine.

 Allocate memory for login request/response buffers */

/**

 * bnx2i_iscsi_prep_generic_pdu_bd - prepares BD table.

 * @bnx2i_conn:		iscsi connection pointer

 *

 * Allocates buffers and BD tables before shipping requests to cnic

 *	for PDUs prepared by 'iscsid' daemon

/**

 * bnx2i_iscsi_send_generic_request - called to send mgmt tasks.

 * @task:	transport layer task pointer

 *

 * called to transmit PDUs prepared by the 'iscsid' daemon. iSCSI login,

 *	Nop-out and Logout requests flow through this path.

/**********************************************************************

 *		SCSI-ML Interface

/**

 * bnx2i_cpy_scsi_cdb - copies LUN & CDB fields in required format to sq wqe

 * @sc:		SCSI-ML command pointer

 * @cmd:	iscsi cmd pointer

	/*

	 * mgmt task or cmd was never sent to us to transmit.

	/*

	 * need to clean-up task context to claim dma buffers

/**

 * bnx2i_mtask_xmit - transmit mtask to chip for further processing

 * @conn:	transport layer conn structure pointer

 * @task:	transport layer command structure pointer

 Tx PDU/data length count */

/**

 * bnx2i_task_xmit - transmit iscsi command to chip for further processing

 * @task:	transport layer command structure pointer

 *

 * maps SG buffers and send request to chip/firmware in the form of SQ WQE

	/*

	 * If there is no scsi_cmnd this must be a mgmt task

/**

 * bnx2i_session_create - create a new iscsi session

 * @ep:		pointer to iscsi endpoint

 * @cmds_max:		user specified maximum commands

 * @qdepth:		scsi queue depth to support

 * @initial_cmdsn:	initial iscsi CMDSN to be used for this session

 *

 * Creates a new iSCSI session instance on given device.

	/*

	 * user can override hw limit as long as it is within

	 * the min/max.

/**

 * bnx2i_session_destroy - destroys iscsi session

 * @cls_session:	pointer to iscsi cls session

 *

 * Destroys previously created iSCSI session instance and releases

 *	all resources held by it

/**

 * bnx2i_conn_create - create iscsi connection instance

 * @cls_session:	pointer to iscsi cls session

 * @cid:		iscsi cid as per rfc (not NX2's CID terminology)

 *

 * Creates a new iSCSI connection instance for a given session

 'ep' ptr will be assigned in bind() call */

/**

 * bnx2i_conn_bind - binds iscsi sess, conn and ep objects together

 * @cls_session:	pointer to iscsi cls session

 * @cls_conn:		pointer to iscsi cls conn

 * @transport_fd:	64-bit EP handle

 * @is_leading:		leading connection on this session?

 *

 * Binds together iSCSI session instance, iSCSI connection instance

 *	and the TCP connection. This routine returns error code if

 *	TCP connection does not belong on the device iSCSI sess/conn

 *	is bound

	/*

	 * Forcefully terminate all in progress connection recovery at the

	 * earliest, either in bind(), send_pdu(LOGIN), or conn_start()

 Peer disconnect via' FIN or RST */

		/* Error - TCP connection does not belong to this device

	/* 5706/5708/5709 FW takes RQ as full when initiated, but for 57710

	 * driver needs to explicitly replenish RQ index during setup.

/**

 * bnx2i_conn_destroy - destroy iscsi connection instance & release resources

 * @cls_conn:	pointer to iscsi cls conn

 *

 * Destroy an iSCSI connection instance and release memory resources held by

 *	this connection

/**

 * bnx2i_ep_get_param - return iscsi ep parameter to caller

 * @ep:		pointer to iscsi endpoint

 * @param:	parameter type identifier

 * @buf: 	buffer pointer

 *

 * returns iSCSI ep parameters

/**

 * bnx2i_host_get_param - returns host (adapter) related parameters

 * @shost:	scsi host pointer

 * @param:	parameter type identifier

 * @buf:	buffer pointer

/**

 * bnx2i_conn_start - completes iscsi connection migration to FFP

 * @cls_conn:	pointer to iscsi cls conn

 *

 * last call in FFP migration to handover iscsi conn to the driver

	/*

	 * this should normally not sleep for a long time so it should

	 * not disrupt the caller.

 update iSCSI context for this conn, wait for CNIC to complete */

/**

 * bnx2i_conn_get_stats - returns iSCSI stats

 * @cls_conn:	pointer to iscsi cls conn

 * @stats:	pointer to iscsi statistic struct

/**

 * bnx2i_check_route - checks if target IP route belongs to one of NX2 devices

 * @dst_addr:	target IP address

 *

 * check if route resolves to BNX2 device

/**

 * bnx2i_tear_down_conn - tear down iscsi/tcp connection and free resources

 * @hba:	pointer to adapter instance

 * @ep:		endpoint (transport identifier) structure

 *

 * destroys cm_sock structure and on chip iscsi context

 Must suspend all rx queue activity for this ep */

		/* CONN_DISCONNECT timeout may or may not be an issue depending

		 * on what transcribed in TCP layer, different targets behave

		 * differently

 destroy iSCSI context, wait for it to complete */

 should never happen */

/**

 * bnx2i_ep_connect - establish TCP connection to target portal

 * @shost:		scsi host

 * @dst_addr:		target IP address

 * @non_blocking:	blocking or non-blocking call

 *

 * this routine initiates the TCP/IP connection by invoking Option-2 i/f

 *	with l5_core and the CNIC. This is a multi-step process of resolving

 *	route to target, create a iscsi connection context, handshaking with

 *	CNIC module to create/initialize the socket struct and finally

 *	sending down option-2 request to complete TCP 3-way handshake

 driver is given scsi host to work with */

		/*

		 * check if the given destination can be reached through

		 * a iscsi capable NetXtreme2 device

 Wait for CNIC hardware to setup conn context and return 'cid' */

 Need to terminate and cleanup the connection */

/**

 * bnx2i_ep_poll - polls for TCP connection establishement

 * @ep:			TCP connection (endpoint) handle

 * @timeout_ms:		timeout value in milli secs

 *

 * polls for TCP connect request to complete

 timeout */

/**

 * bnx2i_ep_tcp_conn_active - check EP state transition

 * @bnx2i_ep:		endpoint pointer

 *

 * check if underlying TCP connection is active

/**

 * bnx2i_hw_ep_disconnect - executes TCP connection teardown process in the hw

 * @bnx2i_ep:		TCP connection (bnx2i endpoint) handle

 *

 * executes  TCP connection teardown process

 Logout sent, but no resp */

 wait for option-2 conn teardown */

/**

 * bnx2i_ep_disconnect - executes TCP connection teardown process

 * @ep:		TCP connection (iscsi endpoint) handle

 *

 * executes  TCP connection teardown process

	/* driver should not attempt connection cleanup until TCP_CONNECT

	 * completes either successfully or fails. Timeout is 9-secs, so

	 * wait for it to complete

 Do all chip cleanup here */

/**

 * bnx2i_nl_set_path - ISCSI_UEVENT_PATH_UPDATE user message handler

 * @shost:	scsi host pointer

 * @params:	pointer to buffer containing iscsi path message

 handled by cnic driver */

/*

 * 'Scsi_Host_Template' structure and 'iscsi_tranport' structure template

 * used while registering with the scsi host and iSCSI transport module.

 TCP connect - disconnect - option-2 interface calls */

 Error recovery timeout call */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic iSCSI Offload Driver

 * Copyright (c) 2016 Cavium Inc.

 Prepare the doorbell parameters */

 Register doorbell with doorbell recovery mechanism */

 delete doorbell from doorbell recovery mechanism */

 Clear now so in cleanup_task we know it didn't make it */

 Delete doorbell from doorbell recovery mechanism */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic iSCSI Offload Driver

 * Copyright (c) 2016 Cavium Inc.

 Fill up the header */

 Session is down so ep_disconnect will clean up */

 Obtain buffer address from rqe_opaque */

 Obtain buffer address from rqe_opaque */

 Increment producer to let f/w know we've handled the frame */

 Response to one of our nop-outs */

 get the scsi command */

	/* If f/w reports data underrun err then set residual to IO transfer

	 * length, set Underrun flag and clear Overrun flag explicitly

 Based on this itt get the corresponding qedi_cmd */

 We found the command */

 Process NOPIN local completion */

 Process other solicited responses */

 wmb - Make sure fw idx is coherent */

	/* Make sure fw write idx is coherent, and include both memory barriers

	 * as a failsafe as for some architectures the call is the same but on

	 * others they are two different assembly operations.

 Increament SQ index */

 Update header info */

 Fill tx AHS and rx buffer */

 Fill fw input params */

 Update header info */

 Fill fw input params */

 From recovery, task is NULL or from tmf resp valid task */

 Enable IOs for all other sessions except current.*/

		/*

		 * We have to still send the TMF because libiscsi needs the

		 * response to avoid a timeout.

 Update header info */

 Fill fw input params */

 Update header info */

 Fill tx AHS and rx buffer */

 Fill fw input params */

 Update header info */

 Fill tx AHS and rx buffer */

 Fill fw input params */

	/*

	 * New condition to send single SGE as cached-SGL.

	 * Single SGE with length less than 64K.

		/*

		 * first sg elem in the 'list',

		 * check if end addr is page-aligned.

		/*

		 * last sg elem in the 'list',

		 * check if start addr is page-aligned.

		/*

		 * middle sg elements in list,

		 * check if start and end addr is page-aligned

 For requests we only care about the submission CPU */

 Update header info */

 Fill tx AHS and rx buffer */

 Add conn param */

 Add cmd params */

 Fill fw input params */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic iSCSI Offload Driver

 * Copyright (c) 2016 Cavium Inc.

 SPDX-License-Identifier: GPL-2.0-only

/* QLogic iSCSI Offload Driver

 * Copyright (c) 2016 Cavium Inc.

 sgl params */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic iSCSI Offload Driver

 * Copyright (c) 2016 Cavium Inc.

 Static function declaration */

 Memory for control area.  */

 Allocating memory for LL2 ring  */

 Allocating memory for Tx/Rx pkt buffer */

		/* fp_array[i] ---- irq cookie

		 * So init data which is needed in int ctx

 Undo VLAN encapsulation */

 Filter out non FIP/FCoE frames here to free them faster */

 map this skb to iscsiuio mmaped region */

 notify the iscsiuio about new packet */

	/* RQ BDQ initializations.

	 * rq_num_entries: suggested value for Initiator is 16 (4KB RQ)

	 * rqe_log_size: 8 for 256B RQE

 BDQ address and size */

 cq_num_entries: num_tasks + rq_num_entries */

 Free DMA coherent memory for array of queue pointers we pass to qed */

/*

 * Protocol TLV handler

 Query firmware for offload stats */

 tpgt, hdr digest, data digest */

 Prevent HW attentions from being reasserted */

 Get the current firmware producer index */

 Get the current firmware producer index */

 Get the pointer to the global CQ this completion is on */

 prod idx wrap around uint16 */

 MSI-X fastpath handler code */

 Check for more work */

 simd handler for MSI/INTa */

 Cookie is qedi_ctx struct */

 Alloc dma memory for BDQ buffers */

 Alloc dma memory for BDQ page buffer list */

	/*

	 * Populate BDQ PBL with physical and virtual address of individual

	 * BDQ buffers

 Allocate list of PBL pages */

	/*

	 * Now populate PBL list with pages that contain pointers to the

	 * individual buffers.

	/*

	 * Number of global queues (CQ / RQ). This should

	 * be <= number of available MSIX vectors for the PF

	/* Make sure we allocated the PBL that will contain the physical

	 * addresses of our queues

 Allocate DMA coherent buffers for BDQ */

 Allocate DMA coherent buffers for NVM_ISCSI_CFG */

	/* Allocate a CQ and an associated PBL for each MSI-X

	 * vector.

 Create PBL */

	/*

	 * The list is built as follows: CQ#0 PBL pointer, RQ#0 PBL pointer,

	 * CQ#1 PBL pointer, RQ#1 PBL pointer, etc.  Each PBL pointer points

	 * to the physical address which contains an array of pointers to the

	 * physical addresses of the specific queue pages.

 Calculate appropriate queue and PBL sizes */

 Create PBL */

/*

 * qedi_get_nvram_block: - Scan through the iSCSI NVRAM block (while accounting

 * for gaps) for the matching absolute-pf-id of the QEDI device.

 Static IP assignments. */

 DHCP IP adjustments. */

 Start the Slowpath-process */

	/* update_pf_params needs to be called before and after slowpath

	 * start

 Learn information crucial for qedi to progress */

 Record BDQ producer doorbell addresses */

	/*

	 * We need to write the number of BDs in the BDQ we've preallocated so

	 * the f/w will do a prefetch and we'll get an unsolicited CQE when a

	 * packet arrives.

 set up rx path */

 start qedi context */

 Allocate uio buffers */

 host the array on iscsi_conn */

 F/w needs 1st task context memory entry for performance */

	/* Call common_ops->recovery_prolog to allow the MFW to quiesce

	 * any PCI transactions.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic iSCSI Offload Driver

 * Copyright (c) 2016 Cavium Inc.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic iSCSI Offload Driver

 * Copyright (c) 2016 Cavium Inc.

/*

 * This module provides common API to set Diagnostic trigger for MPT

 * (Message Passing Technology) based controllers

 *

 * This code is based on drivers/scsi/mpt3sas/mpt3sas_trigger_diag.c

 * Copyright (C) 2012-2014  LSI Corporation

 * Copyright (C) 2013-2014 Avago Technologies

 *  (mailto: MPT-FusionLinux.pdl@avagotech.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License

 * as published by the Free Software Foundation; either version 2

 * of the License, or (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * NO WARRANTY

 * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 * solely responsible for determining the appropriateness of using and

 * distributing the Program and assumes all risks associated with its

 * exercise of rights under this Agreement, including but not limited to

 * the risks and costs of program errors, damage to or loss of data,

 * programs or equipment, and unavailability or interruption of operations.



 * DISCLAIMER OF LIABILITY

 * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write to the Free Software

 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,

 * USA.

/**

 * _mpt3sas_raise_sigio - notifiy app

 * @ioc: per adapter object

 * @event_data: ?

 clearing the diag_trigger_active flag */

/**

 * mpt3sas_process_trigger_data - process the event data for the trigger

 * @ioc: per adapter object

 * @event_data: ?

 release the diag buffer trace */

		/*

		 * add a log message so that user knows which event caused

		 * the release

/**

 * mpt3sas_trigger_master - Master trigger handler

 * @ioc: per adapter object

 * @trigger_bitmask:

 *

 check to see if trace buffers are currently registered */

 check to see if trace buffers are currently released */

 don't send trigger if an trigger is currently active */

 check for the trigger condition */

/**

 * mpt3sas_trigger_event - Event trigger handler

 * @ioc: per adapter object

 * @event: ?

 * @log_entry_qualifier: ?

 *

 check to see if trace buffers are currently registered */

 check to see if trace buffers are currently released */

 don't send trigger if an trigger is currently active */

 check for the trigger condition */

/**

 * mpt3sas_trigger_scsi - SCSI trigger handler

 * @ioc: per adapter object

 * @sense_key: ?

 * @asc: ?

 * @ascq: ?

 *

 check to see if trace buffers are currently registered */

 check to see if trace buffers are currently released */

 don't send trigger if an trigger is currently active */

 check for the trigger condition */

/**

 * mpt3sas_trigger_mpi - MPI trigger handler

 * @ioc: per adapter object

 * @ioc_status: ?

 * @loginfo: ?

 *

 check to see if trace buffers are currently registered */

 check to see if trace buffers are currently released */

 don't send trigger if an trigger is currently active */

 check for the trigger condition */

/*

 * Management Module Support for MPT (Message Passing Technology) based

 * controllers

 *

 * This code is based on drivers/scsi/mpt3sas/mpt3sas_ctl.c

 * Copyright (C) 2012-2014  LSI Corporation

 * Copyright (C) 2013-2014 Avago Technologies

 *  (mailto: MPT-FusionLinux.pdl@avagotech.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License

 * as published by the Free Software Foundation; either version 2

 * of the License, or (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * NO WARRANTY

 * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 * solely responsible for determining the appropriateness of using and

 * distributing the Program and assumes all risks associated with its

 * exercise of rights under this Agreement, including but not limited to

 * the risks and costs of program errors, damage to or loss of data,

 * programs or equipment, and unavailability or interruption of operations.



 * DISCLAIMER OF LIABILITY

 * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write to the Free Software

 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,

 * USA.

/**

 * enum block_state - blocking state

 * @NON_BLOCKING: non blocking

 * @BLOCKING: blocking

 *

 * These states are for ioctls that need to wait for a response

 * from firmware, so they probably require sleep.

/**

 * _ctl_display_some_debug - debug routine

 * @ioc: per adapter object

 * @smid: system request message index

 * @calling_function_name: string pass from calling function

 * @mpi_reply: reply message frame

 * Context: none.

 *

 * Function for displaying debug info helpful when debugging issues

 * in this module.

/**

 * mpt3sas_ctl_done - ctl module completion routine

 * @ioc: per adapter object

 * @smid: system request message index

 * @msix_index: MSIX table index supplied by the OS

 * @reply: reply message frame(lower 32bit addr)

 * Context: none.

 *

 * The callback handler when using ioc->ctl_cb_idx.

 *

 * Return: 1 meaning mf should be freed from _base_interrupt

 *         0 means the mf is freed from this function.

 get sense data */

		/*

		 * Get Error Response data for NVMe device. The ctl_cmds.sense

		 * buffer is used to store the Error Response data.

/**

 * _ctl_check_event_type - determines when an event needs logging

 * @ioc: per adapter object

 * @event: firmware event

 *

 * The bitmask in ioc->event_type[] indicates which events should be

 * be saved in the driver event_log.  This bitmask is set by application.

 *

 * Return: 1 when event should be captured, or zero means no match.

/**

 * mpt3sas_ctl_add_to_event_log - add event

 * @ioc: per adapter object

 * @mpi_reply: reply message frame

 insert entry into circular event_log */

	/* This aen_event_read_flag flag is set until the

	 * application has read the event log.

	 * For MPI2_EVENT_LOG_ENTRY_ADDED, we always notify.

/**

 * mpt3sas_ctl_event_callback - firmware event handler (called at ISR time)

 * @ioc: per adapter object

 * @msix_index: MSIX table index supplied by the OS

 * @reply: reply message frame(lower 32bit addr)

 * Context: interrupt.

 *

 * This function merely adds a new work task into ioc->firmware_event_thread.

 * The tasks are worked from _firmware_event_work in user context.

 *

 * Return: 1 meaning mf should be freed from _base_interrupt

 *         0 means the mf is freed from this function.

/**

 * _ctl_verify_adapter - validates ioc_number passed from application

 * @ioc_number: ?

 * @iocpp: The ioc pointer is returned in this.

 * @mpi_version: will be MPI2_VERSION for mpt2ctl ioctl device &

 * MPI25_VERSION | MPI26_VERSION for mpt3ctl ioctl device.

 *

 * Return: (-1) means error, else ioc_number.

 global ioc lock to protect controller on list operations */

		/* Check whether this ioctl command is from right

		 * ioctl device or not, if not continue the search.

		/* MPI25_VERSION and MPI26_VERSION uses same ioctl

		 * device.

/**

 * mpt3sas_ctl_pre_reset_handler - reset callback handler (for ctl)

 * @ioc: per adapter object

 *

 * The handler for doing any required cleanup or initialization.

		/*

		 * add a log message to indicate the release

/**

 * mpt3sas_ctl_clear_outstanding_ioctls - clears outstanding ioctl cmd.

 * @ioc: per adapter object

 *

 * The handler for doing any required cleanup or initialization.

/**

 * mpt3sas_ctl_reset_done_handler - reset callback handler (for ctl)

 * @ioc: per adapter object

 *

 * The handler for doing any required cleanup or initialization.

/**

 * _ctl_fasync -

 * @fd: ?

 * @filep: ?

 * @mode: ?

 *

 * Called when application request fasyn callback handler.

/**

 * _ctl_poll -

 * @filep: ?

 * @wait: ?

 *

 global ioc lock to protect controller on list operations */

/**

 * _ctl_set_task_mid - assign an active smid to tm request

 * @ioc: per adapter object

 * @karg: (struct mpt3_ioctl_command)

 * @tm_request: pointer to mf from user space

 *

 * Return: 0 when an smid if found, else fail.

 * during failure, the reply frame is filled.

		/*

		 * If the given TaskMID from the user space is zero, then the

		 * first outstanding smid will be picked up.  Otherwise,

		 * targeted smid will be the one.

/**

 * _ctl_do_mpt_command - main handler for MPT3COMMAND opcode

 * @ioc: per adapter object

 * @karg: (struct mpt3_ioctl_command)

 * @mf: pointer to mf in user space

 Check for overflow and wraparound */

 copy in request message frame from user */

 Use first reserved smid for passthrough ioctls */

 obtain dma-able memory for data transfer */

 WRITE */ {

 READ */ {

 send command to firmware */

		/*

		 * Get the Physical Address of the sense buffer.

		 * Use Error Response buffer address field to hold the sense

		 * buffer address.

		 * Clear the internal sense buffer, which will potentially hold

		 * the Completion Queue Entry on return, or 0 if no Entry.

		 * Build the PRPs and set direction bits.

		 * Send the request.

 ioc determines which port to use */

 drop to default case for posting the request */

 copy out xdata to user */

 copy out reply message frame to user */

 copy out sense/NVMe Error Response to user */

 free memory associated with sg buffers */

/**

 * _ctl_getiocinfo - main handler for MPT3IOCINFO opcode

 * @ioc: per adapter object

 * @arg: user space buffer containing ioctl content

/**

 * _ctl_eventquery - main handler for MPT3EVENTQUERY opcode

 * @ioc: per adapter object

 * @arg: user space buffer containing ioctl content

/**

 * _ctl_eventenable - main handler for MPT3EVENTENABLE opcode

 * @ioc: per adapter object

 * @arg: user space buffer containing ioctl content

 initialize event_log */

/**

 * _ctl_eventreport - main handler for MPT3EVENTREPORT opcode

 * @ioc: per adapter object

 * @arg: user space buffer containing ioctl content

	/* If fewer than 1 event is requested, there must have

	 * been some type of error.

 reset flag so SIGIO can restart */

/**

 * _ctl_do_reset - main handler for MPT3HARDRESET opcode

 * @ioc: per adapter object

 * @arg: user space buffer containing ioctl content

/**

 * _ctl_btdh_search_sas_device - searching for sas device

 * @ioc: per adapter object

 * @btdh: btdh ioctl payload

/**

 * _ctl_btdh_search_pcie_device - searching for pcie device

 * @ioc: per adapter object

 * @btdh: btdh ioctl payload

/**

 * _ctl_btdh_search_raid_device - searching for raid device

 * @ioc: per adapter object

 * @btdh: btdh ioctl payload

/**

 * _ctl_btdh_mapping - main handler for MPT3BTDHMAPPING opcode

 * @ioc: per adapter object

 * @arg: user space buffer containing ioctl content

/**

 * _ctl_diag_capability - return diag buffer capability

 * @ioc: per adapter object

 * @buffer_type: specifies either TRACE, SNAPSHOT, or EXTENDED

 *

 * returns 1 when diag buffer support is enabled in firmware

/**

 * _ctl_diag_get_bufftype - return diag buffer type

 *              either TRACE, SNAPSHOT, or EXTENDED

 * @ioc: per adapter object

 * @unique_id: specifies the unique_id for the buffer

 *

 * returns MPT3_DIAG_UID_NOT_FOUND if the id not found

/**

 * _ctl_diag_register_2 - wrapper for registering diag buffer support

 * @ioc: per adapter object

 * @diag_register: the diag_register struct passed in from user space

 *

		/*

		 * If driver posts buffer initially, then an application wants

		 * to Register that buffer (own it) without Releasing first,

		 * the application Register command MUST have the same buffer

		 * type and size in the Register command (obtained from the

		 * Query command). Otherwise that Register command will be

		 * failed. If the application has released the buffer but wants

		 * to re-register it, it should be allowed as long as the

		 * Unique-Id/Size match.

				/*

				 * Application wants to own the buffer with

				 * the same size.

 success */

 Reset ioc variables used for additional query commands */

 TODO */

 process the completed Reply Message Frame */

/**

 * mpt3sas_enable_diag_buffer - enabling diag_buffers support driver load time

 * @ioc: per adapter object

 * @bits_to_register: bitwise field where trace is bit 0, and snapshot is bit 1

 *

 * This is called when command line option diag_buffer_enable is enabled

 * at driver load time.

 The buff size is not set correctly */

				/*

				 * retry the min size if decrement

				 * is not available.

 register for 2MB buffers  */

 adjust the buffer size */

 register for 2MB buffers  */

 register for 2MB buffers  */

/**

 * _ctl_diag_register - application register with driver

 * @ioc: per adapter object

 * @arg: user space buffer containing ioctl content

 *

 * This will allow the driver to setup any required buffers that will be

 * needed by firmware to communicate with the driver.

/**

 * _ctl_diag_unregister - application unregister with driver

 * @ioc: per adapter object

 * @arg: user space buffer containing ioctl content

 *

 * This will allow the driver to cleanup any memory allocated for diag

 * messages and to free up any resources.

/**

 * _ctl_diag_query - query relevant info associated with diag buffers

 * @ioc: per adapter object

 * @arg: user space buffer containing ioctl content

 *

 * The application will send only buffer_type and unique_id.  Driver will

 * inspect unique_id first, if valid, fill in all the info.  If unique_id is

 * 0x00, the driver will return info specified by Buffer Type.

/**

 * mpt3sas_send_diag_release - Diag Release Message

 * @ioc: per adapter object

 * @buffer_type: specifies either TRACE, SNAPSHOT, or EXTENDED

 * @issue_reset: specifies whether host reset is required.

 *

 TODO */

 process the completed Reply Message Frame */

/**

 * _ctl_diag_release - request to send Diag Release Message to firmware

 * @ioc: ?

 * @arg: user space buffer containing ioctl content

 *

 * This allows ownership of the specified buffer to returned to the driver,

 * allowing an application to read the buffer without fear that firmware is

 * overwriting information in the buffer.

 buffers were released by due to host reset */

/**

 * _ctl_diag_read_buffer - request for copy of the diag buffer

 * @ioc: per adapter object

 * @arg: user space buffer containing ioctl content

 Truncate data on requests that are too large */

	/* Get a free request frame and save the message context.

 TODO */

 process the completed Reply Message Frame */

/**

 * _ctl_addnl_diag_query - query relevant info associated with diag buffers

 * @ioc: per adapter object

 * @arg: user space buffer containing ioctl content

 *

 * The application will send only unique_id.  Driver will

 * inspect unique_id first, if valid, fill the details related to cause

 * for diag buffer release.

/**

 * _ctl_compat_mpt_command - convert 32bit pointers to 64bit.

 * @ioc: per adapter object

 * @cmd: ioctl opcode

 * @arg: (struct mpt3_ioctl_command32)

 *

 * MPT3COMMAND32 - Handle 32bit applications running on 64bit os.

/**

 * _ctl_ioctl_main - main ioctl entry point

 * @file:  (struct file)

 * @cmd:  ioctl opcode

 * @arg:  user space data buffer

 * @compat:  handles 32 bit applications in 64bit os

 * @mpi_version: will be MPI2_VERSION for mpt2ctl ioctl device &

 * MPI25_VERSION | MPI26_VERSION for mpt3ctl ioctl device.

 get IOCTL header */

 pci_access_mutex lock acquired by ioctl path */

/**

 * _ctl_ioctl - mpt3ctl main ioctl entry point (unlocked)

 * @file: (struct file)

 * @cmd: ioctl opcode

 * @arg: ?

	/* pass MPI25_VERSION | MPI26_VERSION value,

	 * to indicate that this ioctl cmd

	 * came from mpt3ctl ioctl device.

/**

 * _ctl_mpt2_ioctl - mpt2ctl main ioctl entry point (unlocked)

 * @file: (struct file)

 * @cmd: ioctl opcode

 * @arg: ?

	/* pass MPI2_VERSION value, to indicate that this ioctl cmd

	 * came from mpt2ctl ioctl device.

/**

 * _ctl_ioctl_compat - main ioctl entry point (compat)

 * @file: ?

 * @cmd: ?

 * @arg: ?

 *

 * This routine handles 32 bit applications in 64bit os.

/**

 * _ctl_mpt2_ioctl_compat - main ioctl entry point (compat)

 * @file: ?

 * @cmd: ?

 * @arg: ?

 *

 * This routine handles 32 bit applications in 64bit os.

 scsi host attributes */

/**

 * version_fw_show - firmware version

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * version_bios_show - bios version

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * version_mpi_show - MPI (message passing interface) version

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * version_product_show - product name

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * version_nvdata_persistent_show - ndvata persistent version

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * version_nvdata_default_show - nvdata default version

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * board_name_show - board name

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * board_assembly_show - board assembly name

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * board_tracer_show - board tracer number

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * io_delay_show - io missing delay

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * This is for firmware implemention for deboucing device

 * removal events.

 *

 * A sysfs 'read-only' shost attribute.

/**

 * device_delay_show - device missing delay

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * This is for firmware implemention for deboucing device

 * removal events.

 *

 * A sysfs 'read-only' shost attribute.

/**

 * fw_queue_depth_show - global credits

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * This is firmware queue depth limit

 *

 * A sysfs 'read-only' shost attribute.

/**

 * host_sas_address_show - sas address

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * This is the controller sas address

 *

 * A sysfs 'read-only' shost attribute.

/**

 * logging_level_show - logging level

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read/write' shost attribute.

/**

 * fwfault_debug_show - show/store fwfault_debug

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * mpt3sas_fwfault_debug is command line option

 * A sysfs 'read/write' shost attribute.

/**

 * ioc_reset_count_show - ioc reset count

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * This is firmware queue depth limit

 *

 * A sysfs 'read-only' shost attribute.

/**

 * reply_queue_count_show - number of reply queues

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * This is number of reply queues

 *

 * A sysfs 'read-only' shost attribute.

/**

 * BRM_status_show - Backup Rail Monitor Status

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * This is number of reply queues

 *

 * A sysfs 'read-only' shost attribute.

 pci_access_mutex lock acquired by sysfs show path */

 BRM status is in bit zero of GPIOVal[24] */

/**

 * host_trace_buffer_size_show - host buffer size (trace only)

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * host_trace_buffer_show - firmware ring buffer (trace only)

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read/write' shost attribute.

 *

 * You will only be able to read 4k bytes of ring buffer at a time.

 * In order to read beyond 4k bytes, you will have to write out the

 * offset to the same attribute, it will move the pointer.

****************************************/

/**

 * host_trace_buffer_enable_show - firmware ring buffer (trace only)

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read/write' shost attribute.

 *

 * This is a mechnism to post/release host_trace_buffers

 don't allow post/release occurr while recovery is active */

 exit out if host buffers are already posted */

 post the same buffer allocated previously */

			/*

			 * Free the diag buffer memory which was previously

			 * allocated by an application.

 exit out if host buffers are already released */

********** diagnostic trigger suppport *********************************/

/**

 * diag_trigger_master_show - show the diag_trigger_master attribute

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read/write' shost attribute.

/**

 * diag_trigger_master_store - store the diag_trigger_master attribute

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 * @count: ?

 *

 * A sysfs 'read/write' shost attribute.

/**

 * diag_trigger_event_show - show the diag_trigger_event attribute

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read/write' shost attribute.

/**

 * diag_trigger_event_store - store the diag_trigger_event attribute

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 * @count: ?

 *

 * A sysfs 'read/write' shost attribute.

/**

 * diag_trigger_scsi_show - show the diag_trigger_scsi attribute

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read/write' shost attribute.

/**

 * diag_trigger_scsi_store - store the diag_trigger_scsi attribute

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 * @count: ?

 *

 * A sysfs 'read/write' shost attribute.

/**

 * diag_trigger_mpi_show - show the diag_trigger_mpi attribute

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read/write' shost attribute.

/**

 * diag_trigger_mpi_store - store the diag_trigger_mpi attribute

 * @cdev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 * @count: ?

 *

 * A sysfs 'read/write' shost attribute.

********** diagnostic trigger suppport *** END ****************************/

****************************************/

/**

 * drv_support_bitmap_show - driver supported feature bitmap

 * @cdev: pointer to embedded class device

 * @attr: unused

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * enable_sdev_max_qd_show - display whether sdev max qd is enabled/disabled

 * @cdev: pointer to embedded class device

 * @attr: unused

 * @buf: the buffer returned

 *

 * A sysfs read/write shost attribute. This attribute is used to set the

 * targets queue depth to HBA IO queue depth if this attribute is enabled.

/**

 * enable_sdev_max_qd_store - Enable/disable sdev max qd

 * @cdev: pointer to embedded class device

 * @attr: unused

 * @buf: the buffer returned

 * @count: unused

 *

 * A sysfs read/write shost attribute. This attribute is used to set the

 * targets queue depth to HBA IO queue depth if this attribute is enabled.

 * If this attribute is disabled then targets will have corresponding default

 * queue depth.

 device attributes */

/**

 * sas_address_show - sas address

 * @dev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * This is the sas address for the target

 *

 * A sysfs 'read-only' shost attribute.

/**

 * sas_device_handle_show - device handle

 * @dev: pointer to embedded class device

 * @attr: ?

 * @buf: the buffer returned

 *

 * This is the firmware assigned device handle

 *

 * A sysfs 'read-only' shost attribute.

/**

 * sas_ncq_prio_supported_show - Indicate if device supports NCQ priority

 * @dev: pointer to embedded device

 * @attr: sas_ncq_prio_supported attribute descriptor

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' sdev attribute, only works with SATA

/**

 * sas_ncq_prio_enable_show - send prioritized io commands to device

 * @dev: pointer to embedded device

 * @attr: ?

 * @buf: the buffer returned

 *

 * A sysfs 'read/write' sdev attribute, only works with SATA

 file operations table for mpt3ctl device */

 file operations table for mpt2ctl device */

/**

 * mpt3sas_ctl_init - main entry point for ctl.

 * @hbas_to_enumerate: ?

	/* Don't register mpt3ctl ioctl device if

	 * hbas_to_enumarate is one.

	/* Don't register mpt3ctl ioctl device if

	 * hbas_to_enumarate is two.

/**

 * mpt3sas_ctl_exit - exit point for ctl

 * @hbas_to_enumerate: ?

 free memory associated to diag buffers */

/*

 * SAS Transport Layer for MPT (Message Passing Technology) based controllers

 *

 * This code is based on drivers/scsi/mpt3sas/mpt3sas_transport.c

 * Copyright (C) 2012-2014  LSI Corporation

 * Copyright (C) 2013-2014 Avago Technologies

 *  (mailto: MPT-FusionLinux.pdl@avagotech.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License

 * as published by the Free Software Foundation; either version 2

 * of the License, or (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * NO WARRANTY

 * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 * solely responsible for determining the appropriateness of using and

 * distributing the Program and assumes all risks associated with its

 * exercise of rights under this Agreement, including but not limited to

 * the risks and costs of program errors, damage to or loss of data,

 * programs or equipment, and unavailability or interruption of operations.



 * DISCLAIMER OF LIABILITY

 * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write to the Free Software

 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,

 * USA.

/**

 * _transport_get_port_id_by_sas_phy - get zone's port id that Phy belong to

 * @phy: sas_phy object

 *

 * Return Port number

/**

 * _transport_sas_node_find_by_sas_address - sas node search

 * @ioc: per adapter object

 * @sas_address: sas address of expander or sas host

 * @port: hba port entry

 * Context: Calling function should acquire ioc->sas_node_lock.

 *

 * Search for either hba phys or expander device based on handle, then returns

 * the sas_node object.

/**

 * _transport_get_port_id_by_rphy - Get Port number from rphy object

 * @ioc: per adapter object

 * @rphy: sas_rphy object

 *

 * Returns Port number.

/**

 * _transport_convert_phy_link_rate -

 * @link_rate: link rate returned from mpt firmware

 *

 * Convert link_rate from mpi fusion into sas_transport form.

/**

 * _transport_set_identify - set identify for phys and end devices

 * @ioc: per adapter object

 * @handle: device handle

 * @identify: sas identify info

 *

 * Populates sas identify info.

 *

 * Return: 0 for success, non-zero for failure.

 sas_address */

 phy number of the parent device this device is linked to */

 device_type */

 initiator_port_protocols */

 target_port_protocols */

/**

 * mpt3sas_transport_done -  internal transport layer callback handler.

 * @ioc: per adapter object

 * @smid: system request message index

 * @msix_index: MSIX table index supplied by the OS

 * @reply: reply message frame(lower 32bit addr)

 *

 * Callback handler when sending internal generated transport cmds.

 * The callback index passed is `ioc->transport_cb_idx`

 *

 * Return: 1 meaning mf should be freed from _base_interrupt

 *         0 means the mf is freed from this function.

 report manufacture request structure */

 report manufacture reply structure */

 0x41 */

 0x01 */

/**

 * _transport_expander_report_manufacture - obtain SMP report_manufacture

 * @ioc: per adapter object

 * @sas_address: expander sas address

 * @edev: the sas_expander_device object

 * @port_id: Port ID number

 *

 * Fills in the sas_expander_device object when SMP port is created.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * _transport_delete_port - helper function to removing a port

 * @ioc: per adapter object

 * @mpt3sas_port: mpt3sas per port object

/**

 * _transport_delete_phy - helper function to removing single phy from port

 * @ioc: per adapter object

 * @mpt3sas_port: mpt3sas per port object

 * @mpt3sas_phy: mpt3sas per phy object

/**

 * _transport_add_phy - helper function to adding single phy to port

 * @ioc: per adapter object

 * @mpt3sas_port: mpt3sas per port object

 * @mpt3sas_phy: mpt3sas per phy object

/**

 * mpt3sas_transport_add_phy_to_an_existing_port - adding new phy to existing port

 * @ioc: per adapter object

 * @sas_node: sas node object (either expander or sas host)

 * @mpt3sas_phy: mpt3sas per phy object

 * @sas_address: sas address of device/expander were phy needs to be added to

 * @port: hba port entry

/**

 * mpt3sas_transport_del_phy_from_an_existing_port - delete phy from existing port

 * @ioc: per adapter object

 * @sas_node: sas node object (either expander or sas host)

 * @mpt3sas_phy: mpt3sas per phy object

			/*

			 * Don't delete port during host reset,

			 * just delete phy.

/**

 * _transport_sanity_check - sanity check when adding a new port

 * @ioc: per adapter object

 * @sas_node: sas node object (either expander or sas host)

 * @sas_address: sas address of device being added

 * @port: hba port entry

 *

 * See the explanation above from _transport_delete_duplicate_port

/**

 * mpt3sas_transport_port_add - insert port to the list

 * @ioc: per adapter object

 * @handle: handle of attached device

 * @sas_address: sas address of parent expander or sas host

 * @hba_port: hba port entry

 * Context: This function will acquire ioc->sas_node_lock.

 *

 * Adding new port object to the sas_node->sas_port_list.

 *

 * Return: mpt3sas_port.

 fill in report manufacture */

/**

 * mpt3sas_transport_port_remove - remove port from the list

 * @ioc: per adapter object

 * @sas_address: sas address of attached device

 * @sas_address_parent: sas address of parent expander or sas host

 * @port: hba port entry

 * Context: This function will acquire ioc->sas_node_lock.

 *

 * Removing object and freeing associated memory from the

 * ioc->sas_port_list.

			/*

			 * Delete hba_port object if

			 *  - hba_port object's sas address matches with current

			 *    removed device's sas address and no vphy's

			 *    associated with it.

			 *  - Current removed device is a vSES device and

			 *    none of the other direct attached device have

			 *    this vSES device's port number (hence hba_port

			 *    object sas_address field will be zero).

				/*

				 * Current removed device is a non vSES device

				 * and a vSES device has the same port number

				 * as of current device's port number. Hence

				 * only clear the sas_address filed, don't

				 * delete the hba_port object.

/**

 * mpt3sas_transport_add_host_phy - report sas_host phy to transport

 * @ioc: per adapter object

 * @mpt3sas_phy: mpt3sas per phy object

 * @phy_pg0: sas phy page 0

 * @parent_dev: parent device class object

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_transport_add_expander_phy - report expander phy to transport

 * @ioc: per adapter object

 * @mpt3sas_phy: mpt3sas per phy object

 * @expander_pg1: expander page 1

 * @parent_dev: parent device class object

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_transport_update_links - refreshing phy link changes

 * @ioc: per adapter object

 * @sas_address: sas address of parent expander or sas host

 * @handle: attached device handle

 * @phy_number: phy number

 * @link_rate: new link rate

 * @port: hba port entry

 *

 * Return nothing.

 report phy error log structure */

 0x40 */

 0x11 */

 02 */

 report phy error log reply structure */

 0x41 */

 0x11 */

/**

 * _transport_get_expander_phy_error_log - return expander counters

 * @ioc: per adapter object

 * @phy: The sas phy object

 *

 * Return: 0 for success, non-zero for failure.

 *

 TODO */

/**

 * _transport_get_linkerrors - return phy counters for both hba and expanders

 * @phy: The sas phy object

 *

 * Return: 0 for success, non-zero for failure.

 *

 get hba phy error logs */

/**

 * _transport_get_enclosure_identifier -

 * @rphy: The sas phy object

 * @identifier: ?

 *

 * Obtain the enclosure logical id for an expander.

 * Return: 0 for success, non-zero for failure.

/**

 * _transport_get_bay_identifier -

 * @rphy: The sas phy object

 *

 * Return: the slot id for a device that resides inside an enclosure.

 phy control request structure */

 0x40 */

 0x91 */

 0x09 */

 phy control reply structure */

 0x41 */

 0x11 */

/**

 * _transport_expander_phy_control - expander phy control

 * @ioc: per adapter object

 * @phy: The sas phy object

 * @phy_operation: ?

 *

 * Return: 0 for success, non-zero for failure.

 *

 TODO */

/**

 * _transport_phy_reset -

 * @phy: The sas phy object

 * @hard_reset:

 *

 * Return: 0 for success, non-zero for failure.

 handle expander phys */

 handle hba phys */

/**

 * _transport_phy_enable - enable/disable phys

 * @phy: The sas phy object

 * @enable: enable phy when true

 *

 * Only support sas_host direct attached phys.

 * Return: 0 for success, non-zero for failure.

 handle expander phys */

 handle hba phys */

 read sas_iounit page 0 */

 unable to enable/disable phys when when discovery is active */

 read sas_iounit page 1 */

 copy Port/PortFlags/PhyFlags from page 0 */

 link reset */

/**

 * _transport_phy_speed - set phy min/max link rates

 * @phy: The sas phy object

 * @rates: rates defined in sas_phy_linkrates

 *

 * Only support sas_host direct attached phys.

 *

 * Return: 0 for success, non-zero for failure.

 handle expander phys */

 handle hba phys */

 sas_iounit page 1 */

 link reset */

 read phy page 0, then update the rates in the sas transport phy */

 Check if the request is split across multiple segments */

/**

 * _transport_smp_handler - transport portal for smp passthru

 * @job: ?

 * @shost: shost object

 * @rphy: sas transport rphy object

 *

 * This used primarily for smp_utils.

 * Example:

 *           smp_rep_general /sys/class/bsg/expander-5:0

/*

 * Scsi Host Layer for MPT (Message Passing Technology) based controllers

 *

 * This code is based on drivers/scsi/mpt3sas/mpt3sas_scsih.c

 * Copyright (C) 2012-2014  LSI Corporation

 * Copyright (C) 2013-2014 Avago Technologies

 *  (mailto: MPT-FusionLinux.pdl@avagotech.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License

 * as published by the Free Software Foundation; either version 2

 * of the License, or (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * NO WARRANTY

 * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 * solely responsible for determining the appropriateness of using and

 * distributing the Program and assumes all risks associated with its

 * exercise of rights under this Agreement, including but not limited to

 * the risks and costs of program errors, damage to or loss of data,

 * programs or equipment, and unavailability or interruption of operations.



 * DISCLAIMER OF LIABILITY

 * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write to the Free Software

 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,

 * USA.

 forward proto's */

 global parameters */

 global ioc lock for list operations */

 local parameters */

 command line options */

 scsi-mid layer global parmeter is max_report_luns, which is 511 */

/* diag_buffer_enable is bitwise

 * bit 0 set = TRACE

 * bit 1 set = SNAPSHOT

 * bit 2 set = EXTENDED

 *

 * Either bit can be set, or both

 permit overriding the host protection capabilities mask (EEDP/T10 PI) */

 raid transport support */

/**

 * struct sense_info - common structure for obtaining sense keys

 * @skey: sense key

 * @asc: additional sense code

 * @ascq: additional sense code qualifier

/**

 * struct fw_event_work - firmware event struct

 * @list: link list framework

 * @work: work object (ioc->fault_reset_work_q)

 * @ioc: per adapter object

 * @device_handle: device handle

 * @VF_ID: virtual function id

 * @VP_ID: virtual port id

 * @ignore: flag meaning this event has been marked to ignore

 * @event: firmware event MPI2_EVENT_XXX defined in mpi2_ioc.h

 * @refcount: kref for this event

 * @event_data: reply event data payload follows

 *

 * This object stored on ioc->fw_event_list.

/**

 * struct _scsi_io_transfer - scsi io transfer

 * @handle: sas device handle (assigned by firmware)

 * @is_raid: flag set for hidden raid components

 * @dir: DMA_TO_DEVICE, DMA_FROM_DEVICE,

 * @data_length: data transfer length

 * @data_dma: dma pointer to data

 * @sense: sense data

 * @lun: lun number

 * @cdb_length: cdb length

 * @cdb: cdb contents

 * @timeout: timeout for this command

 * @VF_ID: virtual function id

 * @VP_ID: virtual port id

 * @valid_reply: flag set for reply message

 * @sense_length: sense length

 * @ioc_status: ioc status

 * @scsi_state: scsi state

 * @scsi_status: scsi staus

 * @log_info: log information

 * @transfer_length: data length transfer when there is a reply message

 *

 * Used for sending internal scsi commands to devices within this module.

 * Refer to _scsi_send_scsi_io().

 the following bits are only valid when 'valid_reply = 1' */

/**

 * _scsih_set_debug_level - global setting of ioc->logging_level.

 * @val: ?

 * @kp: ?

 *

 * Note: The logging levels are defined in mpt3sas_debug.h.

/**

 * _scsih_srch_boot_sas_address - search based on sas_address

 * @sas_address: sas address

 * @boot_device: boot device object from bios page 2

 *

 * Return: 1 when there's a match, 0 means no match.

/**

 * _scsih_srch_boot_device_name - search based on device name

 * @device_name: device name specified in INDENTIFY fram

 * @boot_device: boot device object from bios page 2

 *

 * Return: 1 when there's a match, 0 means no match.

/**

 * _scsih_srch_boot_encl_slot - search based on enclosure_logical_id/slot

 * @enclosure_logical_id: enclosure logical id

 * @slot_number: slot number

 * @boot_device: boot device object from bios page 2

 *

 * Return: 1 when there's a match, 0 means no match.

/**

 * mpt3sas_get_port_by_id - get hba port entry corresponding to provided

 *			  port number from port list

 * @ioc: per adapter object

 * @port_id: port number

 * @bypass_dirty_port_flag: when set look the matching hba port entry even

 *			if hba port entry is marked as dirty.

 *

 * Search for hba port entry corresponding to provided port number,

 * if available return port object otherwise return NULL.

	/*

	 * When multipath_on_hba is disabled then

	 * search the hba_port entry using default

	 * port id i.e. 255

	/*

	 * Allocate hba_port object for default port id (i.e. 255)

	 * when multipath_on_hba is disabled for the HBA.

	 * And add this object to port_table_list.

/**

 * mpt3sas_get_vphy_by_phy - get virtual_phy object corresponding to phy number

 * @ioc: per adapter object

 * @port: hba_port object

 * @phy: phy number

 *

 * Return virtual_phy object corresponding to phy number.

/**

 * _scsih_is_boot_device - search for matching boot device.

 * @sas_address: sas address

 * @device_name: device name specified in INDENTIFY fram

 * @enclosure_logical_id: enclosure logical id

 * @slot: slot number

 * @form: specifies boot device form

 * @boot_device: boot device object from bios page 2

 *

 * Return: 1 when there's a match, 0 means no match.

/**

 * _scsih_get_sas_address - set the sas_address for given device handle

 * @ioc: ?

 * @handle: device handle

 * @sas_address: sas address

 *

 * Return: 0 success, non-zero when failure

		/* For HBA, vSES doesn't return HBA SAS address. Instead return

		 * vSES's sas address.

 we hit this because the given parent handle doesn't exist */

 else error case */

/**

 * _scsih_determine_boot_device - determine boot device.

 * @ioc: per adapter object

 * @device: sas_device or pcie_device object

 * @channel: SAS or PCIe channel

 *

 * Determines whether this device should be first reported device to

 * to scsi-ml or sas transport, this purpose is for persistent boot device.

 * There are primary, alternate, and current entries in bios page 2. The order

 * priority is primary, alternate, then current.  This routine saves

 * the corresponding device object.

 * The saved data to be used later in _scsih_probe_boot_devices().

 only process this function when driver loads */

 no Bios, return immediately */

/**

 * mpt3sas_get_pdev_from_target - pcie device search

 * @ioc: per adapter object

 * @tgt_priv: starget private object

 *

 * Context: This function will acquire ioc->pcie_device_lock and will release

 * before returning the pcie_device object.

 *

 * This searches for pcie_device from target, then return pcie_device object.

/**

 * __mpt3sas_get_sdev_by_rphy - sas device search

 * @ioc: per adapter object

 * @rphy: sas_rphy pointer

 *

 * Context: This function will acquire ioc->sas_device_lock and will release

 * before returning the sas_device object.

 *

 * This searches for sas_device from rphy object

 * then return sas_device object.

/**

 * __mpt3sas_get_sdev_by_addr - get _sas_device object corresponding to provided

 *				sas address from sas_device_list list

 * @ioc: per adapter object

 * @sas_address: device sas address

 * @port: port number

 *

 * Search for _sas_device object corresponding to provided sas address,

 * if available return _sas_device object address otherwise return NULL.

/**

 * mpt3sas_get_sdev_by_addr - sas device search

 * @ioc: per adapter object

 * @sas_address: sas address

 * @port: hba port entry

 * Context: Calling function should acquire ioc->sas_device_lock

 *

 * This searches for sas_device based on sas_address & port number,

 * then return sas_device object.

/**

 * mpt3sas_get_sdev_by_handle - sas device search

 * @ioc: per adapter object

 * @handle: sas device handle (assigned by firmware)

 * Context: Calling function should acquire ioc->sas_device_lock

 *

 * This searches for sas_device based on sas_address, then return sas_device

 * object.

/**

 * _scsih_display_enclosure_chassis_info - display device location info

 * @ioc: per adapter object

 * @sas_device: per sas device object

 * @sdev: scsi device struct

 * @starget: scsi target struct

/**

 * _scsih_sas_device_remove - remove sas_device from list.

 * @ioc: per adapter object

 * @sas_device: the sas_device object

 * Context: This function will acquire ioc->sas_device_lock.

 *

 * If sas_device is on the list, remove it and decrement its reference count.

	/*

	 * The lock serializes access to the list, but we still need to verify

	 * that nobody removed the entry while we were waiting on the lock.

/**

 * _scsih_device_remove_by_handle - removing device object by handle

 * @ioc: per adapter object

 * @handle: device handle

/**

 * mpt3sas_device_remove_by_sas_address - removing device object by

 *					sas address & port number

 * @ioc: per adapter object

 * @sas_address: device sas_address

 * @port: hba port entry

 *

 * Return nothing.

/**

 * _scsih_sas_device_add - insert sas_device to the list.

 * @ioc: per adapter object

 * @sas_device: the sas_device object

 * Context: This function will acquire ioc->sas_device_lock.

 *

 * Adding new object to the ioc->sas_device_list.

		/*

		 * When asyn scanning is enabled, its not possible to remove

		 * devices while scanning is turned on due to an oops in

		 * scsi_sysfs_add_sdev()->add_device()->sysfs_addrm_start()

/**

 * _scsih_sas_device_init_add - insert sas_device to the list.

 * @ioc: per adapter object

 * @sas_device: the sas_device object

 * Context: This function will acquire ioc->sas_device_lock.

 *

 * Adding new object at driver load time to the ioc->sas_device_init_list.

/**

 * mpt3sas_get_pdev_by_wwid - pcie device search

 * @ioc: per adapter object

 * @wwid: wwid

 *

 * Context: This function will acquire ioc->pcie_device_lock and will release

 * before returning the pcie_device object.

 *

 * This searches for pcie_device based on wwid, then return pcie_device object.

/**

 * mpt3sas_get_pdev_by_handle - pcie device search

 * @ioc: per adapter object

 * @handle: Firmware device handle

 *

 * Context: This function will acquire ioc->pcie_device_lock and will release

 * before returning the pcie_device object.

 *

 * This searches for pcie_device based on handle, then return pcie_device

 * object.

/**

 * _scsih_set_nvme_max_shutdown_latency - Update max_shutdown_latency.

 * @ioc: per adapter object

 * Context: This function will acquire ioc->pcie_device_lock

 *

 * Update ioc->max_shutdown_latency to that NVMe drives RTD3 Entry Latency

 * which has reported maximum among all available NVMe drives.

 * Minimum max_shutdown_latency will be six seconds.

/**

 * _scsih_pcie_device_remove - remove pcie_device from list.

 * @ioc: per adapter object

 * @pcie_device: the pcie_device object

 * Context: This function will acquire ioc->pcie_device_lock.

 *

 * If pcie_device is on the list, remove it and decrement its reference count.

	/*

	 * This device's RTD3 Entry Latency matches IOC's

	 * max_shutdown_latency. Recalculate IOC's max_shutdown_latency

	 * from the available drives as current drive is getting removed.

/**

 * _scsih_pcie_device_remove_by_handle - removing pcie device object by handle

 * @ioc: per adapter object

 * @handle: device handle

	/*

	 * This device's RTD3 Entry Latency matches IOC's

	 * max_shutdown_latency. Recalculate IOC's max_shutdown_latency

	 * from the available drives as current drive is getting removed.

/**

 * _scsih_pcie_device_add - add pcie_device object

 * @ioc: per adapter object

 * @pcie_device: pcie_device object

 *

 * This is added to the pcie_device_list link list.

TODO-- Need to find out whether this condition will occur or not*/

/*

 * _scsih_pcie_device_init_add - insert pcie_device to the init list.

 * @ioc: per adapter object

 * @pcie_device: the pcie_device object

 * Context: This function will acquire ioc->pcie_device_lock.

 *

 * Adding new object at driver load time to the ioc->pcie_device_init_list.

/**

 * _scsih_raid_device_find_by_id - raid device search

 * @ioc: per adapter object

 * @id: sas device target id

 * @channel: sas device channel

 * Context: Calling function should acquire ioc->raid_device_lock

 *

 * This searches for raid_device based on target id, then return raid_device

 * object.

/**

 * mpt3sas_raid_device_find_by_handle - raid device search

 * @ioc: per adapter object

 * @handle: sas device handle (assigned by firmware)

 * Context: Calling function should acquire ioc->raid_device_lock

 *

 * This searches for raid_device based on handle, then return raid_device

 * object.

/**

 * _scsih_raid_device_find_by_wwid - raid device search

 * @ioc: per adapter object

 * @wwid: ?

 * Context: Calling function should acquire ioc->raid_device_lock

 *

 * This searches for raid_device based on wwid, then return raid_device

 * object.

/**

 * _scsih_raid_device_add - add raid_device object

 * @ioc: per adapter object

 * @raid_device: raid_device object

 *

 * This is added to the raid_device_list link list.

/**

 * _scsih_raid_device_remove - delete raid_device object

 * @ioc: per adapter object

 * @raid_device: raid_device object

 *

/**

 * mpt3sas_scsih_expander_find_by_handle - expander device search

 * @ioc: per adapter object

 * @handle: expander handle (assigned by firmware)

 * Context: Calling function should acquire ioc->sas_device_lock

 *

 * This searches for expander device based on handle, then returns the

 * sas_node object.

/**

 * mpt3sas_scsih_enclosure_find_by_handle - exclosure device search

 * @ioc: per adapter object

 * @handle: enclosure handle (assigned by firmware)

 * Context: Calling function should acquire ioc->sas_device_lock

 *

 * This searches for enclosure device based on handle, then returns the

 * enclosure object.

/**

 * mpt3sas_scsih_expander_find_by_sas_address - expander device search

 * @ioc: per adapter object

 * @sas_address: sas address

 * @port: hba port entry

 * Context: Calling function should acquire ioc->sas_node_lock.

 *

 * This searches for expander device based on sas_address & port number,

 * then returns the sas_node object.

/**

 * _scsih_expander_node_add - insert expander device to the list.

 * @ioc: per adapter object

 * @sas_expander: the sas_device object

 * Context: This function will acquire ioc->sas_node_lock.

 *

 * Adding new object to the ioc->sas_expander_list.

/**

 * _scsih_is_end_device - determines if device is an end device

 * @device_info: bitfield providing information about the device.

 * Context: none

 *

 * Return: 1 if end device.

/**

 * _scsih_is_nvme_pciescsi_device - determines if

 *			device is an pcie nvme/scsi device

 * @device_info: bitfield providing information about the device.

 * Context: none

 *

 * Returns 1 if device is pcie device type nvme/scsi.

/**

 * _scsih_scsi_lookup_find_by_target - search for matching channel:id

 * @ioc: per adapter object

 * @id: target id

 * @channel: channel

 * Context: This function will acquire ioc->scsi_lookup_lock.

 *

 * This will search for a matching channel:id in the scsi_lookup array,

 * returning 1 if found.

/**

 * _scsih_scsi_lookup_find_by_lun - search for matching channel:id:lun

 * @ioc: per adapter object

 * @id: target id

 * @lun: lun number

 * @channel: channel

 * Context: This function will acquire ioc->scsi_lookup_lock.

 *

 * This will search for a matching channel:id:lun in the scsi_lookup array,

 * returning 1 if found.

/**

 * mpt3sas_scsih_scsi_lookup_get - returns scmd entry

 * @ioc: per adapter object

 * @smid: system request message index

 *

 * Return: the smid stored scmd pointer.

 * Then will dereference the stored scmd pointer.

		/*

		 * If SCSI IO request is outstanding at driver level then

		 * DevHandle filed must be non-zero. If DevHandle is zero

		 * then it means that this smid is free at driver level,

		 * so return NULL.

/**

 * scsih_change_queue_depth - setting device queue depth

 * @sdev: scsi device struct

 * @qdepth: requested queue depth

 *

 * Return: queue depth.

	/*

	 * limit max device queue for SATA to 32 if enable_sdev_max_qd

	 * is disabled.

/**

 * mpt3sas_scsih_change_queue_depth - setting device queue depth

 * @sdev: scsi device struct

 * @qdepth: requested queue depth

 *

 * Returns nothing.

/**

 * scsih_target_alloc - target add routine

 * @starget: scsi target struct

 *

 * Return: 0 if ok. Any other return is assumed to be an error and

 * the device is ignored.

 RAID volumes */

 PCIe devices */

 sas/sata devices */

/**

 * scsih_target_destroy - target destroy routine

 * @starget: scsi target struct

			/*

			 * Corresponding get() is in _scsih_target_alloc()

		/*

		 * Corresponding get() is in _scsih_target_alloc()

/**

 * scsih_slave_alloc - device add routine

 * @sdev: scsi device struct

 *

 * Return: 0 if ok. Any other return is assumed to be an error and

 * the device is ignored.

 raid is single lun */

/**

 * scsih_slave_destroy - device destroy routine

 * @sdev: scsi device struct

/**

 * _scsih_display_sata_capabilities - sata capabilities

 * @ioc: per adapter object

 * @handle: device handle

 * @sdev: scsi device struct

/*

 * raid transport support -

 * Enabled for SLES11 and newer, in older kernels the driver will panic when

 * unloading the driver followed by a load - I believe that the subroutine

 * raid_class_release() is not cleaning up properly.

/**

 * scsih_is_raid - return boolean indicating device is raid volume

 * @dev: the device struct object

/**

 * scsih_get_resync - get raid volume resync percent complete

 * @dev: the device struct object

/**

 * scsih_get_state - get raid volume level

 * @dev: the device struct object

/**

 * _scsih_set_level - set raid level

 * @ioc: ?

 * @sdev: scsi device struct

 * @volume_type: volume type

/**

 * _scsih_get_volume_capabilities - volume capabilities

 * @ioc: per adapter object

 * @raid_device: the raid_device object

 *

 * Return: 0 for success, else 1

	/* figure out what the underlying devices are by

	 * obtaining the device_info bits for the 1st device

/**

 * _scsih_enable_tlr - setting TLR flags

 * @ioc: per adapter object

 * @sdev: scsi device struct

 *

 * Enabling Transaction Layer Retries for tape devices when

 * vpd page 0x90 is present

 *

 only for TAPE */

/**

 * scsih_slave_configure - device configure routine.

 * @sdev: scsi device struct

 *

 * Return: 0 if ok. Any other return is assumed to be an error and

 * the device is ignored.

 raid volume handling */

		/*

		 * WARPDRIVE: Initialize the required data for Direct IO

		/* RAID Queue Depth Support

		 * IS volume = underlying qdepth of drive type, either

		 *    MPT3SAS_SAS_QUEUE_DEPTH or MPT3SAS_SATA_QUEUE_DEPTH

		 * IM/IME/R10 = 128 (MPT3SAS_RAID_QUEUE_DEPTH)

 raid transport support */

 non-raid handling */

 PCIe handling */

		/* Enable QUEUE_FLAG_NOMERGES flag, so that IOs won't be

		 ** merged and can eliminate holes created during merging

		 ** operation.

/**

 * scsih_bios_param - fetch head, sector, cylinder info for a disk

 * @sdev: scsi device struct

 * @bdev: pointer to block device context

 * @capacity: device size (in 512 byte sectors)

 * @params: three element array to place output:

 *              params[0] number of heads (max 255)

 *              params[1] number of sectors (max 63)

 *              params[2] number of cylinders

	/*

	 * Handle extended translation size for logical drives

	 * > 1Gb

 return result */

/**

 * _scsih_response_code - translation of device response code

 * @ioc: per adapter object

 * @response_code: response code returned by the device

/**

 * _scsih_tm_done - tm completion routine

 * @ioc: per adapter object

 * @smid: system request message index

 * @msix_index: MSIX table index supplied by the OS

 * @reply: reply message frame(lower 32bit addr)

 * Context: none.

 *

 * The callback handler when using scsih_issue_tm.

 *

 * Return: 1 meaning mf should be freed from _base_interrupt

 *         0 means the mf is freed from this function.

/**

 * mpt3sas_scsih_set_tm_flag - set per target tm_busy

 * @ioc: per adapter object

 * @handle: device handle

 *

 * During taskmangement request, we need to freeze the device queue.

/**

 * mpt3sas_scsih_clear_tm_flag - clear per target tm_busy

 * @ioc: per adapter object

 * @handle: device handle

 *

 * During taskmangement request, we need to freeze the device queue.

/**

 * scsih_tm_cmd_map_status - map the target reset & LUN reset TM status

 * @ioc: per adapter object

 * @channel: the channel assigned by the OS

 * @id: the id assigned by the OS

 * @lun: lun number

 * @type: MPI2_SCSITASKMGMT_TASKTYPE__XXX (defined in mpi2_init.h)

 * @smid_task: smid assigned to the task

 *

 * Look whether TM has aborted the timed out SCSI command, if

 * TM has aborted the IO then return SUCCESS else return FAILED.

/**

 * scsih_tm_post_processing - post processing of target & LUN reset

 * @ioc: per adapter object

 * @handle: device handle

 * @channel: the channel assigned by the OS

 * @id: the id assigned by the OS

 * @lun: lun number

 * @type: MPI2_SCSITASKMGMT_TASKTYPE__XXX (defined in mpi2_init.h)

 * @smid_task: smid assigned to the task

 *

 * Post processing of target & LUN reset. Due to interrupt latency

 * issue it possible that interrupt for aborted IO might not be

 * received yet. So before returning failure status, poll the

 * reply descriptor pools for the reply of timed out SCSI command.

 * Return FAILED status if reply for timed out is not received

 * otherwise return SUCCESS.

	/*

	 * Due to interrupt latency issues, driver may receive interrupt for

	 * TM first and then for aborted SCSI IO command. So, poll all the

	 * ReplyDescriptor pools before returning the FAILED status to SML.

/**

 * mpt3sas_scsih_issue_tm - main routine for sending tm requests

 * @ioc: per adapter struct

 * @handle: device handle

 * @channel: the channel assigned by the OS

 * @id: the id assigned by the OS

 * @lun: lun number

 * @type: MPI2_SCSITASKMGMT_TASKTYPE__XXX (defined in mpi2_init.h)

 * @smid_task: smid assigned to the task

 * @msix_task: MSIX table index supplied by the OS

 * @timeout: timeout in seconds

 * @tr_method: Target Reset Method

 * Context: user

 *

 * A generic API for sending task management requests to firmware.

 *

 * The callback index is set inside `ioc->tm_cb_idx`.

 * The caller is responsible to check for outstanding commands.

 *

 * Return: SUCCESS or FAILED.

 sync IRQs in case those were busy during flush. */

		/*

		 * If DevHandle filed in smid_task's entry of request pool

		 * doesn't match with device handle on which this task abort

		 * TM is received then it means that TM has successfully

		 * aborted the timed out command. Since smid_task's entry in

		 * request pool will be memset to zero once the timed out

		 * command is returned to the SML. If the command is not

		 * aborted then smid_task’s entry won’t be cleared and it

		 * will have same DevHandle value on which this task abort TM

		 * is received and driver will return the TM status as FAILED.

/**

 * _scsih_tm_display_info - displays info about the device

 * @ioc: per adapter struct

 * @scmd: pointer to scsi command object

 *

 * Called by task management callback handlers.

/**

 * scsih_abort - eh threads main abort routine

 * @scmd: pointer to scsi command object

 *

 * Return: SUCCESS if command aborted else FAILED

 check for completed command */

 for hidden raid components and volumes this is not supported */

 Command must be cleared after abort */

/**

 * scsih_dev_reset - eh threads main device reset routine

 * @scmd: pointer to scsi command object

 *

 * Return: SUCCESS if command aborted else FAILED

 for hidden raid components obtain the volume_handle */

 Check for busy commands after reset */

/**

 * scsih_target_reset - eh threads main target reset routine

 * @scmd: pointer to scsi command object

 *

 * Return: SUCCESS if command aborted else FAILED

 for hidden raid components obtain the volume_handle */

 Check for busy commands after reset */

/**

 * scsih_host_reset - eh threads main host reset routine

 * @scmd: pointer to scsi command object

 *

 * Return: SUCCESS if command aborted else FAILED

/**

 * _scsih_fw_event_add - insert and queue up fw_event

 * @ioc: per adapter object

 * @fw_event: object describing the event

 * Context: This function will acquire ioc->fw_event_lock.

 *

 * This adds the firmware event object into link list, then queues it up to

 * be processed from user context.

/**

 * _scsih_fw_event_del_from_list - delete fw_event from the list

 * @ioc: per adapter object

 * @fw_event: object describing the event

 * Context: This function will acquire ioc->fw_event_lock.

 *

 * If the fw_event is on the fw_event_list, remove it and do a put.

 /**

 * mpt3sas_send_trigger_data_event - send event for processing trigger data

 * @ioc: per adapter object

 * @event_data: trigger event data

/**

 * _scsih_error_recovery_delete_devices - remove devices not responding

 * @ioc: per adapter object

/**

 * mpt3sas_port_enable_complete - port enable completed (fake event)

 * @ioc: per adapter object

/**

 * _scsih_fw_event_cleanup_queue - cleanup event queue

 * @ioc: per adapter object

 *

 * Walk the firmware event queue, either killing timers, or waiting

 * for outstanding events to complete

 *

 * Context: task, can sleep

	/*

	 * Set current running event as ignore, so that

	 * current running event will exit quickly.

	 * As diag reset has occurred it is of no use

	 * to process remaining stale event data entries.

		/*

		 * Don't call cancel_work_sync() for current_event

		 * other than MPT3SAS_REMOVE_UNRESPONDING_DEVICES;

		 * otherwise we may observe deadlock if current

		 * hard reset issued as part of processing the current_event.

		 *

		 * Orginal logic of cleaning the current_event is added

		 * for handling the back to back host reset issued by the user.

		 * i.e. during back to back host reset, driver use to process

		 * the two instances of MPT3SAS_REMOVE_UNRESPONDING_DEVICES

		 * event back to back and this made the drives to unregister

		 * the devices from SML.

		/*

		 * Driver has to clear ioc->start_scan flag when

		 * it is cleaning up MPT3SAS_PORT_ENABLE_COMPLETE,

		 * otherwise scsi_scan_host() API waits for the

		 * 5 minute timer to expire. If we exit from

		 * scsi_scan_host() early then we can issue the

		 * new port enable request as part of current diag reset.

		/*

		 * Wait on the fw_event to complete. If this returns 1, then

		 * the event was never executed, and we need a put for the

		 * reference the work had on the fw_event.

		 *

		 * If it did execute, we wait for it to finish, and the put will

		 * happen from _firmware_event_work()

/**

 * _scsih_internal_device_block - block the sdev device

 * @sdev: per device object

 * @sas_device_priv_data : per device driver private data

 *

 * make sure device is blocked without error, if not

 * print an error

/**

 * _scsih_internal_device_unblock - unblock the sdev device

 * @sdev: per device object

 * @sas_device_priv_data : per device driver private data

 * make sure device is unblocked without error, if not retry

 * by blocking and then unblocking

		/* The device has been set to SDEV_RUNNING by SD layer during

		 * device addition but the request queue is still stopped by

		 * our earlier block call. We need to perform a block again

/**

 * _scsih_ublock_io_all_device - unblock every device

 * @ioc: per adapter object

 *

 * change the device state from block to running

/**

 * _scsih_ublock_io_device - prepare device to be deleted

 * @ioc: per adapter object

 * @sas_address: sas address

 * @port: hba port entry

 *

 * unblock then put device in offline state

/**

 * _scsih_block_io_all_device - set the device state to SDEV_BLOCK

 * @ioc: per adapter object

 *

 * During device pull we need to appropriately set the sdev state.

/**

 * _scsih_block_io_device - set the device state to SDEV_BLOCK

 * @ioc: per adapter object

 * @handle: device handle

 *

 * During device pull we need to appropriately set the sdev state.

/**

 * _scsih_block_io_to_children_attached_to_ex

 * @ioc: per adapter object

 * @sas_expander: the sas_device object

 *

 * This routine set sdev state to SDEV_BLOCK for all devices

 * attached to this expander. This function called when expander is

 * pulled.

/**

 * _scsih_block_io_to_children_attached_directly

 * @ioc: per adapter object

 * @event_data: topology change event data

 *

 * This routine set sdev state to SDEV_BLOCK for all devices

 * direct attached during device pull.

/**

 * _scsih_block_io_to_pcie_children_attached_directly

 * @ioc: per adapter object

 * @event_data: topology change event data

 *

 * This routine set sdev state to SDEV_BLOCK for all devices

 * direct attached during device pull/reconnect.

/**

 * _scsih_tm_tr_send - send task management request

 * @ioc: per adapter object

 * @handle: device handle

 * Context: interrupt time.

 *

 * This code is to initiate the device removal handshake protocol

 * with controller firmware.  This function will issue target reset

 * using high priority request queue.  It will send a sas iounit

 * control request (MPI2_SAS_OP_REMOVE_DEVICE) from this completion.

 *

 * This is designed to send muliple task management request at the same

 * time to the fifo. If the fifo is full, we will append the request,

 * and process it in a future completion.

 if PD, then return */

/**

 * _scsih_tm_tr_complete -

 * @ioc: per adapter object

 * @smid: system request message index

 * @msix_index: MSIX table index supplied by the OS

 * @reply: reply message frame(lower 32bit addr)

 * Context: interrupt time.

 *

 * This is the target reset completion routine.

 * This code is part of the code to initiate the device removal

 * handshake protocol with controller firmware.

 * It will send a sas iounit control request (MPI2_SAS_OP_REMOVE_DEVICE)

 *

 * Return: 1 meaning mf should be freed from _base_interrupt

 *         0 means the mf is freed from this function.

/** _scsih_allow_scmd_to_device - check whether scmd needs to

 *				 issue to IOC or not.

 * @ioc: per adapter object

 * @scmd: pointer to scsi command object

 *

 * Returns true if scmd can be issued to IOC otherwise returns false.

/**

 * _scsih_sas_control_complete - completion routine

 * @ioc: per adapter object

 * @smid: system request message index

 * @msix_index: MSIX table index supplied by the OS

 * @reply: reply message frame(lower 32bit addr)

 * Context: interrupt time.

 *

 * This is the sas iounit control completion routine.

 * This code is part of the code to initiate the device removal

 * handshake protocol with controller firmware.

 *

 * Return: 1 meaning mf should be freed from _base_interrupt

 *         0 means the mf is freed from this function.

/**

 * _scsih_tm_tr_volume_send - send target reset request for volumes

 * @ioc: per adapter object

 * @handle: device handle

 * Context: interrupt time.

 *

 * This is designed to send muliple task management request at the same

 * time to the fifo. If the fifo is full, we will append the request,

 * and process it in a future completion.

/**

 * _scsih_tm_volume_tr_complete - target reset completion

 * @ioc: per adapter object

 * @smid: system request message index

 * @msix_index: MSIX table index supplied by the OS

 * @reply: reply message frame(lower 32bit addr)

 * Context: interrupt time.

 *

 * Return: 1 meaning mf should be freed from _base_interrupt

 *         0 means the mf is freed from this function.

/**

 * _scsih_issue_delayed_event_ack - issue delayed Event ACK messages

 * @ioc: per adapter object

 * @smid: system request message index

 * @event: Event ID

 * @event_context: used to track events uniquely

 *

 * Context - processed in interrupt context.

	/* Without releasing the smid just update the

	 * call back index and reuse the same smid for

	 * processing this delayed request

 TODO */

/**

 * _scsih_issue_delayed_sas_io_unit_ctrl - issue delayed

 *				sas_io_unit_ctrl messages

 * @ioc: per adapter object

 * @smid: system request message index

 * @handle: device handle

 *

 * Context - processed in interrupt context.

	/* Without releasing the smid just update the

	 * call back index and reuse the same smid for

	 * processing this delayed request

/**

 * mpt3sas_check_for_pending_internal_cmds - check for pending internal messages

 * @ioc: per adapter object

 * @smid: system request message index

 *

 * Context: Executed in interrupt context

 *

 * This will check delayed internal messages list, and process the

 * next request.

 *

 * Return: 1 meaning mf should be freed from _base_interrupt

 *         0 means the mf is freed from this function.

/**

 * _scsih_check_for_pending_tm - check for pending task management

 * @ioc: per adapter object

 * @smid: system request message index

 *

 * This will check delayed target reset list, and feed the

 * next reqeust.

 *

 * Return: 1 meaning mf should be freed from _base_interrupt

 *         0 means the mf is freed from this function.

/**

 * _scsih_check_topo_delete_events - sanity check on topo events

 * @ioc: per adapter object

 * @event_data: the event data payload

 *

 * This routine added to better handle cable breaker.

 *

 * This handles the case where driver receives multiple expander

 * add and delete events in a single shot.  When there is a delete event

 * the routine will void any pending add events waiting in the event queue.

 put expander attached devices into blocking state */

 mark ignore flag for pending events */

/**

 * _scsih_check_pcie_topo_remove_events - sanity check on topo

 * events

 * @ioc: per adapter object

 * @event_data: the event data payload

 *

 * This handles the case where driver receives multiple switch

 * or device add and delete events in a single shot.  When there

 * is a delete event the routine will void any pending add

 * events waiting in the event queue.

 TODO We are not supporting cascaded PCIe Switch removal yet*/

 mark ignore flag for pending events */

/**

 * _scsih_set_volume_delete_flag - setting volume delete flag

 * @ioc: per adapter object

 * @handle: device handle

 *

 * This returns nothing.

/**

 * _scsih_set_volume_handle_for_tr - set handle for target reset to volume

 * @handle: input handle

 * @a: handle for volume a

 * @b: handle for volume b

 *

 * IR firmware only supports two raid volumes.  The purpose of this

 * routine is to set the volume handle in either a or b. When the given

 * input handle is non-zero, or when a and b have not been set before.

/**

 * _scsih_check_ir_config_unhide_events - check for UNHIDE events

 * @ioc: per adapter object

 * @event_data: the event data payload

 * Context: interrupt time.

 *

 * This routine will send target reset to volume, followed by target

 * resets to the PDs. This is called when a PD has been removed, or

 * volume has been deleted or removed. When the target reset is sent

 * to volume, the PD target resets need to be queued to start upon

 * completion of the volume target reset.

 Volume Resets for Deleted or Removed */

 Volume Resets for UNHIDE events */

 PD target resets */

/**

 * _scsih_check_volume_delete_events - set delete flag for volumes

 * @ioc: per adapter object

 * @event_data: the event data payload

 * Context: interrupt time.

 *

 * This will handle the case when the cable connected to entire volume is

 * pulled. We will take care of setting the deleted flag so normal IO will

 * not be sent.

/**

 * _scsih_temp_threshold_events - display temperature threshold exceeded events

 * @ioc: per adapter object

 * @event_data: the temp threshold event data

 * Context: interrupt time.

/**

 * _scsih_flush_running_cmds - completing outstanding commands.

 * @ioc: per adapter object

 *

 * The flushing out of all pending scmd commands following host reset,

 * where all IO is dropped to the floor.

/**

 * _scsih_setup_eedp - setup MPI request for EEDP transfer

 * @ioc: per adapter object

 * @scmd: pointer to scsi command object

 * @mpi_request: pointer to the SCSI_IO request message frame

 *

 * Supporting protection 1 and 3.

/**

 * _scsih_eedp_error_handling - return sense code for EEDP errors

 * @scmd: pointer to scsi command object

 * @ioc_status: ioc status

/**

 * scsih_qcmd - main scsi request entry point

 * @shost: SCSI host pointer

 * @scmd: pointer to scsi command object

 *

 * The callback index is set inside `ioc->scsi_io_cb_idx`.

 *

 * Return: 0 on success.  If there's a failure, return either:

 * SCSI_MLQUEUE_DEVICE_BUSY if the device queue is full, or

 * SCSI_MLQUEUE_HOST_BUSY if the entire host queue is full

 invalid device handle */

 host recovery or link resets sent via IOCTLs */

 device has been deleted */

 device busy with task management */

	/*

	 * Bug work around for firmware SATL handling.  The loop

	 * is based on atomic operations and ensures consistency

	 * since we're lockless at this point

 set tags */

 NCQ Prio supported, make sure control indicated high priority */

	/* Make sure Device is not raid volume.

	 * We do not expose raid functionality to upper layer for warpdrive.

/**

 * _scsih_normalize_sense - normalize descriptor and fixed format sense data

 * @sense_buffer: sense data returned by target

 * @data: normalized skey/asc/ascq

 descriptor format */

 fixed format */

/**

 * _scsih_scsi_ioc_info - translated non-succesfull SCSI_IO request

 * @ioc: per adapter object

 * @scmd: pointer to scsi command object

 * @mpi_reply: reply mf payload returned from firmware

 * @smid: ?

 *

 * scsi_status - SCSI Status code returned from target device

 * scsi_state - state info associated with SCSI_IO determined by ioc

 * ioc_status - ioc supplied status info

/**

 * _scsih_turn_on_pfa_led - illuminate PFA LED

 * @ioc: per adapter object

 * @handle: device handle

 * Context: process

/**

 * _scsih_turn_off_pfa_led - turn off Fault LED

 * @ioc: per adapter object

 * @sas_device: sas device whose PFA LED has to turned off

 * Context: process

/**

 * _scsih_send_event_to_turn_on_pfa_led - fire delayed event

 * @ioc: per adapter object

 * @handle: device handle

 * Context: interrupt.

/**

 * _scsih_smart_predicted_fault - process smart errors

 * @ioc: per adapter object

 * @handle: device handle

 * Context: interrupt.

 only handle non-raid devices */

 insert into event log */

/**

 * _scsih_io_done - scsi request callback

 * @ioc: per adapter object

 * @smid: system request message index

 * @msix_index: MSIX table index supplied by the OS

 * @reply: reply message frame(lower 32bit addr)

 *

 * Callback handler when using _scsih_qcmd.

 *

 * Return: 1 meaning mf should be freed from _base_interrupt

 *         0 means the mf is freed from this function.

	/*

	 * WARPDRIVE: If direct_io is set then it is directIO,

	 * the failed direct I/O should be redirected to volume

 turning off TLR */

 failure prediction threshold exceeded */

/**

 * _scsih_update_vphys_after_reset - update the Port's

 *			vphys_list after reset

 * @ioc: per adapter object

 *

 * Returns nothing.

	/*

	 * Mark all the vphys objects as dirty.

	/*

	 * Read SASIOUnitPage0 to get each HBA Phy's data.

	/*

	 * Loop over each HBA Phy.

		/*

		 * Check whether Phy's Negotiation Link Rate is > 1.5G or not.

		/*

		 * Check whether Phy is connected to SEP device or not,

		 * if it is SEP device then read the Phy's SASPHYPage0 data to

		 * determine whether Phy is a virtual Phy or not. if it is

		 * virtual phy then it is conformed that the attached remote

		 * device is a HBA's vSES device.

		/*

		 * Get the vSES device's SAS Address.

		/*

		 * Loop over each virtual_phy object from

		 * each port's vphys_list.

				/*

				 * Continue with next virtual_phy object

				 * if the object is not marked as dirty.

				/*

				 * Continue with next virtual_phy object

				 * if the object's SAS Address is not equals

				 * to current Phy's vSES device SAS Address.

				/*

				 * Enable current Phy number bit in object's

				 * phy_mask field.

				/*

				 * Get hba_port object from hba_port table

				 * corresponding to current phy's Port ID.

				 * if there is no hba_port object corresponding

				 * to Phy's Port ID then create a new hba_port

				 * object & add to hba_port table.

				/*

				 * If mport & port pointers are not pointing to

				 * same hba_port object then it means that vSES

				 * device's Port ID got changed after reset and

				 * hence move current virtual_phy object from

				 * port's vphys_list to mport's vphys_list.

				/*

				 * Earlier while updating the hba_port table,

				 * it is determined that there is no other

				 * direct attached device with mport's Port ID,

				 * Hence mport was marked as dirty. Only vSES

				 * device has this Port ID, so unmark the mport

				 * as dirt.

				/*

				 * Unmark current virtual_phy object as dirty.

/**

 * _scsih_get_port_table_after_reset - Construct temporary port table

 * @ioc: per adapter object

 * @port_table: address where port table needs to be constructed

 *

 * return number of HBA port entries available after reset.

/**

 * _scsih_look_and_get_matched_port_entry - Get matched hba port entry

 *					from HBA port table

 * @ioc: per adapter object

 * @port_entry: hba port entry from temporary port table which needs to be

 *		searched for matched entry in the HBA port table

 * @matched_port_entry: save matched hba port entry here

 * @count: count of matched entries

 *

 * return type of matched entry found.

/**

 * _scsih_del_phy_part_of_anther_port - remove phy if it

 *				is a part of anther port

 *@ioc: per adapter object

 *@port_table: port table after reset

 *@index: hba port entry index

 *@port_count: number of ports available after host reset

 *@offset: HBA phy bit offset

 *

/**

 * _scsih_add_or_del_phys_from_existing_port - add/remove phy to/from

 *						right port

 *@ioc: per adapter object

 *@hba_port_entry: hba port table entry

 *@port_table: temporary port table

 *@index: hba port entry index

 *@port_count: number of ports available after host reset

 *

/**

 * _scsih_del_dirty_vphy - delete virtual_phy objects marked as dirty.

 * @ioc: per adapter object

 *

 * Returns nothing.

/**

 * _scsih_del_dirty_port_entries - delete dirty port entries from port list

 *					after host reset

 *@ioc: per adapter object

 *

/**

 * _scsih_sas_port_refresh - Update HBA port table after host reset

 * @ioc: per adapter object

/**

 * _scsih_alloc_vphy - allocate virtual_phy object

 * @ioc: per adapter object

 * @port_id: Port ID number

 * @phy_num: HBA Phy number

 *

 * Returns allocated virtual_phy object.

		/*

		 * Enable bit corresponding to HBA phy number on its

		 * parent hba_port object's vphys_mask field.

/**

 * _scsih_sas_host_refresh - refreshing sas host object contents

 * @ioc: per adapter object

 * Context: user

 *

 * During port enable, fw will send topology events for every device. Its

 * possible that the handles may change from the previous setting, so this

 * code keeping handles updating if changed.

		/*

		 * Check whether current Phy belongs to HBA vSES device or not.

			/*

			 * Allocate a virtual_phy object for vSES device, if

			 * this vSES device is hot added.

/**

 * _scsih_sas_host_add - create sas host object

 * @ioc: per adapter object

 *

 * Creating host side data object, stored in ioc->sas_hba

 sas_iounit page 0 */

 sas_iounit page 1 */

		/*

		 * Check whether current Phy belongs to HBA vSES device or not.

			/*

			 * Allocate a virtual_phy object for vSES device.

/**

 * _scsih_expander_add -  creating expander object

 * @ioc: per adapter object

 * @handle: expander handle

 *

 * Creating expander object, stored in ioc->sas_expander_list.

 *

 * Return: 0 for success, else error.

 handle out of order topology events */

/**

 * mpt3sas_expander_remove - removing expander object

 * @ioc: per adapter object

 * @sas_address: expander sas_address

 * @port: hba port entry

/**

 * _scsih_done -  internal SCSI_IO callback handler.

 * @ioc: per adapter object

 * @smid: system request message index

 * @msix_index: MSIX table index supplied by the OS

 * @reply: reply message frame(lower 32bit addr)

 *

 * Callback handler when sending internal generated SCSI_IO.

 * The callback index passed is `ioc->scsih_cb_idx`

 *

 * Return: 1 meaning mf should be freed from _base_interrupt

 *         0 means the mf is freed from this function.

/**

 * _scsih_check_access_status - check access flags

 * @ioc: per adapter object

 * @sas_address: sas address

 * @handle: sas device handle

 * @access_status: errors returned during discovery of the device

 *

 * Return: 0 for success, else failure

/**

 * _scsih_check_device - checking device responsiveness

 * @ioc: per adapter object

 * @parent_sas_address: sas address of parent expander or sas host

 * @handle: attached device handle

 * @phy_number: phy number

 * @link_rate: new link rate

	/* wide port handling ~ we need only handle device once for the phy that

	 * is matched in sas device page zero

 check if this is end device */

 check if device is present */

 check if there were any issues with discovery */

/**

 * _scsih_add_device -  creating sas device object

 * @ioc: per adapter object

 * @handle: sas device handle

 * @phy_num: phy number end device attached to

 * @is_pd: is this hidden raid component

 *

 * Creating end device object, stored in ioc->sas_device_list.

 *

 * Return: 0 for success, non-zero for failure.

 check if this is end device */

 check if device is present */

 check if there were any issues with discovery */

 get enclosure_logical_id & chassis_slot*/

 get device name */

/**

 * _scsih_remove_device -  removing sas device object

 * @ioc: per adapter object

 * @sas_device: the sas_device object

/**

 * _scsih_sas_topology_change_event_debug - debug for topology event

 * @ioc: per adapter object

 * @event_data: event data payload

 * Context: user.

/**

 * _scsih_sas_topology_change_event - handle topology changes

 * @ioc: per adapter object

 * @fw_event: The fw_event_work object

 * Context: user.

 *

 handle expander add */

 handle siblings events */

 handle expander removal */

/**

 * _scsih_sas_device_status_change_event_debug - debug for device event

 * @ioc: ?

 * @event_data: event data payload

 * Context: user.

/**

 * _scsih_sas_device_status_change_event - handle device status change

 * @ioc: per adapter object

 * @event_data: The fw event

 * Context: user.

	/* In MPI Revision K (0xC), the internal device reset complete was

	 * implemented, so avoid setting tm_busy flag for older firmware.

/**

 * _scsih_check_pcie_access_status - check access flags

 * @ioc: per adapter object

 * @wwid: wwid

 * @handle: sas device handle

 * @access_status: errors returned during discovery of the device

 *

 * Return: 0 for success, else failure

/**

 * _scsih_pcie_device_remove_from_sml -  removing pcie device

 * from SML and free up associated memory

 * @ioc: per adapter object

 * @pcie_device: the pcie_device object

/**

 * _scsih_pcie_check_device - checking device responsiveness

 * @ioc: per adapter object

 * @handle: attached device handle

 check if this is end device */

 check if device is present */

 check if there were any issues with discovery */

/**

 * _scsih_pcie_add_device -  creating pcie device object

 * @ioc: per adapter object

 * @handle: pcie device handle

 *

 * Creating end device object, stored in ioc->pcie_device_list.

 *

 * Return: 1 means queue the event later, 0 means complete the event

 check if device is present */

 check if there were any issues with discovery */

	/* PCIe Device Page 2 contains read-only information about a

	 * specific NVMe device; therefore, this page is only

	 * valid for NVMe devices and skip for pcie devices of type scsi.

 get enclosure_logical_id */

 TODO -- Add device name once FW supports it */

		/*

		 * Set IOC's max_shutdown_latency to drive's RTD3 Entry Latency

		 * if drive's RTD3 Entry Latency is greater then IOC's

		 * max_shutdown_latency.

/**

 * _scsih_pcie_topology_change_event_debug - debug for topology

 * event

 * @ioc: per adapter object

 * @event_data: event data payload

 * Context: user.

/**

 * _scsih_pcie_topology_change_event - handle PCIe topology

 *  changes

 * @ioc: per adapter object

 * @fw_event: The fw_event_work object

 * Context: user.

 *

 handle siblings events */

			/* This code after this point handles the test case

			 * where a device has been added, however its returning

			 * BUSY for sometime.  Then before the Device Missing

			 * Delay expires and the device becomes READY, the

			 * device is removed and added back.

 mark entry vacant */

				/* TODO This needs to be reviewed and fixed,

				 * we dont have an entry

				 * to make an event void like vacant

/**

 * _scsih_pcie_device_status_change_event_debug - debug for device event

 * @ioc: ?

 * @event_data: event data payload

 * Context: user.

/**

 * _scsih_pcie_device_status_change_event - handle device status

 * change

 * @ioc: per adapter object

 * @fw_event: The fw_event_work object

 * Context: user.

/**

 * _scsih_sas_enclosure_dev_status_change_event_debug - debug for enclosure

 * event

 * @ioc: per adapter object

 * @event_data: event data payload

 * Context: user.

/**

 * _scsih_sas_enclosure_dev_status_change_event - handle enclosure events

 * @ioc: per adapter object

 * @fw_event: The fw_event_work object

 * Context: user.

/**

 * _scsih_sas_broadcast_primitive_event - handle broadcast events

 * @ioc: per adapter object

 * @fw_event: The fw_event_work object

 * Context: user.

 sanity checks for retrying this loop */

 skip hidden raid components */

 skip volumes */

 skip PCIe devices */

 see if IO is still owned by IOC and target */

/**

 * _scsih_sas_discovery_event - handle discovery events

 * @ioc: per adapter object

 * @fw_event: The fw_event_work object

 * Context: user.

 Wait for the reset to complete */

/**

 * _scsih_sas_device_discovery_error_event - display SAS device discovery error

 *						events

 * @ioc: per adapter object

 * @fw_event: The fw_event_work object

 * Context: user.

/**

 * _scsih_pcie_enumeration_event - handle enumeration events

 * @ioc: per adapter object

 * @fw_event: The fw_event_work object

 * Context: user.

/**

 * _scsih_ir_fastpath - turn on fastpath for IR physdisk

 * @ioc: per adapter object

 * @handle: device handle for physical disk

 * @phys_disk_num: physical disk number

 *

 * Return: 0 for success, else failure.

/**

 * _scsih_reprobe_lun - reprobing lun

 * @sdev: scsi device struct

 * @no_uld_attach: sdev->no_uld_attach flag setting

 *

/**

 * _scsih_sas_volume_add - add new volume

 * @ioc: per adapter object

 * @element: IR config element data

 * Context: user.

/**

 * _scsih_sas_volume_delete - delete volume

 * @ioc: per adapter object

 * @handle: volume device handle

 * Context: user.

/**

 * _scsih_sas_pd_expose - expose pd component to /dev/sdX

 * @ioc: per adapter object

 * @element: IR config element data

 * Context: user.

 exposing raid component */

/**

 * _scsih_sas_pd_hide - hide pd component from /dev/sdX

 * @ioc: per adapter object

 * @element: IR config element data

 * Context: user.

 hiding raid component */

/**

 * _scsih_sas_pd_delete - delete pd component

 * @ioc: per adapter object

 * @element: IR config element data

 * Context: user.

/**

 * _scsih_sas_pd_add - remove pd component

 * @ioc: per adapter object

 * @element: IR config element data

 * Context: user.

/**

 * _scsih_sas_ir_config_change_event_debug - debug for IR Config Change events

 * @ioc: per adapter object

 * @event_data: event data payload

 * Context: user.

/**

 * _scsih_sas_ir_config_change_event - handle ir configuration change events

 * @ioc: per adapter object

 * @fw_event: The fw_event_work object

 * Context: user.

/**

 * _scsih_sas_ir_volume_event - IR volume event

 * @ioc: per adapter object

 * @fw_event: The fw_event_work object

 * Context: user.

/**

 * _scsih_sas_ir_physical_disk_event - PD event

 * @ioc: per adapter object

 * @fw_event: The fw_event_work object

 * Context: user.

/**

 * _scsih_sas_ir_operation_status_event_debug - debug for IR op event

 * @ioc: per adapter object

 * @event_data: event data payload

 * Context: user.

/**

 * _scsih_sas_ir_operation_status_event - handle RAID operation events

 * @ioc: per adapter object

 * @fw_event: The fw_event_work object

 * Context: user.

 code added for raid transport support */

/**

 * _scsih_prep_device_scan - initialize parameters prior to device scan

 * @ioc: per adapter object

 *

 * Set the deleted flag prior to device scan.  If the device is found during

 * the scan, then we clear the deleted flag.

/**

 * _scsih_update_device_qdepth - Update QD during Reset.

 * @ioc: per adapter object

 *

/**

 * _scsih_mark_responding_sas_device - mark a sas_devices as responding

 * @ioc: per adapter object

 * @sas_device_pg0: SAS Device page 0

 *

 * After host reset, find out whether devices are still responding.

 * Used in _scsih_remove_unresponsive_sas_devices.

/**

 * _scsih_create_enclosure_list_after_reset - Free Existing list,

 *	And create enclosure list by scanning all Enclosure Page(0)s

 * @ioc: per adapter object

 Free existing enclosure list */

 Re constructing enclosure list after reset*/

/**

 * _scsih_search_responding_sas_devices -

 * @ioc: per adapter object

 *

 * After host reset, find out whether devices are still responding.

 * If not remove.

/**

 * _scsih_mark_responding_pcie_device - mark a pcie_device as responding

 * @ioc: per adapter object

 * @pcie_device_pg0: PCIe Device page 0

 *

 * After host reset, find out whether devices are still responding.

 * Used in _scsih_remove_unresponding_devices.

/**

 * _scsih_search_responding_pcie_devices -

 * @ioc: per adapter object

 *

 * After host reset, find out whether devices are still responding.

 * If not remove.

/**

 * _scsih_mark_responding_raid_device - mark a raid_device as responding

 * @ioc: per adapter object

 * @wwid: world wide identifier for raid volume

 * @handle: device handle

 *

 * After host reset, find out whether devices are still responding.

 * Used in _scsih_remove_unresponsive_raid_devices.

			/*

			 * WARPDRIVE: The handles of the PDs might have changed

			 * across the host reset so re-initialize the

			 * required data for Direct IO

/**

 * _scsih_search_responding_raid_devices -

 * @ioc: per adapter object

 *

 * After host reset, find out whether devices are still responding.

 * If not remove.

 refresh the pd_handles */

/**

 * _scsih_mark_responding_expander - mark a expander as responding

 * @ioc: per adapter object

 * @expander_pg0:SAS Expander Config Page0

 *

 * After host reset, find out whether devices are still responding.

 * Used in _scsih_remove_unresponsive_expanders.

/**

 * _scsih_search_responding_expanders -

 * @ioc: per adapter object

 *

 * After host reset, find out whether devices are still responding.

 * If not remove.

/**

 * _scsih_remove_unresponding_devices - removing unresponding devices

 * @ioc: per adapter object

 removing unresponding end devices */

	/*

	 * Iterate, pulling off devices marked as non-responding. We become the

	 * owner for the reference the list had on any object we prune.

	/*

	 * Clean up the sas_device_init_list list as

	 * driver goes for fresh scan as part of diag reset.

	/*

	 * Now, uninitialize and remove the unresponding devices we pruned.

	/*

	 * Clean up the pcie_device_init_list list as

	 * driver goes for fresh scan as part of diag reset.

 removing unresponding volumes */

 removing unresponding expanders */

 unblock devices */

/**

 * _scsih_scan_for_devices_after_reset - scan for devices after host reset

 * @ioc: per adapter object

 expanders */

 phys disk */

			/* This will retry adding the end device.

			 * _scsih_add_device() will decide on retries and

			 * return "1" when it should be retried

 volumes */

 sas devices */

			/* This will retry adding the end device.

			 * _scsih_add_device() will decide on retries and

			 * return "1" when it should be retried

 pcie devices */

/**

 * mpt3sas_scsih_pre_reset_handler - reset callback handler (for scsih)

 * @ioc: per adapter object

 *

 * The handler for doing any required cleanup or initialization.

/**

 * mpt3sas_scsih_clear_outstanding_scsi_tm_commands - clears outstanding

 *							scsi & tm cmds.

 * @ioc: per adapter object

 *

 * The handler for doing any required cleanup or initialization.

/**

 * mpt3sas_scsih_reset_done_handler - reset callback handler (for scsih)

 * @ioc: per adapter object

 *

 * The handler for doing any required cleanup or initialization.

/**

 * _mpt3sas_fw_work - delayed task for processing firmware events

 * @ioc: per adapter object

 * @fw_event: The fw_event_work object

 * Context: user.

 the queue is being flushed so ignore this event */

			/*

			 * If we're unloading or cancelling the work, bail.

			 * Otherwise, this can become an infinite loop.

		/*

		 * If diag reset has occurred during the driver load

		 * then driver has to complete the driver load operation

		 * by executing the following items:

		 *- Register the devices from sas_device_init_list to SML

		 *- clear is_driver_loading flag,

		 *- start the watchdog thread.

		 * In happy driver load path, above things are taken care of when

		 * driver executes scsih_scan_finished().

/**

 * _firmware_event_work

 * @work: The fw_event_work object

 * Context: user.

 *

 * wrappers for the work thread handling firmware events

/**

 * mpt3sas_scsih_event_callback - firmware event handler (called at ISR time)

 * @ioc: per adapter object

 * @msix_index: MSIX table index supplied by the OS

 * @reply: reply message frame(lower 32bit addr)

 * Context: interrupt.

 *

 * This function merely adds a new work task into ioc->firmware_event_thread.

 * The tasks are worked from _firmware_event_work in user context.

 *

 * Return: 1 meaning mf should be freed from _base_interrupt

 *         0 means the mf is freed from this function.

 events turned off due to host reset */

 handle these */

		/*

		 * No need to add the topology change list

		 * event to fw event work queue when

		 * diag reset is going on. Since during diag

		 * reset driver scan the devices by reading

		 * sas device page0's not by processing the

		 * events.

 ignore the rest */

/**

 * _scsih_expander_node_remove - removing expander device from list.

 * @ioc: per adapter object

 * @sas_expander: the sas_device object

 *

 * Removing object and freeing associated memory from the

 * ioc->sas_expander_list.

 remove sibling ports attached to this expander */

/**

 * _scsih_nvme_shutdown - NVMe shutdown notification

 * @ioc: per adapter object

 *

 * Sending IoUnitControl request with shutdown operation code to alert IOC that

 * the host system is shutting down so that IOC can issue NVMe shutdown to

 * NVMe drives attached to it.

 are there any NVMe devices ? */

 Wait for max_shutdown_latency seconds */

/**

 * _scsih_ir_shutdown - IR shutdown notification

 * @ioc: per adapter object

 *

 * Sending RAID Action to alert the Integrated RAID subsystem of the IOC that

 * the host system is shutting down.

 is IR firmware build loaded ? */

 are there any volumes ? */

/**

 * _scsih_get_shost_and_ioc - get shost and ioc

 *			and verify whether they are NULL or not

 * @pdev: PCI device struct

 * @shost: address of scsi host pointer

 * @ioc: address of HBA adapter pointer

 *

 * Return zero if *shost and *ioc are not NULL otherwise return error number.

/**

 * scsih_remove - detach and remove add host

 * @pdev: PCI device struct

 *

 * Routine called when unloading the driver.

	/*

	 * Copy back the unmodified ioc page1. so that on next driver load,

	 * current modified changes on ioc page1 won't take effect.

 release all the volumes */

 free ports attached to the sas_host */

 free phys attached to the sas_host */

/**

 * scsih_shutdown - routine call during system shutdown

 * @pdev: PCI device struct

	/*

	 * Copy back the unmodified ioc page1 so that on next driver load,

	 * current modified changes on ioc page1 won't take effect.

/**

 * _scsih_probe_boot_devices - reports 1st device

 * @ioc: per adapter object

 *

 * If specified in bios page 2, this routine reports the 1st

 * device scsi-ml or sas transport for persistent boot device

 * purposes.  Please refer to function _scsih_determine_boot_device()

 no Bios, return immediately */

		/*

		 * If this boot vd is already registered with SML then

		 * no need to register it again as part of device scanning

		 * after diag reset during driver load operation.

		/*

		 * If this boot NVMe device is already registered with SML then

		 * no need to register it again as part of device scanning

		 * after diag reset during driver load operation.

		/*

		 * If this boot sas/sata device is already registered with SML

		 * then no need to register it again as part of device scanning

		 * after diag reset during driver load operation.

/**

 * _scsih_probe_raid - reporting raid volumes to scsi-ml

 * @ioc: per adapter object

 *

 * Called during initial loading of the driver.

	/*

	 * Since we dropped the lock during the call to port_add(), we need to

	 * be careful here that somebody else didn't move or delete this item

	 * while we were busy with other things.

	 *

	 * If it was on the list, we need a put() for the reference the list

	 * had. Either way, we need a get() for the destination list.

/**

 * _scsih_probe_sas - reporting sas devices to sas transport

 * @ioc: per adapter object

 *

 * Called during initial loading of the driver.

			/*

			 * When asyn scanning is enabled, its not possible to

			 * remove devices while scanning is turned on due to an

			 * oops in scsi_sysfs_add_sdev()->add_device()->

			 * sysfs_addrm_start()

/**

 * get_next_pcie_device - Get the next pcie device

 * @ioc: per adapter object

 *

 * Get the next pcie device from pcie_device_init_list list.

 *

 * Return: pcie device structure if pcie_device_init_list list is not empty

 * otherwise returns NULL

/**

 * pcie_device_make_active - Add pcie device to pcie_device_list list

 * @ioc: per adapter object

 * @pcie_device: pcie device object

 *

 * Add the pcie device which has registered with SCSI Transport Later to

 * pcie_device_list list

/**

 * _scsih_probe_pcie - reporting PCIe devices to scsi-ml

 * @ioc: per adapter object

 *

 * Called during initial loading of the driver.

 PCIe Device List */

			/*

			 * When async scanning is enabled, its not possible to

			 * remove devices while scanning is turned on due to an

			 * oops in scsi_sysfs_add_sdev()->add_device()->

			 * sysfs_addrm_start()

			/* TODO-- Need to find out whether this condition will

			 * occur or not

/**

 * _scsih_probe_devices - probing for devices

 * @ioc: per adapter object

 *

 * Called during initial loading of the driver.

 return when IOC doesn't support initiator mode */

/**

 * scsih_scan_start - scsi lld callback for .scan_start

 * @shost: SCSI host pointer

 *

 * The shost has the ability to discover targets on its own instead

 * of scanning the entire bus.  In our implemention, we will kick off

 * firmware discovery.

/**

 * _scsih_complete_devices_scanning - add the devices to sml and

 * complete ioc initialization.

 * @ioc: per adapter object

 *

 * Return nothing.

/**

 * scsih_scan_finished - scsi lld callback for .scan_finished

 * @shost: SCSI host pointer

 * @time: elapsed time of the scan in jiffies

 *

 * This function will be called periodicallyn until it returns 1 with the

 * scsi_host and the elapsed time of the scan in jiffies. In our implemention,

 * we wait for firmware discovery to complete, then return 1.

/**

 * scsih_map_queues - map reply queues with request queues

 * @shost: SCSI host pointer

		/*

		 * The poll queue(s) doesn't have an IRQ (and hence IRQ

		 * affinity), so use the regular blk-mq cpu mapping

 shost template for SAS 2.0 HBA devices */

 raid transport support for SAS 2.0 HBA devices */

 shost template for SAS 3.0 HBA devices */

 raid transport support for SAS 3.0 HBA devices */

/**

 * _scsih_determine_hba_mpi_version - determine in which MPI version class

 *					this device belongs to.

 * @pdev: PCI device struct

 *

 * return MPI2_VERSION for SAS 2.0 HBA devices,

 *	MPI25_VERSION for SAS 3.0 HBA devices, and

 *	MPI26 VERSION for Cutlass & Invader SAS 3.0 HBA devices

/**

 * _scsih_probe - attach and add scsi host

 * @pdev: PCI device struct

 * @id: pci device id

 *

 * Return: 0 success, anything else error.

 Determine in which MPI version class this pci device belongs */

	/* Enumerate only SAS 2.0 HBA's if hbas_to_enumerate is one,

	 * for other generation HBA's return with -ENODEV

	/* Enumerate only SAS 3.0 HBA's if hbas_to_enumerate is two,

	 * for other generation HBA's return with -ENODEV

 Use mpt2sas driver host template for SAS 2.0 HBA's */

 Use mpt3sas driver host template for SAS 3.0 HBA's */

 Host waits for minimum of six seconds */

	/*

	 * Enable MEMORY MOVE support flag.

 Enable ADDITIONAL QUERY support flag. */

 misc semaphores and spin locks */

 initializing pci_access_mutex lock */

 init shost parameters */

 mCPU MPI support 64K max IO */

 register EEDP capabilities with SCSI layer */

 event thread */

/**

 * scsih_suspend - power management suspend main entry point

 * @dev: Device struct

 *

 * Return: 0 success, anything else error.

/**

 * scsih_resume - power management resume main entry point

 * @dev: Device struct

 *

 * Return: 0 success, anything else error.

/**

 * scsih_pci_error_detected - Called when a PCI error is detected.

 * @pdev: PCI device struct

 * @state: PCI channel state

 *

 * Description: Called when a PCI error is detected.

 *

 * Return: PCI_ERS_RESULT_NEED_RESET or PCI_ERS_RESULT_DISCONNECT.

 Fatal error, prepare for slot reset */

 Permanent error, prepare for device removal */

/**

 * scsih_pci_slot_reset - Called when PCI slot has been reset.

 * @pdev: PCI device struct

 *

 * Description: This routine is called by the pci error recovery

 * code after the PCI slot has been reset, just before we

 * should resume normal operations.

/**

 * scsih_pci_resume() - resume normal ops after PCI reset

 * @pdev: pointer to PCI device

 *

 * Called when the error recovery driver tells us that its

 * OK to resume normal operation. Use completion to allow

 * halted scsi ops to resume.

/**

 * scsih_pci_mmio_enabled - Enable MMIO and dump debug registers

 * @pdev: pointer to PCI device

 TODO - dump whatever for debugging purposes */

	/* This called only if scsih_pci_error_detected returns

	 * PCI_ERS_RESULT_CAN_RECOVER. Read/write to the device still

	 * works, no need to reset slot.

/**

 * scsih_ncq_prio_supp - Check for NCQ command priority support

 * @sdev: scsi device struct

 *

 * This is called when a user indicates they would like to enable

 * ncq command priorities. This works only on SATA devices.

/*

 * The pci device ids are defined in mpi/mpi2_cnfg.h.

 Spitfire ~ 2004 */

 Falcon ~ 2008 */

 Liberator ~ 2108 */

 Meteor ~ 2116 */

 Thunderbolt ~ 2208 */

 Mustang ~ 2308 */

 SSS6200 */

 Fury ~ 3004 and 3008 */

 Invader ~ 3108 */

 Cutlass ~ 3216 and 3224 */

 Intruder ~ 3316 and 3324 */

 Ventura, Crusader, Harpoon & Tomcat ~ 3516, 3416, 3508 & 3408*/

 Mercator ~ 3616*/

	/* Aero SI 0x00E1 Configurable Secure

	 * 0x00E2 Hard Secure

	/*

	 *  Aero SI –> 0x00E0 Invalid, 0x00E3 Tampered

 Atlas PCIe Switch Management Port */

	/* Sea SI 0x00E5 Configurable Secure

	 * 0x00E6 Hard Secure

	/*

	 *  Sea SI –> 0x00E4 Invalid, 0x00E7 Tampered

 Terminating entry */

/**

 * scsih_init - main entry point for this driver.

 *

 * Return: 0 success, anything else error.

 queuecommand callback hander */

 task management callback handler */

 base internal commands callback handler */

 transport internal commands callback handler */

 scsih internal commands callback handler */

 configuration page API internal commands callback handler */

 ctl module callback handler */

/**

 * scsih_exit - exit point for this driver (when it is a module).

 *

 * Return: 0 success, anything else error.

 raid transport support */

/**

 * _mpt3sas_init - main entry point for this driver.

 *

 * Return: 0 success, anything else error.

	/* No need attach mpt3sas raid functions template

	 * if hbas_to_enumarate value is one.

	/* No need to attach mpt2sas raid functions template

	 * if hbas_to_enumarate value is two

/**

 * _mpt3sas_exit - exit point for this driver (when it is a module).

 *

 SPDX-License-Identifier: GPL-2.0

/*

 * Debugfs interface Support for MPT (Message Passing Technology) based

 * controllers.

 *

 * Copyright (C) 2020  Broadcom Inc.

 *

 * Authors: Broadcom Inc.

 * Sreekanth Reddy  <sreekanth.reddy@broadcom.com>

 * Suganath Prabu <suganath-prabu.subramani@broadcom.com>

 *

 * Send feedback to : MPT-FusionLinux.pdl@broadcom.com)

 *

/*

 * _debugfs_iocdump_read - copy ioc dump from debugfs buffer

 * @filep:	File Pointer

 * @ubuf:	Buffer to fill data

 * @cnt:	Length of the buffer

 * @ppos:	Offset in the file

/*

 * _debugfs_iocdump_open :	open the ioc_dump debugfs attribute file

/*

 * _debugfs_iocdump_release :	release the ioc_dump debugfs attribute

 * @inode: inode structure to the corresponds device

 * @file: File pointer

/*

 * mpt3sas_init_debugfs :	Create debugfs root for mpt3sas driver

/*

 * mpt3sas_exit_debugfs :	Remove debugfs root for mpt3sas driver

/*

 * mpt3sas_setup_debugfs :	Setup debugfs per HBA adapter

 * ioc:				MPT3SAS_ADAPTER object

/*

 * mpt3sas_destroy_debugfs :	Destroy debugfs per HBA adapter

 * @ioc:	MPT3SAS_ADAPTER object

/*

 * This module provides common API for accessing firmware configuration pages

 *

 * This code is based on drivers/scsi/mpt3sas/mpt3sas_base.c

 * Copyright (C) 2012-2014  LSI Corporation

 * Copyright (C) 2013-2014 Avago Technologies

 *  (mailto: MPT-FusionLinux.pdl@avagotech.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License

 * as published by the Free Software Foundation; either version 2

 * of the License, or (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * NO WARRANTY

 * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 * solely responsible for determining the appropriateness of using and

 * distributing the Program and assumes all risks associated with its

 * exercise of rights under this Agreement, including but not limited to

 * the risks and costs of program errors, damage to or loss of data,

 * programs or equipment, and unavailability or interruption of operations.



 * DISCLAIMER OF LIABILITY

 * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write to the Free Software

 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,

 * USA.

 local definitions */

 Timeout for config page request (in seconds) */

 Common sgl flags for READING a config page. */

 Common sgl flags for WRITING a config page. */

/**

 * struct config_request - obtain dma memory via routine

 * @sz: size

 * @page: virt pointer

 * @page_dma: phys pointer

 *

/**

 * _config_display_some_debug - debug routine

 * @ioc: per adapter object

 * @smid: system request message index

 * @calling_function_name: string pass from calling function

 * @mpi_reply: reply message frame

 * Context: none.

 *

 * Function for displaying debug info helpful when debugging issues

 * in this module.

/**

 * _config_alloc_config_dma_memory - obtain physical memory

 * @ioc: per adapter object

 * @mem: struct config_request

 *

 * A wrapper for obtaining dma-able memory for config page request.

 *

 * Return: 0 for success, non-zero for failure.

 use tmp buffer if less than 512 bytes */

/**

 * _config_free_config_dma_memory - wrapper to free the memory

 * @ioc: per adapter object

 * @mem: struct config_request

 *

 * A wrapper to free dma-able memory when using _config_alloc_config_dma_memory.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_done - config page completion routine

 * @ioc: per adapter object

 * @smid: system request message index

 * @msix_index: MSIX table index supplied by the OS

 * @reply: reply message frame(lower 32bit addr)

 * Context: none.

 *

 * The callback handler when using _config_request.

 *

 * Return: 1 meaning mf should be freed from _base_interrupt

 *         0 means the mf is freed from this function.

/**

 * _config_request - main routine for sending config page requests

 * @ioc: per adapter object

 * @mpi_request: request message frame

 * @mpi_reply: reply mf payload returned from firmware

 * @timeout: timeout in seconds

 * @config_page: contents of the config page

 * @config_page_sz: size of config page

 * Context: sleep

 *

 * A generic API for config page requests to firmware.

 *

 * The ioc->config_cmds.status flag should be MPT3_CMD_NOT_USED before calling

 * this API.

 *

 * The callback index is set inside `ioc->config_cb_idx.

 *

 * Return: 0 for success, non-zero for failure.

 TODO */

 attempt only 2 retries */

 Reply Frame Sanity Checks to workaround FW issues */

 Config Page Sanity Checks to workaround FW issues */

/**

 * mpt3sas_config_get_manufacturing_pg0 - obtain manufacturing page 0

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_manufacturing_pg7 - obtain manufacturing page 7

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @sz: size of buffer passed in config_page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_manufacturing_pg10 - obtain manufacturing page 10

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_manufacturing_pg11 - obtain manufacturing page 11

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_set_manufacturing_pg11 - set manufacturing page 11

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_bios_pg2 - obtain bios page 2

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_bios_pg3 - obtain bios page 3

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_iounit_pg0 - obtain iounit page 0

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_iounit_pg1 - obtain iounit page 1

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_set_iounit_pg1 - set iounit page 1

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_iounit_pg3 - obtain iounit page 3

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @sz: size of buffer passed in config_page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_iounit_pg8 - obtain iounit page 8

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_ioc_pg8 - obtain ioc page 8

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_ioc_pg1 - obtain ioc page 1

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_set_ioc_pg1 - modify ioc page 1

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_sas_device_pg0 - obtain sas device page 0

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @form: GET_NEXT_HANDLE or HANDLE

 * @handle: device handle

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_sas_device_pg1 - obtain sas device page 1

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @form: GET_NEXT_HANDLE or HANDLE

 * @handle: device handle

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_pcie_device_pg0 - obtain pcie device page 0

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @form: GET_NEXT_HANDLE or HANDLE

 * @handle: device handle

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_pcie_iounit_pg1 - obtain pcie iounit page 1

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @sz: size of buffer passed in config_page

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_pcie_device_pg2 - obtain pcie device page 2

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @form: GET_NEXT_HANDLE or HANDLE

 * @handle: device handle

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_number_hba_phys - obtain number of phys on the host

 * @ioc: per adapter object

 * @num_phys: pointer returned with the number of phys

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_sas_iounit_pg0 - obtain sas iounit page 0

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @sz: size of buffer passed in config_page

 * Context: sleep.

 *

 * Calling function should call config_get_number_hba_phys prior to

 * this function, so enough memory is allocated for config_page.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_sas_iounit_pg1 - obtain sas iounit page 1

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @sz: size of buffer passed in config_page

 * Context: sleep.

 *

 * Calling function should call config_get_number_hba_phys prior to

 * this function, so enough memory is allocated for config_page.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_set_sas_iounit_pg1 - send sas iounit page 1

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @sz: size of buffer passed in config_page

 * Context: sleep.

 *

 * Calling function should call config_get_number_hba_phys prior to

 * this function, so enough memory is allocated for config_page.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_expander_pg0 - obtain expander page 0

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @form: GET_NEXT_HANDLE or HANDLE

 * @handle: expander handle

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_expander_pg1 - obtain expander page 1

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @phy_number: phy number

 * @handle: expander handle

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_enclosure_pg0 - obtain enclosure page 0

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @form: GET_NEXT_HANDLE or HANDLE

 * @handle: expander handle

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_phy_pg0 - obtain phy page 0

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @phy_number: phy number

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_phy_pg1 - obtain phy page 1

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @phy_number: phy number

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_raid_volume_pg1 - obtain raid volume page 1

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @form: GET_NEXT_HANDLE or HANDLE

 * @handle: volume handle

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_number_pds - obtain number of phys disk assigned to volume

 * @ioc: per adapter object

 * @handle: volume handle

 * @num_pds: returns pds count

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_raid_volume_pg0 - obtain raid volume page 0

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @form: GET_NEXT_HANDLE or HANDLE

 * @handle: volume handle

 * @sz: size of buffer passed in config_page

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_phys_disk_pg0 - obtain phys disk page 0

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * @form: GET_NEXT_PHYSDISKNUM, PHYSDISKNUM, DEVHANDLE

 * @form_specific: specific to the form

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_driver_trigger_pg0 - obtain driver trigger page 0

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * _config_set_driver_trigger_pg0 - write driver trigger page 0

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * mpt3sas_config_update_driver_trigger_pg0 - update driver trigger page 0

 * @ioc: per adapter object

 * @trigger_flag: trigger type bit map

 * @set: set ot clear trigger values

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_driver_trigger_pg1 - obtain driver trigger page 1

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * _config_set_driver_trigger_pg1 - write driver trigger page 1

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * mpt3sas_config_update_driver_trigger_pg1 - update driver trigger page 1

 * @ioc: per adapter object

 * @master_tg: Master trigger bit map

 * @set: set ot clear trigger values

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_driver_trigger_pg2 - obtain driver trigger page 2

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * _config_set_driver_trigger_pg2 - write driver trigger page 2

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * mpt3sas_config_update_driver_trigger_pg2 - update driver trigger page 2

 * @ioc: per adapter object

 * @event_tg: list of Event Triggers

 * @set: set ot clear trigger values

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_driver_trigger_pg3 - obtain driver trigger page 3

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * _config_set_driver_trigger_pg3 - write driver trigger page 3

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * mpt3sas_config_update_driver_trigger_pg3 - update driver trigger page 3

 * @ioc: per adapter object

 * @scsi_tg: scsi trigger list

 * @set: set ot clear trigger values

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_driver_trigger_pg4 - obtain driver trigger page 4

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * _config_set_driver_trigger_pg4 - write driver trigger page 4

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @config_page: contents of the config page

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * mpt3sas_config_update_driver_trigger_pg4 - update driver trigger page 4

 * @ioc: per adapter object

 * @mpi_tg: mpi trigger list

 * @set: set ot clear trigger values

 * Context: sleep.

 *

 * Returns 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_volume_handle - returns volume handle for give hidden

 * raid components

 * @ioc: per adapter object

 * @pd_handle: phys disk handle

 * @volume_handle: volume handle

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_config_get_volume_wwid - returns wwid given the volume handle

 * @ioc: per adapter object

 * @volume_handle: volume handle

 * @wwid: volume wwid

 * Context: sleep.

 *

 * Return: 0 for success, non-zero for failure.

/*

 * This is the Fusion MPT base driver providing common API layer interface

 * for access to MPT (Message Passing Technology) firmware.

 *

 * This code is based on drivers/scsi/mpt3sas/mpt3sas_base.c

 * Copyright (C) 2012-2014  LSI Corporation

 * Copyright (C) 2013-2014 Avago Technologies

 *  (mailto: MPT-FusionLinux.pdl@avagotech.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License

 * as published by the Free Software Foundation; either version 2

 * of the License, or (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * NO WARRANTY

 * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 * solely responsible for determining the appropriateness of using and

 * distributing the Program and assumes all risks associated with its

 * exercise of rights under this Agreement, including but not limited to

 * the risks and costs of program errors, damage to or loss of data,

 * programs or equipment, and unavailability or interruption of operations.



 * DISCLAIMER OF LIABILITY

 * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write to the Free Software

 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,

 * USA.

 To get host page size per arch */

 in milliseconds */

 maximum controller queue depth */

/**

 * mpt3sas_base_check_cmd_timeout - Function

 *		to check timeout and command termination due

 *		to Host reset.

 *

 * @ioc:	per adapter object.

 * @status:	Status of issued command.

 * @mpi_request:mf request pointer.

 * @sz:		size of buffer.

 *

 * Return: 1/0 Reset to be done or Not

/**

 * _scsih_set_fwfault_debug - global setting of ioc->fwfault_debug.

 * @val: ?

 * @kp: ?

 *

 * Return: ?

 global ioc spinlock to protect controller list on list operations */

/**

 * _base_readl_aero - retry readl for max three times.

 * @addr: MPT Fusion system interface register address

 *

 * Retry the readl() for max three times if it gets zero value

 * while reading the system interface register.

/**

 * _base_clone_reply_to_sys_mem - copies reply to reply free iomem

 *				  in BAR0 space.

 *

 * @ioc: per adapter object

 * @reply: reply message frame(lower 32bit addr)

 * @index: System request message index.

	/*

	 * 256 is offset within sys register.

	 * 256 offset MPI frame starts. Max MPI frame supported is 32.

	 * 32 * 128 = 4K. From here, Clone of reply free for mcpu starts

/**

 * _base_clone_mpi_to_sys_mem - Writes/copies MPI frames

 *				to system/BAR0 region.

 *

 * @dst_iomem: Pointer to the destination location in BAR0 space.

 * @src: Pointer to the Source data.

 * @size: Size of data to be copied.

/**

 * _base_clone_to_sys_mem - Writes/copies data to system/BAR0 region

 *

 * @dst_iomem: Pointer to the destination location in BAR0 space.

 * @src: Pointer to the Source data.

 * @size: Size of data to be copied.

/**

 * _base_get_chain - Calculates and Returns virtual chain address

 *			 for the provided smid in BAR0 space.

 *

 * @ioc: per adapter object

 * @smid: system request message index

 * @sge_chain_count: Scatter gather chain count.

 *

 * Return: the chain address.

/**

 * _base_get_chain_phys - Calculates and Returns physical address

 *			in BAR0 for scatter gather chains, for

 *			the provided smid.

 *

 * @ioc: per adapter object

 * @smid: system request message index

 * @sge_chain_count: Scatter gather chain count.

 *

 * Return: Physical chain address.

/**

 * _base_get_buffer_bar0 - Calculates and Returns BAR0 mapped Host

 *			buffer address for the provided smid.

 *			(Each smid can have 64K starts from 17024)

 *

 * @ioc: per adapter object

 * @smid: system request message index

 *

 * Return: Pointer to buffer location in BAR0.

 Added extra 1 to reach end of chain.

/**

 * _base_get_buffer_phys_bar0 - Calculates and Returns BAR0 mapped

 *		Host buffer Physical address for the provided smid.

 *		(Each smid can have 64K starts from 17024)

 *

 * @ioc: per adapter object

 * @smid: system request message index

 *

 * Return: Pointer to buffer location in BAR0.

/**

 * _base_get_chain_buffer_dma_to_chain_buffer - Iterates chain

 *			lookup list and Provides chain_buffer

 *			address for the matching dma address.

 *			(Each smid can have 64K starts from 17024)

 *

 * @ioc: per adapter object

 * @chain_buffer_dma: Chain buffer dma address.

 *

 * Return: Pointer to chain buffer. Or Null on Failure.

/**

 * _clone_sg_entries -	MPI EP's scsiio and config requests

 *			are handled here. Base function for

 *			double buffering, before submitting

 *			the requests.

 *

 * @ioc: per adapter object.

 * @mpi_request: mf request pointer.

 * @smid: system request message index.

	/* From smid we can get scsi_cmd, once we have sg_scmd,

	 * we just need to get sg_virt and sg_next to get virtual

	 * address associated with sgel->Address.

 Get scsi_cmd using smid */

 Get sg_scmd from scmd provided */

	/*

	 * 0 - 255	System register

	 * 256 - 4352	MPI Frame. (This is based on maxCredit 32)

	 * 4352 - 4864	Reply_free pool (512 byte is reserved

	 *		considering maxCredit 32. Reply need extra

	 *		room, for mCPU case kept four times of

	 *		maxCredit).

	 * 4864 - 17152	SGE chain element. (32cmd * 3 chain of

	 *		128 byte size = 12288)

	 * 17152 - x	Host buffer mapped with smid.

	 *		(Each smid can have 64K Max IO.)

	 * BAR0+Last 1K MSIX Addr and Data

	 * Total size in use 2113664 bytes of 4MB BAR0

			/*

			 * Helper function which on passing

			 * chain_buffer_dma returns chain_buffer. Get

			 * the virtual address for sgel->Address

			/*

			 * This is coping 128 byte chain

			 * frame (not a host buffer)

					/*

					 * FIXME: this relies on a a zero

					 * PCI mem_offset.

				/*

				 * Every single element in MPT will have

				 * associated sg_next. Better to sanity that

				 * sg_next is not NULL, but it will be a bug

				 * if it is null.

/**

 *  mpt3sas_remove_dead_ioc_func - kthread context to remove dead ioc

 * @arg: input argument, used to derive ioc

 *

 * Return:

 * 0 if controller is removed from pci subsystem.

 * -1 for other case.

/**

 * _base_sync_drv_fw_timestamp - Sync Drive-Fw TimeStamp.

 * @ioc: Per Adapter Object

 *

 * Return: nothing.

/**

 * _base_fault_reset_work - workq handling ioc fault conditions

 * @work: input argument, used to derive ioc

 *

 * Context: sleep.

		/* It may be possible that EEH recovery can resolve some of

		 * pci bus failure issues rather removing the dead ioc function

		 * by considering controller is in a non-operational state. So

		 * here priority is given to the EEH recovery. If it doesn't

		 * not resolve this issue, mpt3sas driver will consider this

		 * controller to non-operational state and remove the dead ioc

		 * function.

		/*

		 * Call _scsih_flush_pending_cmds callback so that we flush all

		 * pending commands back to OS. This call is required to avoid

		 * deadlock at block layer. Dead IOC will fail to do diag reset,

		 * and this call is safe since dead ioc will never return any

		 * command back from HW.

		/*

		 * Set remove_host flag early since kernel thread will

		 * take some time to execute.

Remove the Dead Host */

 don't rearm timer */

 do not accept any IOs and disable the interrupts */

 Wait until CoreDump completes or times out */

 don't rearm timer */

/**

 * mpt3sas_base_start_watchdog - start the fault_reset_work_q

 * @ioc: per adapter object

 *

 * Context: sleep.

 initialize fault polling */

/**

 * mpt3sas_base_stop_watchdog - stop the fault_reset_work_q

 * @ioc: per adapter object

 *

 * Context: sleep.

/**

 * mpt3sas_base_fault_info - verbose translation of firmware FAULT code

 * @ioc: per adapter object

 * @fault_code: fault code

/**

 * mpt3sas_base_coredump_info - verbose translation of firmware CoreDump state

 * @ioc: per adapter object

 * @fault_code: fault code

 *

 * Return: nothing.

/**

 * mpt3sas_base_wait_for_coredump_completion - Wait until coredump

 * completes or times out

 * @ioc: per adapter object

 * @caller: caller function name

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_halt_firmware - halt's mpt controller firmware

 * @ioc: per adapter object

 *

 * For debugging timeout related issues.  Writing 0xCOFFEE00

 * to the doorbell register will halt controller firmware. With

 * the purpose to stop both driver and firmware, the enduser can

 * obtain a ring buffer from controller UART.

/**

 * _base_sas_ioc_info - verbose translation of the ioc status

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

 * @request_hdr: request mf

 SCSI_IO, RAID_PASS are handled from _scsih_scsi_ioc_info */

	/*

	 * Older Firmware version doesn't support driver trigger pages.

	 * So, skip displaying 'config invalid type' type

	 * of error message.

/****************************************************************************

*  Common IOCStatus values for all replies

/****************************************************************************

*  Config IOCStatus values

/****************************************************************************

*  SCSI IO Reply

/****************************************************************************

*  For use by SCSI Initiator and SCSI Target end-to-end data protection

/****************************************************************************

*  SCSI Target values

/****************************************************************************

*  Serial Attached SCSI values

/****************************************************************************

*  Diagnostic Buffer Post / Diagnostic Release values

/**

 * _base_display_event_data - verbose translation of firmware asyn events

 * @ioc: per adapter object

 * @mpi_reply: reply mf payload returned from firmware

/**

 * _base_sas_log_info - verbose translation of firmware log info

 * @ioc: per adapter object

 * @log_info: log info

SAS*/)

 each nexus loss loginfo */

 eat the loginfos associated with task aborts */

/**

 * _base_display_reply_info - handle reply descriptors depending on IOC Status

 * @ioc: per adapter object

 * @smid: system request message index

 * @msix_index: MSIX table index supplied by the OS

 * @reply: reply message frame (lower 32bit addr)

/**

 * mpt3sas_base_done - base internal command completion routine

 * @ioc: per adapter object

 * @smid: system request message index

 * @msix_index: MSIX table index supplied by the OS

 * @reply: reply message frame(lower 32bit addr)

 *

 * Return:

 * 1 meaning mf should be freed from _base_interrupt

 * 0 means the mf is freed from this function.

/**

 * _base_async_event - main callback handler for firmware asyn events

 * @ioc: per adapter object

 * @msix_index: MSIX table index supplied by the OS

 * @reply: reply message frame(lower 32bit addr)

 *

 * Return:

 * 1 meaning mf should be freed from _base_interrupt

 * 0 means the mf is freed from this function.

 TODO */

 scsih callback handler */

 ctl callback handler */

/**

 * _base_get_cb_idx - obtain the callback index

 * @ioc: per adapter object

 * @smid: system request message index

 *

 * Return: callback index.

/**

 * mpt3sas_base_pause_mq_polling - pause polling on the mq poll queues

 *				when driver is flushing out the IOs.

 * @ioc: per adapter object

 *

 * Pause polling on the mq poll (io uring) queues when driver is flushing

 * out the IOs. Otherwise we may see the race condition of completing the same

 * IO from two paths.

 *

 * Returns nothing.

	/*

	 * wait for current poll to complete.

/**

 * mpt3sas_base_resume_mq_polling - Resume polling on mq poll queues.

 * @ioc: per adapter object

 *

 * Returns nothing.

/**

 * mpt3sas_base_mask_interrupts - disable interrupts

 * @ioc: per adapter object

 *

 * Disabling ResetIRQ, Reply and Doorbell Interrupts

/**

 * mpt3sas_base_unmask_interrupts - enable interrupts

 * @ioc: per adapter object

 *

 * Enabling only Reply Interrupts

/**

 * _base_process_reply_queue - Process reply descriptors from reply

 *		descriptor post queue.

 * @reply_q: per IRQ's reply queue object.

 *

 * Return: number of reply descriptors processed from reply

 *		descriptor queue.

 reply free queue handling */

		/* Update the reply post host index after continuously

		 * processing the threshold number of Reply Descriptors.

		 * So that FW can find enough entries to post the Reply

		 * Descriptors in the reply descriptor post queue.

	/* Update Reply Post Host Index.

	 * For those HBA's which support combined reply queue feature

	 * 1. Get the correct Supplemental Reply Post Host Index Register.

	 *    i.e. (msix_index / 8)th entry from Supplemental Reply Post Host

	 *    Index Register address bank i.e replyPostRegisterIndex[],

	 * 2. Then update this register with new reply host index value

	 *    in ReplyPostIndex field and the MSIxIndex field with

	 *    msix_index value reduced to a value between 0 and 7,

	 *    using a modulo 8 operation. Since each Supplemental Reply Post

	 *    Host Index Register supports 8 MSI-X vectors.

	 *

	 * For other HBA's just update the Reply Post Host Index register with

	 * new reply host index value in ReplyPostIndex Field and msix_index

	 * value in MSIxIndex field.

/**

 * mpt3sas_blk_mq_poll - poll the blk mq poll queue

 * @shost: Scsi_Host object

 * @queue_num: hw ctx queue number

 *

 * Return number of entries that has been processed from poll queue.

/**

 * _base_interrupt - MPT adapter (IOC) specific interrupt handler.

 * @irq: irq number (not used)

 * @bus_id: bus identifier cookie == pointer to MPT_ADAPTER structure

 *

 * Return: IRQ_HANDLED if processed, else IRQ_NONE.

/**

 * _base_irqpoll - IRQ poll callback handler

 * @irqpoll: irq_poll object

 * @budget: irq poll weight

 *

 * Return: number of reply descriptors processed

		/*

		 * Go for one more round of processing the

		 * reply descriptor post queue in case the HBA

		 * Firmware has posted some reply descriptors

		 * while reenabling the IRQ.

/**

 * _base_init_irqpolls - initliaze IRQ polls

 * @ioc: per adapter object

 *

 * Return: nothing

/**

 * _base_is_controller_msix_enabled - is controller support muli-reply queues

 * @ioc: per adapter object

 *

 * Return: Whether or not MSI/X is enabled.

/**

 * mpt3sas_base_sync_reply_irqs - flush pending MSIX interrupts

 * @ioc: per adapter object

 * @poll: poll over reply descriptor pools incase interrupt for

 *		timed-out SCSI command got delayed

 * Context: non-ISR context

 *

 * Called when a Task Management request has completed.

	/* If MSIX capability is turned off

	 * then multi-queues are not enabled

 TMs are on msix_index == 0 */

			/* Calling irq_poll_disable will wait for any pending

			 * callbacks to have completed.

			/* check how the scheduled poll has ended,

			 * clean up only if necessary

/**

 * mpt3sas_base_release_callback_handler - clear interrupt callback handler

 * @cb_idx: callback index

/**

 * mpt3sas_base_register_callback_handler - obtain index for the interrupt callback handler

 * @cb_func: callback function

 *

 * Return: Index of @cb_func.

/**

 * mpt3sas_base_initialize_callback_handler - initialize the interrupt callback handler

/**

 * _base_build_zero_len_sge - build zero length sg entry

 * @ioc: per adapter object

 * @paddr: virtual address for SGE

 *

 * Create a zero length scatter gather entry to insure the IOCs hardware has

 * something to use if the target device goes brain dead and tries

 * to send data even when none is asked for.

/**

 * _base_add_sg_single_32 - Place a simple 32 bit SGE at address pAddr.

 * @paddr: virtual address for SGE

 * @flags_length: SGE flags and data transfer length

 * @dma_addr: Physical address

/**

 * _base_add_sg_single_64 - Place a simple 64 bit SGE at address pAddr.

 * @paddr: virtual address for SGE

 * @flags_length: SGE flags and data transfer length

 * @dma_addr: Physical address

/**

 * _base_get_chain_buffer_tracker - obtain chain tracker

 * @ioc: per adapter object

 * @scmd: SCSI commands of the IO request

 *

 * Return: chain tracker from chain_lookup table using key as

 * smid and smid's chain_offset.

/**

 * _base_build_sg - build generic sg

 * @ioc: per adapter object

 * @psge: virtual address for SGE

 * @data_out_dma: physical address for WRITES

 * @data_out_sz: data xfer size for WRITES

 * @data_in_dma: physical address for READS

 * @data_in_sz: data xfer size for READS

 WRITE sgel first */

 incr sgel */

 READ sgel last */

 WRITE */ {

 READ */ {

 IEEE format sgls */

/**

 * _base_build_nvme_prp - This function is called for NVMe end devices to build

 *                        a native SGL (NVMe PRP).

 * @ioc: per adapter object

 * @smid: system request message index for getting asscociated SGL

 * @nvme_encap_request: the NVMe request msg frame pointer

 * @data_out_dma: physical address for WRITES

 * @data_out_sz: data xfer size for WRITES

 * @data_in_dma: physical address for READS

 * @data_in_sz: data xfer size for READS

 *

 * The native SGL is built starting in the first PRP

 * entry of the NVMe message (PRP1).  If the data buffer is small enough to be

 * described entirely using PRP1, then PRP2 is not used.  If needed, PRP2 is

 * used to describe a larger data buffer.  If the data buffer is too large to

 * describe using the two PRP entriess inside the NVMe message, then PRP1

 * describes the first data memory segment, and PRP2 contains a pointer to a PRP

 * list located elsewhere in memory to describe the remaining data memory

 * segments.  The PRP list will be contiguous.

 *

 * The native SGL for NVMe devices is a Physical Region Page (PRP).  A PRP

 * consists of a list of PRP entries to describe a number of noncontigous

 * physical memory segments as a single memory buffer, just as a SGL does.  Note

 * however, that this function is only used by the IOCTL call, so the memory

 * given will be guaranteed to be contiguous.  There is no need to translate

 * non-contiguous SGL into a PRP in this case.  All PRPs will describe

 * contiguous space that is one page size each.

 *

 * Each NVMe message contains two PRP entries.  The first (PRP1) either contains

 * a PRP list pointer or a PRP element, depending upon the command.  PRP2

 * contains the second PRP element if the memory being described fits within 2

 * PRP entries, or a PRP list pointer if the PRP spans more than two entries.

 *

 * A PRP list pointer contains the address of a PRP list, structured as a linear

 * array of PRP entries.  Each PRP entry in this list describes a segment of

 * physical memory.

 *

 * Each 64-bit PRP entry comprises an address and an offset field.  The address

 * always points at the beginning of a 4KB physical memory page, and the offset

 * describes where within that 4KB page the memory segment begins.  Only the

 * first element in a PRP list may contain a non-zero offset, implying that all

 * memory segments following the first begin at the start of a 4KB page.

 *

 * Each PRP element normally describes 4KB of physical memory, with exceptions

 * for the first and last elements in the list.  If the memory being described

 * by the list begins at a non-zero offset within the first 4KB page, then the

 * first PRP element will contain a non-zero offset indicating where the region

 * begins within the 4KB page.  The last memory segment may end before the end

 * of the 4KB segment, depending upon the overall size of the memory being

 * described by the PRP list.

 *

 * Since PRP entries lack any indication of size, the overall data buffer length

 * is used to determine where the end of the data memory buffer is located, and

 * how many PRP entries are required to describe it.

	/*

	 * Not all commands require a data transfer. If no data, just return

	 * without constructing any PRP.

	/*

	 * For the PRP entries, use the specially allocated buffer of

	 * contiguous memory.

	/*

	 * Check if we are within 1 entry of a page boundary we don't

	 * want our first entry to be a PRP List entry.

 Bump up to next page boundary. */

	/*

	 * Set PRP physical pointer, which initially points to the current PRP

	 * DMA memory page.

 Get physical address and length of the data buffer. */

 Loop while the length is not zero. */

		/*

		 * Check if we need to put a list pointer here if we are at

		 * page boundary - prp_size (8 bytes).

			/*

			 * This is the last entry in a PRP List, so we need to

			 * put a PRP list pointer here.  What this does is:

			 *   - bump the current memory pointer to the next

			 *     address, which will be the next full page.

			 *   - set the PRP Entry to point to that page.  This

			 *     is now the PRP List pointer.

			 *   - bump the PRP Entry pointer the start of the

			 *     next page.  Since all of this PRP memory is

			 *     contiguous, no need to get a new page - it's

			 *     just the next address.

 Need to handle if entry will be part of a page. */

			/*

			 * Must fill in the first PRP pointer (PRP1) before

			 * moving on.

			/*

			 * Now point to the second PRP entry within the

			 * command (PRP2).

			/*

			 * Should the PRP2 entry be a PRP List pointer or just

			 * a regular PRP pointer?  If there is more than one

			 * more page of data, must use a PRP List pointer.

				/*

				 * PRP2 will contain a PRP List pointer because

				 * more PRP's are needed with this command. The

				 * list will start at the beginning of the

				 * contiguous buffer.

				/*

				 * The next PRP Entry will be the start of the

				 * first PRP List.

				/*

				 * After this, the PRP Entries are complete.

				 * This command uses 2 PRP's and no PRP list.

			/*

			 * Put entry in list and bump the addresses.

			 *

			 * After PRP1 and PRP2 are filled in, this will fill in

			 * all remaining PRP entries in a PRP List, one per

			 * each time through the loop.

		/*

		 * Bump the phys address of the command's data buffer by the

		 * entry_len.

 Decrement length accounting for last partial page. */

/**

 * base_make_prp_nvme - Prepare PRPs (Physical Region Page) -

 *			SGLs specific to NVMe drives only

 *

 * @ioc:		per adapter object

 * @scmd:		SCSI command from the mid-layer

 * @mpi_request:	mpi request

 * @smid:		msg Index

 * @sge_count:		scatter gather element count.

 *

 * Return:		true: PRPs are built

 *			false: IEEE SGLs needs to be built

	/*

	 * Nvme has a very convoluted prp format.  One prp is required

	 * for each page or partial page. Driver need to split up OS sg_list

	 * entries if it is longer than one page or cross a page

	 * boundary.  Driver also have to insert a PRP list pointer entry as

	 * the last entry in each physical page of the PRP list.

	 *

	 * NOTE: The first PRP "entry" is actually placed in the first

	 * SGL entry in the main message as IEEE 64 format.  The 2nd

	 * entry in the main message is the chain element, and the rest

	 * of the PRP entries are built in the contiguous pcie buffer.

	/*

	 * Native SGL is needed.

	 * Put a chain element in main message frame that points to the first

	 * chain buffer.

	 *

	 * NOTE:  The ChainOffset field must be 0 when using a chain pointer to

	 *        a native SGL.

 Set main message chain element pointer */

	/*

	 * For NVMe the chain element needs to be the 2nd SG entry in the main

	 * message.

	/*

	 * For the PRP entries, use the specially allocated buffer of

	 * contiguous memory.  Normal chain buffers can't be used

	 * because each chain buffer would need to be the size of an OS

	 * page (4k).

 Build first prp, sge need not to be page aligned*/

 Put PRP pointer due to page boundary*/

	/* If Datalenth is <= 16K and number of SGE’s entries are <= 2

	 * we built IEEE SGL

/**

 * _base_check_pcie_native_sgl - This function is called for PCIe end devices to

 * determine if the driver needs to build a native SGL.  If so, that native

 * SGL is built in the special contiguous buffers allocated especially for

 * PCIe SGL creation.  If the driver will not build a native SGL, return

 * TRUE and a normal IEEE SGL will be built.  Currently this routine

 * supports NVMe.

 * @ioc: per adapter object

 * @mpi_request: mf request pointer

 * @smid: system request message index

 * @scmd: scsi command

 * @pcie_device: points to the PCIe device's info

 *

 * Return: 0 if native SGL was built, 1 if no SGL was built

 Get the SG list pointer and info. */

 Check if we need to build a native SG list. */

 We built a native SG list, just return. */

	/*

	 * Build native NVMe PRP.

/**

 * _base_add_sg_single_ieee - add sg element for IEEE format

 * @paddr: virtual address for SGE

 * @flags: SGE flags

 * @chain_offset: number of 128 byte elements from start of segment

 * @length: data transfer length

 * @dma_addr: Physical address

/**

 * _base_build_zero_len_sge_ieee - build zero length sg entry for IEEE format

 * @ioc: per adapter object

 * @paddr: virtual address for SGE

 *

 * Create a zero length scatter gather entry to insure the IOCs hardware has

 * something to use if the target device goes brain dead and tries

 * to send data even when none is asked for.

/**

 * _base_build_sg_scmd - main sg creation routine

 *		pcie_device is unused here!

 * @ioc: per adapter object

 * @scmd: scsi command

 * @smid: system request message index

 * @unused: unused pcie_device pointer

 * Context: none.

 *

 * The main routine that builds scatter gather table from a given

 * scsi request sent via the .queuecommand main handler.

 *

 * Return: 0 success, anything else error

 init scatter gather flags */

 fill in main message segment when there is a chain following */

 initializing the chain flags and pointers */

 fill in chain segments */

 fill the last segment */

/**

 * _base_build_sg_scmd_ieee - main sg creation routine for IEEE format

 * @ioc: per adapter object

 * @scmd: scsi command

 * @smid: system request message index

 * @pcie_device: Pointer to pcie_device. If set, the pcie native sgl will be

 * constructed on need.

 * Context: none.

 *

 * The main routine that builds scatter gather table from a given

 * scsi request sent via the .queuecommand main handler.

 *

 * Return: 0 success, anything else error

 init scatter gather flags */

 Check if we need to build a native SG list. */

 We built a native SG list, just return. */

 chain element */) +

 fill in main message segment when there is a chain following */

 initializing the pointers */

 fill in chain segments */

 fill the last segment */

/**

 * _base_build_sg_ieee - build generic sg for IEEE format

 * @ioc: per adapter object

 * @psge: virtual address for SGE

 * @data_out_dma: physical address for WRITES

 * @data_out_sz: data xfer size for WRITES

 * @data_in_dma: physical address for READS

 * @data_in_sz: data xfer size for READS

 WRITE sgel first */

 incr sgel */

 READ sgel last */

 WRITE */ {

 READ */ {

/**

 * _base_config_dma_addressing - set dma addressing

 * @ioc: per adapter object

 * @pdev: PCI device struct

 *

 * Return: 0 for success, non-zero for failure.

 Set 63 bit DMA mask for all SAS3 and SAS35 controllers */

/**

 * _base_check_enable_msix - checks MSIX capabable.

 * @ioc: per adapter object

 *

 * Check to see if card is capable of MSIX, and set number

 * of available msix vectors

	/* Check whether controller SAS2008 B0 controller,

	 * if it is SAS2008 B0 controller use IO-APIC instead of MSIX

 get msix vector count */

 NUMA_IO not supported for older controllers */

/**

 * mpt3sas_base_free_irq - free irq

 * @ioc: per adapter object

 *

 * Freeing respective reply_queue from the list.

/**

 * _base_request_irq - request irq

 * @ioc: per adapter object

 * @index: msix index into vector table

 *

 * Inserting respective reply_queue into the list.

/**

 * _base_assign_reply_queues - assigning msix index for each cpu

 * @ioc: per adapter object

 *

 * The enduser would need to set the affinity via /proc/irq/#/smp_affinity

 *

 * It would nice if we could call irq_set_affinity, however it is not

 * an exported symbol

		/*

		 * set irq affinity to local numa node for those irqs

		 * corresponding to high iops queues.

/**

 * _base_check_and_enable_high_iops_queues - enable high iops mode

 * @ioc: per adapter object

 * @hba_msix_vector_count: msix vectors supported by HBA

 *

 * Enable high iops queues only if

 *  - HBA is a SEA/AERO controller and

 *  - MSI-Xs vector supported by the HBA is 128 and

 *  - total CPU count in the system >=16 and

 *  - loaded driver with default max_msix_vectors module parameter and

 *  - system booted in non kdump mode

 *

 * Return: nothing.

	/*

	 * Disable high iops queues if io uring poll queues are enabled.

/**

 * mpt3sas_base_disable_msix - disables msix

 * @ioc: per adapter object

 *

/**

 * _base_alloc_irq_vectors - allocate msix vectors

 * @ioc: per adapter object

 *

	/*

	 * Don't allocate msix vectors for poll_queues.

	 * msix_vectors is always within a range of FW supported reply queue.

/**

 * _base_enable_msix - enables msix, failback to io_apic

 * @ioc: per adapter object

 *

	/*

	 * Enable msix_load_balance only if combined reply queue mode is

	 * disabled on SAS3 & above generation HBA devices.

	/*

	 * smp affinity setting is not need when msix load balance

	 * is enabled.

	/*

	 * Enable io uring poll queues only if host_tagset is enabled.

	/*

	 * Add high iops queues count to reply queue count if high iops queues

	 * are enabled.

	/*

	 * Adjust the reply queue count incase reply queue count

	 * exceeds the user provided MSIx vectors count.

	/*

	 * Add io uring poll queues count to reply queues count

	 * if io uring is enabled in driver.

	/*

	 * Starting index of io uring poll queues in reply queue list.

	/*

	 * Adjust the reply queue count if the allocated

	 * MSIx vectors is less then the requested number

	 * of MSIx vectors.

 failback to io_apic interrupt routing */

/**

 * mpt3sas_base_unmap_resources - free controller resources

 * @ioc: per adapter object

/**

 * mpt3sas_base_check_for_fault_and_issue_reset - check if IOC is in fault state

 *     and if it is in fault state then issue diag reset.

 * @ioc: per adapter object

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_base_map_resources - map in controller resources (io/irq/memap)

 * @ioc: per adapter object

 *

 * Return: 0 for success, non-zero for failure.

 AER (Advanced Error Reporting) hooks */

	/* Use the Combined reply queue feature only for SAS3 C0 & higher

	 * revision HBAs and also only when reply queue count is greater than 8

		/* Determine the Supplemental Reply Post Host Index Registers

		 * Addresse. Supplemental Reply Post Host Index Registers

		 * starts at offset MPI25_SUP_REPLY_POST_HOST_INDEX_OFFSET and

		 * each register is at offset bytes of

		 * MPT3_SUP_REPLY_POST_HOST_INDEX_REG_OFFSET from previous one.

 Save PCI configuration state for recovery from PCI AER/EEH errors */

/**

 * mpt3sas_base_get_msg_frame - obtain request mf pointer

 * @ioc: per adapter object

 * @smid: system request message index(smid zero is invalid)

 *

 * Return: virt pointer to message frame.

/**

 * mpt3sas_base_get_sense_buffer - obtain a sense buffer virt addr

 * @ioc: per adapter object

 * @smid: system request message index

 *

 * Return: virt pointer to sense buffer.

/**

 * mpt3sas_base_get_sense_buffer_dma - obtain a sense buffer dma addr

 * @ioc: per adapter object

 * @smid: system request message index

 *

 * Return: phys pointer to the low 32bit address of the sense buffer.

/**

 * mpt3sas_base_get_pcie_sgl - obtain a PCIe SGL virt addr

 * @ioc: per adapter object

 * @smid: system request message index

 *

 * Return: virt pointer to a PCIe SGL.

/**

 * mpt3sas_base_get_pcie_sgl_dma - obtain a PCIe SGL dma addr

 * @ioc: per adapter object

 * @smid: system request message index

 *

 * Return: phys pointer to the address of the PCIe buffer.

/**

 * mpt3sas_base_get_reply_virt_addr - obtain reply frames virt address

 * @ioc: per adapter object

 * @phys_addr: lower 32 physical addr of the reply

 *

 * Converts 32bit lower physical addr into a virt address.

/**

 * _base_get_msix_index - get the msix index

 * @ioc: per adapter object

 * @scmd: scsi_cmnd object

 *

 * Return: msix index of general reply queues,

 * i.e. reply queue on which IO request's reply

 * should be posted by the HBA firmware.

 Enables reply_queue load balancing */

/**

 * _base_get_high_iops_msix_index - get the msix index of

 *				high iops queues

 * @ioc: per adapter object

 * @scmd: scsi_cmnd object

 *

 * Return: msix index of high iops reply queues.

 * i.e. high iops reply queue on which IO request's

 * reply should be posted by the HBA firmware.

	/**

	 * Round robin the IO interrupts among the high iops

	 * reply queues in terms of batch count 16 when outstanding

	 * IOs on the target device is >=8.

/**

 * mpt3sas_base_get_smid - obtain a free smid from internal queue

 * @ioc: per adapter object

 * @cb_idx: callback index

 *

 * Return: smid (zero is invalid)

/**

 * mpt3sas_base_get_smid_scsiio - obtain a free smid from scsiio queue

 * @ioc: per adapter object

 * @cb_idx: callback index

 * @scmd: pointer to scsi command object

 *

 * Return: smid (zero is invalid)

	/*

	 * Store hw queue number corresponding to the tag.

	 * This hw queue number is used later to determine

	 * the unique_tag using the logic below. This unique_tag

	 * is used to retrieve the scmd pointer corresponding

	 * to tag using scsi_host_find_tag() API.

	 *

	 * tag = smid - 1;

	 * unique_tag = ioc->io_queue_num[tag] << BLK_MQ_UNIQUE_TAG_BITS | tag;

/**

 * mpt3sas_base_get_smid_hpr - obtain a free smid from hi-priority queue

 * @ioc: per adapter object

 * @cb_idx: callback index

 *

 * Return: smid (zero is invalid)

	/*

	 * See _wait_for_commands_to_complete() call with regards to this code.

/**

 * mpt3sas_base_free_smid - put smid back on free_list

 * @ioc: per adapter object

 * @smid: system request message index

 Clear MPI request frame */

 hi-priority */

 internal queue */

/**

 * _base_mpi_ep_writeq - 32 bit write to MMIO

 * @b: data payload

 * @addr: address in MMIO space

 * @writeq_lock: spin lock

 *

 * This special handling for MPI EP to take care of 32 bit

 * environment where its not quarenteed to send the entire word

 * in one transfer.

/**

 * _base_writeq - 64 bit write to MMIO

 * @b: data payload

 * @addr: address in MMIO space

 * @writeq_lock: spin lock

 *

 * Glue for handling an atomic 64 bit word to MMIO. This special handling takes

 * care of 32 bit environment where its not quarenteed to send the entire word

 * in one transfer.

/**

 * _base_set_and_get_msix_index - get the msix index and assign to msix_io

 *                                variable of scsi tracker

 * @ioc: per adapter object

 * @smid: system request message index

 *

 * Return: msix index.

/**

 * _base_put_smid_mpi_ep_scsi_io - send SCSI_IO request to firmware

 * @ioc: per adapter object

 * @smid: system request message index

 * @handle: device handle

/**

 * _base_put_smid_scsi_io - send SCSI_IO request to firmware

 * @ioc: per adapter object

 * @smid: system request message index

 * @handle: device handle

/**

 * _base_put_smid_fast_path - send fast path request to firmware

 * @ioc: per adapter object

 * @smid: system request message index

 * @handle: device handle

/**

 * _base_put_smid_hi_priority - send Task Management request to firmware

 * @ioc: per adapter object

 * @smid: system request message index

 * @msix_task: msix_task will be same as msix of IO in case of task abort else 0

 TBD 256 is offset within sys register. */

/**

 * mpt3sas_base_put_smid_nvme_encap - send NVMe encapsulated request to

 *  firmware

 * @ioc: per adapter object

 * @smid: system request message index

/**

 * _base_put_smid_default - Default, primarily used for config pages

 * @ioc: per adapter object

 * @smid: system request message index

 TBD 256 is offset within sys register */

/**

 * _base_put_smid_scsi_io_atomic - send SCSI_IO request to firmware using

 *   Atomic Request Descriptor

 * @ioc: per adapter object

 * @smid: system request message index

 * @handle: device handle, unused in this function, for function type match

 *

 * Return: nothing.

/**

 * _base_put_smid_fast_path_atomic - send fast path request to firmware

 * using Atomic Request Descriptor

 * @ioc: per adapter object

 * @smid: system request message index

 * @handle: device handle, unused in this function, for function type match

 * Return: nothing

/**

 * _base_put_smid_hi_priority_atomic - send Task Management request to

 * firmware using Atomic Request Descriptor

 * @ioc: per adapter object

 * @smid: system request message index

 * @msix_task: msix_task will be same as msix of IO in case of task abort else 0

 *

 * Return: nothing.

/**

 * _base_put_smid_default_atomic - Default, primarily used for config pages

 * use Atomic Request Descriptor

 * @ioc: per adapter object

 * @smid: system request message index

 *

 * Return: nothing.

/**

 * _base_display_OEMs_branding - Display branding string

 * @ioc: per adapter object

/**

 * _base_display_fwpkg_version - sends FWUpload request to pull FWPkg

 *				version from FW Image Header.

 * @ioc: per adapter object

 *

 * Return: 0 for success, non-zero for failure.

 Wait for 15 seconds */

/**

 * _base_display_ioc_capabilities - Display IOC's capabilities.

 * @ioc: per adapter object

/**

 * mpt3sas_base_update_missing_delay - change the missing delay timers

 * @ioc: per adapter object

 * @device_missing_delay: amount of time till device is reported missing

 * @io_missing_delay: interval IO is returned when there is a missing device

 *

 * Passed on the command line, this function will modify the device missing

 * delay, as well as the io missing delay. This should be called at driver

 * load time.

 device missing delay */

 io missing delay */

/**

 * _base_update_ioc_page1_inlinewith_perf_mode - Update IOC Page1 fields

 *    according to performance mode.

 * @ioc : per adapter object

 *

 * Return: zero on success; otherwise return EAGAIN error code asking the

 * caller to retry.

			/*

			 * If 31st bit is zero then interrupt coalescing is

			 * enabled for all reply descriptor post queues.

			 * If 31st bit is set to one then user can

			 * enable/disable interrupt coalescing on per reply

			 * descriptor post queue group(8) basis. So to enable

			 * interrupt coalescing only on first reply descriptor

			 * post queue group 31st bit and zero th bit is enabled.

		/*

		 * Enable interrupt coalescing on all reply queues

		 * with timeout value 0xA

		/*

		 * Enable interrupt coalescing on all reply queues.

/**

 * _base_get_event_diag_triggers - get event diag trigger values from

 *				persistent pages

 * @ioc : per adapter object

 *

 * Return: nothing.

/**

 * _base_get_scsi_diag_triggers - get scsi diag trigger values from

 *				persistent pages

 * @ioc : per adapter object

 *

 * Return: 0 on success; otherwise return failure status.

/**

 * _base_get_mpi_diag_triggers - get mpi diag trigger values from

 *				persistent pages

 * @ioc : per adapter object

 *

 * Return: 0 on success; otherwise return failure status.

/**

 * _base_get_master_diag_triggers - get master diag trigger values from

 *				persistent pages

 * @ioc : per adapter object

 *

 * Return: nothing.

/**

 * _base_check_for_trigger_pages_support - checks whether HBA FW supports

 *					driver trigger pages or not

 * @ioc : per adapter object

 * @trigger_flags : address where trigger page0's TriggerFlags value is copied

 *

 * Return: trigger flags mask if HBA FW supports driver trigger pages;

 * otherwise returns %-EFAULT if driver trigger pages are not supported by FW or

 * return EAGAIN if diag reset occurred due to FW fault and asking the

 * caller to retry the command.

 *

/**

 * _base_get_diag_triggers - Retrieve diag trigger values from

 *				persistent pages.

 * @ioc : per adapter object

 *

 * Return: zero on success; otherwise return EAGAIN error codes

 * asking the caller to retry.

	/*

	 * Default setting of master trigger.

		/*

		 * Don't go for error handling when FW doesn't support

		 * driver trigger pages.

	/*

	 * Retrieve master diag trigger values from driver trigger pg1

	 * if master trigger bit enabled in TriggerFlags.

	/*

	 * Retrieve event diag trigger values from driver trigger pg2

	 * if event trigger bit enabled in TriggerFlags.

	/*

	 * Retrieve scsi diag trigger values from driver trigger pg3

	 * if scsi trigger bit enabled in TriggerFlags.

	/*

	 * Retrieve mpi error diag trigger values from driver trigger pg4

	 * if loginfo trigger bit enabled in TriggerFlags.

/**

 * _base_update_diag_trigger_pages - Update the driver trigger pages after

 *			online FW update, in case updated FW supports driver

 *			trigger pages.

 * @ioc : per adapter object

 *

 * Return: nothing.

/**

 * _base_assign_fw_reported_qd	- Get FW reported QD for SAS/SATA devices.

 *				- On failure set default QD values.

 * @ioc : per adapter object

 *

 * Returns 0 for success, non-zero for failure.

 *

 sas iounit page 1 */

 pcie iounit page 1 */

/**

 * _base_static_config_pages - static start of day config pages

 * @ioc: per adapter object

	/*

	 * Ensure correct T10 PI operation if vendor left EEDPTagMode

	 * flag unset in NVDATA.

	/*

	 * Enable task_set_full handling in iounit_pg1 when the

	 * facts capabilities indicate that its supported.

			/*

			 * In case of online HBA FW update operation,

			 * check whether updated FW supports the driver trigger

			 * pages or not.

			 * - If previous FW has not supported driver trigger

			 *   pages and newer FW supports them then update these

			 *   pages with current diag trigger values.

			 * - If previous FW has supported driver trigger pages

			 *   and new FW doesn't support them then disable

			 *   support_trigger_pages flag.

/**

 * mpt3sas_free_enclosure_list - release memory

 * @ioc: per adapter object

 *

 * Free memory allocated during enclosure add.

 Free enclosure list */

/**

 * _base_release_memory_pools - release memory

 * @ioc: per adapter object

 *

 * Free memory allocated from _base_allocate_memory_pools.

/**

 * mpt3sas_check_same_4gb_region - checks whether all reply queues in a set are

 *	having same upper 32bits in their base memory address.

 * @reply_pool_start_address: Base address of a reply queue set

 * @pool_sz: Size of single Reply Descriptor Post Queues pool size

 *

 * Return: 1 if reply queues in a set have a same upper 32bits in their base

 * memory address, else 0.

/**

 * _base_reduce_hba_queue_depth- Retry with reduced queue depth

 * @ioc: Adapter object

 *

 * Return: 0 for success, non-zero for failure.

/**

 * _base_allocate_pcie_sgl_pool - Allocating DMA'able memory

 *			for pcie sgl pools.

 * @ioc: Adapter object

 * @sz: DMA Pool size

 *

 * Return: 0 for success, non-zero for failure.

/**

 * _base_allocate_chain_dma_pool - Allocating DMA'able memory

 *			for chain dma pool.

 * @ioc: Adapter object

 * @sz: DMA Pool size

 *

 * Return: 0 for success, non-zero for failure.

/**

 * _base_allocate_sense_dma_pool - Allocating DMA'able memory

 *			for sense dma pool.

 * @ioc: Adapter object

 * @sz: DMA Pool size

 * Return: 0 for success, non-zero for failure.

/**

 * _base_allocate_reply_pool - Allocating DMA'able memory

 *			for reply pool.

 * @ioc: Adapter object

 * @sz: DMA Pool size

 * Return: 0 for success, non-zero for failure.

 reply pool, 4 byte align */

/**

 * _base_allocate_reply_free_dma_pool - Allocating DMA'able memory

 *			for reply free dma pool.

 * @ioc: Adapter object

 * @sz: DMA Pool size

 * Return: 0 for success, non-zero for failure.

 reply free queue, 16 byte align */

/**

 * _base_allocate_reply_post_free_array - Allocating DMA'able memory

 *			for reply post free array.

 * @ioc: Adapter object

 * @reply_post_free_array_sz: DMA Pool size

 * Return: 0 for success, non-zero for failure.

/**

 * base_alloc_rdpq_dma_pool - Allocating DMA'able memory

 *                     for reply queues.

 * @ioc: per adapter object

 * @sz: DMA Pool size

 * Return: 0 for success, non-zero for failure.

	/*

	 *  For INVADER_SERIES each set of 8 reply queues(0-7, 8-15, ..) and

	 *  VENTURA_SERIES each set of 16 reply queues(0-15, 16-31, ..) should

	 *  be within 4GB boundary i.e reply queues in a set must have same

	 *  upper 32-bits in their memory address. so here driver is allocating

	 *  the DMA'able memory for reply queues according.

	 *  Driver uses limitation of

	 *  VENTURA_SERIES to manage INVADER_SERIES as well.

			/*

			 * Each set of RDPQ pool must satisfy 4gb boundary

			 * restriction.

			 * 1) Check if allocated resources for RDPQ pool are in

			 *	the same 4GB range.

			 * 2) If #1 is true, continue with 64 bit DMA.

			 * 3) If #1 is false, return 1. which means free all the

			 * resources and set DMA mask to 32 and allocate.

/**

 * _base_allocate_memory_pools - allocate start of day memory pools

 * @ioc: per adapter object

 *

 * Return: 0 success, anything else error.

 command line tunables for max sgl entries */

 max sgl entries <= MPT_KDUMP_MIN_PHYS_SEGMENTS in KDUMP mode */

 command line tunables  for max controller queue depth */

	/* Firmware maintains additional facts->HighPriorityCredit number of

	 * credits for HiPriprity Request messages, so hba queue depth will be

	 * sum of max_request_credit and high priority queue depth.

 request frame size */

 reply frame size */

 chain segment size */

 set to 128 bytes size if IOCMaxChainSegmentSize is zero */

 calculate the max scatter element size */

 calculate number of sg elements left over in the 1st frame */

 now do the same for a chain buffer */

	/*

	 *  MPT3SAS_SG_DEPTH = CONFIG_FUSION_MAX_SGE

 reply free queue sizing - taking into account for 64 FW events */

 mCPU manage single counters for simplicity */

 calculate reply descriptor post queue depth */

 align the reply post queue on the next 16 count boundary */

 reply post queue, 16 byte align */

		/*

		 * Free allocated bad RDPQ memory pools.

		 * Change dma coherent mask to 32 bit and reallocate RDPQ

	/* set the scsi host can_queue depth

	 * with some internal commands that could be outstanding

	/* contiguous pool for request and chains, 16 byte align, one extra "

	 * "frame for smid=0

 hi-priority queue */

 internal queue */

 hi-priority queue */

 internal queue */

 initialize hi-priority queue smid's */

 initialize internal queue smid's */

	/*

	 * The number of NVMe page sized blocks needed is:

	 *     (((sg_tablesize * 8) - 1) / (page_size - 8)) + 1

	 * ((sg_tablesize * 8) - 1) is the max PRP's minus the first PRP entry

	 * that is placed in the main message frame.  8 is the size of each PRP

	 * entry or PRP list pointer entry.  8 is subtracted from page_size

	 * because of the PRP list pointer entry at the end of a page, so this

	 * is not counted as a PRP entry.  The 1 added page is a round up.

	 *

	 * To avoid allocation failures due to the amount of memory that could

	 * be required for NVMe PRP's, only each set of NVMe blocks will be

	 * contiguous, so a new set is allocated for each possible I/O.

 sense buffers, 4 byte align */

 reply pool, 4 byte align */

 reply free queue, 16 byte align */

 Change dma coherent mask to 32 bit and reallocate */

/**

 * mpt3sas_base_get_iocstate - Get the current state of a MPT adapter.

 * @ioc: Pointer to MPT_ADAPTER structure

 * @cooked: Request raw or cooked IOC state

 *

 * Return: all IOC Doorbell register bits if cooked==0, else just the

 * Doorbell bits in MPI_IOC_STATE_MASK.

/**

 * _base_wait_on_iocstate - waiting on a particular ioc state

 * @ioc: ?

 * @ioc_state: controller state { READY, OPERATIONAL, or RESET }

 * @timeout: timeout in second

 *

 * Return: 0 for success, non-zero for failure.

/**

 * _base_dump_reg_set -	This function will print hexdump of register set.

 * @ioc: per adapter object

 *

 * Return: nothing.

/**

 * _base_wait_for_doorbell_int - waiting for controller interrupt(generated by

 * a write to the doorbell)

 * @ioc: per adapter object

 * @timeout: timeout in seconds

 *

 * Return: 0 for success, non-zero for failure.

 *

 * Notes: MPI2_HIS_IOC2SYS_DB_STATUS - set to one when IOC writes to doorbell.

/**

 * _base_wait_for_doorbell_ack - waiting for controller to read the doorbell.

 * @ioc: per adapter object

 * @timeout: timeout in second

 *

 * Return: 0 for success, non-zero for failure.

 *

 * Notes: MPI2_HIS_SYS2IOC_DB_STATUS - set to one when host writes to

 * doorbell.

/**

 * _base_wait_for_doorbell_not_used - waiting for doorbell to not be in use

 * @ioc: per adapter object

 * @timeout: timeout in second

 *

 * Return: 0 for success, non-zero for failure.

/**

 * _base_send_ioc_reset - send doorbell reset

 * @ioc: per adapter object

 * @reset_type: currently only supports: MPI2_FUNCTION_IOC_MESSAGE_UNIT_RESET

 * @timeout: timeout in second

 *

 * Return: 0 for success, non-zero for failure.

		/*

		 * Wait for IOC state CoreDump to clear only during

		 * HBA initialization & release time.

/**

 * mpt3sas_wait_for_ioc - IOC's operational state is checked here.

 * @ioc: per adapter object

 * @timeout: timeout in seconds

 *

 * Return: Waits up to timeout seconds for the IOC to

 * become operational. Returns 0 if IOC is present

 * and operational; otherwise returns %-EFAULT.

		/*

		 * Watchdog thread will be started after IOC Initialization, so

		 * no need to wait here for IOC state to become operational

		 * when IOC Initialization is on. Instead the driver will

		 * return ETIME status, so that calling function can issue

		 * diag reset operation and retry the command.

/**

 * _base_handshake_req_reply_wait - send request thru doorbell interface

 * @ioc: per adapter object

 * @request_bytes: request length

 * @request: pointer having request payload

 * @reply_bytes: reply length

 * @reply: pointer to reply payload

 * @timeout: timeout in second

 *

 * Return: 0 for success, non-zero for failure.

 make sure doorbell is not in use */

 clear pending doorbell interrupts from previous state changes */

 send message to ioc */

 send message 32-bits at a time */

 now wait for the reply */

 read the first two 16-bits, it gives the total length of the reply */

 overflow case */

/**

 * mpt3sas_base_sas_iounit_control - send sas iounit control to FW

 * @ioc: per adapter object

 * @mpi_reply: the reply payload from FW

 * @mpi_request: the request payload sent to FW

 *

 * The SAS IO Unit Control Request message allows the host to perform low-level

 * operations, such as resets on the PHYs of the IO Unit, also allows the host

 * to obtain the IOC assigned device handles for a device if it has other

 * identifying information about the device, in addition allows the host to

 * remove IOC resources associated with the device.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_base_scsi_enclosure_processor - sending request to sep device

 * @ioc: per adapter object

 * @mpi_reply: the reply payload from FW

 * @mpi_request: the request payload sent to FW

 *

 * The SCSI Enclosure Processor request message causes the IOC to

 * communicate with SES devices to control LED status signals.

 *

 * Return: 0 for success, non-zero for failure.

/**

 * _base_get_port_facts - obtain port facts reply and save in ioc

 * @ioc: per adapter object

 * @port: ?

 *

 * Return: 0 for success, non-zero for failure.

/**

 * _base_wait_for_iocstate - Wait until the card is in READY or OPERATIONAL

 * @ioc: per adapter object

 * @timeout:

 *

 * Return: 0 for success, non-zero for failure.

/**

 * _base_get_ioc_facts - obtain ioc facts reply and save in ioc

 * @ioc: per adapter object

 *

 * Return: 0 for success, non-zero for failure.

	/*

	 * Get the Page Size from IOC Facts. If it's 0, default to 4k.

/**

 * _base_send_ioc_init - send ioc_init to firmware

 * @ioc: per adapter object

 *

 * Return: 0 for success, non-zero for failure.

 TODO */

	/*

	 * Set the flag to enable CoreDump state feature in IOC firmware.

	/* This time stamp specifies number of milliseconds

	 * since epoch ~ midnight January 1, 1970.

 Reset TimeSync Counter*/

/**

 * mpt3sas_port_enable_done - command completion routine for port enable

 * @ioc: per adapter object

 * @smid: system request message index

 * @msix_index: MSIX table index supplied by the OS

 * @reply: reply message frame(lower 32bit addr)

 *

 * Return: 1 meaning mf should be freed from _base_interrupt

 *          0 means the mf is freed from this function.

/**

 * _base_send_port_enable - send port_enable(discovery stuff) to firmware

 * @ioc: per adapter object

 *

 * Return: 0 for success, non-zero for failure.

/**

 * mpt3sas_port_enable - initiate firmware discovery (don't wait for reply)

 * @ioc: per adapter object

 *

 * Return: 0 for success, non-zero for failure.

/**

 * _base_determine_wait_on_discovery - desposition

 * @ioc: per adapter object

 *

 * Decide whether to wait on discovery to complete. Used to either

 * locate boot device, or report volumes ahead of physical devices.

 *

 * Return: 1 for wait, 0 for don't wait.

	/* We wait for discovery to complete if IR firmware is loaded.

	 * The sas topology events arrive before PD events, so we need time to

	 * turn on the bit in ioc->pd_handles to indicate PD

	 * Also, it maybe required to report Volumes ahead of physical

	 * devices when MPI2_IOCPAGE8_IRFLAGS_LOW_VOLUME_MAPPING is set.

 if no Bios, then we don't need to wait */

	/* Bios is present, then we drop down here.

	 *

	 * If there any entries in the Bios Page 2, then we wait

	 * for discovery to complete.

 Current Boot Device */

 Request Boot Device */

 Alternate Request Boot Device */

/**

 * _base_unmask_events - turn on notification for this event

 * @ioc: per adapter object

 * @event: firmware event

 *

 * The mask is stored in ioc->event_masks.

/**

 * _base_event_notification - send event notification

 * @ioc: per adapter object

 *

 * Return: 0 for success, non-zero for failure.

 TODO */

/**

 * mpt3sas_base_validate_event_type - validating event types

 * @ioc: per adapter object

 * @event_type: firmware event

 *

 * This will turn on firmware event notification when application

 * ask for that event. We don't mask events that are already enabled.

/**

 * _base_diag_reset - the "big hammer" start of day reset

 * @ioc: per adapter object

 *

 * Return: 0 for success, non-zero for failure.

		/* Write magic sequence to WriteSequence register

		 * Loop until in diagnostic mode

 wait 100 msec */

This delay allows the chip PCIe hardware time to finish reset tasks*/

 Approximately 300 second max wait */

/**

 * mpt3sas_base_make_ioc_ready - put controller in READY state

 * @ioc: per adapter object

 * @type: FORCE_BIG_HAMMER or SOFT_RESET

 *

 * Return: 0 for success, non-zero for failure.

 if in RESET state, it should move to READY state shortly */

		/*

		 * if host reset is invoked while watch dog thread is waiting

		 * for IOC state to be changed to Fault state then driver has

		 * to wait here for CoreDump state to clear otherwise reset

		 * will be issued to the FW and FW move the IOC state to

		 * reset state without copying the FW logs to coredump region.

/**

 * _base_make_ioc_operational - put controller in OPERATIONAL state

 * @ioc: per adapter object

 *

 * Return: 0 for success, non-zero for failure.

 clean the delayed target reset list */

 hi-priority queue */

 internal queue */

 initialize Reply Free Queue */

 initialize reply queues */

 initialize Reply Post Free Queue */

		/*

		 * If RDPQ is enabled, switch to the next allocation.

		 * Otherwise advance within the contiguous region.

		/*

		 * No need to check IOC state for fault state & issue

		 * diag reset during host reset. This check is need

		 * only during driver load time.

 initialize reply free host index */

 initialize reply post host index */

 scan_start and scan_finished support */

/**

 * mpt3sas_base_free_resources - free resources controller resources

 * @ioc: per adapter object

 synchronizing freeing resource with pci_access_mutex lock */

/**

 * mpt3sas_base_attach - attach controller instance

 * @ioc: per adapter object

 *

 * Return: 0 for success, non-zero for failure.

 setup cpu_msix_table */

		/*

		 * In SAS3.0,

		 * SCSI_IO, SMP_PASSTHRU, SATA_PASSTHRU, Target Assist, and

		 * Target Status - all require the IEEE formatted scatter gather

		 * elements.

	/*

	 * These function pointers for other requests that don't

	 * the require IEEE scatter gather elements.

	 *

	 * For example Configuration Pages and SAS IOUNIT Control don't.

 allocate memory pd handle bitmask list */

 allocate memory for pending OS device add list */

 base internal command bits */

 port_enable command bits */

 transport internal command bits */

 scsih internal command bits */

 task management internal command bits */

 config page internal command bits */

 ctl module internal command bits */

 here we enable the events we care about */

	/*

	 * Copy current copy of IOCFacts in prev_fw_facts

	 * and it will be used during online firmware upgrade.

/**

 * mpt3sas_base_detach - remove controller instance

 * @ioc: per adapter object

/**

 * _base_pre_reset_handler - pre reset handler

 * @ioc: per adapter object

/**

 * _base_clear_outstanding_mpt_commands - clears outstanding mpt commands

 * @ioc: per adapter object

/**

 * _base_clear_outstanding_commands - clear all outstanding commands

 * @ioc: per adapter object

/**

 * _base_reset_done_handler - reset done handler

 * @ioc: per adapter object

/**

 * mpt3sas_wait_for_commands_to_complete - reset controller

 * @ioc: Pointer to MPT_ADAPTER structure

 *

 * This function is waiting 10s for all pending commands to complete

 * prior to putting controller in reset.

 pending command count */

 wait for pending commands to complete */

/**

 * _base_check_ioc_facts_changes - Look for increase/decrease of IOCFacts

 *     attributes during online firmware upgrade and update the corresponding

 *     IOC variables accordingly.

 *

 * @ioc: Pointer to MPT_ADAPTER structure

/**

 * mpt3sas_base_hard_reset_handler - reset controller

 * @ioc: Pointer to MPT_ADAPTER structure

 * @type: FORCE_BIG_HAMMER or SOFT_RESET

 *

 * Return: 0 for success, non-zero for failure.

 wait for an active reset in progress to complete */

	/* If this hard reset is called while port enable is active, then

	 * there is no reason to call make_ioc_operational

/*

 * Scsi Host Layer for MPT (Message Passing Technology) based controllers

 *

 * Copyright (C) 2012-2014  LSI Corporation

 * Copyright (C) 2013-2015 Avago Technologies

 *  (mailto: MPT-FusionLinux.pdl@avagotech.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License

 * as published by the Free Software Foundation; either version 2

 * of the License, or (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * NO WARRANTY

 * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 * solely responsible for determining the appropriateness of using and

 * distributing the Program and assumes all risks associated with its

 * exercise of rights under this Agreement, including but not limited to

 * the risks and costs of program errors, damage to or loss of data,

 * programs or equipment, and unavailability or interruption of operations.



 * DISCLAIMER OF LIABILITY

 * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES



 * You should have received a copy of the GNU General Public License

 * along with this program.

/**

 * _warpdrive_disable_ddio - Disable direct I/O for all the volumes

 * @ioc: per adapter object

/**

 * mpt3sas_get_num_volumes - Get number of volumes in the ioc

 * @ioc: per adapter object

/**

 * mpt3sas_init_warpdrive_properties - Set properties for warpdrive direct I/O.

 * @ioc: per adapter object

 * @raid_device: the raid_device object

	/*

	 * WARPDRIVE:If number of physical disks in a volume exceeds the max pds

	 * assumed for WARPDRIVE, disable direct I/O

 Disable direct I/O if member drive lba exceeds 4 bytes */

	/*

	 * Assumption for WD: Direct I/O is not supported if the volume is

	 * not RAID0

	/*

	 * WARPDRIVE: Though the following fields are not used for direct IO,

	 * stored for future purpose:

/**

 * mpt3sas_setup_direct_io - setup MPI request for WARPDRIVE Direct I/O

 * @ioc: per adapter object

 * @scmd: pointer to scsi command object

 * @raid_device: pointer to raid device data structure

 * @mpi_request: pointer to the SCSI_IO reqest message frame

 Return unless IO falls within a stripe */

/*

 *  linux/drivers/scsi/esas2r/esas2r_flash.c

 *      For use with ATTO ExpressSAS R6xx SAS/SATA RAID controllers

 *

 *  Copyright (c) 2001-2013 ATTO Technology, Inc.

 *  (mailto:linuxdrivers@attotech.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License

 * as published by the Free Software Foundation; either version 2

 * of the License, or (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * NO WARRANTY

 * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 * solely responsible for determining the appropriateness of using and

 * distributing the Program and assumes all risks associated with its

 * exercise of rights under this Agreement, including but not limited to

 * the risks and costs of program errors, damage to or loss of data,

 * programs or equipment, and unavailability or interruption of operations.

 *

 * DISCLAIMER OF LIABILITY

 * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES

 *

 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write to the Free Software

 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,

 * USA.

 local macro defs */

 signature          */

 version            */

 checksum           */

 max_lun_for_target */

 pci_latency        */

 options1           */

 options2           */

 int_coalescing     */

 cmd_throttle       */

 dev_wait_time      */

 dev_wait_count     */

 spin_up_delay      */

 ssp_align_rate     */

 sas_addr           */

 phy_speed          */

 SAS multiplexing   */

 phy_flags          */

 sort_type          */

 dpm_reqcmd_lmt     */

 dpm_stndby_time    */

 dpm_active_time    */

 phy_target_id      */

 virt_ses_mode      */

 read_write_mode    */

 link down timeout  */

 reserved           */

 Interrupt callback to process FM API write requests. */

 Last request was successful.  See what to do now. */

		/*

		 * All done. call the real callback to complete the FM API

		 * request.  We should only get here if a BEGINW or WRITE

		 * operation failed.

/*

 * Build a flash request based on the flash context.  The request status

 * is filled in on an error.

 calculate the checksum */

	/*

	 * remember the length we asked for.  we have to keep track of

	 * the current amount done so we know how much to compare when

	 * doing the verification phase.

 setup the S/G context to build the S/G table  */

 update the flsh_addr to the next one to write to  */

 determine the method to process the flash request */

	/*

	 * assume we have more to do.  if we return with the status set to

	 * RS_PENDING, FM API tasks will continue.

 not suppported for now */;

  boot image fixer uppers called before downloading the image. */

 Recalculate the checksum in the PNP header if there  */

 Identifier - dword that starts at byte 10 */

 Checksum - byte 9 */

 Recalculate the checksum needed by the PC */

 Complete a FM API request with the specified status. */

 Process each phase of the flash download process. */

 If the previous operation failed, just return. */

	/*

	 * If an upload just completed and the compare length is non-zero,

	 * then we just read back part of the image we just wrote.  verify the

	 * section and continue reading until the entire image is verified.

 start of the whole gob     */

 start of the current image */

 end of the current image   */

 where we are now           */

		/*

		 * NOTE - curr_len is the exact count of bytes for the read

		 *        even when the end is read and its not a full buffer

 # left to compare    */

 Update fc and determine the length for the next upload */

	/*

	 * This code uses a 'while' statement since the next component may

	 * have a length = zero.  This can happen since some components are

	 * not required.  At the end of this 'while' we set up the length

	 * for the next request and therefore sgc.length can be = 0.

 the BIOS image is written next */

			/*

			 * The BIOS image has been written - read it and

			 * verify it

			/*

			 * Mark the component header status for the image

			 * completed

 The MAC image is written next */

 The MAC image has been written - read and verify */

			/*

			 * Mark the component header status for the image

			 * completed

 The EFI image is written next */

 The EFI image has been written - read and verify */

			/*

			 * Mark the component header status for the image

			 * completed

 The CFG image is written next */

 The CFG image has been written - read and verify */

			/*

			 * Mark the component header status for the image

			 * completed

			/*

			 * The download is complete.  If in degraded mode,

			 * attempt a chip reset.

 Update the type of boot image on the card */

 If verifying, don't try reading more than what's there */

 Build the request to perform the next action */

 Determine the flash image adaptyp for this adapter */

 use the device ID to get the correct adap_typ for this HBA */

 Size of config + copyright + flash_ver images, 0 for failure. */

 See if we are comparing the size to the specified length */

 Verify that the boot image is valid */

 The sum of all the WORDS of the image */

/*

 * Verify the flash image structure.  The following verifications will

 * be performed:

 *              1)  verify the fi_version is correct

 *              2)  verify the checksum of the entire image.

 *              3)  validate the adap_typ, action and length fields.

 *              4)  validate each component header. check the img_type and

 *                  length fields

 *              5)  validate each component image.  validate signatures and

 *                  local checksums

 Verify the length - length must even since we do a word checksum */

 Get adapter type and verify type in flash image */

	/*

	 * Loop through each component and verify the img_type and length

	 * fields.  Keep a running count of the sizes sooze we can verify total

	 * size to additive size.

		/*

		 * Verify that the component header has the same index as the

		 * image type.  The headers must be ordered correctly

 Test if component image is present  */

 Image is present - verify the image */

 Test if component image is present */

 Image is present - verify the image */

 Compare fi->length to the sum of ch->length fields */

 Compute the checksum - it should come out zero */

 Fill in the FS IOCTL response data from a completed request. */

 Prepare an FS IOCTL request to be sent to the firmware. */

 Disable chip interrupts awhile */

 Issue the request to the firmware */

 Now wait for the firmware to process it */

 Got a doorbell interrupt.  Check for the function */

			/*

			 * Iimeout.  If we were requesting flash access,

			 * indicate we are done so the firmware knows we gave

			 * up.  If this was a REQ, we also need to re-enable

			 * chip interrupts.

 if we're done, re-enable chip interrupts */

 Try to acquire access to the flash */

 Release flash access */

/*

 * Find the type of boot image type that is currently in the flash.

 * The chip only has a 64 KB PCI-e expansion ROM

 * size so only one image can be flashed at a time.

 Start at the base of the boot images and look for a valid image */

			/*

			 * So we have an EFI image.  There are several types

			 * so see which architecture we have.

 jump to the next image */

/*

 *  Read and validate current NVRAM parameters by accessing

 *  physical NVRAM directly.  if currently stored parameters are

 *  invalid, use the defaults.

 Interrupt callback to process NVRAM completions. */

 last request was successful.  see what to do now. */

 update the NVRAM state */

/*

 * Write the contents of nvram to the adapter's physical NVRAM.

 * The cached copy of the NVRAM is also updated.

 check the validity of the settings */

 write the NVRAM */

 Validate the cached NVRAM.  if the NVRAM is invalid, load the defaults. */

/*

 * Set the cached NVRAM to defaults.  note that this function sets the default

 * NVRAM when it has been determined that the physical NVRAM is invalid.

 * In this case, the SAS address is fabricated.

	/*

	 * in case we are copying the defaults into the adapter, copy the SAS

	 * address out first.

 flag was already set */

 Download the components */

 Verify the format of the flash image */

 Adjust the BIOS fields that are dependent on the HBA */

 Adjust the EFI fields that are dependent on the HBA */

		/*

		 * Since the image was just modified, compute the checksum on

		 * the modified image.  First update the CRC for the composite

		 * expansion ROM image.

 Disable the heartbeat */

 Now start up the download sequence */

 Setup the callback address */

 Get upload sizes */

 Report the type of boot image in the rel_version string */

 Build the component headers */

 Upload the components */

	/*

	 * If we make it here, fc has been setup to do the first task.  Call

	 * load_image to format the request, start it, and get out.  The

	 * interrupt code will call the callback when the first message is

	 * complete.

/*

 *  linux/drivers/scsi/esas2r/esas2r_main.c

 *      For use with ATTO ExpressSAS R6xx SAS/SATA RAID controllers

 *

 *  Copyright (c) 2001-2013 ATTO Technology, Inc.

 *  (mailto:linuxdrivers@attotech.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License

 * as published by the Free Software Foundation; either version 2

 * of the License, or (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * NO WARRANTY

 * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 * solely responsible for determining the appropriateness of using and

 * distributing the Program and assumes all risks associated with its

 * exercise of rights under this Agreement, including but not limited to

 * the risks and costs of program errors, damage to or loss of data,

 * programs or equipment, and unavailability or interruption of operations.

 *

 * DISCLAIMER OF LIABILITY

 * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES

 *

 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write to the Free Software

 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,

 * USA.

 global definitions */

 override max LUN and max target id */

 we can handle 16-byte CDbs */

 set to bus master for BIOses that don't do it for us */

 Add sysfs binary files */

 verify valid parameters */

 set up other globals */

 Handle ioctl calls to "/proc/scsi/esas2r/ATTOnode" */

www.attotech.com\n"

	/*

	 * if we haven't done so already, register as a char driver

	 * and stick a node under "/proc/scsi/esas2r/ATTOnode"

 Callback for building a request scatter/gather list */

		/*

		 * the normal case: caller used all bytes from previous call, so

		 * expected offset is the same as the current offset.

 retrieve next segment, except for first time */

 advance current segment */

 save the total # bytes returned to caller so far */

		/*

		 * caller did not use all bytes from previous call. need to

		 * compute the address based on current segment.

 calculate PA based on prev segment address and offsets */

 re-calculate length based on offset */

 if ( sgc->cur_offset > sgc->exp_offset ) */

		   /*

		    * we don't expect the caller to skip ahead.

		    * cur_offset will never exceed the len we return

 Assume success, if it fails we will fix the result later. */

/*

 * Searches the specified queue for the specified queue for the command

 * to abort.

 *

 * Return 0 on failure, 1 if command was not found, 2 if command was found

 Found the request.  See what to do with it. */

				/*

				 * We are searching the active queue, which

				 * means that we need to send an abort request

				 * to the firmware.

 Failure */

				/*

				 * Task management request must be formatted

				 * with a lock held.

				/*

				 * The request is pending but not active on

				 * the firmware.  Just free it now and we'll

				 * report the successful abort below.

 Not found */

 found */

	/*

	 * Run through the defer and active queues looking for the request

	 * to abort.

		/*

		 * the request is already active, so we need to tell

		 * the firmware to abort it and wait for the response.

		/*

		 * Once we get here, the original request will have been

		 * completed by the firmware and the abort request will have

		 * been cleaned up.  we're done!

	/*

	 * If we get here, either we found the inactive request and

	 * freed it, or we didn't find it at all.  Either way, success!

 above call sets the AF_OS_RESET flag.  wait for it to clear. */

 Task management cmd completed right away, need to free it. */

		/*

		 * Wait for firmware to complete the request.  Completion

		 * callback will free it.

		/*

		 * Busy, probably because we are flashing.  Wait a bit and

		 * try again.

 Don't log inquiry underruns */

 Read a block of data from chip memory */

 Run tasklet to handle stuff outside of interrupt context. */

/*

 * Firmware events need to be handled outside of interrupt context

 * so we schedule a delayed_work to handle them.

/*

 * Sends a firmware asynchronous event to anyone who happens to be

 * listening on the defined ATTO VDA event ports.

 do nothing */

 Translate status to a Linux SCSI mid-layer error code */

	/*

	 * NOTE: SCSI mid-layer wants a good status for a SCSI error, because

	 *       it will check the scsi_stat value in the completion anyway.

 everything else is just an error. */

/*

 *  linux/drivers/scsi/esas2r/esas2r_int.c

 *      esas2r interrupt handling

 *

 *  Copyright (c) 2001-2013 ATTO Technology, Inc.

 *  (mailto:linuxdrivers@attotech.com)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  This program is free software; you can redistribute it and/or modify

 *  it under the terms of the GNU General Public License as published by

 *  the Free Software Foundation; version 2 of the License.

 *

 *  This program is distributed in the hope that it will be useful,

 *  but WITHOUT ANY WARRANTY; without even the implied warranty of

 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *  GNU General Public License for more details.

 *

 *  NO WARRANTY

 *  THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 *  CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 *  LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 *  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 *  solely responsible for determining the appropriateness of using and

 *  distributing the Program and assumes all risks associated with its

 *  exercise of rights under this Agreement, including but not limited to

 *  the risks and costs of program errors, damage to or loss of data,

 *  programs or equipment, and unavailability or interruption of operations.

 *

 *  DISCLAIMER OF LIABILITY

 *  NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 *  DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 *  USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 *  HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES

 *

 *  You should have received a copy of the GNU General Public License

 *  along with this program; if not, write to the Free Software

 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 Local function prototypes */

/*

 * Poll the adapter for interrupts and service them.

 * This function handles both legacy interrupts and MSI.

 clear the interrupt */

/*

 * Legacy and MSI interrupt handlers.  Note that the legacy interrupt handler

 * schedules a TASKLET to process events, whereas the MSI handler just

 * processes interrupt events directly.

 clear the interrupt */

 clear the interrupt */

	/*

	 * Work around a chip bug and force a new MSI to be sent if one is

	 * still pending.

	/*

	 * For I/O requests, only copy the response if an error

	 * occurred and setup a callback to do error processing.

 Any of these are a good result. */

 Get the outbound limit and pointers */

 If we don't have anything to process, get out */

 Make sure the firmware is healthy */

 Verify the handle range */

 Get the request for this handle */

 Get the completion status */

			/*

			 * Copy the outbound completion struct for non-I/O

			 * requests.

 Queue the request for completion. */

/*

 * Perform all deferred processes for the adapter.  Deferred

 * processes can only be done while the current interrupt

 * disable_cnt for the adapter is zero.

	/*

	 * startreqs is used to control starting requests

	 * that are on the deferred queue

	 *  = 0 - do not start any requests

	 *  = 1 - can start discovery requests

	 *  = 2 - can start any request

 Clear off the completed list to be processed later. */

	/*

	 * If we can start requests then traverse the defer queue

	 * looking for requests to start or complete

			/*

			 * Process discovery and OS requests separately.  We

			 * can't hold up discovery requests when discovery is

			 * pending.  In general, there may be different sets of

			 * conditions for starting different types of requests.

				/*

				 * Flashing could have been set by last local

				 * start

/*

 * Process an adapter reset (or one that is about to happen)

 * by making sure all outstanding requests are completed that

 * haven't been already.

 abort the active discovery, if any.   */

	/*

	 * just clear the interrupt callback for now.  it will be dequeued if

	 * and when we find it on the active queue and we don't want the

	 * callback called.  also set the dummy completion callback in case we

	 * were doing an I/O request.

 Reset the read and write pointers */

 Kill all the requests on the active list */

 kill all the requests on the deferred queue */

	/*

	 * Make sure we don't get attempt more than 3 resets

	 * when the uptime between resets does not exceed one

	 * minute.  This will stop any situation where there is

	 * really something wrong with the hardware.  The way

	 * this works is that we start with uptime ticks at 0.

	 * Each time we do a reset, we add 20 seconds worth to

	 * the count.  Each time a timer tick occurs, as long

	 * as a chip reset is not pending, we decrement the

	 * tick count.  If the uptime ticks ever gets to 60

	 * seconds worth, we disable the adapter from that

	 * point forward.  Three strikes, you're out.

		/*

		 * Ok, some kind of hard failure.  Make sure we

		 * exit this loop with chip interrupts

		 * permanently disabled so we don't lock up the

		 * entire system.  Also flag degraded mode to

		 * prevent the heartbeat from trying to recover.

			/*

			 * Only disable interrupts if this is

			 * the first reset attempt.

			/*

			 * Don't reset the chip on the first

			 * deferred power up attempt.

 Kick off the reinitialization */

 Remove devices now that I/O is cleaned up. */

		/*

		 * Balance the enable in esas2r_initadapter_hw.

		 * Esas2r_power_down already took care of it for power

		 * management.

 Reinitialize the chip. */

 Recovery from power management. */

 Chip reset during normal power up */

 Deferred power up complete. */

 Recovery from online chip reset. */

 Chip reset during driver load */

 Chip reset after driver load */

		/*

		 * Clear this flag last!  this indicates that the chip has been

		 * reset already during initialization.

 Perform deferred tasks when chip interrupts are disabled */

 First clear the doorbell bits */

			/* Silently ignore the rest and let the apps deal with

			 * them.

 Now requeue it. */

 Send an asynchronous event for a chip reset or power management. */

 See about possible sense data */

 Report LUNS data has changed */

 See if we setup a callback to do special processing */

/*

 *  linux/drivers/scsi/esas2r/esas2r_init.c

 *      For use with ATTO ExpressSAS R6xx SAS/SATA RAID controllers

 *

 *  Copyright (c) 2001-2013 ATTO Technology, Inc.

 *  (mailto:linuxdrivers@attotech.com)mpt3sas/mpt3sas_trigger_diag.

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License

 * as published by the Free Software Foundation; either version 2

 * of the License, or (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * NO WARRANTY

 * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 * solely responsible for determining the appropriateness of using and

 * distributing the Program and assumes all risks associated with its

 * exercise of rights under this Agreement, including but not limited to

 * the risks and costs of program errors, damage to or loss of data,

 * programs or equipment, and unavailability or interruption of operations.

 *

 * DISCLAIMER OF LIABILITY

 * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES

 *

 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write to the Free Software

 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,

 * USA.

	/*

	 * Careful!  phys_addr and virt_addr may have been adjusted from the

	 * original allocation in order to return the desired alignment.  That

	 * means we have to use the original address (in esas2r_data) and size

	 * (esas2r_param) and calculate the original physical address based on

	 * the difference between the requested and actual allocation size.

 Set up interrupt mode based on the requested value */

 interrupts will be disabled until we are done with init */

	/*

	 * Disable chip interrupts to prevent spurious interrupts

	 * until we claim the IRQ.

		/*

		 * There are versions of firmware that do not handle the sync

		 * cache command correctly.  Stall here to ensure that the

		 * cache is lazily flushed.

 Remove sysfs binary files */

 Clean up interrupts */

 Following frees everything allocated via alloc_vda_req */

 Release/free allocated resources for specified adapters. */

 Set up interupt mode */

	/*

	 * Disable chip interrupts to prevent spurious interrupts until we

	 * claim the IRQ.

		/*

		 * Now that system interrupt(s) are claimed, we can enable

		 * chip interrupts.

 outbound list copy pointer */

 VDA request and buffer align */

/*

 * Determine the organization of the uncached data area and

 * finish initializing the adapter structure

 allocate requests for asynchronous events */

 allocate the S/G list memory descriptors */

 allocate the request table */

 initialize PCI configuration space */

	/*

	 * the thunder_stream boards all have a serial flash part that has a

	 * different base address on the AHB bus.

 Uncached Area */

 initialize the scatter/gather table pages */

 Allow the driver to load if the minimum count met. */

 compute the size of the lists */

 allocate the inbound list */

 allocate the outbound list */

 allocate the NVRAM structure */

 allocate the discovery buffer */

 allocate the outbound list copy pointer */

 update the caller's uncached memory area pointer */

 initialize the allocated memory */

 prime parts of the inbound list */

 init the AE requests */

 override the completion function */

 This code will verify that the chip is operational. */

	/*

	 * if the chip reset detected flag is set, we can bypass a bunch of

	 * stuff.

	/*

	 * BEFORE WE DO ANYTHING, disable the chip interrupts!  the boot driver

	 * may have left them enabled or we may be recovering from a fault.

	/*

	 * wait for the firmware to become ready by forcing an interrupt and

	 * waiting for a response.

			/*

			 * Give the firmware up to two seconds to enable

			 * register access after a reset.

			/*

			 * This driver supports version 0 and version 1 of

			 * the API

 purge any asynchronous events since we will repost them later */

	/*

	 * first things first, before we go changing any of these registers

	 * disable the communication lists.

 configure the communication list addresses */

 reset the read and write pointers */

 configure the interface select fields */

 finish configuring the communication lists */

	/*

	 * notify the firmware that we're done setting up the communication

	 * list registers.  wait here until the firmware is done configuring

	 * its lists.  it will signal that it is done by enabling the lists.

	/*

	 * flag whether the firmware supports the power down doorbell.  we

	 * determine this by reading the inbound doorbell enable mask.

	/*

	 * enable assertion of outbound queue and doorbell interrupts in the

	 * main interrupt cause register.

 Process the initialization message just completed and format the next one. */

 firmware interface overflows in y2106 */

		/*

		 * the 2.71 and earlier releases of R6xx firmware did not error

		 * unsupported config requests correctly.

/*

 * Perform initialization messages via the request queue.  Messages are

 * performed with interrupts disabled.

 Initialize the adapter chip */

 The firmware is ready. */

 Post all the async event requests */

 initialize discovery */

	/*

	 * wait for the device wait time to expire here if requested.  this is

	 * usually requested during initial driver load and possibly when

	 * resuming from a low power state.  deferred device waiting will use

	 * interrupts.  chip reset recovery always defers device waiting to

	 * avoid being in a TASKLET too long.

		/*

		 * Block Tasklets from getting scheduled and indicate this is

		 * polled discovery.

		/*

		 * Temporarily bring the disable count to zero to enable

		 * deferred processing.  Note that the count is already zero

		 * after the first initialization.

			/*

			 * Determine the need for a timer tick based on the

			 * delta time between this and the last iteration of

			 * this loop.  We don't use the absolute time because

			 * then we would have to worry about when nexttick

			 * wraps and currtime hasn't yet.

			/*

			 * Process any waiting discovery as long as the chip is

			 * up.  If a chip reset happens during initial polling,

			 * we have to make sure the timer tick processes the

			 * doorbell indicating the firmware is ready.

 Simulate a timer tick. */

 Time for a timer tick */

 Do any deferred processing */

	/*

	 * For cases where (a) the initialization messages processing may

	 * handle an interrupt for a port event and a discovery is waiting, but

	 * we are not waiting for devices, or (b) the device wait time has been

	 * exhausted but there is still discovery pending, start any leftover

	 * discovery in interrupt driven mode.

 Enable chip interrupts */

	/*

	 * Regardless of whether initialization was successful, certain things

	 * need to get done before we exit.

		/*

		 * Reinitialization was performed during the first

		 * initialization.  Only clear the chip reset flag so the

		 * original device polling is not cancelled.

 First initialization or a subsequent re-init is complete. */

 Enable deferred processing after the first initialization. */

	/*

	 * Before we reset the chip, save off the VDA core dump.  The VDA core

	 * dump is located in the upper 512KB of the onchip SRAM.  Make sure

	 * to not overwrite a previous crash that was saved.

 Reset the chip */

 Stall a little while to let the reset condition clear */

/*

 * Perform power management processing including managing device states, adapter

 * states, interrupts, and I/O.

		/*

		 * We are currently running OK and will be reinitializing later.

		 * increment the disable count to coordinate with

		 * esas2r_init_adapter.  We don't have to do this in degraded

		 * mode since we never enabled interrupts in the first place.

 wait for any VDA activity to clear before continuing */

		/*

		 * For versions of firmware that support it tell them the driver

		 * is powering down.

 Suspend I/O processing. */

 Remove devices now that I/O is cleaned up. */

/*

 * Perform power management processing including managing device states, adapter

 * states, interrupts, and I/O.

 reinitialize the adapter */

 send the reset asynchronous event */

 clear this flag after initialization. */

/*

 *  linux/drivers/scsi/esas2r/esas2r_targdb.c

 *      For use with ATTO ExpressSAS R6xx SAS/SATA RAID controllers

 *

 *  Copyright (c) 2001-2013 ATTO Technology, Inc.

 *  (mailto:linuxdrivers@attotech.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License

 * as published by the Free Software Foundation; either version 2

 * of the License, or (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * NO WARRANTY

 * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 * solely responsible for determining the appropriateness of using and

 * distributing the Program and assumes all risks associated with its

 * exercise of rights under this Agreement, including but not limited to

 * the risks and costs of program errors, damage to or loss of data,

 * programs or equipment, and unavailability or interruption of operations.

 *

 * DISCLAIMER OF LIABILITY

 * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES

 *

 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write to the Free Software

 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,

 * USA.

 these are invalid values, don't create the target entry. */

 see if we found this device before. */

/*

 *  linux/drivers/scsi/esas2r/esas2r_io.c

 *      For use with ATTO ExpressSAS R6xx SAS/SATA RAID controllers

 *

 *  Copyright (c) 2001-2013 ATTO Technology, Inc.

 *  (mailto:linuxdrivers@attotech.com)mpt3sas/mpt3sas_trigger_diag.

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License

 * as published by the Free Software Foundation; either version 2

 * of the License, or (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * NO WARRANTY

 * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 * solely responsible for determining the appropriateness of using and

 * distributing the Program and assumes all risks associated with its

 * exercise of rights under this Agreement, including but not limited to

 * the risks and costs of program errors, damage to or loss of data,

 * programs or equipment, and unavailability or interruption of operations.

 *

 * DISCLAIMER OF LIABILITY

 * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES

 *

 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write to the Free Software

 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,

 * USA.

 copy in the target ID. */

			/*

			 * Test if we want to report RS_SEL for missing target.

			 * Note that if AF_DISC_PENDING is set than this will

			 * go on the defer queue.

/*

 * Starts the specified request.  all requests have RS_PENDING set when this

 * routine is called.  The caller is usually esas2r_start_request, but

 * esas2r_do_deferred_processes will start request that are deferred.

 *

 * The caller must ensure that requests can be started.

 *

 * esas2r_start_request will defer a request if there are already requests

 * waiting or there is a chip reset pending.  once the reset condition clears,

 * esas2r_do_deferred_processes will call this function to start the request.

 *

 * When a request is started, it is placed on the active list and queued to

 * the controller.

	/*

	 * Calculate the inbound list entry location and the current state of

	 * toggle bit.

 update the toggle bit */

 Set the VDA request size if it was never modified */

 Update the write pointer */

/*

 * Build the scatter/gather list for an I/O request according to the

 * specifications placed in the s/g context.  The caller must initialize

 * context prior to the initial call by calling esas2r_sgc_init().

 if current length is more than what's left, stop there */

 limit to a round number less than the maximum length */

			/*

			 * Save the remainder of the split.  Whenever we limit

			 * an entry we come back around to build entries out

			 * of the leftover.  We do this to prevent multiple

			 * calls to the get_phys_addr() function for an SGE

			 * that is too large.

 See if we need to allocate a new SGL */

			/*

			 * If no SGls are available, return failure.  The

			 * caller can call us later with the current context

			 * to pick up here.

 Calculate the length of the last SGE filled in */

			/*

			 * Copy the last SGE filled in to the first entry of

			 * the new SGL to make room for the chain entry.

 Figure out the new curr pointer in the new segment */

 Set the limit pointer and build the chain entry */

			/*

			 * Now, if there was a previous chain entry, then

			 * update it to contain the length of this segment

			 * and size of this chain.  otherwise this is the

			 * first SGL, so set the chain_offset in the request.

				/*

				 * This is the first SGL, so set the

				 * chain_offset and the VDA request size in

				 * the request.

			/*

			 * Remember this so when we get a new SGL filled in we

			 * can update the length of this chain entry.

 Now link the new SGL onto the primary request. */

 Update last one filled in */

 Build the new SGE and update the S/G context */

		/*

		 * Check if we previously split an entry.  If so we have to

		 * pick up where we left off.

 Mark the end of the SGL */

	/*

	 * If there was a previous chain entry, update the length to indicate

	 * the length of this last segment.

		/*

		 * The entire VDA request was not used so lets

		 * set the size of the VDA request to be DMA'd

		/*

		 * Only update the request size if it is bigger than what is

		 * already there.  We can come in here twice for some management

		 * commands.

/*

 * Create PRD list for each I-block consumed by the command. This routine

 * determines how much data is required from each I-block being consumed

 * by the command. The first and last I-blocks can be partials and all of

 * the I-blocks in between are for a full I-block of data.

 *

 * The interleave size is used to determine the number of bytes in the 1st

 * I-block and the remaining I-blocks are what remeains.

 Get the next address/length pair */

 If current length is more than what's left, stop there */

 Limit to a round number less than the maximum length */

			/*

			 * Save the remainder of the split.  whenever we limit

			 * an entry we come back around to build entries out

			 * of the leftover.  We do this to prevent multiple

			 * calls to the get_phys_addr() function for an SGE

			 * that is too large.

 See if we need to allocate a new SGL */

				/*

				 * We only have 1 PRD entry left.

				 * It can be placed where the chain

				 * entry would have gone

 Build the simple SGE */

 Adjust length related fields */

 We use the reserved chain entry for data */

				/*

				 * Fill # of entries of current SGL in previous

				 * chain the length of this current SGL may not

				 * full.

			/*

			 * If no SGls are available, return failure.  The

			 * caller can call us later with the current context

			 * to pick up here.

			/*

			 * Link the new SGL onto the chain

			 * They are in reverse order

			/*

			 * An SGL was just filled in and we are starting

			 * a new SGL. Prime the chain of the ending SGL with

			 * info that points to the new SGL. The length gets

			 * filled in when the new SGL is filled or ended

			/*

			 * Start a new segment.

			 * Take one away and save for chain SGE

 Build the simple SGE */

 Used another element.  Point to the next one */

 Adjust length related fields */

		/*

		 * Check if we previously split an entry.  If so we have to

		 * pick up where we left off.

	/*

	 * extract LBA from command so we can determine

	 * the I-Block boundary

 Determine size of 1st I-block PRD list       */

 Chk if the 1st iblk chain starts at base of Iblock */

 get our starting chain address   */

 create all of the I-block PRD lists          */

 increment to next I-Block    */

 go build the next I-Block PRD list   */

 figure out the size used of the VDA request */

	/*

	 * only update the request size if it is bigger than what is

	 * already there.  we can come in here twice for some management

	 * commands.

 Wait before accessing registers */

		/*

		 * The last reset failed so try again. Reset

		 * processing will give up after three tries.

 We can now see if the firmware is ready */

 Driver supports API version 0 and 1 */

 This function must be called once per timer tick */

 count down the uptime */

/*

 * Send the specified task management function to the target and LUN

 * specified in rqaux.  in addition, immediately abort any commands that

 * are queued but not sent to the device according to the rules specified

 * by the task management function.

 search the defer queue looking for requests for the device */

 target reset */

 Found a request affected by the task management */

				/*

				 * The request is pending or waiting.  We can

				 * safelycomplete the request now.

 Send the task management request to the firmware */

 Assume success.  if there are active requests, return busy */

 target reset */

		/*

		 * The request timed out, but we could not abort it because a

		 * chip reset occurred.  Return busy status.

/*

 *  linux/drivers/scsi/esas2r/esas2r_ioctl.c

 *      For use with ATTO ExpressSAS R6xx SAS/SATA RAID controllers

 *

 *  Copyright (c) 2001-2013 ATTO Technology, Inc.

 *  (mailto:linuxdrivers@attotech.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License

 * as published by the Free Software Foundation; either version 2

 * of the License, or (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * NO WARRANTY

 * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 * solely responsible for determining the appropriateness of using and

 * distributing the Program and assumes all risks associated with its

 * exercise of rights under this Agreement, including but not limited to

 * the risks and costs of program errors, damage to or loss of data,

 * programs or equipment, and unavailability or interruption of operations.

 *

 * DISCLAIMER OF LIABILITY

 * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES

 *

 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write to the Free Software

 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,

 * USA.

/*

 * Buffered ioctl handlers.  A buffered ioctl is one which requires that we

 * allocate a DMA-able memory area to communicate with the firmware.  In

 * order to prevent continually allocating and freeing consistent memory,

 * we will allocate a global buffer the first time we need it and re-use

 * it for subsequent ioctl calls that require it.

 Callbacks for building scatter/gather lists for FM API requests */

 Handle EXPRESS_IOCTL_RW_FIRMWARE ioctl with img_type = FW_IMG_FM_API. */

 Now wait around for it to complete. */

 Callback for building scatter/gather lists for buffered ioctls */

 allocate a buffer or use the existing buffer. */

 free the too-small buffer and get a new one */

 completed immediately, no need to wait */

 now wait around for it to complete. */

 SMP ioctl support */

 CSMI ioctl support */

 Now call the original completion callback. */

 Tunnel a CSMI IOCTL to the back end driver for processing. */

	/*

	 * Always usurp the completion callback since the interrupt callback

	 * mechanism may be used.

 Byte 1 is intentionally skipped */

 make sure the device is present */

 make sure the target is present */

 fill in the result */

 make sure the target is present */

 ATTO HBA ioctl support */

 Tunnel an ATTO HBA IOCTL to the back end driver for processing. */

 Update the target ID to the next one present. */

 Done, call the completion callback. */

 Size is zero if a core dump isn't present */

 Always return all the info we can. */

 Return zero length buffer if core dump not present */

 Finish request initialization */

 NOTE: we ignore spt->timeout */

		/*

		 * always usurp the completion callback since the interrupt

		 * callback mechanism may be used.

 update the target ID to the next one present. */

 update the target ID to the next one present. */

 now wait around for it to complete. */

 done, check the status. */

 This function only cares about ATTO-specific ioctls (atto_express_ioctl) */

 verify the signature */

 assume success */

	/*

	 * handle EXPRESS_IOCTL_GET_CHANNELS

	 * without paying attention to channel

 get the channel */

 Always copy the buffer back, if only to pick up the status */

 Handle a call to read firmware. */

 if the cached header is a status, simply copy it over and return. */

	/*

	 * if the cached header is a command, do it if at

	 * offset 0, otherwise copy the pieces.

 copy header over */

 when done, release the buffer */

 Handle a call to write firmware. */

 assume version 0 flash image */

 validate the version field first */

 See if its a version 1 flash image */

 If this is the start, the header must be full and valid. */

 Make sure the size is reasonable. */

		/*

		 * If this is a write command, allocate memory because

		 * we have to cache everything. otherwise, just cache

		 * the header, because the read op will do the command.

			/*

			 * Store the command, so there is context on subsequent

			 * calls.

 Save the command, result will be picked up on read */

			/*

			 * Pretend we took the whole buffer,

			 * so we don't get bothered again.

	/*

	 * We only get here on a download command, regardless of offset.

	 * the chunks written by the system need to be cached, and when

	 * the final one arrives, issue the fmapi command.

		/*

		 * On a full upload, the system tries sending the whole buffer.

		 * there's nothing to do with it, so just drop it here, before

		 * trying to copy over into unallocated memory!

			/*

			 * Now copy the header result to be picked up by the

			 * next read

			/*

			 * Since the system has the data buffered, the only way

			 * this can leak is if a root user writes a program

			 * that writes a shorter buffer than it claims, and the

			 * copyin fails.

 Callback for the completion of a VDA request. */

 Scatter/gather callback for VDA requests */

 Handle a call to read a VDA command. */

		/*

		 * Presumeably, someone has already written to the vda_buffer,

		 * and now they are reading the node the response, so now we

		 * will actually issue the request to the chip and reply.

 allocate a request */

 now wait around for it to complete. */

 Handle a call to write a VDA command. */

	/*

	 * allocate memory for it, if not already done.  once allocated,

	 * we will keep it around until the driver is unloaded.

 Callback for the completion of an FS_API request.*/

 Scatter/gather callback for VDA requests */

 Handle a call to read firmware via FS_API. */

 If another flash request is already in progress, return. */

		/*

		 * Presumeably, someone has already written to the

		 * fs_api_buffer, and now they are reading the node the

		 * response, so now we will actually issue the request to the

		 * chip and reply. Allocate a request

 Set up the SGCONTEXT for to build the s/g table */

 Now wait around for it to complete. */

 Free the request and keep going */

 Pick up possible error code from above */

 Handle a call to write firmware via FS_API. */

		/*

		 * Special case, for BEGIN commands, the length field

		 * is lying to us, so just get enough for the header.

		/*

		 * Beginning a command.  We assume we'll get at least

		 * enough in the first write so we can look at the

		 * header and see how much we need to alloc.

 Allocate a buffer or use the existing buffer. */

 Free too-small buffer and get a new one */

/*

 *  linux/drivers/scsi/esas2r/esas2r_vda.c

 *      esas2r driver VDA firmware interface functions

 *

 *  Copyright (c) 2001-2013 ATTO Technology, Inc.

 *  (mailto:linuxdrivers@attotech.com)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  This program is free software; you can redistribute it and/or modify

 *  it under the terms of the GNU General Public License as published by

 *  the Free Software Foundation; version 2 of the License.

 *

 *  This program is distributed in the hope that it will be useful,

 *  but WITHOUT ANY WARRANTY; without even the implied warranty of

 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *  GNU General Public License for more details.

 *

 *  NO WARRANTY

 *  THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 *  CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 *  LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 *  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 *  solely responsible for determining the appropriateness of using and

 *  distributing the Program and assumes all risks associated with its

 *  exercise of rights under this Agreement, including but not limited to

 *  the risks and costs of program errors, damage to or loss of data,

 *  programs or equipment, and unavailability or interruption of operations.

 *

 *  DISCLAIMER OF LIABILITY

 *  NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 *  DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 *  USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 *  HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES

 *

 *  You should have received a copy of the GNU General Public License

 *  along with this program; if not, write to the Free Software

 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 Prepare a VDA IOCTL request to be sent to the firmware. */

		/*

		 * build the data payload SGL here first since

		 * esas2r_sgc_init() will modify the S/G list offset for the

		 * management SGL (which is built below where the data SGL is

		 * usually built).

 Setup the length so building the payload SGL works */

		/*

		 * Now that the payload SGL is built, if any, setup to build

		 * the management SGL.

 Finish initializing the management request. */

 Build a flash VDA request. */

 Build a VDA management request. */

 Build a VDA asyncronous event (AE) request. */

 Build a VDA CLI request. */

 Build a VDA IOCTL request. */

 Build a VDA configuration request. */

 since the data buffer is separate clear that too */

	/*

	 * Setup next and prev pointer in case the request is not going through

	 * esas2r_start_request().

/*

 *  linux/drivers/scsi/esas2r/esas2r_disc.c

 *      esas2r device discovery routines

 *

 *  Copyright (c) 2001-2013 ATTO Technology, Inc.

 *  (mailto:linuxdrivers@attotech.com)

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

/*

 *  This program is free software; you can redistribute it and/or modify

 *  it under the terms of the GNU General Public License as published by

 *  the Free Software Foundation; version 2 of the License.

 *

 *  This program is distributed in the hope that it will be useful,

 *  but WITHOUT ANY WARRANTY; without even the implied warranty of

 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 *  GNU General Public License for more details.

 *

 *  NO WARRANTY

 *  THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 *  CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 *  LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 *  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 *  solely responsible for determining the appropriateness of using and

 *  distributing the Program and assumes all risks associated with its

 *  exercise of rights under this Agreement, including but not limited to

 *  the risks and costs of program errors, damage to or loss of data,

 *  programs or equipment, and unavailability or interruption of operations.

 *

 *  DISCLAIMER OF LIABILITY

 *  NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 *  DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 *  USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 *  HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES

 *

 *  You should have received a copy of the GNU General Public License

 *  along with this program; if not, write to the Free Software

 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

 Miscellaneous internal discovery routines */

 Internal discovery routines that process the states */

	/*

	 * If we are doing chip reset or power management processing, always

	 * wait for devices.  use the NVRAM device count if it is greater than

	 * previously discovered devices.

			/* Don't bother waiting if there is nothing to wait

			 * for.

			/*

			 * Set the device wait count to what was previously

			 * found.  We don't care if the user only configured

			 * a time because we know the exact count to wait for.

			 * There is no need to honor the user's wishes to

			 * always wait the full time.

			/*

			 * bump the minimum wait time to 15 seconds since the

			 * default is 3 (system boot or the boot driver usually

			 * buys us more time).

 service any pending interrupts first */

	/*

	 * now, interrupt processing may have queued up a discovery event.  go

	 * see if we have one to start.  we couldn't start it in the ISR since

	 * polled discovery would cause a deadlock.

 wait for the current discovery request to complete. */

 check to see if we should be waiting for devices */

		/*

		 * Wait until the device wait time is exhausted or the device

		 * wait count is satisfied.

 After three seconds of waiting, schedule a scan. */

		/*

		 * We are done waiting...we think.  Adjust the wait time to

		 * consume events after the count is met.

 If we haven't done a full scan yet, do it now. */

		/*

		 * Now, if there is still time left to consume events, continue

		 * waiting.

 We want to stop waiting for devices. */

		/*

		 * Polled discovery is still pending so continue the active

		 * discovery until it is done.  At that point, we will stop

		 * polled discovery and transition to interrupt driven

		 * discovery.

		/*

		 * Done waiting for devices.  Note that we get here immediately

		 * after deferred waiting completes because that is interrupt

		 * driven; i.e. There is no transition.

		/*

		 * We have deferred target state changes until now because we

		 * don't want to report any removals (due to the first arrival)

		 * until the device wait time expires.

 Initialize the discovery context */

	/*

	 * Don't start discovery before or during polled discovery.  if we did,

	 * we would have a deadlock if we are in the ISR already.

 If there is a discovery waiting, process it. */

			/*

			 * We are doing polled discovery, but we no longer want

			 * to wait for devices.  Stop polled discovery and

			 * transition to interrupt driven discovery.

 Discovery is complete. */

 Handle the discovery context */

 Decode the event code */

 Continue interrupt driven discovery */

 Device discovery/removal */

 Discovery is done...for now. */

 Start the next discovery. */

 Set the timeout to a minimum value. */

	/*

	 * Override the request type to distinguish discovery requests.  If we

	 * end up deferring the request, esas2r_disc_local_start_request()

	 * will be called to restart it.

 abort the current discovery */

 continue discovery if it's interrupt driven */

 go to the next group. */

 continue discovery if it's interrupt driven */

 continue discovery if it's interrupt driven */

 continue discovery if it's interrupt driven */

 format the request. */

 format the IOCTL data. */

 start it up. */

 Get the unique identifier. */

 Add the pass through target. */

 getting the back end data failed */

 getting the back end data failed */

 proceed to the next device. */

 continue discovery if it's interrupt driven */

 process removals. */

 remove the right target! */

 removals complete.  process arrivals. */

 done processing state changes. */

 clear this now in case more events come in. */

 setup the discovery context for adding this device. */

 determine the device type being added. */

 go to the next device. */

/*

 * When discovery is done, find all requests on defer queue and

 * test if they need to be modified. If a target is no longer present

 * then complete the request with RS_SEL. Otherwise, update the

 * target_id since after a hibernate it can be a different value.

 * VDA does not make passthrough target IDs persistent.

 update virt_targ_id in any outstanding esas2r_requests  */

/*

 *  linux/drivers/scsi/esas2r/esas2r_log.c

 *      For use with ATTO ExpressSAS R6xx SAS/SATA RAID controllers

 *

 *  Copyright (c) 2001-2013 ATTO Technology, Inc.

 *  (mailto:linuxdrivers@attotech.com)

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License

 * as published by the Free Software Foundation; either version 2

 * of the License, or (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * NO WARRANTY

 * THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR

 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT

 * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,

 * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is

 * solely responsible for determining the appropriateness of using and

 * distributing the Program and assumes all risks associated with its

 * exercise of rights under this Agreement, including but not limited to

 * the risks and costs of program errors, damage to or loss of data,

 * programs or equipment, and unavailability or interruption of operations.

 *

 * DISCLAIMER OF LIABILITY

 * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY

 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND

 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR

 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE

 * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED

 * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES

 *

 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write to the Free Software

 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,

 * USA.

/*

 * this module within the driver is tasked with providing logging functionality.

 * the event_log_level module parameter controls the level of messages that are

 * written to the system log.  the default level of messages that are written

 * are critical and warning messages.  if other types of messages are desired,

 * one simply needs to load the module with the correct value for the

 * event_log_level module parameter.  for example:

 *

 * insmod <module> event_log_level=1

 *

 * will load the module and only critical events will be written by this module

 * to the system log.  if critical, warning, and information-level messages are

 * desired, the correct value for the event_log_level module parameter

 * would be as follows:

 *

 * insmod <module> event_log_level=3

 A shared buffer to use for formatting messages. */

 A lock to protect the shared buffer used for formatting messages. */

/*

 * translates an esas2r-defined logging event level to a kernel logging level.

 *

 * @param [in] level the esas2r-defined logging event level to translate

 *

 * @return the corresponding kernel logging level.

/*

 * the master logging function.  this function will format the message as

 * outlined by the formatting string, the input device information and the

 * substitution arguments and output the resulting string to the system log.

 *

 * @param [in] level  the event log level of the message

 * @param [in] dev    the device information

 * @param [in] format the formatting string for the message

 * @param [in] args   the substition arguments to the formatting string

 *

 * @return 0 on success, or -1 if an error occurred.

		/*

		 * format the level onto the beginning of the string and do

		 * some pointer arithmetic to move the pointer to the point

		 * where the actual message can be inserted.

		/*

		 * Put a line break at the end of the formatted string so that

		 * we don't wind up with run-on messages.

/*

 * formats and logs a message to the system log.

 *

 * @param [in] level  the event level of the message

 * @param [in] format the formating string for the message

 * @param [in] ...    the substitution arguments to the formatting string

 *

 * @return 0 on success, or -1 if an error occurred.

/*

 * formats and logs a message to the system log.  this message will include

 * device information.

 *

 * @param [in] level   the event level of the message

 * @param [in] dev     the device information

 * @param [in] format  the formatting string for the message

 * @param [in] ...     the substitution arguments to the formatting string

 *

 * @return 0 on success, or -1 if an error occurred.

/*

 * formats and logs a message to the system log.  this message will include

 * device information.

 *

 * @param [in] level   the event level of the message

 * @param [in] buf

 * @param [in] len

 *

 * @return 0 on success, or -1 if an error occurred.

/*

 * This file is part of the Chelsio FCoE driver for Linux.

 *

 * Copyright (c) 2008-2012 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 Default FW event queue entries. */

 Default MSI param level */

 FCoE function instances */

 FCoE Adapter types & its description */

 State machine forward declarations */

/*

 *	csio_hw_wait_op_done_val - wait until an operation is completed

 *	@hw: the HW module

 *	@reg: the register to check for completion

 *	@mask: a single-bit field within @reg that indicates completion

 *	@polarity: the value of the field when the operation is completed

 *	@attempts: number of check iterations

 *	@delay: delay in usecs between iterations

 *	@valp: where to store the value of the register at completion time

 *

 *	Wait until an operation is completed by checking a bit in a register

 *	up to @attempts times.  If @valp is not NULL the value of the register

 *	at the time it indicated completion is stored there.  Returns 0 if the

 *	operation completes and	-EAGAIN	otherwise.

/*

 *	csio_hw_tp_wr_bits_indirect - set/clear bits in an indirect TP register

 *	@hw: the adapter

 *	@addr: the indirect TP register address

 *	@mask: specifies the field within the register to modify

 *	@val: new value for the field

 *

 *	Sets a field of an indirect TP register to the given value.

 Flush */

/*

 * EEPROM reads take a few tens of us while writes can take a bit over 5 ms.

/*

 *	csio_hw_seeprom_read - read a serial EEPROM location

 *	@hw: hw to read

 *	@addr: EEPROM virtual address

 *	@data: where to store the read data

 *

 *	Read a 32-bit word from a location in serial EEPROM using the card's PCI

 *	VPD capability.  Note that this function must be called with a virtual

 *	address.

/*

 * Partial EEPROM Vital Product Data structure.  Includes only the ID and

 * VPD-R sections.

/*

 *	csio_hw_get_vpd_keyword_val - Locates an information field keyword in

 *				      the VPD

 *	@v: Pointer to buffered vpd data structure

 *	@kw: The keyword to search for

 *

 *	Returns the value of the information field keyword or

 *	-EINVAL otherwise.

/*

 *	csio_hw_get_vpd_params - read VPD parameters from VPD EEPROM

 *	@hw: HW module

 *	@p: where to store the parameters

 *

 *	Reads card parameters stored in VPD EEPROM.

 To get around compilation warning from strstrip */

	/*

	 * Card information normally starts at VPD_BASE but early cards had

	 * it at 0.

 Reset the VPD flag! */

/*

 *	csio_hw_sf1_read - read data from the serial flash

 *	@hw: the HW module

 *	@byte_cnt: number of bytes to read

 *	@cont: whether another operation will be chained

 *      @lock: whether to lock SF for PL access only

 *	@valp: where to store the read data

 *

 *	Reads up to 4 bytes of data from the serial flash.  The location of

 *	the read needs to be specified prior to calling this by issuing the

 *	appropriate commands to the serial flash.

/*

 *	csio_hw_sf1_write - write data to the serial flash

 *	@hw: the HW module

 *	@byte_cnt: number of bytes to write

 *	@cont: whether another operation will be chained

 *      @lock: whether to lock SF for PL access only

 *	@val: value to write

 *

 *	Writes up to 4 bytes of data to the serial flash.  The location of

 *	the write needs to be specified prior to calling this by issuing the

 *	appropriate commands to the serial flash.

/*

 *	csio_hw_flash_wait_op - wait for a flash operation to complete

 *	@hw: the HW module

 *	@attempts: max number of polls of the status register

 *	@delay: delay between polls in ms

 *

 *	Wait for a flash operation to complete by polling the status register.

/*

 *	csio_hw_read_flash - read words from serial flash

 *	@hw: the HW module

 *	@addr: the start address for the read

 *	@nwords: how many 32-bit words to read

 *	@data: where to store the read data

 *	@byte_oriented: whether to store data as bytes or as words

 *

 *	Read the specified number of 32-bit words from the serial flash.

 *	If @byte_oriented is set the read data is stored as a byte array

 *	(i.e., big-endian), otherwise as 32-bit words in the platform's

 *	natural endianess.

 unlock SF */

/*

 *	csio_hw_write_flash - write up to a page of data to the serial flash

 *	@hw: the hw

 *	@addr: the start address to write

 *	@n: length of data to write in bytes

 *	@data: the data to write

 *

 *	Writes up to a page of data (256 bytes) to the serial flash starting

 *	at the given address.  All the data must be written to the same page.

 unlock SF */

 Read the page to verify the write succeeded */

 unlock SF */

/*

 *	csio_hw_flash_erase_sectors - erase a range of flash sectors

 *	@hw: the HW module

 *	@start: the first sector to erase

 *	@end: the last sector to erase

 *

 *	Erases the sectors in the given inclusive range.

 unlock SF */

/*

 * csio_hw_get_fw_version - read the firmware version

 * @hw: HW module

 * @vers: where to place the version

 *

 * Reads the FW version from flash.

/*

 *	csio_hw_get_tp_version - read the TP microcode version

 *	@hw: HW module

 *	@vers: where to place the version

 *

 *	Reads the TP microcode version from flash.

/*

 * csio_hw_fw_dload - download firmware.

 * @hw: HW module

 * @fw_data: firmware image to write.

 * @size: image size

 *

 * Write the supplied firmware image to the card's serial flash.

 # of sectors spanned */

	/*

	 * We write the correct version at the end so the driver can see a bad

	 * version if the FW write fails.  Start by writing a copy of the

	 * first page with a bad version.

	/* Table for non-Numonix supported flash parts.  Numonix parts are left

	 * to the preexisting code.  All flash parts have 64KB sectors.

 Spansion 4MB S25FL032P */

 unlock SF */

	/* Check to see if it's one of our non-standard supported Flash parts.

	/* Decode Flash part size.  The code below looks repetitive with

	 * common encodings, but that's not guaranteed in the JEDEC

	 * specification for the Read JEDEC ID command.  The only thing that

	 * we're guaranteed by the JEDEC specification is where the

	 * Manufacturer ID is in the returned result.  After that each

	 * Manufacturer ~could~ encode things completely differently.

	 * Note, all Flash parts must have 64KB sectors.

 Micron/Numonix */

		/* This Density -> Size decoding table is taken from Micron

		 * Data Sheets.

 1MB - 32MB */

 64MB */

 128MB */

 256MB */

 ISSI -- Integrated Silicon Solution, Inc. */

		/* This Density -> Size decoding table is taken from ISSI

		 * Data Sheets.

 32 MB */

 64MB */

 Macronix */

 Winbond */ {

		/* This Density -> Size decoding table is taken from

		 * Macronix and Winbond Data Sheets.

 8MB */

 16MB */

	/* If we didn't recognize the FLASH part, that's no real issue: the

	 * Hardware/Software contract says that Hardware will _*ALWAYS*_

	 * use a FLASH part which is at least 4MB in size and has 64KB

	 * sectors.  The unrecognized FLASH part is likely to be much larger

	 * than 4MB, but that's all we really need.

 Store decoded Flash size */

****************************************************************************/

 HW State machine assists                                                  */

****************************************************************************/

/*

 * csio_do_hello - Perform the HELLO FW Mailbox command and process response.

 * @hw: HW module

 * @state: Device state

 *

 * FW_HELLO_CMD has to be polled for completion.

 Firmware has designated us to be master */

		/*

		 * If we're not the Master PF then we need to wait around for

		 * the Master PF Driver to finish setting up the adapter.

		 *

		 * Note that we also do this wait if we're a non-Master-capable

		 * PF and there is no current Master PF; a Master PF may show up

		 * momentarily and we wouldn't want to fail pointlessly.  (This

		 * can happen when an OS loads lots of different drivers rapidly

		 * at the same time). In this case, the Master PF returned by

		 * the firmware will be PCIE_FW_MASTER_MASK so the test below

		 * will work ...

		/*

		 * Wait for the firmware to either indicate an error or

		 * initialized state.  If we see either of these we bail out

		 * and report the issue to the caller.  If we exhaust the

		 * "hello timeout" and we haven't exhausted our retries, try

		 * again.  Otherwise bail with a timeout error.

			/*

			 * If neither Error nor Initialized are indicated

			 * by the firmware keep waiting till we exhaust our

			 * timeout ... and then retry if we haven't exhausted

			 * our retries ...

			/*

			 * We either have an Error or Initialized condition

			 * report errors preferentially.

			/*

			 * If we arrived before a Master PF was selected and

			 * there's not a valid Master PF, grab its identity

			 * for our caller.

/*

 * csio_do_bye - Perform the BYE FW Mailbox command and process response.

 * @hw: HW module

 *

/*

 * csio_do_reset- Perform the device reset.

 * @hw: HW module

 * @fw_rst: FW reset

 *

 * If fw_rst is set, issues FW reset mbox cmd otherwise

 * does PIO reset.

 * Performs reset of the function.

 PIO reset */

/*

 *	csio_hw_fw_halt - issue a reset/halt to FW and put uP into RESET

 *	@hw: the HW module

 *	@mbox: mailbox to use for the FW RESET command (if desired)

 *	@force: force uP into RESET even if FW RESET command fails

 *

 *	Issues a RESET command to firmware (if desired) with a HALT indication

 *	and then puts the microprocessor into RESET state.  The RESET command

 *	will only be issued if a legitimate mailbox is provided (mbox <=

 *	PCIE_FW_MASTER_MASK).

 *

 *	This is generally used in order for the host to safely manipulate the

 *	adapter without fear of conflicting with whatever the firmware might

 *	be doing.  The only way out of this state is to RESTART the firmware

 *	...

	/*

	 * If a legitimate mailbox is provided, issue a RESET command

	 * with a HALT indication.

	/*

	 * Normally we won't complete the operation if the firmware RESET

	 * command fails but if our caller insists we'll go ahead and put the

	 * uP into RESET.  This can be useful if the firmware is hung or even

	 * missing ...  We'll have to take the risk of putting the uP into

	 * RESET without the cooperation of firmware in that case.

	 *

	 * We also force the firmware's HALT flag to be on in case we bypassed

	 * the firmware RESET command above or we're dealing with old firmware

	 * which doesn't have the HALT capability.  This will serve as a flag

	 * for the incoming firmware to know that it's coming out of a HALT

	 * rather than a RESET ... if it's new enough to understand that ...

	/*

	 * And we always return the result of the firmware RESET command

	 * even when we force the uP into RESET ...

/*

 *	csio_hw_fw_restart - restart the firmware by taking the uP out of RESET

 *	@hw: the HW module

 *	@reset: if we want to do a RESET to restart things

 *

 *	Restart firmware previously halted by csio_hw_fw_halt().  On successful

 *	return the previous PF Master remains as the new PF Master and there

 *	is no need to issue a new HELLO command, etc.

 *

 *	We do this in two ways:

 *

 *	 1. If we're dealing with newer firmware we'll simply want to take

 *	    the chip's microprocessor out of RESET.  This will cause the

 *	    firmware to start up from its start vector.  And then we'll loop

 *	    until the firmware indicates it's started again (PCIE_FW.HALT

 *	    reset to 0) or we timeout.

 *

 *	 2. If we're dealing with older firmware then we'll need to RESET

 *	    the chip since older firmware won't recognize the PCIE_FW.HALT

 *	    flag and automatically RESET itself on startup.

		/*

		 * Since we're directing the RESET instead of the firmware

		 * doing it automatically, we need to clear the PCIE_FW.HALT

		 * bit.

		/*

		 * If we've been given a valid mailbox, first try to get the

		 * firmware to do the RESET.  If that works, great and we can

		 * return success.  Otherwise, if we haven't been given a

		 * valid mailbox or the RESET command failed, fall back to

		 * hitting the chip with a hammer.

/*

 *	csio_hw_fw_upgrade - perform all of the steps necessary to upgrade FW

 *	@hw: the HW module

 *	@mbox: mailbox to use for the FW RESET command (if desired)

 *	@fw_data: the firmware image to write

 *	@size: image size

 *	@force: force upgrade even if firmware doesn't cooperate

 *

 *	Perform all of the steps necessary for upgrading an adapter's

 *	firmware image.  Normally this requires the cooperation of the

 *	existing firmware in order to halt all existing activities

 *	but if an invalid mailbox token is passed in we skip that step

 *	(though we'll still put the adapter microprocessor into RESET in

 *	that case).

 *

 *	On successful return the new firmware will have been loaded and

 *	the adapter will have been fully RESET losing all previous setup

 *	state.  On unsuccessful return the adapter may be completely hosed ...

 *	positive errno indicates that the adapter is ~probably~ intact, a

 *	negative errno indicates that things are looking bad ...

	/*

	 * Older versions of the firmware don't understand the new

	 * PCIE_FW.HALT flag and so won't know to perform a RESET when they

	 * restart.  So for newly loaded older firmware we'll have to do the

	 * RESET for it so it starts up on a clean slate.  We can tell if

	 * the newly loaded firmware will handle this right by checking

	 * its header flags to see if it advertises the capability.

/*

 * csio_get_device_params - Get device parameters.

 * @hw: HW module

 *

 Initialize portids to -1 */

 Get port vec information. */

 Get Core clock. */

 Get EQ id start and end. */

 Get IQ id start and end. */

 cache the information. */

 Using FW configured max iqs & eqs */

/*

 * csio_config_device_caps - Get and set device capabilities.

 * @hw: HW module

 *

 Get device capabilities */

 Validate device capabilities */

 Don't config device capabilities if already configured */

 Write back desired device capabilities */

/**

 * fwcap_to_fwspeed - return highest speed in Port Capabilities

 * @acaps: advertised Port Capabilities

 *

 * Get the highest speed for the port from the advertised Port

 * Capabilities.

/**

 *      fwcaps16_to_caps32 - convert 16-bit Port Capabilities to 32-bits

 *      @caps16: a 16-bit Port Capabilities value

 *

 *      Returns the equivalent 32-bit Port Capabilities value.

/**

 *	fwcaps32_to_caps16 - convert 32-bit Port Capabilities to 16-bits

 *	@caps32: a 32-bit Port Capabilities value

 *

 *	Returns the equivalent 16-bit Port Capabilities value.  Note that

 *	not all 32-bit Port Capabilities can be represented in the 16-bit

 *	Port Capabilities and some fields/values may not make it.

/**

 *      lstatus_to_fwcap - translate old lstatus to 32-bit Port Capabilities

 *      @lstatus: old FW_PORT_ACTION_GET_PORT_INFO lstatus value

 *

 *      Translates old FW_PORT_ACTION_GET_PORT_INFO lstatus field into new

 *      32-bit Port Capabilities value.

	/* The format of the Link Status in the old

	 * 16-bit Port Information message isn't the same as the

	 * 16-bit Port Capabilities bitfield used everywhere else.

/**

 *      csio_init_link_config - initialize a link's SW state

 *      @lc: pointer to structure holding the link state

 *      @pcaps: link Port Capabilities

 *      @acaps: link current Advertised Port Capabilities

 *

 *      Initializes the SW state maintained for each link, including the link's

 *      capabilities and default speed/flow-control/autonegotiation settings.

	/*

	 * For Forward Error Control, we default to whatever the Firmware

	 * tells us the Link is currently advertising.

	/* If the Port is capable of Auto-Negtotiation, initialize it as

	 * "enabled" and copy over all of the Physical Port Capabilities

	 * to the Advertised Port Capabilities.  Otherwise mark it as

	 * Auto-Negotiate disabled and select the highest supported speed

	 * for the link.  Note parallel structure in t4_link_l1cfg_core()

	 * and t4_handle_get_port_info().

	/*

	 * Convert driver coding of Pause Frame Flow Control settings into the

	 * Firmware's API.

	/*

	 * Convert Common Code Forward Error Control settings into the

	 * Firmware's API.  If the current Requested FEC has "Automatic"

	 * (IEEE 802.3) specified, then we use whatever the Firmware

	 * sent us as part of it's IEEE 802.3-based interpretation of

	 * the Transceiver Module EPROM FEC parameters.  Otherwise we

	 * use whatever is in the current Requested FEC settings.

	/* Figure out what our Requested Port Capabilities are going to be.

	 * Note parallel structure in t4_handle_get_port_info() and

	 * init_link_config().

/*

 * csio_enable_ports - Bring up all available ports.

 * @hw: HW module.

 *

 Read PORT information */

 Write back PORT information */

 For all ports */

/*

 * csio_get_fcoe_resinfo - Read fcoe fw resource info.

 * @hw: HW module

 * Issued with lock held.

 Get FCoE FW resource information */

	/*

	 * Find out whether we're dealing with a version of

	 * the firmware which has configuration file support.

/*

 * HW initialization: contact FW, obtain config, perform basic init.

 *

 * If the firmware we're dealing with has Configuration File support, then

 * we use that to perform all configuration -- either using the configuration

 * file stored in flash on the adapter or using a filesystem-local file

 * if available.

 *

 * If we don't have configuration file support in the firmware, then we'll

 * have to set things up the old fashioned way with hard-coded register

 * writes and firmware commands ...

/*

 * Attempt to initialize the HW via a Firmware Configuration File.

	/*

	 * Reset device if necessary

	/*

	 * If we have a configuration file in host ,

	 * then use that.  Otherwise, use the configuration file stored

	 * in the HW flash ...

		/*

		 * config file was not found. Use default

		 * config file from flash.

	/*

	 * Tell the firmware to process the indicated Configuration File.

	 * If there are no errors and the caller has provided return value

	 * pointers for the [fini] section version, checksum and computed

	 * checksum, pass those back to the caller.

	 /* If the CAPS_CONFIG failed with an ENOENT (for a Firmware

	  * Configuration File in FLASH), our last gasp effort is to use the

	  * Firmware Configuration File which is embedded in the

	  * firmware.  A very few early versions of the firmware didn't

	  * have one embedded but we can ignore those.

	/*

	 * And now tell the firmware to use the configuration we just loaded.

 Validate device capabilities */

	/*

	 * Note that we're operating with parameters

	 * not supplied by the driver, rather than from hard-wired

	 * initialization constants buried in the driver.

 device parameters */

 Configure SGE */

	/*

	 * And finally tell the firmware to initialize itself using the

	 * parameters from the Configuration File.

 Post event to notify completion of configuration */

	/*

	 * Something bad happened.  Return the error ...

/* Is the given firmware API compatible with the one the driver was compiled

 * with?

 short circuit if it's the exact same firmware version */

/* The firmware in the filesystem is usable, but should it be installed?

 * This routine explains itself in detail if it indicates the filesystem

 * firmware should be installed.

 Read the header of the firmware on the card */

		/* Common case: the firmware on the card is an exact match and

		 * the filesystem one is an exact match too, or the filesystem

		 * one is absent/incompatible.

 Installed successfully, update the cached header too. */

 already reset as part of load_fw */

 We're using whatever's on the card and it's known to be good. */

/*

 * Returns -EINVAL if attempts to flash the firmware failed,

 * -ENOMEM if memory allocation failed else returns 0,

 * if flashing was not attempted because the card had the

 * latest firmware ECANCELED is returned

	/* This is the firmware whose headers the driver was compiled

	 * against

	/* allocate memory to read the header of the firmware on the

	 * card

 upgrade FW logic */

 Cleaning up */

/*

 * csio_hw_configure - Configure HW

 * @hw - HW module

 *

 HW version */

 Needed for FW download */

 Set PCIe completion timeout to 4 seconds */

 Read vpd */

 Do firmware update */

		/* If the firmware doesn't support Configuration Files,

		 * return an error.

		/* The firmware provides us with a memory buffer where we can

		 * load a Configuration File from the host if we want to

		 * override the Configuration File in flash.

 device parameters */

 Get device capabilities */

 Configure SGE */

 Post event to notify completion of configuration */

 if not master */

/*

 * csio_hw_initialize - Initialize HW

 * @hw - HW module

 *

/*

 * csio_hw_intr_enable - Enable HW interrupts

 * @hw: Pointer to HW module.

 *

 * Enable interrupts in HW registers.

	/*

	 * Set aivec for MSI/MSIX. PCIE_PF_CFG.INTXType is set up

	 * by FW, so do nothing for INTX.

 Turn on MB interrupts - this will internally flush PIO as well */

 These are common registers - only a master can modify them */

		/*

		 * Disable the Serial FLASH interrupt, if enabled!

/*

 * csio_hw_intr_disable - Disable HW interrupts

 * @hw: Pointer to HW module.

 *

 * Turn off Mailbox and PCI_PF_CFG interrupts.

 Turn off MB interrupts */

 Do not reset HW, we may need FW state for debugging */

****************************************************************************/

 START: HW SM                                                              */

****************************************************************************/

/*

 * csio_hws_uninit - Uninit state

 * @hw - HW module

 * @evt - Event

 *

/*

 * csio_hws_configuring - Configuring state

 * @hw - HW module

 * @evt - Event

 *

 Fan out event to all lnode SMs */

/*

 * csio_hws_initializing - Initializing state

 * @hw - HW module

 * @evt - Event

 *

 Fan out event to all lnode SMs */

 Enable interrupts */

/*

 * csio_hws_ready - Ready state

 * @hw - HW module

 * @evt - Event

 *

 Remember the event */

 cleanup all outstanding cmds */

/*

 * csio_hws_quiescing - Quiescing state

 * @hw - HW module

 * @evt - Event

 *

 Download firmware */

 Start reset of the HBA */

 Now send the bye command */

/*

 * csio_hws_quiesced - Quiesced state

 * @hw - HW module

 * @evt - Event

 *

/*

 * csio_hws_resetting - HW Resetting state

 * @hw - HW module

 * @evt - Event

 *

/*

 * csio_hws_removing - PCI Hotplug removing state

 * @hw - HW module

 * @evt - Event

 *

		/*

		 * The BYE should have already been issued, so we can't

		 * use the mailbox interface. Hence we use the PL_RST

		 * register directly.

 Should never receive any new events */

/*

 * csio_hws_pcierr - PCI Error state

 * @hw - HW module

 * @evt - Event

 *

****************************************************************************/

 END: HW SM                                                                */

****************************************************************************/

/*

 *	csio_handle_intr_status - table driven interrupt handler

 *	@hw: HW instance

 *	@reg: the interrupt status register to process

 *	@acts: table of interrupt actions

 *

 *	A table driven interrupt handler that applies a set of masks to an

 *	interrupt status word and performs the corresponding actions if the

 *	interrupts described by the mask have occurred.  The actions include

 *	optionally emitting a warning or alert message. The table is terminated

 *	by an entry specifying mask 0.  Returns the number of fatal interrupt

 *	conditions.

 clear processed interrupts */

/*

 * TP interrupt handler.

/*

 * SGE interrupt handler.

/*

 * CIM interrupt handler.

/*

 * ULP RX interrupt handler.

/*

 * ULP TX interrupt handler.

/*

 * PM TX interrupt handler.

/*

 * PM RX interrupt handler.

/*

 * CPL switch interrupt handler.

/*

 * LE interrupt handler.

/*

 * MPS interrupt handler.

 flush */

/*

 * EDC/MC interrupt handler.

/*

 * MA interrupt handler.

/*

 * SMB interrupt handler.

/*

 * NC-SI interrupt handler.

/*

 * XGMAC interrupt handler.

/*

 * PL interrupt handler.

/*

 *	csio_hw_slow_intr_handler - control path interrupt handler

 *	@hw: HW module

 *

 *	Interrupt handler for non-data global interrupt events, e.g., errors.

 *	The designation 'slow' is because it involves register reads, while

 *	data interrupts typically don't involve any MMIOs.

 Clear the interrupts just processed for which we are the master. */

 flush */

/*****************************************************************************

 * HW <--> mailbox interfacing routines.

/*

 * csio_mberr_worker - Worker thread (dpc) for mailbox/error completions

 *

 * @data: Private data pointer.

 *

 * Called from worker thread context.

 Try to start waiting mailboxes */

 Now callback completions */

/*

 * csio_hw_mb_timer - Top-level Mailbox timeout handler.

 *

 * @data: private data pointer

 *

 Call back the function for the timed-out Mailbox */

/*

 * csio_hw_mbm_cleanup - Cleanup Mailbox module.

 * @hw: HW module

 *

 * Called with lock held, should exit with lock held.

 * Cancels outstanding mailboxes (waiting, in-flight) and gathers them

 * into a local queue. Drops lock and calls the completions. Holds

 * lock and returns.

/*****************************************************************************

 * Event handling

 copy event msg and queue the event */

 copy event msg and queue the event */

 If Payload in SG list*/

 Release outstanding events from activeq to freeq*/

 Freeup event entry */

 skip RSS header */

	/*

	 * Enqueue event to EventQ. Events processing happens

	 * in Event worker thread context

 Drop events if queue is STOPPED */

 Handle any remaining fw events */

/****************************************************************************

 * Entry points

 Management module */

/*

 * csio_mgmt_req_lookup - Lookup the given IO req exist in Active Q.

 * mgmt - mgmt module

 * @io_req - io request

 *

 * Return - 0:if given IO Req exists in active Q.

 *          -EINVAL  :if lookup fails.

 Lookup ioreq in the ACTIVEQ */

 Minimum timeout value for req */

/*

 * csio_mgmts_tmo_handler - MGMT IO Timeout handler.

 * @data - Event data.

 *

 * Return - none.

 Dequeue the request from retry Q. */

 io_req will be freed by completion handler */

 If retry queue is not empty, re-arm timer */

 Wait for all outstanding req to complete gracefully */

 release outstanding req from ACTIVEQ */

 io_req will be freed by completion handler */

/*

 * csio_mgmt_init - Mgmt module init entry point

 * @mgmtsm - mgmt module

 * @hw	 - HW module

 *

 * Initialize mgmt timer, resource wait queue, active queue,

 * completion q. Allocate Egress and Ingress

 * WR queues and save off the queue index returned by the WR

 * module for future use. Allocate and save off mgmt reqs in the

 * mgmt_req_freelist for future use. Make sure their SM is initialized

 * to uninit state.

 * Returns: 0 - on success

 *          -ENOMEM   - on error.

mgmtm->iq_idx = hw->fwevt_iq_idx;*/

/*

 * csio_mgmtm_exit - MGMT module exit entry point

 * @mgmtsm - mgmt module

 *

 * This function called during MGMT module uninit.

 * Stop timers, free ioreqs allocated.

 * Returns: None

 *

/**

 * csio_hw_start - Kicks off the HW State machine

 * @hw:		Pointer to HW module.

 *

 * It is assumed that the initialization is a synchronous operation.

 * So when we return after posting the event, the HW SM should be in

 * the ready state, if there were no errors during init.

 Max reset retries */

/**

 * csio_hw_reset - Reset the hardware

 * @hw:		HW module.

 *

 * Caller should hold lock across this function.

/*

 * csio_hw_get_device_id - Caches the Adapter's vendor & device id.

 * @hw: HW module.

 Is the adapter device id cached already ?*/

 Get the PCI vendor & device id */

 csio_hw_get_device_id */

/*

 * csio_hw_set_description - Set the model, description of the hw.

 * @hw: HW module.

 * @ven_id: PCI Vendor ID

 * @dev_id: PCI Device ID

 csio_hw_set_description */

/**

 * csio_hw_init - Initialize HW module.

 * @hw:		Pointer to HW module.

 *

 * Initialize the members of the HW module.

 Get the PCI vendor & device id */

 Initialize the HW chip ops T5 specific ops */

 Set the model & its description */

 Initialize default log level */

 Init all the modules: Mailbox, WorkRequest and Transport */

 Pre-allocate evtq and initialize them */

/**

 * csio_hw_exit - Un-initialize HW module.

 * @hw:		Pointer to HW module.

 *

/*

 * This file is part of the Chelsio FCoE driver for Linux.

 *

 * Copyright (c) 2008-2012 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 value:SGE_INGRESS_RX_THRESHOLD[0] */

 SGE_INGRESS_RX_THRESHOLD[0] */

 value:SGE_TIMER_VALUE_1 */

 Free list buffer size */

 Size of the egress queue status page */

 Ring freelist doorbell */

	/*

	 * Ring the doorbell only when we have atleast CSIO_QCREDIT_SZ

	 * number of bytes in the freelist queue. This translates to atleast

	 * 8 freelist buffer pointers (since each pointer is 8 bytes).

 Write a 0 cidx increment value to enable SGE interrupts for this queue */

/*

 * csio_wr_fill_fl - Populate the FL buffers of a FL queue.

 * @hw: HW module.

 * @flq: Freelist queue.

 *

 * Fill up freelist buffer entries with buffers of size specified

 * in the size register.

 *

/*

 * csio_wr_update_fl -

 * @hw: HW module.

 * @flq: Freelist queue.

 *

 *

/*

 * csio_wr_alloc_q - Allocate a WR queue and initialize it.

 * @hw: HW module

 * @qsize: Size of the queue in bytes

 * @wrsize: Since of WR in this queue, if fixed.

 * @type: Type of queue (Ingress/Egress/Freelist)

 * @owner: Module that owns this queue.

 * @nflb: Number of freelist buffers for FL.

 * @sreg: What is the FL buffer size register?

 * @iq_int_handler: Ingress queue handler in INTx mode.

 *

 * This function allocates and sets up a queue for the caller

 * of size qsize, aligned at the required boundary. This is subject to

 * be free entries being available in the queue array. If one is found,

 * it is initialized with the allocated queue, marked as being used (owner),

 * and a handle returned to the caller in form of the queue's index

 * into the q_arr array.

 * If user has indicated a freelist (by specifying nflb > 0), create

 * another queue (with its own index into q_arr) for the freelist. Allocate

 * memory for DMA buffer metadata (vaddr, len etc). Save off the freelist

 * idx in the ingress queue's flq.idx. This is how a Freelist is associated

 * with its owning ingress queue.

		/*

		 * Number of elements must be a multiple of 16

		 * So this includes status page size

 If using fixed size WRs */

 Since queue area is set to zero */

		/*

		 * Ingress queue status page size is always the size of

		 * the ingress queue entry.

 Allocate memory for FL if requested */

 Associate the new FL with the Ingress quue */

 Fill up the free list buffers */

			/*

			 * Make sure in a FLQ, atleast 1 credit (8 FL buffers)

			 * remains unpopulated,otherwise HW thinks

			 * FLQ is empty.

 Associate the IQ INTx handler. */

 Freelist */

/*

 * csio_wr_iq_create_rsp - Response handler for IQ creation.

 * @hw: The HW module.

 * @mbp: Mailbox.

 * @iq_idx: Ingress queue that got created.

 *

 * Handle FW_IQ_CMD mailbox completion. Save off the assigned IQ/FL ids.

 Actual iq-id. */

 Set the iq-id to iq map table. */

	/*

	 * During FW_IQ_CMD, FW sets interrupt_sent bit to 1 in the SGE

	 * ingress context of this queue. This will block interrupts to

	 * this queue until the next GTS write. Therefore, we do a

	 * 0-cidx increment GTS write for this queue just to clear the

	 * interrupt_sent bit. This will re-enable interrupts to this

	 * queue.

 Now update SGE about the buffers allocated during init */

/*

 * csio_wr_iq_create - Configure an Ingress queue with FW.

 * @hw: The HW module.

 * @priv: Private data object.

 * @iq_idx: Ingress queue index in the WR module.

 * @vec: MSIX vector.

 * @portid: PCIE Channel to be associated with this queue.

 * @async: Is this a FW asynchronous message handling queue?

 * @cbfn: Completion callback.

 *

 * This API configures an ingress queue with FW by issuing a FW_IQ_CMD mailbox

 * with alloc/write bits set.

 For interrupt forwarding queue only */

 Pass in the ingress queue cmd parameters */

/*

 * csio_wr_eq_create_rsp - Response handler for EQ creation.

 * @hw: The HW module.

 * @mbp: Mailbox.

 * @eq_idx: Egress queue that got created.

 *

 * Handle FW_EQ_OFLD_CMD mailbox completion. Save off the assigned EQ ids.

/*

 * csio_wr_eq_create - Configure an Egress queue with FW.

 * @hw: HW module.

 * @priv: Private data.

 * @eq_idx: Egress queue index in the WR module.

 * @iq_idx: Associated ingress queue index.

 * @cbfn: Completion callback.

 *

 * This API configures a offload egress queue with FW by issuing a

 * FW_EQ_OFLD_CMD  (with alloc + write ) mailbox.

/*

 * csio_wr_iq_destroy_rsp - Response handler for IQ removal.

 * @hw: The HW module.

 * @mbp: Mailbox.

 * @iq_idx: Ingress queue that was freed.

 *

 * Handle FW_IQ_CMD (free) mailbox completion.

/*

 * csio_wr_iq_destroy - Free an ingress queue.

 * @hw: The HW module.

 * @priv: Private data object.

 * @iq_idx: Ingress queue index to destroy

 * @cbfn: Completion callback.

 *

 * This API frees an ingress queue by issuing the FW_IQ_CMD

 * with the free bit set.

/*

 * csio_wr_eq_destroy_rsp - Response handler for OFLD EQ creation.

 * @hw: The HW module.

 * @mbp: Mailbox.

 * @eq_idx: Egress queue that was freed.

 *

 * Handle FW_OFLD_EQ_CMD (free) mailbox completion.

/*

 * csio_wr_eq_destroy - Free an Egress queue.

 * @hw: The HW module.

 * @priv: Private data object.

 * @eq_idx: Egress queue index to destroy

 * @cbfn: Completion callback.

 *

 * This API frees an Egress queue by issuing the FW_EQ_OFLD_CMD

 * with the free bit set.

/*

 * csio_wr_cleanup_eq_stpg - Cleanup Egress queue status page

 * @hw: HW module

 * @qidx: Egress queue index

 *

 * Cleanup the Egress queue status page.

/*

 * csio_wr_cleanup_iq_ftr - Cleanup Footer entries in IQ

 * @hw: HW module

 * @qidx: Ingress queue index

 *

 * Cleanup the footer entries in the given ingress queue,

 * set to 1 the internal copy of genbit.

 set to 1 since we are just about zero out genbit */

 Get the WR */

 Get the footer */

 Zero out footer */

/*

 * csio_wr_get - Get requested size of WR entry/entries from queue.

 * @hw: HW module.

 * @qidx: Index of queue.

 * @size: Cumulative size of Work request(s).

 * @wrp: Work request pair.

 *

 * If requested credits are available, return the start address of the

 * work request in the work request pair. Set pidx accordingly and

 * return.

 *

 * NOTE about WR pair:

 * ==================

 * A WR can start towards the end of a queue, and then continue at the

 * beginning, since the queue is considered to be circular. This will

 * require a pair of address/size to be passed back to the caller -

 * hence Work request pair format.

 Calculate credits */

 cidx == pidx, empty queue */

	/*

	 * Check if we have enough credits.

	 * credits = 1 implies queue is full.

	/*

	 * If we are here, we have enough credits to satisfy the

	 * request. Check if we are near the end of q, and if WR spills over.

	 * If it does, use the first addr/size to cover the queue until

	 * the end. Fit the remainder portion of the request at the top

	 * of queue and return it in the second addr/len. Set pidx

	 * accordingly.

 We are the end of queue, roll back pidx to top of queue */

/*

 * csio_wr_copy_to_wrp - Copies given data into WR.

 * @data_buf - Data buffer

 * @wrp - Work request pair.

 * @wr_off - Work request offset.

 * @data_len - Data length.

 *

 * Copies the given data in Work Request. Work request pair(wrp) specifies

 * address information of Work request.

 * Returns: none

 Number of space available in buffer addr1 of WRP */

 Write the remaining data from the begining of circular buffer */

/*

 * csio_wr_issue - Notify chip of Work request.

 * @hw: HW module.

 * @qidx: Index of queue.

 * @prio: 0: Low priority, 1: High priority

 *

 * Rings the SGE Doorbell by writing the current producer index of the passed

 * in queue into the register.

 *

 Ring SGE Doorbell writing q->pidx into it */

 cidx == pidx, empty queue */

/*

 * csio_wr_inval_flq_buf - Invalidate a free list buffer entry.

 * @hw: HW module.

 * @flq: The freelist queue.

 *

 * Invalidate the driver's version of a freelist buffer entry,

 * without freeing the associated the DMA memory. The entry

 * to be invalidated is picked up from the current Free list

 * queue cidx.

 *

/*

 * csio_wr_process_fl - Process a freelist completion.

 * @hw: HW module.

 * @q: The ingress queue attached to the Freelist.

 * @wr: The freelist completion WR in the ingress queue.

 * @len_to_qid: The lower 32-bits of the first flit of the RSP footer

 * @iq_handler: Caller's handler for this completion.

 * @priv: Private pointer of caller

 *

 Consume all freelist buffers used for len bytes */

/*

 * csio_is_new_iqwr - Is this a new Ingress queue entry ?

 * @q: Ingress quueue.

 * @ftr: Ingress queue WR SGE footer.

 *

 * The entry is new if our generation bit matches the corresponding

 * bit in the footer of the current WR.

/*

 * csio_wr_process_iq - Process elements in Ingress queue.

 * @hw:  HW pointer

 * @qidx: Index of queue

 * @iq_handler: Handler for this queue

 * @priv: Caller's private pointer

 *

 * This routine walks through every entry of the ingress queue, calling

 * the provided iq_handler with the entry, until the generation bit

 * flips.

 Get the footer */

	/*

	 * When q wrapped around last time, driver should have inverted

	 * ic.genbit as well.

 Subtract footer from WR len */

				/*

				 * We are already in the Forward Interrupt

				 * Interrupt Queue Service! Do-not service

				 * again!

				 *

 Call the queue handler. */

		/*

		 * Ingress *always* has fixed size WR entries. Therefore,

		 * there should always be complete WRs towards the end of

		 * queue.

 Roll over to start of queue */

 Toggle genbit */

 while (q->un.iq.genbit == hdr->genbit) */

	/*

	 * We need to re-arm SGE interrupts in case we got a stray interrupt,

	 * especially in msix mode. With INTx, this may be a common occurence.

 Replenish free list buffers if pending falls below low water mark */

			/* Make sure in FLQ, atleast 1 credit (8 FL buffers)

			 * remains unpopulated otherwise HW thinks

			 * FLQ is empty.

 Now inform SGE about our incremental index value */

	/* T5 introduced the separation of the Free List Padding and

	 * Packing Boundaries.  Thus, we can select a smaller Padding

	 * Boundary to avoid uselessly chewing up PCIe Link and Memory

	 * Bandwidth, and use a Packing Boundary which is large enough

	 * to avoid false sharing between CPUs, etc.

	 *

	 * For the PCI Link, the smaller the Padding Boundary the

	 * better.  For the Memory Controller, a smaller Padding

	 * Boundary is better until we cross under the Memory Line

	 * Size (the minimum unit of transfer to/from Memory).  If we

	 * have a Padding Boundary which is smaller than the Memory

	 * Line Size, that'll involve a Read-Modify-Write cycle on the

	 * Memory Controller which is never good.

	/* We want the Packing Boundary to be based on the Cache Line

	 * Size in order to help avoid False Sharing performance

	 * issues between CPUs, etc.  We also want the Packing

	 * Boundary to incorporate the PCI-E Maximum Payload Size.  We

	 * get best performance when the Packing Boundary is a

	 * multiple of the Maximum Payload Size.

		/* The PCIe Device Control Maximum Payload Size field

		 * [bits 7:5] encodes sizes as powers of 2 starting at

		 * 128 bytes.

	/* T5/T6 have a special interpretation of the "0"

	 * value for the Packing Boundary.  This corresponds to 16

	 * bytes instead of the expected 32 bytes.

	/* Use the smallest Ingress Padding which isn't smaller than

	 * the Memory Controller Read/Write Size.  We'll take that as

	 * being 8 bytes since we don't know of any system with a

	 * wider Memory Controller Bus Width.

 FL BUFFER SIZE#0 is Page size i,e already aligned to cache line */

	/*

	 * If using hard params, the following will get set correctly

	 * in csio_wr_set_sge().

 default value of rx_dma_offset of the NIC driver */

/*

 * csio_wr_get_sge - Get SGE register values.

 * @hw: HW module.

 *

 * Used by non-master functions and by master-functions relying on config file.

/*

 * csio_wr_set_sge - Initialize SGE registers

 * @hw: HW module.

 *

 * Used by Master function to initialize SGE registers in the absence

 * of a config file.

	/*

	 * Set up our basic SGE mode to deliver CPL messages to our Ingress

	 * Queue and Packet Date to the Free List.

 sge->csio_fl_align is set up by csio_wr_fixup_host_params(). */

	/*

	 * Set up to drop DOORBELL writes when the DOORBELL FIFO overflows

	 * and generate an interrupt when this occurs so we can recover.

 SGE_FL_BUFFER_SIZE0 is set up by csio_wr_fixup_host_params(). */

 Initialize interrupt coalescing attributes */

	/*

	 * If we are master and chip is not initialized:

	 *    - If we plan to use the config file, we need to fixup some

	 *      host specific registers, and read the rest of the SGE

	 *      configuration.

	 *    - If we dont plan to use the config file, we need to initialize

	 *      SGE entirely, including fixing the host specific registers.

	 * If we are master and chip is initialized, just read and work off of

	 *	the already initialized SGE values.

	 * If we arent the master, we are only allowed to read and work off of

	 *      the already initialized SGE values.

	 *

	 * Therefore, before calling this function, we assume that the master-

	 * ship of the card, state and whether to use config file or not, have

	 * already been decided.

/*

 * csio_wrm_init - Initialize Work request module.

 * @wrm: WR module

 * @hw: HW pointer

 *

 * Allocates memory for an array of queue pointers starting at q_arr.

/*

 * csio_wrm_exit - Initialize Work request module.

 * @wrm: WR module

 * @hw: HW module

 *

 * Uninitialize WR module. Free q_arr and pointers in it.

 * We have the additional job of freeing the DMA memory associated

 * with the queues.

/*

 * This file is part of the Chelsio FCoE driver for Linux.

 *

 * Copyright (c) 2008-2012 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 Lnode SM declarations */

 LN event mapping */

 None */

 PLOGI_ACC_RCVD  */

 PLOGI_RJT_RCVD  */

 PLOGI_RCVD	   */

 PLOGO_RCVD	   */

 PRLI_ACC_RCVD   */

 PRLI_RJT_RCVD   */

 PRLI_RCVD	   */

 PRLO_RCVD	   */

 NPORT_ID_CHGD   */

 FLOGO_RCVD	   */

 CLR_VIRT_LNK_RCVD */

 FLOGI_ACC_RCVD   */

 FLOGI_RJT_RCVD   */

 FDISC_ACC_RCVD   */

 FDISC_RJT_RCVD   */

 FLOGI_TMO_MAX_RETRY */

 IMPL_LOGO_ADISC_ACC */

 IMPL_LOGO_ADISC_RJT */

 IMPL_LOGO_ADISC_CNFLT */

 PRLI_TMO		*/

 ADISC_TMO		*/

 RSCN_DEV_LOST */

 SCR_ACC_RCVD */

 ADISC_RJT_RCVD */

 LOGO_SNT */

 PROTO_ERR_IMPL_LOGO */

/*

 * csio_ln_match_by_portid - lookup lnode using given portid.

 * @hw: HW module

 * @portid: port-id.

 *

 * If found, returns lnode matching given portid otherwise returns NULL.

 Match siblings lnode with portid */

/*

 * csio_ln_lookup_by_vnpi - Lookup lnode using given vnp id.

 * @hw - HW module

 * @vnpi - vnp index.

 * Returns - If found, returns lnode matching given vnp id

 * otherwise returns NULL.

 Traverse sibling lnodes */

 Match sibling lnode */

 Traverse children lnodes */

/**

 * csio_lnode_lookup_by_wwpn - Lookup lnode using given wwpn.

 * @hw:		HW module.

 * @wwpn:	WWPN.

 *

 * If found, returns lnode matching given wwpn, returns NULL otherwise.

 Traverse sibling lnodes */

 Match sibling lnode */

 Traverse children lnodes */

 FDMI */

 includes attribute type and length */

 should be multiple of 4 bytes */

/*

 * csio_ln_fdmi_done - FDMI registeration completion

 * @hw: HW context

 * @fdmi_req: fdmi request

/*

 * csio_ln_fdmi_rhba_cbfn - RHBA completion

 * @hw: HW context

 * @fdmi_req: fdmi request

 Prepare CT hdr for RPA cmd */

 Prepare RPA payload */

 Start appending Port attributes */

 Submit FDMI RPA request */

/*

 * csio_ln_fdmi_dprt_cbfn - DPRT completion

 * @hw: HW context

 * @fdmi_req: fdmi request

 Prepare CT hdr for RHBA cmd */

 Prepare RHBA payload */

 HBA identifer */

 Register one port per hba */

 Start appending HBA attributes hba */

 Submit FDMI RHBA request */

/*

 * csio_ln_fdmi_dhba_cbfn - DHBA completion

 * @hw: HW context

 * @fdmi_req: fdmi request

	/* Send FDMI cmd to de-register any Port attributes if registered

	 * before

 Prepare FDMI DPRT cmd */

 Submit FDMI request */

/**

 * csio_ln_fdmi_start - Start an FDMI request.

 * @ln:		lnode

 * @context:	session context

 *

 * Issued with lock held.

	/* Send FDMI cmd to de-register any HBA attributes if registered

	 * before

 Prepare FDMI DHBA cmd */

 Submit FDMI request */

/*

 * csio_ln_vnp_read_cbfn - vnp read completion handler.

 * @hw: HW lnode

 * @cbfn: Completion handler.

 *

 * Reads vnp response and updates ln parameters.

 Update WWNs */

	/*

	 * This may look like a duplication of what csio_fcoe_enable_link()

	 * does, but is absolutely necessary if the vnpi changes between

	 * a FCOE LINK UP and FCOE LINK DOWN.

 Copy common sparam */

 Copy word 0 & word 1 of class sparam */

 Send an event to update local attribs */

/*

 * csio_ln_vnp_read - Read vnp params.

 * @ln: lnode

 * @cbfn: Completion handler.

 *

 * Issued with lock held.

 Allocate Mbox request */

 Prepare VNP Command */

 Issue MBOX cmd */

/*

 * csio_fcoe_enable_link - Enable fcoe link.

 * @ln: lnode

 * @enable: enable/disable

 * Issued with lock held.

 * Issues mbox cmd to bring up FCOE link on port associated with given ln.

/*

 * csio_ln_read_fcf_cbfn - Read fcf parameters

 * @ln: lnode

 *

 * read fcf response and Update ln fcf information.

/*

 * csio_ln_read_fcf_entry - Read fcf entry.

 * @ln: lnode

 * @cbfn: Completion handler.

 *

 * Issued with lock held.

 Get FCoE FCF information */

/*

 * csio_handle_link_up - Logical Linkup event.

 * @hw - HW module.

 * @portid - Physical port number

 * @fcfi - FCF index.

 * @vnpi - VNP index.

 * Returns - none.

 *

 * This event is received from FW, when virtual link is established between

 * Physical port[ENode] and FCF. If its new vnpi, then local node object is

 * created on this FCF and set to [ONLINE] state.

 * Lnode waits for FW_RDEV_CMD event to be received indicating that

 * Fabric login is completed and lnode moves to [READY] state.

 *

 * This called with hw lock held

 Lookup lnode based on vnpi */

 Pick lnode based on portid */

 Check if lnode has valid vnp flowid */

 New VN-Port */

Initialize fcfi */

 Send LINKUP event to SM */

/*

 * csio_post_event_rns

 * @ln - FCOE lnode

 * @evt - Given rnode event

 * Returns - none

 *

 * Posts given rnode event to all FCOE rnodes connected with given Lnode.

 * This routine is invoked when lnode receives LINK_DOWN/DOWN_LINK/CLOSE

 * event.

 *

 * This called with hw lock held

/*

 * csio_cleanup_rns

 * @ln - FCOE lnode

 * Returns - none

 *

 * Frees all FCOE rnodes connected with given Lnode.

 *

 * This called with hw lock held

/*

 * csio_post_event_lns

 * @ln - FCOE lnode

 * @evt - Given lnode event

 * Returns - none

 *

 * Posts given lnode event to all FCOE lnodes connected with given Lnode.

 * This routine is invoked when lnode receives LINK_DOWN/DOWN_LINK/CLOSE

 * event.

 *

 * This called with hw lock held

 If NPIV lnode, send evt only to that and return */

 Traverse children lnodes list and send evt */

 Send evt to parent lnode */

/*

 * csio_ln_down - Lcoal nport is down

 * @ln - FCOE Lnode

 * Returns - none

 *

 * Sends LINK_DOWN events to Lnode and its associated NPIVs lnodes.

 *

 * This called with hw lock held

/*

 * csio_handle_link_down - Logical Linkdown event.

 * @hw - HW module.

 * @portid - Physical port number

 * @fcfi - FCF index.

 * @vnpi - VNP index.

 * Returns - none

 *

 * This event is received from FW, when virtual link goes down between

 * Physical port[ENode] and FCF. Lnode and its associated NPIVs lnode hosted on

 * this vnpi[VN-Port] will be de-instantiated.

 *

 * This called with hw lock held

 Lookup lnode based on vnpi */

Warn if linkdown received if lnode is not in ready state */

 Verify portid */

 verify fcfi */

 Send LINK_DOWN event to lnode s/m */

/*

 * csio_is_lnode_ready - Checks FCOE lnode is in ready state.

 * @ln: Lnode module

 *

 * Returns True if FCOE lnode is in ready state.

****************************************************************************/

 START: Lnode SM                                                           */

****************************************************************************/

/*

 * csio_lns_uninit - The request in uninit state.

 * @ln - FCOE lnode.

 * @evt - Event to be processed.

 *

 * Process the given lnode event which is currently in "uninit" state.

 * Invoked with HW lock held.

 * Return - none.

 Read FCF only for physical lnode */

 TODO: Send HW RESET event */

 Add FCF record */

 TODO: Send HW RESET event */

 switch event */

/*

 * csio_lns_online - The request in online state.

 * @ln - FCOE lnode.

 * @evt - Event to be processed.

 *

 * Process the given lnode event which is currently in "online" state.

 * Invoked with HW lock held.

 * Return - none.

 Remove FCF entry */

 switch event */

/*

 * csio_lns_ready - The request in ready state.

 * @ln - FCOE lnode.

 * @evt - Event to be processed.

 *

 * Process the given lnode event which is currently in "ready" state.

 * Invoked with HW lock held.

 * Return - none.

 Remove FCF entry */

		/* Host need to issue aborts in case if FW has not returned

		 * WRs with status "ABORTED"

 Remove FCF entry */

 switch event */

/*

 * csio_lns_offline - The request in offline state.

 * @ln - FCOE lnode.

 * @evt - Event to be processed.

 *

 * Process the given lnode event which is currently in "offline" state.

 * Invoked with HW lock held.

 * Return - none.

 Read FCF only for physical lnode */

 TODO: Send HW RESET event */

 Add FCF record */

 TODO: Send HW RESET event */

 switch event */

****************************************************************************/

 END: Lnode SM                                                             */

****************************************************************************/

 Helper routines for attributes  */

/*

 * csio_lnode_state_to_str - Get current state of FCOE lnode.

 * @ln - lnode

 * @str - state of lnode.

 *

 csio_lnode_state_to_str */

/*

 * csio_ln_mgmt_wr_handler -Mgmt Work Request handler.

 * @wr - WR.

 * @len - WR len.

 * This handler is invoked when an outstanding mgmt WR is completed.

 * Its invoked in the context of FW event worker thread for every

 * mgmt event received.

 * Return - none.

 lookup ioreq exists in our active Q */

 Dequeue from active queue */

 io_req will be freed by completion handler */

/**

 * csio_fcoe_fwevt_handler - Event handler for Firmware FCoE events.

 * @hw:		HW module

 * @cpl_op:	CPL opcode

 * @cmd:	FW cmd/WR.

 *

 * Process received FCoE cmd/WR event from FW.

 HW lock here */

 HW un lock here */

 HW lock here */

 HW un lock here */

 HW lock here */

 save previous event for debugging */

 Translate all the fabric events to lnode SM events */

 Handover event to rn SM here. */

/**

 * csio_lnode_start - Kickstart lnode discovery.

 * @ln:		lnode

 *

 * This routine kickstarts the discovery by issuing an FCOE_LINK (up) command.

/**

 * csio_lnode_stop - Stop the lnode.

 * @ln:		lnode

 *

 * This routine is invoked by HW module to stop lnode and its associated NPIV

 * lnodes.

/**

 * csio_lnode_close - Close an lnode.

 * @ln:		lnode

 *

 * This routine is invoked by HW module to close an lnode and its

 * associated NPIV lnodes. Lnode and its associated NPIV lnodes are

 * set to uninitialized state.

/*

 * csio_ln_prep_ecwr - Prepare ELS/CT WR.

 * @io_req - IO request.

 * @wr_len - WR len

 * @immd_len - WR immediate data

 * @sub_op - Sub opcode

 * @sid - source portid.

 * @did - destination portid

 * @flow_id - flowid

 * @fw_wr - ELS/CT WR to be prepared.

 * Returns: 0 - on success

 Prepare RSP SGL */

/*

 * csio_ln_mgmt_submit_wr - Post elsct work request.

 * @mgmtm - mgmtm

 * @io_req - io request.

 * @sub_op - ELS or CT request type

 * @pld - Dma Payload buffer

 * @pld_len - Payload len

 * Prepares ELSCT Work request and sents it to FW.

 * Returns: 0 - on success

 Calculate WR Size for this ELS REQ */

 Send as immediate data if pld < 256 */

 Roundup WR size in units of 16 bytes */

 Get WR to send ELS REQ */

 Prepare Generic WR used by all ELS/CT cmd */

 Copy ELS/CT WR CMD */

 Copy payload to Immediate section of WR */

 Program DSGL to dma payload */

 Issue work request to xmit ELS/CT req to FW */

/*

 * csio_ln_mgmt_submit_req - Submit FCOE Mgmt request.

 * @io_req - IO Request

 * @io_cbfn - Completion handler.

 * @req_type - ELS or CT request type

 * @pld - Dma Payload buffer

 * @pld_len - Payload len

 *

 *

 * This API used submit managment ELS/CT request.

 * This called with hw lock held

 * Returns: 0 - on success

 *	    -ENOMEM	- on error.

 Upper layer callback handler */

/*

 * csio_ln_fdmi_init - FDMI Init entry point.

 * @ln: lnode

 Allocate MGMT request required for FDMI */

 Allocate Dma buffers for FDMI response Payload */

/*

 * csio_ln_fdmi_exit - FDMI exit entry point.

 * @ln: lnode

/*

 * csio_notify_lnodes:

 * @hw: HW module

 * @note: Notification

 *

 * Called from the HW SM to fan out notifications to the

 * Lnode SM. Since the HW SM is entered with lock held,

 * there is no need to hold locks here.

 *

 Traverse children lnodes list and send evt */

/*

 * csio_disable_lnodes:

 * @hw: HW module

 * @portid:port id

 * @disable: disable/enable flag.

 * If disable=1, disables all lnode hosted on given physical port.

 * otherwise enables all the lnodes on given phsysical port.

 * This routine need to called with hw lock held.

 Traverse sibling lnodes list and send evt */

/*

 * csio_ln_init - Initialize an lnode.

 * @ln:		lnode

 *

 This is the lnode used during initialization */

 Either a non-root physical or a virtual lnode */

		/*

		 * THe rest is common for non-root physical and NPIV lnodes.

		 * Just get references to all other modules

 NPIV */

 Another non-root physical lnode (FCF) */

 if (!csio_is_root_ln(ln)) */

/*

 * csio_lnode_init - Initialize the members of an lnode.

 * @ln:		lnode

 Link this lnode to hw */

 Link child to parent if child lnode */

 Initialize scsi_tgt and timers to zero */

 Initialize rnode list */

 Initialize log level for debug */

 Add lnode to list of sibling or children lnodes */

/**

 * csio_lnode_exit - De-instantiate an lnode.

 * @ln:		lnode

 *

 Remove this lnode from hw->sln_head */

	/* If it is children lnode, decrement the

	 * counter in its parent lnode

 Update root lnode pointer */

/*

 * This file is part of the Chelsio FCoE driver for Linux.

 *

 * Copyright (c) 2008-2012 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/*

 * csio_reg_rnode - Register a remote port with FC transport.

 * @rn: Rnode representing remote port.

 *

 * Call fc_remote_port_add() to register this remote port with FC transport.

 * If remote port is Initiator OR Target OR both, change the role appropriately.

 *

/*

 * csio_unreg_rnode - Unregister a remote port with FC transport.

 * @rn: Rnode representing remote port.

 *

 * Call fc_remote_port_delete() to unregister this remote port with FC

 * transport.

 *

/*

 * csio_lnode_async_event - Async events from local port.

 * @ln: lnode representing local port.

 *

 * Async events from local node that FC transport/SCSI ML

 * should be made aware of (Eg: RSCN).

 Get payload of rscn from ln */

 For each RSCN entry */

			/*

			 * fc_host_post_event(shost,

			 *		      fc_get_event_number(),

			 *		      FCH_EVT_RSCN,

			 *		      rscn_entry);

 send fc_host_post_event */

 set vport state */

 send fc_host_post_event */

 set vport state */

/*

 * csio_fchost_attr_init - Initialize FC transport attributes

 * @ln: Lnode.

 *

/*

 * csio_get_host_port_id - sysfs entries for nport_id is

 * populated/cached from this function

/*

 * csio_get_port_type - Return FC local port type.

 * @shost: scsi host.

 *

/*

 * csio_get_port_state - Return FC local port state.

 * @shost: scsi host.

 *

/*

 * csio_get_host_speed - Return link speed to FC transport.

 * @shost: scsi host.

 *

/*

 * csio_get_host_fabric_name - Return fabric name

 * @shost: scsi host.

 *

/*

 * csio_get_host_speed - Return FC transport statistics.

 * @ln: Lnode.

 *

 Reset stats for the device */

/*

 * csio_set_rport_loss_tmo - Set the rport dev loss timeout

 * @rport: fc rport.

 * @timeout: new value for dev loss tmo.

 *

 * If timeout is non zero set the dev_loss_tmo to timeout, else set

 * dev_loss_tmo to one.

 Set fc vport state based on phyiscal lnode */

 Set fc vport state based on virtual lnode */

 Issue VNP cmd to alloc vport */

 Allocate Mbox request */

		/* FW is expected to complete vnp cmd in immediate mode

		 * without much delay.

		 * Otherwise, there will be increase in IO latency since HW

		 * lock is held till completion of vnp mbox cmd.

 Retry if mbox returns busy */

 Process Mbox response of VNP command */

 Issue VNP cmd to free vport */

 Allocate Mbox request */

 Retry if mbox returns busy */

 Process Mbox response of VNP command */

 Quiesce ios and send remove event to lnode */

 Free vnp */

 disable vport */

 Quiesce ios and send stop event to lnode */

 Free vnp */

 enable vport */

 return if driver is being removed or same rnode comes back online */

	/*

	 * enqueue devloss event to event worker thread to serialize all

	 * rnode events.

 FC transport functions template - Physical port */

 FC transport functions template - Virtual  port */

/*

 * This file is part of the Chelsio FCoE driver for Linux.

 *

 * Copyright (c) 2008-2012 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/*

 * debugfs support

/*

 * csio_dfs_create - Creates and sets up per-hw debugfs.

 *

/*

 * csio_dfs_destroy - Destroys per-hw debugfs.

/*

 * csio_dfs_init - Debug filesystem initialization for the module.

 *

/*

 * csio_dfs_exit - debugfs cleanup for the module.

/*

 * csio_pci_init - PCI initialization.

 * @pdev: PCI device.

 * @bars: Bitmask of bars to be requested.

 *

 * Initializes the PCI function by enabling MMIO, setting bus

 * mastership and setting DMA mask.

/*

 * csio_pci_exit - PCI unitialization.

 * @pdev: PCI device.

 * @bars: Bars to be released.

 *

/*

 * csio_hw_init_workers - Initialize the HW module's worker threads.

 * @hw: HW module.

 *

 FW event queue */

 Create mgmt queue */

 Create SCSI queues */

 for all CPUs */

 For all ports */

/*

 * csio_config_queues - Configure the DMA queues.

 * @hw: HW module.

 *

 * Allocates memory for queues are registers them with FW.

 Calculate number of SCSI queues for MSIX we would like */

 Initialize max_cpus, may get reduced during msix allocations */

 Allocate Forward interrupt iq. */

 Allocate the FW evt queue */

 Allocate the mgmt queue */

 Use FW IQ for MGMT req completion */

 Allocate SCSI queues */

 for all CPUs */

 For all ports */

	/*

	 * Now request IRQs for the vectors. In the event of a failure,

	 * cleanup is handled internally by this function.

/*

 * csio_hw_alloc - Allocate and initialize the HW module.

 * @pdev: PCI device.

 *

 * Allocates HW structure, DMA, memory resources, maps BARS to

 * host memory and initializes HW module.

 memory pool/DMA pool allocation */

 Get the start address of registers from BAR 0 */

/*

 * csio_hw_free - Uninitialize and free the HW module.

 * @hw: The HW module

 *

 * Disable interrupts, uninit the HW module, free resources, free hw.

/**

 * csio_shost_init - Create and initialize the lnode module.

 * @hw:		The HW module.

 * @dev:	The device associated with this invocation.

 * @probe:	Called from probe context or not?

 * @pln:	Parent lnode if any.

 *

 * Allocates lnode structure via scsi_host_alloc, initializes

 * shost, initializes lnode module and registers with SCSI ML

 * via scsi_host_add. This function is shared between physical and

 * virtual node ports.

	/*

	 * hw->pdev is the physical port's PCI dev structure,

	 * which will be different from the NPIV dev structure.

 Link common lnode to this lnode */

 Max CDB length supported */

 root lnode */

 Other initialization here: Common, Transport specific */

/**

 * csio_shost_exit - De-instantiate the shost.

 * @ln:		The lnode module corresponding to the shost.

 *

 Inform transport */

 Inform SCSI ML */

	/* Flush all the events, so that any rnode removal events

	 * already queued are all handled, before we remove the lnode.

 Traverse sibling lnodes */

 Traverse children lnodes */

 Traverse sibling lnodes */

 Traverse children lnodes */

 Traverse sibling lnodes */

 Traverse children lnodes */

 Traverse sibling lnodes */

 Traverse children lnodes */

 Get all child lnodes(NPIV ports) */

 Traverse children lnodes */

 Delete NPIV lnodes */

 Delete only npiv lnodes */

 Get all physical lnodes */

 Traverse sibling lnodes */

 Delete physical lnodes */

/*

 * csio_lnode_init_post: Set lnode attributes after starting HW.

 * @ln: lnode.

 *

/*

 * csio_probe_one - Instantiate this function.

 * @pdev: PCI device

 * @id: Device ID

 *

 * This is the .probe() callback of the driver. This function:

 * - Initializes the PCI function by enabling MMIO, setting bus

 *   mastership and setting DMA mask.

 * - Allocates HW structure, DMA, memory resources, maps BARS to

 *   host memory and initializes HW module.

 * - Allocates lnode structure via scsi_host_alloc, initializes

 *   shost, initialized lnode module and registers with SCSI ML

 *   via scsi_host_add.

 * - Enables interrupts, and starts the chip by kicking off the

 *   HW state machine.

 * - Once hardware is ready, initiated scan of the host via

 *   scsi_scan_host.

 probe only T5 and T6 cards */

 Initialize portid */

/*

 * csio_remove_one - Remove one instance of the driver at this PCI function.

 * @pdev: PCI device

 *

 * Used during hotplug operation.

	/* Stops lnode, Rnode s/m

	 * Quiesce IOs.

	 * All sessions with remote ports are unregistered.

/*

 * csio_pci_error_detected - PCI error was detected

 * @pdev: PCI device

 *

	/* Post PCI error detected evt to HW s/m

	 * HW s/m handles this evt by quiescing IOs, unregisters rports

	 * and finally takes the device to offline.

/*

 * csio_pci_slot_reset - PCI slot has been reset.

 * @pdev: PCI device

 *

	/* Bring HW s/m to ready state.

	 * but don't resume IOs.

/*

 * csio_pci_resume - Resume normal operations

 * @pdev: PCI device

 *

 Bring the LINK UP and Resume IO */

 Initialize portid */

/*

 *  Macros needed to support the PCI Device ID Table ...

 Define for FCoE uses PF6 */

/*

 * csio_init - Chelsio storage driver initialization function.

 *

/*

 * csio_exit - Chelsio storage driver uninitialization .

 *

 * Function that gets called in the unload path.

/*

 * This file is part of the Chelsio FCoE driver for Linux.

 *

 * Copyright (c) 2008-2013 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

	/*

	 * Truncation intentional: we only read the bottom 32-bits of the

	 * 64-bit BAR0/BAR1 ...  We use the hardware backdoor mechanism to

	 * read BAR0 instead of using pci_resource_start() because we could be

	 * operating from within a Virtual Machine which is trapping our

	 * accesses to our Configuration Space and we need to set up the PCI-E

	 * Memory Window decoders with the actual addresses which will be

	 * coming across the PCI-E link.

 For T5, only relative offset inside the PCIe BAR is passed */

	/*

	 * Set up memory window for accessing adapter memory ranges.  (Read

	 * back MA register to ensure that changes propagate before we attempt

	 * to use the new values.)

/*

 * Interrupt handler for the PCIE module.

/*

 * csio_t5_flash_cfg_addr - return the address of the flash configuration file

 * @hw: the HW module

 *

 * Return the address within the flash where the Firmware Configuration

 * File is stored.

/*

 *      csio_t5_mc_read - read from MC through backdoor accesses

 *      @hw: the hw module

 *      @idx: index to the register

 *      @addr: address of first byte requested

 *      @data: 64 bytes of data containing the requested address

 *      @ecc: where to store the corresponding 64-bit ECC word

 *

 *      Read 64 bytes of data from MC starting at a 64-byte-aligned address

 *      that covers the requested address @addr.  If @parity is not %NULL it

 *      is assigned the 64-bit ECC word for the read data.

/*

 *      csio_t5_edc_read - read from EDC through backdoor accesses

 *      @hw: the hw module

 *      @idx: which EDC to access

 *      @addr: address of first byte requested

 *      @data: 64 bytes of data containing the requested address

 *      @ecc: where to store the corresponding 64-bit ECC word

 *

 *      Read 64 bytes of data from EDC starting at a 64-byte-aligned address

 *      that covers the requested address @addr.  If @parity is not %NULL it

 *      is assigned the 64-bit ECC word for the read data.

/*

 * These macro are missing in t4_regs.h file.

/*

 * csio_t5_memory_rw - read/write EDC 0, EDC 1 or MC via PCIE memory window

 * @hw: the csio_hw

 * @win: PCI-E memory Window to use

 * @mtype: memory type: MEM_EDC0, MEM_EDC1, MEM_MC0 (or MEM_MC) or MEM_MC1

 * @addr: address within indicated memory type

 * @len: amount of memory to transfer

 * @buf: host memory buffer

 * @dir: direction of transfer 1 => read, 0 => write

 *

 * Reads/writes an [almost] arbitrary memory region in the firmware: the

 * firmware memory address, length and host buffer must be aligned on

 * 32-bit boundaries.  The memory is transferred as a raw byte sequence

 * from/to the firmware's memory.  If this memory contains data

 * structures which contain multi-byte integers, it's the callers

 * responsibility to perform appropriate byte order conversions.

	/*

	 * Argument sanity checks ...

	/* Offset into the region of memory which is being accessed

	 * MEM_EDC0 = 0

	 * MEM_EDC1 = 1

	 * MEM_MC   = 2 -- T4

	 * MEM_MC0  = 2 -- For T5

	 * MEM_MC1  = 3 -- For T5

 Determine the PCIE_MEM_ACCESS_OFFSET */

	/*

	 * Each PCI-E Memory Window is programmed with a window size -- or

	 * "aperture" -- which controls the granularity of its mapping onto

	 * adapter memory.  We need to grab that aperture in order to know

	 * how to use the specified window.  The window is also programmed

	 * with the base address of the Memory Window in BAR0's address

	 * space.  For T4 this is an absolute PCI-E Bus Address.  For T5

	 * the address is relative to BAR0.

		/*

		 * Move PCI-E Memory Window to our current transfer

		 * position.  Read it back to ensure that changes propagate

		 * before we attempt to use the new value.

/*

 * csio_t5_dfs_create_ext_mem - setup debugfs for MC0 or MC1 to read the values

 * @hw: the csio_hw

 *

 * This function creates files in the debugfs with external memory region

 * MC0 & MC1.

 T5 adapter specific function */

/*

 * This file is part of the Chelsio FCoE driver for Linux.

 *

 * Copyright (c) 2008-2012 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 MB Command/Response Helpers */

/*

 * csio_mb_fw_retval - FW return value from a mailbox response.

 * @mbp: Mailbox structure

 *

/*

 * csio_mb_hello - FW HELLO command helper

 * @hw: The HW structure

 * @mbp: Mailbox structure

 * @m_mbox: Master mailbox number, if any.

 * @a_mbox: Mailbox number for asycn notifications.

 * @master: Device mastership.

 * @cbfn: Callback, if any.

 *

/*

 * csio_mb_process_hello_rsp - FW HELLO response processing helper

 * @hw: The HW structure

 * @mbp: Mailbox structure

 * @retval: Mailbox return value from Firmware

 * @state: State that the function is in.

 * @mpfn: Master pfn

 *

/*

 * csio_mb_bye - FW BYE command helper

 * @hw: The HW structure

 * @mbp: Mailbox structure

 * @cbfn: Callback, if any.

 *

/*

 * csio_mb_reset - FW RESET command helper

 * @hw: The HW structure

 * @mbp: Mailbox structure

 * @reset: Type of reset.

 * @cbfn: Callback, if any.

 *

/*

 * csio_mb_params - FW PARAMS command helper

 * @hw: The HW structure

 * @mbp: Mailbox structure

 * @tmo: Command timeout.

 * @pf: PF number.

 * @vf: VF number.

 * @nparams: Number of parameters

 * @params: Parameter mnemonic array.

 * @val: Parameter value array.

 * @wr: Write/Read PARAMS.

 * @cbfn: Callback, if any.

 *

 Write Params */

/*

 * csio_mb_process_read_params_rsp - FW PARAMS response processing helper

 * @hw: The HW structure

 * @mbp: Mailbox structure

 * @retval: Mailbox return value from Firmware

 * @nparams: Number of parameters

 * @val: Parameter value array.

 *

/*

 * csio_mb_ldst - FW LDST command

 * @hw: The HW structure

 * @mbp: Mailbox structure

 * @tmo: timeout

 * @reg: register

 *

	/*

	 * Construct and send the Firmware LDST Command to retrieve the

	 * specified PCI-E Configuration Space register.

/*

 *

 * csio_mb_caps_config - FW Read/Write Capabilities command helper

 * @hw: The HW structure

 * @mbp: Mailbox structure

 * @wr: Write if 1, Read if 0

 * @init: Turn on initiator mode.

 * @tgt: Turn on target mode.

 * @cofld:  If 1, Control Offload for FCoE

 * @cbfn: Callback, if any.

 *

 * This helper assumes that cmdp has MB payload from a previous CAPS

 * read command.

 Read config */

 Write config */

/*

 * csio_mb_port- FW PORT command helper

 * @hw: The HW structure

 * @mbp: Mailbox structure

 * @tmo: COmmand timeout

 * @portid: Port ID to get/set info

 * @wr: Write/Read PORT information.

 * @fc: Flow control

 * @caps: Port capabilites to set.

 * @cbfn: Callback, if any.

 *

 Set port */

/*

 * csio_mb_process_read_port_rsp - FW PORT command response processing helper

 * @hw: The HW structure

 * @mbp: Mailbox structure

 * @retval: Mailbox return value from Firmware

 * @caps: port capabilities

 *

/*

 * csio_mb_initialize - FW INITIALIZE command helper

 * @hw: The HW structure

 * @mbp: Mailbox structure

 * @tmo: COmmand timeout

 * @cbfn: Callback, if any.

 *

/*

 * csio_mb_iq_alloc - Initializes the mailbox to allocate an

 *				Ingress DMA queue in the firmware.

 *

 * @hw: The hw structure

 * @mbp: Mailbox structure to initialize

 * @priv: Private object

 * @mb_tmo: Mailbox time-out period (in ms).

 * @iq_params: Ingress queue params needed for allocation.

 * @cbfn: The call-back function

 *

 *

 csio_mb_iq_alloc */

/*

 * csio_mb_iq_write - Initializes the mailbox for writing into an

 *				Ingress DMA Queue.

 *

 * @hw: The HW structure

 * @mbp: Mailbox structure to initialize

 * @priv: Private object

 * @mb_tmo: Mailbox time-out period (in ms).

 * @cascaded_req: TRUE - if this request is cascased with iq-alloc request.

 * @iq_params: Ingress queue params needed for writing.

 * @cbfn: The call-back function

 *

 * NOTE: We OR relevant bits with cmdp->XXX, instead of just equating,

 * because this IQ write request can be cascaded with a previous

 * IQ alloc request, and we dont want to over-write the bits set by

 * that request. This logic will work even in a non-cascaded case, since the

 * cmdp structure is zeroed out by CSIO_INIT_MBP.

	/*

	 * If this IQ write is cascaded with IQ alloc request, do not

	 * re-initialize with 0's.

	 *

 csio_mb_iq_write */

/*

 * csio_mb_iq_alloc_write - Initializes the mailbox for allocating an

 *				Ingress DMA Queue.

 *

 * @hw: The HW structure

 * @mbp: Mailbox structure to initialize

 * @priv: Private data.

 * @mb_tmo: Mailbox time-out period (in ms).

 * @iq_params: Ingress queue params needed for allocation & writing.

 * @cbfn: The call-back function

 *

 *

 csio_mb_iq_alloc_write */

/*

 * csio_mb_iq_alloc_write_rsp - Process the allocation & writing

 *				of ingress DMA queue mailbox's response.

 *

 * @hw: The HW structure.

 * @mbp: Mailbox structure to initialize.

 * @retval: Firmware return value.

 * @iq_params: Ingress queue parameters, after allocation and write.

 *

 csio_mb_iq_alloc_write_rsp */

/*

 * csio_mb_iq_free - Initializes the mailbox for freeing a

 *				specified Ingress DMA Queue.

 *

 * @hw: The HW structure

 * @mbp: Mailbox structure to initialize

 * @priv: Private data

 * @mb_tmo: Mailbox time-out period (in ms).

 * @iq_params: Parameters of ingress queue, that is to be freed.

 * @cbfn: The call-back function

 *

 *

 csio_mb_iq_free */

/*

 * csio_mb_eq_ofld_alloc - Initializes the mailbox for allocating

 *				an offload-egress queue.

 *

 * @hw: The HW  structure

 * @mbp: Mailbox structure to initialize

 * @priv: Private data

 * @mb_tmo: Mailbox time-out period (in ms).

 * @eq_ofld_params: (Offload) Egress queue parameters.

 * @cbfn: The call-back function

 *

 *

 csio_mb_eq_ofld_alloc */

/*

 * csio_mb_eq_ofld_write - Initializes the mailbox for writing

 *				an alloacted offload-egress queue.

 *

 * @hw: The HW structure

 * @mbp: Mailbox structure to initialize

 * @priv: Private data

 * @mb_tmo: Mailbox time-out period (in ms).

 * @cascaded_req: TRUE - if this request is cascased with Eq-alloc request.

 * @eq_ofld_params: (Offload) Egress queue parameters.

 * @cbfn: The call-back function

 *

 *

 * NOTE: We OR relevant bits with cmdp->XXX, instead of just equating,

 * because this EQ write request can be cascaded with a previous

 * EQ alloc request, and we dont want to over-write the bits set by

 * that request. This logic will work even in a non-cascaded case, since the

 * cmdp structure is zeroed out by CSIO_INIT_MBP.

	/*

	 * If this EQ write is cascaded with EQ alloc request, do not

	 * re-initialize with 0's.

	 *

 csio_mb_eq_ofld_write */

/*

 * csio_mb_eq_ofld_alloc_write - Initializes the mailbox for allocation

 *				writing into an Engress DMA Queue.

 *

 * @hw: The HW structure

 * @mbp: Mailbox structure to initialize

 * @priv: Private data.

 * @mb_tmo: Mailbox time-out period (in ms).

 * @eq_ofld_params: (Offload) Egress queue parameters.

 * @cbfn: The call-back function

 *

 *

 csio_mb_eq_ofld_alloc_write */

/*

 * csio_mb_eq_ofld_alloc_write_rsp - Process the allocation

 *				& write egress DMA queue mailbox's response.

 *

 * @hw: The HW structure.

 * @mbp: Mailbox structure to initialize.

 * @retval: Firmware return value.

 * @eq_ofld_params: (Offload) Egress queue parameters.

 *

 csio_mb_eq_ofld_alloc_write_rsp */

/*

 * csio_mb_eq_ofld_free - Initializes the mailbox for freeing a

 *				specified Engress DMA Queue.

 *

 * @hw: The HW structure

 * @mbp: Mailbox structure to initialize

 * @priv: Private data area.

 * @mb_tmo: Mailbox time-out period (in ms).

 * @eq_ofld_params: (Offload) Egress queue parameters, that is to be freed.

 * @cbfn: The call-back function

 *

 *

 csio_mb_eq_ofld_free */

/*

 * csio_write_fcoe_link_cond_init_mb - Initialize Mailbox to write FCoE link

 *				 condition.

 *

 * @ln: The Lnode structure

 * @mbp: Mailbox structure to initialize

 * @mb_tmo: Mailbox time-out period (in ms).

 * @cbfn: The call back function.

 *

 *

 csio_write_fcoe_link_cond_init_mb */

/*

 * csio_fcoe_read_res_info_init_mb - Initializes the mailbox for reading FCoE

 *				resource information(FW_GET_RES_INFO_CMD).

 *

 * @hw: The HW structure

 * @mbp: Mailbox structure to initialize

 * @mb_tmo: Mailbox time-out period (in ms).

 * @cbfn: The call-back function

 *

 *

 csio_fcoe_read_res_info_init_mb */

/*

 * csio_fcoe_vnp_alloc_init_mb - Initializes the mailbox for allocating VNP

 *				in the firmware (FW_FCOE_VNP_CMD).

 *

 * @ln: The Lnode structure.

 * @mbp: Mailbox structure to initialize.

 * @mb_tmo: Mailbox time-out period (in ms).

 * @fcfi: FCF Index.

 * @vnpi: vnpi

 * @iqid: iqid

 * @vnport_wwnn: vnport WWNN

 * @vnport_wwpn: vnport WWPN

 * @cbfn: The call-back function.

 *

 *

 csio_fcoe_vnp_alloc_init_mb */

/*

 * csio_fcoe_vnp_read_init_mb - Prepares VNP read cmd.

 * @ln: The Lnode structure.

 * @mbp: Mailbox structure to initialize.

 * @mb_tmo: Mailbox time-out period (in ms).

 * @fcfi: FCF Index.

 * @vnpi: vnpi

 * @cbfn: The call-back handler.

/*

 * csio_fcoe_vnp_free_init_mb - Initializes the mailbox for freeing an

 *			alloacted VNP in the firmware (FW_FCOE_VNP_CMD).

 *

 * @ln: The Lnode structure.

 * @mbp: Mailbox structure to initialize.

 * @mb_tmo: Mailbox time-out period (in ms).

 * @fcfi: FCF flow id

 * @vnpi: VNP flow id

 * @cbfn: The call-back function.

 * Return: None

/*

 * csio_fcoe_read_fcf_init_mb - Initializes the mailbox to read the

 *				FCF records.

 *

 * @ln: The Lnode structure

 * @mbp: Mailbox structure to initialize

 * @mb_tmo: Mailbox time-out period (in ms).

 * @fcf_params: FC-Forwarder parameters.

 * @cbfn: The call-back function

 *

 *

 csio_fcoe_read_fcf_init_mb */

 csio_fcoe_read_portparams_init_mb */

 Get the first 6 flits from the Mailbox */

 Get the second 6 flits from the Mailbox */

 Get the last 4 flits from the Mailbox */

 Entry points/APIs for MB module					     */

/*

 * csio_mb_intr_enable - Enable Interrupts from mailboxes.

 * @hw: The HW structure

 *

 * Enables CIM interrupt bit in appropriate INT_ENABLE registers.

/*

 * csio_mb_intr_disable - Disable Interrupts from mailboxes.

 * @hw: The HW structure

 *

 * Disable bit in HostInterruptEnable CIM register.

 This is a FW assertion */

 Copy mailbox data */

 Notify FW of mailbox by setting owner as UP */

/*

 * csio_mb_issue - generic routine for issuing Mailbox commands.

 * @hw: The HW structure

 * @mbp: Mailbox command to issue

 *

 *  Caller should hold hw lock across this call.

 Determine mode */

 Need to issue/get results in the same context */

 Queue mbox cmd, if another mbox cmd is active */

 Now get ownership of mailbox */

		/*

		 * Mailbox unavailable. In immediate mode, fail the command.

		 * In other modes, enqueue the request.

 Mailbox is available, copy mailbox data into it */

 Start completion timers in non-immediate modes and notify FW */

 Flush posted writes */

 Poll for completion in immediate mode */

 Check for response */

 Copy response */

/*

 * csio_mb_completions - Completion handler for Mailbox commands

 * @hw: The HW structure

 * @cbfn_q: Completion queue.

 *

/*

 * csio_mb_isr_handler - Handle mailboxes related interrupts.

 * @hw: The HW structure

 *

 * Called from the ISR to handle Mailbox related interrupts.

 * HW Lock should be held across this call.

	/*

	 * The cause registers below HAVE to be cleared in the SAME

	 * order as below: The low level cause register followed by

	 * the upper level cause register. In other words, CIM-cause

	 * first followed by PL-Cause next.

 Flush */

 When we are not master */

 Get response */

 Flush */

 Add completion to tail of cbfn queue */

		/*

		 * Enqueue event to EventQ. Events processing happens

		 * in Event worker thread context

		/*

		 * We can get here if mailbox MSIX vector is shared,

		 * or in INTx case. Or a stray interrupt.

/*

 * csio_mb_tmo_handler - Timeout handler

 * @hw: The HW structure

 *

	/*

	 * Could be a race b/w the completion handler and the timer

	 * and the completion handler won that race.

/*

 * csio_mb_cancel_all - Cancel all waiting commands.

 * @hw: The HW structure

 * @cbfn_q: The callback queue.

 *

 * Caller should hold hw lock across this call.

 Stop mailbox completion timer */

 Add completion to tail of cbfn queue */

/*

 * csio_mbm_init - Initialize Mailbox module

 * @mbm: Mailbox module

 * @hw: The HW structure

 * @timer: Timing function for interrupting mailboxes

 *

 * Initialize timer and the request/response queues.

/*

 * csio_mbm_exit - Uninitialize mailbox module

 * @mbm: Mailbox module

 *

 * Stop timer.

/*

 * This file is part of the Chelsio FCoE driver for Linux.

 *

 * Copyright (c) 2008-2012 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/*

 * csio_fwevt_handler - Common FW event handler routine.

 * @hw: HW module.

 *

 * This is the ISR for FW events. It is shared b/w MSIX

 * and INTx handlers.

 csio_fwevt_handler */

/*

 * csio_fwevt_isr() - FW events MSIX ISR

 * @irq:

 * @dev_id:

 *

 * Process WRs on the FW event queue.

 *

/*

 * csio_fwevt_isr() - INTx wrapper for handling FW events.

 * @irq:

 * @dev_id:

 csio_fwevt_intx_handler */

/*

 * csio_process_scsi_cmpl - Process a SCSI WR completion.

 * @hw: HW module.

 * @wr: The completed WR from the ingress queue.

 * @len: Length of the WR.

 * @flb: Freelist buffer array.

 *

			/*

			 * We call scsi_done for I/Os that driver thinks aborts

			 * have timed out. If there is a race caused by FW

			 * completing abort at the exact same time that the

			 * driver has deteced the abort timeout, the following

			 * check prevents calling of scsi_done twice for the

			 * same command: once from the eh_abort_handler, another

			 * from csio_scsi_isr_handler(). This also avoids the

			 * need to check if csio_scsi_cmnd(req) is NULL in the

			 * fast path.

/*

 * csio_scsi_isr_handler() - Common SCSI ISR handler.

 * @iq: Ingress queue pointer.

 *

 * Processes SCSI completions on the SCSI IQ indicated by scm->iq_idx

 * by calling csio_wr_process_iq_idx. If there are completions on the

 * isr_cbfn_q, yank them out into a local queue and call their io_cbfns.

 * Once done, add these completions onto the freelist.

 * This routine is shared b/w MSIX and INTx.

 Call back the completion routines */

 Release ddp buffer if used for this req */

 Return the ioreqs back to ioreq->freelist */

/*

 * csio_scsi_isr() - SCSI MSIX handler

 * @irq:

 * @dev_id:

 *

 * This is the top level SCSI MSIX handler. Calls csio_scsi_isr_handler()

 * for handling SCSI completions.

/*

 * csio_scsi_intx_handler() - SCSI INTx handler

 * @irq:

 * @dev_id:

 *

 * This is the top level SCSI INTx handler. Calls csio_scsi_isr_handler()

 * for handling SCSI completions.

 csio_scsi_intx_handler */

/*

 * csio_fcoe_isr() - INTx/MSI interrupt service routine for FCoE.

 * @irq:

 * @dev_id:

 *

 *

 Disable the interrupt for this PCI function. */

	/*

	 * The read in the following function will flush the

	 * above write.

 Get the INTx Forward interrupt IQ. */

 IQ handler is not possible for intx_q, hence pass in NULL */

 Non-data vector */

 Name SCSI vecs */

 Add the MSIX vector descriptions */

 Allocate IRQs for SCSI */

 for all scsi cpus */

 for all ports */

 Reduce per-port max possible CPUs */

 Max vectors required based on #niqs configured in fw */

 Distribute vectors */

 Try MSIX, then MSI or fall back to INTx */

 Max iqs required based on #niqs configured in fw */

/*

 * This file is part of the Chelsio FCoE driver for Linux.

 *

 * Copyright (c) 2008-2012 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

 Static machine forward declarations */

 RNF event mapping */

 None */

 PLOGI_ACC_RCVD  */

 PLOGI_RJT_RCVD  */

 PLOGI_RCVD	   */

 PLOGO_RCVD	   */

 PRLI_ACC_RCVD   */

 PRLI_RJT_RCVD   */

 PRLI_RCVD	   */

 PRLO_RCVD	   */

 NPORT_ID_CHGD   */

 FLOGO_RCVD	   */

 CLR_VIRT_LNK_RCVD */

 FLOGI_ACC_RCVD   */

 FLOGI_RJT_RCVD   */

 FDISC_ACC_RCVD   */

 FDISC_RJT_RCVD   */

 FLOGI_TMO_MAX_RETRY */

 IMPL_LOGO_ADISC_ACC */

 IMPL_LOGO_ADISC_RJT */

 IMPL_LOGO_ADISC_CNFLT */

 PRLI_TMO		*/

 ADISC_TMO		*/

 RSCN_DEV_LOST  */

 SCR_ACC_RCVD	*/

 ADISC_RJT_RCVD */

 LOGO_SNT */

 PROTO_ERR_IMPL_LOGO */

/*

 * csio_rn_lookup - Finds the rnode with the given flowid

 * @ln - lnode

 * @flowid - flowid.

 *

 * Does the rnode lookup on the given lnode and flowid.If no matching entry

 * found, NULL is returned.

/*

 * csio_rn_lookup_wwpn - Finds the rnode with the given wwpn

 * @ln: lnode

 * @wwpn: wwpn

 *

 * Does the rnode lookup on the given lnode and wwpn. If no matching entry

 * found, NULL is returned.

/**

 * csio_rnode_lookup_portid - Finds the rnode with the given portid

 * @ln:		lnode

 * @portid:	port id

 *

 * Lookup the rnode list for a given portid. If no matching entry

 * found, NULL is returned.

/*

 * csio_get_rnode - Gets rnode with the given flowid

 * @ln - lnode

 * @flowid - flow id.

 *

 * Does the rnode lookup on the given lnode and flowid. If no matching

 * rnode found, then new rnode with given npid is allocated and returned.

/*

 * csio_put_rnode - Frees the given rnode

 * @ln - lnode

 * @flowid - flow id.

 *

 * Does the rnode lookup on the given lnode and flowid. If no matching

 * rnode found, then new rnode with given npid is allocated and returned.

/*

 * csio_confirm_rnode - confirms rnode based on wwpn.

 * @ln: lnode

 * @rdev_flowid: remote device flowid

 * @rdevp: remote device params

 * This routines searches other rnode in list having same wwpn of new rnode.

 * If there is a match, then matched rnode is returned and otherwise new rnode

 * is returned.

 * returns rnode.

 Drop rdev event for cntrl port */

 Lookup on flowid */

 Drop events with duplicate flowid */

 Lookup on wwpn for NPORTs */

 Lookup well-known ports with nport id */

			/*

			 * Now compare the wwpn to confirm that

			 * same port relogged in. If so update the matched rn.

			 * Else, go ahead and alloc a new rnode.

 Update rn */

 wwpn match */

 Search for rnode that have same wwpn */

 Update flowid */

 update rdev entry */

 update rdev entry */

/*

 * csio_rn_verify_rparams - verify rparams.

 * @ln: lnode

 * @rn: rnode

 * @rdevp: remote device params

 * returns success if rparams are verified.

 NPIV support */

 validate wwpn/wwnn for Name server/remote port */

 Copy wwnn, wwpn and nport id */

 Cleanup I/Os that were waiting for rnode to unregister */

****************************************************************************/

 START: Rnode SM                                                           */

****************************************************************************/

/*

 * csio_rns_uninit -

 * @rn - rnode

 * @evt - SM event.

 *

/*

 * csio_rns_ready -

 * @rn - rnode

 * @evt - SM event.

 *

		/* FW expected to internally aborted outstanding SCSI WRs

		 * and return all SCSI WRs to host with status "ABORTED".

		/* FW expected to internally aborted outstanding SCSI WRs

		 * and return all SCSI WRs to host with status "ABORTED".

		/*

		 * Each rnode receives CLOSE event when driver is removed or

		 * device is reset

		 * Note: All outstanding IOs on remote port need to returned

		 * to uppper layer with appropriate error before sending

		 * CLOSE event

		/*

		 * FW expected to internally aborted outstanding SCSI WRs

		 * and return all SCSI WRs to host with status "ABORTED".

/*

 * csio_rns_offline -

 * @rn - rnode

 * @evt - SM event.

 *

		/* Each rnode receives CLOSE event when driver is removed or

		 * device is reset

		 * Note: All outstanding IOs on remote port need to returned

		 * to uppper layer with appropriate error before sending

		 * CLOSE event

/*

 * csio_rns_disappeared -

 * @rn - rnode

 * @evt - SM event.

 *

		/* Each rnode receives CLOSE event when driver is removed or

		 * device is reset.

		 * Note: All outstanding IOs on remote port need to returned

		 * to uppper layer with appropriate error before sending

		 * CLOSE event

****************************************************************************/

 END: Rnode SM                                                             */

****************************************************************************/

/*

 * csio_rnode_devloss_handler - Device loss event handler

 * @rn: rnode

 *

 * Post event to close rnode SM and free rnode.

 ignore if same rnode came back as online */

 Free rn if in uninit state */

/**

 * csio_rnode_fwevt_handler - Event handler for firmware rnode events.

 * @rn:		rnode

 * @fwevt:	firmware event to handle

 Track previous & current events for debugging */

 Post event to rnode SM */

 Free rn if in uninit state */

/*

 * csio_rnode_init - Initialize rnode.

 * @rn: RNode

 * @ln: Associated lnode

 *

 * Caller is responsible for holding the lock. The lock is required

 * to be held for inserting the rnode in ln->rnhead list.

 Add rnode to list of lnodes->rnhead */

/*

 * This file is part of the Chelsio FCoE driver for Linux.

 *

 * Copyright (c) 2008-2012 Chelsio Communications, Inc. All rights reserved.

 *

 * This software is available to you under a choice of one of two

 * licenses.  You may choose to be licensed under the terms of the GNU

 * General Public License (GPL) Version 2, available from the file

 * COPYING in the main directory of this source tree, or the

 * OpenIB.org BSD license below:

 *

 *     Redistribution and use in source and binary forms, with or

 *     without modification, are permitted provided that the following

 *     conditions are met:

 *

 *      - Redistributions of source code must retain the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer.

 *

 *      - Redistributions in binary form must reproduce the above

 *        copyright notice, this list of conditions and the following

 *        disclaimer in the documentation and/or other materials

 *        provided with the distribution.

 *

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,

 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF

 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND

 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS

 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN

 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN

 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

 * SOFTWARE.

/*

 * csio_scsi_match_io - Match an ioreq with the given SCSI level data.

 * @ioreq: The I/O request

 * @sld: Level information

 *

 * Should be called with lock held.

 *

/*

 * csio_scsi_gather_active_ios - Gather active I/Os based on level

 * @scm: SCSI module

 * @sld: Level information

 * @dest: The queue where these I/Os have to be gathered.

 *

 * Should be called with lock held.

 Just splice the entire active_q into dest */

/*

 * csio_scsi_fcp_cmnd - Frame the SCSI FCP command paylod.

 * @req: IO req structure.

 * @addr: DMA location to place the payload.

 *

 * This routine is shared between FCP_WRITE, FCP_READ and FCP_CMD requests.

 Check for Task Management */

/*

 * csio_scsi_init_cmd_wr - Initialize the SCSI CMD WR.

 * @req: IO req structure.

 * @addr: DMA location to place the payload.

 * @size: Size of WR (including FW WR + immed data + rsp SG entry

 *

 * Wrapper for populating fw_scsi_cmd_wr.

 Get RSP DMA buffer */

 Prepare RSP SGL */

 Frame a FCP command */

 WR size */	\

 Immed data */

/*

 * csio_scsi_cmd - Create a SCSI CMD WR.

 * @req: IO req structure.

 *

 * Gets a WR slot in the ingress queue and initializes it with SCSI CMD WR.

 *

 Initialize WR in one shot */

		/*

		 * Make a temporary copy of the WR and write back

		 * the copy into the WR pair.

/*

 * csio_scsi_init_ulptx_dsgl - Fill in a ULP_TX_SC_DSGL

 * @hw: HW module

 * @req: IO request

 * @sgl: ULP TX SGL pointer.

 *

 Now add the data SGLs */

 Program sg elements with driver's DDP buffer */

/*

 * csio_scsi_init_read_wr - Initialize the READ SCSI WR.

 * @req: IO req structure.

 * @wrp: DMA location to place the payload.

 * @size: Size of WR (including FW WR + immed data + rsp SG entry + data SGL

 *

 * Wrapper for populating fw_scsi_read_wr.

 Get RSP DMA buffer */

 Prepare RSP SGL */

 Move WR pointer past command and immediate data */

 Fill in the DSGL */

/*

 * csio_scsi_init_write_wr - Initialize the WRITE SCSI WR.

 * @req: IO req structure.

 * @wrp: DMA location to place the payload.

 * @size: Size of WR (including FW WR + immed data + rsp SG entry + data SGL

 *

 * Wrapper for populating fw_scsi_write_wr.

 Get RSP DMA buffer */

 Prepare RSP SGL */

 Move WR pointer past command and immediate data */

 Fill in the DSGL */

 Calculate WR size needed for fw_scsi_read_wr/fw_scsi_write_wr */

 WR size */          \

 Immed data */       \

 ulptx_sgl */	       \

 Data SGE */	       \

/*

 * csio_scsi_read - Create a SCSI READ WR.

 * @req: IO req structure.

 *

 * Gets a WR slot in the ingress queue and initializes it with

 * SCSI READ WR.

 *

 Initialize WR in one shot */

			/*

			 * Make a temporary copy of the WR and write back

			 * the copy into the WR pair.

/*

 * csio_scsi_write - Create a SCSI WRITE WR.

 * @req: IO req structure.

 *

 * Gets a WR slot in the ingress queue and initializes it with

 * SCSI WRITE WR.

 *

 Initialize WR in one shot */

			/*

			 * Make a temporary copy of the WR and write back

			 * the copy into the WR pair.

/*

 * csio_setup_ddp - Setup DDP buffers for Read request.

 * @req: IO req structure.

 *

 * Checks SGLs/Data buffers are virtually contiguous required for DDP.

 * If contiguous,driver posts SGLs in the WR otherwise post internal

 * buffers for such request for DDP.

 Except 1st buffer,all buffer addr have to be Page aligned */

 Except last buffer,all buffer must end on page boundary */

 SGL's are virtually contiguous. HW will DDP to SGLs */

	/*

	 * For unaligned SGLs, driver will allocate internal DDP buffer.

	 * Once command is completed data from DDP buffer copied to SGLs

 Use gen_list to store the DDP buffers */

 Allocate ddp buffers for this request */

 Added to IO req */

 set number of ddp bufs used */

 release dma descs */

/*

 * csio_scsi_init_abrt_cls_wr - Initialize an ABORT/CLOSE WR.

 * @req: IO req structure.

 * @addr: DMA location to place the payload.

 * @size: Size of WR

 * @abort: abort OR close

 *

 * Wrapper for populating fw_scsi_cmd_wr.

 0 for CHK_ALL_IO tells FW to look up t_cookie */

 Since we re-use the same ioreq for abort as well */

 Initialize WR in one shot */

		/*

		 * Make a temporary copy of the WR and write back

		 * the copy into the WR pair.

****************************************************************************/

 START: SCSI SM                                                            */

****************************************************************************/

 change state and enqueue on active_q */

			/*

			 * NOTE: We collect the affected I/Os prior to issuing

			 * LUN reset, and not after it. This is to prevent

			 * aborting I/Os that get issued after the LUN reset,

			 * but prior to LUN reset completion (in the event that

			 * the host stack has not blocked I/Os to a LUN that is

			 * being reset.

		/*

		 * NOTE:

		 * We could get here due to  :

		 * - a window in the cleanup path of the SCSI module

		 *   (csio_scsi_abort_io()). Please see NOTE in this function.

		 * - a window in the time we tried to issue an abort/close

		 *   of a request to FW, and the FW completed the request

		 *   itself.

		 *   Print a message for now, and return INVAL either way.

		/*

		 * In MSIX mode, with multiple queues, the SCSI compeltions

		 * could reach us sooner than the FW events sent to indicate

		 * I-T nexus loss (link down, remote device logo etc). We

		 * dont want to be returning such I/Os to the upper layer

		 * immediately, since we wouldnt have reported the I-T nexus

		 * loss itself. This forces us to serialize such completions

		 * with the reporting of the I-T nexus loss. Therefore, we

		 * internally queue up such up such completions in the rnode.

		 * The reporting of I-T nexus loss to the upper layer is then

		 * followed by the returning of I/Os in this internal queue.

		 * Having another state alongwith another queue helps us take

		 * actions for events such as ABORT received while we are

		 * in this rnode queue.

			/*

			 * FW says remote device is lost, but rnode

			 * doesnt reflect it.

		/*

		 * Use -ECANCELED to explicitly tell the ABORTED event that

		 * the original I/O was returned to driver by FW.

		 * We dont really care if the I/O was returned with success by

		 * FW (because the ABORT and completion of the I/O crossed each

		 * other), or any other return value. Once we are in aborting

		 * state, the success or failure of the I/O is unimportant to

		 * us.

		/*

		 * Check if original I/O WR completed before the Abort

		 * completion.

		/*

		 * There are the following possible scenarios:

		 * 1. The abort completed successfully, FW returned FW_SUCCESS.

		 * 2. The completion of an I/O and the receipt of

		 *    abort for that I/O by the FW crossed each other.

		 *    The FW returned FW_EINVAL. The original I/O would have

		 *    returned with FW_SUCCESS or any other SCSI error.

		 * 3. The FW couldn't sent the abort out on the wire, as there

		 *    was an I-T nexus loss (link down, remote device logged

		 *    out etc). FW sent back an appropriate IT nexus loss status

		 *    for the abort.

		 * 4. FW sent an abort, but abort timed out (remote device

		 *    didnt respond). FW replied back with

		 *    FW_SCSI_ABORT_TIMEDOUT.

		 * 5. FW couldn't genuinely abort the request for some reason,

		 *    and sent us an error.

		 *

		 * The first 3 scenarios are treated as  succesful abort

		 * operations by the host, while the last 2 are failed attempts

		 * to abort. Manipulate the return value of the request

		 * appropriately, so that host can convey these results

		 * back to the upper layer.

		/*

		 * We can receive this event from the module

		 * cleanup paths, if the FW forgot to reply to the ABORT WR

		 * and left this ioreq in this state. For now, just ignore

		 * the event. The CLOSE event is sent to this state, as

		 * the LINK may have already gone down.

		/*

		 * Use -ECANCELED to explicitly tell the CLOSED event that

		 * the original I/O was returned to driver by FW.

		 * We dont really care if the I/O was returned with success by

		 * FW (because the CLOSE and completion of the I/O crossed each

		 * other), or any other return value. Once we are in aborting

		 * state, the success or failure of the I/O is unimportant to

		 * us.

		/*

		 * Check if original I/O WR completed before the Close

		 * completion.

		/*

		 * Either close succeeded, or we issued close to FW at the

		 * same time FW compelted it to us. Either way, the I/O

		 * is closed.

		/*

		 * Just succeed the abort request, and hope that

		 * the remote device unregister path will cleanup

		 * this I/O to the upper layer within a sane

		 * amount of time.

		/*

		 * A close can come in during a LINK DOWN. The FW would have

		 * returned us the I/O back, but not the remote device lost

		 * FW event. In this interval, if the I/O times out at the upper

		 * layer, a close can come in. Take the same action as abort:

		 * return success, and hope that the remote device unregister

		 * path will cleanup this I/O. If the FW still doesnt send

		 * the msg, the close times out, and the upper layer resorts

		 * to the next level of error recovery.

/*

 * csio_scsi_cmpl_handler - WR completion handler for SCSI.

 * @hw: HW module.

 * @wr: The completed WR from the ingress queue.

 * @len: Length of the WR.

 * @flb: Freelist buffer array.

 * @priv: Private object

 * @scsiwr: Pointer to SCSI WR.

 *

 * This is the WR completion handler called per completion from the

 * ISR. It is called with lock held. It walks past the RSS and CPL message

 * header where the actual WR is present.

 * It then gets the status, WR handle (ioreq pointer) and the len of

 * the WR, based on WR opcode. Only on a non-good status is the entire

 * WR copied into the WR cache (ioreq->fw_wr).

 * The ioreq corresponding to the WR is returned to the caller.

 * NOTE: The SCSI queue doesnt allocate a freelist today, hence

 * no freelist buffer is expected.

 skip RSS header */

/*

 * csio_scsi_cleanup_io_q - Cleanup the given queue.

 * @scm: SCSI module.

 * @q: Queue to be cleaned up.

 *

 * Called with lock held. Has to exit with lock held.

 Call back the completion routines of the active_q */

		/*

		 * Upper layers may have cleared this command, hence this

		 * check to avoid accessing stale references.

/*

 * csio_scsi_abort_io_q - Abort all I/Os on given queue

 * @scm: SCSI module.

 * @q: Queue to abort.

 * @tmo: Timeout in ms

 *

 * Attempt to abort all I/Os on given queue, and wait for a max

 * of tmo milliseconds for them to complete. Returns success

 * if all I/Os are aborted. Else returns -ETIMEDOUT.

 * Should be entered with lock held. Exits with lock held.

 * NOTE:

 * Lock has to be held across the loop that aborts I/Os, since dropping the lock

 * in between can cause the list to be corrupted. As a result, the caller

 * of this function has to ensure that the number of I/os to be aborted

 * is finite enough to not cause lock-held-for-too-long issues.

 Now abort/close I/Os in the queue passed */

 Wait till all active I/Os are completed/aborted/closed */

 all aborts completed */

/*

 * csio_scsim_cleanup_io - Cleanup all I/Os in SCSI module.

 * @scm: SCSI module.

 * @abort: abort required.

 * Called with lock held, should exit with lock held.

 * Can sleep when waiting for I/Os to complete.

 No I/Os pending */

 Wait until all active I/Os are completed */

 all I/Os completed */

 Else abort */

/*

 * csio_scsim_cleanup_io_lnode - Cleanup all I/Os of given lnode.

 * @scm: SCSI module.

 * @lnode: lnode

 *

 * Called with lock held, should exit with lock held.

 * Can sleep (with dropped lock) when waiting for I/Os to complete.

 No I/Os pending on this lnode  */

 Wait until all active I/Os on this lnode are completed */

 all I/Os completed */

 I/Os are pending, abort them */

 Device reset */

 Delete NPIV lnodes */

 Block upper IOs */

 Unblock upper IOs */

 disable port */

 Block upper IOs */

 Unblock upper IOs */

 Show debug level */

 Store debug level */

 Copy data from driver buffer to SGs of SCSI CMD */

/*

 * csio_scsi_err_handler - SCSI error handler.

 * @hw: HW module.

 * @req: IO request.

 *

 Under run */

		/*

		 * csio_eh_abort_handler checks this value to

		 * succeed or fail the abort request.

 FW timed out the abort itself */

		/*

		 * In firmware, a RDEV can get into this state

		 * temporarily, before moving into dissapeared/lost

		 * state. So, the driver should complete the request equivalent

		 * to device-disappeared!

 Wake up waiting threads */

/*

 * csio_scsi_cbfn - SCSI callback function.

 * @hw: HW module.

 * @req: IO request.

 *

 Error handling */

/**

 * csio_queuecommand - Entry point to kickstart an I/O request.

 * @host:	The scsi_host pointer.

 * @cmnd:	The I/O request from ML.

 *

 * This routine does the following:

 *	- Checks for HW and Rnode module readiness.

 *	- Gets a free ioreq structure (which is already initialized

 *	  to uninit during its allocation).

 *	- Maps SG elements.

 *	- Initializes ioreq members.

 *	- Kicks off the SCSI state machine for this IO.

 *	- Returns busy status on error.

 Get req->nsge, if there are SG elements to be mapped  */

 Do we support so many mappings? */

 Get a free ioreq structure - SM is already set to uninit */

 Set cbfn */

 Needed during abort */

 Kick off SCSI IO SM on the ioreq */

	/*

	 * Use current processor queue for posting the abort/close, but retain

	 * the ingress queue ID of the original I/O being aborted/closed - we

	 * need the abort/close completion to be received on the same queue

	 * as the original I/O.

			/* Return success, if abort/close request issued on

			 * already completed IO

 FW didnt respond to abort within our timeout */

 FW successfully aborted the request */

/*

 * csio_tm_cbfn - TM callback function.

 * @hw: HW module.

 * @req: IO request.

 *

 * Cache the result in 'cmnd', since ioreq will be freed soon

 * after we return from here, and the waiting thread shouldnt trust

 * the ioreq contents.

 Cache FW return status */

 Special handling based on FCP response */

	/*

	 * FW returns us this error, if flags were set. FCP4 says

	 * FCP_RSP_LEN_VAL in flags shall be set for TM completions.

	 * So if a target were to set this bit, we expect that the

	 * rsp_code is set to FCP_TMF_CMPL for a successful TM

	 * completion. Any other rsp_code means TM operation failed.

	 * If a target were to just ignore setting flags, we treat

	 * the TM operation as success, and FW returns FW_SUCCESS.

 Modify return status if flags indicate success */

 Wake up the TM handler thread */

 Lnode is ready, now wait on rport node readiness */

	/*

	 * If we have blocked in the previous call, at this point, either the

	 * remote node has come back online, or device loss timer has fired

	 * and the remote node is destroyed. Allow the LUN reset only for

	 * the former case, since LUN reset is a TMF I/O on the wire, and we

	 * need a valid session to issue it.

 Get a free ioreq structure - SM is already set to uninit */

	/*

	 * FW times the LUN reset for ioreq->tmo, so we got to wait a little

	 * longer (10s for now) than that to allow FW to return the timed

	 * out command.

 Set cbfn */

 Save of the ioreq info for later use */

 Kick off TM SM on the ioreq */

 Wait for completion */

 LUN reset timed-out */

 LUN reset returned, check cached status */

 LUN reset succeeded, Start aborting affected I/Os */

	/*

	 * Since the host guarantees during LUN reset that there

	 * will not be any more I/Os to that LUN, until the LUN reset

	 * completes, we gather pending I/Os after the LUN reset.

 Aborts may have timed out */

 Return I/Os back to active_q */

/*

 * csio_scsi_alloc_ddp_bufs - Allocate buffers for DDP of unaligned SGLs.

 * @scm: SCSI Module

 * @hw: HW device.

 * @buf_size: buffer size

 * @num_buf : Number of buffers.

 *

 * This routine allocates DMA buffers required for SCSI Data xfer, if

 * each SGL buffer for a SCSI Read request posted by SCSI midlayer are

 * not virtually contiguous.

 Align buf size to page size */

 Initialize dma descriptors */

 Set unit size to request size */

 Allocate Dma buffers for DDP */

 Added it to scsi ddp freelist */

 release dma descs back to freelist and free dma memory */

/*

 * csio_scsi_free_ddp_bufs - free DDP buffers of unaligned SGLs.

 * @scm: SCSI Module

 * @hw: HW device.

 *

 * This routine frees ddp buffers.

 release dma descs back to freelist and free dma memory */

/**

 * csio_scsim_init - Initialize SCSI Module

 * @scm:	SCSI Module

 * @hw:		HW module

 *

 Pre-allocate ioreqs and initialize them */

 Allocate Dma buffers for Response Payload */

 Set state to uninit */

	/*

	 * Free up existing allocations, since an error

	 * from here means we are returning for good

/**

 * csio_scsim_exit: Uninitialize SCSI Module

 * @scm: SCSI Module

 *

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *	Adaptec AAC series RAID controller driver

 *	(c) Copyright 2001 Red Hat Inc.

 *

 * based on the old aacraid driver that is..

 * Adaptec aacraid device driver for Linux.

 *

 * Copyright (c) 2000-2010 Adaptec, Inc.

 *               2010-2015 PMC-Sierra, Inc. (aacraid@pmc-sierra.com)

 *		 2016-2017 Microsemi Corp. (aacraid@microsemi.com)

 *

 * Module Name:

 *  sa.c

 *

 * Abstract: Drawbridge specific support functions

	/*

	 *	Read mask and invert because drawbridge is reversed.

	 *	This allows us to only service interrupts that have been enabled.

 Check to see if this is our interrupt.  If it isn't just return */

 clear PrintfReady */

 dev -> Host Normal Command Ready

 dev -> Host Normal Response Ready

 dev -> Host Normal Command Not Full

 dev -> Host Normal Response Not Full

/**

 *	aac_sa_disable_interrupt	-	disable interrupt

 *	@dev: Which adapter to enable.

/**

 *	aac_sa_enable_interrupt	-	enable interrupt

 *	@dev: Which adapter to enable.

/**

 *	aac_sa_notify_adapter		-	handle adapter notification

 *	@dev:	Adapter that notification is for

 *	@event:	Event to notidy

 *

 *	Notify the adapter of an event

		/*

		sa_sync_cmd(dev, HOST_CRASHING, 0, 0, 0, 0, 0, 0,

		NULL, NULL, NULL, NULL, NULL);

/**

 *	sa_sync_cmd	-	send a command and wait

 *	@dev: Adapter

 *	@command: Command to execute

 *	@p1: first parameter

 *	@p2: second parameter

 *	@p3: third parameter

 *	@p4: forth parameter

 *	@p5: fifth parameter

 *	@p6: sixth parameter

 *	@ret: adapter status

 *	@r1: first return value

 *	@r2: second return value

 *	@r3: third return value

 *	@r4: forth return value

 *

 *	This routine will send a synchronous command to the adapter and wait

 *	for its	completion.

	/*

	 *	Write the Command into Mailbox 0

	/*

	 *	Write the parameters into Mailboxes 1 - 4

	/*

	 *	Clear the synch command doorbell to start on a clean slate.

	/*

	 *	Signal that there is a new synch command

		/*

		 *	Delay 5uS so that the monitor gets access

		/*

		 *	Mon110 will set doorbell0 bit when it has 

		 *	completed the command.

	/*

	 *	Clear the synch command doorbell.

	/*

	 *	Pull the synch status from Mailbox 0.

/**

 *	aac_sa_interrupt_adapter	-	interrupt an adapter

 *	@dev: Which adapter to enable.

 *

 *	Breakpoint an adapter.

/**

 *	aac_sa_start_adapter		-	activate adapter

 *	@dev:	Adapter

 *

 *	Start up processing on an ARM based AAC adapter

	/*

	 * Fill in the remaining pieces of the init.

 We can only use a 32 bit address here */

/**

 *	aac_sa_check_health

 *	@dev: device to check if healthy

 *

 *	Will attempt to determine if the specified adapter is alive and

 *	capable of handling requests, returning 0 if alive.

	/*

	 *	Check to see if the board failed any self tests.

	/*

	 *	Check to see if the board panic'd while booting.

	/*

	 *	Wait for the adapter to be up and running. Wait up to 3 minutes

	/*

	 *	Everything is OK

/**

 *	aac_sa_ioremap

 *	@dev: device to ioremap

 *	@size: mapping resize request

 *

/**

 *	aac_sa_init	-	initialize an ARM based AAC card

 *	@dev: device to configure

 *

 *	Allocate and set up resources for the ARM based AAC variants. The

 *	device_interface in the commregion will be allocated and linked

 *	to the comm region.

	/*

	 *	Fill in the function dispatch table.

	/*

	 *	Check to see if the board failed any self tests.

	/*

	 *	Check to see if the board panic'd while booting.

	/*

	 *	Wait for the adapter to be up and running. Wait up to 3 minutes.

	/*

	 *	First clear out all interrupts.  Then enable the one's that 

	 *	we can handle.

 sync. mode not supported */

	/*

	 *	Tell the adapter that all is configure, and it can start 

	 *	accepting requests

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *	Adaptec AAC series RAID controller driver

 *	(c) Copyright 2001 Red Hat Inc.

 *

 * based on the old aacraid driver that is..

 * Adaptec aacraid device driver for Linux.

 *

 * Copyright (c) 2000-2010 Adaptec, Inc.

 *               2010-2015 PMC-Sierra, Inc. (aacraid@pmc-sierra.com)

 *		 2016-2017 Microsemi Corp. (aacraid@microsemi.com)

 *

 * Module Name:

 *   linit.c

 *

 * Abstract: Linux Driver entry module for Adaptec RAID Array Controller

/*

 * Because of the way Linux names scsi devices, the order in this table has

 * become important.  Check for on-board Raid first, add-in cards second.

 *

 * Note: The last field is used to index into aac_drivers below.

 PERC 2/Si (Iguana/PERC2Si) */

 PERC 3/Di (Opal/PERC3Di) */

 PERC 3/Si (SlimFast/PERC3Si */

 PERC 3/Di (Iguana FlipChip/PERC3DiF */

 PERC 3/Di (Viper/PERC3DiV) */

 PERC 3/Di (Lexus/PERC3DiL) */

 PERC 3/Di (Jaguar/PERC3DiJ) */

 PERC 3/Di (Dagger/PERC3DiD) */

 PERC 3/Di (Boxster/PERC3DiB) */

 catapult */

 tomcat */

 Adaptec 2120S (Crusader) */

 Adaptec 2200S (Vulcan) */

 Adaptec 2200S (Vulcan-2m) */

 Legend S220 (Legend Crusader) */

 Legend S230 (Legend Vulcan) */

 Adaptec 3230S (Harrier) */

 Adaptec 3240S (Tornado) */

 ASR-2020ZCR SCSI PCI-X ZCR (Skyhawk) */

 ASR-2025ZCR SCSI SO-DIMM PCI-X ZCR (Terminator) */

 ASR-2230S + ASR-2230SLP PCI-X (Lancer) */

 ASR-2130S (Lancer) */

 AAR-2820SA (Intruder) */

 AAR-2620SA (Intruder) */

 AAR-2420SA (Intruder) */

 ICP9024RO (Lancer) */

 ICP9014RO (Lancer) */

 ICP9047MA (Lancer) */

 ICP9087MA (Lancer) */

 ICP5445AU (Hurricane44) */

 ICP9085LI (Marauder-X) */

 ICP5085BR (Marauder-E) */

 ICP9067MA (Intruder-6) */

 Themisto Jupiter Platform */

 Themisto Jupiter Platform */

 Callisto Jupiter Platform */

 ASR-2020SA SATA PCI-X ZCR (Skyhawk) */

 ASR-2025SA SATA SO-DIMM PCI-X ZCR (Terminator) */

 AAR-2410SA PCI SATA 4ch (Jaguar II) */

 CERC SATA RAID 2 PCI SATA 6ch (DellCorsair) */

 AAR-2810SA PCI SATA 8ch (Corsair-8) */

 AAR-21610SA PCI SATA 16ch (Corsair-16) */

 ESD SO-DIMM PCI-X SATA ZCR (Prowler) */

 AAR-2610SA PCI SATA 6ch */

 ASR-2240S (SabreExpress) */

 ASR-4005 */

 IBM 8i (AvonPark) */

 IBM 8i (AvonPark Lite) */

 IBM 8k/8k-l8 (Aurora) */

 IBM 8k/8k-l4 (Aurora Lite) */

 ASR-4000 (BlackBird) */

 ASR-4800SAS (Marauder-X) */

 ASR-4805SAS (Marauder-E) */

 ASR-3800 (Hurricane44) */

 Perc 320/DC*/

 Adaptec 5400S (Mustang)*/

 Adaptec 5400S (Mustang)*/

 Dell PERC2/QC */

 HP NetRAID-4M */

 Dell Catchall */

 Legend Catchall */

 Adaptec Catch All */

 Adaptec Rocket Catch All */

 Adaptec NEMER/ARK Catch All */

 Adaptec PMC Series 6 (Tupelo) */

 Adaptec PMC Series 7 (Denali) */

 Adaptec PMC Series 8 */

/*

 * dmb - For now we add the number of channels to this structure.

 * In the future we should add a fib that reports the number of channels

 * for the card.  At that time we can remove the channels from here

 PERC 2/Si (Iguana/PERC2Si) */

 PERC 3/Di (Opal/PERC3Di) */

 PERC 3/Si (SlimFast/PERC3Si */

 PERC 3/Di (Iguana FlipChip/PERC3DiF */

 PERC 3/Di (Viper/PERC3DiV) */

 PERC 3/Di (Lexus/PERC3DiL) */

 PERC 3/Di (Jaguar/PERC3DiJ) */

 PERC 3/Di (Dagger/PERC3DiD) */

 PERC 3/Di (Boxster/PERC3DiB) */

 catapult */

 tomcat */

 Adaptec 2120S (Crusader) */

 Adaptec 2200S (Vulcan) */

 Adaptec 2200S (Vulcan-2m) */

 Legend S220 (Legend Crusader) */

 Legend S230 (Legend Vulcan) */

 Adaptec 3230S (Harrier) */

 Adaptec 3240S (Tornado) */

 ASR-2020ZCR SCSI PCI-X ZCR (Skyhawk) */

 ASR-2025ZCR SCSI SO-DIMM PCI-X ZCR (Terminator) */

 ASR-2230S + ASR-2230SLP PCI-X (Lancer) */

 ASR-2130S (Lancer) */

 AAR-2820SA (Intruder) */

 AAR-2620SA (Intruder) */

 AAR-2420SA (Intruder) */

 ICP9024RO (Lancer) */

 ICP9014RO (Lancer) */

 ICP9047MA (Lancer) */

 ICP9087MA (Lancer) */

 ICP5445AU (Hurricane44) */

 ICP9085LI (Marauder-X) */

 ICP5085BR (Marauder-E) */

 ICP9067MA (Intruder-6) */

 Jupiter Platform */

 Jupiter Platform */

 ASR-2020SA SATA PCI-X ZCR (Skyhawk) */

 ASR-2025SA SATA SO-DIMM PCI-X ZCR (Terminator) */

 AAR-2410SA PCI SATA 4ch (Jaguar II) */

 CERC SATA RAID 2 PCI SATA 6ch (DellCorsair) */

 AAR-2810SA PCI SATA 8ch (Corsair-8) */

 AAR-21610SA PCI SATA 16ch (Corsair-16) */

 ESD SO-DIMM PCI-X SATA ZCR (Prowler) */

 SATA 6Ch (Bearcat) */

 ASR-2240S (SabreExpress) */

 ASR-4005 */

 IBM 8i (AvonPark) */

 IBM 8k/8k-l8 (Aurora) */

 IBM 8k/8k-l4 (Aurora Lite) */

 ASR-4000 (BlackBird & AvonPark) */

 ASR-4800SAS (Marauder-X) */

 ASR-4805SAS (Marauder-E) */

 ASR-3800 (Hurricane44) */

 Perc 320/DC*/

 Adaptec 5400S (Mustang)*/

 Adaptec 5400S (Mustang)*/

 Dell PERC2/QC */

 HP NetRAID-4M */

 Dell Catchall */

 Legend Catchall */

 Adaptec Catch All */

 Adaptec Rocket Catch All */

 Adaptec NEMER/ARK Catch All */

 Adaptec PMC Series 6 (Tupelo) */

 Adaptec PMC Series 7 (Denali) */

 Adaptec PMC Series 8 */

/**

 *	aac_queuecommand	-	queue a SCSI command

 *	@shost:		Scsi host to queue command on

 *	@cmd:		SCSI command to queue

 *

 *	Queues a command for execution by the associated Host Adapter.

 *

 *	TODO: unify with aac_scsi_cmd().

/**

 *	aac_info		-	Returns the host adapter name

 *	@shost:		Scsi host to report on

 *

 *	Returns a static string describing the device in question

/**

 *	aac_get_driver_ident

 *	@devtype: index into lookup table

 *

 *	Returns a pointer to the entry in the driver lookup table.

/**

 *	aac_biosparm	-	return BIOS parameters for disk

 *	@sdev: The scsi device corresponding to the disk

 *	@bdev: the block device corresponding to the disk

 *	@capacity: the sector capacity of the disk

 *	@geom: geometry block to fill in

 *

 *	Return the Heads/Sectors/Cylinders BIOS Disk Parameters for Disk.

 *	The default disk geometry is 64 heads, 32 sectors, and the appropriate

 *	number of cylinders so as not to exceed drive capacity.  In order for

 *	disks equal to or larger than 1 GB to be addressable by the BIOS

 *	without exceeding the BIOS limitation of 1024 cylinders, Extended

 *	Translation should be enabled.   With Extended Translation enabled,

 *	drives between 1 GB inclusive and 2 GB exclusive are given a disk

 *	geometry of 128 heads and 32 sectors, and drives above 2 GB inclusive

 *	are given a disk geometry of 255 heads and 63 sectors.  However, if

 *	the BIOS detects that the Extended Translation setting does not match

 *	the geometry in the partition table, then the translation inferred

 *	from the partition table will be used by the BIOS, and a warning may

 *	be displayed.

	/*

	 *	Assuming extended translation is enabled - #REVISIT#

 1 GB in 512 byte sectors */

 2 GB in 512 byte sectors */

	/*

	 *	Read the first 1024 bytes from the disk device, if the boot

	 *	sector partition table is valid, search for a partition table

	 *	entry whose end_head matches one of the standard geometry

	 *	translations ( 64/32, 128/32, 255/63 ).

/**

 *	aac_slave_configure		-	compute queue depths

 *	@sdev:	SCSI device we are considering

 *

 *	Selects queue depths for each target device based on the host adapter's

 *	total capacity and the queue depth supported by the target device.

 *	A queue depth of one automatically disables tagged queueing.

	/*

	 * Check if SATA drive

	/*

	 * Firmware has an individual device recovery time typically

	 * of 35 seconds, give us a margin. Thor devices can take longer in

	 * error recovery, hence different value.

/**

 *	aac_change_queue_depth		-	alter queue depths

 *	@sdev:	SCSI device we are considering

 *	@depth:	desired queue depth

 *

 *	Alters queue depths for target device based on the host adapter's

 *	total capacity and the queue depth supported by the target device.

 Called during SCSI EH, so we don't need to block requests */

 start a HBA_TMF_ABORT_TASK TMF request */

 Wait up to 15 secs for completion */

			/*

			 * Mark associated FIB to not complete,

			 * eh handler does this

			/*

			 * Mark associated FIB to not complete,

			 * eh handler does this

 start a HBA_TMF_LUN_RESET TMF request */

 already tried, start a hard reset now */

/*

 *	aac_eh_dev_reset	- Device reset command handling

 *	@scsi_cmd:	SCSI command block causing the reset

 *

 start a HBA_TMF_LUN_RESET TMF request */

 Wait up to 15 seconds for completion */

/*

 *	aac_eh_target_reset	- Target reset command handling

 *	@scsi_cmd:	SCSI command block causing the reset

 *

 already tried, start a hard reset now */

 Wait up to 15 seconds for completion */

/*

 *	aac_eh_bus_reset	- Bus reset command handling

 *	@scsi_cmd:	SCSI command block causing the reset

 *

 Mark the assoc. FIB to not complete, eh handler does this */

	/*

	 * Check the health of the controller

/*

 *	aac_eh_host_reset	- Host reset command handling

 *	@scsi_cmd:	SCSI command block causing the reset

 *

	/*

	 * Check if reset is supported by the firmware

	/*

	 * This adapter needs a blind reset, only do so for

	 * Adapters that support a register, instead of a commanded,

	 * reset.

 Bypass wait for command quiesce */

	/*

	 * Reset EH state

/**

 *	aac_cfg_open		-	open a configuration file

 *	@inode: inode being opened

 *	@file: file handle attached

 *

 *	Called when the configuration device is opened. Does the needed

 *	set up on the handle and then returns

 *

 *	Bugs: This needs extending to check a given adapter is present

 *	so we can support hot plugging, and to ref count adapters.

 BKL pushdown: nothing else protects this list */

/**

 *	aac_cfg_ioctl		-	AAC configuration request

 *	@file: file handle

 *	@cmd: ioctl command code

 *	@arg: argument

 *

 *	Handles a configuration ioctl. Currently this involves wrapping it

 *	up and feeding it into the nasty windowsalike glue layer.

 *

 *	Bugs: Needs locking against parallel ioctls lower down

 *	Bugs: Needs to handle hot plugging

 Clear out events first */

	/*

	 * Firmware may send a AIF messages very early and the Driver may have

	 * ignored as it is not fully ready to process the messages. Send

	 * AIF to firmware so that if there are any unprocessed events they

	 * can be processed now.

	/*

	 * Only series 7 needs freset.

	/*

	 * If the quirk31 bit is set, the adapter needs adapter

	 * to driver communication memory to be allocated below 2gig

	/*

	 *	Map in the registers from the adapter.

	/*

	 *	Start any kernel threads needed

	/*

	 * Lets override negotiations and drop the maximum SG limit to 34

	/*

	 * Firmware printf works only with older firmware.

	/*

	 * max channel will be the physical channels plus 1 virtual channel

	 * all containers are on the virtual channel 0 (CONTAINER_CHANNEL)

	 * physical channels are address by their actual physical number+1

	/*

	 * dmb - we may need to move the setting of these parms somewhere else once

	 * we get a fib that can report the actual numbers

	/*

	 *	First clear out all interrupts.  Then enable the one's that we

	 *	can handle.

	/*max msix may change  after EEH

	 * Re-assign vectors to fibs

		/* After EEH recovery or suspend resume, max_msix count

		 * may change, therefore updating in init as well.

	/*

	* reset this flag to unblock ioctl() as it was set at

	* aac_send_shutdown() to block ioctls from upperlayer

 remap failed, go back ... */

	/*

	 * reset this flag to unblock ioctl() as it was set

	 * at aac_send_shutdown() to block ioctls from upperlayer

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *	Adaptec AAC series RAID controller driver

 *	(c) Copyright 2001 Red Hat Inc.

 *

 * based on the old aacraid driver that is..

 * Adaptec aacraid device driver for Linux.

 *

 * Copyright (c) 2000-2010 Adaptec, Inc.

 *               2010-2015 PMC-Sierra, Inc. (aacraid@pmc-sierra.com)

 *               2016-2017 Microsemi Corp. (aacraid@microsemi.com)

 *

 * Module Name:

 *  comminit.c

 *

 * Abstract: This supports the initialization of the host adapter commuication interface.

 *    This is a platform dependent module for the pci cyclone board.

		/*

		 *	Adapter Fibs are the first thing allocated so that they

		 *	start page aligned

		/*

		 * number of 4k pages of host physical memory. The aacraid fw

		 * needs this number to be less than 4gb worth of pages. New

		 * firmware doesn't have any issues with the mapping system, but

		 * older Firmware did, and had *troubles* dealing with the math

		 * overloading past 32 bits, thus we must limit this field.

 must be the COMM_PREFERRED_SETTINGS values */

	/*

	 * Increment the base address by the amount already used

	/*

	 *	Align the beginning of Headers to commalign

	/*

	 *	Fill in addresses of the Comm Area Headers and Queues

	/*

	 *	Increment the base address by the size of the CommArea

	/*

	 *	 Place the Printf buffer area after the Fast I/O comm area.

		/*

		 * We can exit If all the commands are complete

/**

 *	aac_send_shutdown		-	shutdown an adapter

 *	@dev: Adapter to shutdown

 *

 *	This routine will send a VM_CloseAll (shutdown) request to the adapter.

 Timeout silently */, 1,

 FIB should be freed only after getting the response from the F/W */

/**

 *	aac_comm_init	-	Initialise FSA data structures

 *	@dev:	Adapter to initialise

 *

 *	Initializes the data structures that are required for the FSA commuication

 *	interface to operate. 

 *	Returns

 *		1 - if we were able to init the commuication interface.

 *		0 - If there were errors initing. This is a fatal error.

	/*

	 *	Now allocate and initialize the zone structures used as our 

	 *	pool of FIB context records.  The size of the zone is based

	 *	on the system memory size.  We also initialize the mutex used

	 *	to protect the zone.

	/*

	 *	Allocate the physically contiguous space for the commuication

	 *	queue headers. 

 Adapter to Host normal priority Command queue */ 

 Adapter to Host high priority command queue */

 Host to adapter normal priority command queue */

 host to adapter high priority command queue */

 adapter to host normal priority response queue */

 adapter to host high priority response queue */

 host to adapter normal priority response queue */

 host to adapter high priority response queue */ 

 max. vectors from GET_COMM_PREFERRED_SETTINGS */

 Don't bother allocating more MSI-X vectors than cpus */

	/*

	 *	Check the preferred comm settings, defaults from template.

	/*

	 * Enable INTX mode, if not done already Enabled

 driver supports TYPE1 (Tupelo) */

 driver supports TYPE2 (Denali, Yosemite) */

 driver supports TYPE3 (Yosemite, Thor) */

 not supported TYPE - switch to sync. mode */

 remap failed, go back ... */

		/*

		 *	status[1] >> 16		maximum command size in KB

		 *	status[1] & 0xFFFF	maximum FIB size

		 *	status[2] >> 16		maximum SG elements to driver

		 *	status[2] & 0xFFFF	maximum SG elements from driver

		 *	status[3] & 0xFFFF	maximum number FIBs outstanding

 Multiple of 32 for PMC */

	/*

	 *	Ok now init the communication subsystem

	/*

	 *	Initialize the list of fibs

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *	Adaptec AAC series RAID controller driver

 *	(c) Copyright 2001 Red Hat Inc.

 *

 * based on the old aacraid driver that is..

 * Adaptec aacraid device driver for Linux.

 *

 * Copyright (c) 2000-2010 Adaptec, Inc.

 *               2010-2015 PMC-Sierra, Inc. (aacraid@pmc-sierra.com)

 *		 2016-2017 Microsemi Corp. (aacraid@microsemi.com)

 *

 * Module Name:

 *  commsup.c

 *

 * Abstract: Contain all routines that are required for FSA host/adapter

 *    communication.

/**

 *	fib_map_alloc		-	allocate the fib objects

 *	@dev: Adapter to allocate for

 *

 *	Allocate and map the shared PCI space for the FIB blocks used to

 *	talk to the Adaptec firmware.

/**

 *	aac_fib_map_free		-	free the fib objects

 *	@dev: Adapter to free

 *

 *	Free the PCI mappings and the memory allocated for FIB blocks

 *	on this adapter.

/**

 *	aac_fib_setup	-	setup the fibs

 *	@dev: Adapter to set up

 *

 *	Allocate the PCI space for the fibs, map it and then initialise the

 *	fib area, the unmapped fib data and also the free list

 32 byte alignment for PMC */

 add Xport header */

	/*

	 *	Initialise the fibs

 Forward chain the fibs */

 ?? max_cmd_size */

		/*

		 * one element is for the ptr to the separate sg list,

		 * second element for 32 byte alignment

	/*

	 *Assign vector numbers to fibs

	/*

	 *	Add the fib chain to the free list

	/*

	*	Set 8 fibs aside for management tools

/**

 *	aac_fib_alloc_tag-allocate a fib using tags

 *	@dev: Adapter to allocate the fib for

 *	@scmd: SCSI command

 *

 *	Allocate a fib from the adapter fib pool using tags

 *	from the blk layer.

	/*

	 *	Null out fields that depend on being zero at the start of

	 *	each I/O

/**

 *	aac_fib_alloc	-	allocate a fib

 *	@dev: Adapter to allocate the fib for

 *

 *	Allocate a fib from the adapter fib pool. If the pool is empty we

 *	return NULL.

	/*

	 *	Set the proper node type code and node byte size

	/*

	 *	Null out fields that depend on being zero at the start of

	 *	each I/O

/**

 *	aac_fib_free	-	free a fib

 *	@fibptr: fib to free up

 *

 *	Frees up a fib and places it on the appropriate queue

/**

 *	aac_fib_init	-	initialise a fib

 *	@fibptr: The fib to initialize

 *

 *	Set up the generic fib fields ready for use

/**

 *	fib_dealloc		-	deallocate a fib

 *	@fibptr: fib to deallocate

 *

 *	Will deallocate and return to the free pool the FIB pointed to by the

 *	caller.

/*

 *	Commuication primitives define and support the queuing method we use to

 *	support host to adapter commuication. All queue accesses happen through

 *	these routines and are the only routines which have a knowledge of the

 *	 how these queues are implemented.

/**

 *	aac_get_entry		-	get a queue entry

 *	@dev: Adapter

 *	@qid: Queue Number

 *	@entry: Entry return

 *	@index: Index return

 *	@nonotify: notification control

 *

 *	With a priority the routine returns a queue entry if the queue has free entries. If the queue

 *	is full(no free entries) than no entry is returned and the function returns 0 otherwise 1 is

 *	returned.

	/*

	 *	All of the queues wrap when they reach the end, so we check

	 *	to see if they have reached the end and if they have we just

	 *	set the index back to zero. This is a wrap. You could or off

	 *	the high bits in all updates but this is a bit faster I think.

 Interrupt Moderation, only interrupt for first two entries */

 Wrap to front of the Producer Queue. */

 Wrap to front of the Producer Queue. */

 Queue is full */

/**

 *	aac_queue_get		-	get the next free QE

 *	@dev: Adapter

 *	@index: Returned index

 *	@qid: Queue number

 *	@hw_fib: Fib to associate with the queue entry

 *	@wait: Wait if queue full

 *	@fibptr: Driver fib object to go with fib

 *	@nonotify: Don't notify the adapter

 *

 *	Gets the next free QE off the requested priorty adapter command

 *	queue and associates the Fib with the QE. The QE represented by

 *	index is ready to insert on the queue when this routine returns

 *	success.

  if no entries wait for some if caller wants to */

		/*

		 *	Setup queue entry with a command, status and fib mapped

 if no entries wait for some if caller wants to */

		/*

		 *	Setup queue entry with command, status and fib mapped

 Restore adapters pointer to the FIB */

 Let the adapter now where to find its data */

	/*

	 *	If MapFib is true than we need to map the Fib and put pointers

	 *	in the queue entry.

/*

 *	Define the highest level of host to adapter communication routines.

 *	These routines will support host to adapter FS commuication. These

 *	routines have no knowledge of the commuication method used. This level

 *	sends and receives FIBs. This level has no knowledge of how these FIBs

 *	get passed back and forth.

/**

 *	aac_fib_send	-	send a fib to the adapter

 *	@command: Command to send

 *	@fibptr: The fib

 *	@size: Size of fib data area

 *	@priority: Priority of Fib

 *	@wait: Async/sync select

 *	@reply: True if a reply is wanted

 *	@callback: Called with reply

 *	@callback_data: Passed to callback

 *

 *	Sends the requested FIB to the adapter and optionally will wait for a

 *	response FIB. If the caller does not wish to wait for a response than

 *	an event to wait on must be supplied. This event will be set when a

 *	response FIB is received from the adapter.

	/*

	 *	There are 5 cases with the wait and response requested flags.

	 *	The only invalid cases are if the caller requests to wait and

	 *	does not request a response and if the caller does not want a

	 *	response and the Fib is not allocated from pool. If a response

	 *	is not requested the Fib will just be deallocaed by the DPC

	 *	routine when the response comes back from the adapter. No

	 *	further processing will be done besides deleting the Fib. We

	 *	will have a debug mode where the adapter can notify the host

	 *	it had a problem and the host can log that fact.

	/*

	 *	Map the fib into 32bits by using the fib number

	/* use the same shifted value for handle to be compatible

	 * with the new native hba command handle

	/*

	 *	Set FIB state to indicate where it came from and if we want a

	 *	response from the adapter. Also load the command from the

	 *	caller.

	 *

	 *	Map the hw fib pointer as a 32bit value

	/*

	 *	Set the size of the Fib we want to send to the adapter

	/*

	 *	Get a queue entry connect the FIB to it and send an notify

	 *	the adapter a command is ready.

	/*

	 *	Fill in the Callback and CallbackContext if we are not

	 *	going to wait.

	/*

	 *	If the caller wanted us to wait for response wait now.

 Only set for first known interruptable command */

			/*

			 * *VERY* Dangerous to time out a command, the

			 * assumption is made that we have no hope of

			 * functioning because an interrupt routing or other

			 * hardware failure has occurred.

 3 minutes */

				/*

				 * Allow other processes / CPUS to use core

			/* Do nothing ... satisfy

 Tell interrupt we aborted */

	/*

	 *	If the user does not want a response than return success otherwise

	 *	return pending

 bit1 of request_id must be 0 */

 Tell interrupt we aborted */

/**

 *	aac_consumer_get	-	get the top of the queue

 *	@dev: Adapter

 *	@q: Queue

 *	@entry: Return entry

 *

 *	Will return a pointer to the entry on the top of the queue requested that

 *	we are a consumer of, and return the address of the queue entry. It does

 *	not change the state of the queue.

		/*

		 *	The consumer index must be wrapped if we have reached

		 *	the end of the queue, else we just use the entry

		 *	pointed to by the header index

/**

 *	aac_consumer_free	-	free consumer entry

 *	@dev: Adapter

 *	@q: Queue

 *	@qid: Queue ident

 *

 *	Frees up the current top of the queue we are a consumer of. If the

 *	queue was full notify the producer that the queue is no longer full.

/**

 *	aac_fib_adapter_complete	-	complete adapter issued fib

 *	@fibptr: fib to complete

 *	@size: size of fib

 *

 *	Will do all necessary work to complete a FIB that was sent from

 *	the adapter.

	/*

	 *	If we plan to do anything check the structure type first.

	/*

	 *	This block handles the case where the adapter had sent us a

	 *	command and we have finished processing the command. We

	 *	call completeFib when we are done processing the command

	 *	and want to send a response back to the adapter. This will

	 *	send the completed cdb to the adapter.

/**

 *	aac_fib_complete	-	fib completion handler

 *	@fibptr: FIB to complete

 *

 *	Will do all necessary work to complete a FIB.

	/*

	 *	Check for a fib which has already been completed or with a

	 *	status wait timeout

	/*

	 *	If we plan to do anything check the structure type first.

	/*

	 *	This block completes a cdb which orginated on the host and we

	 *	just need to deallocate the cdb or reinit it. At this point the

	 *	command is complete that we had sent to the adapter and this

	 *	cdb could be reused.

		/*

		 *	This handles the case when the host has aborted the I/O

		 *	to the adapter because the adapter is not responding

/**

 *	aac_printf	-	handle printf from firmware

 *	@dev: Adapter

 *	@val: Message info

 *

 *	Print a message passed to us by the controller firmware on the

 *	Adaptec board

		/*

		 *	The size of the printfbuf is set in port.c

		 *	There is no variable or define for it

/**

 *	aac_handle_aif		-	Handle a message from the firmware

 *	@dev: Which adapter this fib is from

 *	@fibptr: Pointer to fibptr from adapter

 *

 *	This routine handles a driver notify fib from the adapter and

 *	dispatches it to the appropriate routine for handling.

 Sniff for container changes */

	/*

	 *	We have set this up to try and minimize the number of

	 * re-configures that take place. As a result of this when

	 * certain AIF's come in we will set a flag waiting for another

	 * type of AIF before setting the re-config flag.

		/*

		 *	Morph or Expand complete

			/*

			 *	Find the scsi_device associated with the SCSI

			 * address. Make sure we have the right array, and if

			 * so set the flag to initiate a new re-config once we

			 * see an AifEnConfigChange AIF come through.

		/*

		 *	If we are waiting on something and this happens to be

		 * that thing then set the re-configure flag.

		/*

		 *	Add an Array.

		/*

		 *	Delete an Array.

		/*

		 *	Container change detected. If we currently are not

		 * waiting on something else, setup to wait on a Config Change.

			/*

			 * If in JBOD mode, automatic exposure of new

			 * physical target to be suppressed until configured.

 legacy dev_t ? */

		/*

		 *	If we are waiting on something and this happens to be

		 * that thing then set the re-configure flag.

		/*

		 *	These are job progress AIF's. When a Clear is being

		 * done on a container it is initially created then hidden from

		 * the OS. When the clear completes we don't get a config

		 * change so we monitor the job status complete on a clear then

		 * wait for a container change.

				/*

				 * Stomp on all config sequencing for all

				 * containers?

				/*

				 * Stomp on all config sequencing for all

				 * containers?

	/*

	 *	If we decided that a re-configuration needs to be done,

	 * schedule it here on the way out the door, please close the door

	 * behind you.

	/*

	 *	Find the scsi_device associated with the SCSI address,

	 * and mark it as changed, invalidating the cache. This deals

	 * with changes to existing device IDs.

	/*

	 * force reload of disk info via aac_probe_container

	/*

	 * Assumptions:

	 *	- host is locked, unless called by the aacraid thread.

	 *	  (a matter of convenience, due to legacy issues surrounding

	 *	  eh_host_adapter_reset).

	 *	- in_reset is asserted, so no new i/o is getting to the

	 *	  card.

	 *	- The card is dead, or will be very shortly ;-/ so no new

	 *	  commands are completing in the interrupt service.

	/*

	 *	If a positive health, means in a known DEAD PANIC

	 * state and the adapter could be reset to `try again'.

	/*

	 *	Loop through the fibs, close the synchronous FIBS

 Give some extra time for ioctls to complete. */

	/*

	 * Re-initialize the adapter, first free resources, then carefully

	 * apply the initialization sequence to come back again. Only risk

	 * is a change in Firmware dropping cache, it is assumed the caller

	 * will ensure that i/o is queisced and the card is flushed in that

	 * case.

	/*

	 * This is where the assumption that the Adapter is quiesced

	 * is important.

	/*

	 * Issue bus rescan to catch any configuration that might have

	 * occurred

	/*

	 * Wait for all commands to complete to this specific

	 * target (block maximum 60 seconds). Although not necessary,

	 * it does make us a good storage citizen.

 Quiesce build, flush cache, write through mode */

 Unwind aac_send_shutdown() IOP_RESET unsupported/disabled */

 Timeout silently */, 1,

			/* FIB should be freed only after getting

 Extending the scope of fib_lock slightly to protect aac->in_reset */

 OK */

	/* Fake up an AIF:

	 *	aac_aifcmd.command = AifCmdEventNotify = 1

	 *	aac_aifcmd.seqnum = 0xFFFFFFFF

	 *	aac_aifcmd.data[0] = AifEnExpEvent = 23

	 *	aac_aifcmd.data[1] = AifExeFirmwarePanic = 3

	 *	aac.aifcmd.data[2] = AifHighPriority = 3

	 *	aac.aifcmd.data[3] = BlinkLED

	/*

	 * For each Context that is on the

	 * fibctxList, make a copy of the

	 * fib, and then set the event to wake up the

	 * thread that is waiting for it.

		/*

		 * Extract the fibctx

		/*

		 * Check if the queue is getting

		 * backlogged

			/*

			 * It's *not* jiffies folks,

			 * but jiffies / HZ, so do not

			 * panic ...

			/*

			 * Has it been > 2 minutes

			 * since the last read off

			 * the queue?

		/*

		 * Warning: no sleep allowed while

		 * holding spinlock

			/*

			 * Put the FIB onto the

			 * fibctx's fibs

			/*

			 * Set the event to wake up the

			 * thread that will waiting.

/**

 *	aac_handle_sa_aif -	Handle a message from the firmware

 *	@dev: Which adapter this fib is from

 *	@fibptr: Pointer to fibptr from adapter

 *

 *	This routine handles a driver notify fib from the adapter and

 *	dispatches it to the appropriate routine for handling.

 currently do nothing */

	/*

	 * Warning: no sleep allowed while

	 * holding spinlock. We take the estimate

	 * and pre-allocate a set of fibs outside the

	 * lock.

 some extra */

	/*

	 * Get the actual number of allocated fibs

	/*

	 * For each Context that is on the

	 * fibctxList, make a copy of the

	 * fib, and then set the event to wake up the

	 * thread that is waiting for it.

		/*

		 * Extract the fibctx

		/*

		 * Check if the queue is getting

		 * backlogged

			/*

			 * It's *not* jiffies folks,

			 * but jiffies / HZ so do not

			 * panic ...

			/*

			 * Has it been > 2 minutes

			 * since the last read off

			 * the queue?

		/*

		 * Warning: no sleep allowed while

		 * holding spinlock

		/*

		 * Make the copy of the FIB

		/*

		 * Put the FIB onto the

		 * fibctx's fibs

		/*

		 * Set the event to wake up the

		 * thread that is waiting.

	/*

	 *	Set the status of this FIB

 Thor AIF */

		/*

		 *	We will process the FIB here or pass it to a

		 *	worker thread that is TBD. We Really can't

		 *	do anything at this point since we don't have

		 *	anything defined for this thread to do.

		/*

		 *	We only handle AifRequest fibs from the adapter.

 Handle Driver Notify Events */

		/*

		 * The u32 here is important and intended. We are using

		 * 32bit wrapping time to fit the adapter field

 Sniff events */

		/*

		 * get number of fibs to process

		/*

		 * Fill up fib pointer pools with actual fibs

		 * and hw_fibs

		/*

		 * wakeup the thread that is waiting for

		 * the response from fw (ioctl)

 Free up the remaining resources */

	/*

	 *	There are no more AIF's

	/*

	 * Do not set XferState to zero unless

	 * receives a response from F/W

	/*

	 * FIB should be freed only after

	 * getting the response from the F/W

 overflow in y2106 */

	/*

	 * Do not set XferState to zero unless

	 * receives a response from F/W

	/*

	 * FIB should be freed only after

	 * getting the response from the F/W

/**

 *	aac_command_thread	-	command processing thread

 *	@data: Adapter to monitor

 *

 *	Waits on the commandready event in it's queue. When the event gets set

 *	it will pull FIBs off it's queue. It will continue to pull FIBs off

 *	until the queue is empty. When the queue is empty it will wait for

 *	more FIBs.

	/*

	 *	We can only have one thread per adapter for AIF's.

	/*

	 *	Let the DPC know it has a place to send the AIF's to.

		/*

		 *	Background activity

 Don't even try to talk to adapter if its sick */

 Synchronize our watches */

		/*

		 * we probably want usleep_range() here instead of the

		 * jiffies computation

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *	Adaptec AAC series RAID controller driver

 *	(c) Copyright 2001 Red Hat Inc.

 *

 * based on the old aacraid driver that is..

 * Adaptec aacraid device driver for Linux.

 *

 * Copyright (c) 2000-2010 Adaptec, Inc.

 *               2010-2015 PMC-Sierra, Inc. (aacraid@pmc-sierra.com)

 *		 2016-2017 Microsemi Corp. (aacraid@microsemi.com)

 *

 * Module Name:

 *  rx.c

 *

 * Abstract: Hardware miniport for Drawbridge specific hardware functions.

	/*

	 *	Read mask and invert because drawbridge is reversed.

	 *	This allows us to only service interrupts that have

	 *	been enabled.

	 *	Check to see if this is our interrupt.  If it isn't just return

/**

 *	aac_rx_disable_interrupt	-	Disable interrupts

 *	@dev: Adapter

/**

 *	aac_rx_enable_interrupt_producer	-	Enable interrupts

 *	@dev: Adapter

/**

 *	aac_rx_enable_interrupt_message	-	Enable interrupts

 *	@dev: Adapter

/**

 *	rx_sync_cmd	-	send a command and wait

 *	@dev: Adapter

 *	@command: Command to execute

 *	@p1: first parameter

 *	@p2: second parameter

 *	@p3: third parameter

 *	@p4: forth parameter

 *	@p5: fifth parameter

 *	@p6: sixth parameter

 *	@status: adapter status

 *	@r1: first return value

 *	@r2: second return value

 *	@r3: third return value

 *	@r4: forth return value

 *

 *	This routine will send a synchronous command to the adapter and wait 

 *	for its	completion.

	/*

	 *	Write the command into Mailbox 0

	/*

	 *	Write the parameters into Mailboxes 1 - 6

	/*

	 *	Clear the synch command doorbell to start on a clean slate.

	/*

	 *	Disable doorbell interrupts

	/*

	 *	Force the completion of the mask register write before issuing

	 *	the interrupt.

	/*

	 *	Signal that there is a new synch command

	/*

	 *	Wait up to 30 seconds

 Delay 5 microseconds to let Mon960 get info. */

		/*

		 *	Mon960 will set doorbell0 bit when it has completed the command.

			/*

			 *	Clear the doorbell.

		/*

		 *	Yield the processor in case we are slow 

		/*

		 *	Restore interrupt mask even though we timed out

	/*

	 *	Pull the synch status from Mailbox 0.

	/*

	 *	Clear the synch command doorbell.

	/*

	 *	Restore interrupt mask

/**

 *	aac_rx_interrupt_adapter	-	interrupt adapter

 *	@dev: Adapter

 *

 *	Send an interrupt to the i960 and breakpoint it.

/**

 *	aac_rx_notify_adapter		-	send an event to the adapter

 *	@dev: Adapter

 *	@event: Event to send

 *

 *	Notify the i960 that something it probably cares about has

 *	happened.

/**

 *	aac_rx_start_adapter		-	activate adapter

 *	@dev:	Adapter

 *

 *	Start up processing on an i960 based AAC adapter

 We can only use a 32 bit address here

/**

 *	aac_rx_check_health

 *	@dev: device to check if healthy

 *

 *	Will attempt to determine if the specified adapter is alive and

 *	capable of handling requests, returning 0 if alive.

	/*

	 *	Check to see if the board failed any self tests.

	/*

	 *	Check to see if the board panic'd.

	/*

	 *	Wait for the adapter to be up and running.

	/*

	 *	Everything is OK

/**

 *	aac_rx_deliver_producer

 *	@fib: fib to issue

 *

 *	Will send a fib, returning 0 if successful.

/**

 *	aac_rx_deliver_message

 *	@fib: fib to issue

 *

 *	Will send a fib, returning 0 if successful.

 50 seconds */

/**

 *	aac_rx_ioremap

 *	@dev: adapter

 *	@size: mapping resize request

 *

 USE_OTHER_METHOD */

 Delay 5 seconds */

/**

 *	aac_rx_select_comm	-	Select communications method

 *	@dev: Adapter

 *	@comm: communications method

/**

 *	_aac_rx_init	-	initialize an i960 based AAC card

 *	@dev: device to configure

 *

 *	Allocate and set up resources for the i960 based AAC variants. The 

 *	device_interface in the commregion will be allocated and linked 

 *	to the comm region.

 Failure to reset here is an option ... */

 Make sure the Hardware FIFO is empty */

	/*

	 *	Check to see if the board panic'd while booting.

	/*

	 *	Check to see if the board failed any self tests.

	/*

	 *	Check to see if the monitor panic'd while booting.

	/*

	 *	Wait for the adapter to be up and running. Wait up to 3 minutes

	/*

	 *	Fill in the common function dispatch table.

	/*

	 *	First clear out all interrupts.  Then enable the one's that we

	 *	can handle.

 sync. mode not supported */

	/*

	 *	Tell the adapter that all is configured, and it can

	 * start accepting requests

	/*

	 *	Fill in the function dispatch table.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *	Adaptec AAC series RAID controller driver

 *	(c) Copyright 2001 Red Hat Inc.

 *

 * based on the old aacraid driver that is..

 * Adaptec aacraid device driver for Linux.

 *

 * Copyright (c) 2000-2010 Adaptec, Inc.

 *               2010-2015 PMC-Sierra, Inc. (aacraid@pmc-sierra.com)

 *		 2016-2017 Microsemi Corp. (aacraid@microsemi.com)

 *

 * Module Name:

 *  commctrl.c

 *

 * Abstract: Contains all routines for control of the AFA comm layer

 ssleep prototype */

/**

 *	ioctl_send_fib	-	send a FIB from userspace

 *	@dev:	adapter is being processed

 *	@arg:	arguments to the ioctl call

 *

 *	This routine sends a fib to the adapter on behalf of a user level

 *	program.

	/*

	 *	First copy in the header so that we can check the size field.

	/*

	 *	Since we copy based on the fib header size, make sure that we

	 *	will not overrun the buffer when we copy the memory. Return

	 *	an error if we would.

 Highjack the hw_fib */

 Sanity check the second copy */

		/*

		 * Since we didn't really send a fib, zero out the state to allow

		 * cleanup code not to assert.

	/*

	 *	Make sure that the size returned by the adapter (which includes

	 *	the header) is less than or equal to the size of a fib, so we

	 *	don't corrupt application data. Then copy that size to the user

	 *	buffer. (Don't try to add the header information again, since it

	 *	was already included by the adapter.)

/**

 *	open_getadapter_fib	-	Get the next fib

 *	@dev:	adapter is being processed

 *	@arg:	arguments to the open call

 *

 *	This routine will get the next Fib, if available, from the AdapterFibContext

 *	passed in from the user.

		/*

		 *	Yes yes, I know this could be an index, but we have a

		 * better guarantee of uniqueness for the locked loop below.

		 * Without the aid of a persistent history, this also helps

		 * reduce the chance that the opaque context would be reused.

		/*

		 *	Initialize the mutex used to wait for the next AIF.

		/*

		 *	Initialize the fibs and set the count of fibs on

		 *	the list to 0.

		/*

		 *	Now add this context onto the adapter's

		 *	AdapterFibContext list.

 Ensure that we have a unique identifier */

 Not unique (32 bits) */

/**

 *	next_getadapter_fib	-	get the next fib

 *	@dev: adapter to use

 *	@arg: ioctl argument

 *

 *	This routine will get the next Fib, if available, from the AdapterFibContext

 *	passed in from the user.

	/*

	 *	Verify that the HANDLE passed in was a valid AdapterFibContext

	 *

	 *	Search the list of AdapterFibContext addresses on the adapter

	 *	to be sure this is a valid address

		/*

		 *	Extract the AdapterFibContext from the Input parameters.

 We found a winner */

	/*

	 *	If there are no fibs to send back, then either wait or return

	 *	-EAGAIN

		/*

		 *	Pull the next fib from the fibs

		/*

		 *	Free the space occupied by this copy of the fib.

 If someone killed the AIF aacraid thread, restart it */

 Be paranoid, be very paranoid! */

 Lock again and retry */

	/*

	 *	First free any FIBs that have not been consumed.

		/*

		 *	Pull the next fib from the fibs

		/*

		 *	Free the space occupied by this copy of the fib.

	/*

	 *	Remove the Context from the AdapterFibContext List

	/*

	 *	Invalidate context

	/*

	 *	Free the space occupied by the Context

/**

 *	close_getadapter_fib	-	close down user fib context

 *	@dev: adapter

 *	@arg: ioctl arguments

 *

 *	This routine will close down the fibctx passed in from the user.

	/*

	 *	Verify that the HANDLE passed in was a valid AdapterFibContext

	 *

	 *	Search the list of AdapterFibContext addresses on the adapter

	 *	to be sure this is a valid address

		/*

		 *	Extract the fibctx from the input parameters

 We found a winner */

 Already gone */

/**

 *	check_revision	-	close down user fib context

 *	@dev: adapter

 *	@arg: ioctl arguments

 *

 *	This routine returns the driver version.

 *	Under Linux, there have been no version incompatibilities, so this is

 *	simple!

/**

 * aac_send_raw_srb()

 *	@dev:	adapter is being processed

 *	@arg:	arguments to the send call

	/*

	 *	Allocate and initialize a Fib then setup a SRB command

 cleanup may take issue */

 from user in cpu order */

 User made a mistake - should not continue */

 sizeof(*hbacmd) is not necessary */

 iu_type is a parameter of aac_hba_send */

		/*

		 * we fill in reply_qid later in aac_src_deliver_message

		 * we fill in iu_type, request_id later in aac_hba_send

		 * we fill in emb_data_desc_count, data_length later

		 * in sg list build

 raw_srb FIB is not FastResponseCapable */

 Fix up srb for endian and force some values

 Force this

 Obsolete parameter

 save so we can clean up later

 embedded sglist */

		/*

		 * This should also catch if user used the 32 bit sgmap

 save so we can clean up later

 save so we can clean up later

 save so we can clean up later

 save so we can clean up later

 fast response */

	/*

	 *	HBA gets first crack

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *	Adaptec AAC series RAID controller driver

 *	(c) Copyright 2001 Red Hat Inc.

 *

 * based on the old aacraid driver that is..

 * Adaptec aacraid device driver for Linux.

 *

 * Copyright (c) 2000-2010 Adaptec, Inc.

 *               2010-2015 PMC-Sierra, Inc. (aacraid@pmc-sierra.com)

 *		 2016-2017 Microsemi Corp. (aacraid@microsemi.com)

 *

 * Module Name:

 *  rkt.c

 *

 * Abstract: Hardware miniport for Drawbridge specific hardware functions.

/**

 *	aac_rkt_select_comm	-	Select communications method

 *	@dev: Adapter

 *	@comm: communications method

		/*

		 * FIB Setup has already been done, but we can minimize the

		 * damage by at least ensuring the OS never issues more

		 * commands than we can handle. The Rocket adapters currently

		 * can only handle 246 commands and 8 AIFs at the same time,

		 * and in fact do notify us accordingly if we negotiate the

		 * FIB size. The problem that causes us to add this check is

		 * to ensure that we do not overdo it with the adapter when a

		 * hard coded FIB override is being utilized. This special

		 * case warrants this half baked, but convenient, check here.

/**

 *	aac_rkt_ioremap

 *	@dev: device to ioremap

 *	@size: mapping resize request

 *

/**

 *	aac_rkt_init	-	initialize an i960 based AAC card

 *	@dev: device to configure

 *

 *	Allocate and set up resources for the i960 based AAC variants. The

 *	device_interface in the commregion will be allocated and linked

 *	to the comm region.

	/*

	 *	Fill in the function dispatch table.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *	Adaptec AAC series RAID controller driver

 *

 * based on the old aacraid driver that is..

 * Adaptec aacraid device driver for Linux.

 *

 * Copyright (c) 2000-2010 Adaptec, Inc.

 *               2010-2015 PMC-Sierra, Inc. (aacraid@pmc-sierra.com)

 *		 2016-2017 Microsemi Corp. (aacraid@microsemi.com)

 *

 * Module Name:

 *  nark.c

 *

 * Abstract: Hardware Device Interface for NEMER/ARK

/**

 *	aac_nark_ioremap

 *	@dev: device to ioremap

 *	@size: mapping resize request

 *

/**

 *	aac_nark_init	-	initialize an NEMER/ARK Split Bar card

 *	@dev: device to configure

 *

	/*

	 *	Fill in the function dispatch table.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *	Adaptec AAC series RAID controller driver

 *	(c) Copyright 2001 Red Hat Inc.

 *

 * based on the old aacraid driver that is..

 * Adaptec aacraid device driver for Linux.

 *

 * Copyright (c) 2000-2010 Adaptec, Inc.

 *               2010-2015 PMC-Sierra, Inc. (aacraid@pmc-sierra.com)

 *		 2016-2017 Microsemi Corp. (aacraid@microsemi.com)

 *

 * Module Name:

 *  src.c

 *

 * Abstract: Hardware Device Interface for PMC SRC based controllers

 handle AIF */

 remove toggle bit (31) */

 check fast response bits (30, 1) */

/**

 *	aac_src_disable_interrupt	-	Disable interrupts

 *	@dev: Adapter

/**

 *	aac_src_enable_interrupt_message	-	Enable interrupts

 *	@dev: Adapter

/**

 *	src_sync_cmd	-	send a command and wait

 *	@dev: Adapter

 *	@command: Command to execute

 *	@p1: first parameter

 *	@p2: second parameter

 *	@p3: third parameter

 *	@p4: forth parameter

 *	@p5: fifth parameter

 *	@p6: sixth parameter

 *	@status: adapter status

 *	@r1: first return value

 *	@r2: second return valu

 *	@r3: third return value

 *	@r4: forth return value

 *

 *	This routine will send a synchronous command to the adapter and wait

 *	for its	completion.

	/*

	 *	Write the command into Mailbox 0

	/*

	 *	Write the parameters into Mailboxes 1 - 6

	/*

	 *	Clear the synch command doorbell to start on a clean slate.

	/*

	 *	Disable doorbell interrupts

	/*

	 *	Force the completion of the mask register write before issuing

	 *	the interrupt.

	/*

	 *	Signal that there is a new synch command

 Wait up to 10 sec */

 Wait up to 5 minutes */

 Delay 5 microseconds to let Mon960 get info. */

			/*

			 *	Mon960 will set doorbell0 bit when it has completed the command.

				/*

				 *	Clear the doorbell.

			/*

			 *	Yield the processor in case we are slow

			/*

			 *	Restore interrupt mask even though we timed out

		/*

		 *	Pull the synch status from Mailbox 0.

		/*

		 *	Clear the synch command doorbell.

	/*

	 *	Restore interrupt mask

/**

 *	aac_src_interrupt_adapter	-	interrupt adapter

 *	@dev: Adapter

 *

 *	Send an interrupt to the i960 and breakpoint it.

/**

 *	aac_src_notify_adapter		-	send an event to the adapter

 *	@dev: Adapter

 *	@event: Event to send

 *

 *	Notify the i960 that something it probably cares about has

 *	happened.

/**

 *	aac_src_start_adapter		-	activate adapter

 *	@dev:	Adapter

 *

 *	Start up processing on an i960 based AAC adapter

 reset host_rrq_idx first */

 We can only use a 32 bit address here

/**

 *	aac_src_check_health

 *	@dev: device to check if healthy

 *

 *	Will attempt to determine if the specified adapter is alive and

 *	capable of handling requests, returning 0 if alive.

	/*

	 *	Check to see if the board panic'd.

	/*

	 *	Check to see if the board failed any self tests.

	/*

	 *	Check to see if the board failed any self tests.

	/*

	 *	Wait for the adapter to be up and running.

	/*

	 *	Everything is OK

/**

 *	aac_src_deliver_message

 *	@fib: fib to issue

 *

 *	Will send a fib, returning 0 if successful.

 Calculate the amount to the fibsize bits */

 New FIB header, 32-bit */

 Calculate the amount to the fibsize bits */

 Fill XPORT header */

/**

 *	aac_src_ioremap

 *	@dev: device ioremap

 *	@size: mapping resize request

 *

/**

 *  aac_srcv_ioremap

 *	@dev: device ioremap

 *	@size: mapping resize request

 *

 Delay 5 seconds */

	/*

	 * Check for PCI Errors or Kernel Panic

	/*

	 * Preserve MSIX Value if any

	/*

	 * When there is a BlinkLED, IOP_RESET has not effect

		/*

		 * Creates a delay or wait till up and running comes thru

/**

 *	aac_src_select_comm	-	Select communications method

 *	@dev: Adapter

 *	@comm: communications method

/**

 *  aac_src_init	-	initialize an Cardinal Frey Bar card

 *  @dev: device to configure

 *

 Failure to reset here is an option ... */

	/*

	 *	Check to see if the board panic'd while booting.

	/*

	 *	Check to see if the board failed any self tests.

	/*

	 *	Check to see if the monitor panic'd while booting.

	/*

	 *	Wait for the adapter to be up and running. Wait up to 3 minutes

	/*

	 *	Fill in the common function dispatch table.

	/*

	 *	First clear out all interrupts.  Then enable the one's that we

	 *	can handle.

		/*

		 * Tell the adapter that all is configured, and it can

		 * start accepting requests

		/*

		 * Delay 5 microseconds to let Mon960 get info.

		/*

		 * Mon960 will set doorbell0 bit when it has completed the

		 * command.

			/*

			 * Clear: the doorbell.

		/*

		 * Yield the processor in case we are slow

	/*

	 * Pull the synch status from Mailbox 0.

/**

 *  aac_src_soft_reset	-	perform soft reset to speed up

 *  access

 *

 *  Assumptions: That the controller is in a state where we can

 *  bring it back to life with an init struct. We can only use

 *  fast sync commands, as the timeout is 5 seconds.

 *

 *  @dev: device to configure

 *

 pcie hosed

 not up and running

	/*

	 * We go into soft reset mode to allow us to handle response

 Get adapter properties */

/**

 *  aac_srcv_init	-	initialize an SRCv card

 *  @dev: device to configure

 *

 Failure to reset here is an option ... */

	/*

	 *	Check to see if flash update is running.

	 *	Wait for the adapter to be up and running. Wait up to 5 minutes

		/* Delay 10 seconds.

		 * Because right now FW is doing a soft reset,

		 * do not read scratch pad register at this time

	/*

	 *	Check to see if the board panic'd while booting.

	/*

	 *	Check to see if the board failed any self tests.

	/*

	 *	Check to see if the monitor panic'd while booting.

	/*

	 *	Wait for the adapter to be up and running. Wait up to 3 minutes

	/*

	 *	Fill in the common function dispatch table.

	/*

	 *	First clear out all interrupts.  Then enable the one's that we

	 *	can handle.

		/*

		 * Tell the adapter that all is configured, and it can

		 * start accepting requests

 set bit 6 */

 unmask int. */

 reset bit 6 */

 set bit 5 */

 set bit 4 */

 set bit 7 */

 unmask int. */

		/*

		 * if Legacy int status indicates cmd is not complete

		 * sample MSIx register to see if it indiactes cmd complete,

		 * if yes set the controller in MSIx mode and consider cmd

		 * completed

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *	Adaptec AAC series RAID controller driver

 *	(c) Copyright 2001 Red Hat Inc.

 *

 * based on the old aacraid driver that is..

 * Adaptec aacraid device driver for Linux.

 *

 * Copyright (c) 2000-2010 Adaptec, Inc.

 *               2010-2015 PMC-Sierra, Inc. (aacraid@pmc-sierra.com)

 *		 2016-2017 Microsemi Corp. (aacraid@microsemi.com)

 *

 * Module Name:

 *  dpcsup.c

 *

 * Abstract: All DPC processing routines for the cyclone board occur here.

/**

 *	aac_response_normal	-	Handle command replies

 *	@q: Queue to read from

 *

 *	This DPC routine will be run when the adapter interrupts us to let us

 *	know there is a response on our normal priority queue. We will pull off

 *	all QE there are and wake up all the waiters before exiting. We will

 *	take a spinlock out on the queue before operating on it.

	/*

	 *	Keep pulling response QEs off the response queue and waking

	 *	up the waiters until there are no more QEs. We then return

	 *	back to the system. If no response was requested we just

	 *	deallocate the Fib here and continue.

		/*

		 *	Remove this fib from the Outstanding I/O queue.

		 *	But only if it has not already been timed out.

		 *

		 *	If the fib has been timed out already, then just 

		 *	continue. The caller has already been notified that

		 *	the fib timed out.

			/*

			 *	Doctor the fib

			/*

			 *	NOTE:  we cannot touch the fib after this

			 *	    call, because it may have been deallocated.

/**

 *	aac_command_normal	-	handle commands

 *	@q: queue to process

 *

 *	This DPC routine will be queued when the adapter interrupts us to 

 *	let us know there is a command on our normal priority queue. We will 

 *	pull off all QE there are and wake up all the waiters before exiting.

 *	We will take a spinlock out on the queue before operating on it.

	/*

	 *	Keep pulling response QEs off the response queue and waking

	 *	up the waiters until there are no more QEs. We then return

	 *	back to the system.

		/*

		 *	Allocate a FIB at all costs. For non queued stuff

		 *	we can just use the stack so we are happy. We need

		 *	a fib object in order to manage the linked lists

			/*

			 *	Set the status of this FIB

/*

 *

 * aac_aif_callback

 * @context: the context set in the fib - here it is scsi cmd

 * @fibptr: pointer to the fib

 *

 * Handles the AIFs - new method (SRC)

 *

/*

 *	aac_intr_normal	-	Handle command replies

 *	@dev: Device

 *	@index: completion reference

 *

 *	This DPC routine will be run when the adapter interrupts us to let us

 *	know there is a response on our normal priority queue. We will pull off

 *	all QE there are and wake up all the waiters before exiting.

 AIF - common */

		/*

		 *	Allocate a FIB. For non queued stuff we can just use

		 * the stack so we are happy. We need a fib object in order to

		 * manage the linked lists.

 store event type */

 AIF - new (SRC) */

		/*

		 *	Remove this fib from the Outstanding I/O queue.

		 *	But only if it has not already been timed out.

		 *

		 *	If the fib has been timed out already, then just 

		 *	continue. The caller has already been notified that

		 *	the fib timed out.

 Doctor the fib */

			/*

			 * NOTE:  we cannot touch the fib after this

			 *  call, because it may have been deallocated.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *	Adaptec AAC series RAID controller driver

 *	(c) Copyright 2001 Red Hat Inc.

 *

 * based on the old aacraid driver that is..

 * Adaptec aacraid device driver for Linux.

 *

 * Copyright (c) 2000-2010 Adaptec, Inc.

 *               2010-2015 PMC-Sierra, Inc. (aacraid@pmc-sierra.com)

 *		 2016-2017 Microsemi Corp. (aacraid@microsemi.com)

 *

 * Module Name:

 *  aachba.c

 *

 * Abstract: Contains Interfaces to manage IOs.

 values for inqd_pdt: Peripheral device type in plain English */

 Direct-access (DISK) device */

 Processor device */

 Changer (jukebox, scsi2) */

 Communication device (scsi2) */

 Unknown Device (scsi2) */

 Logical Unit Not Present */

 Peripheral Device Type Mask */

 Peripheral Device Qualifer Mask */

/*

 *	Sense codes

/*

 *	Additional sense codes

 MODE_SENSE data format */

 MODE_SENSE_10 data format */

/*------------------------------------------------------------------------------

 *              S T R U C T S / T Y P E D E F S

 SCSI inquiry data */

 Peripheral qualifier | Peripheral Device Type */

 RMB | Device Type Qualifier */

 ISO version | ECMA version | ANSI-approved version */

 AENC | TrmIOP | Response data format */

 Additional length (n-4) */

 Reserved - must be zero */

 RelAdr | WBus32 | WBus16 |  Sync  | Linked |Reserved| CmdQue | SftRe */

 Vendor ID */

 Product ID */

 Product Revision Level */

 Added for VPD 0x83 */

 VPD_CODE_SET */

 VPD_IDENTIFIER_TYPE */

 SN in ASCII */

 VPD_CODE_SET */

 VPD_IDENTIFIER_TYPE */

		 /* The serial number supposed to be 40 bits,

 VPD_CODE_SET */

 VPD_IDENTIFIER_TYPE */

/*

 *              M O D U L E   G L O B A L S

/*

 *	Non dasd selection is handled entirely in aachba now

 WCE=0 to avoid performance problems */

 Only Sync. transfer - disabled */

 convert non-conformable s/g list - enabled */

/**

 *	aac_get_config_status	-	check the adapter configuration

 *	@dev: aac driver data

 *	@commit_flag: force sending CT_COMMIT_CONFIG

 *

 *	Query config status, and commit the configuration if needed.

 Do not set XferState to zero unless receives a response from F/W */

 Send a CT_COMMIT_CONFIG to enable discovery of devices */

			/* Do not set XferState to zero unless

 FIB should be freed only after getting the response from the F/W */

/**

 *	aac_get_containers	-	list containers

 *	@dev: aac driver data

 *

 *	Make a list of all containers on this controller

 FIB should be freed only after getting the response from the F/W */

 SCSI command has been submitted by the SCSI mid-layer. */

 SCSI command has been submitted by aac_probe_container(). */

 Failure is irrelevant, using default value instead */

/*

 *	aac_get_container_name	-	get container name, none blocking.

	/*

	 *	Check that the command queued to the controller

 sense_key holds the current state of the spin-up */

	/*

	 *	Check that the command queued to the controller

 Inherit results from VM_NameServe, if any */

		/*

		 *	Check that the command queued to the controller

/**

 *	aac_probe_container_callback1	-	query a logical volume

 *	@scsicmd: the scsi command block

 *

 *	Queries the controller about the given volume. The volume information

 *	is updated in the struct fsa_dev_info structure rather than returned.

 Local Structure to set SCSI inquiry data strings */

 Vendor ID */

 Product ID */

 Product Revision Level */

/**

 *	inqstrcpy	-	string merge

 *	@a:	string to copy from

 *	@b:	string to copy to

 *

 *	Copy a String from one location to another

 *	without copying \0

/* Function: setinqstr

 *

 * Arguments: [1] pointer to void [1] int

 *

 * Purpose: Sets SCSI inquiry data strings for vendor, product

 * and revision level. Allows strings to be set in platform dependent

 * files instead of in OS dependent driver source.

 cast data to scsi inq block */

 last six chars reserved for vol type */

 last six chars reserved for vol type */

 walk till we find a space */

 RAID is superfluous in the context of a RAID device */

 Failure is irrelevant, using default value instead */

Check to see if it's for VPD 0x83 or 0x80 */

 vpd page 0x83 - Device Identification Page */

 DIRECT_ACCESS_DEVIC */

 DEVICE_CONNECTED */

 VPD_DEVICE_IDENTIFIERS */

 VPD 83 Type 3 is not supported for ARC */

 T10 Vendor Identifier Field Format */

 VpdcodesetAscii */

 VpdIdentifierTypeVendorId */

 "ADAPTEC " for adaptec */

			/* Convert to ascii based serial number.

			 * The LSB is the the end.

 VpdCodeSetBinary */

 VpdidentifiertypeEUI64 */

			/*

			 * VpdIdentifierTypeFCPHName

			 * VPD 0x83 Type 3 not supported for ARC

 Move the inquiry data to the response buffer. */

 It must be for VPD 0x80 */

 EVPD bit set */

/*

 *	aac_get_container_serial - get container serial, none blocking.

	/*

	 *	Check that the command queued to the controller

/* Function: setinqserial

 *

 * Arguments: [1] pointer to void [1] int

 *

 * Purpose: Sets SCSI Unit Serial number.

 *          This is a fake. We should read a proper

 *          serial number from the container. <SuSE>But

 *          without docs it's quite hard to do it :-)

 *          So this will have to do in the meantime.</SuSE>

	/*

	 *	This breaks array migration.

 Sense data valid, err code 70h */

 No info field */

 Segment number, always zero */

 Sense key */

 Additional sense code */

 Additional sense code qualifier */

 Additional sense length */

 Illegal parameter is in the parameter block */

 Std sense key specific field */

 Illegal parameter is in the CDB block */

 MSB */

 LSB */

 Additional sense length */

	/*

	 *	Now send the Fib to the adapter

	/*

	 *	Now send the Fib to the adapter

	/*

	 *	Now send the Fib to the adapter

	/*

	 *	Now send the Fib to the adapter

	/*

	 *	Now send the Fib to the adapter

 ->stable is not used - it did mean which type of write */

	/*

	 *	Now send the Fib to the adapter

 shuts up some versions of gcc */

 timeout in seconds

 Obsolete parameter */

 sizeof(*hbacmd) is not necessary */

 iu_type is a parameter of aac_hba_send */

 we fill in reply_qid later in aac_src_deliver_message */

 we fill in iu_type, request_id later in aac_hba_send */

 we fill in emb_data_desc_count later in aac_build_sghba */

	/*

	 *	Build Scatter/Gather list

	/*

	 *	Now send the Fib to the adapter

	/*

	 *	Build Scatter/Gather list

	/*

	 *	Now send the Fib to the adapter

	/*

	 *	Now send the HBA command to the adapter

 allocate FIB */

 allocate DMA buffer for response */

 set the common request fields */

	/*

	 * Copy the updated data for other dumping or other usage if needed

 issue request to the controller */

/**

 *	aac_get_safw_ciss_luns() - Process topology change

 *	@dev:		aac_dev structure

 *

 *	Execute a CISS REPORT PHYS LUNS and process the results into

 *	the current hba_map.

 extended reporting */

/**

 *	aac_set_safw_attr_all_targets-	update current hba map with data from FW

 *	@dev:	aac_dev structure

 *

 *	Update our hba map with the information gathered from the FW

 ok and extended reporting */

 First `interrupt' command uses special wait */

		/* FIB should be freed only after

 reset all previous mapped devices (i.e. for init. after IOP_RESET) */

	/*

	 * GetBusInfo

 reasoned default */

	/*

	 * If the firmware supports ROMB RAID/SCSI mode and we are currently

	 * in RAID/SCSI mode, set the flag. For now if in this mode we will

	 * force nondasd support on. If we decide to allow the non-dasd flag

	 * additional changes changes will have to be made to support

	 * RAID/SCSI.  the function aac_scsi_cmd in this module will have to be

	 * changed to support the new dev->raid_scsi_mode flag instead of

	 * leaching off of the dev->nondasd_support flag. Also in linit.c the

	 * function aac_detect will have to be modified where it sets up the

	 * max number of channels based on the aac->nondasd_support flag only.

 avoid problems with AAC_QUIRK_SCSI_32 controllers */

	/*

	 * Deal with configuring for the individualized limits of each packet

	 * interface.

			/*

			 * 38 scatter gather elements

			/*

			 * Worst case size that could cause sg overflow when

			 * we break up SG elements that are larger than 64KB.

			 * Would be nice if we could tell the SCSI layer what

			 * the maximum SG element size can be. Worst case is

			 * (sg_tablesize-1) 4KB elements with one 64KB

			 * element.

			 *	32bit -> 468 or 238KB	64bit -> 424 or 212KB

 FIB should be freed only after getting the response from the F/W */

	/*

	 *	Get block address and transfer length

	/*

	 *	Alocate and initialize a Fib

	/*

	 *	Check that the command queued to the controller

	/*

	 *	For some reason, the Fib didn't queue, return QUEUE_FULL

	/*

	 *	Get block address and transfer length

 6 byte command */

 16 byte command */

 12 byte command */

	/*

	 *	Allocate and initialize a Fib then setup a BlockWrite command

	/*

	 *	Check that the command queued to the controller

	/*

	 *	For some reason, the Fib didn't queue, return QUEUE_FULL

	/*

	 *	Allocate and initialize a Fib

	/*

	 *	Now send the Fib to the adapter

	/*

	 *	Check that the command queued to the controller

	/*

	 *	Allocate and initialize a Fib

 Eject bit ignored, not relevant */

	/*

	 *	Now send the Fib to the adapter

	/*

	 *	Check that the command queued to the controller

/**

 *	aac_scsi_cmd()		-	Process SCSI command

 *	@scsicmd:		SCSI command block

 *

 *	Emulate a SCSI command and queue the required request for the

 *	aacraid firmware.

	/*

	 *	If the bus, id or lun is out of range, return fail

	 *	Test does not apply to ID 16, the pseudo id for the controller

	 *	itself.

			/*

			 *	If the target container doesn't exist, it may have

			 *	been newly created

 check for physical non-dasd devices */

	/*

	 * else Command for the controller itself

 only INQUIRY & TUR cmnd supported for controller */

 Issue FIB to tell Firmware to flush it's cache */

 EVPD bit set */

 supported vital product data pages */

 unit serial number page */

 vpd page 0x83 - Device Identification Page */

 vpd page not implemented */

 claim compliance to SCSI-2 */

 A response data format value of two indicates that the data shall be in the format specified in SCSI-2 */

Format for "pad2" is  RelAdr | WBus32 | WBus16 |  Sync  | Linked |Reserved| CmdQue | SftRe */

WBus16|Sync|CmdQue */

		/*

		 *	Set the Vendor, Product, and Revision Level

		 *	see: <vendor>.c i.e. aac.c

 Processor device */

 Direct/random access device */

 Do not cache partition table for arrays */

 Do not cache partition table for arrays */

 Mode data length */

 Medium type - default */

		/* Device-specific param,

		   bit 8: 0/1 = write enabled/protected

 Block descriptor length */

 page length */

 Mode data length */

 Mode data length */

 WCE */

 Mode data length (MSB) */

 Mode data length (LSB) */

 Medium type - default */

		/* Device-specific param,

		   bit 8: 0/1 = write enabled/protected

 reserved */

 reserved */

 Block descriptor length (MSB) */

 Block descriptor length (LSB) */

 WCE */

	/*

	 *	These commands are all No-Ops

	/*

	 *	Unhandled commands

	/*

	 *	Mark this container as being deleted.

	/*

	 *	Mark the container as no longer valid

	/*

	 *	If the container is locked, it can not be deleted by the API.

		/*

		 *	Mark the container as no longer being valid.

/**

 * aac_srb_callback

 * @context: the context set in the fib - here it is scsi cmd

 * @fibptr: pointer to the fib

 *

 * Handles the completion of a scsi command to a non dasd device

 Initialize sense valid flag to false */

 fast response */

		/*

		 *	Calculate resid for sg

 expose physical device if expose_physicald flag is on */

	/*

	 * First check the fib status

	/*

	 * Next check the srb status

		/*

		 * Not sure about this one - but assuming the

		 * hba was trying to abort for some reason

		/*

		 * When the CC bit is SET by the host in ATA pass thru CDB,

		 *  driver is supposed to return DID_OK

		 *

		 * When the CC bit is RESET by the host, driver should

		 *  return DID_ERROR

	/*

	 * OR in the scsi status (already shifted up a bit)

 set residual count */

 UNDERRUN is OK */

/**

 * aac_hba_callback

 * @context: the context set in the fib - here it is scsi cmd

 * @fibptr: pointer to the fib

 *

 * Handles the completion of a native HBA scsi command

 fast response */

/**

 * aac_send_srb_fib

 * @scsicmd: the scsi command block

 *

 * This routine will form a FIB and fill in the aac_srb from the

 * scsicmd passed in.

	/*

	 *	Allocate and initialize a Fib then setup a BlockWrite command

	/*

	 *	Check that the command queued to the controller

/**

 * aac_send_hba_fib

 * @scsicmd: the scsi command block

 *

 * This routine will form a FIB and fill in the aac_hba_cmd_req from the

 * scsicmd passed in.

	/*

	 *	Allocate and initialize a Fib then setup a BlockWrite command

	/*

	 *	Check that the command queued to the controller

 Get rid of old data

 hba wants the size to be exact */

 Check for command underflow */

 Get rid of old data

 hba wants the size to be exact */

 Check for command underflow */

 Get rid of old data

 hba wants the size to be exact */

 Check for command underflow */

 hba wants the size to be exact */

 not conformable: evaluate required sg elements */

 Check for command underflow */

 hba wants the size to be exact */

 not embedded */

 Check for command underflow */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family 

 * of PCI-SCSI IO processors.

 *

 * Copyright (C) 1999-2001  Gerard Roudier <groudier@free.fr>

 *

 * This driver is derived from the Linux sym53c8xx driver.

 * Copyright (C) 1998-2000  Gerard Roudier

 *

 * The sym53c8xx driver is derived from the ncr53c8xx driver that had been 

 * a port of the FreeBSD ncr driver to Linux-1.2.13.

 *

 * The original ncr driver has been written for 386bsd and FreeBSD by

 *         Wolfgang Stanglmeier        <wolf@cologne.de>

 *         Stefan Esser                <se@mi.Uni-Koeln.de>

 * Copyright (C) 1994  Wolfgang Stanglmeier

 *

 * Other major contributions:

 *

 * NVRAM detection and reading.

 * Copyright (C) 1997 Richard Waltham <dormouse@farsrobt.demon.co.uk>

 *

 *-----------------------------------------------------------------------------

/*

 *  Simple power of two buddy-like generic allocator.

 *  Provides naturally aligned memory chunks.

 *

 *  This simple code is not intended to be fast, but to 

 *  provide power of 2 aligned memory allocations.

 *  Since the SCRIPTS processor only supplies 8 bit arithmetic, 

 *  this allocator allows simple and fast address calculations  

 *  from the SCRIPTS code. In addition, cache line alignment 

 *  is guaranteed for power of 2 cache line size.

 *

 *  This allocator has been developed for the Linux sym53c8xx  

 *  driver, since this O/S does not provide naturally aligned 

 *  allocations.

 *  It has the advantage of allowing the driver to use private 

 *  pages of memory that will be useful if we ever need to deal 

 *  with IO MMUs for PCI.

/*

 *  Counter-part of the generic allocator.

/*

 *  Verbose and zeroing allocator that wrapps to the generic allocator.

/*

 *  Its counter-part.

/*

 *  Default memory pool we donnot need to involve in DMA.

 *

 *  With DMA abstraction, we use functions (methods), to 

 *  distinguish between non DMAable memory and DMAable memory.

/*

 *  Methods that maintains DMAable pools according to user allocations.

 *  New pools are created on the fly when a new pool id is provided.

 *  They are deleted on the fly when they get emptied.

 Get a memory cluster that matches the DMA constraints of a given pool */

 Free a memory cluster and associated resources for DMA */

 Fetch the memory pool for a given pool id (i.e. DMA constraints) */

 Create a new memory DMAable pool (when fetch failed) */

 Destroy a DMAable memory pool (when got emptied) */

 This lock protects only the memory allocation/free.  */

/*

 *  Actual allocator for DMAable memory.

/*

 *  Actual virtual to bus physical address translator 

 *  for 32 bit addressable DMAable memory.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family 

 * of PCI-SCSI IO processors.

 *

 * Copyright (C) 1999-2001  Gerard Roudier <groudier@free.fr>

 * Copyright (c) 2003-2005  Matthew Wilcox <matthew@wil.cx>

 *

 * This driver is derived from the Linux sym53c8xx driver.

 * Copyright (C) 1998-2000  Gerard Roudier

 *

 * The sym53c8xx driver is derived from the ncr53c8xx driver that had been 

 * a port of the FreeBSD ncr driver to Linux-1.2.13.

 *

 * The original ncr driver has been written for 386bsd and FreeBSD by

 *         Wolfgang Stanglmeier        <wolf@cologne.de>

 *         Stefan Esser                <se@mi.Uni-Koeln.de>

 * Copyright (C) 1994  Wolfgang Stanglmeier

 *

 * Other major contributions:

 *

 * NVRAM detection and reading.

 * Copyright (C) 1997 Richard Waltham <dormouse@farsrobt.demon.co.uk>

 *

 *-----------------------------------------------------------------------------

 for timeouts in units of HZ */

/*

 *  Needed function prototypes.

/*

 *  Print a buffer in hexadecimal format with a ".\n" at end.

/*

 *  Print something that tells about extended errors.

/*

 *  Return a string for SCSI BUS mode.

/*

 *  Soft reset the chip.

 *

 *  Raising SRST when the chip is running may cause 

 *  problems on dual function chips (see below).

 *  On the other hand, LVD devices need some delay 

 *  to settle and report actual BUS mode in STEST4.

 For BUS MODE to settle */

/*

 *  Really soft reset the chip.:)

 *

 *  Some 896 and 876 chip revisions may hang-up if we set 

 *  the SRST (soft reset) bit at the wrong time when SCRIPTS 

 *  are running.

 *  So, we need to abort the current operation prior to 

 *  soft resetting the chip.

/*

 *  Start reset process.

 *

 *  The interrupt handler will reinitialize the chip.

 Soft reset the chip */

	/*

	 *  Enable Tolerant, reset IRQD if present and 

	 *  properly set IRQ mode, prior to resetting the bus.

	/*

	 *  Check for no terminators or SCSI bus shorts to ground.

	 *  Read SCSI data bus, data parity bits and control signals.

	 *  We are expecting RESET to be TRUE and other signals to be 

	 *  FALSE.

 rst sdp0 */

 sdp1     */

 d7-0     */

 d15-8    */

 req ack bsy sel atn msg cd io    */

/*

 *  Select SCSI clock frequency

	/*

	 *  If multiplier not present or not selected, leave here.

 Enable clock multiplier */

	/*

	 *  Wait for the LCKFRQ bit to be set if supported by the chip.

	 *  Otherwise wait 50 micro-seconds (at least).

 Halt the scsi clock	*/

 Select clock multiplier	*/

 Restart scsi clock 	*/

/*

 *  Determine the chip's clock frequency.

 *

 *  This is essential for the negotiation of the synchronous 

 *  transfer rate.

 *

 *  Note: we have to return the correct value.

 *  THERE IS NO SAFE DEFAULT VALUE.

 *

 *  Most NCR/SYMBIOS boards are delivered with a 40 Mhz clock.

 *  53C860 and 53C875 rev. 1 support fast20 transfers but 

 *  do not have a clock doubler and so are provided with a 

 *  80 MHz clock. All other fast20 boards incorporate a doubler 

 *  and so should be delivered with a 40 MHz clock.

 *  The recent fast40 chips (895/896/895A/1010) use a 40 Mhz base 

 *  clock and provide a clock quadrupler (160 Mhz).

/*

 *  calculate SCSI clock frequency (in KHz)

	/*

	 * Measure GEN timer delay in order 

	 * to calculate SCSI clock frequency

	 *

	 * This code will never execute too

	 * many loop iterations (if DELAY is 

	 * reasonably correct). It could get

	 * too low a delay (too high a freq.)

	 * if the CPU is slow executing the 

	 * loop for some reason (an NMI, for

	 * example). For this reason we will

	 * if multiple measurements are to be 

	 * performed trust the higher delay 

	 * (lower frequency returned).

 mask all scsi interrupts */

 clear pending scsi interrupt */

 mask all dma interrupts */

 another one, just to be sure :) */

	/*

	 * The C1010-33 core does not report GEN in SIST,

	 * if this interrupt is masked in SIEN.

	 * I don't know yet if the C1010-66 behaves the same way.

 set pre-scaler to divide by 3 */

 disable general purpose timer */

 set to nominal delay of 1<<gen * 125us */

 count in 1/4 of ms */

 disable general purpose timer */

	/*

	 * Undo C1010-33 specific settings.

 	/*

 	 * set prescaler to divide by whatever 0 means

 	 * 0 ought to choose divide by 2, but appears

 	 * to set divide by 3.5 mode in my 53c810 ...

  	/*

 	 * adjust for prescaler, and convert into KHz 

	/*

	 * The C1010-33 result is biased by a factor 

	 * of 2/3 compared to earlier chips.

 throw away first result */

 trust lower result	*/

/*

 *  Get/probe chip SCSI clock frequency

	/*

	 *  True with 875/895/896/895A with clock multiplier selected

	/*

	 *  If multiplier not found or scntl3 not 7,5,3,

	 *  reset chip and get frequency from general purpose timer.

	 *  Otherwise trust scntl3 BIOS setting.

 make sure doubler is OFF */

	/*

	 *  Compute controller synchronous parameters.

/*

 *  Get/probe PCI clock frequency

	/*

	 *  For now, we only need to know about the actual 

	 *  PCI BUS clock frequency for C1010-66 chips.

 Use the PCI clock as SCSI clock */

/*

 *  SYMBIOS chip clock divisor table.

 *

 *  Divisors are multiplied by 10,000,000 in order to make 

 *  calculations more simple.

/*

 *  Get clock factor and sync divisor for a given 

 *  synchronous factor period.

 SCSI clock frequency in kHz	*/

 Number of divisors supported	*/

 Sync factor in sxfer		*/

 Period in tenths of ns	*/

 (per * clk)			*/

	/*

	 *  Compute the synchronous period in tenths of nano-seconds

	/*

	 *  For earliest C10 revision 0, we cannot use extra 

	 *  clocks for the setting of the SCSI clocking.

	 *  Note that this limits the lowest sync data transfer 

	 *  to 5 Mega-transfers per second and may result in

	 *  using higher clock divisors.

		/*

		 *  Look for the lowest clock divisor that allows an 

		 *  output speed not faster than the period.

 No extra clocks */

 Are we too fast ? */

	/*

	 *  Look for the greatest clock divisor that allows an 

	 *  input speed faster than the period.

	/*

	 *  Calculate the lowest clock factor that allows an output 

	 *  speed not faster than the period, and the max output speed.

	 *  If fak >= 1 we will set both XCLKH_ST and XCLKH_DT.

	 *  If fak >= 2 we will also set XCLKS_ST and XCLKS_DT.

 ret = ((2+fak)*div_10M[div])/np->clock_khz; */

 ret = ((4+fak)*div_10M[div])/np->clock_khz; */

	/*

	 *  Check against our hardware limits, or bugs :).

	/*

	 *  Compute and return sync parameters.

/*

 *  SYMBIOS chips allow burst lengths of 2, 4, 8, 16, 32, 64,

 *  128 transfers. All chips support at least 16 transfers 

 *  bursts. The 825A, 875 and 895 chips support bursts of up 

 *  to 128 transfers and the 895A and 896 support bursts of up

 *  to 64 transfers. All other chips support up to 16 

 *  transfers bursts.

 *

 *  For PCI 32 bit data transfers each transfer is a DWORD.

 *  It is a QUADWORD (8 bytes) for PCI 64 bit data transfers.

 *

 *  We use log base 2 (burst length) as internal code, with 

 *  value 0 meaning "burst disabled".

/*

 *  Burst length from burst code.

/*

 *  Burst code from io register bits.

/*

 *  Set initial io register bits from burst code.

/*

 *  Save initial settings of some IO registers.

 *  Assumed to have been set by BIOS.

 *  We cannot reset the chip prior to reading the 

 *  IO registers, since informations will be lost.

 *  Since the SCRIPTS processor may be running, this 

 *  is not safe on paper, but it seems to work quite 

 *  well. :)

 Always large DMA fifo + ultra3 */

/*

 *  Set SCSI BUS mode.

 *  - LVD capable chips (895/895A/896/1010) report the current BUS mode

 *    through the STEST4 IO register.

 *  - For previous generation chips (825/825A/875), the user has to tell us

 *    how to check against HVD, since a 100% safe algorithm is not possible.

/*

 *  Prepare io register values used by sym_start_up() 

 *  according to selected and supported features.

	/*

	 *  Guess the frequency of the chip's clock.

	/*

	 *  Get the clock multiplier factor.

	/*

	 *  Measure SCSI clock frequency for chips 

	 *  it may vary from assumed one.

	/*

	 * Divisor to be used for async (timer pre-scaler).

	/*

	 * The C1010 uses hardwired divisors for async.

	 * So, we just throw away, the async. divisor.:-)

	/*

	 * Minimum synchronous period factor supported by the chip.

	 * Btw, 'period' is in tenths of nanoseconds.

	/*

	 * Check against chip SCSI standard support (SCSI-2,ULTRA,ULTRA2).

	/*

	 * Maximum synchronous period factor supported by the chip.

	/*

	 * If chip is a C1010, guess the sync limits in DT mode.

	/*

	 *  64 bit addressing  (895A/896/1010) ?

	/*

	 *  Phase mismatch handled by SCRIPTS (895A/896/1010) ?

 	/*

	 *  C1010-33 Errata: Part Number:609-039638 (rev. 1) is fixed.

	 *  In dual channel mode, contention occurs if internal cycles

	 *  are used. Disable internal cycles.

	/*

	 *  Select burst length (dwords)

	/*

	 *  DEL 352 - 53C810 Rev x11 - Part Number 609-0392140 - ITEM 2.

	 *  This chip and the 860 Rev 1 may wrongly use PCI cache line 

	 *  based transactions on LOAD/STORE instructions. So we have 

	 *  to prevent these chips from using such PCI transactions in 

	 *  this driver. The generic ncr driver that does not use 

	 *  LOAD/STORE instructions does not need this work-around.

	/*

	 *  Select all supported special features.

	 *  If we are using on-board RAM for scripts, prefetch (PFEN) 

	 *  does not help, but burst op fetch (BOF) does.

	 *  Disabling PFEN makes sure BOF will be used.

 Enable Read Line */

 Burst Opcode Fetch */

 Enable Read Multiple */

 Prefetch Enable */

 Cache Line Size Enable */

 Write and Invalidate */

 Dma Fifo Size */

	/*

	 *  Select some other

 Master parity checking */

  full arb., ena parity, par->ATN  */

	/*

	 *  Get parity checking, host ID and verbose mode from NVRAM

	/*

	 *  Get SCSI addr of host adapter (set by bios?).

	/*

	 *  Prepare initial io register bits for burst length

	/*

	 *  Set LED support from SCRIPTS.

	 *  Ignore this feature for boards known to use a 

	 *  specific GPIO wiring and for the 895A, 896 

	 *  and 1010 that drive the LED directly.

	/*

	 *  Set irq mode.

	/*

	 *  Configure targets according to driver setup.

	 *  If NVRAM present get targets setup from NVRAM.

	/*

	 *  Let user know about the settings.

	/*

	 *  Tell him more on demand.

	/*

	 *  And still more.

/*

 *  Test the pci bus snoop logic :-(

 *

 *  Has to be called with interrupts disabled.

	/*

	 *  chip registers may NOT be cached.

	 *  write 0xffffffff to a read only register area,

	 *  and try to read it back.

	/*

	 *  Enable Master Parity Checking as we intend 

	 *  to enable it for normal operations.

	/*

	 *  init

	/*

	 *  Set memory and register.

	/*

	 *  Start script (exchange values)

	/*

	 *  Wait 'til done (with timeout)

	/*

	 *  Check for fatal DMA errors.

 Band aiding for broken hardwares that fail PCI parity */

	/*

	 *  Save termination position.

	/*

	 *  Read memory and register.

	/*

	 *  Check termination position.

	/*

	 *  Show results.

/*

 *  log message for real hard errors

 *

 *  sym0 targ 0?: ERROR (ds:si) (so-si-sd) (sx/s3/s4) @ name (dsp:dbc).

 *  	      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf.

 *

 *  exception register:

 *  	ds:	dstat

 *  	si:	sist

 *

 *  SCSI bus lines:

 *  	so:	control lines as driven by chip.

 *  	si:	control lines as seen by chip.

 *  	sd:	scsi data lines as seen by chip.

 *

 *  wide/fastmode:

 *  	sx:	sxfer  (see the manual)

 *  	s3:	scntl3 (see the manual)

 *  	s4:	scntl4 (see the manual)

 *

 *  current script command:

 *  	dsp:	script address (relative to start of script).

 *  	dbc:	first word of script command.

 *

 *  First 24 register of the chip:

 *  	r0..rf

	/*

	 *  PCI BUS error.

/*

 *  Look up the chip table.

 *

 *  Return a pointer to the chip entry if found, 

 *  zero otherwise.

/*

 *  Lookup the 64 bit DMA segments map.

 *  This is only used if the direct mapping 

 *  has been unsuccessful.

 Look up existing mappings */

 If direct mapping is free, get it */

 Collision -> lookup free mappings */

/*

 *  Update IO registers scratch C..R so they will be 

 *  in sync. with queued CCB expectations.

 Enforce all the fiddly SPI rules and the chip limitations */

 Some targets fail to properly negotiate DT in SE mode */

 all DT transfers must be wide */

/*

 *  Prepare the next negotiation message if needed.

 *

 *  Fill in the part of message buffer that contains the 

 *  negotiation and the nego_status field of the CCB.

 *  Returns the size of the message in bytes.

	/*

	 * Many devices implement PPR in a buggy way, so only use it if we

	 * really want to.

 Keep track a nego will be performed */

/*

 *  Insert a job into the start queue.

	/*

	 *  If the previously queued CCB is not yet done, 

	 *  set the IARB hint. The SCRIPTS will go with IARB 

	 *  for this job when starting the previous one.

	 *  We leave devices a chance to win arbitration by 

	 *  not using more than 'iarb_max' consecutive 

	 *  immediate arbitrations.

	/*

	 *  Make SCRIPTS aware of the 64 bit DMA 

	 *  segment registers not being up-to-date.

	/*

	 *  Insert first the idle task and then our job.

	 *  The MBs should ensure proper ordering.

	/*

	 *  Script processor may be waiting for reselect.

	 *  Wake it up.

/*

 *  Start next ready-to-start CCBs.

	/* 

	 *  Paranoia, as usual. :-)

	/*

	 *  Try to start as many commands as asked by caller.

	 *  Prevent from having both tagged and untagged 

	 *  commands queued to the device at the same time.

 SYM_OPT_HANDLE_DEVICE_QUEUEING */

/*

 *  The chip may have completed jobs. Look at the DONE QUEUE.

 *

 *  On paper, memory read barriers may be needed here to 

 *  prevent out of order LOADs by the CPU from having 

 *  prefetched stale data prior to DMA having occurred.

 MEMORY_READ_BARRIER(); */

/*

 *  Complete all CCBs queued to the COMP queue.

 *

 *  These CCBs are assumed:

 *  - Not to be referenced either by devices or 

 *    SCRIPTS-related queues and datas.

 *  - To have to be completed with an error condition 

 *    or requeued.

 *

 *  The device queue freeze count is incremented 

 *  for each CCB that does not prevent this.

 *  This function is called when all CCBs involved 

 *  in error handling/recovery have been reaped.

 Leave quiet CCBs waiting for resources */

/*

 *  Complete all active CCBs with error.

 *  Used on CHIP/SCSI RESET.

	/*

	 *  Move all active CCBs to the COMP queue 

	 *  and flush this queue.

/*

 *  Start chip.

 *

 *  'reason' means:

 *     0: initialisation.

 *     1: SCSI BUS RESET delivered or received.

 *     2: SCSI BUS MODE changed.

 	/*

	 *  Reset chip if asked, otherwise just clear fifos.

	/*

	 *  Clear Start Queue

	/*

	 *  Start at first entry.

	/*

	 *  Clear Done Queue

	/*

	 *  Start at first entry.

	/*

	 *  Install patches in scripts.

	 *  This also let point to first position the start 

	 *  and done queue pointers used from SCRIPTS.

	/*

	 *  Wakeup all pending jobs.

	/*

	 *  Init chip.

  Remove Reset, abort */

 The 895 needs time for the bus mode to settle */

  full arb., ena parity, par->ATN  */

  odd parity, and remove CRST!! */

 Select SCSI clock */

 Adapter SCSI address */

 Id to respond to */

  Signal Process */

 Burst length, dma mode */

 Large fifo + large burst */

 Protect SFBR */

 Write and invalidate */

 Master parity checking */

 Extended Sreq/Sack filtering not supported on the C10 */

 TolerANT enable */

 HTH disabled  STO 0.25 sec */

	/*

	 *  For now, disable AIP generation on C1010-66.

	/*

	 *  C10101 rev. 0 errata.

	 *  Errant SGE's when in narrow. Write bits 4 & 5 of

	 *  STEST1 register to disable SGE. We probably should do 

	 *  that from SCRIPTS for each selection/reselection, but 

	 *  I just don't want. :)

	/*

	 *  DEL 441 - 53C876 Rev 5 - Part Number 609-0392787/2788 - ITEM 2.

	 *  Disable overlapped arbitration for some dual function devices, 

	 *  regardless revision id (kind of post-chip-design feature. ;-))

	/*

	 *  Write CCNTL0/CCNTL1 for chips capable of 64 bit addressing 

	 *  and/or hardware phase mismatch, since only such chips 

	 *  seem to support those IO registers.

	/*

	 *  Set up scratch C and DRS IO registers to map the 32 bit 

	 *  DMA address range our data structures are located in.

 ??? */

	/*

	 *  If phase mismatch handled by scripts (895A/896/1010),

	 *  set PM jump addresses.

	/*

	 *    Enable GPIO0 pin for writing if LED support from SCRIPTS.

	 *    Also set GPIO5 and clear GPIO6 if hardware LED control.

	/*

	 *      enable ints

	/*

	 *  For 895/6 enable SBMC interrupt and save current SCSI bus mode.

	 *  Try to eat the spurious SBMC interrupt that may occur when 

	 *  we reset the chip but not the SCSI BUS (at initialization).

	/*

	 *  Fill in target structure.

	 *  Reinitialize usrsync.

	 *  Reinitialize usrwide.

	 *  Prepare sync negotiation according to actual SCSI bus mode.

	/*

	 *  Download SCSI SCRIPTS to on-chip RAM if present,

	 *  and start script processor.

	 *  We do the download preferently from the CPU.

	 *  For platforms that may not support PCI memory mapping,

	 *  we use simple SCRIPTS that performs MEMORY MOVEs.

	/*

	 *  Notify the XPT about the RESET condition.

/*

 *  Switch trans mode for current job and its target.

	/*

	 *  Set the offset.

	/*

	 *  Set the sync divisor and extra clock factor.

	/*

	 *  Set the bus width.

	/*

	 *  Set misc. ultra enable bits.

	/*

	 *   Stop there if sync parameters are unchanged.

	/*

	 *  Disable extended Sreq/Sack filtering if per < 50.

	 *  Not supported on the C1010.

	/*

	 *  set actual value and sync_status

	/*

	 *  patch ALL busy ccbs of this target.

/*

 *  We received a WDTR.

 *  Let everything be aware of the changes.

/*

 *  We received a SDTR.

 *  Let everything be aware of the changes.

/*

 *  We received a PPR.

 *  Let everything be aware of the changes.

/*

 *  generic recovery from scsi interrupt

 *

 *  The doc says that when the chip gets an SCSI interrupt,

 *  it tries to stop in an orderly fashion, by completing 

 *  an instruction fetch that had started or by flushing 

 *  the DMA fifo for a write to memory that was executing.

 *  Such a fashion is not enough to know if the instruction 

 *  that was just before the current DSP value has been 

 *  executed or not.

 *

 *  There are some small SCRIPTS sections that deal with 

 *  the start queue and the done queue that may break any 

 *  assomption from the C code if we are interrupted 

 *  inside, so we reset if this happens. Btw, since these 

 *  SCRIPTS sections are executed while the SCRIPTS hasn't 

 *  started SCSI operations, it is very unlikely to happen.

 *

 *  All the driver data structures are supposed to be 

 *  allocated from the same 4 GB memory window, so there 

 *  is a 1 to 1 relationship between DSA and driver data 

 *  structures. Since we are careful :) to invalidate the 

 *  DSA when we complete a command or when the SCRIPTS 

 *  pushes a DSA into a queue, we can trust it when it 

 *  points to a CCB.

	/*

	 *  If we haven't been interrupted inside the SCRIPTS 

	 *  critical pathes, we can safely restart the SCRIPTS 

	 *  and trust the DSA value if it matches a CCB.

 clear dma fifo  */

 clear scsi fifo */

		/*

		 *  If we have a CCB, let the SCRIPTS call us back for 

		 *  the handling of the error with SCRATCHA filled with 

		 *  STARTPOS. This way, we will be able to freeze the 

		 *  device queue and requeue awaiting IOs.

		/*

		 *  Otherwise just restart the SCRIPTS.

/*

 *  chip exception handler for selection timeout

/*

 *  chip exception handler for unexpected disconnect

/*

 *  chip exception handler for SCSI bus mode change

 *

 *  spi2-r12 11.2.3 says a transceiver mode change must 

 *  generate a reset event and a device that detects a reset 

 *  event shall initiate a hard reset. It says also that a

 *  device that detects a mode change shall set data transfer 

 *  mode to eight bit asynchronous, etc...

 *  So, just reinitializing all except chip should be enough.

	/*

	 *  Notify user.

	/*

	 *  Should suspend command processing for a few seconds and 

	 *  reinitialize all except the chip.

/*

 *  chip exception handler for SCSI parity error.

 *

 *  When the chip detects a SCSI parity error and is 

 *  currently executing a (CH)MOV instruction, it does 

 *  not interrupt immediately, but tries to finish the 

 *  transfer of the current scatter entry before 

 *  interrupting. The following situations may occur:

 *

 *  - The complete scatter entry has been transferred 

 *    without the device having changed phase.

 *    The chip will then interrupt with the DSP pointing 

 *    to the instruction that follows the MOV.

 *

 *  - A phase mismatch occurs before the MOV finished 

 *    and phase errors are to be handled by the C code.

 *    The chip will then interrupt with both PAR and MA 

 *    conditions set.

 *

 *  - A phase mismatch occurs before the MOV finished and 

 *    phase errors are to be handled by SCRIPTS.

 *    The chip will load the DSP with the phase mismatch 

 *    JUMP address and interrupt the host processor.

	/*

	 *  Check that the chip is connected to the SCSI BUS.

	/*

	 *  If the nexus is not clearly identified, reset the bus.

	 *  We will try to do better later.

	/*

	 *  Check instruction was a MOV, direction was INPUT and 

	 *  ATN is asserted.

	/*

	 *  Keep track of the parity error.

	/*

	 *  Prepare the message to send to the device.

	/*

	 *  If the old phase was DATA IN phase, we have to deal with

	 *  the 3 situations described above.

	 *  For other input phases (MSG IN and STATUS), the device 

	 *  must resend the whole thing that failed parity checking 

	 *  or signal error. So, jumping to dispatcher should be OK.

 Phase mismatch handled by SCRIPTS */

 Phase mismatch handled by the C code */

 No phase mismatch occurred */

 We definitely cannot handle parity errors */

 in message-in phase due to the relection  */

 path and various message anticipations.   */

/*

 *  chip exception handler for phase errors.

 *

 *  We have to construct a new transfer descriptor,

 *  to transfer the rest of the current block.

	/*

	 *  locate matching cp if any.

	/*

	 *  Donnot take into account dma fifo and various buffers in 

	 *  INPUT phase since the chip flushes everything before 

	 *  raising the MA interrupt for interrupted INPUT phases.

	 *  For DATA IN phase, we will check for the SWIDE later.

			/*

			 * Read DFIFO, CTEST[4-6] using 1 PCI bus ownership.

			/*

			 *  Calculate remaining bytes in DMA fifo.

			 *  (CTEST5 = dfifo >> 16)

		/*

		 *  The data in the dma fifo has not been transferred to

		 *  the target -> add the amount to the rest

		 *  and clear the data.

		 *  Check the sstat2 register in case of wide transfer.

		/*

		 *  Clear fifos.

 dma fifo  */

 scsi fifo */

	/*

	 *  log the information

	/*

	 *  try to find the interrupted script command,

	 *  and the address at which to continue.

	/*

	 *  log the information

	/*

	 *  get old startaddress and old length.

 Table indirect */

	/*

	 *  check cmd against assumed interrupted script command.

	 *  If dt data phase, the MOVE instruction hasn't bit 4 of 

	 *  the phase.

	/*

	 *  if old phase not dataphase, leave here.

	/*

	 *  Choose the correct PM save area.

	 *

	 *  Look at the PM_SAVE SCRIPT if you want to understand 

	 *  this stuff. The equivalent code is implemented in 

	 *  SCRIPTS for the 895A, 896 and 1010 that are able to 

	 *  handle PM from the SCRIPTS processor.

	/*

	 *  fillin the phase mismatch context

	/*

	 *  If we have a SWIDE,

	 *  - prepare the address to write the SWIDE from SCRIPTS,

	 *  - compute the SCRIPTS address to restart from,

	 *  - move current data pointer context by one byte.

		/*

		 *  Set up the table indirect for the MOVE

		 *  of the residual byte and adjust the data 

		 *  pointer context.

		/*

		 *  If only the residual byte is to be moved, 

		 *  no PM context is needed.

		/*

		 *  Prepare the address of SCRIPTS that will 

		 *  move the residual byte to memory.

	/*

	 *  Restart the SCRIPTS processor.

	/*

	 *  Unexpected phase changes that occurs when the current phase 

	 *  is not a DATA IN or DATA OUT phase are due to error conditions.

	 *  Such event may only happen when the SCRIPTS is using a 

	 *  multibyte SCSI MOVE.

	 *

	 *  Phase change		Some possible cause

	 *

	 *  COMMAND  --> MSG IN	SCSI parity error detected by target.

	 *  COMMAND  --> STATUS	Bad command or refused by target.

	 *  MSG OUT  --> MSG IN     Message rejected by target.

	 *  MSG OUT  --> COMMAND    Bogus target that discards extended

	 *  			negotiation messages.

	 *

	 *  The code below does not care of the new phase and so 

	 *  trusts the target. Why to annoy it ?

	 *  If the interrupted phase is COMMAND phase, we restart at

	 *  dispatcher.

	 *  If a target does not get all the messages after selection, 

	 *  the code assumes blindly that the target discards extended 

	 *  messages and clears the negotiation status.

	 *  If the target does not want all our response to negotiation,

	 *  we force a SIR_NEGO_PROTO interrupt (it is a hack that avoids 

	 *  bloat for such a should_not_happen situation).

	 *  In all other situation, we reset the BUS.

	 *  Are these assumptions reasonable ? (Wait and see ...)

 COMMAND phase */

 STATUS  phase */

 MSG OUT phase */

		/*

		 *  If the device may want to use untagged when we want 

		 *  tagged, we prepare an IDENTIFY without disc. granted, 

		 *  since we will not be able to handle reselect.

		 *  Otherwise, we just don't care.

 MSG IN  phase */

/*

 *  chip interrupt handler

 *

 *  In normal situations, interrupt conditions occur one at 

 *  a time. But when something bad happens on the SCSI BUS, 

 *  the chip may raise several interrupt flags before 

 *  stopping and interrupting the CPU. The additionnal 

 *  interrupt flags are stacked in some extra registers 

 *  after the SIP and/or DIP flag has been raised in the 

 *  ISTAT. After the CPU has read the interrupt condition 

 *  flag from SIST or DSTAT, the chip unstacks the other 

 *  interrupt flags and sets the corresponding bits in 

 *  SIST or DSTAT. Since the chip starts stacking once the 

 *  SIP or DIP flag is set, there is a small window of time 

 *  where the stacking does not occur.

 *

 *  Typically, multiple interrupt conditions may happen in 

 *  the following situations:

 *

 *  - SCSI parity error + Phase mismatch  (PAR|MA)

 *    When an parity error is detected in input phase 

 *    and the device switches to msg-in phase inside a 

 *    block MOV.

 *  - SCSI parity error + Unexpected disconnect (PAR|UDC)

 *    When a stupid device does not want to handle the 

 *    recovery of an SCSI parity error.

 *  - Some combinations of STO, PAR, UDC, ...

 *    When using non compliant SCSI stuff, when user is 

 *    doing non compliant hot tampering on the BUS, when 

 *    something really bad happens to a device, etc ...

 *

 *  The heuristic suggested by SYMBIOS to handle 

 *  multiple interrupts is to try unstacking all 

 *  interrupts conditions and to handle them on some 

 *  priority based on error severity.

 *  This will work when the unstacking has been 

 *  successful, but we cannot be 100 % sure of that, 

 *  since the CPU may have been faster to unstack than 

 *  the chip is able to stack. Hmmm ... But it seems that 

 *  such a situation is very unlikely to happen.

 *

 *  If this happen, for example STO caught by the CPU 

 *  then UDC happenning before the CPU have restarted 

 *  the SCRIPTS, the driver may wrongly complete the 

 *  same command on UDC, since the SCRIPTS didn't restart 

 *  and the DSA still points to the same command.

 *  We avoid this situation by setting the DSA to an 

 *  invalid value when the CCB is completed and before 

 *  restarting the SCRIPTS.

 *

 *  Another issue is that we need some section of our 

 *  recovery procedures to be somehow uninterruptible but 

 *  the SCRIPTS processor does not provides such a 

 *  feature. For this reason, we handle recovery preferently 

 *  from the C code and check against some SCRIPTS critical 

 *  sections from the C code.

 *

 *  Hopefully, the interrupt handling of the driver is now 

 *  able to resist to weird BUS error conditions, but donnot 

 *  ask me for any guarantee that it will never fail. :-)

 *  Use at your own decision and risk.

	/*

	 *  interrupt on the fly ?

	 *  (SCRIPTS may still be running)

	 *

	 *  A `dummy read' is needed to ensure that the 

	 *  clear of the INTF flag reaches the device 

	 *  and that posted writes are flushed to memory

	 *  before the scanning of the DONE queue.

	 *  Note that SCRIPTS also (dummy) read to memory 

	 *  prior to deliver the INTF interrupt condition.

 DUMMY READ */

 We should never get this one */

	/*

	 *  PAR and MA interrupts may occur at the same time,

	 *  and we need to know of both in order to handle 

	 *  this situation properly. We try to unstack SCSI 

	 *  interrupts for that reason. BTW, I dislike a LOT 

	 *  such a loop inside the interrupt routine.

	 *  Even if DMA interrupt stacking is very unlikely to 

	 *  happen, we also try unstacking these ones, since 

	 *  this has no performance impact.

		/* Prevent deadlock waiting on a condition that may

	/*

	 *  On paper, a memory read barrier may be needed here to 

	 *  prevent out of order LOADs by the CPU from having 

	 *  prefetched stale data prior to DMA having occurred.

	 *  And since we are paranoid ... :)

	/*

	 *  First, interrupts we want to service cleanly.

	 *

	 *  Phase mismatch (MA) is the most frequent interrupt 

	 *  for chip earlier than the 896 and so we have to service 

	 *  it as quickly as possible.

	 *  A SCSI parity error (PAR) may be combined with a phase 

	 *  mismatch condition (MA).

	 *  Programmed interrupts (SIR) are used to call the C code 

	 *  from SCRIPTS.

	 *  The single step interrupt (SSI) is not used in this 

	 *  driver.

	/*

	 *  Now, interrupts that donnot happen in normal 

	 *  situations and that we may need to recover from.

	 *

	 *  On SCSI RESET (RST), we reset everything.

	 *  On SCSI BUS MODE CHANGE (SBMC), we complete all 

	 *  active CCBs with RESET status, prepare all devices 

	 *  for negotiating again and restart the SCRIPTS.

	 *  On STO and UDC, we complete the CCB with the corres- 

	 *  ponding status and restart the SCRIPTS.

 clear dma fifo  */

 clear scsi fifo */

	/*

	 *  Now, interrupts we are not able to recover cleanly.

	 *

	 *  Log message for hard errors.

	 *  Reset everything.

	/*

	 *  We just miss the cause of the interrupt. :(

	 *  Print a message. The timeout will do the real work.

/*

 *  Dequeue from the START queue all CCBs that match 

 *  a given target/lun/task condition (-1 means all),

 *  and move them from the BUSY queue to the COMP queue 

 *  with DID_SOFT_ERROR status condition.

 *  This function is used during error handling/recovery.

 *  It is called with SCRIPTS not running.

	/*

	 *  Make sure the starting index is within range.

	/*

	 *  Walk until end of START queue and dequeue every job 

	 *  that matches the target/lun/task condition.

 Forget hints for IARB, they may be no longer relevant */

 Copy back the idle task if needed */

 Update our current start queue pointer */

/*

 *  chip handler for bad SCSI status condition

 *

 *  In case of bad SCSI status, we unqueue all the tasks 

 *  currently queued to the controller but not yet started 

 *  and then restart the SCRIPTS processor immediately.

 *

 *  QUEUE FULL and BUSY conditions are handled the same way.

 *  Basically all the not yet started tasks are requeued in 

 *  device queue and the queue is frozen until a completion.

 *

 *  For CHECK CONDITION and COMMAND TERMINATED status, we use 

 *  the CCB of the failed command to prepare a REQUEST SENSE 

 *  SCSI command and queue it to the controller queue.

 *

 *  SCRATCHA is assumed to have been loaded with STARTPOS 

 *  before the SCRIPTS called the C code.

	/*

	 *  Compute the index of the next job to start from SCRIPTS.

	/*

	 *  The last CCB queued used for IARB hint may be 

	 *  no longer relevant. Forget it.

	/*

	 *  Now deal with the SCSI status.

 S_INT, S_INT_COND_MET, S_CONFLICT */

		/*

		 *  If we get an SCSI error when requesting sense, give up.

		/*

		 *  Dequeue all queued CCBs for that device not yet started,

		 *  and restart the SCRIPTS processor immediately.

 		/*

		 *  Save some info of the actual IO.

		 *  Compute the data residual.

		/*

		 *  Prepare all needed data structures for 

		 *  requesting sense data.

		/*

		 *  If we are currently using anything different from 

		 *  async. 8 bit data transfers with that target,

		 *  start a negotiation, since the device may want 

		 *  to report us a UNIT ATTENTION condition due to 

		 *  a cause we currently ignore, and we donnot want 

		 *  to be stuck with WIDE and/or SYNC data transfer.

		 *

		 *  cp->nego_status is filled by sym_prepare_nego().

		/*

		 *  Message table indirect structure.

		/*

		 *  sense command

		/*

		 *  patch requested size into sense command

		/*

		 *  sense data

		/*

		 *  requeue the command.

		/*

		 *  Requeue the command.

		/*

		 *  Give back to upper layer everything we have dequeued.

/*

 *  After a device has accepted some management message 

 *  as BUS DEVICE RESET, ABORT TASK, etc ..., or when 

 *  a device signals a UNIT ATTENTION condition, some 

 *  tasks are thrown away by the device. We are required 

 *  to reflect that on our tasks list since the device 

 *  will never complete these tasks.

 *

 *  This function move from the BUSY queue to the COMP 

 *  queue all disconnected CCBs for a given target that 

 *  match the following criteria:

 *  - lun=-1  means any logical UNIT otherwise a given one.

 *  - task=-1 means any task, otherwise a given one.

	/*

	 *  Move the entire BUSY queue to our temporary queue.

	/*

	 *  Put all CCBs that matches our criteria into 

	 *  the COMP queue and put back other ones into 

	 *  the BUSY queue.

 Preserve the software timeout condition */

/*

 *  chip handler for TASKS recovery

 *

 *  We cannot safely abort a command, while the SCRIPTS 

 *  processor is running, since we just would be in race 

 *  with it.

 *

 *  As long as we have tasks to abort, we keep the SEM 

 *  bit set in the ISTAT. When this bit is set, the 

 *  SCRIPTS processor interrupts (SIR_SCRIPT_STOPPED) 

 *  each time it enters the scheduler.

 *

 *  If we have to reset a target, clear tasks of a unit,

 *  or to perform the abort of a disconnected job, we 

 *  restart the SCRIPTS for selecting the target. Once 

 *  selected, the SCRIPTS interrupts (SIR_TARGET_SELECTED).

 *  If it loses arbitration, the SCRIPTS will interrupt again 

 *  the next time it will enter its scheduler, and so on ...

 *

 *  On SIR_TARGET_SELECTED, we scan for the more 

 *  appropriate thing to do:

 *

 *  - If nothing, we just sent a M_ABORT message to the 

 *    target to get rid of the useless SCSI bus ownership.

 *    According to the specs, no tasks shall be affected.

 *  - If the target is to be reset, we send it a M_RESET 

 *    message.

 *  - If a logical UNIT is to be cleared , we send the 

 *    IDENTIFY(lun) + M_ABORT.

 *  - If an untagged task is to be aborted, we send the 

 *    IDENTIFY(lun) + M_ABORT.

 *  - If a tagged task is to be aborted, we send the 

 *    IDENTIFY(lun) + task attributes + M_ABORT_TAG.

 *

 *  Once our 'kiss of death' :) message has been accepted 

 *  by the target, the SCRIPTS interrupts again 

 *  (SIR_ABORT_SENT). On this interrupt, we complete 

 *  all the CCBs that should have been aborted by the 

 *  target according to our message.

 gcc isn't quite smart enough yet */

	/*

	 *  The SCRIPTS processor stopped before starting

	 *  the next command in order to allow us to perform 

	 *  some task recovery.

		/*

		 *  Do we have any target to reset or unit to clear ?

		/*

		 *  If not, walk the busy queue for any 

		 *  disconnected CCB to be aborted.

		/*

		 *  If some target is to be selected, 

		 *  prepare and start the selection.

		/*

		 *  Now look for a CCB to abort that haven't started yet.

		 *  Btw, the SCRIPTS processor is still stopped, so 

		 *  we are not in race.

			/*

			 *    If we are using IMMEDIATE ARBITRATION, we donnot 

			 *    want to cancel the last queued CCB, since the 

			 *    SCRIPTS may have anticipated the selection.

 Means we have found some */

			/*

			 *  We are done, so we donnot need 

			 *  to synchronize with the SCRIPTS anylonger.

			 *  Remove the SEM flag from the ISTAT.

		/*

		 *  Compute index of next position in the start 

		 *  queue the SCRIPTS intends to start and dequeue 

		 *  all CCBs for that device that haven't been started.

		/*

		 *  Make sure at least our IO to abort has been dequeued.

		/*

		 *  Keep track in cam status of the reason of the abort.

		/*

		 *  Complete with error everything that we have dequeued.

	/*

	 *  The SCRIPTS processor has selected a target 

	 *  we may have some manual recovery to perform for.

		/*

		 *  If the target is to be reset, prepare a 

		 *  M_RESET message and clear the to_reset flag 

		 *  since we donnot expect this operation to fail.

		/*

		 *  Otherwise, look for some logical unit to be cleared.

		/*

		 *  If a logical unit is to be cleared, prepare 

		 *  an IDENTIFY(lun) + ABORT MESSAGE.

 We don't expect to fail here */

		/*

		 *  Otherwise, look for some disconnected job to 

		 *  abort for this target.

 Means we have some */

		/*

		 *  If we have none, probably since the device has 

		 *  completed the command before we won abitration,

		 *  send a M_ABORT message without IDENTIFY.

		 *  According to the specs, the device must just 

		 *  disconnect the BUS and not abort any task.

		/*

		 *  We have some task to abort.

		 *  Set the IDENTIFY(lun)

		/*

		 *  If we want to abort an untagged command, we 

		 *  will send a IDENTIFY + M_ABORT.

		 *  Otherwise (tagged command), we will send 

		 *  a IDENTITFY + task attributes + ABORT TAG.

		/*

		 *  Keep track of software timeout condition, since the 

		 *  peripheral driver may not count retries on abort 

		 *  conditions not due to timeout.

 We donnot expect to fail here */

	/*

	 *  The target has accepted our message and switched 

	 *  to BUS FREE phase as we expected.

		/*

		**  If we didn't abort anything, leave here.

		/*

		 *  If we sent a M_RESET, then a hardware reset has 

		 *  been performed by the target.

		 *  - Reset everything to async 8 bit

		 *  - Tell ourself to negotiate next time :-)

		 *  - Prepare to clear all disconnected CCBs for 

		 *    this target from our task list (lun=task=-1)

		/*

		 *  Otherwise, check for the LUN and TASK(s) 

		 *  concerned by the cancelation.

		 *  If it is not ABORT_TAG then it is CLEAR_QUEUE 

		 *  or an ABORT message :-)

		/*

		 *  Complete all the CCBs the device should have 

		 *  aborted due to our 'kiss of death' message.

 		/*

		 *  If we sent a BDR, make upper layer aware of that.

	/*

	 *  Print to the log the message we intend to send.

	/*

	 *  Let the SCRIPTS processor continue.

/*

 *  Gerard's alchemy:) that deals with with the data 

 *  pointer for both MDP and the residual calculation.

 *

 *  I didn't want to bloat the code by more than 200 

 *  lines for the handling of both MDP and the residual.

 *  This has been achieved by using a data pointer 

 *  representation consisting in an index in the data 

 *  array (dp_sg) and a negative offset (dp_ofs) that 

 *  have the following meaning:

 *

 *  - dp_sg = SYM_CONF_MAX_SG

 *    we are at the end of the data script.

 *  - dp_sg < SYM_CONF_MAX_SG

 *    dp_sg points to the next entry of the scatter array 

 *    we want to transfer.

 *  - dp_ofs < 0

 *    dp_ofs represents the residual of bytes of the 

 *    previous entry scatter entry we will send first.

 *  - dp_ofs = 0

 *    no residual to send first.

 *

 *  The function sym_evaluate_dp() accepts an arbitray 

 *  offset (basically from the MDP message) and returns 

 *  the corresponding values of dp_sg and dp_ofs.

	/*

	 *  Compute the resulted data pointer in term of a script 

	 *  address within some DATA script and a signed byte offset.

	/*

	 *  If we are auto-sensing, then we are done.

	/*

	 *  Deduce the index of the sg entry.

	 *  Keep track of the index of the first valid entry.

	 *  If result is dp_sg = SYM_CONF_MAX_SG, then we are at the 

	 *  end of the data.

	/*

	 *  Move to the sg entry the data pointer belongs to.

	 *

	 *  If we are inside the data area, we expect result to be:

	 *

	 *  Either,

	 *      dp_ofs = 0 and dp_sg is the index of the sg entry

	 *      the data pointer belongs to (or the end of the data)

	 *  Or,

	 *      dp_ofs < 0 and dp_sg is the index of the sg entry 

	 *      the data pointer belongs to + 1.

	/*

	 *  Make sure the data pointer is inside the data area.

	 *  If not, return some error.

	/*

	 *  Save the extreme pointer if needed.

	/*

	 *  Return data.

/*

 *  chip handler for MODIFY DATA POINTER MESSAGE

 *

 *  We also call this function on IGNORE WIDE RESIDUE 

 *  messages that do not match a SWIDE full condition.

 *  Btw, we assume in that situation that such a message 

 *  is equivalent to a MODIFY DATA POINTER (offset=-1).

	/*

	 *  Not supported for auto-sense.

	/*

	 *  Apply our alchemy:) (see comments in sym_evaluate_dp()), 

	 *  to the resulted data pointer.

	/*

	 *  And our alchemy:) allows to easily calculate the data 

	 *  script address we want to return for the next data phase.

	/*

	 *  If offset / scatter entry is zero we donnot need 

	 *  a context for the new current data pointer.

	/*

	 *  Get a context for the new current data pointer.

	/*

	 *  Set up the new current data pointer.

	 *  ofs < 0 there, and for the next data phase, we 

	 *  want to transfer part of the data of the sg entry 

	 *  corresponding to index dp_sg-1 prior to returning 

	 *  to the main data script.

/*

 *  chip calculation of the data residual.

 *

 *  As I used to say, the requirement of data residual 

 *  in SCSI is broken, useless and cannot be achieved 

 *  without huge complexity.

 *  But most OSes and even the official CAM require it.

 *  When stupidity happens to be so widely spread inside 

 *  a community, it gets hard to convince.

 *

 *  Anyway, I don't care, since I am not going to use 

 *  any software that considers this data residual as 

 *  a relevant information. :)

	/*

	 *  Check for some data lost or just thrown away.

	 *  We are not required to be quite accurate in this 

	 *  situation. Btw, if we are odd for output and the 

	 *  device claims some more data, it may well happen 

	 *  than our residual be zero. :-)

	/*

	 *  If all data has been transferred,

	 *  there is no residual.

	/*

	 *  If no data transfer occurs, or if the data

	 *  pointer is weird, return full residual.

	/*

	 *  If we were auto-sensing, then we are done.

	/*

	 *  We are now full comfortable in the computation 

	 *  of the data residual (2's complement).

	/*

	 *  Hopefully, the result is not too wrong.

/*

 *  Negotiation for WIDE and SYNCHRONOUS DATA TRANSFER.

 *

 *  When we try to negotiate, we append the negotiation message

 *  to the identify and (maybe) simple tag message.

 *  The host status field is set to HS_NEGOTIATE to mark this

 *  situation.

 *

 *  If the target doesn't answer this message immediately

 *  (as required by the standard), the SIR_NEGO_FAILED interrupt

 *  will be raised eventually.

 *  The handler removes the HS_NEGOTIATE status, and sets the

 *  negotiated value to the default (async / nowide).

 *

 *  If we receive a matching answer immediately, we check it

 *  for validity, and set the values.

 *

 *  If we receive a Reject message immediately, we assume the

 *  negotiation has failed, and fall back to standard values.

 *

 *  If we receive a negotiation message while not in HS_NEGOTIATE

 *  state, it's a target initiated negotiation. We prepare a

 *  (hopefully) valid answer, set our parameters, and send back 

 *  this answer to the target.

 *

 *  If the target doesn't fetch the answer (no message out phase),

 *  we assume the negotiation has failed, and fall back to default

 *  settings (SIR_NEGO_PROTO interrupt).

 *

 *  When we set the values, we adjust them in all ccbs belonging 

 *  to this target, in the controller's register, and in the "phys"

 *  field of the controller's struct sym_hcb.

/*

 *  chip handler for SYNCHRONOUS DATA TRANSFER REQUEST (SDTR) message.

	/*

	 *  Get requested values.

	/*

	 *  Check values against our limits.

	/*

	 *  Get new chip synchronous parameters value.

	/*

	 *  If it was an answer we want to change, 

	 *  then it isn't acceptable. Reject it.

	/*

	 *  Apply new values.

	/*

	 *  It was an answer. We are done.

	/*

	 *  It was a request. Prepare an answer message.

	/*

	 *  Request or answer ?

	/*

	 *  Check and apply new values.

 Not acceptable, reject it */

 Was a request, send response. */

 Was a response, we are done. */

/*

 *  chip handler for PARALLEL PROTOCOL REQUEST (PPR) message.

	/*

	 *  Check values against our limits.

	/*

	 *  Get new chip synchronous parameters value.

	/*

	 *  If it was an answer we want to change, 

	 *  then it isn't acceptable. Reject it.

	/*

	 *  Apply new values.

	/*

	 *  It was an answer. We are done.

	/*

	 *  It was a request. Prepare an answer message.

	/*

	 *  If it is a device response that should result in  

	 *  ST, we may want to try a legacy negotiation later.

	/*

	 *  Request or answer ?

	/*

	 *  Check and apply new values.

 Not acceptable, reject it */

 Was a request, send response. */

 Was a response, we are done. */

/*

 *  chip handler for WIDE DATA TRANSFER REQUEST (WDTR) message.

	/*

	 *  Get requested values.

	/*

	 *  Check values against our limits.

	/*

	 *  If it was an answer we want to change, 

	 *  then it isn't acceptable. Reject it.

	/*

	 *  Apply new values.

	/*

	 *  It was an answer. We are done.

	/*

	 *  It was a request. Prepare an answer message.

	/*

	 *  Request or answer ?

	/*

	 *  Check and apply new values.

 Not acceptable, reject it */

 Was a request, send response. */

 Was a response. */

		/*

		 * Negotiate for SYNC immediately after WIDE response.

		 * This allows to negotiate for both WIDE and SYNC on 

		 * a single SCSI command (Suggested by Justin Gibbs).

/*

 *  Reset DT, SYNC or WIDE to default settings.

 *

 *  Called when a negotiation does not succeed either 

 *  on rejection or on protocol error.

 *

 *  A target that understands a PPR message should never 

 *  reject it, and messing with it is very unlikely.

 *  So, if a PPR makes problems, we may just want to 

 *  try a legacy negotiation later.

/*

 *  chip handler for MESSAGE REJECT received in response to 

 *  PPR, WIDE or SYNCHRONOUS negotiation.

/*

 *  chip exception handler for programmed interrupts.

	/*

	 *  SCRIPTS tell us that we may have to update 

	 *  64 bit DMA segment registers.

	/*

	 *  Command has been completed with error condition 

	 *  or has been auto-sensed.

	/*

	 *  The C code is currently trying to recover from something.

	 *  Typically, user want to abort some command.

	/*

	 *  The device didn't go to MSG OUT phase after having 

	 *  been selected with ATN.  We do not want to handle that.

	/*

	 *  The device didn't switch to MSG IN phase after 

	 *  having reselected the initiator.

	/*

	 *  After reselection, the device sent a message that wasn't 

	 *  an IDENTIFY.

	/*

	 *  The device reselected a LUN we do not know about.

	/*

	 *  The device reselected for an untagged nexus and we 

	 *  haven't any.

	/*

	 * The device reselected for a tagged nexus that we do not have.

	/*

	 *  The SCRIPTS let us know that the device has grabbed 

	 *  our message and will abort the job.

	/*

	 *  The SCRIPTS let us know that a message has been 

	 *  successfully sent to the device.

 Should we really care of that */

	/*

	 *  The device didn't send a GOOD SCSI status.

	 *  We may have some work to do prior to allow 

	 *  the SCRIPTS processor to continue.

	/*

	 *  We are asked by the SCRIPTS to prepare a 

	 *  REJECT message.

	/*

	 *  We have been ODD at the end of a DATA IN 

	 *  transfer and the device didn't send a 

	 *  IGNORE WIDE RESIDUE message.

	 *  It is a data overrun condition.

	/*

	 *  We have been ODD at the end of a DATA OUT 

	 *  transfer.

	 *  It is a data underrun condition.

	/*

	 *  The device wants us to tranfer more data than 

	 *  expected or in the wrong direction.

	 *  The number of extra bytes is in scratcha.

	 *  It is a data overrun condition.

	/*

	 *  The device switched to an illegal phase (4/5).

	/*

	 *  We received a message.

		/*

		 *  We received an extended message.

		 *  We handle MODIFY DATA POINTER, SDTR, WDTR 

		 *  and reject all other extended messages.

		/*

		 *  We received a 1/2 byte message not handled from SCRIPTS.

		 *  We are only expecting MESSAGE REJECT and IGNORE WIDE 

		 *  RESIDUE messages that haven't been anticipated by 

		 *  SCRIPTS on SWIDE full condition. Unanticipated IGNORE 

		 *  WIDE RESIDUE messages are aliased as MODIFY DP (-1).

	/*

	 *  We received an unknown message.

	 *  Ignore all MSG IN phases and reject it.

	/*

	 *  Negotiation failed.

	 *  Target does not send us the reply.

	 *  Remove the HS_NEGOTIATE status.

	/*

	 *  Negotiation failed.

	 *  Target does not want answer message.

/*

 *  Acquire a control block

	/*

	 *  Look for a free CCB

		/*

		 *  If we have been asked for a tagged command.

			/*

			 *  Debugging purpose.

			/*

			 *  Allocate resources for tags if not yet.

			/*

			 *  Get a tag for this SCSI IO and set up

			 *  the CCB bus address for reselection, 

			 *  and count it for this LUN.

			 *  Toggle reselect path to tagged.

		/*

		 *  This command will not be tagged.

		 *  If we already have either a tagged or untagged 

		 *  one, refuse to overlap this untagged one.

			/*

			 *  Debugging purpose.

			/*

			 *  Count this nexus for this LUN.

			 *  Set up the CCB bus address for reselection.

			 *  Toggle reselect path to untagged.

	/*

	 *  Put the CCB into the busy queue.

/*

 *  Release one control block

	/*

	 *  If LCB available,

		/*

		 *  If tagged, release the tag, set the relect path 

			/*

			 *  Free the tag value.

			/*

			 *  Make the reselect path invalid, 

			 *  and uncount this CCB.

 Untagged */

			/*

			 *  Make the reselect path invalid, 

			 *  and uncount this CCB.

		/*

		 *  If no JOB active, make the LUN reselect path invalid.

	/*

	 *  We donnot queue more than 1 ccb per target 

	 *  with negotiation at any time. If this ccb was 

	 *  used for negotiation, clear this info in the tcb.

	/*

	 *  If we just complete the last queued CCB,

	 *  clear this info that is no longer relevant.

	/*

	 *  Make this CCB available.

/*

 *  Allocate a CCB from memory and initialize its fixed part.

	/*

	 *  Prevent from allocating more CCBs than we can 

	 *  queue to the controller.

	/*

	 *  Allocate memory for this CCB.

	/*

	 *  Count it.

	/*

	 *  Compute the bus address of this ccb.

	/*

	 *  Insert this ccb into the hashed list.

	/*

	 *  Initialyze the start and restart actions.

 	/*

	 *  Initilialyze some other fields.

	/*

	 *  Chain into free ccb queue.

	/*

	 *  Chain into optionnal lists.

/*

 *  Look up a CCB from a DSA value.

/*

 *  Target control block initialisation.

 *  Nothing important to do at the moment.

  Hmmm... this checking looks paranoid. */

	/*

	 *  Check some alignments required by the chip.

/*

 *  Lun control block allocation and initialization.

	/*

	 *  Initialize the target control block if not yet.

	/*

	 *  Allocate the LCB bus address array.

	 *  Compute the bus address of this table.

	/*

	 *  Allocate the table of pointers for LUN(s) > 0, if needed.

	/*

	 *  Allocate the lcb.

	 *  Make it available to the chip.

	/*

	 *  Let the itl task point to error handling.

	/*

	 *  Set the reselect pattern to our default. :)

	/*

	 *  Set user capabilities.

	/*

	 *  Initialize device queueing.

/*

 *  Allocate LCB resources for tagged command queuing.

	/*

	 *  Allocate the task table and and the tag allocation 

	 *  circular buffer. We want both or none.

	/*

	 *  Initialize the task table with invalid entries.

	/*

	 *  Fill up the tag buffer with tag numbers.

	/*

	 *  Make the task table available to SCRIPTS, 

	 *  And accept tagged commands now.

/*

 *  Lun control block deallocation. Returns the number of valid remaining LCBs

 *  for the target.

/*

 *  Queue a SCSI IO to the controller.

	/*

	 *  Keep track of the IO in our CCB.

	/*

	 *  Retrieve the target descriptor.

	/*

	 *  Retrieve the lun descriptor.

	/*

	 *  Build the tag message if present.

		/*

		 *  Avoid too much reordering of SCSI commands.

		 *  The algorithm tries to prevent completion of any 

		 *  tagged command from being delayed against more 

		 *  than 3 times the max number of queued commands.

		/*

		 *  For less than 128 tags, actual tags are numbered 

		 *  1,3,5,..2*MAXTAGS+1,since we may have to deal 

		 *  with devices that have problems with #TAG 0 or too 

		 *  great #TAG numbers. For more tags (up to 256), 

		 *  we use directly our tag number.

	/*

	 *  Build a negotiation message if needed.

	 *  (nego_status is filled by sym_prepare_nego())

	 *

	 *  Always negotiate on INQUIRY and REQUEST SENSE.

	 *

	/*

	 *  Startqueue

	/*

	 *  select

	/*

	 *  message

	/*

	 *  status

	/*

	 *  extreme data pointer.

	 *  shall be positive, so -1 is lower than lowest.:)

	/*

	 *  Build the CDB and DATA descriptor block 

	 *  and start the IO.

/*

 *  Reset a SCSI target (all LUNs of this target).

/*

 *  Abort a SCSI IO.

	/*

	 *  Check that the IO is active.

	/*

	 *  If a previous abort didn't succeed in time,

	 *  perform a BUS reset.

	/*

	 *  Mark the CCB for abort and allow time for.

	/*

	 *  Tell the SCRIPTS processor to stop and synchronize with us.

	/*

	 *  Look up our CCB control block.

/*

 *  Complete execution of a SCSI command with extended 

 *  error, SCSI status error, or having been auto-sensed.

 *

 *  The SCRIPTS processor is not running there, so we 

 *  can safely access IO registers and remove JOBs from  

 *  the START queue.

 *  SCRATCHA is assumed to have been loaded with STARTPOS 

 *  before the SCRIPTS called the C code.

	/*

	 *  Paranoid check. :)

	/*

	 *  Get target and lun pointers.

	/*

	 *  Check for extended errors.

	/*

	 *  Calculate the residual.

 If user does not want residuals */

 throw them away. :)		    */

	/*

	 *  Dequeue all queued CCBs for that device 

	 *  not yet started by SCRIPTS.

	/*

	 *  Restart the SCRIPTS processor.

		/*

		 *  Decrease queue depth as needed.

		/*

		 *  Repair the CCB.

		/*

		 *  Let's requeue it to device.

	/*

	 *  Build result in CAM ccb.

	/*

	 *  Add this one to the COMP queue.

	/*

	 *  Complete all those commands with either error 

	 *  or requeue condition.

	/*

	 *  Donnot start more than 1 command after an error.

/*

 *  Complete execution of a successful SCSI command.

 *

 *  Only successful commands go to the DONE queue, 

 *  since we need to have the SCRIPTS processor 

 *  stopped on any error condition.

 *  The SCRIPTS processor is running while we are 

 *  completing successful commands.

	/*

	 *  Paranoid check. :)

	/*

	 *  Get user command.

	/*

	 *  Get target and lun pointers.

	/*

	 *  If all data have been transferred, given than no

	 *  extended error did occur, there is no residual.

	/*

	 *  Wrong transfer residuals may be worse than just always 

	 *  returning zero. User can disable this feature in 

	 *  sym53c8xx.h. Residual support is enabled by default.

	/*

	 *  Build result in CAM ccb.

	/*

	 *  If max number of started ccbs had been reduced,

	 *  increase it if 200 good status received.

	/*

	 *  Free our CCB.

	/*

	 *  Requeue a couple of awaiting scsi commands.

	/*

	 *  Complete the command.

/*

 *  Soft-attach the controller.

	/*

	 *  Get some info about the firmware.

	/*

	 *  Save setting of some IO registers, so we will 

	 *  be able to probe specific implementations.

	/*

	 *  Reset the chip now, since it has been reported 

	 *  that SCSI clock calibration may not work properly 

	 *  if the chip is currently active.

	/*

	 *  Prepare controller and devices settings, according 

	 *  to chip features, user set-up and driver set-up.

	/*

	 *  Check the PCI clock frequency.

	 *  Must be performed after prepare_setting since it destroys 

	 *  STEST1 that is used to probe for the clock doubler.

	/*

	 *  Allocate the start queue.

	/*

	 *  Allocate the done queue.

	/*

	 *  Allocate the target bus address array.

	/*

	 *  Allocate SCRIPTS areas.

	/*

	 *  Allocate the array of lists of CCBs hashed by DSA.

	/*

	 *  Initialyze the CCB free and busy queues.

	/*

	 *  Initialization for optional handling 

	 *  of device queueing.

	/*

	 *  Allocate some CCB. We need at least ONE.

	/*

	 *  Calculate BUS addresses where we are going 

	 *  to load the SCRIPTS.

 May get useful for 64 BIT PCI addressing */

	/*

	 *  Copy scripts to controller instance.

	/*

	 *  Setup variable parts in scripts and compute

	 *  scripts bus addresses used from the C code.

	/*

	 *  Bind SCRIPTS with physical addresses usable by the 

	 *  SCRIPTS processor (as seen from the BUS = BUS addresses).

	/*

	 *    If user wants IARB to be set when we win arbitration 

	 *    and have other jobs, compute the max number of consecutive 

	 *    settings of IARB hints before we leave devices a chance to 

	 *    arbitrate for reselection.

	/*

	 *  Prepare the idle and invalid task actions.

	/*

	 *  Allocate and prepare the lun JUMP table that is used 

	 *  for a target prior the probing of devices (bad lun table).

	 *  A private table will be allocated for the target on the 

	 *  first INQUIRY response received.

	/*

	 *  Prepare the bus address array that contains the bus 

	 *  address of each target control block.

	 *  For now, assume all logical units are wrong. :)

	/*

	 *  Now check the cache handling of the pci chipset.

	/*

	 *  Sigh! we are done.

/*

 *  Free everything that has been allocated for this device.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family 

 * of PCI-SCSI IO processors.

 *

 * Copyright (C) 1999-2001  Gerard Roudier <groudier@free.fr>

 * Copyright (c) 2003-2005  Matthew Wilcox <matthew@wil.cx>

 *

 * This driver is derived from the Linux sym53c8xx driver.

 * Copyright (C) 1998-2000  Gerard Roudier

 *

 * The sym53c8xx driver is derived from the ncr53c8xx driver that had been 

 * a port of the FreeBSD ncr driver to Linux-1.2.13.

 *

 * The original ncr driver has been written for 386bsd and FreeBSD by

 *         Wolfgang Stanglmeier        <wolf@cologne.de>

 *         Stefan Esser                <se@mi.Uni-Koeln.de>

 * Copyright (C) 1994  Wolfgang Stanglmeier

 *

 * Other major contributions:

 *

 * NVRAM detection and reading.

 * Copyright (C) 1997 Richard Waltham <dormouse@farsrobt.demon.co.uk>

 *

 *-----------------------------------------------------------------------------

/*

 *  Driver private area in the SCSI command structure.

 Override the SCSI pointer structure */

 SCSI error handling */

/*

 *  Complete a pending CAM CCB.

/*

 *  Tell the SCSI layer about a BUS RESET.

/*

 *  Choose the more appropriate CAM status if 

 *  the IO encountered an extended error.

/*

 *  Build CAM result for a failed or auto-sensed IO.

			/*

			 *  Bounce back the sense data to user.

			/*

			 *  If the device reports a UNIT ATTENTION condition 

			 *  due to a RESET condition, we should consider all 

			 *  disconnect CCBs for this unit as aborted.

			/*

			 * Error return from our internal request sense.  This

			 * is bad: we must clear the contingent allegiance

			 * condition otherwise the device will always return

			 * BUSY.  Use a big stick.

 Bad SCSI status */

 Selection timeout */

 Unexpected BUS FREE*/

 Extended error */

		/*

		 *  Set the most appropriate value for CAM status.

/*

 *  Queue a SCSI command.

	/*

	 *  Retrieve the target descriptor.

	/*

	 *  Select tagged/untagged.

	/*

	 *  Queue the SCSI IO.

 Means resource shortage */

/*

 *  Setup buffers and pointers that address the CDB.

/*

 *  Setup pointers that address the data and start the I/O.

	/*

	 *  Build the CDB.

	/*

	 *  No direction means no data.

		/*

		 *  No segments means no data.

	/*

	 *  Set the data pointer.

	/*

	 *  Set all pointers values needed by SCRIPTS.

	/*

	 *  When `#ifed 1', the code below makes the driver 

	 *  panic on the first attempt to write to a SCSI device.

	 *  It is the first test we want to do after a driver 

	 *  change that does not seem obviously safe. :)

	/*

	 *	activate this job.

/*

 *  timer daemon.

 *

 *  Misused to keep the driver running when

 *  interrupts are not configured correctly.

	/*

	 *  Restart the timer.

	/*

	 *  If we are resetting the ncr, wait for settle_time before 

	 *  clearing it. Then command processing will be resumed.

	/*

	 *	Nothing to do for now, but that may come.

	/*

	 *  Some way-broken PCI bridges may lead to 

	 *  completions being lost when the clearing 

	 *  of the INTFLY flag by the CPU occurs 

	 *  concurrently with the chip raising this flag.

	 *  If this ever happen, lost completions will 

	 * be reaped here.

/*

 *  PCI BUS error handler.

/*

 * queuecommand method.  Entered with the host adapter lock held and

 * interrupts disabled.

	/*

	 *  Shorten our settle_time if needed for 

	 *  this command not to time out.

/*

 *  Linux entry point of the interrupt handler.

 Avoid spinloop trying to handle interrupts on frozen device */

/*

 *  Linux entry point of the timer handler

/*

 *  What the eh thread wants us to perform.

/*

 *  Generic method for our eh processing.

 *  The 'op' argument tells what we have to do.

	/* We may be in an error condition because the PCI bus

	 * went down. In this case, we need to wait until the

	 * PCI bus is reset, the card is reset, and only then

	 * proceed with the scsi error recovery.  There's no

	 * point in hurrying; take a leisurely wait.

 Make sure we didn't race */

 This one is queued in some place -> to wait for completion */

 Try to proceed the operation we have been asked for */

 On error, restore everything and cross fingers :) */

/*

 * Error handlers called from the eh thread (one thread per HBA).

/*

 *  Tune device queuing depth, according to various limits.

	/*

	 * Fail the device init if the device is flagged NOSCAN at BOOT in

	 * the NVRAM.  This may speed up boot and maintain coherency with

	 * BIOS device numbering.  Clearing the flag allows the user to

	 * rescan skipped devices later.  We also return an error for

	 * devices not flagged for SCAN LUNS in the NVRAM since some single

	 * lun devices behave badly when asked for a non zero LUN.

/*

 * Linux entry point for device queue sizing.

	/*

	 *  Get user flags.

	/*

	 *  Select queue depth from driver setup.

	 *  Do not use more than configured by user.

	 *  Use at least 1.

	 *  Do not use more than our maximum.

 if slave_alloc returned before allocating a sym_lcb, return */

		/*

		 * This really shouldn't happen, but we can't return an error

		 * so let's try to stop all on-going I/O.

		/*

		 * It was the last unit for this target.

/*

 *  Linux entry point for info() function

/*

 *  Proc file system stuff

 *

 *  A read operation returns adapter information.

 *  A write operation is a control command.

 *  The string is parsed in the driver code and the command is passed 

 *  to the sym_usercmd() function.

		/*

		 * We assume that other commands apply to targets.

		 * This should always be the case and avoid the below 

		 * 4 lines to be repeated 6 times.

/*

 * Parse a control command

 SYM_LINUX_DEBUG_CONTROL_SUPPORT */

 SYM_LINUX_USER_COMMAND_SUPPORT */

/*

 *  Copy formatted information into the input buffer.

 SYM_LINUX_USER_INFO_SUPPORT */

 SYM_LINUX_PROC_INFO_SUPPORT */

/*

 * Free resources claimed by sym_iomap_device().  Note that

 * sym_free_resources() should be used instead of this function after calling

 * sym_attach().

/*

 *	Free controller resources.

	/*

	 *  Free O/S specific resources.

	/*

	 *  Free O/S independent resources.

/*

 *  Host attach and initialisations.

 *

 *  Allocate host data and ncb structure.

 *  Remap MMIO region.

 *  Do chip initialization.

 *  If all is OK, install interrupt handling and

 *  start the timer daemon.

	/*

	 *  Get the firmware for this chip.

	/*

	 *  Allocate immediately the host control block, 

	 *  since we are only expecting to succeed. :)

	 *  We keep track in the HCB of all the resources that 

	 *  are to be released on error.

 Result in 1 DMA pool per HBA */

	/*

	 *  Copy some useful infos to the HCB.

	/*

	 *  Edit its name.

	/*

	 *  Install the interrupt handler.

	 *  If we synchonize the C code with SCRIPTS on interrupt, 

	 *  we do not want to share the INTR line at all.

	/*

	 *  After SCSI devices have been opened, we cannot

	 *  reset the bus safely, so we do it here.

	/*

	 *  Start the SCRIPTS.

	/*

	 *  Start the timer daemon

	/*

	 *  Fill Linux host instance structure

	 *  and return success.

 53c896 rev 1 errata: DMA may not cross 16MB boundary */

/*

 *    Detect and try to read SYMBIOS and TEKRAM NVRAM.

 SYM_CONF_NVRAM_SUPPORT */

	/*

	 *  If user excluded this chip, do not initialize it.

	 *  I hate this code so much.  Must kill it.

	/*

	 * Check if the chip is supported.  Then copy the chip description

	 * to our device structure so we can make it match the actual device

	 * and options.

/*

 * Ignore Symbios chips controlled by various RAID controllers.

 * These controllers set value 0x52414944 at RAM end - 16.

	/*

	 *  (ITEM 12 of a DEL about the 896 I haven't yet).

	 *  We must ensure the chip will use WRITE AND INVALIDATE.

	 *  The revision number limit is for now arbitrary.

 If the chip can do Memory Write Invalidate, enable it */

	/*

	 *  Work around for errant bit in 895A. The 66Mhz

	 *  capable bit is set erroneously. Clear this bit.

	 *  (Item 1 DEL 533)

	 *

	 *  Make sure Config space and Features agree.

	 *

	 *  Recall: writes are not normal to status register -

	 *  write a 1 to clear and a 0 to leave unchanged.

	 *  Can only reset bits.

/*

 * Map HBA registers and on-chip SRAM (if present).

		/*

		 * If the BAR is 64-bit, resource 2 will be occupied by the

		 * upper 32 bits

/*

 * The NCR PQS and PDS cards are constructed as a DEC bridge

 * behind which sits a proprietary NCR memory controller and

 * either four or two 53c875s as separate devices.  We can tell

 * if an 875 is part of a PQS/PDS or not since if it is, it will

 * be on the same bus as the memory controller.  In its usual

 * mode of operation, the 875s are slaved to the memory

 * controller for all transfers.  To operate with the Linux

 * driver, the memory controller is disabled and the 875s

 * freed to function independently.  The only wrinkle is that

 * the preset SCSI ID (which may be zero) must be read in from

 * a special configuration space register of the 875.

 bit 1: allow individual 875 configuration */

 bit 2: drive individual 875 interrupts to the bus */

/*

 *  Called before unloading the module.

 *  Detach the host.

 *  We have to free resources and halt the NCR chip.

	/*

	 * Reset NCR chip.

	 * We should use sym_soft_reset(), but we don't want to do 

	 * so, since we may not be safe if interrupts occur.

/*

 * Driver host template.

 Don't disable the device */

 Don't sym_iounmap_device() after sym_attach(). */

/**

 * sym2_io_error_detected() - called when PCI error is detected

 * @pdev: pointer to PCI device

 * @state: current state of the PCI slot

 If slot is permanently frozen, turn everything off */

 Request that MMIO be enabled, so register dump can be taken. */

/**

 * sym2_io_slot_dump - Enable MMIO and dump debug registers

 * @pdev: pointer to PCI device

 Request a slot reset. */

/**

 * sym2_reset_workarounds - hardware-specific work-arounds

 * @pdev: pointer to PCI device

 *

 * This routine is similar to sym_set_workarounds(), except

 * that, at this point, we already know that the device was

 * successfully initialized at least once before, and so most

 * of the steps taken there are un-needed here.

	/* Work around for errant bit in 895A, in a fashion

	 * similar to what is done in sym_set_workarounds().

/**

 * sym2_io_slot_reset() - called when the pci bus has been reset.

 * @pdev: pointer to PCI device

 *

 * Restart the card from scratch.

 If the chip can do Memory Write Invalidate, enable it */

 Perform work-arounds, analogous to sym_set_workarounds() */

 Perform host reset only on one instance of the card */

/**

 * sym2_io_resume() - resume normal ops after PCI reset

 * @pdev: pointer to PCI device

 *

 * Called when the error recovery driver tells us that its

 * OK to resume normal operation. Use completion to allow

 * halted scsi ops to resume.

	/* have to have DT for these transfers, but DT will also

	/* It is illegal to have DT set on narrow transfers.  If DT is

 We must clear QAS and IU if DT is clear */

 new */

 new */

 new */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family 

 * of PCI-SCSI IO processors.

 *

 * Copyright (C) 1999-2001  Gerard Roudier <groudier@free.fr>

 *

 * This driver is derived from the Linux sym53c8xx driver.

 * Copyright (C) 1998-2000  Gerard Roudier

 *

 * The sym53c8xx driver is derived from the ncr53c8xx driver that had been 

 * a port of the FreeBSD ncr driver to Linux-1.2.13.

 *

 * The original ncr driver has been written for 386bsd and FreeBSD by

 *         Wolfgang Stanglmeier        <wolf@cologne.de>

 *         Stefan Esser                <se@mi.Uni-Koeln.de>

 * Copyright (C) 1994  Wolfgang Stanglmeier

 *

 * Other major contributions:

 *

 * NVRAM detection and reading.

 * Copyright (C) 1997 Richard Waltham <dormouse@farsrobt.demon.co.uk>

 *

 *-----------------------------------------------------------------------------

/*

 *  Macros used for all firmwares.

/*

 *  Allocate firmware #1 script area.

 SYM_CONF_GENERIC_SUPPORT */

/*

 *  Allocate firmware #2 script area.

/*

 *  Patch routine for firmware #1.

	/*

	 *  Remove LED support if not needed.

	/*

	 *    If user does not want to use IMMEDIATE ARBITRATION

	 *    when we are reselected while attempting to arbitrate,

	 *    patch the SCRIPTS accordingly with a SCRIPT NO_OP.

	/*

	 *  Patch some data in SCRIPTS.

	 *  - start and done queue initial bus address.

	 *  - target bus address table bus address.

 SYM_CONF_GENERIC_SUPPORT */

/*

 *  Patch routine for firmware #2.

	/*

	 *  Remove LED support if not needed.

	/*

	 *  Remove useless 64 bit DMA specific SCRIPTS, 

	 *  when this feature is not available.

	/*

	 *    If user does not want to use IMMEDIATE ARBITRATION

	 *    when we are reselected while attempting to arbitrate,

	 *    patch the SCRIPTS accordingly with a SCRIPT NO_OP.

	/*

	 *  Patch some variable in SCRIPTS.

	 *  - start and done queue initial bus address.

	 *  - target bus address table bus address.

	/*

	 *  Remove the load of SCNTL4 on reselection if not a C10.

	/*

	 *  Remove a couple of work-arounds specific to C1010 if 

	 *  they are not desirable. See `sym_fw2.h' for more details.

	if (!(pdev->device == PCI_DEVICE_ID_LSI_53C1010_33 /* &&

	/*

	 *  Patch some other variables in SCRIPTS.

	 *  These ones are loaded by the SCRIPTS processor.

/*

 *  Fill the data area in scripts.

 *  To be done for all firmwares.

/*

 *  Setup useful script bus addresses.

 *  To be done for all firmwares.

	/*

	 *  Build the bus address table for script A 

	 *  from the script A offset table.

	/*

	 *  Same for script B.

	/*

	 *  Same for script Z.

/*

 *  Setup routine for firmware #1.

	/*

	 *  Fill variable parts in scripts.

	/*

	 *  Setup bus addresses used from the C code..

 SYM_CONF_GENERIC_SUPPORT */

/*

 *  Setup routine for firmware #2.

	/*

	 *  Fill variable parts in scripts.

	/*

	 *  Setup bus addresses used from the C code..

/*

 *  Allocate firmware descriptors.

 SYM_CONF_GENERIC_SUPPORT */

/*

 *  Find the most appropriate firmware for a chip.

/*

 *  Bind a script to physical addresses.

		/*

		 *  If we forget to change the length

		 *  in scripts, a field will be

		 *  padded with 0. This is an illegal

		 *  command.

		/*

		 *  We use the bogus value 0xf00ff00f ;-)

		 *  to reserve data area in SCRIPTS.

		/*

		 *  We don't have to decode ALL commands

			/*

			 *  LOAD / STORE DSA relative, don't relocate.

			/*

			 *  LOAD / STORE absolute.

			/*

			 *  COPY has TWO arguments.

			/*

			 *  If PREFETCH feature not enabled, remove 

			 *  the NO FLUSH bit if present.

			/*

			 *  MOVE/CHMOV (absolute address)

			/*

			 *  MOVE/CHMOV (table indirect)

			/*

			 *  MOVE/CHMOV in target role (absolute address)

			/*

			 *  MOVE/CHMOV in target role (table indirect)

			/*

			 *  JUMP / CALL

			 *  don't relocate if relative :-)

JUMP64*/

		/*

		 *  Scriptify:) the opcode.

		/*

		 *  If no relocation, assume 1 argument 

		 *  and just scriptize:) it.

		/*

		 *  Otherwise performs all needed relocations.

				/*

				 *  Don't relocate a 0 address.

				 *  They are mostly used for patched or 

				 *  script self-modified areas.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family 

 * of PCI-SCSI IO processors.

 *

 * Copyright (C) 1999-2001  Gerard Roudier <groudier@free.fr>

 *

 * This driver is derived from the Linux sym53c8xx driver.

 * Copyright (C) 1998-2000  Gerard Roudier

 *

 * The sym53c8xx driver is derived from the ncr53c8xx driver that had been 

 * a port of the FreeBSD ncr driver to Linux-1.2.13.

 *

 * The original ncr driver has been written for 386bsd and FreeBSD by

 *         Wolfgang Stanglmeier        <wolf@cologne.de>

 *         Stefan Esser                <se@mi.Uni-Koeln.de>

 * Copyright (C) 1994  Wolfgang Stanglmeier

 *

 * Other major contributions:

 *

 * NVRAM detection and reading.

 * Copyright (C) 1997 Richard Waltham <dormouse@farsrobt.demon.co.uk>

 *

 *-----------------------------------------------------------------------------

/*

 *  Get host setup from NVRAM.

	/*

	 *  Get parity checking, host ID, verbose mode 

	 *  and miscellaneous host flags from NVRAM.

/*

 *  Get target set-up from Symbios format NVRAM.

/*

 *  Get target set-up from Tekram format NVRAM.

/*

 *  Get target setup from NVRAM.

/*

 *  Dump Symbios format NVRAM for debugging purpose.

 display Symbios nvram host data */

 display Symbios nvram drive data */

/*

 *  Dump TEKRAM format NVRAM for debugging purpose.

 display Tekram nvram host data */

 display Tekram nvram drive data */

 SYM_CONF_DEBUG_NVRAM */

/*

 *  24C16 EEPROM reading.

 *

 *  GPIO0 - data in/data out

 *  GPIO1 - clock

 *  Symbios NVRAM wiring now also used by Tekram.

/*

 *  Set/clear data/clock bit in GPIO0

/*

 *  Send START condition to NVRAM to wake it up.

/*

 *  Send STOP condition to NVRAM - puts NVRAM to sleep... ZZzzzz!!

/*

 *  Read or write a bit to the NVRAM,

 *  read if GPIO0 input else write if GPIO0 output

/*

 *  Output an ACK to the NVRAM after reading,

 *  change GPIO0 to output and when done back to an input

/*

 *  Input an ACK from NVRAM after writing,

 *  change GPIO0 to input and when done back to an output

/*

 *  WRITE a byte to the NVRAM and then get an ACK to see it was accepted OK,

 *  GPIO0 must already be set as an output

/*

 *  READ a byte from the NVRAM and then send an ACK to say we have got it,

 *  GPIO0 must already be set as an input

/*

 *  Write 'len' bytes starting at 'offset'.

 save current state of GPCNTL and GPREG */

 set up GPREG & GPCNTL to set GPIO0 and GPIO1 in to known state */

 this is to set NVRAM into a known state with GPIO0/1 both low */

 now set NVRAM inactive with GPIO0/1 both high */

 NVRAM has to be written in segments of 16 bytes */

 return GPIO0/1 to original states after having accessed NVRAM */

 SYM_CONF_NVRAM_WRITE_SUPPORT */

/*

 *  Read 'len' bytes starting at 'offset'.

 save current state of GPCNTL and GPREG */

 set up GPREG & GPCNTL to set GPIO0 and GPIO1 in to known state */

 this is to set NVRAM into a known state with GPIO0/1 both low */

 now set NVRAM inactive with GPIO0/1 both high */

 activate NVRAM */

 write device code and random address MSB */

 write random address LSB */

 regenerate START state to set up for reading */

 rewrite device code and address MSB with read bit set (lsb = 0x01) */

 now set up GPIO0 for inputting data */

 input all requested data - only part of total NVRAM */

 finally put NVRAM back in inactive mode */

 return GPIO0/1 to original states after having accessed NVRAM */

/*

 *  Try reading Symbios NVRAM.

 *  Return 0 if OK.

 probe the 24c16 and read the SYMBIOS 24c16 area */

 check valid NVRAM signature, verify byte count and checksum */

 verify checksum */

/*

 *  93C46 EEPROM reading.

 *

 *  GPIO0 - data in

 *  GPIO1 - data out

 *  GPIO2 - clock

 *  GPIO4 - chip select

 *

 *  Used by Tekram.

/*

 *  Pulse clock bit in GPIO0

/* 

 *  Read bit from NVRAM

/*

 *  Write bit to GPIO0

/*

 *  Send STOP condition to NVRAM - puts NVRAM to sleep... ZZZzzz!!

/*

 *  Send read command and address to NVRAM

 send 9 bits, start bit (1), command (2), address (6)  */

/*

 *  READ 2 bytes from the NVRAM

/*

 *  Read Tekram NvRAM data.

 output read command and address */

 Bad */

/*

 *  Try reading 93C46 Tekram NVRAM.

 save current state of GPCNTL and GPREG */

	/* set up GPREG & GPCNTL to set GPIO0/1/2/4 in to known state, 0 in,

 input all of NVRAM, 64 words */

 return GPIO0/1/2/4 to original states after having accessed NVRAM */

/*

 *  Try reading Tekram NVRAM.

 *  Return 0 if OK.

 verify checksum */

/*

 * Host firmware (PDC) keeps a table for altering SCSI capabilities.

 * Many newer machines export one channel of 53c896 chip as SE, 50-pin HD.

 * Also used for Multi-initiator SCSI clusters to set the SCSI Initiator ID.

/*

 *  Try reading Symbios or Tekram NVRAM

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Broadcom MPI3 Storage Controllers

 *

 * Copyright (C) 2017-2021 Broadcom Inc.

 *  (mailto: mpi3mr-linuxdrv.pdl@broadcom.com)

 *

/**

 * mpi3mr_get_reply_desc - get reply descriptor frame corresponding to

 *	queue's consumer index from operational reply descriptor queue.

 * @op_reply_q: op_reply_qinfo object

 * @reply_ci: operational reply descriptor's queue consumer index

 *

 * Returns reply descriptor frame address

		/*

		 * Exit completion loop to avoid CPU lockup

		 * Ensure remaining completion happens from threaded ISR.

 Call primary ISR routine */

	/*

	 * If more IOs are expected, schedule IRQ polling thread.

	 * Otherwise exit from ISR.

/**

 * mpi3mr_isr_poll - Reply queue polling routine

 * @irq: IRQ

 * @privdata: Interrupt info

 *

 * poll for pending I/O completions in a loop until pending I/Os

 * present or controller queue depth I/Os are processed.

 *

 * Return: IRQ_NONE or IRQ_HANDLED

 Poll for pending IOs completions */

/**

 * mpi3mr_request_irq - Request IRQ and register ISR

 * @mrioc: Adapter instance reference

 * @index: IRQ vector index

 *

 * Request threaded ISR with primary ISR and secondary

 *

 * Return: 0 on success and non zero on failures.

/**

 * mpi3mr_setup_isr - Setup ISR for the controller

 * @mrioc: Adapter instance reference

 * @setup_one: Request one IRQ or more

 *

 * Allocate IRQ vectors and call mpi3mr_request_irq to setup ISR

 *

 * Return: 0 on success and non zero on failures.

		/*

		 * If only one MSI-x is allocated, then MSI-x 0 will be shared

		 * between Admin queue and operational queue

 Reset reason to name mapper structure*/

/**

 * mpi3mr_reset_rc_name - get reset reason code name

 * @reason_code: reset reason code value

 *

 * Map reset reason to an NULL terminated ASCII string

 *

 * Return: name corresponding to reset reason value or NULL.

 Reset type to name mapper structure*/

/**

 * mpi3mr_reset_type_name - get reset type name

 * @reset_type: reset type value

 *

 * Map reset type to an NULL terminated ASCII string

 *

 * Return: name corresponding to reset type value or NULL.

/**

 * mpi3mr_print_fault_info - Display fault information

 * @mrioc: Adapter instance reference

 *

 * Display the controller fault information if there is a

 * controller fault.

 *

 * Return: Nothing.

/**

 * mpi3mr_get_iocstate - Get IOC State

 * @mrioc: Adapter instance reference

 *

 * Return a proper IOC state enum based on the IOC status and

 * IOC configuration and unrcoverable state of the controller.

 *

 * Return: Current IOC state.

/**

 * mpi3mr_clear_reset_history - clear reset history

 * @mrioc: Adapter instance reference

 *

 * Write the reset history bit in IOC status to clear the bit,

 * if it is already set.

 *

 * Return: Nothing.

/**

 * mpi3mr_issue_and_process_mur - Message unit Reset handler

 * @mrioc: Adapter instance reference

 * @reset_reason: Reset reason code

 *

 * Issue Message unit Reset to the controller and wait for it to

 * be complete.

 *

 * Return: 0 on success, -1 on failure.

/**

 * mpi3mr_bring_ioc_ready - Bring controller to ready state

 * @mrioc: Adapter instance reference

 *

 * Set Enable IOC bit in IOC configuration register and wait for

 * the controller to become ready.

 *

 * Return: 0 on success, -1 on failure.

/**

 * mpi3mr_soft_reset_success - Check softreset is success or not

 * @ioc_status: IOC status register value

 * @ioc_config: IOC config register value

 *

 * Check whether the soft reset is successful or not based on

 * IOC status and IOC config register values.

 *

 * Return: True when the soft reset is success, false otherwise.

/**

 * mpi3mr_diagfault_success - Check diag fault is success or not

 * @mrioc: Adapter reference

 * @ioc_status: IOC status register value

 *

 * Check whether the controller hit diag reset fault code.

 *

 * Return: True when there is diag fault, false otherwise.

/**

 * mpi3mr_set_diagsave - Set diag save bit for snapdump

 * @mrioc: Adapter reference

 *

 * Set diag save bit in IOC configuration register to enable

 * snapdump.

 *

 * Return: Nothing.

/**

 * mpi3mr_issue_reset - Issue reset to the controller

 * @mrioc: Adapter reference

 * @reset_type: Reset type

 * @reset_reason: Reset reason code

 *

 * Unlock the host diagnostic registers and write the specific

 * reset type to that, wait for reset acknowledgment from the

 * controller, if the reset is not successful retry for the

 * predefined number of times.

 *

 * Return: 0 on success, non-zero on failure.

/**

 * mpi3mr_admin_request_post - Post request to admin queue

 * @mrioc: Adapter reference

 * @admin_req: MPI3 request

 * @admin_req_sz: Request size

 * @ignore_reset: Ignore reset in process

 *

 * Post the MPI3 request into admin request queue and

 * inform the controller, if the queue is full return

 * appropriate error.

 *

 * Return: 0 on success, non-zero on failure.

/**

 * mpi3mr_free_op_req_q_segments - free request memory segments

 * @mrioc: Adapter instance reference

 * @q_idx: operational request queue index

 *

 * Free memory segments allocated for operational request queue

 *

 * Return: Nothing.

/**

 * mpi3mr_free_op_reply_q_segments - free reply memory segments

 * @mrioc: Adapter instance reference

 * @q_idx: operational reply queue index

 *

 * Free memory segments allocated for operational reply queue

 *

 * Return: Nothing.

/**

 * mpi3mr_delete_op_reply_q - delete operational reply queue

 * @mrioc: Adapter instance reference

 * @qidx: operational reply queue index

 *

 * Delete operatinal reply queue by issuing MPI request

 * through admin queue.

 *

 * Return:  0 on success, non-zero on failure.

/**

 * mpi3mr_alloc_op_reply_q_segments -Alloc segmented reply pool

 * @mrioc: Adapter instance reference

 * @qidx: request queue index

 *

 * Allocate segmented memory pools for operational reply

 * queue.

 *

 * Return: 0 on success, non-zero on failure.

/**

 * mpi3mr_alloc_op_req_q_segments - Alloc segmented req pool.

 * @mrioc: Adapter instance reference

 * @qidx: request queue index

 *

 * Allocate segmented memory pools for operational request

 * queue.

 *

 * Return: 0 on success, non-zero on failure.

/**

 * mpi3mr_create_op_reply_q - create operational reply queue

 * @mrioc: Adapter instance reference

 * @qidx: operational reply queue index

 *

 * Create operatinal reply queue by issuing MPI request

 * through admin queue.

 *

 * Return:  0 on success, non-zero on failure.

/**

 * mpi3mr_create_op_req_q - create operational request queue

 * @mrioc: Adapter instance reference

 * @idx: operational request queue index

 * @reply_qid: Reply queue ID

 *

 * Create operatinal request queue by issuing MPI request

 * through admin queue.

 *

 * Return:  0 on success, non-zero on failure.

/**

 * mpi3mr_create_op_queues - create operational queue pairs

 * @mrioc: Adapter instance reference

 *

 * Allocate memory for operational queue meta data and call

 * create request and reply queue functions.

 *

 * Return: 0 on success, non-zero on failures.

 Not even one queue is created successfully*/

/**

 * mpi3mr_op_request_post - Post request to operational queue

 * @mrioc: Adapter reference

 * @op_req_q: Operational request queue info

 * @req: MPI3 request

 *

 * Post the MPI3 request into operational request queue and

 * inform the controller, if the queue is full return

 * appropriate error.

 *

 * Return: 0 on success, non-zero on failure.

/**

 * mpi3mr_sync_timestamp - Issue time stamp sync request

 * @mrioc: Adapter reference

 *

 * Issue IO unit control MPI request to synchornize firmware

 * timestamp with host time.

 *

 * Return: 0 on success, non-zero on failure.

/**

 * mpi3mr_watchdog_work - watchdog thread to monitor faults

 * @work: work struct

 *

 * Watch dog work periodically executed (1 second interval) to

 * monitor firmware fault and to issue periodic timer sync to

 * the firmware.

 *

 * Return: Nothing.

Check for fault state every one second and issue Soft reset*/

/**

 * mpi3mr_start_watchdog - Start watchdog

 * @mrioc: Adapter instance reference

 *

 * Create and start the watchdog thread to monitor controller

 * faults.

 *

 * Return: Nothing.

/**

 * mpi3mr_stop_watchdog - Stop watchdog

 * @mrioc: Adapter instance reference

 *

 * Stop the watchdog thread created to monitor controller

 * faults.

 *

 * Return: Nothing.

/**

 * mpi3mr_kill_ioc - Kill the controller

 * @mrioc: Adapter instance reference

 * @reason: reason for the failure.

 *

 * If fault debug is enabled, display the fault info else issue

 * diag fault and freeze the system for controller debug

 * purpose.

 *

 * Return: Nothing.

/**

 * mpi3mr_setup_admin_qpair - Setup admin queue pair

 * @mrioc: Adapter instance reference

 *

 * Allocate memory for admin queue pair if required and register

 * the admin queue with the controller.

 *

 * Return: 0 on success, non-zero on failures.

/**

 * mpi3mr_issue_iocfacts - Send IOC Facts

 * @mrioc: Adapter instance reference

 * @facts_data: Cached IOC facts data

 *

 * Issue IOC Facts MPI request through admin queue and wait for

 * the completion of it or time out.

 *

 * Return: 0 on success, non-zero on failures.

/**

 * mpi3mr_check_reset_dma_mask - Process IOC facts data

 * @mrioc: Adapter instance reference

 *

 * Check whether the new DMA mask requested through IOCFacts by

 * firmware needs to be set, if so set it .

 *

 * Return: 0 on success, non-zero on failure.

/**

 * mpi3mr_process_factsdata - Process IOC facts data

 * @mrioc: Adapter instance reference

 * @facts_data: Cached IOC facts data

 *

 * Convert IOC facts data into cpu endianness and cache it in

 * the driver .

 *

 * Return: Nothing.

/**

 * mpi3mr_alloc_reply_sense_bufs - Send IOC Init

 * @mrioc: Adapter instance reference

 *

 * Allocate and initialize the reply free buffers, sense

 * buffers, reply free queue and sense buffer queue.

 *

 * Return: 0 on success, non-zero on failures.

 reply buffer pool, 16 byte align */

 reply free queue, 8 byte align */

 sense buffer pool,  4 byte align */

 sense buffer queue, 8 byte align */

 initialize Reply buffer Queue */

 initialize Sense Buffer Queue */

/**

 * mpi3mr_issue_iocinit - Send IOC Init

 * @mrioc: Adapter instance reference

 *

 * Issue IOC Init MPI request through admin queue and wait for

 * the completion of it or time out.

 *

 * Return: 0 on success, non-zero on failures.

/**

 * mpi3mr_unmask_events - Unmask events in event mask bitmap

 * @mrioc: Adapter instance reference

 * @event: MPI event ID

 *

 * Un mask the specific event by resetting the event_mask

 * bitmap.

 *

 * Return: 0 on success, non-zero on failures.

/**

 * mpi3mr_issue_event_notification - Send event notification

 * @mrioc: Adapter instance reference

 *

 * Issue event notification MPI request through admin queue and

 * wait for the completion of it or time out.

 *

 * Return: 0 on success, non-zero on failures.

/**

 * mpi3mr_send_event_ack - Send event acknowledgment

 * @mrioc: Adapter instance reference

 * @event: MPI3 event ID

 * @event_ctx: Event context

 *

 * Send event acknowledgment through admin queue and wait for

 * it to complete.

 *

 * Return: 0 on success, non-zero on failures.

/**

 * mpi3mr_alloc_chain_bufs - Allocate chain buffers

 * @mrioc: Adapter instance reference

 *

 * Allocate chain buffers and set a bitmap to indicate free

 * chain buffers. Chain buffers are used to pass the SGE

 * information along with MPI3 SCSI IO requests for host I/O.

 *

 * Return: 0 on success, non-zero on failure

/**

 * mpi3mr_port_enable_complete - Mark port enable complete

 * @mrioc: Adapter instance reference

 * @drv_cmd: Internal command tracker

 *

 * Call back for asynchronous port enable request sets the

 * driver command to indicate port enable request is complete.

 *

 * Return: Nothing

/**

 * mpi3mr_issue_port_enable - Issue Port Enable

 * @mrioc: Adapter instance reference

 * @async: Flag to wait for completion or not

 *

 * Issue Port Enable MPI request through admin queue and if the

 * async flag is not set wait for the completion of the port

 * enable or time out.

 *

 * Return: 0 on success, non-zero on failures.

 Protocol type to name mapper structure*/

 Capability to name mapper structure*/

/**

 * mpi3mr_print_ioc_info - Display controller information

 * @mrioc: Adapter instance reference

 *

 * Display controller personalit, capability, supported

 * protocols etc.

 *

 * Return: Nothing

/**

 * mpi3mr_cleanup_resources - Free PCI resources

 * @mrioc: Adapter instance reference

 *

 * Unmap PCI device memory and disable PCI device.

 *

 * Return: 0 on success and non-zero on failure.

/**

 * mpi3mr_setup_resources - Enable PCI resources

 * @mrioc: Adapter instance reference

 *

 * Enable PCI device memory, MSI-x registers and set DMA mask.

 *

 * Return: 0 on success and non-zero on failure.

/**

 * mpi3mr_init_ioc - Initialize the controller

 * @mrioc: Adapter instance reference

 * @init_type: Flag to indicate is the init_type

 *

 * This the controller initialization routine, executed either

 * after soft reset or from pci probe callback.

 * Setup the required resources, memory map the controller

 * registers, create admin and operational reply queue pairs,

 * allocate required memory for reply pool, sense buffer pool,

 * issue IOC init request to the firmware, unmask the events and

 * issue port enable to discover SAS/SATA/NVMe devies and RAID

 * volumes.

 *

 * Return: 0 on success and non-zero on failure.

The timeout value is in 2sec unit, changing it to seconds*/

/**

 * mpi3mr_memset_op_reply_q_buffers - memset the operational reply queue's

 *					segments

 * @mrioc: Adapter instance reference

 * @qidx: Operational reply queue index

 *

 * Return: Nothing.

/**

 * mpi3mr_memset_op_req_q_buffers - memset the operational request queue's

 *					segments

 * @mrioc: Adapter instance reference

 * @qidx: Operational request queue index

 *

 * Return: Nothing.

/**

 * mpi3mr_memset_buffers - memset memory for a controller

 * @mrioc: Adapter instance reference

 *

 * clear all the memory allocated for a controller, typically

 * called post reset to reuse the memory allocated during the

 * controller init.

 *

 * Return: Nothing.

/**

 * mpi3mr_free_mem - Free memory allocated for a controller

 * @mrioc: Adapter instance reference

 *

 * Free all the memory allocated for a controller.

 *

 * Return: Nothing.

/**

 * mpi3mr_issue_ioc_shutdown - shutdown controller

 * @mrioc: Adapter instance reference

 *

 * Send shutodwn notification to the controller and wait for the

 * shutdown_timeout for it to be completed.

 *

 * Return: Nothing.

/**

 * mpi3mr_cleanup_ioc - Cleanup controller

 * @mrioc: Adapter instance reference

 * @reason: Cleanup reason

 *

 * controller cleanup handler, Message unit reset or soft reset

 * and shutdown notification is issued to the controller and the

 * associated memory resources are freed.

 *

 * Return: Nothing.

/**

 * mpi3mr_drv_cmd_comp_reset - Flush a internal driver command

 * @mrioc: Adapter instance reference

 * @cmdptr: Internal command tracker

 *

 * Complete an internal driver commands with state indicating it

 * is completed due to reset.

 *

 * Return: Nothing.

/**

 * mpi3mr_flush_drv_cmds - Flush internaldriver commands

 * @mrioc: Adapter instance reference

 *

 * Flush all internal driver commands post reset

 *

 * Return: Nothing.

/**

 * mpi3mr_diagfault_reset_handler - Diag fault reset handler

 * @mrioc: Adapter instance reference

 * @reset_reason: Reset reason code

 *

 * This is an handler for issuing diag fault reset from the

 * applications through IOCTL path to stop the execution of the

 * controller

 *

 * Return: 0 on success, non-zero on failure.

/**

 * mpi3mr_soft_reset_handler - Reset the controller

 * @mrioc: Adapter instance reference

 * @reset_reason: Reset reason code

 * @snapdump: Flag to generate snapdump in firmware or not

 *

 * This is an handler for recovering controller by issuing soft

 * reset are diag fault reset.  This is a blocking function and

 * when one reset is executed if any other resets they will be

 * blocked. All IOCTLs/IO will be blocked during the reset. If

 * controller reset is successful then the controller will be

 * reinitalized, otherwise the controller will be marked as not

 * recoverable

 *

 * In snapdump bit is set, the controller is issued with diag

 * fault reset so that the firmware can create a snap dump and

 * post that the firmware will result in F000 fault and the

 * driver will issue soft reset to recover from that.

 *

 * Return: 0 on success, non-zero on failure.

	/*

	 * Block new resets until the currently executing one is finished and

	 * return the status of the existing reset for all blocked resets

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Broadcom MPI3 Storage Controllers

 *

 * Copyright (C) 2017-2021 Broadcom Inc.

 *  (mailto: mpi3mr-linuxdrv.pdl@broadcom.com)

 *

 global driver scop variables */

 Module parameters*/

 Forward declarations*/

/**

 * mpi3mr_host_tag_for_scmd - Get host tag for a scmd

 * @mrioc: Adapter instance reference

 * @scmd: SCSI command reference

 *

 * Calculate the host tag based on block tag for a given scmd.

 *

 * Return: Valid host tag or MPI3MR_HOSTTAG_INVALID.

host_tag 0 is invalid hence incrementing by 1*/

/**

 * mpi3mr_scmd_from_host_tag - Get SCSI command from host tag

 * @mrioc: Adapter instance reference

 * @host_tag: Host tag

 * @qidx: Operational queue index

 *

 * Identify the block tag from the host tag and queue index and

 * retrieve associated scsi command using scsi_host_find_tag().

 *

 * Return: SCSI command reference or NULL.

/**

 * mpi3mr_clear_scmd_priv - Cleanup SCSI command private date

 * @mrioc: Adapter instance reference

 * @scmd: SCSI command reference

 *

 * Invalidate the SCSI command private data to mark the command

 * is not in LLD scope anymore.

 *

 * Return: Nothing.

/**

 * mpi3mr_fwevt_free - firmware event memory dealloctor

 * @r: k reference pointer of the firmware event

 *

 * Free firmware event memory when no reference.

/**

 * mpi3mr_fwevt_get - k reference incrementor

 * @fwevt: Firmware event reference

 *

 * Increment firmware event reference count.

/**

 * mpi3mr_fwevt_put - k reference decrementor

 * @fwevt: Firmware event reference

 *

 * decrement firmware event reference count.

/**

 * mpi3mr_alloc_fwevt - Allocate firmware event

 * @len: length of firmware event data to allocate

 *

 * Allocate firmware event with required length and initialize

 * the reference counter.

 *

 * Return: firmware event reference.

/**

 * mpi3mr_fwevt_add_to_list - Add firmware event to the list

 * @mrioc: Adapter instance reference

 * @fwevt: Firmware event reference

 *

 * Add the given firmware event to the firmware event list.

 *

 * Return: Nothing.

 get fwevt reference count while adding it to fwevt_list */

 get fwevt reference count while enqueueing it to worker queue */

/**

 * mpi3mr_fwevt_del_from_list - Delete firmware event from list

 * @mrioc: Adapter instance reference

 * @fwevt: Firmware event reference

 *

 * Delete the given firmware event from the firmware event list.

 *

 * Return: Nothing.

		/*

		 * Put fwevt reference count after

		 * removing it from fwevt_list

/**

 * mpi3mr_dequeue_fwevt - Dequeue firmware event from the list

 * @mrioc: Adapter instance reference

 *

 * Dequeue a firmware event from the firmware event list.

 *

 * Return: firmware event.

		/*

		 * Put fwevt reference count after

		 * removing it from fwevt_list

/**

 * mpi3mr_cleanup_fwevt_list - Cleanup firmware event list

 * @mrioc: Adapter instance reference

 *

 * Flush all pending firmware events from the firmware event

 * list.

 *

 * Return: Nothing.

		/*

		 * Wait on the fwevt to complete. If this returns 1, then

		 * the event was never executed, and we need a put for the

		 * reference the work had on the fwevt.

		 *

		 * If it did execute, we wait for it to finish, and the put will

		 * happen from mpi3mr_process_fwevt()

			/*

			 * Put fwevt reference count after

			 * dequeuing it from worker queue

			/*

			 * Put fwevt reference count to neutralize

			 * kref_init increment

/**

 * mpi3mr_invalidate_devhandles -Invalidate device handles

 * @mrioc: Adapter instance reference

 *

 * Invalidate the device handles in the target device structures

 * . Called post reset prior to reinitializing the controller.

 *

 * Return: Nothing.

/**

 * mpi3mr_print_scmd - print individual SCSI command

 * @rq: Block request

 * @data: Adapter instance reference

 * @reserved: N/A. Currently not used

 *

 * Print the SCSI command details if it is in LLD scope.

 *

 * Return: true always.

/**

 * mpi3mr_flush_scmd - Flush individual SCSI command

 * @rq: Block request

 * @data: Adapter instance reference

 * @reserved: N/A. Currently not used

 *

 * Return the SCSI command to the upper layers if it is in LLD

 * scope.

 *

 * Return: true always.

/**

 * mpi3mr_flush_host_io -  Flush host I/Os

 * @mrioc: Adapter instance reference

 *

 * Flush all of the pending I/Os by calling

 * blk_mq_tagset_busy_iter() for each possible tag. This is

 * executed post controller reset

 *

 * Return: Nothing.

/**

 * mpi3mr_alloc_tgtdev - target device allocator

 *

 * Allocate target device instance and initialize the reference

 * count

 *

 * Return: target device instance.

/**

 * mpi3mr_tgtdev_add_to_list -Add tgtdevice to the list

 * @mrioc: Adapter instance reference

 * @tgtdev: Target device

 *

 * Add the target device to the target device list

 *

 * Return: Nothing.

/**

 * mpi3mr_tgtdev_del_from_list -Delete tgtdevice from the list

 * @mrioc: Adapter instance reference

 * @tgtdev: Target device

 *

 * Remove the target device from the target device list

 *

 * Return: Nothing.

/**

 * __mpi3mr_get_tgtdev_by_handle -Get tgtdev from device handle

 * @mrioc: Adapter instance reference

 * @handle: Device handle

 *

 * Accessor to retrieve target device from the device handle.

 * Non Lock version

 *

 * Return: Target device reference.

/**

 * mpi3mr_get_tgtdev_by_handle -Get tgtdev from device handle

 * @mrioc: Adapter instance reference

 * @handle: Device handle

 *

 * Accessor to retrieve target device from the device handle.

 * Lock version

 *

 * Return: Target device reference.

/**

 * __mpi3mr_get_tgtdev_by_perst_id -Get tgtdev from persist ID

 * @mrioc: Adapter instance reference

 * @persist_id: Persistent ID

 *

 * Accessor to retrieve target device from the Persistent ID.

 * Non Lock version

 *

 * Return: Target device reference.

/**

 * mpi3mr_get_tgtdev_by_perst_id -Get tgtdev from persistent ID

 * @mrioc: Adapter instance reference

 * @persist_id: Persistent ID

 *

 * Accessor to retrieve target device from the Persistent ID.

 * Lock version

 *

 * Return: Target device reference.

/**

 * __mpi3mr_get_tgtdev_from_tgtpriv -Get tgtdev from tgt private

 * @mrioc: Adapter instance reference

 * @tgt_priv: Target private data

 *

 * Accessor to return target device from the target private

 * data. Non Lock version

 *

 * Return: Target device reference.

/**

 * mpi3mr_remove_tgtdev_from_host - Remove dev from upper layers

 * @mrioc: Adapter instance reference

 * @tgtdev: Target device structure

 *

 * Checks whether the device is exposed to upper layers and if it

 * is then remove the device from upper layers by calling

 * scsi_remove_target().

 *

 * Return: 0 on success, non zero on failure.

/**

 * mpi3mr_report_tgtdev_to_host - Expose device to upper layers

 * @mrioc: Adapter instance reference

 * @perst_id: Persistent ID of the device

 *

 * Checks whether the device can be exposed to upper layers and

 * if it is not then expose the device to upper layers by

 * calling scsi_scan_target().

 *

 * Return: 0 on success, non zero on failure.

/**

 * mpi3mr_change_queue_depth- Change QD callback handler

 * @sdev: SCSI device reference

 * @q_depth: Queue depth

 *

 * Validate and limit QD and call scsi_change_queue_depth.

 *

 * Return: return value of scsi_change_queue_depth

/**

 * mpi3mr_update_sdev - Update SCSI device information

 * @sdev: SCSI device reference

 * @data: target device reference

 *

 * This is an iterator function called for each SCSI device in a

 * target to update the target specific information into each

 * SCSI device.

 *

 * Return: Nothing.

The block layer hw sector size = 512*/

/**

 * mpi3mr_rfresh_tgtdevs - Refresh target device exposure

 * @mrioc: Adapter instance reference

 *

 * This is executed post controller reset to identify any

 * missing devices during reset and remove from the upper layers

 * or expose any newly detected device to the upper layers.

 *

 * Return: Nothing.

/**

 * mpi3mr_update_tgtdev - DevStatusChange evt bottomhalf

 * @mrioc: Adapter instance reference

 * @tgtdev: Target device internal structure

 * @dev_pg0: New device page0

 *

 * Update the information from the device page0 into the driver

 * cached target device structure.

 *

 * Return: Nothing.

 2^12 = 4096 */

/**

 * mpi3mr_devstatuschg_evt_bh - DevStatusChange evt bottomhalf

 * @mrioc: Adapter instance reference

 * @fwevt: Firmware event information.

 *

 * Process Device status Change event and based on device's new

 * information, either expose the device to the upper layers, or

 * remove the device from upper layers.

 *

 * Return: Nothing.

/**

 * mpi3mr_devinfochg_evt_bh - DeviceInfoChange evt bottomhalf

 * @mrioc: Adapter instance reference

 * @dev_pg0: New device page0

 *

 * Process Device Info Change event and based on device's new

 * information, either expose the device to the upper layers, or

 * remove the device from upper layers or update the details of

 * the device.

 *

 * Return: Nothing.

/**

 * mpi3mr_sastopochg_evt_debug - SASTopoChange details

 * @mrioc: Adapter instance reference

 * @event_data: SAS topology change list event data

 *

 * Prints information about the SAS topology change event.

 *

 * Return: Nothing.

/**

 * mpi3mr_sastopochg_evt_bh - SASTopologyChange evt bottomhalf

 * @mrioc: Adapter instance reference

 * @fwevt: Firmware event reference

 *

 * Prints information about the SAS topology change event and

 * for "not responding" event code, removes the device from the

 * upper layers.

 *

 * Return: Nothing.

/**

 * mpi3mr_pcietopochg_evt_debug - PCIeTopoChange details

 * @mrioc: Adapter instance reference

 * @event_data: PCIe topology change list event data

 *

 * Prints information about the PCIe topology change event.

 *

 * Return: Nothing.

/**

 * mpi3mr_pcietopochg_evt_bh - PCIeTopologyChange evt bottomhalf

 * @mrioc: Adapter instance reference

 * @fwevt: Firmware event reference

 *

 * Prints information about the PCIe topology change event and

 * for "not responding" event code, removes the device from the

 * upper layers.

 *

 * Return: Nothing.

/**

 * mpi3mr_fwevt_bh - Firmware event bottomhalf handler

 * @mrioc: Adapter instance reference

 * @fwevt: Firmware event reference

 *

 * Identifies the firmware event and calls corresponding bottomg

 * half handler and sends event acknowledgment if required.

 *

 * Return: Nothing.

 Put fwevt reference count to neutralize kref_init increment */

/**

 * mpi3mr_fwevt_worker - Firmware event worker

 * @work: Work struct containing firmware event

 *

 * Extracts the firmware event and calls mpi3mr_fwevt_bh.

 *

 * Return: Nothing.

	/*

	 * Put fwevt reference count after

	 * dequeuing it from worker queue

/**

 * mpi3mr_create_tgtdev - Create and add a target device

 * @mrioc: Adapter instance reference

 * @dev_pg0: Device Page 0 data

 *

 * If the device specified by the device page 0 data is not

 * present in the driver's internal list, allocate the memory

 * for the device, populate the data and add to the list, else

 * update the device data.  The key is persistent ID.

 *

 * Return: 0 on success, -ENOMEM on memory allocation failure

/**

 * mpi3mr_flush_delayed_rmhs_list - Flush pending commands

 * @mrioc: Adapter instance reference

 *

 * Flush pending commands in the delayed removal handshake list

 * due to a controller reset or driver removal as a cleanup.

 *

 * Return: Nothing

/**

 * mpi3mr_dev_rmhs_complete_iou - Device removal IOUC completion

 * @mrioc: Adapter instance reference

 * @drv_cmd: Internal command tracker

 *

 * Issues a target reset TM to the firmware from the device

 * removal TM pend list or retry the removal handshake sequence

 * based on the IOU control request IOC status.

 *

 * Return: Nothing

/**

 * mpi3mr_dev_rmhs_complete_tm - Device removal TM completion

 * @mrioc: Adapter instance reference

 * @drv_cmd: Internal command tracker

 *

 * Issues a target reset TM to the firmware from the device

 * removal TM pend list or issue IO unit control request as

 * part of device removal or hidden acknowledgment handshake.

 *

 * Return: Nothing

/**

 * mpi3mr_dev_rmhs_send_tm - Issue TM for device removal

 * @mrioc: Adapter instance reference

 * @handle: Device handle

 * @cmdparam: Internal command tracker

 * @iou_rc: IO unit reason code

 *

 * Issues a target reset TM to the firmware or add it to a pend

 * list as part of device removal or hidden acknowledgment

 * handshake.

 *

 * Return: Nothing

/**

 * mpi3mr_pcietopochg_evt_th - PCIETopologyChange evt tophalf

 * @mrioc: Adapter instance reference

 * @event_reply: event data

 *

 * Checks for the reason code and based on that either block I/O

 * to device, or unblock I/O to the device, or start the device

 * removal handshake with reason as remove with the firmware for

 * PCIe devices.

 *

 * Return: Nothing

/**

 * mpi3mr_sastopochg_evt_th - SASTopologyChange evt tophalf

 * @mrioc: Adapter instance reference

 * @event_reply: event data

 *

 * Checks for the reason code and based on that either block I/O

 * to device, or unblock I/O to the device, or start the device

 * removal handshake with reason as remove with the firmware for

 * SAS/SATA devices.

 *

 * Return: Nothing

/**

 * mpi3mr_devstatuschg_evt_th - DeviceStatusChange evt tophalf

 * @mrioc: Adapter instance reference

 * @event_reply: event data

 *

 * Checks for the reason code and based on that either block I/O

 * to device, or unblock I/O to the device, or start the device

 * removal handshake with reason as remove/hide acknowledgment

 * with the firmware.

 *

 * Return: Nothing

/**

 * mpi3mr_energypackchg_evt_th - Energy pack change evt tophalf

 * @mrioc: Adapter instance reference

 * @event_reply: event data

 *

 * Identifies the new shutdown timeout value and update.

 *

 * Return: Nothing

/**

 * mpi3mr_os_handle_events - Firmware event handler

 * @mrioc: Adapter instance reference

 * @event_reply: event data

 *

 * Identify whteher the event has to handled and acknowledged

 * and either process the event in the tophalf and/or schedule a

 * bottom half through mpi3mr_fwevt_worker.

 *

 * Return: Nothing

/**

 * mpi3mr_setup_eedp - Setup EEDP information in MPI3 SCSI IO

 * @mrioc: Adapter instance reference

 * @scmd: SCSI command reference

 * @scsiio_req: MPI3 SCSI IO request

 *

 * Identifies the protection information flags from the SCSI

 * command and set appropriate flags in the MPI3 SCSI IO

 * request.

 *

 * Return: Nothing

/**

 * mpi3mr_build_sense_buffer - Map sense information

 * @desc: Sense type

 * @buf: Sense buffer to populate

 * @key: Sense key

 * @asc: Additional sense code

 * @ascq: Additional sense code qualifier

 *

 * Maps the given sense information into either descriptor or

 * fixed format sense data.

 *

 * Return: Nothing

 descriptor, current */

 fixed, current */

/**

 * mpi3mr_map_eedp_error - Map EEDP errors from IOC status

 * @scmd: SCSI command reference

 * @ioc_status: status of MPI3 request

 *

 * Maps the EEDP error status of the SCSI IO request to sense

 * data.

 *

 * Return: Nothing

/**

 * mpi3mr_process_op_reply_desc - reply descriptor handler

 * @mrioc: Adapter instance reference

 * @reply_desc: Operational reply descriptor

 * @reply_dma: place holder for reply DMA address

 * @qidx: Operational queue index

 *

 * Process the operational reply descriptor and identifies the

 * descriptor type. Based on the descriptor map the MPI3 request

 * status to a SCSI command status and calls scsi_done call

 * back.

 *

 * Return: Nothing

/**

 * mpi3mr_get_chain_idx - get free chain buffer index

 * @mrioc: Adapter instance reference

 *

 * Try to get a free chain buffer index from the free pool.

 *

 * Return: -1 on failure or the free chain buffer index

/**

 * mpi3mr_prepare_sg_scmd - build scatter gather list

 * @mrioc: Adapter instance reference

 * @scmd: SCSI command reference

 * @scsiio_req: MPI3 SCSI IO request

 *

 * This function maps SCSI command's data and protection SGEs to

 * MPI request SGEs. If required additional 4K chain buffer is

 * used to send the SGEs.

 *

 * Return: 0 on success, -ENOMEM on dma_map_sg failure

 To unmap meta sg DMA */

 Reserve 1st segment (scsiio_req->sgl[0]) for eedp */

 Reserve last segment (scsiio_req->sgl[3]) for meta sg */

 fill in main message segment when there is a chain following */

/**

 * mpi3mr_build_sg_scmd - build scatter gather list for SCSI IO

 * @mrioc: Adapter instance reference

 * @scmd: SCSI command reference

 * @scsiio_req: MPI3 SCSI IO request

 *

 * This function calls mpi3mr_prepare_sg_scmd for constructing

 * both data SGEs and protection information SGEs in the MPI

 * format from the SCSI Command as appropriate .

 *

 * Return: return value of mpi3mr_prepare_sg_scmd.

 There is a valid meta sg */

/**

 * mpi3mr_print_response_code - print TM response as a string

 * @mrioc: Adapter instance reference

 * @resp_code: TM response code

 *

 * Print TM response code as a readable string.

 *

 * Return: Nothing.

/**

 * mpi3mr_issue_tm - Issue Task Management request

 * @mrioc: Adapter instance reference

 * @tm_type: Task Management type

 * @handle: Device handle

 * @lun: lun ID

 * @htag: Host tag of the TM request

 * @drv_cmd: Internal command tracker

 * @resp_code: Response code place holder

 * @cmd_priv: SCSI command private data

 *

 * Issues a Task Management Request to the controller for a

 * specified target, lun and command and wait for its completion

 * and check TM response. Recover the TM if it timed out by

 * issuing controller reset.

 *

 * Return: 0 on success, non-zero on errors

		/*

		 * Flush all IRQ handlers by calling synchronize_irq().

		 * mpi3mr_ioc_disable_intr() takes care of it.

/**

 * mpi3mr_bios_param - BIOS param callback

 * @sdev: SCSI device reference

 * @bdev: Block device reference

 * @capacity: Capacity in logical sectors

 * @params: Parameter array

 *

 * Just the parameters with heads/secots/cylinders.

 *

 * Return: 0 always

/**

 * mpi3mr_map_queues - Map queues callback handler

 * @shost: SCSI host reference

 *

 * Call the blk_mq_pci_map_queues with from which operational

 * queue the mapping has to be done

 *

 * Return: return of blk_mq_pci_map_queues

/**

 * mpi3mr_get_fw_pending_ios - Calculate pending I/O count

 * @mrioc: Adapter instance reference

 *

 * Calculate the pending I/Os for the controller and return.

 *

 * Return: Number of pending I/Os

/**

 * mpi3mr_print_pending_host_io - print pending I/Os

 * @mrioc: Adapter instance reference

 *

 * Print number of pending I/Os and each I/O details prior to

 * reset for debug purpose.

 *

 * Return: Nothing

/**

 * mpi3mr_wait_for_host_io - block for I/Os to complete

 * @mrioc: Adapter instance reference

 * @timeout: time out in seconds

 * Waits for pending I/Os for the given adapter to complete or

 * to hit the timeout.

 *

 * Return: Nothing

/**

 * mpi3mr_eh_host_reset - Host reset error handling callback

 * @scmd: SCSI command reference

 *

 * Issue controller reset if the scmd is for a Physical Device,

 * if the scmd is for RAID volume, then wait for

 * MPI3MR_RAID_ERRREC_RESET_TIMEOUT and checke whether any

 * pending I/Os prior to issuing reset to the controller.

 *

 * Return: SUCCESS of successful reset else FAILED

/**

 * mpi3mr_eh_target_reset - Target reset error handling callback

 * @scmd: SCSI command reference

 *

 * Issue Target reset Task Management and verify the scmd is

 * terminated successfully and return status accordingly.

 *

 * Return: SUCCESS of successful termination of the scmd else

 *         FAILED

/**

 * mpi3mr_eh_dev_reset- Device reset error handling callback

 * @scmd: SCSI command reference

 *

 * Issue lun reset Task Management and verify the scmd is

 * terminated successfully and return status accordingly.

 *

 * Return: SUCCESS of successful termination of the scmd else

 *         FAILED

/**

 * mpi3mr_scan_start - Scan start callback handler

 * @shost: SCSI host reference

 *

 * Issue port enable request asynchronously.

 *

 * Return: Nothing

/**

 * mpi3mr_scan_finished - Scan finished callback handler

 * @shost: SCSI host reference

 * @time: Jiffies from the scan start

 *

 * Checks whether the port enable is completed or timedout or

 * failed and set the scan status accordingly after taking any

 * recovery if required.

 *

 * Return: 1 on scan finished or timed out, 0 for in progress

/**

 * mpi3mr_slave_destroy - Slave destroy callback handler

 * @sdev: SCSI device reference

 *

 * Cleanup and free per device(lun) private data.

 *

 * Return: Nothing.

/**

 * mpi3mr_target_destroy - Target destroy callback handler

 * @starget: SCSI target reference

 *

 * Cleanup and free per target private data.

 *

 * Return: Nothing.

/**

 * mpi3mr_slave_configure - Slave configure callback handler

 * @sdev: SCSI device reference

 *

 * Configure queue depth, max hardware sectors and virt boundary

 * as required

 *

 * Return: 0 always.

The block layer hw sector size = 512*/

/**

 * mpi3mr_slave_alloc -Slave alloc callback handler

 * @sdev: SCSI device reference

 *

 * Allocate per device(lun) private data and initialize it.

 *

 * Return: 0 on success -ENOMEM on memory allocation failure.

/**

 * mpi3mr_target_alloc - Target alloc callback handler

 * @starget: SCSI target reference

 *

 * Allocate per target private data and initialize it.

 *

 * Return: 0 on success -ENOMEM on memory allocation failure.

/**

 * mpi3mr_check_return_unmap - Whether an unmap is allowed

 * @mrioc: Adapter instance reference

 * @scmd: SCSI Command reference

 *

 * The controller hardware cannot handle certain unmap commands

 * for NVMe drives, this routine checks those and return true

 * and completes the SCSI command with proper status and sense

 * data.

 *

 * Return: TRUE for not  allowed unmap, FALSE otherwise.

/**

 * mpi3mr_allow_scmd_to_fw - Command is allowed during shutdown

 * @scmd: SCSI Command reference

 *

 * Checks whether a cdb is allowed during shutdown or not.

 *

 * Return: TRUE for allowed commands, FALSE otherwise.

/**

 * mpi3mr_qcmd - I/O request despatcher

 * @shost: SCSI Host reference

 * @scmd: SCSI Command reference

 *

 * Issues the SCSI Command as an MPI3 request.

 *

 * Return: 0 on successful queueing of the request or if the

 *         request is completed with failure.

 *         SCSI_MLQUEUE_DEVICE_BUSY when the device is busy.

 *         SCSI_MLQUEUE_HOST_BUSY when the host queue is full.

	/* max xfer supported is 1M (2K in 512 byte sized sectors)

/**

 * mpi3mr_init_drv_cmd - Initialize internal command tracker

 * @cmdptr: Internal command tracker

 * @host_tag: Host tag used for the specific command

 *

 * Initialize the internal command tracker structure with

 * specified host tag.

 *

 * Return: Nothing.

/**

 * osintfc_mrioc_security_status -Check controller secure status

 * @pdev: PCI device instance

 *

 * Read the Device Serial Number capability from PCI config

 * space and decide whether the controller is secure or not.

 *

 * Return: 0 on success, non-zero on failure.

/**

 * mpi3mr_probe - PCI probe callback

 * @pdev: PCI device instance

 * @id: PCI device ID details

 *

 * controller initialization routine. Checks the security status

 * of the controller and if it is invalid or tampered return the

 * probe without initializing the controller. Otherwise,

 * allocate per adapter instance through shost_priv and

 * initialize controller specific data structures, initializae

 * the controller hardware, add shost to the SCSI subsystem.

 *

 * Return: 0 on success, non-zero on failure.

 For Invalid and Tampered device */

 init shost parameters */

/**

 * mpi3mr_remove - PCI remove callback

 * @pdev: PCI device instance

 *

 * Free up all memory and resources associated with the

 * controllerand target devices, unregister the shost.

 *

 * Return: Nothing.

/**

 * mpi3mr_shutdown - PCI shutdown callback

 * @pdev: PCI device instance

 *

 * Free up all memory and resources associated with the

 * controller

 *

 * Return: Nothing.

/**

 * mpi3mr_suspend - PCI power management suspend callback

 * @pdev: PCI device instance

 * @state: New power state

 *

 * Change the power state to the given value and cleanup the IOC

 * by issuing MUR and shutdown notification

 *

 * Return: 0 always.

/**

 * mpi3mr_resume - PCI power management resume callback

 * @pdev: PCI device instance

 *

 * Restore the power state to D0 and reinitialize the controller

 * and resume I/O operations to the target devices

 *

 * Return: 0 on success, non-zero on failure

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Basic HP/COMPAQ MSA 1000 support. This is only needed if your HW cannot be

 * upgraded.

 *

 * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.

 * Copyright (C) 2006 Mike Christie

 * Copyright (C) 2008 Hannes Reinecke <hare@suse.de>

/*

 * tur_done - Handle TEST UNIT READY return status

 * @sdev: sdev the command has been sent to

 * @errors: blk error code

 *

 * Returns SCSI_DH_DEV_OFFLINED if the sdev is on the passive path

			/*

			 * LUN not ready - Initialization command required

			 *

			 * This is the passive path

/*

 * hp_sw_tur - Send TEST UNIT READY

 * @sdev: sdev command should be sent to

 *

 * Use the TEST UNIT READY command to determine

 * the path state.

/*

 * hp_sw_start_stop - Send START STOP UNIT command

 * @sdev: sdev command should be sent to

 *

 * Sending START STOP UNIT activates the SP.

				/*

				 * LUN not ready - manual intervention required

				 *

				 * Switch-over in progress, retry.

/*

 * hp_sw_activate - Activate a path

 * @sdev: sdev on the path to be activated

 *

 * The HP Active/Passive firmware is pretty simple;

 * the passive path reports NOT READY with sense codes

 * 0x04/0x02; a START STOP UNIT command will then

 * activate the passive path (and deactivate the

 * previously active one).

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Generic SCSI-3 ALUA SCSI Device Handler

 *

 * Copyright (C) 2007-2010 Hannes Reinecke, SUSE Linux Products GmbH.

 * All rights reserved.

 device handler flags */

 State machine flags */

 used for optimizing STPG */

/*

 * submit_rtpg - Issue a REPORT TARGET GROUP STATES command

 * @sdev: sdev the command should be sent to

 Prepare the command. */

/*

 * submit_stpg - Issue a SET TARGET PORT GROUP command

 *

 * Currently we're only setting the current target port group state

 * to 'active/optimized' and let the array firmware figure out

 * the states of the remaining groups.

 Prepare the data buffer */

 Prepare the command. */

/*

 * alua_alloc_pg - Allocate a new port_group structure

 * @sdev: scsi device

 * @group_id: port group id

 * @tpgs: target port group settings

 *

 * Allocate a new port_group structure for a given

 * device.

		/*

		 * TPGS supported but no device identification found.

		 * Generate private device identification.

/*

 * alua_check_tpgs - Evaluate TPGS setting

 * @sdev: device to be checked

 *

 * Examine the TPGS setting of the sdev to find out if ALUA

 * is supported.

	/*

	 * ALUA support for non-disk devices is fraught with

	 * difficulties, so disable it for now.

/*

 * alua_check_vpd - Evaluate INQUIRY vpd page 0x83

 * @sdev: device to be checked

 *

 * Extract the relative target port and the target port group

 * descriptor from the list of identificators.

		/*

		 * Internal error; TPGS supported but required

		 * VPD identification descriptors not present.

		 * Disable ALUA support

 Check for existing port group references */

 port group has changed. Update to new port group */

			/*

			 * LUN Not Accessible - ALUA state transition

			/*

			 * Power On, Reset, or Bus Device Reset.

			 * Might have obscured a state transition,

			 * so schedule a recheck.

			/*

			 * Device internal reset

			/*

			 * Mode Parameters Changed

			/*

			 * ALUA state changed

			/*

			 * Implicit ALUA state transition failed

			/*

			 * Inquiry data has changed

			/*

			 * REPORTED_LUNS_DATA_HAS_CHANGED is reported

			 * when switching controllers on targets like

			 * Intel Multi-Flex. We can just retry.

/*

 * alua_tur - Send a TEST UNIT READY

 * @sdev: device to which the TEST UNIT READY command should be send

 *

 * Send a TEST UNIT READY to @sdev to figure out the device state

 * Returns SCSI_DH_RETRY if the sense code is NOT READY/ALUA TRANSITIONING,

 * SCSI_DH_OK if no error occurred, and SCSI_DH_IO otherwise.

/*

 * alua_rtpg - Evaluate REPORT TARGET GROUP STATES

 * @sdev: the device to be evaluated.

 *

 * Evaluate the Target Port Group State.

 * Returns SCSI_DH_DEV_OFFLINED if the path is

 * found to be unusable.

		/*

		 * Some (broken) implementations have a habit of returning

		 * an error during things like firmware update etc.

		 * But if the target only supports active/optimized there's

		 * not much we can do; it's not that we can switch paths

		 * or anything.

		 * So ignore any errors to avoid spurious failures during

		 * path failover.

		/*

		 * submit_rtpg() has failed on existing arrays

		 * when requesting extended header info, and

		 * the array doesn't support extended headers,

		 * even though it shouldn't according to T10.

		 * The retry without rtpg_ext_hdr_req set

		 * handles this.

		 * Note:  some arrays return a sense key of ILLEGAL_REQUEST

		 * with ASC 00h if they don't support the extended header.

		/*

		 * If the array returns with 'ALUA state transition'

		 * sense code here it cannot return RTPG data during

		 * transition. So set the state to 'transitioning' directly.

		/*

		 * Retry on any other UNIT ATTENTION occurred.

 Resubmit with the correct length */

 Temporary failure, bypass */

 State transition, retry */

 Transitioning time exceeded, set port to standby */

 Path unusable */

 Useable path if active */

/*

 * alua_stpg - Issue a SET TARGET PORT GROUP command

 *

 * Issue a SET TARGET PORT GROUP command and evaluate the

 * response. Returns SCSI_DH_RETRY per default to trigger

 * a re-evaluation of the target group state or SCSI_DH_OK

 * if no further action needs to be taken.

 Only implicit ALUA supported, retry */

 Retry RTPG */

	/*

	 * RCU protection isn't necessary for dh_list here

	 * as we hold pg->lock, but for access to h->pg.

 Send RTPG on failure or if TUR indicates SUCCESS */

 If RTPG failed on the current device, try using another */

	/*

	 * We went through an RTPG, for good or bad.

	 * Re-enable all devices for the next attempt.

/**

 * alua_rtpg_queue() - cause RTPG to be submitted asynchronously

 * @pg: ALUA port group associated with @sdev.

 * @sdev: SCSI device for which to submit an RTPG.

 * @qdata: Information about the callback to invoke after the RTPG.

 * @force: Whether or not to submit an RTPG if a work item that will submit an

 *         RTPG already has been scheduled.

 *

 * Returns true if and only if alua_rtpg_work() will be called asynchronously.

 * That function is responsible for calling @qdata->fn().

 Do not queue if the worker is already running */

/*

 * alua_initialize - Initialize ALUA state

 * @sdev: the device to be initialized

 *

 * For the prep_fn to work correctly we have

 * to initialize the ALUA state for the device.

/*

 * alua_set_params - set/unset the optimize flag

 * @sdev: device on the path to be activated

 * params - parameters in the following format

 *      "no_of_params\0param1\0param2\0param3\0...\0"

 * For example, to set the flag pass the following parameters

 * from multipath.conf

 *     hardware_handler        "2 alua 1"

/*

 * alua_activate - activate a path

 * @sdev: device on the path to be activated

 *

 * We're currently switching the port group to be activated only and

 * let the array figure out the rest.

 * There may be other arrays which require us to switch all port groups

 * based on a certain policy. But until we actually encounter them it

 * should be okay.

/*

 * alua_check - check path status

 * @sdev: device on the path to be checked

 *

 * Check the device status

/*

 * alua_prep_fn - request callback

 *

 * Fail I/O to all paths not in state

 * active/optimized or active/non-optimized.

/*

 * alua_bus_attach - Attach device handler

 * @sdev: device to be attached to

/*

 * alua_bus_detach - Detach device handler

 * @sdev: device to be detached from

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Target driver for EMC CLARiiON AX/CX-series hardware.

 * Based on code from Lars Marowsky-Bree <lmb@suse.de>

 * and Ed Goggin <egoggin@emc.com>.

 *

 * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.

 * Copyright (C) 2006 Mike Christie

 Flags */

 LUN states */

 Page code */

 Page length - 2 */

 Trespass code */

 Trespass target */

 Reserved bytes / unknown */

 Page code */

 Page length - 2 */

 Trespass code */

 Trespass target */

	/*

	 * Flags:

	 *  CLARIION_SHORT_TRESPASS

	 * Use short trespass command (FC-series) or the long version

	 * (default for AX/CX CLARiiON arrays).

	 *

	 *  CLARIION_HONOR_RESERVATIONS

	 * Whether or not (default) to honor SCSI reservations when

	 * initiating a switch-over.

	/*

	 * I/O buffer for both MODE_SELECT and INQUIRY commands.

	/*

	 * LUN state

	/*

	 * SP Port number

	/*

	 * which SP (A=0,B=1,UNBOUND=-1) is the default SP for this

	 * path's mapped LUN

	/*

	 * which SP (A=0,B=1,UNBOUND=-1) is the active SP for this

	 * path's mapped LUN

/*

 * Parse MODE_SELECT cmd reply.

		/*

		 * Array based copy in progress -- do not send

		 * mode_select or copy will be aborted mid-stream.

		/*

		 * LUN Not Ready - Manual Intervention Required

		 * indicates in-progress ucode upgrade (NDU).

 check for in-progress ucode upgrade (NDU) */

 Invalid buffer format */

 Linux failover */

 Check for old FC arrays */

 Old FC array, not supporting extended information */

	/*

	 * Parse extended information for SP model number

 Strip whitespace at the end */

 Set Honor Reservations bit */

 Set Honor Reservations bit */

			/*

			 * LUN Not Ready - Manual Intervention Required

			 * indicates this is a passive path.

			 *

			 * FIXME: However, if this is seen and EVPD C0

			 * indicates that this is due to a NDU in

			 * progress, we should set FAIL_PATH too.

			 * This indicates we might have to do a SCSI

			 * inquiry in the end_io path. Ugh.

			 *

			 * Can return FAILED only when we want the error

			 * recovery process to kick in.

			/*

			 * An array based copy is in progress. Do not

			 * fail the path, do not bypass to another PG,

			 * do not retry. Fail the IO immediately.

			 * (Actually this is the same conclusion as in

			 * the default handler, but lets make sure.)

			 *

			 * Can return FAILED only when we want the error

			 * recovery process to kick in.

			/*

			 * Unit Attention Code. This is the first IO

			 * to the new path, so just retry.

	/*

	 * FC Series arrays do not support long trespass

 Update status */

/*

 * params - parameters in the following format

 *      "no_of_params\0param1\0param2\0param3\0...\0"

 *      for example, string for 2 parameters with value 10 and 21

 *      is specified as "2\010\021\0".

	/*

	 * If this path is owned, we have to send a trespass command

	 * with the new parameters. If not, simply return. Next trespass

	 * command would use the parameters.

 Update status */

/*

 * LSI/Engenio/NetApp E-Series RDAC SCSI Device Handler

 *

 * Copyright (C) 2005 Mike Christie. All rights reserved.

 * Copyright (C) Chandra Seetharaman, IBM Corp. 2007

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation; either version 2 of the License, or

 * (at your option) any later version.

 *

 * This program is distributed in the hope that it will be useful,

 * but WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

 *

 * You should have received a copy of the GNU General Public License

 * along with this program; if not, write to the Free Software

 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

 *

/*

 * LSI mode page stuff

 *

 * These struct definitions and the forming of the

 * mode page were taken from the LSI RDAC 2.4 GPL'd

 * driver, and then converted to Linux conventions.

/*

 * Page Codes

/*

 * Controller modes definitions

/*

 * RDAC Options field

 0xC9 */

 "vace" */

 0xC4 */

 "subs" */

 0xC8 */

 "edid" */

 list of all controllers */

 0xC2 */

 "swr4" */

 Total allocation length should be 0xFF */

/*

 * module parameter to enable rdac debug logging.

 * 2 bits for each type of logging, only two types defined for now

 * Can be enhanced if required at later point

 Prepare the command. */

 initialize fields of controller */

 Uses only the last byte */

 detect the operating mode */

 LUN in IOSHIP mode */

 LUN in AVT mode */

 LUN in RDAC mode */

 Update ownership */

 Update path prio*/

 h->sdev should always be valid */

 get the controller index */

		/*

		 * If more than MODE6_MAX_LUN luns are supported, use

		 * mode select 10

			/* LUN Not Ready and is in the Process of Becoming

			 * Ready

			/*

			 * Command Lock contention

			/* LUN Not Ready - Logical Unit Not Ready and is in

			* the process of becoming ready

			* Just retry.

			/* LUN Not Ready - Storage firmware incompatible

			 * Manual code synchonisation required.

			 *

			 * Nothing we can do here. Try to bypass the path.

			/* LUN Not Ready - Quiescense in progress

			 *

			 * Just retry and wait.

			/* LUN Not Ready - Quiescense in progress

			 * or has been achieved

			 * Just retry.

			/* Invalid Request - Current Logical Unit Ownership.

			 * Controller is not the current owner of the LUN,

			 * Fail the path, so that the other path be used.

			/*

			 * Power On, Reset, or Bus Device Reset, just retry.

			/*

			 * Quiescence in progress , just retry.

 success just means we do not care what scsi-ml does */

	/*

	 * Create workqueue to handle mode selects for rdac

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * CXL Flash Device Driver

 *

 * Written by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>, IBM Corporation

 *             Uma Krishnan <ukrishn@linux.vnet.ibm.com>, IBM Corporation

 *

 * Copyright (C) 2018 IBM Corporation

/*

 * The following routines map the cxlflash backend operations to existing CXL

 * kernel API function and are largely simple shims that provide an abstraction

 * for converting generic context and AFU cookies into cxl_context or cxl_afu

 * pointers.

 Dummy fop for cxl */

 Dummy fop for cxl */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * CXL Flash Device Driver

 *

 * Written by: Manoj N. Kumar <manoj@linux.vnet.ibm.com>, IBM Corporation

 *             Matthew R. Ochs <mrochs@linux.vnet.ibm.com>, IBM Corporation

 *

 * Copyright (C) 2015 IBM Corporation

/**

 * marshal_virt_to_resize() - translate uvirtual to resize structure

 * @virt:	Source structure from which to translate/copy.

 * @resize:	Destination structure for the translate/copy.

/**

 * marshal_clone_to_rele() - translate clone to release structure

 * @clone:	Source structure from which to translate/copy.

 * @release:	Destination structure for the translate/copy.

/**

 * ba_init() - initializes a block allocator

 * @ba_lun:	Block allocator to initialize.

 *

 * Return: 0 on success, -errno on failure

 Calculate bit map size */

 Allocate lun information container */

 Allocate bitmap space */

 Initialize the bit map size and set all bits to '1' */

 If the last word not fully utilized, mark extra bits as allocated */

 Initialize high elevator index, low/curr already at 0 from kzalloc */

 Allocate clone map */

 Pass the allocated LUN info as a handle to the user */

/**

 * find_free_range() - locates a free bit within the block allocator

 * @low:	First word in block allocator to start search.

 * @high:	Last word in block allocator to search.

 * @bali:	LUN information structure owning the block allocator to search.

 * @bit_word:	Passes back the word in the block allocator owning the free bit.

 *

 * Return: The bit position within the passed back word, -1 on failure

/**

 * ba_alloc() - allocates a block from the block allocator

 * @ba_lun:	Block allocator from which to allocate a block.

 *

 * Return: The allocated block, -1 on failure

 Search to find a free entry, curr->high then low->curr */

 Update the free_curr_idx */

/**

 * validate_alloc() - validates the specified block has been allocated

 * @bali:		LUN info owning the block allocator.

 * @aun:		Block to validate.

 *

 * Return: 0 on success, -1 on failure

/**

 * ba_free() - frees a block from the block allocator

 * @ba_lun:	Block allocator from which to allocate a block.

 * @to_free:	Block to free.

 *

 * Return: 0 on success, -1 on failure

/**

 * ba_clone() - Clone a chunk of the block allocation table

 * @ba_lun:	Block allocator from which to allocate a block.

 * @to_clone:	Block to clone.

 *

 * Return: 0 on success, -1 on failure

/**

 * ba_space() - returns the amount of free space left in the block allocator

 * @ba_lun:	Block allocator.

 *

 * Return: Amount of free space in block allocator

/**

 * cxlflash_ba_terminate() - frees resources associated with the block allocator

 * @ba_lun:	Block allocator.

 *

 * Safe to call in a partially allocated state.

/**

 * init_vlun() - initializes a LUN for virtual use

 * @lli:	LUN information structure that owns the block allocator.

 *

 * Return: 0 on success, -errno on failure

 LUN IDs are unique per port, save the index instead */

/**

 * write_same16() - sends a SCSI WRITE_SAME16 (0) command to specified LUN

 * @sdev:	SCSI device associated with LUN.

 * @lba:	Logical block address to start write same.

 * @nblks:	Number of logical blocks to write same.

 *

 * The SCSI WRITE_SAME16 can take quite a while to complete. Should an EEH occur

 * while in scsi_execute(), the EEH handler will attempt to recover. As part of

 * the recovery, the handler drains all currently running ioctls, waiting until

 * they have completed before proceeding with a reset. As this routine is used

 * on the ioctl path, this can create a condition where the EEH handler becomes

 * stuck, infinitely waiting for this ioctl thread. To avoid this behavior,

 * temporarily unmark this thread as an ioctl thread by releasing the ioctl read

 * semaphore. This will allow the EEH handler to proceed with a recovery while

 * this thread is still running. Once the scsi_execute() returns, reacquire the

 * ioctl read semaphore and check the adapter state in case it changed while

 * inside of scsi_execute(). The state check will wait if the adapter is still

 * being recovered or return a failure if the recovery failed. In the event that

 * the adapter reset failed, simply return the failure as the ioctl would be

 * unable to continue.

 *

 * Note that the above puts a requirement on this routine to only be called on

 * an ioctl thread.

 *

 * Return: 0 on success, -errno on failure

 Drop the ioctl read semahpore across lengthy call */

/**

 * grow_lxt() - expands the translation table associated with the specified RHTE

 * @afu:	AFU associated with the host.

 * @sdev:	SCSI device associated with LUN.

 * @ctxid:	Context ID of context owning the RHTE.

 * @rhndl:	Resource handle associated with the RHTE.

 * @rhte:	Resource handle entry (RHTE).

 * @new_size:	Number of translation entries associated with RHTE.

 *

 * By design, this routine employs a 'best attempt' allocation and will

 * truncate the requested size down if there is not sufficient space in

 * the block allocator to satisfy the request but there does exist some

 * amount of space. The user is made aware of this by returning the size

 * allocated.

 *

 * Return: 0 on success, -errno on failure

 chunk# allocated by block allocator */

	/*

	 * Check what is available in the block allocator before re-allocating

	 * LXT array. This is done up front under the mutex which must not be

	 * released until after allocation is complete.

 reallocate to fit new size */

 copy over all old entries */

 nothing can fail from now on */

 add new entries to the end */

		/*

		 * Due to the earlier check of available space, ba_alloc

		 * cannot fail here. If it did due to internal error,

		 * leave a rlba_base of -1u which will likely be a

		 * invalid LUN (too large).

 select both ports, use r/w perms from RHT */

	/*

	 * The following sequence is prescribed in the SISlite spec

	 * for syncing up with the AFU when adding LXT entries.

 Make LXT updates are visible */

 Make RHT entry's LXT table update visible */

 Make RHT entry's LXT table size update visible */

 free old lxt if reallocated */

/**

 * shrink_lxt() - reduces translation table associated with the specified RHTE

 * @afu:	AFU associated with the host.

 * @sdev:	SCSI device associated with LUN.

 * @rhndl:	Resource handle associated with the RHTE.

 * @rhte:	Resource handle entry (RHTE).

 * @ctxi:	Context owning resources.

 * @new_size:	Number of translation entries associated with RHTE.

 *

 * Return: 0 on success, -errno on failure

 chunk# allocated by block allocator */

 Reallocate to fit new size unless new size is 0 */

 Copy over old entries that will remain */

 Nothing can fail from now on */

	/*

	 * The following sequence is prescribed in the SISlite spec

	 * for syncing up with the AFU when removing LXT entries.

 Make RHT entry's LXT table size update visible */

 Make RHT entry's LXT table update visible */

		/*

		 * Mark the context as unavailable, so that we can release

		 * the mutex safely.

 Free LBAs allocated to freed chunks */

 Make the context visible again */

 Free old lxt if reallocated */

/**

 * _cxlflash_vlun_resize() - changes the size of a virtual LUN

 * @sdev:	SCSI device associated with LUN owning virtual LUN.

 * @ctxi:	Context owning resources.

 * @resize:	Resize ioctl data structure.

 *

 * On successful return, the user is informed of the new size (in blocks)

 * of the virtual LUN in last LBA format. When the size of the virtual

 * LUN is zero, the last LBA is reflected as -1. See comment in the

 * prologue for _cxlflash_disk_release() regarding AFU syncs and contexts

 * on the error recovery list.

 *

 * Return: 0 on success, -errno on failure

	/*

	 * The requested size (req_size) is always assumed to be in 4k blocks,

	 * so we have to convert it here from 4k to chunk size.

		/*

		 * Rare case where there is already sufficient space, just

		 * need to perform a translation sync with the AFU. This

		 * scenario likely follows a previous sync failure during

		 * a resize operation. Accordingly, perform the heavyweight

		 * form of translation sync as it is unknown which type of

		 * resize failed previously.

/**

 * cxlflash_restore_luntable() - Restore LUN table to prior state

 * @cfg:	Internal structure associated with the host.

/**

 * get_num_ports() - compute number of ports from port selection mask

 * @psm:	Port selection mask.

 *

 * Return: Population count of port selection mask

/**

 * init_luntable() - write an entry in the LUN table

 * @cfg:	Internal structure associated with the host.

 * @lli:	Per adapter LUN information structure.

 *

 * On successful return, a LUN table entry is created:

 *	- at the top for LUNs visible on multiple ports.

 *	- at the bottom for LUNs visible only on one port.

 *

 * Return: 0 on success, -errno on failure

		/*

		 * When LUN is visible from multiple ports, we will put

		 * it in the top half of the LUN table.

		/*

		 * When LUN is visible only from one port, we will put

		 * it in the bottom half of the LUN table.

/**

 * cxlflash_disk_virtual_open() - open a virtual disk of specified size

 * @sdev:	SCSI device associated with LUN owning virtual LUN.

 * @arg:	UVirtual ioctl data structure.

 *

 * On successful return, the user is informed of the resource handle

 * to be used to identify the virtual LUN and the size (in blocks) of

 * the virtual LUN in last LBA format. When the size of the virtual LUN

 * is zero, the last LBA is reflected as -1.

 *

 * Return: 0 on success, -errno on failure

 Setup the LUNs block allocator on first call */

 too many opens  */

 Populate RHT format 0 */

 Resize even if requested size is 0 */

 Special common cleanup prior to successful LUN attach */

/**

 * clone_lxt() - copies translation tables from source to destination RHTE

 * @afu:	AFU associated with the host.

 * @blka:	Block allocator associated with LUN.

 * @ctxid:	Context ID of context owning the RHTE.

 * @rhndl:	Resource handle associated with the RHTE.

 * @rhte:	Destination resource handle entry (RHTE).

 * @rhte_src:	Source resource handle entry (RHTE).

 *

 * Return: 0 on success, -errno on failure

 chunk# allocated by block allocator */

 allocate new LXTs for clone */

 copy over */

		/* clone the LBAs in block allocator via ref_cnt, note that the

		 * block allocator mutex must be held until it is established

		 * that this routine will complete without the need for a

		 * cleanup.

	/*

	 * The following sequence is prescribed in the SISlite spec

	 * for syncing up with the AFU when adding LXT entries.

 Make LXT updates are visible */

 Make RHT entry's LXT table update visible */

 Make RHT entry's LXT table size update visible */

 Reset the RHTE */

 free the clones already made */

/**

 * cxlflash_disk_clone() - clone a context by making snapshot of another

 * @sdev:	SCSI device associated with LUN owning virtual LUN.

 * @clone:	Clone ioctl data structure.

 *

 * This routine effectively performs cxlflash_disk_open operation for each

 * in-use virtual resource in the source context. Note that the destination

 * context must be in pristine state and cannot have any resource handles

 * open at the time of the clone.

 *

 * Return: 0 on success, -errno on failure

 Do not clone yourself */

 Verify there is no open resource handle in the destination context */

 Clone LUN access list */

 User specified permission on attach */

	/*

	 * Copy over checked-out RHT (and their associated LXT) entries by

	 * hand, stopping after we've copied all outstanding entries and

	 * cleaning up if the clone fails.

	 *

	 * Note: This loop is equivalent to performing cxlflash_disk_open and

	 * cxlflash_vlun_resize. As such, LUN accounting needs to be taken into

	 * account by attaching after each successful RHT entry clone. In the

	 * event that a clone failure is experienced, the LUN detach is handled

	 * via the cleanup performed by _cxlflash_disk_release.

 Consume a destination RHT entry */

 Put back the one we failed on */

 fall through */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * CXL Flash Device Driver

 *

 * Written by: Manoj N. Kumar <manoj@linux.vnet.ibm.com>, IBM Corporation

 *             Matthew R. Ochs <mrochs@linux.vnet.ibm.com>, IBM Corporation

 *

 * Copyright (C) 2015 IBM Corporation

/**

 * create_local() - allocate and initialize a local LUN information structure

 * @sdev:	SCSI device associated with LUN.

 * @wwid:	World Wide Node Name for LUN.

 *

 * Return: Allocated local llun_info structure on success, NULL on failure

/**

 * create_global() - allocate and initialize a global LUN information structure

 * @sdev:	SCSI device associated with LUN.

 * @wwid:	World Wide Node Name for LUN.

 *

 * Return: Allocated global glun_info structure on success, NULL on failure

/**

 * lookup_local() - find a local LUN information structure by WWID

 * @cfg:	Internal structure associated with the host.

 * @wwid:	WWID associated with LUN.

 *

 * Return: Found local lun_info structure on success, NULL on failure

/**

 * lookup_global() - find a global LUN information structure by WWID

 * @wwid:	WWID associated with LUN.

 *

 * Return: Found global lun_info structure on success, NULL on failure

/**

 * find_and_create_lun() - find or create a local LUN information structure

 * @sdev:	SCSI device associated with LUN.

 * @wwid:	WWID associated with LUN.

 *

 * The LUN is kept both in a local list (per adapter) and in a global list

 * (across all adapters). Certain attributes of the LUN are local to the

 * adapter (such as index, port selection mask, etc.).

 *

 * The block allocation map is shared across all adapters (i.e. associated

 * wih the global list). Since different attributes are associated with

 * the per adapter and global entries, allocate two separate structures for each

 * LUN (one local, one global).

 *

 * Keep a pointer back from the local to the global entry.

 *

 * This routine assumes the caller holds the global mutex.

 *

 * Return: Found/Allocated local lun_info structure on success, NULL on failure

/**

 * cxlflash_term_local_luns() - Delete all entries from local LUN list, free.

 * @cfg:	Internal structure associated with the host.

/**

 * cxlflash_list_init() - initializes the global LUN list

/**

 * cxlflash_term_global_luns() - frees resources associated with global LUN list

/**

 * cxlflash_manage_lun() - handles LUN management activities

 * @sdev:	SCSI device associated with LUN.

 * @manage:	Manage ioctl data structure.

 *

 * This routine is used to notify the driver about a LUN's WWID and associate

 * SCSI devices (sdev) with a global LUN instance. Additionally it serves to

 * change a LUN's operating mode: legacy or superpipe.

 *

 * Return: 0 on success, -errno on failure

		/*

		 * Update port selection mask based upon channel, store off LUN

		 * in unpacked, AFU-friendly format, and hang LUN reference in

		 * the sdev.

			/*

			 * Clean up local LUN for this port and reset table

			 * tracking when no more references exist.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * CXL Flash Device Driver

 *

 * Written by: Manoj N. Kumar <manoj@linux.vnet.ibm.com>, IBM Corporation

 *             Matthew R. Ochs <mrochs@linux.vnet.ibm.com>, IBM Corporation

 *

 * Copyright (C) 2015 IBM Corporation

/**

 * marshal_rele_to_resize() - translate release to resize structure

 * @release:	Source structure from which to translate/copy.

 * @resize:	Destination structure for the translate/copy.

/**

 * marshal_det_to_rele() - translate detach to release structure

 * @detach:	Destination structure for the translate/copy.

 * @release:	Source structure from which to translate/copy.

/**

 * marshal_udir_to_rele() - translate udirect to release structure

 * @udirect:	Source structure from which to translate/copy.

 * @release:	Destination structure for the translate/copy.

/**

 * cxlflash_free_errpage() - frees resources associated with global error page

/**

 * cxlflash_stop_term_user_contexts() - stops/terminates known user contexts

 * @cfg:	Internal structure associated with the host.

 *

 * When the host needs to go down, all users must be quiesced and their

 * memory freed. This is accomplished by putting the contexts in error

 * state which will notify the user and let them 'drive' the tear down.

 * Meanwhile, this routine camps until all user contexts have been removed.

 *

 * Note that the main loop in this routine will always execute at least once

 * to flush the reset_waitq.

/**

 * find_error_context() - locates a context by cookie on the error recovery list

 * @cfg:	Internal structure associated with the host.

 * @rctxid:	Desired context by id.

 * @file:	Desired context by file.

 *

 * Return: Found context on success, NULL on failure

/**

 * get_context() - obtains a validated and locked context reference

 * @cfg:	Internal structure associated with the host.

 * @rctxid:	Desired context (raw, un-decoded format).

 * @arg:	LUN information or file associated with request.

 * @ctx_ctrl:	Control information to 'steer' desired lookup.

 *

 * NOTE: despite the name pid, in linux, current->pid actually refers

 * to the lightweight process id (tid) and can change if the process is

 * multi threaded. The tgid remains constant for the process and only changes

 * when the process of fork. For all intents and purposes, think of tgid

 * as a pid in the traditional sense.

 *

 * Return: Validated context on success, NULL on failure

			/*

			 * Need to acquire ownership of the context while still

			 * under the table/list lock to serialize with a remove

			 * thread. Use the 'try' to avoid stalling the

			 * table/list lock for a single context.

			 *

			 * Note that the lock order is:

			 *

			 *	cfg->ctx_tbl_list_mutex -> ctxi->mutex

			 *

			 * Therefore release ctx_tbl_list_mutex before retrying.

 got the context's lock! */

/**

 * put_context() - release a context that was retrieved from get_context()

 * @ctxi:	Context to release.

 *

 * For now, releasing the context equates to unlocking it's mutex.

/**

 * afu_attach() - attach a context to the AFU

 * @cfg:	Internal structure associated with the host.

 * @ctxi:	Context to attach.

 *

 * Upon setting the context capabilities, they must be confirmed with

 * a read back operation as the context might have been closed since

 * the mailbox was unlocked. When this occurs, registration is failed.

 *

 * Return: 0 on success, -errno on failure

 Unlock cap and restrict user to read/write cmds in translated mode */

 Set up the LISN effective address for each interrupt */

 Use primary HWQ PASID as identifier for all interrupts */

 Set up MMIO registers pointing to the RHT */

/**

 * read_cap16() - issues a SCSI READ_CAP16 command

 * @sdev:	SCSI device associated with LUN.

 * @lli:	LUN destined for capacity request.

 *

 * The READ_CAP16 can take quite a while to complete. Should an EEH occur while

 * in scsi_execute(), the EEH handler will attempt to recover. As part of the

 * recovery, the handler drains all currently running ioctls, waiting until they

 * have completed before proceeding with a reset. As this routine is used on the

 * ioctl path, this can create a condition where the EEH handler becomes stuck,

 * infinitely waiting for this ioctl thread. To avoid this behavior, temporarily

 * unmark this thread as an ioctl thread by releasing the ioctl read semaphore.

 * This will allow the EEH handler to proceed with a recovery while this thread

 * is still running. Once the scsi_execute() returns, reacquire the ioctl read

 * semaphore and check the adapter state in case it changed while inside of

 * scsi_execute(). The state check will wait if the adapter is still being

 * recovered or return a failure if the recovery failed. In the event that the

 * adapter reset failed, simply return the failure as the ioctl would be unable

 * to continue.

 *

 * Note that the above puts a requirement on this routine to only be called on

 * an ioctl thread.

 *

 * Return: 0 on success, -errno on failure

 read cap(16) */

 service action */

 Drop the ioctl read semahpore across lengthy call */

 Power on Reset or Device Reset */

 Device capacity changed */

 Report LUNs changed */

 Retry the command once more */

	/*

	 * Read cap was successful, grab values from the buffer;

	 * note that we don't need to worry about unaligned access

	 * as the buffer is allocated on an aligned boundary.

/**

 * get_rhte() - obtains validated resource handle table entry reference

 * @ctxi:	Context owning the resource handle.

 * @rhndl:	Resource handle associated with entry.

 * @lli:	LUN associated with request.

 *

 * Return: Validated RHTE on success, NULL on failure

/**

 * rhte_checkout() - obtains free/empty resource handle table entry

 * @ctxi:	Context owning the resource handle.

 * @lli:	LUN associated with request.

 *

 * Return: Free RHTE on success, NULL on failure

 Find a free RHT entry */

/**

 * rhte_checkin() - releases a resource handle table entry

 * @ctxi:	Context owning the resource handle.

 * @rhte:	RHTE to release.

/**

 * rht_format1() - populates a RHTE for format 1

 * @rhte:	RHTE to populate.

 * @lun_id:	LUN ID of LUN associated with RHTE.

 * @perm:	Desired permissions for RHTE.

 * @port_sel:	Port selection mask

	/*

	 * Populate the Format 1 RHT entry for direct access (physical

	 * LUN) using the synchronization sequence defined in the

	 * SISLite specification.

 Make setting of format bit visible */

 Make setting of LUN id visible */

	/*

	 * Use a dummy RHT Format 1 entry to build the second dword

	 * of the entry that must be populated in a single write when

	 * enabled (valid bit set to TRUE).

 Make remaining RHT entry fields visible */

/**

 * cxlflash_lun_attach() - attaches a user to a LUN and manages the LUN's mode

 * @gli:	LUN to attach.

 * @mode:	Desired mode of the LUN.

 * @locked:	Mutex status on current thread.

 *

 * Return: 0 on success, -errno on failure

/**

 * cxlflash_lun_detach() - detaches a user from a LUN and resets the LUN's mode

 * @gli:	LUN to detach.

 *

 * When resetting the mode, terminate block allocation resources as they

 * are no longer required (service is safe to call even when block allocation

 * resources were not present - such as when transitioning from physical mode).

 * These resources will be reallocated when needed (subsequent transition to

 * virtual mode).

/**

 * _cxlflash_disk_release() - releases the specified resource entry

 * @sdev:	SCSI device associated with LUN.

 * @ctxi:	Context owning resources.

 * @release:	Release ioctl data structure.

 *

 * For LUNs in virtual mode, the virtual LUN associated with the specified

 * resource handle is resized to 0 prior to releasing the RHTE. Note that the

 * AFU sync should _not_ be performed when the context is sitting on the error

 * recovery list. A context on the error recovery list is not known to the AFU

 * due to reset. When the context is recovered, it will be reattached and made

 * known again to the AFU.

 *

 * Return: 0 on success, -errno on failure

	/*

	 * Resize to 0 for virtual LUNS by setting the size

	 * to 0. This will clear LXT_START and LXT_CNT fields

	 * in the RHT entry and properly sync with the AFU.

	 *

	 * Afterwards we clear the remaining fields.

		/*

		 * Clear the Format 1 RHT entry for direct access

		 * (physical LUN) using the synchronization sequence

		 * defined in the SISLite specification.

 Make revocation of RHT entry visible */

 Make clearing of LUN id visible */

 Make RHT entry bottom-half clearing visible */

/**

 * destroy_context() - releases a context

 * @cfg:	Internal structure associated with the host.

 * @ctxi:	Context to release.

 *

 * This routine is safe to be called with a a non-initialized context.

 * Also note that the routine conditionally checks for the existence

 * of the context control map before clearing the RHT registers and

 * context capabilities because it is possible to destroy a context

 * while the context is in the error state (previous mapping was

 * removed [so there is no need to worry about clearing] and context

 * is waiting for a new mapping).

 Clear RHT registers and drop all capabilities for context */

 Free memory associated with context */

/**

 * create_context() - allocates and initializes a context

 * @cfg:	Internal structure associated with the host.

 *

 * Return: Allocated context on success, NULL on failure

/**

 * init_context() - initializes a previously allocated context

 * @ctxi:	Previously allocated context

 * @cfg:	Internal structure associated with the host.

 * @ctx:	Previously obtained context cookie.

 * @ctxid:	Previously obtained process element associated with CXL context.

 * @file:	Previously obtained file associated with CXL context.

 * @perms:	User-specified permissions.

 * @irqs:	User-specified number of interrupts.

 tgid = pid */

 initialize for list_empty() */

/**

 * remove_context() - context kref release handler

 * @kref:	Kernel reference associated with context to be removed.

 *

 * When a context no longer has any references it can safely be removed

 * from global access and destroyed. Note that it is assumed the thread

 * relinquishing access to the context holds its mutex.

 Remove context from table/error list */

 Context now completely uncoupled/unreachable */

/**

 * _cxlflash_disk_detach() - detaches a LUN from a context

 * @sdev:	SCSI device associated with LUN.

 * @ctxi:	Context owning resources.

 * @detach:	Detach ioctl data structure.

 *

 * As part of the detach, all per-context resources associated with the LUN

 * are cleaned up. When detaching the last LUN for a context, the context

 * itself is cleaned up and released.

 *

 * Return: 0 on success, -errno on failure

 Cleanup outstanding resources tied to this LUN */

 No need to loop further if we're done */

 Take our LUN out of context, free the node */

	/*

	 * Release the context reference and the sdev reference that

	 * bound this LUN to the context.

/**

 * cxlflash_cxl_release() - release handler for adapter file descriptor

 * @inode:	File-system inode associated with fd.

 * @file:	File installed with adapter file descriptor.

 *

 * This routine is the release handler for the fops registered with

 * the CXL services on an initial attach for a context. It is called

 * when a close (explicity by the user or as part of a process tear

 * down) is performed on the adapter file descriptor returned to the

 * user. The user should be aware that explicitly performing a close

 * considered catastrophic and subsequent usage of the superpipe API

 * with previously saved off tokens will fail.

 *

 * This routine derives the context reference and calls detach for

 * each LUN associated with the context.The final detach operation

 * causes the context itself to be freed. With exception to when the

 * CXL process element (context id) lookup fails (a case that should

 * theoretically never occur), every call into this routine results

 * in a complete freeing of a context.

 *

 * Detaching the LUN is typically an ioctl() operation and the underlying

 * code assumes that ioctl_rwsem has been acquired as a reader. To support

 * that design point, the semaphore is acquired and released around detach.

 *

 * Return: 0 on success

/**

 * unmap_context() - clears a previously established mapping

 * @ctxi:	Context owning the mapping.

 *

 * This routine is used to switch between the error notification page

 * (dummy page of all 1's) and the real mapping (established by the CXL

 * fault handler).

/**

 * get_err_page() - obtains and allocates the error notification page

 * @cfg:	Internal structure associated with the host.

 *

 * Return: error notification page on success, NULL on failure

 Serialize update w/ other threads to avoid a leak */

/**

 * cxlflash_mmap_fault() - mmap fault handler for adapter file descriptor

 * @vmf:	VM fault associated with current fault.

 *

 * To support error notification via MMIO, faults are 'caught' by this routine

 * that was inserted before passing back the adapter file descriptor on attach.

 * When a fault occurs, this routine evaluates if error recovery is active and

 * if so, installs the error page to 'notify' the user about the error state.

 * During normal operation, the fault is simply handled by the original fault

 * handler that was installed by CXL services as part of initializing the

 * adapter file descriptor. The VMA's page protection bits are toggled to

 * indicate cached/not-cached depending on the memory backing the fault.

 *

 * Return: 0 on success, VM_FAULT_SIGBUS on failure

/*

 * Local MMAP vmops to 'catch' faults

/**

 * cxlflash_cxl_mmap() - mmap handler for adapter file descriptor

 * @file:	File installed with adapter file descriptor.

 * @vma:	VM area associated with mapping.

 *

 * Installs local mmap vmops to 'catch' faults for error notification support.

 *

 * Return: 0 on success, -errno on failure

 Insert ourself in the mmap fault handler path */

/**

 * cxlflash_mark_contexts_error() - move contexts to error state and list

 * @cfg:	Internal structure associated with the host.

 *

 * A context is only moved over to the error list when there are no outstanding

 * references to it. This ensures that a running operation has completed.

 *

 * Return: 0 on success, -errno on failure

/*

 * Dummy NULL fops

/**

 * check_state() - checks and responds to the current adapter state

 * @cfg:	Internal structure associated with the host.

 *

 * This routine can block and should only be used on process context.

 * It assumes that the caller is an ioctl thread and holding the ioctl

 * read semaphore. This is temporarily let up across the wait to allow

 * for draining actively running ioctls. Also note that when waking up

 * from waiting in reset, the state is unknown and must be checked again

 * before proceeding.

 *

 * Return: 0 on success, -errno on failure

/**

 * cxlflash_disk_attach() - attach a LUN to a context

 * @sdev:	SCSI device associated with LUN.

 * @attach:	Attach ioctl data structure.

 *

 * Creates a context and attaches LUN to it. A LUN can only be attached

 * one time to a context (subsequent attaches for the same context/LUN pair

 * are not supported). Additional LUNs can be attached to a context by

 * specifying the 'reuse' flag defined in the cxlflash_ioctl.h header.

 *

 * Return: 0 on success, -errno on failure

 Non-NULL context indicates reuse (another context reference) */

 Translate read/write O_* flags from fcntl.h to AFU permission bits */

 Context mutex is locked upon return */

	/*

	 * No error paths after this point. Once the fd is installed it's

	 * visible to user space and can't be undone safely on this thread.

	 * There is no need to worry about a deadlock here because no one

	 * knows about us yet; we can be the only one holding our mutex.

 Cleanup CXL context; okay to 'stop' even if it was not started */

	/*

	 * Here, we're overriding the fops with a dummy all-NULL fops because

	 * fput() calls the release fop, which will cause us to mistakenly

	 * call into the CXL code. Rather than try to add yet more complexity

	 * to that routine (cxlflash_cxl_release) we should try to fix the

	 * issue here.

 Cleanup our context */

/**

 * recover_context() - recovers a context in error

 * @cfg:	Internal structure associated with the host.

 * @ctxi:	Context to release.

 * @adap_fd:	Adapter file descriptor associated with new/recovered context.

 *

 * Restablishes the state for a context-in-error.

 *

 * Return: 0 on success, -errno on failure

 Update with new MMIO area based on updated context id */

	/*

	 * No error paths after this point. Once the fd is installed it's

	 * visible to user space and can't be undone safely on this thread.

	/*

	 * Put context back in table (note the reinit of the context list);

	 * we must first drop the context's mutex and then acquire it in

	 * order with the table/list mutex to avoid a deadlock - safe to do

	 * here because no one can find us at this moment in time.

/**

 * cxlflash_afu_recover() - initiates AFU recovery

 * @sdev:	SCSI device associated with LUN.

 * @recover:	Recover ioctl data structure.

 *

 * Only a single recovery is allowed at a time to avoid exhausting CXL

 * resources (leading to recovery failure) in the event that we're up

 * against the maximum number of contexts limit. For similar reasons,

 * a context recovery is retried if there are multiple recoveries taking

 * place at the same time and the failure was due to CXL services being

 * unable to keep up.

 *

 * As this routine is called on ioctl context, it holds the ioctl r/w

 * semaphore that is used to drain ioctls in recovery scenarios. The

 * implementation to achieve the pacing described above (a local mutex)

 * requires that the ioctl r/w semaphore be dropped and reacquired to

 * avoid a 3-way deadlock when multiple process recoveries operate in

 * parallel.

 *

 * Because a user can detect an error condition before the kernel, it is

 * quite possible for this routine to act as the kernel's EEH detection

 * source (MMIO read of mbox_r). Because of this, there is a window of

 * time where an EEH might have been detected but not yet 'serviced'

 * (callback invoked, causing the device to enter reset state). To avoid

 * looping in this routine during that window, a 1 second sleep is in place

 * between the time the MMIO failure is detected and the time a wait on the

 * reset wait queue is attempted via check_state().

 *

 * Return: 0 on success, -errno on failure

 up to 2 seconds */

 Ensure that this process is attached to the context */

 Test if in error state */

		/*

		 * Before checking the state, put back the context obtained with

		 * get_context() as it is no longer needed and sleep for a short

		 * period of time (see prolog notes).

/**

 * process_sense() - evaluates and processes sense data

 * @sdev:	SCSI device associated with LUN.

 * @verify:	Verify ioctl data structure.

 *

 * Return: 0 on success, -errno on failure

 Power on Reset or Device Reset */

 Device settings/capacity changed */

 Report LUNs changed, Rescan. */

/**

 * cxlflash_disk_verify() - verifies a LUN is the same and handle size changes

 * @sdev:	SCSI device associated with LUN.

 * @verify:	Verify ioctl data structure.

 *

 * Return: 0 on success, -errno on failure

	/*

	 * Look at the hint/sense to see if it requires us to redrive

	 * inquiry (i.e. the Unit attention is due to the WWN changing).

		/* Can't hold mutex across process_sense/read_cap16,

		 * since we could have an intervening EEH event.

 Cast lxt_cnt to u64 for multiply to be treated as 64bit op */

/**

 * decode_ioctl() - translates an encoded ioctl to an easily identifiable string

 * @cmd:	The ioctl command to decode.

 *

 * Return: A string identifying the decoded ioctl.

/**

 * cxlflash_disk_direct_open() - opens a direct (physical) disk

 * @sdev:	SCSI device associated with LUN.

 * @arg:	UDirect ioctl data structure.

 *

 * On successful return, the user is informed of the resource handle

 * to be used to identify the direct lun and the size (in blocks) of

 * the direct lun in last LBA format.

 *

 * Return: 0 on success, -errno on failure

 too many opens  */

/**

 * ioctl_common() - common IOCTL handler for driver

 * @sdev:	SCSI device associated with LUN.

 * @cmd:	IOCTL command.

 *

 * Handles common fencing operations that are valid for multiple ioctls. Always

 * allow through ioctls that are cleanup oriented in nature, even when operating

 * in a failed/terminating state.

 *

 * Return: 0 on success, -errno on failure

/**

 * cxlflash_ioctl() - IOCTL handler for driver

 * @sdev:	SCSI device associated with LUN.

 * @cmd:	IOCTL command.

 * @arg:	Userspace ioctl data structure.

 *

 * A read/write semaphore is used to implement a 'drain' of currently

 * running ioctls. The read semaphore is taken at the beginning of each

 * ioctl thread and released upon concluding execution. Additionally the

 * semaphore should be released and then reacquired in any ioctl execution

 * path which will wait for an event to occur that is outside the scope of

 * the ioctl (i.e. an adapter reset). To drain the ioctls currently running,

 * a thread simply needs to acquire the write semaphore.

 *

 * Return: 0 on success, -errno on failure

 NOTE: order matters here */

 Hold read semaphore so we can drain if needed */

 Restrict command set to physical support only for internal LUN */

 fall through to exit */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * CXL Flash Device Driver

 *

 * Written by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>, IBM Corporation

 *             Uma Krishnan <ukrishn@linux.vnet.ibm.com>, IBM Corporation

 *

 * Copyright (C) 2018 IBM Corporation

/*

 * Pseudo-filesystem to allocate inodes.

/*

 * ocxlflash_release_mapping() - release the memory mapping

 * @ctx:	Context whose mapping is to be released.

/*

 * ocxlflash_getfile() - allocate pseudo filesystem, inode, and the file

 * @dev:	Generic device of the host.

 * @name:	Name of the pseudo filesystem.

 * @fops:	File operations.

 * @priv:	Private data.

 * @flags:	Flags for the file.

 *

 * Return: pointer to the file on success, ERR_PTR on failure

/**

 * ocxlflash_psa_map() - map the process specific MMIO space

 * @ctx_cookie:	Adapter context for which the mapping needs to be done.

 *

 * Return: MMIO pointer of the mapped region

/**

 * ocxlflash_psa_unmap() - unmap the process specific MMIO space

 * @addr:	MMIO pointer to unmap.

/**

 * ocxlflash_process_element() - get process element of the adapter context

 * @ctx_cookie:	Adapter context associated with the process element.

 *

 * Return: process element of the adapter context

/**

 * afu_map_irq() - map the interrupt of the adapter context

 * @flags:	Flags.

 * @ctx:	Adapter context.

 * @num:	Per-context AFU interrupt number.

 * @handler:	Interrupt handler to register.

 * @cookie:	Interrupt handler private data.

 * @name:	Name of the interrupt.

 *

 * Return: 0 on success, -errno on failure

/**

 * ocxlflash_map_afu_irq() - map the interrupt of the adapter context

 * @ctx_cookie:	Adapter context.

 * @num:	Per-context AFU interrupt number.

 * @handler:	Interrupt handler to register.

 * @cookie:	Interrupt handler private data.

 * @name:	Name of the interrupt.

 *

 * Return: 0 on success, -errno on failure

/**

 * afu_unmap_irq() - unmap the interrupt

 * @flags:	Flags.

 * @ctx:	Adapter context.

 * @num:	Per-context AFU interrupt number.

 * @cookie:	Interrupt handler private data.

/**

 * ocxlflash_unmap_afu_irq() - unmap the interrupt

 * @ctx_cookie:	Adapter context.

 * @num:	Per-context AFU interrupt number.

 * @cookie:	Interrupt handler private data.

/**

 * ocxlflash_get_irq_objhndl() - get the object handle for an interrupt

 * @ctx_cookie:	Context associated with the interrupt.

 * @irq:	Interrupt number.

 *

 * Return: effective address of the mapped region

/**

 * ocxlflash_xsl_fault() - callback when translation error is triggered

 * @data:	Private data provided at callback registration, the context.

 * @addr:	Address that triggered the error.

 * @dsisr:	Value of dsisr register.

/**

 * start_context() - local routine to start a context

 * @ctx:	Adapter context to be started.

 *

 * Assign the context specific MMIO space, add and enable the PE.

 *

 * Return: 0 on success, -errno on failure

 pid and mm not set for master contexts */

/**

 * ocxlflash_start_context() - start a kernel context

 * @ctx_cookie:	Adapter context to be started.

 *

 * Return: 0 on success, -errno on failure

/**

 * ocxlflash_stop_context() - stop a context

 * @ctx_cookie:	Adapter context to be stopped.

 *

 * Return: 0 on success, -errno on failure

 If EBUSY, PE could be referenced in future by the AFU */

/**

 * ocxlflash_afu_reset() - reset the AFU

 * @ctx_cookie:	Adapter context.

 Pending implementation from OCXL transport services */

 Silently return success until it is implemented */

/**

 * ocxlflash_set_master() - sets the context as master

 * @ctx_cookie:	Adapter context to set as master.

/**

 * ocxlflash_get_context() - obtains the context associated with the host

 * @pdev:	PCI device associated with the host.

 * @afu_cookie:	Hardware AFU associated with the host.

 *

 * Return: returns the pointer to host adapter context

/**

 * ocxlflash_dev_context_init() - allocate and initialize an adapter context

 * @pdev:	PCI device associated with the host.

 * @afu_cookie:	Hardware AFU associated with the host.

 *

 * Return: returns the adapter context on success, ERR_PTR on failure

/**

 * ocxlflash_release_context() - releases an adapter context

 * @ctx_cookie:	Adapter context to be released.

 *

 * Return: 0 on success, -errno on failure

/**

 * ocxlflash_perst_reloads_same_image() - sets the image reload policy

 * @afu_cookie:	Hardware AFU associated with the host.

 * @image:	Whether to load the same image on PERST.

/**

 * ocxlflash_read_adapter_vpd() - reads the adapter VPD

 * @pdev:	PCI device associated with the host.

 * @buf:	Buffer to get the VPD data.

 * @count:	Size of buffer (maximum bytes that can be read).

 *

 * Return: size of VPD on success, -errno on failure

/**

 * free_afu_irqs() - internal service to free interrupts

 * @ctx:	Adapter context.

/**

 * alloc_afu_irqs() - internal service to allocate interrupts

 * @ctx:	Context associated with the request.

 * @num:	Number of interrupts requested.

 *

 * Return: 0 on success, -errno on failure

/**

 * ocxlflash_allocate_afu_irqs() - allocates the requested number of interrupts

 * @ctx_cookie:	Context associated with the request.

 * @num:	Number of interrupts requested.

 *

 * Return: 0 on success, -errno on failure

/**

 * ocxlflash_free_afu_irqs() - frees the interrupts of an adapter context

 * @ctx_cookie:	Adapter context.

/**

 * ocxlflash_unconfig_afu() - unconfigure the AFU

 * @afu: AFU associated with the host.

/**

 * ocxlflash_destroy_afu() - destroy the AFU structure

 * @afu_cookie:	AFU to be freed.

 Disable the AFU */

/**

 * ocxlflash_config_fn() - configure the host function

 * @pdev:	PCI device associated with the host.

 * @afu:	AFU associated with the host.

 *

 * Return: 0 on success, -errno on failure

 Read DVSEC config of the function */

 Check if function has AFUs defined, only 1 per function supported */

/**

 * ocxlflash_unconfig_fn() - unconfigure the host function

 * @pdev:	PCI device associated with the host.

 * @afu:	AFU associated with the host.

/**

 * ocxlflash_map_mmio() - map the AFU MMIO space

 * @afu: AFU associated with the host.

 *

 * Return: 0 on success, -errno on failure

/**

 * ocxlflash_config_afu() - configure the host AFU

 * @pdev:	PCI device associated with the host.

 * @afu:	AFU associated with the host.

 *

 * Must be called _after_ host function configuration.

 *

 * Return: 0 on success, -errno on failure

 This HW AFU function does not have any AFUs defined */

 Read AFU config at index 0 */

 Only one AFU per function is supported, so actag_base is same */

 Enable the AFU */

/**

 * ocxlflash_create_afu() - create the AFU for OCXL

 * @pdev:	PCI device associated with the host.

 *

 * Return: AFU on success, NULL on failure

/**

 * ctx_event_pending() - check for any event pending on the context

 * @ctx:	Context to be checked.

 *

 * Return: true if there is an event pending, false if none pending

/**

 * afu_poll() - poll the AFU for events on the context

 * @file:	File associated with the adapter context.

 * @poll:	Poll structure from the user.

 *

 * Return: poll mask

/**

 * afu_read() - perform a read on the context for any event

 * @file:	File associated with the adapter context.

 * @buf:	Buffer to receive the data.

 * @count:	Size of buffer (maximum bytes that can be read).

 * @off:	Offset.

 *

 * Return: size of the data read on success, -errno on failure

/**

 * afu_release() - release and free the context

 * @inode:	File inode pointer.

 * @file:	File associated with the context.

 *

 * Return: 0 on success, -errno on failure

 Unmap and free the interrupts associated with the context */

/**

 * ocxlflash_mmap_fault() - mmap fault handler

 * @vmf:	VM fault associated with current fault.

 *

 * Return: 0 on success, -errno on failure

/**

 * afu_mmap() - map the fault handler operations

 * @file:	File associated with the context.

 * @vma:	VM area associated with mapping.

 *

 * Return: 0 on success, -errno on failure

/**

 * ocxlflash_get_fd() - get file descriptor for an adapter context

 * @ctx_cookie:	Adapter context.

 * @fops:	File operations to be associated.

 * @fd:		File descriptor to be returned back.

 *

 * Return: pointer to the file on success, ERR_PTR on failure

 Only allow one fd per context */

 This code is similar to anon_inode_getfd() */

 Patch the file ops that are not defined */

 Use default ops */

/**

 * ocxlflash_fops_get_context() - get the context associated with the file

 * @file:	File associated with the adapter context.

 *

 * Return: pointer to the context

/**

 * ocxlflash_afu_irq() - interrupt handler for user contexts

 * @irq:	Interrupt number.

 * @data:	Private data provided at interrupt registration, the context.

 *

 * Return: Always return IRQ_HANDLED.

/**

 * ocxlflash_start_work() - start a user context

 * @ctx_cookie:	Context to be started.

 * @num_irqs:	Number of interrupts requested.

 *

 * Return: 0 on success, -errno on failure

/**

 * ocxlflash_fd_mmap() - mmap handler for adapter file descriptor

 * @file:	File installed with adapter file descriptor.

 * @vma:	VM area associated with mapping.

 *

 * Return: 0 on success, -errno on failure

/**

 * ocxlflash_fd_release() - release the context associated with the file

 * @inode:	File inode pointer.

 * @file:	File associated with the adapter context.

 *

 * Return: 0 on success, -errno on failure

 Backend ops to ocxlflash services */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * CXL Flash Device Driver

 *

 * Written by: Manoj N. Kumar <manoj@linux.vnet.ibm.com>, IBM Corporation

 *             Matthew R. Ochs <mrochs@linux.vnet.ibm.com>, IBM Corporation

 *

 * Copyright (C) 2015 IBM Corporation

/**

 * process_cmd_err() - command error handler

 * @cmd:	AFU command that experienced the error.

 * @scp:	SCSI command associated with the AFU command in error.

 *

 * Translates error bits from AFU command to SCSI command results.

 We have a SCSI status */

	/*

	 * We encountered an error. Set scp->result based on nature

	 * of error.

 We have an FC status */

 This indicates an FCP resid underrun */

				/* If the SISL_RC_FLAGS_OVERRUN flag was set,

				 * then we will handle this error else where.

				 * If not then we must handle it here.

				 * This is probably an AFU bug.

 Resid mismatch between adapter and device */

 We have an AFU error */

 Retry */

 Retry */

/**

 * cmd_complete() - command completion handler

 * @cmd:	AFU command that has completed.

 *

 * For SCSI commands this routine prepares and submits commands that have

 * either completed or timed out to the SCSI stack. For internal commands

 * (TMF or AFU), this routine simply notifies the originator that the

 * command has completed.

/**

 * flush_pending_cmds() - flush all pending commands on this hardware queue

 * @hwq:	Hardware queue to flush.

 *

 * The hardware send queue lock associated with this hardware queue must be

 * held when calling this routine.

 Bypass command when on a doneq, cmd_complete() will handle */

/**

 * context_reset() - reset context via specified register

 * @hwq:	Hardware queue owning the context to be reset.

 * @reset_reg:	MMIO register to perform reset.

 *

 * When the reset is successful, the SISLite specification guarantees that

 * the AFU has aborted all currently pending I/O. Accordingly, these commands

 * must be flushed.

 *

 * Return: 0 on success, -errno on failure

 Double delay each time */

/**

 * context_reset_ioarrin() - reset context via IOARRIN register

 * @hwq:	Hardware queue owning the context to be reset.

 *

 * Return: 0 on success, -errno on failure

/**

 * context_reset_sq() - reset context via SQ_CONTEXT_RESET register

 * @hwq:	Hardware queue owning the context to be reset.

 *

 * Return: 0 on success, -errno on failure

/**

 * send_cmd_ioarrin() - sends an AFU command via IOARRIN register

 * @afu:	AFU associated with the host.

 * @cmd:	AFU command to send.

 *

 * Return:

 *	0 on success, SCSI_MLQUEUE_HOST_BUSY on failure

	/*

	 * To avoid the performance penalty of MMIO, spread the update of

	 * 'room' over multiple commands.

/**

 * send_cmd_sq() - sends an AFU command via SQ ring

 * @afu:	AFU associated with the host.

 * @cmd:	AFU command to send.

 *

 * Return:

 *	0 on success, SCSI_MLQUEUE_HOST_BUSY on failure

/**

 * wait_resp() - polls for a response or timeout to a sent AFU command

 * @afu:	AFU associated with the host.

 * @cmd:	AFU command that was sent.

 *

 * Return: 0 on success, -errno on failure

/**

 * cmd_to_target_hwq() - selects a target hardware queue for a SCSI command

 * @host:	SCSI host associated with device.

 * @scp:	SCSI command to send.

 * @afu:	SCSI command to send.

 *

 * Hashes a command based upon the hardware queue mode.

 *

 * Return: Trusted index of target hardware queue

/**

 * send_tmf() - sends a Task Management Function (TMF)

 * @cfg:	Internal structure associated with the host.

 * @sdev:	SCSI device destined for TMF.

 * @tmfcmd:	TMF command to send.

 *

 * Return:

 *	0 on success, SCSI_MLQUEUE_HOST_BUSY or -errno on failure

 When Task Management Function is active do not send another */

/**

 * cxlflash_driver_info() - information handler for this host driver

 * @host:	SCSI host associated with device.

 *

 * Return: A string describing the device.

/**

 * cxlflash_queuecommand() - sends a mid-layer request

 * @host:	SCSI host associated with device.

 * @scp:	SCSI command to send.

 *

 * Return: 0 on success, SCSI_MLQUEUE_HOST_BUSY on failure

	/*

	 * If a Task Management Function is active, wait for it to complete

	 * before continuing with regular commands.

/**

 * cxlflash_wait_for_pci_err_recovery() - wait for error recovery during probe

 * @cfg:	Internal structure associated with the host.

/**

 * free_mem() - free memory associated with the AFU

 * @cfg:	Internal structure associated with the host.

/**

 * cxlflash_reset_sync() - synchronizing point for asynchronous resets

 * @cfg:	Internal structure associated with the host.

 Wait until all async calls prior to this cookie have completed */

/**

 * stop_afu() - stops the AFU command timers and unmaps the MMIO space

 * @cfg:	Internal structure associated with the host.

 *

 * Safe to call with AFU in a partially allocated/initialized state.

 *

 * Cancels scheduled worker threads, waits for any active internal AFU

 * commands to timeout, disables IRQ polling and then unmaps the MMIO space.

/**

 * term_intr() - disables all AFU interrupts

 * @cfg:	Internal structure associated with the host.

 * @level:	Depth of allocation, where to begin waterfall tear down.

 * @index:	Index of the hardware queue.

 *

 * Safe to call with AFU/MC in partially allocated/initialized state.

 SISL_MSI_ASYNC_ERROR is setup only for the primary HWQ */

 No action required */

/**

 * term_mc() - terminates the master context

 * @cfg:	Internal structure associated with the host.

 * @index:	Index of the hardware queue.

 *

 * Safe to call with AFU/MC in partially allocated/initialized state.

/**

 * term_afu() - terminates the AFU

 * @cfg:	Internal structure associated with the host.

 *

 * Safe to call with AFU/MC in partially allocated/initialized state.

	/*

	 * Tear down is carefully orchestrated to ensure

	 * no interrupts can come in when the problem state

	 * area is unmapped.

	 *

	 * 1) Disable all AFU interrupts for each master

	 * 2) Unmap the problem state area

	 * 3) Stop each master context

/**

 * notify_shutdown() - notifies device of pending shutdown

 * @cfg:	Internal structure associated with the host.

 * @wait:	Whether to wait for shutdown processing to complete.

 *

 * This function will notify the AFU that the adapter is being shutdown

 * and will wait for shutdown processing to complete if wait is true.

 * This notification should flush pending I/Os to the device and halt

 * further I/Os until the next AFU reset is issued and device restarted.

 Notify AFU */

 Wait up to 1.5 seconds for shutdown processing to complete */

/**

 * cxlflash_get_minor() - gets the first available minor number

 *

 * Return: Unique minor number that can be used to create the character device.

/**

 * cxlflash_put_minor() - releases the minor number

 * @minor:	Minor number that is no longer needed.

/**

 * cxlflash_release_chrdev() - release the character device for the host

 * @cfg:	Internal structure associated with the host.

/**

 * cxlflash_remove() - PCI entry point to tear down host

 * @pdev:	PCI device associated with the host.

 *

 * Safe to use as a cleanup in partially allocated/initialized state. Note that

 * the reset_waitq is flushed as part of the stop/termination of user contexts.

 Yield to running recovery threads before continuing with remove */

 Notify AFU and wait for shutdown processing to complete */

/**

 * alloc_mem() - allocates the AFU and its command pool

 * @cfg:	Internal structure associated with the host.

 *

 * A partially allocated state remains on failure.

 *

 * Return:

 *	0 on success

 *	-ENOMEM on failure to allocate memory

 AFU is ~28k, i.e. only one 64k page or up to seven 4k pages */

/**

 * init_pci() - initializes the host as a PCI device

 * @cfg:	Internal structure associated with the host.

 *

 * Return: 0 on success, -errno on failure

/**

 * init_scsi() - adds the host to the SCSI stack and kicks off host scan

 * @cfg:	Internal structure associated with the host.

 *

 * Return: 0 on success, -errno on failure

/**

 * set_port_online() - transitions the specified host FC port to online state

 * @fc_regs:	Top of MMIO region defined for specified port.

 *

 * The provided MMIO region must be mapped prior to call. Online state means

 * that the FC link layer has synced, completed the handshaking process, and

 * is ready for login to start.

 clear OFF_LINE */

 set ON_LINE */

/**

 * set_port_offline() - transitions the specified host FC port to offline state

 * @fc_regs:	Top of MMIO region defined for specified port.

 *

 * The provided MMIO region must be mapped prior to call.

 clear ON_LINE */

 set OFF_LINE */

/**

 * wait_port_online() - waits for the specified host FC port come online

 * @fc_regs:	Top of MMIO region defined for specified port.

 * @delay_us:	Number of microseconds to delay between reading port status.

 * @nretry:	Number of cycles to retry reading port status.

 *

 * The provided MMIO region must be mapped prior to call. This will timeout

 * when the cable is not plugged in.

 *

 * Return:

 *	TRUE (1) when the specified port is online

 *	FALSE (0) when the specified port fails to come online after timeout

/**

 * wait_port_offline() - waits for the specified host FC port go offline

 * @fc_regs:	Top of MMIO region defined for specified port.

 * @delay_us:	Number of microseconds to delay between reading port status.

 * @nretry:	Number of cycles to retry reading port status.

 *

 * The provided MMIO region must be mapped prior to call.

 *

 * Return:

 *	TRUE (1) when the specified port is offline

 *	FALSE (0) when the specified port fails to go offline after timeout

/**

 * afu_set_wwpn() - configures the WWPN for the specified host FC port

 * @afu:	AFU associated with the host that owns the specified FC port.

 * @port:	Port number being configured.

 * @fc_regs:	Top of MMIO region defined for specified port.

 * @wwpn:	The world-wide-port-number previously discovered for port.

 *

 * The provided MMIO region must be mapped prior to call. As part of the

 * sequence to configure the WWPN, the port is toggled offline and then back

 * online. This toggling action can cause this routine to delay up to a few

 * seconds. When configured to use the internal LUN feature of the AFU, a

 * failure to come online is overridden.

/**

 * afu_link_reset() - resets the specified host FC port

 * @afu:	AFU associated with the host that owns the specified FC port.

 * @port:	Port number being configured.

 * @fc_regs:	Top of MMIO region defined for specified port.

 *

 * The provided MMIO region must be mapped prior to call. The sequence to

 * reset the port involves toggling it offline and then back online. This

 * action can cause this routine to delay up to a few seconds. An effort

 * is made to maintain link with the device by switching to host to use

 * the alternate port exclusively while the reset takes place.

 * failure to come online is overridden.

 first switch the AFU to the other links, if any */

 switch back to include this port */

/**

 * afu_err_intr_init() - clears and initializes the AFU for error interrupts

 * @afu:	AFU associated with the host.

	/* global async interrupts: AFU clears afu_ctrl on context exit

	 * if async interrupts were sent to that context. This prevents

	 * the AFU form sending further async interrupts when

	 * there is

	 * nobody to receive them.

 mask all */

 set LISN# to send and point to primary master context */

 Bit 63 indicates local lun */

 clear all */

 unmask bits that are of interest */

 note: afu can send an interrupt after this step */

 clear again in case a bit came on after previous clear but before */

 unmask */

 Clear/Set internal lun bits */

 now clear FC errors */

 sync interrupts for master's IOARRIN write */

 note that unlike asyncs, there can be no pending sync interrupts */

 at this time (this is a fresh context and master has not written */

 IOARRIN yet), so there is nothing to clear. */

 set LISN#, it is always sent to the context that wrote IOARRIN */

/**

 * cxlflash_sync_err_irq() - interrupt handler for synchronous errors

 * @irq:	Interrupt number.

 * @data:	Private data provided at interrupt registration, the AFU.

 *

 * Return: Always return IRQ_HANDLED.

/**

 * process_hrrq() - process the read-response queue

 * @hwq:	HWQ associated with the host.

 * @doneq:	Queue of commands harvested from the RRQ.

 * @budget:	Threshold of RRQ entries to process.

 *

 * This routine must be called holding the disabled RRQ spin lock.

 *

 * Return: The number of entries processed.

 Process ready RRQ entries up to the specified budget (if any) */

 Advance to next entry or wrap and flip the toggle bit */

/**

 * process_cmd_doneq() - process a queue of harvested RRQ commands

 * @doneq:	Queue of completed commands.

 *

 * Note that upon return the queue can no longer be trusted.

/**

 * cxlflash_irqpoll() - process a queue of harvested RRQ commands

 * @irqpoll:	IRQ poll structure associated with queue to poll.

 * @budget:	Threshold of RRQ entries to process per poll.

 *

 * Return: The number of entries processed.

/**

 * cxlflash_rrq_irq() - interrupt handler for read-response queue (normal path)

 * @irq:	Interrupt number.

 * @data:	Private data provided at interrupt registration, the AFU.

 *

 * Return: IRQ_HANDLED or IRQ_NONE when no ready entries found.

 Silently drop spurious interrupts when queue is not online */

/*

 * Asynchronous interrupt information table

 *

 * NOTE:

 *	- Order matters here as this array is indexed by bit position.

 *

 *	- The checkpatch script considers the BUILD_SISL_ASTATUS_FC_PORT macro

 *	  as complex and complains due to a lack of parentheses/braces.

/**

 * cxlflash_async_err_irq() - interrupt handler for asynchronous errors

 * @irq:	Interrupt number.

 * @data:	Private data provided at interrupt registration, the AFU.

 *

 * Return: Always return IRQ_HANDLED.

 FYI, it is 'okay' to clear AFU status before FC_ERROR */

 Check each bit that is on */

		/*

		 * Do link reset first, some OTHER errors will set FC_ERROR

		 * again if cleared before or w/o a reset

			/*

			 * Since all errors are unmasked, FC_ERROR and FC_ERRCAP

			 * should be the same and tracing one is sufficient.

/**

 * read_vpd() - obtains the WWPNs from VPD

 * @cfg:	Internal structure associated with the host.

 * @wwpn:	Array of size MAX_FC_PORTS to pass back WWPNs

 *

 * Return: 0 on success, -errno on failure

 Get the VPD data from the device */

	/*

	 * Find the offset of the WWPN tag within the read only

	 * VPD data and validate the found field (partials are

	 * no good to us). Convert the ASCII data to an integer

	 * value. Note that we must copy to a temporary buffer

	 * because the conversion service requires that the ASCII

	 * string be terminated.

	 *

	 * Allow for WWPN not being found for all devices, setting

	 * the returned WWPN to zero when not found. Notify with a

	 * log error for cards that should have had WWPN keywords

	 * in the VPD - cards requiring WWPN will not have their

	 * ports programmed and operate in an undefined state.

/**

 * init_pcr() - initialize the provisioning and control registers

 * @cfg:	Internal structure associated with the host.

 *

 * Also sets up fast access to the mapped registers and initializes AFU

 * command fields that never change.

 Disrupt any clients that could be running */

 e.g. clients that survived a master restart */

 Copy frequently used fields into hwq */

 Program the Endian Control for the master context */

/**

 * init_global() - initialize AFU global registers

 * @cfg:	Internal structure associated with the host.

 wwpn of AFU ports */

 Set up RRQ and SQ in HWQ for master issued cmds */

 AFU configuration */

 enable all auto retry options and control endianness */

 leave others at default: */

 CTX_CAP write protected, mbox_r does not clear on read and */

 checker on if dual afu */

 Global port select: select either port */

 Only use port 0 */

 Unmask all errors (but they are still masked at AFU) */

 Clear CRC error cnt & set a threshold */

 Set WWPNs. If already programmed, wwpn[i] is 0 */

		/* Programming WWPN back to back causes additional

		 * offline/online transitions and a PLOGI

 Set up the LISN effective address for each master */

 Set up master's own CTX_CAP to allow real mode, host translation */

 tables, afu cmds and read/write GSCSI cmds. */

 First, unlock ctx_cap write by reading mbox */

 unlock ctx_cap */

	/*

	 * Determine write-same unmap support for host by evaluating the unmap

	 * sector support bit of the context control register associated with

	 * the primary hardware queue. Note that while this status is reflected

	 * in a context register, the outcome can be assumed to be host-wide.

 Initialize heartbeat */

/**

 * start_afu() - initializes and starts the AFU

 * @cfg:	Internal structure associated with the host.

 Initialize each HWQ */

 After an AFU reset, RRQ entries are stale, clear them */

 Initialize RRQ pointers */

 Initialize spin locks */

 Initialize SQ */

 Initialize IRQ poll */

/**

 * init_intr() - setup interrupt handlers for the master context

 * @cfg:	Internal structure associated with the host.

 * @hwq:	Hardware queue to initialize.

 *

 * Return: 0 on success, -errno on failure

 SISL_MSI_ASYNC_ERROR is setup only for the primary HWQ */

/**

 * init_mc() - create and register as the master context

 * @cfg:	Internal structure associated with the host.

 * @index:	HWQ Index of the master context.

 *

 * Return: 0 on success, -errno on failure

 Set it up as a master with the CXL */

 Reset AFU when initializing primary context */

 Finally, activate the context by starting it */

/**

 * get_num_afu_ports() - determines and configures the number of AFU ports

 * @cfg:	Internal structure associated with the host.

 *

 * This routine determines the number of AFU ports by converting the global

 * port selection mask. The converted value is only valid following an AFU

 * reset (explicit or power-on). This routine must be invoked shortly after

 * mapping as other routines are dependent on the number of ports during the

 * initialization sequence.

 *

 * To support legacy AFUs that might not have reflected an initial global

 * port mask (value read is 0), default to the number of ports originally

 * supported by the cxlflash driver (2) before hardware with other port

 * offerings was introduced.

/**

 * init_afu() - setup as master context and start AFU

 * @cfg:	Internal structure associated with the host.

 *

 * This routine is a higher level of control for configuring the

 * AFU on probe and reset paths.

 *

 * Return: 0 on success, -errno on failure

 Map the entire MMIO space of the AFU using the first context */

 No byte reverse on reading afu_version or string will be backwards */

 Restore the LUN mappings */

/**

 * afu_reset() - resets the AFU

 * @cfg:	Internal structure associated with the host.

 *

 * Return: 0 on success, -errno on failure

	/* Stop the context before the reset. Since the context is

	 * no longer available restart it after the reset is complete

/**

 * drain_ioctls() - wait until all currently executing ioctls have completed

 * @cfg:	Internal structure associated with the host.

 *

 * Obtain write access to read/write semaphore that wraps ioctl

 * handling to 'drain' ioctls currently executing.

/**

 * cxlflash_async_reset_host() - asynchronous host reset handler

 * @data:	Private data provided while scheduling reset.

 * @cookie:	Cookie that can be used for checkpointing.

/**

 * cxlflash_schedule_async_reset() - schedule an asynchronous host reset

 * @cfg:	Internal structure associated with the host.

/**

 * send_afu_cmd() - builds and sends an internal AFU command

 * @afu:	AFU associated with the host.

 * @rcb:	Pre-populated IOARCB describing command to send.

 *

 * The AFU can only take one internal AFU command at a time. This limitation is

 * enforced by using a mutex to provide exclusive access to the AFU during the

 * operation. This design point requires calling threads to not be on interrupt

 * context due to the possibility of sleeping during concurrent AFU operations.

 *

 * The command status is optionally passed back to the caller when the caller

 * populates the IOASA field of the IOARCB with a pointer to an IOASA structure.

 *

 * Return:

 *	0 on success, -errno on failure

 Delete the command from pending_cmds list */

 to retry */

 to exit */

/**

 * cxlflash_afu_sync() - builds and sends an AFU sync command

 * @afu:	AFU associated with the host.

 * @ctx:	Identifies context requesting sync.

 * @res:	Identifies resource requesting sync.

 * @mode:	Type of sync to issue (lightweight, heavyweight, global).

 *

 * AFU sync operations are only necessary and allowed when the device is

 * operating normally. When not operating normally, sync requests can occur as

 * part of cleaning up resources associated with an adapter prior to removal.

 * In this scenario, these requests are simply ignored (safe due to the AFU

 * going away).

 *

 * Return:

 *	0 on success, -errno on failure

/**

 * cxlflash_eh_abort_handler() - abort a SCSI command

 * @scp:	SCSI command to abort.

 *

 * CXL Flash devices do not support a single command abort. Reset the context

 * as per SISLite specification. Flush any pending commands in the hardware

 * queue before the reset.

 *

 * Return: SUCCESS/FAILED as defined in scsi/scsi.h

	/* When the state is not normal, another reset/reload is in progress.

	 * Return failed and the mid-layer will invoke host reset handler.

/**

 * cxlflash_eh_device_reset_handler() - reset a single LUN

 * @scp:	SCSI command to send.

 *

 * Return:

 *	SUCCESS as defined in scsi/scsi.h

 *	FAILED as defined in scsi/scsi.h

/**

 * cxlflash_eh_host_reset_handler() - reset the host adapter

 * @scp:	SCSI command from stack identifying host.

 *

 * Following a reset, the state is evaluated again in case an EEH occurred

 * during the reset. In such a scenario, the host reset will either yield

 * until the EEH recovery is complete or return success or failure based

 * upon the current device state.

 *

 * Return:

 *	SUCCESS as defined in scsi/scsi.h

 *	FAILED as defined in scsi/scsi.h

/**

 * cxlflash_change_queue_depth() - change the queue depth for the device

 * @sdev:	SCSI device destined for queue depth change.

 * @qdepth:	Requested queue depth value to set.

 *

 * The requested queue depth is capped to the maximum supported value.

 *

 * Return: The actual queue depth set.

/**

 * cxlflash_show_port_status() - queries and presents the current port status

 * @port:	Desired port for status reporting.

 * @cfg:	Internal structure associated with the host.

 * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.

 *

 * Return: The size of the ASCII string returned in @buf or -EINVAL.

/**

 * port0_show() - queries and presents the current status of port 0

 * @dev:	Generic device associated with the host owning the port.

 * @attr:	Device attribute representing the port.

 * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.

 *

 * Return: The size of the ASCII string returned in @buf.

/**

 * port1_show() - queries and presents the current status of port 1

 * @dev:	Generic device associated with the host owning the port.

 * @attr:	Device attribute representing the port.

 * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.

 *

 * Return: The size of the ASCII string returned in @buf.

/**

 * port2_show() - queries and presents the current status of port 2

 * @dev:	Generic device associated with the host owning the port.

 * @attr:	Device attribute representing the port.

 * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.

 *

 * Return: The size of the ASCII string returned in @buf.

/**

 * port3_show() - queries and presents the current status of port 3

 * @dev:	Generic device associated with the host owning the port.

 * @attr:	Device attribute representing the port.

 * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.

 *

 * Return: The size of the ASCII string returned in @buf.

/**

 * lun_mode_show() - presents the current LUN mode of the host

 * @dev:	Generic device associated with the host.

 * @attr:	Device attribute representing the LUN mode.

 * @buf:	Buffer of length PAGE_SIZE to report back the LUN mode in ASCII.

 *

 * Return: The size of the ASCII string returned in @buf.

/**

 * lun_mode_store() - sets the LUN mode of the host

 * @dev:	Generic device associated with the host.

 * @attr:	Device attribute representing the LUN mode.

 * @buf:	Buffer of length PAGE_SIZE containing the LUN mode in ASCII.

 * @count:	Length of data resizing in @buf.

 *

 * The CXL Flash AFU supports a dummy LUN mode where the external

 * links and storage are not required. Space on the FPGA is used

 * to create 1 or 2 small LUNs which are presented to the system

 * as if they were a normal storage device. This feature is useful

 * during development and also provides manufacturing with a way

 * to test the AFU without an actual device.

 *

 * 0 = external LUN[s] (default)

 * 1 = internal LUN (1 x 64K, 512B blocks, id 0)

 * 2 = internal LUN (1 x 64K, 4K blocks, id 0)

 * 3 = internal LUN (2 x 32K, 512B blocks, ids 0,1)

 * 4 = internal LUN (2 x 32K, 4K blocks, ids 0,1)

 *

 * Return: The size of the ASCII string returned in @buf.

		/*

		 * When configured for internal LUN, there is only one channel,

		 * channel number 0, else there will be one less than the number

		 * of fc ports for this card.

/**

 * ioctl_version_show() - presents the current ioctl version of the host

 * @dev:	Generic device associated with the host.

 * @attr:	Device attribute representing the ioctl version.

 * @buf:	Buffer of length PAGE_SIZE to report back the ioctl version.

 *

 * Return: The size of the ASCII string returned in @buf.

/**

 * cxlflash_show_port_lun_table() - queries and presents the port LUN table

 * @port:	Desired port for status reporting.

 * @cfg:	Internal structure associated with the host.

 * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.

 *

 * Return: The size of the ASCII string returned in @buf or -EINVAL.

/**

 * port0_lun_table_show() - presents the current LUN table of port 0

 * @dev:	Generic device associated with the host owning the port.

 * @attr:	Device attribute representing the port.

 * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.

 *

 * Return: The size of the ASCII string returned in @buf.

/**

 * port1_lun_table_show() - presents the current LUN table of port 1

 * @dev:	Generic device associated with the host owning the port.

 * @attr:	Device attribute representing the port.

 * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.

 *

 * Return: The size of the ASCII string returned in @buf.

/**

 * port2_lun_table_show() - presents the current LUN table of port 2

 * @dev:	Generic device associated with the host owning the port.

 * @attr:	Device attribute representing the port.

 * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.

 *

 * Return: The size of the ASCII string returned in @buf.

/**

 * port3_lun_table_show() - presents the current LUN table of port 3

 * @dev:	Generic device associated with the host owning the port.

 * @attr:	Device attribute representing the port.

 * @buf:	Buffer of length PAGE_SIZE to report back port status in ASCII.

 *

 * Return: The size of the ASCII string returned in @buf.

/**

 * irqpoll_weight_show() - presents the current IRQ poll weight for the host

 * @dev:	Generic device associated with the host.

 * @attr:	Device attribute representing the IRQ poll weight.

 * @buf:	Buffer of length PAGE_SIZE to report back the current IRQ poll

 *		weight in ASCII.

 *

 * An IRQ poll weight of 0 indicates polling is disabled.

 *

 * Return: The size of the ASCII string returned in @buf.

/**

 * irqpoll_weight_store() - sets the current IRQ poll weight for the host

 * @dev:	Generic device associated with the host.

 * @attr:	Device attribute representing the IRQ poll weight.

 * @buf:	Buffer of length PAGE_SIZE containing the desired IRQ poll

 *		weight in ASCII.

 * @count:	Length of data resizing in @buf.

 *

 * An IRQ poll weight of 0 indicates polling is disabled.

 *

 * Return: The size of the ASCII string returned in @buf.

/**

 * num_hwqs_show() - presents the number of hardware queues for the host

 * @dev:	Generic device associated with the host.

 * @attr:	Device attribute representing the number of hardware queues.

 * @buf:	Buffer of length PAGE_SIZE to report back the number of hardware

 *		queues in ASCII.

 *

 * Return: The size of the ASCII string returned in @buf.

/**

 * num_hwqs_store() - sets the number of hardware queues for the host

 * @dev:	Generic device associated with the host.

 * @attr:	Device attribute representing the number of hardware queues.

 * @buf:	Buffer of length PAGE_SIZE containing the number of hardware

 *		queues in ASCII.

 * @count:	Length of data resizing in @buf.

 *

 * n > 0: num_hwqs = n

 * n = 0: num_hwqs = num_online_cpus()

 * n < 0: num_online_cpus() / abs(n)

 *

 * Return: The size of the ASCII string returned in @buf.

 Ideally should not happen */

/**

 * hwq_mode_show() - presents the HWQ steering mode for the host

 * @dev:	Generic device associated with the host.

 * @attr:	Device attribute representing the HWQ steering mode.

 * @buf:	Buffer of length PAGE_SIZE to report back the HWQ steering mode

 *		as a character string.

 *

 * Return: The size of the ASCII string returned in @buf.

/**

 * hwq_mode_store() - sets the HWQ steering mode for the host

 * @dev:	Generic device associated with the host.

 * @attr:	Device attribute representing the HWQ steering mode.

 * @buf:	Buffer of length PAGE_SIZE containing the HWQ steering mode

 *		as a character string.

 * @count:	Length of data resizing in @buf.

 *

 * rr = Round-Robin

 * tag = Block MQ Tagging

 * cpu = CPU Affinity

 *

 * Return: The size of the ASCII string returned in @buf.

/**

 * mode_show() - presents the current mode of the device

 * @dev:	Generic device associated with the device.

 * @attr:	Device attribute representing the device mode.

 * @buf:	Buffer of length PAGE_SIZE to report back the dev mode in ASCII.

 *

 * Return: The size of the ASCII string returned in @buf.

/*

 * Host attributes

/*

 * Device attributes

/*

 * Host template

 No scatter gather support */

/*

 * Device dependent values

/*

 * PCI device binding table

/**

 * cxlflash_worker_thread() - work thread handler for the AFU

 * @work:	Work structure contained within cxlflash associated with host.

 *

 * Handles the following events:

 * - Link reset which cannot be performed on interrupt context due to

 * blocking up to a few seconds

 * - Rescan the host

 Avoid MMIO if the device has failed */

 The reset can block... */

/**

 * cxlflash_chr_open() - character device open handler

 * @inode:	Device inode associated with this character device.

 * @file:	File pointer for this device.

 *

 * Only users with admin privileges are allowed to open the character device.

 *

 * Return: 0 on success, -errno on failure

/**

 * decode_hioctl() - translates encoded host ioctl to easily identifiable string

 * @cmd:        The host ioctl command to decode.

 *

 * Return: A string identifying the decoded host ioctl.

/**

 * cxlflash_lun_provision() - host LUN provisioning handler

 * @cfg:	Internal structure associated with the host.

 * @lunprov:	Kernel copy of userspace ioctl data structure.

 *

 * Return: 0 on success, -errno on failure

/**

 * cxlflash_afu_debug() - host AFU debug handler

 * @cfg:	Internal structure associated with the host.

 * @afu_dbg:	Kernel copy of userspace ioctl data structure.

 *

 * For debug requests requiring a data buffer, always provide an aligned

 * (cache line) buffer to the AFU to appease any alignment requirements.

 *

 * Return: 0 on success, -errno on failure

/**

 * cxlflash_chr_ioctl() - character device IOCTL handler

 * @file:	File pointer for this device.

 * @cmd:	IOCTL command.

 * @arg:	Userspace ioctl data structure.

 *

 * A read/write semaphore is used to implement a 'drain' of currently

 * running ioctls. The read semaphore is taken at the beginning of each

 * ioctl thread and released upon concluding execution. Additionally the

 * semaphore should be released and then reacquired in any ioctl execution

 * path which will wait for an event to occur that is outside the scope of

 * the ioctl (i.e. an adapter reset). To drain the ioctls currently running,

 * a thread simply needs to acquire the write semaphore.

 *

 * Return: 0 on success, -errno on failure

 NOTE: order matters here */

 Hold read semaphore so we can drain if needed */

 fall through to exit */

/*

 * Character device file operations

/**

 * init_chrdev() - initialize the character device for the host

 * @cfg:	Internal structure associated with the host.

 *

 * Return: 0 on success, -errno on failure

/**

 * cxlflash_probe() - PCI entry point to add host

 * @pdev:	PCI device associated with the host.

 * @dev_id:	PCI device id associated with device.

 *

 * The device will initially start out in a 'probing' state and

 * transition to the 'normal' state at the end of a successful

 * probe. Should an EEH event occur during probe, the notification

 * thread (error_detected()) will wait until the probe handler

 * is nearly complete. At that time, the device will be moved to

 * a 'probed' state and the EEH thread woken up to drive the slot

 * reset and recovery (device moves to 'normal' state). Meanwhile,

 * the probe will be allowed to exit successfully.

 *

 * Return: 0 on success, -errno on failure

	/*

	 * Promoted LUNs move to the top of the LUN table. The rest stay on

	 * the bottom half. The bottom half grows from the end (index = 255),

	 * whereas the top half grows from the beginning (index = 0).

	 *

	 * Initialize the last LUN index for all possible ports.

/**

 * cxlflash_pci_error_detected() - called when a PCI error is detected

 * @pdev:	PCI device struct.

 * @state:	PCI channel state.

 *

 * When an EEH occurs during an active reset, wait until the reset is

 * complete and then take action based upon the device state.

 *

 * Return: PCI_ERS_RESULT_NEED_RESET or PCI_ERS_RESULT_DISCONNECT

/**

 * cxlflash_pci_slot_reset() - called when PCI slot has been reset

 * @pdev:	PCI device struct.

 *

 * This routine is called by the pci error recovery code after the PCI

 * slot has been reset, just before we should resume normal operations.

 *

 * Return: PCI_ERS_RESULT_RECOVERED or PCI_ERS_RESULT_DISCONNECT

/**

 * cxlflash_pci_resume() - called when normal operation can resume

 * @pdev:	PCI device struct

/**

 * cxlflash_devnode() - provides devtmpfs for devices in the cxlflash class

 * @dev:	Character device.

 * @mode:	Mode that can be used to verify access.

 *

 * Return: Allocated string describing the devtmpfs structure.

/**

 * cxlflash_class_init() - create character device class

 *

 * Return: 0 on success, -errno on failure

/**

 * cxlflash_class_exit() - destroy character device class

/*

 * PCI device structure

/**

 * init_cxlflash() - module entry point

 *

 * Return: 0 on success, -errno on failure

/**

 * exit_cxlflash() - module exit point

/*

 * PMC-Sierra SPCv/ve 8088/8089 SAS/SATA based host adapters driver

 *

 * Copyright (c) 2008-2009 PMC-Sierra, Inc.,

 * All rights reserved.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions

 * are met:

 * 1. Redistributions of source code must retain the above copyright

 * notice, this list of conditions, and the following disclaimer,

 * without modification.

 * 2. Redistributions in binary form must reproduce at minimum a disclaimer

 * substantially similar to the "NO WARRANTY" disclaimer below

 * ("Disclaimer") and any redistribution must be conditioned upon

 * including a substantially similar Disclaimer requirement for further

 * binary redistribution.

 * 3. Neither the names of the above-listed copyright holders nor the names

 * of any contributors may be used to endorse or promote products derived

 * from this software without specific prior written permission.

 *

 * Alternatively, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") version 2 as published by the Free

 * Software Foundation.

 *

 * NO WARRANTY

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR

 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS

 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)

 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,

 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING

 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE

 * POSSIBILITY OF SUCH DAMAGES.

 *

 confirm the setting is written */

 1 sec */

 initialize variables for very first call from host application */

 Write signature to fatal dump table */

 start to get data */

 Program the MEMBASE II Shifting Register with 0x00.*/

 Read until accum_len is retrieved */

	/* Determine length of data between previously stored transfer length

	 * and current accumulated transfer length

 If accumulated length failed to read correctly fail the attempt.*/

 If accumulated length is zero fail the attempt */

 Accumulated length is good so start capturing the first data */

		/* If data to read is less than SYSFS_OFFSET then reduce the

		 * length of dataLen

 Data is in bar, copy to host memory */

 Increment the MEMBASE II Shifting Register value by 0x100.*/

		/* store previous accumulated length before triggering next

		 * accumulated length update

 continue capturing the fatal log until Dump status is 0x3 */

 reset fddstat bit by writing to zero*/

			/* set dump control value to '1' so that new data will

			 * be transferred to shared memory

Poll FDDHSHK  until clear */

 2 sec */

 Fail the dump if a timeout occurs */

			/* Poll status register until set to 2 or

			 * 3 for up to 2 seconds

 2 sec */

 Fail the dump if a timeout occurs */

 reset fatal_forensic_shift_offset back to zero and reset MEMBASE 2 register to zero */

 location in 64k region */

 Read the next block of the debug data.*/

/* pm80xx_get_non_fatal_dump - dump the nonfatal data from the dma

 * location by the firmware.

		/*

		 * Step 1: Write the host buffer parameters in the MPI Fatal and

		 * Non-Fatal Error Dump Capture Table.This is the buffer

		 * where debug data will be DMAed to.

		/* Optionally, set the DUMPCTRL bit to 1 if the host

		 * keeps sending active I/Os while capturing the non-fatal

		 * debug data. Otherwise, leave this bit set to zero

		/*

		 * Step 2: Clear Accumulative Length of Debug Data Transferred

		 * [ACCDDLEN] field in the MPI Fatal and Non-Fatal Error Dump

		 * Capture Table to zero.

 initiallize previous accumulated length to 0 */

	/*

	 * Step 3:Clear Fatal/Non-Fatal Debug Data Transfer Status [FDDTSTAT]

	 * field and then request that the SPCv controller transfer the debug

	 * data by setting bit 7 of the Inbound Doorbell Set Register.

	/*

	 * Step 4.1: Read back the Inbound Doorbell Set Register (by polling for

	 * 2 seconds) until register bit 7 is cleared.

	 * This step only indicates the request is accepted by the controller.

 2 sec */

	/* Step 4.2: To check the completion of the transfer, poll the Fatal/Non

	 * Fatal Debug Data Transfer Status [FDDTSTAT] field for 2 seconds in

	 * the MPI Fatal and Non-Fatal Error Dump Capture Table.

 2 sec */

	/* store current accumulated length to use in next iteration as

	 * the previous accumulated length

/**

 * read_main_config_table - read the configure table and save it.

 * @pm8001_ha: our hba card information

 read Error Dump Offset and Length */

 read GPIO LED settings from the configuration table */

 read analog Setting offset from the configuration table */

 read port recover and reset timeout */

 read ILA and inactive firmware version */

/**

 * read_general_status_table - read the general status table and save it.

 * @pm8001_ha: our hba card information

/**

 * read_phy_attr_table - read the phy attribute table and save it.

 * @pm8001_ha: our hba card information

/**

 * read_inbnd_queue_table - read the inbound queue table and save it.

 * @pm8001_ha: our hba card information

/**

 * read_outbnd_queue_table - read the outbound queue table and save it.

 * @pm8001_ha: our hba card information

/**

 * init_default_table_values - init the default table.

 * @pm8001_ha: our hba card information

 Disable end to end CRC checking */

 interrupt vector based on oq */

/**

 * update_main_config_table - update the main default table to the HBA.

 * @pm8001_ha: our hba card information

 Update Fatal error interrupt vector */

 SPCv specific */

 Set GPIOLED to 0x2 for LED indicator */

/**

 * update_inbnd_queue_table - update the inbound queue table to the HBA.

 * @pm8001_ha: our hba card information

 * @number: entry in the queue

/**

 * update_outbnd_queue_table - update the outbound queue table to the HBA.

 * @pm8001_ha: our hba card information

 * @number: entry in the queue

/**

 * mpi_init_check - check firmware initialization status.

 * @pm8001_ha: our hba card information

	/* Write bit0=1 to Inbound DoorBell Register to tell the SPC FW the

 wait until Inbound DoorBell Clear Register toggled */

 additional check */

 check the MPI-State for initialization up to 100ms*/

 100 msec */

 check MPI Initialization error */

/**

 * check_fw_ready - The LLDD check if the FW is ready, if not, return error.

 * This function sleeps hence it must not be used in atomic context.

 * @pm8001_ha: our hba card information

 reset / PCIe ready */

 100 milli sec */

 check ila, RAAE and iops status */

 3600 milli sec */

 3400 milli sec */

	/*

	 * lower 26 bits of SCRATCHPAD0 register describes offset within the

	 * PCIe BAR where the MPI configuration table is present

 scratch pad 0 TBL address */

	/*

	 * Upper 6 bits describe the offset within PCI config space where BAR

	 * is located.

	/*

	 * Make sure the offset falls inside the ioremapped PCI BAR

	/*

	 * Validate main configuration table address: first DWord should read

	 * "PMCS"

/**

 * pm80xx_set_thermal_config - support the thermal configuration

 * @pm8001_ha: our hba card information.

/**

* pm80xx_set_sas_protocol_timer_config - support the SAS Protocol

* Timer configuration page

* @pm8001_ha: our hba card information.

/**

 * pm80xx_get_encrypt_info - Check for encryption

 * @pm8001_ha: our hba card information.

 Read encryption status from SCRATCH PAD 3 */

/**

 * pm80xx_encrypt_update - update flash with encryption information

 * @pm8001_ha: our hba card information.

	/* Currently only one key is used. New KEK index is 1.

	 * Current KEK index is 1. Store KEK to NVRAM is 1.

/**

 * pm80xx_chip_init - the main init function that initializes whole PM8001 chip.

 * @pm8001_ha: our hba card information

 check the firmware status */

 Initialize the controller fatal error flag */

 Initialize pci space address eg: mpi offset */

 update main config table ,inbound table and outbound table */

 notify firmware update finished and check initialization status */

 send SAS protocol timer configuration page to FW */

 Check for encryption */

	/* Write bit1=1 to Inbound DoorBell Register to tell the SPC FW the

 wait until Inbound DoorBell Clear Register toggled */

 check the MPI-State for termination in progress */

 wait until Inbound DoorBell Clear Register toggled */

 2 sec for spcv/ve */

/**

 * pm80xx_fatal_errors - returns non-zero *ONLY* when fatal errors

 * @pm8001_ha: our hba card information

 *

 * Fatal errors are recoverable only after a host reboot.

/**

 * pm80xx_chip_soft_rst - soft reset the PM8001 chip, so that all

 * FW register status are reset to the originated status.

 * @pm8001_ha: our hba card information

 Process MPI table uninitialization only if FW is ready */

 Check if MPI is in ready state to reset */

			/* if things aren't ready but the bootloader is ok then

			 * try the reset anyway.

 checked for reset register normal state; 0x0 */

 check bootloader is successfully executed or in HDA mode */

 check the firmware status after reset */

 check iButton feature support for motherboard controller */

 do SPCv chip reset. */

 Check this ..whether delay is required or no */

 delay 10 usec */

 wait for 20 msec until the firmware gets reloaded */

/**

 * pm80xx_chip_intx_interrupt_enable - enable PM8001 chip interrupt

 * @pm8001_ha: our hba card information

/**

 * pm80xx_chip_intx_interrupt_disable - disable PM8001 chip interrupt

 * @pm8001_ha: our hba card information

/**

 * pm80xx_chip_interrupt_enable - enable PM8001 chip interrupt

 * @pm8001_ha: our hba card information

 * @vec: interrupt number to enable

/**

 * pm80xx_chip_interrupt_disable - disable PM8001 chip interrupt

 * @pm8001_ha: our hba card information

 * @vec: interrupt number to disable

	/* allocate domain device by ourselves as libsas

	 * is not going to provide any

 construct read log FIS */

/**

 * mpi_ssp_completion - process the event that FW response to the SSP request.

 * @pm8001_ha: our hba card information

 * @piomb: the message contents of this outbound message.

 *

 * When FW has completed a ssp request for example a IO request, after it has

 * filled the SG data with the data, it will trigger this event representing

 * that he has finished the job; please check the corresponding buffer.

 * So we will tell the caller who maybe waiting the result to tell upper layer

 * that the task has been finished.

 Being completed by another */

 Print sas address of IO failed device */

 SSP Completion with error */

 Force the midlayer to retry */

 not allowed case. Therefore, return failed status */

 in order to force CPU ordering */

See the comments for mpi_ssp_completion */

 TBC: used default set values */

 not allowed case. Therefore, return failed status */

 in order to force CPU ordering */

See the comments for mpi_ssp_completion */

 Print sas address of IO failed device */

 check if response is for SEND READ LOG */

 set new bit for abort_all */

 clear bit for read log */

 Free the tag */

 following cases are to do cases */

 SATA Completion with error */

 not allowed case. Therefore, return failed status */

See the comments for mpi_ssp_completion */

 Check if this is NCQ error */

 find device using device id */

 send read log extension */

 TBC: used default set values */

 TBC: used default set values */

 not allowed case. Therefore, return failed status */

See the comments for mpi_ssp_completion */

 not allowed case. Therefore, return failed status */

 in order to force CPU ordering */

/**

 * pm80xx_hw_event_ack_req- For PM8001, some events need to acknowledge to FW.

 * @pm8001_ha: our hba card information

 * @Qnum: the outbound queue message number.

 * @SEA: source of event to ack

 * @port_id: port id.

 * @phyId: phy id.

 * @param0: parameter 0.

 * @param1: parameter 1.

/**

 * hw_event_sas_phy_up - FW tells me a SAS phy up event.

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

 delay a moment to wait for disk to spin up */

/**

 * hw_event_sata_phy_up - FW tells me a SATA phy up event.

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

/**

 * hw_event_phy_down - we should notify the libsas the phy is down.

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

/**

 * mpi_thermal_hw_event - a thermal hw event has come.

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

/**

 * mpi_hw_event - The hw event has come.

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

	/* the broadcast change primitive received, tell the LIBSAS this event

/**

 * mpi_phy_stop_resp - SPCv specific

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

/**

 * mpi_set_controller_config_resp - SPCv specific

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

/**

 * mpi_get_controller_config_resp - SPCv specific

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

/**

 * mpi_get_phy_profile_resp - SPCv specific

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

/**

 * mpi_flash_op_ext_resp - SPCv specific

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

/**

 * mpi_set_phy_profile_resp - SPCv specific

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

 status is FAILED */

/**

 * mpi_kek_management_resp - SPCv specific

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

/**

 * mpi_dek_management_resp - SPCv specific

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

/**

 * ssp_coalesced_comp_resp - SPCv specific

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

/**

 * process_one_iomb - process one outbound Queue memory block

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

This is for target*/

This is for target*/

 spcv specific commands */

		/* spurious interrupt during setup if kexec-ing and

		 * driver doing a doorbell access w/ the pre-kexec oq

		 * interrupt setup.

 process the outbound message */

 free the message from the outbound circular buffer */

 Update the producer index from SPC */

 OQ is empty */

 DMA_... to our direction translation. */

 UNSPECIFIED */

 OUTBOUND */

 INBOUND */

 NO TRANSFER */

 subtract crc */

/**

 * pm80xx_chip_smp_req - send an SMP task to FW

 * @pm8001_ha: our hba card information.

 * @ccb: the ccb information this request used.

	/*

	 * DMA-map SMP request, response buffers

 must be in dwords */

 INDIRECT MODE command settings. Use DMA */

		/* for SPCv indirect mode. Place the top 4 bytes of

 exclude top 4 bytes for SMP req header */

 exclude 4 bytes for SMP req header and CRC */

 DIRECT MODE */

/**

 * pm80xx_chip_ssp_io_req - send an SSP task to FW

 * @pm8001_ha: our hba card information.

 * @ccb: the ccb information this request used.

	/* data address domain added for spcv; set to 0 by host,

	 * used internally by controller

	 * 0 for SAS 1.1 and SAS 2.0 compatible TLR

 Check if encryption is set */

 enable encryption. 0 for SAS 1.1 and SAS 2.0 compatible TLR*/

 fill in PRD (scatter/gather) table, if any */

 Check 4G Boundary */

 XTS mode. All other fields are 0 */

 set tweak values. Should be the start lba */

 fill in PRD (scatter/gather) table, if any */

 Check 4G Boundary */

 no data*/

 DMA */

 PIO*/

 FPDMA */

 C=1: update ATA cmd reg */

 PM_PORT field shall be 0 */

 Check if encryption is set */

 set encryption bit */

 dad (bit 0-1) is 0 */

 fill in PRD (scatter/gather) table, if any */

 Check 4G Boundary */

 XTS mode. All other fields are 0 */

 set tweak values. Should be the start lba */

 dad (bit 0-1) is 0 */

 fill in PRD (scatter/gather) table, if any */

 Check 4G Boundary */

 scsi cdb */

 Check for read log for failed drive and return */

/**

 * pm80xx_chip_phy_start_req - start phy via PHY_START COMMAND

 * @pm8001_ha: our hba card information.

 * @phy_id: the phy id which we wanted to start up.

 SSC Disable and SAS Analog ST configuration */

	/*

	payload.ase_sh_lm_slr_phyid =

		cpu_to_le32(SSC_DISABLE_30 | SAS_ASE | SPINHOLD_DISABLE |

		LINKMODE_AUTO | LINKRATE_15 | LINKRATE_30 | LINKRATE_60 |

		phy_id);

	Have to add "SAS PHY Analog Setup SPASTI 1 Byte" Based on need

/**

 * pm80xx_chip_phy_stop_req - start phy via PHY_STOP COMMAND

 * @pm8001_ha: our hba card information.

 * @phy_id: the phy id which we wanted to start up.

/*

 * see comments on pm8001_mpi_reg_resp.

direct attached sata */

 stp*/

ssp or smp*/

/**

 * pm80xx_chip_phy_ctl_req - support the local phy operation

 * @pm8001_ha: our hba card information.

 * @phyId: the phy id which we wanted to operate

 * @phy_op: phy operation to request

/**

 * pm80xx_chip_isr - PM8001 isr handler.

 * @pm8001_ha: our hba card information.

 * @vec: irq number.

/*

 * PMC-Sierra PM8001/8081/8088/8089 SAS/SATA based host adapters driver

 *

 * Copyright (c) 2008-2009 USI Co., Ltd.

 * All rights reserved.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions

 * are met:

 * 1. Redistributions of source code must retain the above copyright

 *    notice, this list of conditions, and the following disclaimer,

 *    without modification.

 * 2. Redistributions in binary form must reproduce at minimum a disclaimer

 *    substantially similar to the "NO WARRANTY" disclaimer below

 *    ("Disclaimer") and any redistribution must be conditioned upon

 *    including a substantially similar Disclaimer requirement for further

 *    binary redistribution.

 * 3. Neither the names of the above-listed copyright holders nor the names

 *    of any contributors may be used to endorse or promote products derived

 *    from this software without specific prior written permission.

 *

 * Alternatively, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") version 2 as published by the Free

 * Software Foundation.

 *

 * NO WARRANTY

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR

 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS

 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)

 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,

 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING

 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE

 * POSSIBILITY OF SUCH DAMAGES.

 *

/**

 * pm8001_find_tag - from sas task to find out  tag that belongs to this task

 * @task: the task sent to the LLDD

 * @tag: the found tag associated with the task

/**

  * pm8001_tag_free - free the no more needed tag

  * @pm8001_ha: our hba struct

  * @tag: the found tag associated with the task

/**

  * pm8001_tag_alloc - allocate a empty tag for task used.

  * @pm8001_ha: our hba struct

  * @tag_out: the found empty tag .

/**

 * pm8001_mem_alloc - allocate memory for pm8001.

 * @pdev: pci device.

 * @virt_addr: the allocated virtual address

 * @pphys_addr: DMA address for this device

 * @pphys_addr_hi: the physical address high byte address.

 * @pphys_addr_lo: the physical address low byte address.

 * @mem_size: memory size.

 * @align: requested byte alignment

/**

  * pm8001_find_ha_by_dev - from domain device which come from sas layer to

  * find out our hba struct.

  * @dev: the domain device which from sas layer.

/**

  * pm8001_phy_control - this function should be registered to

  * sas_domain_function_template to provide libsas used, note: this is just

  * control the HBA phy rather than other expander phy if you want control

  * other phy, you should use SMP command.

  * @sas_phy: which phy in HBA phys.

  * @func: the operation.

  * @funcdata: always NULL.

/**

  * pm8001_scan_start - we should enable all HBA phys by sending the phy_start

  * command to HBA.

  * @shost: the scsi host data.

 SAS_RE_INITIALIZATION not available in SPCv/ve */

	/* give the phy enabling interrupt event time to come in (1s

 Wait for discovery to finish */

/**

  * pm8001_task_prep_smp - the dispatcher function, prepare data for smp task

  * @pm8001_ha: our hba card information

  * @ccb: the ccb which attached to smp task

/**

  * pm8001_task_prep_ata - the dispatcher function, prepare data for sata task

  * @pm8001_ha: our hba card information

  * @ccb: the ccb which attached to sata task

/**

  * pm8001_task_prep_ssp_tm - the dispatcher function, prepare task management data

  * @pm8001_ha: our hba card information

  * @ccb: the ccb which attached to TM

  * @tmf: the task management IU

/**

  * pm8001_task_prep_ssp - the dispatcher function, prepare ssp data for ssp task

  * @pm8001_ha: our hba card information

  * @ccb: the ccb which attached to ssp task

 Find the local port id that's attached to this device */

 Directly attached device */

/**

  * pm8001_task_exec - queue the task(ssp, smp && ata) to the hardware.

  * @task: the task to be execute.

  * @gfp_flags: gfp_flags.

  * @is_tmf: if it is task management task.

  * @tmf: the task management IU

 TODO: select normal or high priority */

/**

  * pm8001_queue_command - register for upper layer used, all IO commands sent

  * to HBA are from this interface.

  * @task: the task to be execute.

  * @gfp_flags: gfp_flags

/**

  * pm8001_ccb_task_free - free the sg for ssp and smp command, free the ccb.

  * @pm8001_ha: our hba card information

  * @ccb: the ccb which attached to ssp task

  * @task: the task to be free.

  * @ccb_idx: ccb index.

 do nothing */

/**

 * pm8001_alloc_dev - find a empty pm8001_device

 * @pm8001_ha: our hba card information

/**

  * pm8001_find_dev - find a matching pm8001_device

  * @pm8001_ha: our hba card information

  * @device_id: device ID to match against

/**

  * pm8001_dev_found_notify - libsas notify a device is found.

  * @dev: the device structure which sas layer used.

  *

  * when libsas find a sas domain device, it should tell the LLDD that

  * device is found, and then LLDD register this device to HBA firmware

  * by the command "OPC_INB_REG_DEV", after that the HBA will assign a

  * device ID(according to device's sas address) and returned it to LLDD. From

  * now on, we communicate with HBA FW with the device ID which HBA assigned

  * rather than sas address. it is the necessary step for our HBA but it is

  * the optional for other HBA driver.

 directly sata */

register this device to HBA*/

/**

  * pm8001_exec_internal_tmf_task - execute some task management commands.

  * @dev: the wanted device.

  * @tmf: which task management wanted to be take.

  * @para_len: para_len.

  * @parameter: ssp task parameter.

  *

  * when errors or exception happened, we may want to do something, for example

  * abort the issued task which result in this exception, it is done by calling

  * this function, note it is also with the task execute interface.

 Even TMF timed out, return direct. */

			/* no error, but return the number of bytes of

 Even TMF timed out, return direct. */

/**

  * pm8001_dev_gone_notify - see the comments for "pm8001_dev_found_notify"

  * @dev: the device structure which sas layer used.

 retry commands by ha, by task and/or by device */

 Force the midlayer to retry */

 in order to force CPU ordering */

/**

 * pm8001_I_T_nexus_reset() - reset the initiator/target connection

 * @dev: the device structure for the device to reset.

 *

 * Standard mandates link reset for ATA (type 0) and hard reset for

 * SSP (type 1), only for RECOVERY

/*

* This function handle the IT_NEXUS_XXX event or completion

* status code for SSP/SATA/SMP I/O request.

 send internal ssp/sata/smp abort command to FW */

 deregister the target device */

send phy reset to hard reset target */

 send internal ssp/sata/smp abort command to FW */

 deregister the target device */

send phy reset to hard reset target */

 mandatory SAM-3, the task reset the specified LUN*/

 If failed, fall-through I_T_Nexus reset */

 optional SAM-3 */

 The task is still in Lun, release it then */

 The task is not in Lun or failed, reset the phy */

  mandatory SAM-3, still need free task/ccb info, abort the specified task */

 If the controller is seeing fatal errors

 abort task will not get a response from the controller

 1. Set Device state as Recovery */

 2. Send Phy Control Hard Reset */

			/* In the case of the reset timeout/fail we still

			 * abort the command at the firmware. The assumption

			 * here is that the drive is off doing something so

			 * that it's not processing requests, and we want to

			 * avoid getting a completion for this and either

			 * leaking the task in libsas or losing the race and

			 * getting a double free.

				/* 3. Wait for Port Reset complete or

				 * Port reset TMO

			/*

			 * 4. SATA Abort ALL

			 * we wait for the task to be aborted so that the task

			 * is removed from the ccb. on success the caller is

			 * going to free the task.

 5. Set Device State as Operational */

 SMP */

/*

 * PMC-Sierra 8001/8081/8088/8089 SAS/SATA based host adapters driver

 *

 * Copyright (c) 2008-2009 USI Co., Ltd.

 * All rights reserved.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions

 * are met:

 * 1. Redistributions of source code must retain the above copyright

 *    notice, this list of conditions, and the following disclaimer,

 *    without modification.

 * 2. Redistributions in binary form must reproduce at minimum a disclaimer

 *    substantially similar to the "NO WARRANTY" disclaimer below

 *    ("Disclaimer") and any redistribution must be conditioned upon

 *    including a substantially similar Disclaimer requirement for further

 *    binary redistribution.

 * 3. Neither the names of the above-listed copyright holders nor the names

 *    of any contributors may be used to endorse or promote products derived

 *    from this software without specific prior written permission.

 *

 * Alternatively, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") version 2 as published by the Free

 * Software Foundation.

 *

 * NO WARRANTY

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR

 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS

 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)

 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,

 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING

 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE

 * POSSIBILITY OF SUCH DAMAGES.

 *

 scsi host attributes */

/**

 * pm8001_ctl_mpi_interface_rev_show - MPI interface revision number

 * @cdev: pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * controller_fatal_error_show - check controller is under fatal err

 * @cdev: pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * pm8001_ctl_fw_version_show - firmware version

 * @cdev: pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * pm8001_ctl_ila_version_show - ila version

 * @cdev: pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * pm8001_ctl_inactive_fw_version_show - Inactive firmware version number

 * @cdev: pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * pm8001_ctl_max_out_io_show - max outstanding io supported

 * @cdev: pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * pm8001_ctl_max_devices_show - max devices support

 * @cdev: pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * pm8001_ctl_max_sg_list_show - max sg list supported iff not 0.0 for no

 * hardware limitation

 * @cdev: pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * pm8001_ctl_sas_spec_support_show - sas spec supported

 * @cdev: pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

 fe000000 means supports SAS2.1 */

 fe000000 means supports SAS2.1 */

/**

 * pm8001_ctl_host_sas_address_show - sas address

 * @cdev: pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * This is the controller sas address

 *

 * A sysfs 'read-only' shost attribute.

/**

 * pm8001_ctl_logging_level_show - logging level

 * @cdev: pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs 'read/write' shost attribute.

/**

 * pm8001_ctl_aap_log_show - aap1 event log

 * @cdev: pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * pm8001_ctl_ib_queue_log_show - Out bound Queue log

 * @cdev:pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * pm8001_ctl_ob_queue_log_show - Out bound Queue log

 * @cdev:pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * pm8001_ctl_bios_version_show - Bios version Display

 * @cdev:pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf:the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * event_log_size_show - event log size

 * @cdev: pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs read  shost attribute.

/**

 * pm8001_ctl_iop_log_show - IOP event log

 * @cdev: pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * pm8001_ctl_fatal_log_show - fatal error logging

 * @cdev:pointer to embedded class device

 * @attr: device attribute

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * non_fatal_log_show - non fatal error logging

 * @cdev:pointer to embedded class device

 * @attr: device attribute

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * pm8001_ctl_gsm_log_show - gsm dump collection

 * @cdev:pointer to embedded class device

 * @attr: device attribute (unused)

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

 Last entry should be NULL. */

 Last entry err_code = 0. */

 IN */

 IN */

 OUT */

OUT */

		/* for the last chunk of data in case file size is not even with

	/* this test protects us from running two flash processes at once,

/**

 * ctl_mpi_state_show - controller MPI state check

 * @cdev: pointer to embedded class device

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * ctl_hmi_error_show - controller MPI initialization fails

 * @cdev: pointer to embedded class device

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * ctl_raae_count_show - controller raae count check

 * @cdev: pointer to embedded class device

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * ctl_iop0_count_show - controller iop0 count check

 * @cdev: pointer to embedded class device

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/**

 * ctl_iop1_count_show - controller iop1 count check

 * @cdev: pointer to embedded class device

 * @buf: the buffer returned

 *

 * A sysfs 'read-only' shost attribute.

/*

 * PMC-Sierra SPC 8001 SAS/SATA based host adapters driver

 *

 * Copyright (c) 2008-2009 USI Co., Ltd.

 * All rights reserved.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions

 * are met:

 * 1. Redistributions of source code must retain the above copyright

 *    notice, this list of conditions, and the following disclaimer,

 *    without modification.

 * 2. Redistributions in binary form must reproduce at minimum a disclaimer

 *    substantially similar to the "NO WARRANTY" disclaimer below

 *    ("Disclaimer") and any redistribution must be conditioned upon

 *    including a substantially similar Disclaimer requirement for further

 *    binary redistribution.

 * 3. Neither the names of the above-listed copyright holders nor the names

 *    of any contributors may be used to endorse or promote products derived

 *    from this software without specific prior written permission.

 *

 * Alternatively, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") version 2 as published by the Free

 * Software Foundation.

 *

 * NO WARRANTY

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR

 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS

 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)

 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,

 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING

 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE

 * POSSIBILITY OF SUCH DAMAGES.

 *

/**

 * read_main_config_table - read the configure table and save it.

 * @pm8001_ha: our hba card information

 read analog Setting offset from the configuration table */

 read Error Dump Offset and Length */

/**

 * read_general_status_table - read the general status table and save it.

 * @pm8001_ha: our hba card information

/**

 * read_inbnd_queue_table - read the inbound queue table and save it.

 * @pm8001_ha: our hba card information

/**

 * read_outbnd_queue_table - read the outbound queue table and save it.

 * @pm8001_ha: our hba card information

/**

 * init_default_table_values - init the default table.

 * @pm8001_ha: our hba card information

/**

 * update_main_config_table - update the main default table to the HBA.

 * @pm8001_ha: our hba card information

/**

 * update_inbnd_queue_table - update the inbound queue table to the HBA.

 * @pm8001_ha: our hba card information

 * @number: entry in the queue

/**

 * update_outbnd_queue_table - update the outbound queue table to the HBA.

 * @pm8001_ha: our hba card information

 * @number: entry in the queue

/**

 * pm8001_bar4_shift - function is called to shift BAR base address

 * @pm8001_ha : our hba card information

 * @shiftValue : shifting value in memory bar.

 program the inbound AXI translation Lower Address */

 confirm the setting is written */

 1 sec */

/**

 * mpi_set_phys_g3_with_ssc

 * @pm8001_ha: our hba card information

 * @SSCbit: set SSCbit to 0 to disable all phys ssc; 1 to enable all phys ssc.

   /*

    * Using shifted destination address 0x3_0000:0x1074 + 0x4000*N (N=0:3)

    * Using shifted destination address 0x4_0000:0x1074 + 0x4000*(N-4) (N=4:7)

 shift membase 3 for SAS2_SETTINGS_LOCAL_PHY 4 - 7 */

	/*************************************************************

	Change the SSC upspreading value to 0x0 so that upspreading is disabled.

	Device MABC SMOD0 Controls

	Address: (via MEMBASE-III):

	Using shifted destination address 0x0_0000: with Offset 0xD8



	31:28 R/W Reserved Do not change

	27:24 R/W SAS_SMOD_SPRDUP 0000

	23:20 R/W SAS_SMOD_SPRDDN 0000

	19:0  R/W  Reserved Do not change

	Upon power-up this register will read as 0x8990c016,

	and I would like you to change the SAS_SMOD_SPRDUP bits to 0b0000

	so that the written value will be 0x8090c016.

	This will ensure only down-spreading SSC is enabled on the SPC.

set the shifted destination address to 0x0 to avoid error operation */

/**

 * mpi_set_open_retry_interval_reg

 * @pm8001_ha: our hba card information

 * @interval: interval time for each OPEN_REJECT (RETRY). The units are in 1us.

 shift bar and set the OPEN_REJECT(RETRY) interval time of PHY 0 -3.*/

set the shifted destination address to 0x0 to avoid error operation */

/**

 * mpi_init_check - check firmware initialization status.

 * @pm8001_ha: our hba card information

	/* Write bit0=1 to Inbound DoorBell Register to tell the SPC FW the

 wait until Inbound DoorBell Clear Register toggled */

 1 sec */

 check the MPI-State for initialization */

 check MPI Initialization error */

/**

 * check_fw_ready - The LLDD check if the FW is ready, if not, return error.

 * @pm8001_ha: our hba card information

 check error state */

 check AAP error */

 error state */

 check IOP error */

 error state */

	/* bit 4-31 of scratch pad1 should be zeros if it is not

 error case */

	/* bit 2, 4-31 of scratch pad2 should be zeros if it is not

 error case */

 1 sec timeout */

 wait until scratch pad 1 and 2 registers in ready state  */

/**

 * pm8001_chip_init - the main init function that initialize whole PM8001 chip.

 * @pm8001_ha: our hba card information

	/* 8081 controllers need BAR shift to access MPI space

 check the firmware status */

 Initialize pci space address eg: mpi offset */

 update main config table ,inbound table and outbound table */

 8081 controller donot require these operations */

 7->130ms, 34->500ms, 119->1.5s */

 notify firmware update finished and check initialization status */

	/*This register is a 16-bit timer with a resolution of 1us. This is the

	timer used for interrupt delay/coalescing in the PCIe Application Layer.

	Zero is not a valid value. A value of 1 in the register will cause the

	interrupts to be normal. A value greater than 1 will cause coalescing

	/* Write bit1=1 to Inbound DoorBell Register to tell the SPC FW the

 wait until Inbound DoorBell Clear Register toggled */

 1 sec */

 check the MPI-State for termination in progress */

 wait until Inbound DoorBell Clear Register toggled */

 1 sec */

/**

 * soft_reset_ready_check - Function to check FW is ready for soft reset.

 * @pm8001_ha: our hba card information

 read the scratch pad 2 register bit 2 */

 Trigger NMI twice via RB6 */

 wait for 100 ms */

/**

 * pm8001_chip_soft_rst - soft reset the PM8001 chip, so that the clear all

 * the FW register status to the originated status.

 * @pm8001_ha: our hba card information

 for host scratch pad0 */

 step1: Check FW is ready for soft reset */

	/* step 2: clear NMI status register on AAP1 and IOP, write the same

 map 0x60000 to BAR4(0x20), BAR2(win) */

 map 0x70000 to BAR4(0x20), BAR2(win) */

 read the scratch pad 1 register bit 2 */

	/* set signature in host scratch pad0 register to tell SPC that the

 read required registers for confirmming */

 map 0x0700000 to BAR4(0x20), BAR2(win) */

 step 3: host read GSM Configuration and Reset register */

 Put those bits to low */

	/* GSM XCBI offset = 0x70 0000

	0x00 Bit 13 COM_SLV_SW_RSTB 1

	0x00 Bit 12 QSSP_SW_RSTB 1

	0x00 Bit 11 RAAE_SW_RSTB 1

	0x00 Bit 9 RB_1_SW_RSTB 1

	0x00 Bit 8 SM_SW_RSTB 1

 host write GSM Configuration and Reset register */

 step 4: */

 disable GSM - Read Address Parity Check */

 disable GSM - Write Address Parity Check */

 disable GSM - Write Data Parity Check */

 step 5: delay 10 usec */

 step 5-b: set GPIO-0 output control to tristate anyway */

 set GPIO-0 output control to tri-state */

 Step 6: Reset the IOP and AAP1 */

 map 0x00000 to BAR4(0x20), BAR2(win) */

 step 7: Reset the BDMA/OSSP */

 step 8: delay 10 usec */

 step 9: bring the BDMA and OSSP out of reset */

 step 10: delay 10 usec */

 step 11: reads and sets the GSM Configuration and Reset Register */

 map 0x0700000 to BAR4(0x20), BAR2(win) */

 Put those bits to high */

	/* GSM XCBI offset = 0x70 0000

	0x00 Bit 13 COM_SLV_SW_RSTB 1

	0x00 Bit 12 QSSP_SW_RSTB 1

	0x00 Bit 11 RAAE_SW_RSTB 1

	0x00 Bit 9   RB_1_SW_RSTB 1

	0x00 Bit 8   SM_SW_RSTB 1

 step 12: Restore GSM - Read Address Parity Check */

 just for debugging */

 Restore GSM - Write Address Parity Check */

 Restore GSM - Write Data Parity Check */

 step 13: bring the IOP and AAP1 out of reset */

 map 0x00000 to BAR4(0x20), BAR2(win) */

 step 14: delay 10 usec - Normal Mode */

 check Soft Reset Normal mode or Soft Reset HDA mode */

		/* step 15 (Normal Mode): wait until scratch pad1 register

 2 sec */

 step 16 (Normal) - Clear ODMR and ODCR */

		/* step 17 (Normal Mode): wait for the FW and IOP to get

 Wait for the SPC Configuration Table to be ready */

 return error if MPI Configuration Table not ready */

 return error if MPI Configuration Table not ready */

 do SPC chip reset. */

 delay 10 usec */

 bring chip reset out of reset */

 delay 10 usec */

 wait for 20 msec until the firmware gets reloaded */

/**

 * pm8001_chip_iounmap - which mapped when initialized.

 * @pm8001_ha: our hba card information

		/*

		** logical BARs for SPC:

		** bar 0 and 1 - logical BAR0

		** bar 2 and 3 - logical BAR1

		** bar4 - logical BAR2

		** bar5 - logical BAR3

		** Skip the appropriate assignments:

/**

 * pm8001_chip_intx_interrupt_enable - enable PM8001 chip interrupt

 * @pm8001_ha: our hba card information

/**

 * pm8001_chip_intx_interrupt_disable - disable PM8001 chip interrupt

 * @pm8001_ha: our hba card information

/**

 * pm8001_chip_msix_interrupt_enable - enable PM8001 chip interrupt

 * @pm8001_ha: our hba card information

 * @int_vec_idx: interrupt number to enable

/**

 * pm8001_chip_msix_interrupt_disable - disable PM8001 chip interrupt

 * @pm8001_ha: our hba card information

 * @int_vec_idx: interrupt number to disable

/**

 * pm8001_chip_interrupt_enable - enable PM8001 chip interrupt

 * @pm8001_ha: our hba card information

 * @vec: unused

/**

 * pm8001_chip_interrupt_disable - disable PM8001 chip interrupt

 * @pm8001_ha: our hba card information

 * @vec: unused

/**

 * pm8001_mpi_msg_free_get - get the free message buffer for transfer

 * inbound queue.

 * @circularQ: the inbound queue  we want to transfer to HBA.

 * @messageSize: the message size of this transfer, normally it is 64 bytes

 * @messagePtr: the pointer to message.

 only support single buffer */

 Checks is the requested message size can be allocated in this queue*/

 Stores the new consumer index */

 get memory IOMB buffer address */

 increment to next bcCount element */

	/* Adds that distance to the base of the region virtual address plus

/**

 * pm8001_mpi_build_cmd- build the message queue for transfer, update the PI to

 * FW to tell the fw to get this message from IOMB.

 * @pm8001_ha: our hba card information

 * @circularQ: the inbound queue we want to transfer to HBA.

 * @opCode: the operation code represents commands which LLDD and fw recognized.

 * @payload: the command payload of each operation command.

 * @nb: size in bytes of the command payload

 * @responseQueue: queue to interrupt on w/ command response (if any)

Build the header*/

Update the PI to the firmware*/

 Update the producer index from SPC */

 free the circular queue buffer elements associated with the message*/

 update the CI of outbound queue */

 Update the producer index from SPC*/

/**

 * pm8001_mpi_msg_consume- get the MPI message from outbound queue

 * message table.

 * @pm8001_ha: our hba card information

 * @circularQ: the outbound queue  table.

 * @messagePtr1: the message contents of this outbound message.

 * @pBC: the message size.

 If there are not-yet-delivered messages ... */

Get the pointer to the circular queue buffer element*/

 read header */

 update the CI of outbound queue */

 update the CI of outbound queue */

			/* spurious interrupt during setup if

			 * kexec-ing and driver doing a doorbell access

			 * with the pre-kexec oq interrupt setup

 Update the producer index from SPC */

 while we don't have any more not-yet-delivered message */

 report empty */

	/*

	 * So far, all users of this stash an associated structure here.

	 * If we get here, and this pointer is null, then the action

	 * was cancelled. This nullification happens when the device

	 * goes away.

 Most stash device structure */

 This one stashes the sas_task instead */

 Task still on lu */

 Task got completed by another */

 Search for a possible ccb that matches the task */

 Task got freed by another */

 Force the midlayer to retry */

 in order to force CPU ordering */

 This one stashes the sas_task instead */

 task on lu */

 Task got completed by another */

 Search for a possible ccb that matches the task */

 task on lu */

 Task got freed by another */

 task on lu */

 Snub completion */

 device misbehavior */

 task not on lu */

 Do we need to abort the task locally? */

 device misbehavior */

 check if tag is NULL */

complete sas task and update to top layer */

 complete the internal commands/non-sas task */

 Deregister all the device ids  */

	/* allocate domain device by ourselves as libsas

	 * is not going to provide any

 construct read log FIS */

/**

 * mpi_ssp_completion- process the event that FW response to the SSP request.

 * @pm8001_ha: our hba card information

 * @piomb: the message contents of this outbound message.

 *

 * When FW has completed a ssp request for example a IO request, after it has

 * filled the SG data with the data, it will trigger this event representing

 * that he has finished the job; please check the corresponding buffer.

 * So we will tell the caller who maybe waiting the result to tell upper layer

 * that the task has been finished.

 Being completed by another */

 Print sas address of IO failed device */

 SSP Completion with error */

 Force the midlayer to retry */

 not allowed case. Therefore, return failed status */

 in order to force CPU ordering */

See the comments for mpi_ssp_completion */

 not allowed case. Therefore, return failed status */

 in order to force CPU ordering */

See the comments for mpi_ssp_completion */

 Print sas address of IO failed device */

 check if response is for SEND READ LOG */

 set new bit for abort_all */

 clear bit for read log */

 Free the tag */

 following cases are to do cases */

 SATA Completion with error */

 not allowed case. Therefore, return failed status */

See the comments for mpi_ssp_completion */

 Check if this is NCQ error */

 find device using device id */

 send read log extension */

 not allowed case. Therefore, return failed status */

See the comments for mpi_ssp_completion */

 not allowed case. Therefore, return failed status */

 in order to force CPU ordering */

		/* We should free tag during failure also, the tag is not being

		 * freed by requesting path anywhere.

 indirect mode - IR bit set */

 Should not be happened*/

 direct mode */{

	/* Though fw_control_context is freed below, usrAddr still needs

	 * to be updated as this holds the response to the request function

	/* To avoid race condition, complete should be

	 * called after the message is copied to

	 * fw_control_context->usrAddr

/**

 * pm8001_bytes_dmaed - one of the interface function communication with libsas

 * @pm8001_ha: our hba card information

 * @i: which phy that received the event.

 *

 * when HBA driver received the identify done event or initiate FIS received

 * event(for SATA), it will invoke this function to notify the sas layer that

 * the sas toplogy has formed, please discover the the whole sas domain,

 * while receive a broadcast(change) primitive just tell the sas

 * layer to discover the changed domain rather than the whole domain.

Nothing*/

 Get the link rate speed  */

/**

 * pm8001_get_attached_sas_addr - extract/generate attached SAS address

 * @phy: pointer to asd_phy

 * @sas_addr: pointer to buffer where the SAS address is to be written

 *

 * This function extracts the SAS address from an IDENTIFY frame

 * received.  If OOB is SATA, then a SAS address is generated from the

 * HA tables.

 *

 * LOCKING: the frame_rcvd_lock needs to be held since this parses the frame

 * buffer.

 FIS device-to-host */

/**

 * pm8001_hw_event_ack_req- For PM8001,some events need to acknowage to FW.

 * @pm8001_ha: our hba card information

 * @Qnum: the outbound queue message number.

 * @SEA: source of event to ack

 * @port_id: port id.

 * @phyId: phy id.

 * @param0: parameter 0.

 * @param1: parameter 1.

/**

 * hw_event_sas_phy_up -FW tells me a SAS phy up event.

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

delay a moment to wait disk to spinup*/

/**

 * hw_event_sata_phy_up -FW tells me a SATA phy up event.

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

/**

 * hw_event_phy_down -we should notify the libsas the phy is down.

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

/**

 * pm8001_mpi_reg_resp -process register device ID response.

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

 *

 * when sas layer find a device it will notify LLDD, then the driver register

 * the domain device to FW, this event is the return device ID which the FW

 * has assigned, from now, inter-communication with FW is no longer using the

 * SAS address, use device ID which FW assigned.

/**

 * pm8001_mpi_fw_flash_update_resp - Response from FW for flash update command.

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

 retrieve device */

 clear the flag */

/**

 * mpi_hw_event -The hw event has come.

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

	/* the broadcast change primitive received, tell the LIBSAS this event

/**

 * process_one_iomb - process one outbound Queue memory block

 * @pm8001_ha: our hba card information

 * @piomb: IO message buffer

This is for target*/

This is for target*/

 process the outbound message */

 free the message from the outbound circular buffer */

 Update the producer index from SPC */

 OQ is empty */

 DMA_... to our direction translation. */

 UNSPECIFIED */

 OUTBOUND */

 INBOUND */

 NO TRANSFER */

/**

 * pm8001_chip_smp_req - send a SMP task to FW

 * @pm8001_ha: our hba card information.

 * @ccb: the ccb information this request used.

	/*

	 * DMA-map SMP request, response buffers

 must be in dwords */

/**

 * pm8001_chip_ssp_io_req - send a SSP task to FW

 * @pm8001_ha: our hba card information.

 * @ccb: the ccb information this request used.

		cpu_to_le32(data_dir_flags[task->data_dir] << 8 | 0x0);/*0 for

 fill in PRD (scatter/gather) table, if any */

 no data*/

 DMA */

 PIO*/

 FPDMA */

 C=1: update ATA cmd reg */

 PM_PORT field shall be 0 */

 fill in PRD (scatter/gather) table, if any */

 Check for read log for failed drive and return */

/**

 * pm8001_chip_phy_start_req - start phy via PHY_START COMMAND

 * @pm8001_ha: our hba card information.

 * @phy_id: the phy id which we wanted to start up.

	/*

	 ** [0:7]   PHY Identifier

	 ** [8:11]  link rate 1.5G, 3G, 6G

	 ** [12:13] link mode 01b SAS mode; 10b SATA mode; 11b both

	 ** [14]    0b disable spin up hold; 1b enable spin up hold

/**

 * pm8001_chip_phy_stop_req - start phy via PHY_STOP COMMAND

 * @pm8001_ha: our hba card information.

 * @phy_id: the phy id which we wanted to start up.

/*

 * see comments on pm8001_mpi_reg_resp.

direct attached sata */

 stp*/

ssp or smp*/

/*

 * see comments on pm8001_mpi_reg_resp.

/**

 * pm8001_chip_phy_ctl_req - support the local phy operation

 * @pm8001_ha: our hba card information.

 * @phyId: the phy id which we wanted to operate

 * @phy_op: the phy operation to request

/**

 * pm8001_chip_isr - PM8001 isr handler.

 * @pm8001_ha: our hba card information.

 * @vec: IRQ number

/*

 * pm8001_chip_abort_task - SAS abort task when error or exception happened.

 SMP */

/**

 * pm8001_chip_ssp_tm_req - built the task management command.

 * @pm8001_ha: our hba card information.

 * @ccb: the ccb information.

 * @tmf: task management function.

/**

 * pm8001_chip_fw_flash_update_build - support the firmware update operation

 * @pm8001_ha: our hba card information.

 * @fw_flash_updata_info: firmware flash update param

 * @tag: Tag to apply to the payload

 check max is 1 Mbytes */

 adjust length to dword boundary */

 xfr for non_dw */

 Shift back to BAR4 original address */

/*

 * PMC-Sierra PM8001/8081/8088/8089 SAS/SATA based host adapters driver

 *

 * Copyright (c) 2008-2009 USI Co., Ltd.

 * All rights reserved.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions

 * are met:

 * 1. Redistributions of source code must retain the above copyright

 *    notice, this list of conditions, and the following disclaimer,

 *    without modification.

 * 2. Redistributions in binary form must reproduce at minimum a disclaimer

 *    substantially similar to the "NO WARRANTY" disclaimer below

 *    ("Disclaimer") and any redistribution must be conditioned upon

 *    including a substantially similar Disclaimer requirement for further

 *    binary redistribution.

 * 3. Neither the names of the above-listed copyright holders nor the names

 *    of any contributors may be used to endorse or promote products derived

 *    from this software without specific prior written permission.

 *

 * Alternatively, this software may be distributed under the terms of the

 * GNU General Public License ("GPL") version 2 as published by the Free

 * Software Foundation.

 *

 * NO WARRANTY

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR

 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS

 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)

 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,

 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING

 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE

 * POSSIBILITY OF SUCH DAMAGES.

 *

/*

 * chip info structure to identify chip key functionality as

 * encryption available/not, no of ports, hw specific function ref

/*

 * The main structure which LLDD must register for scsi core.

/*

 * Sas layer call this function to execute specific task.

/**

 * pm8001_phy_init - initiate our adapter phys

 * @pm8001_ha: our hba structure.

 * @phy_id: phy id.

/**

 * pm8001_free - free hba

 * @pm8001_ha:	our hba structure.

/**

 * pm8001_tasklet() - tasklet for 64 msi-x interrupt handler

 * @opaque: the passed general host adapter struct

 * Note: pm8001_tasklet is common for pm8001 & pm80xx

/**

 * pm8001_interrupt_handler_msix - main MSIX interrupt handler.

 * It obtains the vector number and calls the equivalent bottom

 * half or services directly.

 * @irq: interrupt number

 * @opaque: the passed outbound queue/vector. Host structure is

 * retrieved from the same.

/**

 * pm8001_interrupt_handler_intx - main INTx interrupt handler.

 * @irq: interrupt number

 * @dev_id: sas_ha structure. The HBA is retrieved from sas_ha structure.

/**

 * pm8001_alloc - initiate our hba structure and 6 DMAs area.

 * @pm8001_ha: our hba structure.

 * @ent: PCI device ID structure to match on

 Setup Interrupt */

 Request Interrupt */

 Queues are chosen based on the number of cores/msix availability */

 MPI Memory region 1 for AAP Event Log for fw */

 MPI Memory region 2 for IOP Event Log for fw */

 MPI Memory region 3 for consumer Index of inbound queues */

 MPI Memory region 5 inbound queues */

 MPI Memory region 4 for producer Index of outbound queues */

 MPI Memory region 6 Outbound queues */

 MPI Memory region 6 Outbound queues */

 Memory region write DMA*/

 Memory region for fw flash */

 Memory region for devices*/

 Initialize tags */

/**

 * pm8001_ioremap - remap the pci high physical address to kernel virtual

 * address so that we can access them.

 * @pm8001_ha: our hba structure.

 map pci mem (PMC pci base 0-3)*/

		/*

		** logical BARs for SPC:

		** bar 0 and 1 - logical BAR0

		** bar 2 and 3 - logical BAR1

		** bar4 - logical BAR2

		** bar5 - logical BAR3

		** Skip the appropriate assignments:

/**

 * pm8001_pci_alloc - initialize our ha card structure

 * @pdev: pci device.

 * @ent: ent

 * @shost: scsi host struct which has been initialized before.

 IOMB size is 128 for 8088/89 controllers */

 Tasklet for non msi-x interrupt handler */

/**

 * pci_go_44 - pm8001 specified, its DMA is 44 bit rather than 64 bit

 * @pdev: pci device.

/**

 * pm8001_prep_sas_ha_init - allocate memory in general hba struct && init them.

 * @shost: scsi host which has been allocated outside.

 * @chip_info: our ha struct.

/**

 * pm8001_post_sas_ha_init - initialize general hba struct defined in libsas

 * @shost: scsi host which has been allocated outside

 * @chip_info: our ha struct.

/**

 * pm8001_init_sas_add - initialize sas address

 * @pm8001_ha: our ha struct.

 *

 * Currently we just set the fixed SAS address to our HBA, for manufacture,

 * it should read from the EEPROM

	/* For new SPC controllers WWN is stored in flash vpd

	*  For SPC/SPCve controllers WWN is stored in EEPROM

	*  For Older SPC WWN is stored in NVMD

/*

 * pm8001_get_phy_settings_info : Read phy setting values.

 * @pm8001_ha : our hba.

OPTION ROM FLASH read for the SPC cards */

 SAS ADDRESS read from flash / EEPROM */

 Read phy setting values from flash */

/**

 * pm8001_get_internal_phy_settings - Retrieves the internal PHY settings

 * @pm8001_ha : our adapter

 * @phycfg : PHY config page to populate

/**

 * pm8001_get_external_phy_settings - Retrieves the external PHY settings

 * @pm8001_ha : our adapter

 * @phycfg : PHY config page to populate

/**

 * pm8001_get_phy_mask - Retrieves the mask that denotes if a PHY is int/ext

 * @pm8001_ha : our adapter

 * @phymask : The PHY mask

 H1280 - 8 external 0 internal */

 H12F0 - 16 external 0 internal */

 H1208 - 0 external 8 internal */

 H120F - 0 external 16 internal */

 H1244 - 4 external 4 internal */

 H1248 - 4 external 8 internal */

 H1288 - 8 external 8 internal */

/**

 * pm8001_set_phy_settings_ven_117c_12G() - Configure ATTO 12Gb PHY settings

 * @pm8001_ha : our adapter

 Internal PHY */

 External PHY */

/**

 * pm8001_configure_phy_settings - Configures PHY settings based on vendor ID.

 * @pm8001_ha : our hba.

 6Gb */

/**

 * pm8001_setup_msix - enable MSI-X interrupt

 * @pm8001_ha: our ha struct.

 SPCv controllers supports 64 msi-x */

 Assigns the number of interrupts */

 Maximum queue number updating in HBA structure */

/**

 * pm8001_request_irq - register interrupt

 * @pm8001_ha: our ha struct.

 initialize the INT-X interrupt */

/**

 * pm8001_pci_probe - probe supported device

 * @pdev: pci device which kernel has been prepared for.

 * @ent: pci device id

 *

 * This function is the main initialization function, when register a new

 * pci driver it is invoked, all struct and hardware initialization should be

 * done here, also, register interrupt.

	/*

	 * Enable pci slot busmaster by setting pci command register.

	 * This is required by FW for Cyclone card.

 ent->driver variable is used to differentiate between controllers */

 setup thermal configuration. */

 phy setting support for motherboard controller */

/**

 * pm8001_init_ccb_tag - allocate memory to CCB and tag.

 * @pm8001_ha: our hba card information.

 * @shost: scsi host which has been allocated outside.

 * @pdev: pci device.

 Update to the scsi host*/

 Memory region for ccb_info*/

 For non-msix and msix interrupts */

/**

 * pm8001_pci_suspend - power management suspend main entry point

 * @dev: Device struct

 *

 * Return: 0 on success, anything else on error.

 For non-msix and msix interrupts */

/**

 * pm8001_pci_resume - power management resume main entry point

 * @dev: Device struct

 *

 * Return: 0 on success, anything else on error.

 chip soft rst only for spc */

 disable all the interrupt bits */

  Tasklet for non msi-x interrupt handler */

 Chip documentation for the 8070 and 8072 SPCv    */

 states that a 500ms minimum delay is required    */

 before issuing commands. Otherwise, the firmware */

 will enter an unrecoverable state.               */

 Spin up the PHYs */

/* update of pci device, vendor id and driver data with

 * unique value for each of the controller

 Support for SPC/SPCv/SPCve controllers */

 terminate list */

/**

 *	pm8001_init - initialize scsi transport template

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2015 Linaro Ltd.

 * Copyright (c) 2015 Hisilicon Limited.

/*

 * This function assumes linkrate mask fits in 8 bits, which it

 * does for all HW versions supported.

 It would be better to call dma_unmap_sg() here, but it's messy */

		/*

		 * libsas will use dev->port, should

		 * not call task_done for sata

 protect task_prep and start_delivery sequence */

 Nothing */

		/*

		 * send HARD RESET to clear previous affiliation of

		 * STP target port

 Wait for PHY up interrupt to occur */

 Wrapper to ensure we track hisi_sas_phy.enable properly */

 We may have been enabled already; if so, don't touch */

 Don't mark it as SAS_PHY_UNUSED if failed to clear ITCT */

 Even TMF timed out, return direct. */

					/*

					 * sync irq to avoid free'ing task

					 * before using task in IO completion

			/* no error, but return the number of bytes of

			 * underrun

 Update linkrate of directly attached device. */

 Report PHY state change to libsas */

 Try to find a SATA device */

 Init and wait for PHYs to come up and all libsas event finished. */

			/*

			 * sync irq to avoid free'ing task

			 * before using task in IO completion

		/*

		 * If the TMF finds that the IO is not in the device and also

		 * the internal abort does not succeed, then it is safe to

		 * free the slot.

		 * Note: if the internal abort succeeds then the slot

		 * will have already been completed

 SMP */

			/*

			 * sync irq to avoid free'ing task

			 * before using task in IO completion

 report PHY down if timed out */

		/*

		 * If in init state, we rely on caller to wait for link to be

		 * ready; otherwise, except phy reset is fail, delay.

 Clear internal IO and then lu reset */

 The task is still in Lun, release it then */

 The task is not in Lun or failed, reset the phy */

 simply get a slot and send abort command */

 send abort command to the chip */

/**

 * _hisi_sas_internal_task_abort -- execute an internal

 * abort command for single IO command or a device

 * @hisi_hba: host controller struct

 * @device: domain device

 * @abort_flag: mode of operation, device or single IO

 * @tag: tag of IO to be aborted (only relevant to single

 *       IO mode)

 * @dq: delivery queue for this internal abort command

 * @rst_to_recover: If rst_to_recover set, queue a controller

 *		    reset if an internal abort times out.

	/*

	 * The interface is not realized means this HW don't support internal

	 * abort, or don't need to do internal abort. Then here, we return

	 * TMF_RESP_FUNC_FAILED and let other steps go on, which depends that

	 * the internal abort has been executed and returned CQ.

 Internal abort timed out */

				/*

				 * sync irq to avoid free'ing task

				 * before using task in IO completion

 0 is complete, -1 is undelivered */

 Phy down but ready */

 Phy down and not ready */

 Completion queue structure */

 Delivery queue structure */

 Delivery queue */

 Completion queue */

 roundup to avoid overly large block size */

		/*

		 * These properties are only required for platform device-based

		 * controller with DT firmware.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2015 Linaro Ltd.

 * Copyright (c) 2015 Hisilicon Limited.

 global registers need init*/

 phy registers need init */

 HW dma structures */

 Delivery queue header */

 dw0 */

 dw1 */

 dw2 */

 dw3 */

 dw6 */

 Completion header */

 ITCT header */

 qw0 */

 qw1 */

 qw2 */

 Err record header */

 dw0 */

 dw1 */

 dw2 */

 dw3 */

 dma tx */

 0x0 */

 0x1 */

 0x2 */

 0x3 */

 0x4 */

 0x5 */

 0x6 */

 0x7 */

 0x8 */

 0x9 */

 dma rx */

 0x100 */

 0x101 */

 0x102 */

 0x103 */

 0x104 */

 0x105 */

 0x106 */

 0x107 */

 0x108 */

 0x109 */

 0x10a */

 0x10b */

 0x10c */

 trans tx */

 0x200 */

 0x201 */

 0x202 */

 0x203 */

 0x204 */

 0x205 */

 0x206 */

 0x207 */

 0x208 */

 0x209 */

 0x20a */

 0x20b */

 0x20c */

 0x20d */

 0x20e */

 0x20f */

 0x210 */

 0x211 */

 0x212 */

 0x213 */

 0x214 */

 0x215 */

 0x216 */

 0x217 */

 0x218 */

 0x219 */

 0x21a */

 0x21b */

 0x21c */

 0x21d */

 0x21e */

 0x21f */

 trans rx */

 0x300 */

 0x301 */

 0x302 */

 0x303 */

 0x304 */

 0x305 */

 0x306 */

 0x307 */

 0x308 */

 0x309 */

 0x30a */

 0x30b */

 0x30c */

 0x30d */

 0x30e */

 0x30f */

 0x310 */

 0x311 */

 0x312 */

 0x313 */

 0x314 */

 0x315 */

 0x316 */

 0x317 */

 0x318 */

 0x319 */

 0x31a */

 qw0 */

 qw1 */

 qw2 */

 free itct */

 It is safe to wait for 50us */

 Ensure DMA tx & rx idle */

 Ensure axi bus idle */

 Apply reset and disable clock */

 clk disable reg is offset by +4 bytes from clk enable reg */

 De-reset and enable clock */

 deassert rst reg is offset by +4 bytes from assert reg */

 Global registers init*/

 Delivery queue */

 Completion queue */

 itct */

 iost */

 breakpoint */

 DQ lock must be taken here */

	/*

	 * Ensure that memories for slots built on other CPUs is observed.

 req */

 create header */

 dw0 */

 high pri */

 ini mode */

 smp */

 map itct entry */

 dw2 */

 create header */

 ini mode */

 ssp */

 map itct entry */

 by default, task resp is complete */

 dma tx err */

 dma rx err */

 trans tx err */

 trans rx err */

 This will request a retry */

 Interrupts */

 Get the linkrate */

 mask_int0 */

 read int0 */

 write to zero */

		/* The completion queue and queue slot index are not

		 * necessarily the same as the delivery queue and

		 * queue slot index.

 update rd_point */

 Clear interrupt status */

 Unmask interrupt */

 bypass chip bug mask abnormal intr */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2017 Hisilicon Limited.

 global registers need init */

 phy registers requiring init */

 reset value, not reprogrammed */

 RAS registers need init */

 HW dma structures */

 Delivery queue header */

 dw0 */

 dw1 */

 dw2 */

 dw3 */

 dw6 */

 dw7 */

 Completion header */

 dw0 */

 abort_stat */

 dw1 */

 dw3 */

 ITCT header */

 qw0 */

 qw2 */

 dw0 */

 dw1 */

 dw2 */

 dw3 */

 permit overriding the host protection capabilities mask (EEDP/T10 PI) */

 Global registers init */

 used for 12G negotiate */

 get default FFE configuration for BIST */

 Delivery queue */

 Completion queue */

 itct */

 iost */

 breakpoint */

 SATA broken msg */

 SATA initial fis */

 RAS registers init */

 LED registers init */

 Configure blink generator rate A to 1Hz and B to 4Hz */

 qw0 */

 qw1 */

 qw2 */

 clear the itct interrupt state */

 clear the itct table */

 Disable all of the PHYs */

 Ensure axi bus idle */

	/*

	 * This DSM handles some hardware-related configurations:

	 * 1. Switch over to MSI error handling in kernel

	 * 2. BIOS *may* reset some register values through this method

	/*

	 * Ensure that memories for slots built on other CPUs is observed.

 ssp */

 map itct entry */

		/*

		 * For READ, we need length of info read to memory, while for

		 * WRITE we need length of data written to the disk.

 req */

 create header */

 dw0 */

 high pri */

 smp */

 map itct entry */

 dw2 */

 dw2 */

 dw3 */

 C=1: update ATA cmd reg */

 fill in command FIS */

 dw0 */

abort*/

 dw1 */

 dw7 */

 Check for SATA dev */

 check ERR bit of Status Register */

 phy up */

 phy bcast */

 phy down */

 loss dword sync */

 phy reset problem */

 invalid dword */

 disparity err */

 code violation error */

	/*

	 * Use SAS+TMF status codes

 this IO has been aborted by abort command */

 internal abort command complete */

		/*

		 * abort single IO, the controller can't find the IO

 check for erroneous completion */

 update rd_point */

 wait until bus idle */

 config those registers between enable and disable PHYs */

 disable PHY */

 update FFE */

 disable ALOS */

 disable loopback */

 enable ALOS */

 restore the linkrate */

 init OOB link rate as 1.5 Gbits */

 enable PHY */

 some preparations before bist test */

 set linkrate of bit test*/

 set code mode of bit test */

 set the bist init value */

 clear error bit */

 disable bist test and recover it */

 completion header size not fixed per HW version */

 completion header size not fixed per HW version */

		/*

		 * Data struct of IOST cache:

		 * Data[1]: BIT0~15: Table index

		 *	    Bit16:   Valid mask

		 * Data[2]~[9]: IOST table

		/*

		 * Data struct of ITCT cache:

		 * Data[1]: BIT0~15: Table index

		 *	    Bit16:   Valid mask

		 * Data[2]~[9]: ITCT table

 Create port dir and files */

 Create CQ dir and files */

 Create DQ dir and files */

 when FIFO_DUMP_FORVER, no need to check trigger_mode */

 Check the validity of trace FIFO configuration */

 Disable trace FIFO before update configuration */

 Update trace FIFO configuration */

 Enable trace FIFO after updated configuration */

 Disable trace FIFO before read data */

 Enable trace FIFO after read data */

 get default configuration for trace FIFO */

 New memory allocation must be locate before itct */

 create bist structures */

	/*

	 * For the situation that there are ATA disks connected with SAS

	 * controller, it additionally creates ata_port which will affect the

	 * child_count of hisi_hba->dev. Even if suspended all the disks,

	 * ata_port is still and the child_count of hisi_hba->dev is not 0.

	 * So use pm_suspend_ignore_children() to ignore the effect to

	 * hisi_hba->dev.

 instances of the controller */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2016 Linaro Ltd.

 * Copyright (c) 2016 Hisilicon Limited.

 global registers need init*/

 phy registers need init */

 HW dma structures */

 Delivery queue header */

 dw0 */

 dw1 */

 dw2 */

 dw3 */

 dw6 */

 Completion header */

 dw0 */

 abort_stat */

 dw1 */

 ITCT header */

 qw0 */

 2ms */

 qw2 */

 dw0 */

 dw1 */

 dw2 */

 dw3 */

 dw0 */

 dw1 */

 dw2 bit 15-0 */

 dw2 bit 31-16*/

 dw3 */

 trans tx*/

 0x0 */

 0x1 */

 0x2 */

 0x3 */

 0x4 */

 0x5 */

 0x6 */

 0x7 */

 0x8 */

 0x9 */

 0xa */

 0xb */

 0xc */

 0xd */

 0xe */

 0xf */

 0x10 */

 0x11 */

 0x12 */

 0x13 */

 0x14 */

 0x15 */

 0x16 for ssp*/

 0x17 */

 0x18 */

 0x19 */

 0x1a for ssp*/

 0x1b for ssp*/

IO_TX_ERR_WITH_R_ERR_RECEVIED, [> 0x1b for sata/stp<] */

 0x1c for ssp */

IO_RX_ERR_WITH_SATA_DEVICE_LOST 0x1c for sata/stp */

 0x1d for ssp/smp */

 0x1e */

IO_TX_ERR_WITH_SYNC_RXD, [> 0x1e <] for sata/stp */

 0x1f for sata/stp */

 trans rx */

 0x20 */

 0x21 for sata/stp */

 0x22 for ssp/smp */

IO_ERR_WITH_RXFIS_8B10B_CODE_ERR, [> 0x22 <] for sata/stp */

 0x23 for sata/stp */

 0x24 for sata/stp */

 0x25 for smp */

IO_ERR_WITH_RXFIS_TX SYNCP, [> 0x25 <] for sata/stp */

 0x26 for sata/stp*/

 0x27 */

 0x28 */

 0x29 */

 0x2a */

 0x2b */

 0x2c */

 0x2d */

 0x2e */

 0x2f */

 0x30 for ssp/smp */

 0x31 for ssp */

IO_RX_ERR_WITH_FIS_TOO_SHORT, [> 0x31 <] for sata/stp */

 0x32 for ssp*/

IO_RX_ERR_WITH_FIS_TOO_LONG, [> 0x32 <] for sata/stp */

 0x33 for ssp */

IO_RX_ERR_WITH_SATA_DEVICE_LOST, [> 0x33 <] for sata */

 0x34 */

 0x35 */

 0x36 */

 0x37 */

 0x38 */

 0x39 */

 0x3a */

 0x3b */

 0x3c */

 0x3d */

 0x3e */

 0x3f */

 dma tx */

 0x40 */

 0x41 */

 0x42 */

 0x43 */

 0x44 */

 0x45 */

 0x46 */

 0x47 */

 0x48 */

 0x49 */

 0x4a */

 sipc rx */

 0x50 */

 0x51 */

 0x52 */

 0x53 */

 0x54 */

 0x55 */

 0x56 */

 0x57 */

 0x58 */

 0x59 */

 0x5a */

 dma rx */

 0x60 */

 0x61 */

 0x62 */

 0x63 */

 0x64 */

 0x65 */

 0x66 */

 0x67 */

 0x68 */

 0x69 */

 0x6a */

 0x6b */

 0x6c */

 0x6d */

 0x6e */

 0x6f */

 0x70 */

 0x71 */

 0x72 */

 0x73 */

 0x74 */

 0x75 */

 0x76 */

 0x77 */

 0x78 */

 0x79 */

 This function needs to be protected from pre-emption. */

		/*

		 * STP link SoC bug workaround: index starts from 1.

		 * additionally, we can only allocate odd IPTT(1~4095)

		 * for SAS/SMP device.

		/*

		 * For SATA device: allocate even IPTT in this interval

		 * [64*(sata_idx+1), 64*(sata_idx+2)], then each SATA device

		 * own 32 IPTTs. IPTT 0 shall not be used duing to STP link

		 * SoC bug workaround. So we ignore the first 32 even IPTTs.

		/*

		  * SAS IPTT bit0 should be 1, and SATA IPTT bit0 should be 0.

		/*

		 * SATA device id bit0 should be 0

 qw0 */

 qw1 */

 qw2 */

 clear the itct interrupt state */

 need to set register twice to clear ITCT for v2 hw */

 SoC bug workaround */

 The mask needs to be set depending on the number of phys */

 Disable all of the PHYs */

 Ensure DMA tx & rx idle */

 Ensure axi bus idle */

 reset and disable clock*/

 De-reset and enable clock*/

 This function needs to be called after resetting SAS controller. */

 Global registers init */

 Deal with am-max-transmissions quirk */

 Else, use defaults -> do nothing */

 Get sas_phy_ctrl value to deal with TX FFE issue. */

 else, do nothing -> leave it how you found it */

 Delivery queue */

 Completion queue */

 itct */

 iost */

 breakpoint */

 SATA broken msg */

 SATA initial fis */

 Close axi bus. */

 Reset host controller. */

 Open axi bus. */

 loss dword syn, phy reset problem */

 disparity err, invalid dword */

 DQ lock must be taken here */

	/*

	 * Ensure that memories for slots built on other CPUs is observed.

 req */

 create header */

 dw0 */

 high pri */

 smp */

 map itct entry */

 dw2 */

 ssp */

 map itct entry */

 by default, task resp is complete */

 error in TX phase, the priority of error is: DW2 > DW0 */

 error in RX phase, the priority is: DW1 > DW3 > DW2 */

 not sure */

 This will request a retry */

 Use SAS+TMF status codes */

 this io has been aborted by abort command */

 internal abort command complete */

		/* abort single io, controller don't find

		 * the io need to abort

 Analyse error happens on which phase TX or RX */

 create header */

 dw0 */

 dw1 */

 dw2 */

 dw3 */

 C=1: update ATA cmd reg */

 fill in command FIS */

 Kick the hardware - send break command */

 setup the quirk timer */

 Set the timeout to 10ms less than internal abort timeout */

 dw0 */

abort*/

 dw1 */

 dw7 */

 phy up */

 phy down */

 phy up */

 phy down */

 Check for NCQ completion */

 The NCQ tags are held in the itct header */

 update rd_point */

 check ERR bit of Status Register */

 Make up some unique SAS address */

/*

 * There is a limitation in the hip06 chipset that we need

 * to map in all mbigen interrupts, even if they are not used.

 Phy up/down is irq1 */

 wait until bus idle */

			/*

			 * GPIO_TX[n] register has the highest numbered drive

			 * of the four in the first byte and the lowest

			 * numbered drive in the fourth byte.

			 * See SFF-8485 Rev. 0.7 Table 24.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

 BSG support for ELS/CT pass through */

 No FCP Priority config data in flash */

 Invalid FCP priority data header*/

 No valid FCP priority data entries */

 FCP priority data is valid */

 Get the sub command */

 Only set config is allowed if config memory is not allocated */

 validate fcp priority data */

			/* If buffer was invalidatic int

			 * fcp_prio_cfg is of no use

 pass through is supported only for ISP 4Gb or higher */

  Multiple SG's are not supported for ELS requests */

 ELS request for rport */

		/* make sure the rport is logged in,

		 * if not perform fabric login

		/* Allocate a dummy fcport structure, since functions

		 * preparing the IOCB and mailbox command retrieves port

		 * specific information from fcport structure. For Host based

		 * ELS commands there will be no fcport structure allocated

 Initialize all required  fields of fcport */

 Alloc SRB structure */

	/* Allocate a dummy fcport structure, since functions preparing the

	 * IOCB and mailbox command retrieves port specific information

	 * from fcport structure. For Host based ELS commands there will be

	 * no fcport structure allocated

 Initialize all required  fields of fcport */

 Alloc SRB structure */

 Disable loopback mode */

 Wait for DCBX complete event */

/*

 * Set the port configuration to enable the internal or external loopback

 * depending on the loopback mode.

 Wait for DCBX complete event */

		/*

		 * If the reset of the loopback mode doesn't work take a FCoE

		 * dump and reset the chip.

 Copy the request buffer in req_data now */

 Also reset the MPI */

				/* Revert back to original port config

				 * Also clear internal loopback

					/*

					 * If the reset of the loopback mode

					 * doesn't work take FCoE dump and then

					 * reset the chip.

 Set the isp82xx_no_md_cap not to capture minidump */

 Check the type of the adapter */

 Check if host is online */

 Check if cable is plugged in or not */

 Check if the switch is connected or not */

 Check if operating mode is P2P */

 Initialize all required  fields of fcport */

 Assign the self login loop id to fcport */

 Alloc SRB structure */

Populate srb->ctx with bidir ctx*/

 Add the read and write sg count */

 the bsg request  will be completed in the interrupt handler */

	/* Return an error vendor specific response

	 * and complete the bsg request

 Always return success, vendor rsp carries correct status */

 Copy the IOCB specific information */

 Dump the vendor information */

	/* Allocate a dummy fcport structure, since functions preparing the

	 * IOCB and mailbox command retrieves port specific information

	 * from fcport structure. For Host based ELS commands there will be

	 * no fcport structure allocated

 Alloc SRB structure */

 Initialize all required  fields of fcport */

 Copy the request buffer in req_data */

 Prepare response */

 Copy the request buffer in req_data */

 Copy stat type to work on it */

 Num of tgts connected to this host */

 unset BIT_17 */

 Total ini stats */

 Total number of entries */

 Copy the request buffer in req_data */

 structure + size for one entry */

 Copy the request buffer in req_data */

 Prepare response */

 In case no data transferred. */

 Disable port will bring down the chip, allow enable command */

 operation not permitted */

 find the bsg job from the active list of commands */

 Copy the request buffer in req_data */

 Copy the req_data in  request buffer */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

 terminate exchange */

 send ABTS response */

 include flipping bit23 in fctl */

/**

 * __qla_consume_iocb - this routine is used to tell fw driver has processed

 *   or consumed the head IOCB along with the continuation IOCB's from the

 *   provided respond queue.

 * @vha: host adapter pointer

 * @pkt: pointer to current packet.  On return, this pointer shall move

 *       to the next packet.

 * @rsp: respond queue pointer.

 *

 * it is assumed pkt is the head iocb, not the continuation iocbk

 flush signature */

/**

 * __qla_copy_purex_to_buffer - extract ELS payload from Purex IOCB

 *    and save to provided buffer

 * @vha: host adapter pointer

 * @pkt: pointer Purex IOCB

 * @rsp: respond queue

 * @buf: extracted ELS payload copy here

 * @buf_len: buffer length

	/*

	 * end of payload may not end in 4bytes boundary.  Need to

	 * round up / pad for room to swap, before saving data

 flush signature */

 flush signature */

/**

 * qla2100_intr_handler() - Process interrupts for the ISP2100 and ISP2200.

 * @irq: interrupt number

 * @dev_id: SCSI driver HA context

 *

 * Called by system whenever the host adapter generates an interrupt.

 *

 * Returns handled flag.

			/*

			 * Issue a "HARD" reset in order for the RISC interrupt

			 * bit to be cleared.  Schedule a big hammer to get

			 * out of the RISC PAUSED state.

 Get mailbox data. */

EMPTY*/

 Release mailbox registers. */

 Check for PCI disconnection */

/**

 * qla2300_intr_handler() - Process interrupts for the ISP23xx and ISP63xx.

 * @irq: interrupt number

 * @dev_id: SCSI driver HA context

 *

 * Called by system whenever the host adapter generates an interrupt.

 *

 * Returns handled flag.

			/*

			 * Issue a "HARD" reset in order for the RISC

			 * interrupt bit to be cleared.  Schedule a big

			 * hammer to get out of the RISC PAUSED state.

 Release mailbox registers. */

/**

 * qla2x00_mbx_completion() - Process mailbox command completions.

 * @vha: SCSI driver HA context

 * @mb0: Mailbox0 register

 Read all mbox registers? */

 Load return mailbox registers. */

 Seed data -- mailbox1 -> mailbox7. */

 Handle IDC Error completion case. */

 Acknowledgement needed? [Notify && non-zero timeout]. */

	/*

	 * 8200 AEN Interpretation:

	 * mb[0] = AEN code

	 * mb[1] = AEN Reason code

	 * mb[2] = LSW of Peg-Halt Status-1 Register

	 * mb[6] = MSW of Peg-Halt Status-1 Register

	 * mb[3] = LSW of Peg-Halt Status-2 register

	 * mb[7] = MSW of Peg-Halt Status-2 register

	 * mb[4] = IDC Device-State Register value

	 * mb[5] = IDC Driver-Presence Register value

			/*

			 * IDC_PEG_HALT_STATUS_CHANGE interpretation:

			 *  - PEG-Halt Status-1 Register:

			 *	(LSW = mb[2], MSW = mb[6])

			 *	Bits 0-7   = protocol-engine ID

			 *	Bits 8-28  = f/w error code

			 *	Bits 29-31 = Error-level

			 *	    Error-level 0x1 = Non-Fatal error

			 *	    Error-level 0x2 = Recoverable Fatal error

			 *	    Error-level 0x4 = UnRecoverable Fatal error

			 *  - PEG-Halt Status-2 Register:

			 *	(LSW = mb[3], MSW = mb[7])

			/*

			 * IDC_NIC_FW_REPORTED_FAILURE interpretation:

			 *  - PEG-to-FC Status Register:

			 *	(LSW = mb[2], MSW = mb[6])

			 *	Bits 0-7   = Peg-Firmware state

			 *	Bit 8      = N/W Interface Link-up

			 *	Bit 9      = N/W Interface signal detected

			 *	Bits 10-11 = SFP Status

			 *	  SFP Status 0x0 = SFP+ transceiver not expected

			 *	  SFP Status 0x1 = SFP+ transceiver not present

			 *	  SFP Status 0x2 = SFP+ transceiver invalid

			 *	  SFP Status 0x3 = SFP+ transceiver present and

			 *	  valid

			 *	Bits 12-14 = Heartbeat Counter

			 *	Bit 15     = Heartbeat Monitor Enable

			 *	Bits 16-17 = SFP Additional Info

			 *	  SFP info 0x0 = Unregocnized transceiver for

			 *	  Ethernet

			 *	  SFP info 0x1 = SFP+ brand validation failed

			 *	  SFP info 0x2 = SFP+ speed validation failed

			 *	  SFP info 0x3 = SFP+ access error

			 *	Bit 18     = SFP Multirate

			 *	Bit 19     = SFP Tx Fault

			 *	Bits 20-22 = Link Speed

			 *	Bits 23-27 = Reserved

			 *	Bits 28-30 = DCBX Status

			 *	  DCBX Status 0x0 = DCBX Disabled

			 *	  DCBX Status 0x1 = DCBX Enabled

			 *	  DCBX Status 0x2 = DCBX Exchange error

			 *	Bit 31     = Reserved

 Shall be called only on supported adapters. */

/**

 * qla24xx_copy_std_pkt() - Copy over purex ELS which is

 * contained in a single IOCB.

 * purex packet.

 * @vha: SCSI driver HA context

 * @pkt: ELS packet

/**

 * qla27xx_copy_fpin_pkt() - Copy over fpin packets that can

 * span over multiple IOCBs.

 * @vha: SCSI driver HA context

 * @pkt: ELS packet

 * @rsp: Response queue

/**

 * qla2x00_async_event() - Process aynchronous events.

 * @vha: SCSI driver HA context

 * @rsp: response queue

 * @mb: Mailbox registers (0 - 3)

 Setup to process RIO completion. */

 Fast Post */

 Reset */

 System Error */

 Check to see if MPI timeout occurred */

 Request Transfer Error */

 Response Transfer Error */

 Request Queue Wake-up */

 Loop Initialization Procedure */

 Loop Up Event */

 Loop Down Event */

			/*

			 * In case of loop down, restore WWPN from

			 * NVRAM in case of FA-WWPN capable ISP

			 * Restore for Physical Port only

 LIP reset occurred */

 case MBA_DCBX_COMPLETE: */

 Point-to-Point */

		/*

		 * Until there's a transition from loop down to loop up, treat

		 * this as loop down only.

 Change in connection mode */

 Port database update */

		/*

		 * Handle only global and vn-port update events

		 *

		 * Relevant inputs:

		 * mb[1] = N_Port handle of changed port

		 * OR 0xffff for global event

		 * mb[2] = New login state

		 * 7 = Port logged out

		 * mb[3] = LSB is vp_idx, 0xff = all vps

		 *

		 * Skip processing if:

		 *       Event is global, vp_idx is NOT all vps,

		 *           vp_idx does not match

		 *       Event is not global, vp_idx does not match

 use handle_cnt for loop id/nport handle */

 Port logout */

		/*

		 * If PORT UPDATE is global (received LIP_OCCURRED/LIP_RESET

		 * event etc. earlier indicating loop is down) then process

		 * it.  Otherwise ignore it and Wait for RSCN to come in.

		/*

		 * Mark all devices as missing so we will login again.

 State Change Registration */

 Check if the Vport has issued a SCR */

 Only handle SCNs for our Vport index. */

 Ignore reserved bits from RSCN-payload. */

 Skip RSCNs for virtual ports on the same physical port */

 case MBA_RIO_RESPONSE: */

				/*

				 * Extend loop down timer since port is active.

/**

 * qla2x00_process_completed_request() - Process a Fast Post response.

 * @vha: SCSI driver HA context

 * @req: request queue

 * @index: SRB index

 Validate handle. */

 Free outstanding command slot. */

 Save ISP completion status */

	    /*

	     * return FC_CTELS_STATUS_OK and leave the decoding of the ELS/CT

	     * fc payload  to the caller

	    /*

	     * borrowing sts_entry_24xx.comp_status.

	     * same location as ct_entry_24xx.comp_status

		/* borrowing sts_entry_24xx.comp_status.

		   same location as ct_entry_24xx.comp_status

	/* return FC_CTELS_STATUS_OK and leave the decoding of the ELS/CT

	 * fc payload  to the caller

			/*

			 * PLOGI/PRLI Completed. We must have Recv PLOGI/PRLI,

			 * Target side acked.

	/*

	 * State flags: Bit 6 and 0.

	 * If 0 is set, we don't care about 6.

	 * both cases resp was dma'd to host buffer

	 * if both are 0, that is good path case.

	 * if six is set and 0 is clear, we need to

	 * copy resp data from status iocb to resp buffer.

 Response already DMA'd to fd->rspaddr. */

		/*

		 * Non-zero value in first 12 bytes of NVMe_RSP IU, treat this

		 * as an error.

			/*

			 * Do not log if this is just an underflow and there

			 * is no data loss.

	/*

	 * If transport error then Failure (HBA rejects request)

	 * otherwise transport will handle.

 Process a single response queue entry. */

 Type Not Supported. */

/**

 * qla2x00_process_response_queue() - Process response queue entries.

 * @rsp: response queue

 Adjust ring index */

 Checksum */

 APPL identifier */

 Target LBA or indirect LBA */

/*

 * Checks the guard or meta-data for the type of error

 * detected by the HBA. In case of errors, we set the

 * ASC/ASCQ fields in the sense buffer with ILLEGAL_REQUEST

 * to indicate to the kernel that the HBA detected error.

	/*

	 * swab32 of the "data" field in the beginning of qla2x00_status_entry()

	 * would make guard field appear at offset 2

	/*

	 * Ignore sector if:

	 * For type     3: ref & app tag is all 'f's

	 * For type 0,1,2: app tag is all 'f's

 2TB boundary case covered automatically with this */

 Update protection tag */

 Patch the corresponding protection tags */

 check guard */

 check ref tag */

 check appl tag */

 Validate handle. */

 Free outstanding command slot. */

 Return the vendor specific reply to API */

	/* Always return DID_OK, bsg will send the vendor specific response

/**

 * qla2x00_status_entry() - Process a Status IOCB entry.

 * @vha: SCSI driver HA context

 * @rsp: response queue

 * @pkt: Entry pointer

 Check for invalid queue pointer */

 Validate handle. */

 NVME completion. */

 Task Management completion. */

 Fast path completion. */

 Check for any FCP transport errors. */

 Sense data lies beyond any FCP RESPONSE data. */

 Check for overrun. */

	/*

	 * Check retry_delay_timer value if we receive a busy or

	 * queue full.

	/*

	 * Based on Host and scsi status generate status code for Linux

 Use F/W calculated residual length. */

			/*

			 * scsi status of task set and busy are considered to be

			 * task not completed.

		/*

		 * Check to see if SCSI Status is non zero. If so report SCSI

		 * Status.

		/*

		 * We are going to have the fc class block the rport

		 * while we try to recover so instruct the mid layer

		 * to requeue until the class decides how to handle this.

/**

 * qla2x00_status_cont_entry() - Process a Status Continuations entry.

 * @rsp: response queue

 * @pkt: Entry pointer

 *

 * Extended sense data.

 Move sense data. */

 Place command on done queue. */

/**

 * qla2x00_error_entry() - Process an error entry.

 * @vha: SCSI driver HA context

 * @rsp: response queue

 * @pkt: Entry pointer

 * return : 1=allow further error analysis. 0=no additional error analysis.

/**

 * qla24xx_mbx_completion() - Process mailbox command completions.

 * @vha: SCSI driver HA context

 * @mb0: Mailbox0 register

 Read all mbox registers? */

 Load return mailbox registers. */

 Need to pass original sp */

/**

 * qla_chk_cont_iocb_avail - check for all continuation iocbs are available

 *   before iocb processing can start.

 * @vha: host adapter pointer

 * @rsp: respond queue

 * @pkt: head iocb describing how many continuation iocb

 * Return: 0 all iocbs has arrived, xx- all iocbs have not arrived.

 ring_index was pre-increment. set it back to current pkt */

  next pkt = end_pkt + 1 */

 rsp_q_in is either wrapped or pointing beyond endpkt */

 all IOCBs arrived. */

/**

 * qla24xx_process_response_queue() - Process response queue entries.

 * @vha: SCSI driver HA context

 * @rsp: response queue

 ensure that the ATIO queue is empty */

			/* Do nothing in this case, this check is to prevent it

			 * from falling into default case

 Type Not Supported. */

 Adjust ring index */

/**

 * qla24xx_intr_handler() - Process interrupts for the ISP23xx and ISP24xx.

 * @irq: interrupt number

 * @dev_id: SCSI driver HA context

 *

 * Called by system whenever the host adapter generates an interrupt.

 *

 * Returns handled flag.

 Interrupt handling helpers. */

 user wants to control IRQ setting for target mode */

 Recalculate queue values */

 ATIOQ needs 1 vector. That's 1 less QPair */

 Enable MSI-X vectors for the base queue */

	/*

	 * If target mode is enable, also request the vector for the ATIO

	 * queue.

 Enable MSI-X vector for response queue update for queue 0 */

 If possible, enable MSI-X. */

 Skip INTx on ISP82xx. */

 Set max_qpair to 0, as MSI-X and MSI in not enabled */

	/*

	 * We need to check that ha->rsp_q_map is valid in case we are called

	 * from a probe failure context.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2017 QLogic Corporation

 Allocate a queue for NVMe traffic */

 Map admin queue and 1st IO queue to index 0 */

 Use base qpair if max_qpairs is 0 */

 it assumed that QPair lock is held. */

	/*

	 * sp may not be valid after abort_command if return code is either

	 * SUCCESS or ERR_FROM_FW codes, so cache the value here.

	/*

	 * If async tmf is enabled, the abort callback is called only on

	 * return codes QLA_SUCCESS and QLA_ERR_FROM_FW.

	/*

	 * Returned before decreasing kref so that I/O requests

	 * are waited until ABTS complete. This kref is decreased

	 * at qla24xx_abort_sp_done function.

 kref_get was done before work was schedule. */

 Alloc SRB structure */

 Setup qpair pointers */

 Acquire qpair specific lock */

 Build command packet. */

 Zero out remaining portion of packet. */

 Update entry type to indicate Command NVME IOCB */

 No data transfer how do we check buffer len == 0?? */

 Set BIT_13 of control flags for Async event */

 Set NPORT-ID */

 NVME RSP IU */

 NVME CNMD IU */

 One DSD is available in the Command Type NVME IOCB */

 Load data segments */

 Allocate additional continuation packets? */

			/*

			 * Five DSDs are available in the Continuation

			 * Type 1 IOCB.

 Adjust ring index */

 Set total entry count. */

 Adjust ring index. */

 ignore nvme async cmd due to long timeout */

 Set chip new ring index. */

 Post a command */

 nvme association has been torn down */

	/*

	 * If we know the dev is going away while the transport is still sending

	 * IO's return busy back to stall the IO Q.  This happens when the

	 * link goes away and fw hasn't notified us yet, but IO's are being

	 * returned. If the dev comes back quickly we won't exhaust the IO

	 * retry count at the core.

 Alloc SRB structure */

 Use Driver Specified Retry Count */

 Use specified response timeout */

 set it to 2 * r_a_tov in secs */

 reset event aborted */

 IOCB was cleaned */

 N_Port handle is not currently logged in */

 N_Port handle was logged out while waiting for ABTS to complete */

 Firmware found that the port name changed */

 BA_RJT was received for the ABTS */

 BA_RJT was received for the ABTS */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

 Find an empty slot and assign an vp_id */

	/*

	 * Wait for all pending activities to finish before removing vport from

	 * the list.

	 * Lock needs to be held for safe removal from the list (it

	 * ensures no active vp_list traversal while the vport is removed

	 * from the queue)

 Locate matching device in database. */

/*

 * qla2x00_mark_vp_devices_dead

 *	Updates fcport state when device goes offline.

 *

 * Input:

 *	ha = adapter block pointer.

 *	fcport = port structure pointer.

 *

 * Return:

 *	None.

 *

 * Context:

	/*

	 * !!! NOTE !!!

	 * This function, if called in contexts other than vp create, disable

	 * or delete, please make sure this is synchronized with the

	 * delete thread.

 delete sessions and flush sa_indexes */

 Remove port id from vp target map */

 Check if physical ha port is Up */

 Initialize the new vport unless it is a persistent port */

 Corresponds to SCR enabled */

	/*

	 * To exclusively reset vport, we need to log it out first.

	 * Note: This control_vp can fail if ISP reset is already

	 * issued, this is expected, as the vp would be already

	 * logged out due to ISP reset.

	/*

	 * Physical port will do most of the abort and recovery work. We can

	 * just treat it as a loop down

 Check if Fw is ready to configure VP first */

 VP acquired. complete port configuration */

 Check up the F/W and H/W support NPIV */

 Check up whether npiv supported switch presented */

 Check up unique WWPN */

 Check up max-npiv-supports */

 New host info */

	/*

	 * To fix the issue of processing a parent's RSCN for the vport before

	 * its SCR is complete.

 Delete all queues for a given vhost */

 Delete request queues */

 Delete response queues */

 Use alternate PCI bus number */

 Use alternate PCI devfn */

 create response queue */

 Use alternate PCI bus number */

 Use alternate PCI devfn */

 Enable MSIX handshake mode on for uncapable adapters */

 Set option to indicate response queue creation */

 don't free sp here. Let the caller do the free */

/**

 * qla24xx_control_vp() - Enable a virtual port for given host

 * @vha:	adapter block pointer

 * @cmd:	command type to be sent for enable virtual port

 *

 * Return:	qla2xxx local function return status code.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

/**

 * qla2x00_prep_ms_iocb() - Prepare common MS/CT IOCB fields for SNS CT query.

 * @vha: HA context

 * @arg: CT arguments

 *

 * Returns a pointer to the @vha's ms_iocb.

/**

 * qla24xx_prep_ms_iocb() - Prepare common CT IOCB fields for SNS CT query.

 * @vha: HA context

 * @arg: CT arguments

 *

 * Returns a pointer to the @ha's ms_iocb.

/**

 * qla2x00_prep_ct_req() - Prepare common CT request fields for SNS query.

 * @p: CT request buffer

 * @cmd: GS command

 * @rsp_size: response size in bytes

 *

 * Returns a pointer to the intitialized @ct_req.

 Overrun? */

/**

 * qla2x00_ga_nxt() - SNS scan for fabric devices via GA_NXT command.

 * @vha: HA context

 * @fcport: fcport entry to updated

 *

 * Returns 0 on success.

 Issue GA_NXT */

 Prepare common MS IOCB */

 Prepare CT request */

 Prepare CT arguments -- port_id */

 Execute MS IOCB */

EMPTY*/

 Populate fc_port_t entry. */

/**

 * qla2x00_gid_pt() - SNS scan for fabric devices via GID_PT command.

 * @vha: HA context

 * @list: switch info entries to populate

 *

 * NOTE: Non-Nx_Ports are not requested.

 *

 * Returns 0 on success.

 Issue GID_PT */

 Prepare common MS IOCB */

 Prepare CT request */

 Prepare CT arguments -- port_type */

 Execute MS IOCB */

EMPTY*/

 Set port IDs in switch info list. */

 Last one exit. */

		/*

		 * If we've used all available slots, then the switch is

		 * reporting back more devices than we can handle with this

		 * single call.  Return a failed status, and let GA_NXT handle

		 * the overload.

/**

 * qla2x00_gpn_id() - SNS Get Port Name (GPN_ID) query.

 * @vha: HA context

 * @list: switch info entries to populate

 *

 * Returns 0 on success.

 Issue GPN_ID */

 Prepare common MS IOCB */

 Prepare CT request */

 Prepare CT arguments -- port_id */

 Execute MS IOCB */

EMPTY*/

 Save portname */

 Last device exit. */

/**

 * qla2x00_gnn_id() - SNS Get Node Name (GNN_ID) query.

 * @vha: HA context

 * @list: switch info entries to populate

 *

 * Returns 0 on success.

 Issue GNN_ID */

 Prepare common MS IOCB */

 Prepare CT request */

 Prepare CT arguments -- port_id */

 Execute MS IOCB */

EMPTY*/

 Save nodename */

 Last device exit. */

 please ignore kernel warning. otherwise, we have mem leak. */

/**

 * qla2x00_rft_id() - SNS Register FC-4 TYPEs (RFT_ID) supported by the HBA.

 * @vha: HA context

 *

 * Returns 0 on success.

 Prepare CT request */

 Prepare CT arguments -- port_id, FC-4 types */

 FCP-3 */

 NVMe type 28h */

/**

 * qla2x00_rff_id() - SNS Register FC-4 Features (RFF_ID) supported by the HBA.

 * @vha: HA context

 * @type: not used

 *

 * Returns 0 on success.

 Prepare CT request */

 Prepare CT arguments -- port_id, FC-4 feature, FC-4 type */

 SCSI - FCP */

/**

 * qla2x00_rnn_id() - SNS Register Node Name (RNN_ID) of the HBA.

 * @vha: HA context

 *

 * Returns 0 on success.

 Prepare CT request */

 Prepare CT arguments -- port_id, node_name */

/**

 * qla2x00_rsnn_nn() - SNS Register Symbolic Node Name (RSNN_NN) of the HBA.

 * @vha: HA context

 *

 * Returns 0 on success.

 Prepare CT request */

 Prepare CT arguments -- node_name, symbolic node_name, size */

 Prepare the Symbolic Node Name */

/**

 * qla2x00_prep_sns_cmd() - Prepare common SNS command request fields for query.

 * @vha: HA context

 * @cmd: GS command

 * @scmd_len: Subcommand length

 * @data_size: response size in bytes

 *

 * Returns a pointer to the @ha's sns_cmd.

 Size in 16bit words. */

 Size in 32bit words. */

/**

 * qla2x00_sns_ga_nxt() - SNS scan for fabric devices via GA_NXT command.

 * @vha: HA context

 * @fcport: fcport entry to updated

 *

 * This command uses the old Exectute SNS Command mailbox routine.

 *

 * Returns 0 on success.

 Issue GA_NXT. */

 Prepare SNS command request. */

 Prepare SNS command arguments -- port_id. */

 Execute SNS command. */

EMPTY*/

 Populate fc_port_t entry. */

/**

 * qla2x00_sns_gid_pt() - SNS scan for fabric devices via GID_PT command.

 * @vha: HA context

 * @list: switch info entries to populate

 *

 * This command uses the old Exectute SNS Command mailbox routine.

 *

 * NOTE: Non-Nx_Ports are not requested.

 *

 * Returns 0 on success.

 Issue GID_PT. */

 Prepare SNS command request. */

 Prepare SNS command arguments -- port_type. */

 Execute SNS command. */

EMPTY*/

 Set port IDs in switch info list. */

 Last one exit. */

		/*

		 * If we've used all available slots, then the switch is

		 * reporting back more devices that we can handle with this

		 * single call.  Return a failed status, and let GA_NXT handle

		 * the overload.

/**

 * qla2x00_sns_gpn_id() - SNS Get Port Name (GPN_ID) query.

 * @vha: HA context

 * @list: switch info entries to populate

 *

 * This command uses the old Exectute SNS Command mailbox routine.

 *

 * Returns 0 on success.

 Issue GPN_ID */

 Prepare SNS command request. */

 Prepare SNS command arguments -- port_id. */

 Execute SNS command. */

EMPTY*/

 Save portname */

 Last device exit. */

/**

 * qla2x00_sns_gnn_id() - SNS Get Node Name (GNN_ID) query.

 * @vha: HA context

 * @list: switch info entries to populate

 *

 * This command uses the old Exectute SNS Command mailbox routine.

 *

 * Returns 0 on success.

 Issue GNN_ID */

 Prepare SNS command request. */

 Prepare SNS command arguments -- port_id. */

 Execute SNS command. */

EMPTY*/

 Save nodename */

 Last device exit. */

/**

 * qla2x00_sns_rft_id() - SNS Register FC-4 TYPEs (RFT_ID) supported by the HBA.

 * @vha: HA context

 *

 * This command uses the old Exectute SNS Command mailbox routine.

 *

 * Returns 0 on success.

 Issue RFT_ID. */

 Prepare SNS command request. */

 Prepare SNS command arguments -- port_id, FC-4 types */

 FCP-3 */

 Execute SNS command. */

EMPTY*/

/**

 * qla2x00_sns_rnn_id() - SNS Register Node Name (RNN_ID) of the HBA.

 * @vha: HA context

 *

 * This command uses the old Exectute SNS Command mailbox routine.

 *

 * Returns 0 on success.

 Issue RNN_ID. */

 Prepare SNS command request. */

 Prepare SNS command arguments -- port_id, nodename. */

 Execute SNS command. */

EMPTY*/

/**

 * qla2x00_mgmt_svr_login() - Login to fabric Management Service.

 * @vha: HA context

 *

 * Returns 0 on success.

/**

 * qla2x00_prep_ms_fdmi_iocb() - Prepare common MS IOCB fields for FDMI query.

 * @vha: HA context

 * @req_size: request size in bytes

 * @rsp_size: response size in bytes

 *

 * Returns a pointer to the @ha's ms_iocb.

/**

 * qla24xx_prep_ms_fdmi_iocb() - Prepare common MS IOCB fields for FDMI query.

 * @vha: HA context

 * @req_size: request size in bytes

 * @rsp_size: response size in bytes

 *

 * Returns a pointer to the @ha's ms_iocb.

/**

 * qla2x00_prep_ct_fdmi_req() - Prepare common CT request fields for SNS query.

 * @p: CT request buffer

 * @cmd: GS command

 * @rsp_size: response size in bytes

 *

 * Returns a pointer to the intitialized @ct_req.

/**

 * qla2x00_hba_attributes() - perform HBA attributes registration

 * @vha: HA context

 * @entries: number of entries to use

 * @callopt: Option to issue extended or standard FDMI

 *           command parameter

 *

 * Returns 0 on success.

 Nodename. */

 Manufacturer. */

 Serial number. */

 Model name. */

 Model description. */

 Hardware version. */

 Driver version. */

 Option ROM version. */

 Firmware version */

 OS Name and Version */

 MAX CT Payload Length */

 Node Sybolic Name */

 Vendor Specific information */

 Num Ports */

 Fabric Name */

 BIOS Version */

 Vendor Identifier */

/**

 * qla2x00_port_attributes() - perform Port attributes registration

 * @vha: HA context

 * @entries: number of entries to use

 * @callopt: Option to issue extended or standard FDMI

 *           command parameter

 *

 * Returns 0 on success.

 FC4 types. */

 NVMe type 28h */

 Supported speed. */

 Current speed. */

 Max frame size. */

 OS device name. */

 Hostname. */

 Node Name */

 Port Name */

 Port Symbolic Name */

 Port Type */

 Supported Class of Service */

 Port Fabric Name */

 FC4_type */

 Port State */

 Number of Ports */

 Port Identifier */

 Smart SAN Service Category (Populate Smart SAN Initiator)*/

 Smart SAN GUID (NWWN+PWWN) */

 Smart SAN Version (populate "Smart SAN Version 1.0") */

 Smart SAN Product Name (Specify Adapter Model No) */

 Smart SAN Port Info (specify: 1=Physical, 2=NPIV, 3=SRIOV) */

 Smart SAN Security Support */

/**

 * qla2x00_fdmi_rhba() - perform RHBA FDMI registration

 * @vha: HA context

 * @callopt: Option to issue FDMI registration

 *

 * Returns 0 on success.

   Request size adjusted after CT preparation */

 Prepare CT request */

 Prepare FDMI command entries */

 Attribute count */

 Attribute block */

 Update MS request size. */

 Execute MS IOCB */

 Issue RPA */

 Prepare common MS IOCB */

 Prepare CT request */

 Prepare FDMI command arguments -- portname. */

 Execute MS IOCB */

EMPTY*/

/**

 * qla2x00_fdmi_rprt() - perform RPRT registration

 * @vha: HA context

 * @callopt: Option to issue extended or standard FDMI

 *           command parameter

 *

 * Returns 0 on success.

 Request size adjusted after CT preparation */

 Prepare CT request */

 Prepare FDMI command entries */

 Attribute count */

 Attribute block */

 Update MS request size. */

 Execute MS IOCB */

/**

 * qla2x00_fdmi_rpa() - perform RPA registration

 * @vha: HA context

 * @callopt: Option to issue FDMI registration

 *

 * Returns 0 on success.

 Request size adjusted after CT preparation */

 Prepare CT request */

 Prepare FDMI command entries. */

 Attribute count */

 Attribute block */

 Update MS request size. */

 Execute MS IOCB */

/**

 * qla2x00_fdmi_register() -

 * @vha: HA context

 *

 * Returns 0 on success.

 For npiv/vport send rprt only */

 Try fdmi2 first, if fails then try fdmi1 */

/**

 * qla2x00_gfpn_id() - SNS Get Fabric Port Name (GFPN_ID) query.

 * @vha: HA context

 * @list: switch info entries to populate

 *

 * Returns 0 on success.

 Issue GFPN_ID */

 Prepare common MS IOCB */

 Prepare CT request */

 Prepare CT arguments -- port_id */

 Execute MS IOCB */

EMPTY*/

 Save fabric portname */

 Last device exit. */

/**

 * qla2x00_gpsc() - FCS Get Port Speed Capabilities (GPSC) query.

 * @vha: HA context

 * @list: switch info entries to populate

 *

 * Returns 0 on success.

 Issue GFPN_ID */

 Prepare common MS IOCB */

 Prepare CT request */

 Prepare CT arguments -- port_name */

 Execute MS IOCB */

EMPTY*/

 FM command unsupported? */

 Last device exit. */

/**

 * qla2x00_gff_id() - SNS Get FC-4 Features (GFF_ID) query.

 *

 * @vha: HA context

 * @list: switch info entries to populate

 *

		/* Set default FC4 Type as UNKNOWN so the default is to

 Do not attempt GFF_ID if we are not FWI_2 capable */

 Prepare common MS IOCB */

 Prepare CT request */

 Prepare CT arguments -- port_id */

 Execute MS IOCB */

 Last device exit. */

 We will figure-out what happen after AUTH completes */

 target side must have changed it. */

 entry status error */

 CT_IU preamble  */

 GPSC req */

 cable is disconnected */

 cable is connected */

					/*

					 * 2 fcports with conflict Nport ID or

					 * an existing fcport is having nport ID

					 * conflict with new fcport.

 recheck session is still intact. */

					/* 2 fcports with conflict Nport ID or

					 * an existing fcport is having nport ID

					 * conflict with new fcport.

 create new fcport */

 There was another RSCN for this Nport ID */

 please ignore kernel warning. otherwise, we have mem leak. */

 Get WWPN with Nport ID. */

 CT_IU preamble  */

 GPN_ID req */

	/*

	 * FC-GS-7, 5.2.3.12 FC-4 Features - format

	 * The format of the FC-4 Features object, as defined by the FC-4,

	 * Shall be an array of 4-bit values, one for each type code value

 w1 b00:03 */

 w5 [00:03]/28h */

 Get FC4 Feature with Nport ID. */

 CT_IU preamble  */

 GPN_FT + GNN_FT*/

			/*

			 * Unable to scan any rports. logout loop below

			 * will unregister all sessions.

 Remove duplicate NPORT ID entries from switch data base */

 Bypass reserved domain fields. */

 Bypass virtual ports of the same host. */

			/*

			 * If device was not a fabric device before.

	/*

	 * Logout all previous fabric dev marked lost, except FCP2 devices.

				/* Cable got disconnected after we sent

				 * a login. Do delete to prevent timeout.

 Search if the fibre device supports FC4_TYPE_NVME */

						/*

						 * Supports FC-NVMe & FCP

 We found new FC-NVMe only port */

 gen2 field is holding the fc4type */

			/* switch is ignoring all commands.

			 * This might be a zone disable behavior.

			 * This means we hit 64s timeout.

			 * 22s GPNFT + 44s Abort = 64s

		/*

		 * We are in an Interrupt context, queue up this

		 * sp for GNNFT_DONE work. This will allow all

		 * the resource to get freed up.

 Cleanup here to prevent memory leak */

/*

 * Get WWNN list for fc4_type

 *

 * It is assumed the same SRB is re-used from GPNFT to avoid

 * mem free & re-alloc

 CT_IU preamble  */

 GPN_FT req */

 GNNFT */

 Get WWPN list for certain fc4_type */

 should not happen */

 CT_IU preamble  */

 GPN_FT req */

 GNN_ID */

 CT_IU preamble  */

 GNN_ID req */

 req & rsp use the same buffer */

 GPFN_ID */

 target side must have changed it. */

 CT_IU preamble  */

 GFPN_ID req */

 req & rsp use the same buffer */

 SPDX-License-Identifier: GPL-2.0-or-later

/*******************************************************************************

 * This file contains tcm implementation using v4 configfs fabric infrastructure

 * for QLogic target mode HBAs

 *

 * (c) Copyright 2010-2013 Datera, Inc.

 *

 * Author: Nicholas A. Bellinger <nab@daterainc.com>

 *

 * tcm_qla2xxx_parse_wwn() and tcm_qla2xxx_format_wwn() contains code from

 * the TCM_FC / Open-FCoE.org fabric module.

 *

 * Copyright (c) 2010 Cisco Systems, Inc

 *

/*

 * Parse WWN.

 * If strict, we require lower-case hex and colon separators to be sure

 * the name is the same as what would be generated by ft_format_wwn()

 * so the name and wwn are mapped one-to-one.

/*

 * From drivers/scsi/scsi_transport_fc.c:fc_parse_wwn

 Validate and store the new name */

/*

 * This parsing logic follows drivers/scsi/scsi_transport_fc.c:

 * store_fc_host_vport_create()

 count may include a LF at end of string */

 validate we have enough characters for WWPN */

/*

 * Called from qla_target_template->free_mcmd(), and will call

 * tcm_qla2xxx_release_cmd() via normal struct target_core_fabric_ops

 * release callback.  qla_hw_data->hardware_lock is expected to be held

 To do: protect all tgt_counters manipulations with proper locking. */

/*

 * Called from qla_target_template->free_cmd(), and will call

 * tcm_qla2xxx_release_cmd via normal struct target_core_fabric_ops

 * release callback.  qla_hw_data->hardware_lock is expected to be held

/*

 * Called from struct target_core_fabric_ops->check_stop_free() context

/* tcm_qla2xxx_release_cmd - Callback from TCM Core to release underlying

 * fabric descriptor @se_cmd command to release

		/* Cmd can loop during Q-full.  tcm_qla2xxx_aborted_task

		 * can get ahead of this cmd. tcm_qla2xxx_aborted_task

		 * already kick start the free.

	/*

	 * qla_target.c:qlt_rdy_to_xfer() will call dma_map_sg() to setup

	 * the SGL mappings into PCIe memory for incoming FCP WRITE data.

/*

 * Called from process context in qla_target.c:qlt_do_work() code

 return, and dont run target_submit_cmd,discarding command */

	/*

	 * Ensure that the complete FCP WRITE payload has been received.

	 * Otherwise return an exception via CHECK_CONDITION status.

/*

 * Called from qla_target.c:qlt_do_ctio_completion()

/*

 * Called from qla_target.c:qlt_issue_task_mgmt()

		/* Cmd can loop during Q-full.  tcm_qla2xxx_aborted_task

		 * can get ahead of this cmd. tcm_qla2xxx_aborted_task

		 * already kick start the free.

	/*

	 * Now queue completed DATA_IN the qla2xxx LLD and response ring

		/*

		 * Cmd can loop during Q-full. tcm_qla2xxx_aborted_task

		 * can get ahead of this cmd. tcm_qla2xxx_aborted_task

		 * already kick start the free.

		/*

		 * For FCP_READ with CHECK_CONDITION status, clear cmd->bufflen

		 * for qla_tgt_xmit_response LLD code

	/*

	 * Now queue status response to qla2xxx LLD code and response ring

	/*

	 * Do translation between TCM TM response codes and

	 * QLA2xxx FC TM response codes.

	/*

	 * Queue the TM response to QLA2xxx LLD to build a

	 * CTIO response packet.

/*

 * Expected to be called with struct qla_hw_data->tgt.sess_lock held

		/*

		 * The nacl no longer matches what we think it should be.

		 * Most likely a new dynamic acl has been added while

		 * someone dropped the hardware lock.  It clearly is a

		 * bug elsewhere, but this bit can't make things worse.

	/*

	 * Now clear the se_nacl and session pointers from our HW lport lookup

	 * table mapping for this initiator's fabric S_ID and LOOP_ID entries.

	 *

	 * This is done ahead of callbacks into tcm_qla2xxx_free_session() ->

	 * target_wait_for_sess_cmds() before the session waits for outstanding

	 * I/O to complete, to avoid a race between session shutdown execution

	 * and incoming ATIOs or TMRs picking up a stale se_node_act reference.

 Start items for tcm_qla2xxx_tpg_attrib_cit */

 End items for tcm_qla2xxx_tpg_attrib_cit */

	/*

	 * By default allow READ-ONLY TPG demo-mode access w/ cached dynamic

	 * NodeACLs

	/*

	 * Call into qla2x_target.c LLD logic to shutdown the active

	 * FC Nexuses and disable target mode operation for this qla_hw_data

	/*

	 * Clear local TPG=1 pointer for non NPIV mode.

	/*

	 * By default allow READ-ONLY TPG demo-mode access w/ cached dynamic

	 * NodeACLs

/*

 * Expected to be called with struct qla_hw_data->tgt.sess_lock held

/*

 * Expected to be called with struct qla_hw_data->tgt.sess_lock held

/*

 * Expected to be called with struct qla_hw_data->tgt.sess_lock held

/*

 * Expected to be called with struct qla_hw_data->tgt.sess_lock held

/*

 * Should always be called with qla_hw_data->tgt.sess_lock held.

	/*

	 * And now setup se_nacl and session pointers into HW lport internal

	 * mappings for fabric S_ID and LOOP_ID.

/*

 * Called via qlt_create_sess():ha->qla2x_tmpl->check_initiator_node_acl()

 * to locate struct se_node_acl

	/*

	 * Locate the TPG=1 reference..

	/*

	 * Format the FCP Initiator port_name into colon seperated values to

	 * match the format by tcm_qla2xxx explict ConfigFS NodeACLs.

	/*

	 * Locate our struct se_node_acl either from an explict NodeACL created

	 * via ConfigFS, or via running in TPG demo mode.

		/*

		 * Because we can shuffle loop IDs around and we

		 * update different sessions non-atomically, we might

		 * have overwritten this session's old loop ID

		 * already, and we might end up overwriting some other

		 * session that will be updated later.  So we have to

		 * be extra careful and we can't warn about those things...

/*

 * Calls into tcm_qla2xxx used by qla2xxx LLD I/O path.

	/*

	 * Setup tgt_ops, local pointer to vha and target_lport_ptr

	/*

	 * Call into qla2x_target.c LLD logic to complete the

	 * shutdown of struct qla_tgt after the call to

	 * qlt_stop_phase1() from tcm_qla2xxx_drop_tpg() above..

	/*

	 * Setup local pointer to NPIV vhba + target_lport_ptr

	/*

	 * Notify libfc that we want to release the vha->fc_vport

	/*

	 * XXX: Limit assumes single page per scatter-gather-list entry.

	 * Current maximum is ~4.9 MB per se_cmd->t_data_sg with PAGE_SIZE=4096

	/*

	 * Setup function pointers for generic logic in

	 * target_core_fabric_configfs.c

	/*

	 * Setup function pointers for generic logic in

	 * target_core_fabric_configfs.c

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

 SYSFS attributes --------------------------------------------------------- */

 Checksum NVRAM. */

 Write NVRAM. */

 NVRAM settings take effect immediately. */

		/*

		 * We need to be more restrictive on which FLASH regions are

		 * allowed to be updated via user-space.  Regions accessible

		 * via this method include:

		 *

		 * ISP21xx/ISP22xx/ISP23xx type boards:

		 *

		 * 	0x000000 -> 0x020000 -- Boot code.

		 *

		 * ISP2322/ISP24xx type boards:

		 *

		 * 	0x000000 -> 0x07ffff -- Boot code.

		 * 	0x080000 -> 0x0fffff -- Firmware.

		 *

		 * ISP25xx type boards:

		 *

		 * 	0x000000 -> 0x07ffff -- Boot code.

		 * 	0x080000 -> 0x0fffff -- Firmware.

		 * 	0x120000 -> 0x12ffff -- VPD and HBA parameters.

		 *

		 * > ISP25xx type boards:

		 *

		 *      None -- should go through BSG.

 Write NVRAM. */

 Update flash version information for 4Gb & above. */

 Make sure FC side is not in reset */

 Issue MPI reset */

 Scsi_Host attributes. */

 Update per-hba values and queue a reset. */

 check led index */

 ----- */

 --- */

 exchange offload flipped */

					/*

					 * The number of exchange to be offload

					 * was tweaked or offload option was

					 * flipped

					/*

					 * The number of exchange to be offload

					 * was tweaked or offload option was

					 * flipped

 active_mode is target only, reset it to dual */

					/*

					 * The number of exchange to be offload

					 * was tweaked or offload option was

					 * flipped

 exclusive -> dual */

 turning off initiator mode */

 Host attributes. */

	/* Now that the rport has been deleted, set the fcport state to

	/*

	 * Transport has effectively 'deleted' the rport, clear

	 * all local references.

	/*

	 * At this point all fcport's software-states are cleared.  Perform any

	 * final cleanup of firmware resources (PCBs and XCBs).

 Must be in a 'READY' state for statistics retrieval. */

 --- */

 --- */

 reset firmware statistics */

 ready to create vport */

 initialized vport states */

 Check if physical ha port is Up */

 Don't retry or attempt login of this virtual port */

 initialize attributes */

 Create a request queue in QoS mode for the vport */

 Allow timer to run to drain queued items, when removing vp */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

 8044 Flash Read/Write functions */

/*

 * qla8044_read_write_crb_reg - Read from raddr and write value to waddr.

 *

 * @ha : Pointer to adapter structure

 * @raddr : CRB address to read from

 * @waddr : CRB address to write to

 *

 jiffies after 100ms */

 jiffies after 100 msecs */

/*

 * qla8044_rmw_crb_reg - Read value from raddr, AND with test_mask,

 * Shift Left,Right/OR/XOR with values RMW header and write value to waddr.

 *

 * @vha : Pointer to adapter structure

 * @raddr : CRB address to read from

 * @waddr : CRB address to write to

 * @p_rmw_hdr : header with shift/or/xor values.

 *

/**

 * qla8044_lock_recovery - Recovers the idc_lock.

 * @vha : Pointer to adapter structure

 *

 * Lock Recovery Register

 * 5-2	Lock recovery owner: Function ID of driver doing lock recovery,

 *	valid if bits 1..0 are set by driver doing lock recovery.

 * 1-0  1 - Driver intends to force unlock the IDC lock.

 *	2 - Driver is moving forward to unlock the IDC lock. Driver clears

 *	    this field after force unlocking the IDC lock.

 *

 * Lock Recovery process

 * a. Read the IDC_LOCK_RECOVERY register. If the value in bits 1..0 is

 *    greater than 0, then wait for the other driver to unlock otherwise

 *    move to the next step.

 * b. Indicate intent to force-unlock by writing 1h to the IDC_LOCK_RECOVERY

 *    register bits 1..0 and also set the function# in bits 5..2.

 * c. Read the IDC_LOCK_RECOVERY register again after a delay of 200ms.

 *    Wait for the other driver to perform lock recovery if the function

 *    number in bits 5..2 has changed, otherwise move to the next step.

 * d. Write a value of 2h to the IDC_LOCK_RECOVERY register bits 1..0

 *    leaving your function# in bits 5..2.

 * e. Force unlock using the DRIVER_UNLOCK register and immediately clear

 *    the IDC_LOCK_RECOVERY bits 5..0 by writing 0.

 Check for other Recovery in progress, go wait */

 Intent to Recover */

 Check Intent to Recover is advertised */

 Proceed to Recover */

 Force Unlock() */

 Clear bits 0-5 in IDC_RECOVERY register*/

 Get lock() */

 acquire semaphore5 from PCI HW block */

			/* Increment Counter (8-31) and update func_num (0-7) on

				/* Some other driver got lock,

				 * OR same driver got lock again (counter

				 * value changed), when we were waiting for

				/* Same driver holding lock > 2sec.

 Recovered and got lock */

				/* Recovery Failed, some other function

				 * has the lock, wait for 2secs

				 * and retry

 Keep lock counter value, update the ha->func_num to 0xFF */

 8044 Flash Lock/Unlock functions */

 Reading FLASH_UNLOCK register unlocks the Flash */

 Someone else is holding the lock. */

	/*

	 * Either we got the lock, or someone

	 * else died while holding it.

	 * In either case, unlock.

/*

 * Address and length are byte address

/*

 * Address and length are byte address

/*

 * qla8044_write_list - Write the value (p_entry->arg2) to address specified

 * by p_entry->arg1 for all entries in header with delay of p_hdr->delay between

 * entries.

 *

 * @vha : Pointer to adapter structure

 * @p_hdr : reset_entry header for WRITE_LIST opcode.

 *

/*

 * qla8044_read_write_list - Read from address specified by p_entry->arg1,

 * write value read to address specified by p_entry->arg2, for all entries in

 * header with delay of p_hdr->delay between entries.

 *

 * @vha : Pointer to adapter structure

 * @p_hdr : reset_entry header for READ_WRITE_LIST opcode.

 *

/*

 * qla8044_poll_reg - Poll the given CRB addr for duration msecs till

 * value read ANDed with test_mask is equal to test_result.

 *

 * @ha : Pointer to adapter structure

 * @addr : CRB register address

 * @duration : Poll for total of "duration" msecs

 * @test_mask : Mask value read with "test_mask"

 * @test_result : Compare (value&test_mask) with test_result.

 *

 * Return Value - QLA_SUCCESS/QLA_FUNCTION_FAILED

 poll every 1/10 of the total duration */

/*

 * qla8044_poll_list - For all entries in the POLL_LIST header, poll read CRB

 * register specified by p_entry->arg1 and compare (value AND test_mask) with

 * test_result to validate it. Wait for p_hdr->delay between processing entries.

 *

 * @ha : Pointer to adapter structure

 * @p_hdr : reset_entry header for POLL_LIST opcode.

 *

	/* Entries start after 8 byte qla8044_poll, poll header contains

	 * the test_mask, test_value.

					/*If

					* (data_read&test_mask != test_value)

					* read TIMEOUT_ADDR (arg1) and

					* ADDR (arg2) registers

/*

 * qla8044_poll_write_list - Write dr_value, ar_value to dr_addr/ar_addr,

 * read ar_addr, if (value& test_mask != test_mask) re-read till timeout

 * expires.

 *

 * @vha : Pointer to adapter structure

 * @p_hdr : reset entry header for POLL_WRITE_LIST opcode.

 *

/*

 * qla8044_read_modify_write - Read value from p_entry->arg1, modify the

 * value, write value to p_entry->arg2. Process entries with p_hdr->delay

 * between entries.

 *

 * @vha : Pointer to adapter structure

 * @p_hdr : header with shift/or/xor values.

 *

/*

 * qla8044_pause - Wait for p_hdr->delay msecs, called between processing

 * two entries of a sequence.

 *

 * @vha : Pointer to adapter structure

 * @p_hdr : Common reset entry header.

 *

/*

 * qla8044_template_end - Indicates end of reset sequence processing.

 *

 * @vha : Pointer to adapter structure

 * @p_hdr : Common reset entry header.

 *

/*

 * qla8044_poll_read_list - Write ar_value to ar_addr register, read ar_addr,

 * if (value & test_mask != test_value) re-read till timeout value expires,

 * read dr_addr register and assign to reset_tmplt.array.

 *

 * @vha : Pointer to adapter structure

 * @p_hdr : Common reset entry header.

 *

/*

 * qla8031_process_reset_template - Process all entries in reset template

 * till entry with SEQ_END opcode, which indicates end of the reset template

 * processing. Each entry has a Reset Entry header, entry opcode/command, with

 * size of the entry, number of entries in sub-sequence and delay in microsecs

 * or timeout in millisecs.

 *

 * @ha : Pointer to adapter structure

 * @p_buff : Common reset entry header.

 *

		/*

		 *Set pointer to next entry in the sequence.

 Check if data is spread across multiple sectors  */

 Multi sector read */

 This write is needed once for each sector */

 Single sector read */

/*

 * qla8044_ms_mem_write_128b - Writes data to MS/off-chip memory

 *

 * @vha : Pointer to adapter structure

 * addr : Flash address to write to

 * data : Data to be written

 * count : word_count to be written

 *

 * Return Value - QLA_SUCCESS/QLA_FUNCTION_FAILED

 Only 128-bit aligned access */

 Write address */

 Write data */

 Check write status */

 Status check failed */

 128 bit alignment check */

 16 byte count */

 128 bit/16 byte write to MS memory */

 Collect minidump */

	/*

	 *  Loads F/W from flash

/*

 * qla8044_check_cmd_peg_status - Check peg status to see if Peg is

 * initialized.

 *

 * @ha : Pointer to adapter structure

 *

 * Return Value - QLA_SUCCESS/QLA_FUNCTION_FAILED

/*

 * qla8044_device_bootstrap - Initialize device, set DEV_READY, start fw

 * @ha: pointer to adapter structure

 *

 * Note: IDC lock must be held upon entry

 We are trying to perform a recovery here. */

 set to DEV_INITIALIZING */

	/* For ISP8044, If IDC_CTRL GRACEFUL_RESET_BIT1 is set , reset it after

-------------------------Reset Sequence Functions-----------------------*/

/*

 * qla8044_reset_seq_checksum_test - Validate Reset Sequence template.

 *

 * @ha : Pointer to adapter structure

 *

 * Return Value - QLA_SUCCESS/QLA_FUNCTION_FAILED

 checksum of 0 indicates a valid template */

/*

 * qla8044_read_reset_template - Read Reset Template from Flash, validate

 * the template and store offsets of stop/start/init offsets in ha->reset_tmplt.

 *

 * @ha : Pointer to adapter structure

 Copy template header from flash */

 Validate the template header size and signature */

 Copy rest of the template */

 Integrity check */

 Get STOP, START, INIT sequence offsets */

	/* For ISP8044, drv_active register has 1 bit per function,

/**

 * qla8044_need_reset_handler - Code to start reset sequence

 * @vha: pointer to adapter structure

 *

 * Note: IDC lock must be held upon entry

 wait for 10 seconds for reset ack from all functions */

 Remove IDC participation of functions not acknowledging */

		/*

		 * Reset owner should execute reset recovery,

		 * if all functions acknowledged

 Exit if non active function */

	/*

	 * Execute Reset Recovery if Reset Owner or Function 7

	 * is the only active function

	/* For ISP8044, drv_active register has 1 bit per function,

 Update IDC_MINOR_VERSION */

	/* If we are the first driver to load and

/**

 * qla8044_need_qsnt_handler - Code to start qsnt

 * @vha: pointer to adapter structure

 Wait for 30 secs for all functions to ack qsnt mode */

	/* Shift drv_active by 1 to match drv_state. As quiescent ready bit

			/* Other functions did not ack, changing state to

			 * DEV_READY

 All functions have Acked. Set quiescent state */

/*

 * qla8044_device_state_handler - Adapter state machine

 * @ha: pointer to host adapter structure.

 *

 * Note: IDC lock must be UNLOCKED upon entry

 wait for 30 seconds for device to go ready */

 NOTE: Make sure idc unlocked upon exit of switch statement */

			/* For ISP8044, if NEED_RESET is set by any driver,

			 * it should be honored, irrespective of IDC_CTRL

 idc locked/unlocked in handler */

 Reset the init timeout after qsnt handler */

 Reset the init timeout after qsnt handler */

/**

 * qla8044_check_temp - Check the ISP82XX temperature.

 * @vha: adapter block pointer.

 *

 * Note: The caller should not hold the idc lock.

/**

 * qla8044_check_fw_alive  - Check firmware health

 * @vha: Pointer to host adapter structure.

 *

 * Context: Interrupt

 If PEG_ALIVE_COUNTER is 0xffffffff, AER/EEH is in progress, ignore */

 FW not alive after 2 seconds */

 don't poll if reset is going on or FW hang in quiescent state */

 Check firmware health */

				/* Since we cannot change dev_state in interrupt

				 * context, set appropriate DPC flag then wakeup

 capturing dump failed */

 ISP83xx flash read for _RDROM _BOARD */

 capturing dump failed */

 ISP83xx functions to process new minidump entries... */

 Max wait of 100 msecs */

 Read the pex-dma's command-status-and-control register. */

 Check if requested pex-dma engine is available. */

 Wait for dma operation to complete. */

 Wait a max of 100 ms, otherwise fallback to rdmem entry read */

 Prepare pex-dma descriptor to be written to MS memory. */

	/* dma-desc-cmd layout:

	 *		0-3: dma-desc-cmd 0-3

	 *		4-7: pcid function number

	 *		8-15: dma-desc-cmd 8-15

	 * dma_bus_addr: dma buffer address

	 * cmd.read_data_size: amount of data-chunk to be read.

	/*

	 * Perform rdmem operation using pex-dma.

	 * Prepare dma in chunks of ISP8044_PEX_DMA_READ_SIZE.

 Prepare: Write pex-dma descriptor to MS memory. */

 Execute: Start pex-dma operation. */

/*

 *

 * qla8044_collect_md_data - Retrieve firmware minidump data.

 * @ha: pointer to adapter structure

 Validate whether required debug level is set */

 Update current timestamp before taking dump */

 Walk through the entry headers - validate/perform required action */

		/* Decode the entry type and take required action to capture

		 * debug data

		/*

		 * next entry in the template

/*

 * This function assumes that the flash lock is held.

/*

 * This function assumes that the flash lock is held.

/*

 * qla8044_flash_write_u32 - Write data to flash

 *

 * @ha : Pointer to adapter structure

 * addr : Flash address to write to

 * p_data : Data to be written

 *

 * Return Value - QLA_SUCCESS/QLA_FUNCTION_FAILED

 *

 * NOTE: Lock should be held on entry

 First DWORD write to FLASH_WRDATA */

 Second to N-1 DWORDS writes */

 Last DWORD write */

 Operation failed, clear error bit. */

	/* Since the offset and legth are sector aligned, it will be always

	 * multiple of burst_iter_count (64)

 Suspend HBA. */

 Lock and enable write for whole operation. */

 Erasing the sectors */

 Go with write. */

 Buffer Mode failed skip to dword mode */

/**

 * qla8044_intr_handler() - Process interrupts for the ISP8044

 * @irq: interrupt number

 * @dev_id: SCSI driver HA context

 *

 * Called by system whenever the host adapter generates an interrupt.

 *

 * Returns handled flag.

 Legacy interrupt is valid if bit31 of leg_int_ptr is set */

 Validate the PCIE function ID set in leg_int_ptr bits [19..16] */

	/* To de-assert legacy interrupt, write 0 to Legacy Interrupt Trigger

	 * Control register and poll till Legacy Interrupt Pointer register

	 * bit32 is 0.

	/*

	 * For ISP8044, drv_active register has 1 bit per function,

	 * shift 1 by func_num to set a bit for the function.

	 * For ISP82xx, drv_active has 4 bits per function

	/* If device_state is NEED_RESET, go ahead with

	 * Reset,irrespective of ql2xdontresethba. This is to allow a

	 * non-reset-owner to force a reset. Non-reset-owner sets

	 * the IDC_CTRL BIT0 to prevent Reset-owner from doing a Reset

	 * and then forces a Reset by setting device_state to

		/* If IDC_CTRL DONTRESETHBA_BIT0 is set don't do reset

	/* For ISP8044, Reset owner is NIC, iSCSI or FCOE based on priority

	 * and which drivers are present. Unlike ISP82XX, the function setting

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

 terminate */

		/*

		 * Mirror pointers are not implemented in the

		 * driver, instead shadow pointers are used by

		 * the drier. Skip these entries.

 endianize residual count */

 Use the spare area for any further dumps. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

/*

 * Driver version

/*

 * SRB allocation cache

/*

 * CT6 CTX allocation cache

/*

 * error level for logging

/* TODO Convert to inlines

 *

 * Timer routines

 Currently used for 82XX only. */

 -------------------------------------------------------------------------- */

 init qpair to this cpu. Will adjust at run time. */

	/*

	 * Make sure we record at least the request and response queue zero in

	 * case we need to free them if part of the probe fails.

 List assured to be having elements */

 List assured to be having elements */

	/*

	 * Return target busy if we've received a non-zero retry_delay_timer

	 * in a FCP_RSP.

 retry delay not set */

 For MQ supported I/O */

	/*

	 * Return target busy if we've received a non-zero retry_delay_timer

	 * in a FCP_RSP.

 retry delay not set */

/*

 * qla2x00_eh_wait_on_command

 *    Waits for the command to be returned by the Firmware for some

 *    max time.

 *

 * Input:

 *    cmd = Scsi Command to wait on.

 *

 * Return:

 *    Completed in time : QLA_SUCCESS

 *    Did not complete in time : QLA_FUNCTION_FAILED

/*

 * qla2x00_wait_for_hba_online

 *    Wait till the HBA is online after going through

 *    <= MAX_RETRIES_OF_ISP_ABORT  or

 *    finally HBA is disabled ie marked offline

 *

 * Input:

 *     ha - pointer to host adapter structure

 *

 * Note:

 *    Does context switching-Release SPIN_LOCK

 *    (if any) before calling this routine.

 *

 * Return:

 *    Success (Adapter is online) : 0

 *    Failed  (Adapter is offline/disabled) : 1

 Return 0 = sleep, x=wake */

				/* session(s) may not be fully logged in

				 * (ie fcport_count=0), but session

				 * deletion thread(s) may be inflight.

/*

 * qla2x00_wait_for_sess_deletion can only be called from remove_one.

 * it has dependency on UNLOADING flag to stop device discovery

/*

 * qla2x00_wait_for_hba_ready

 * Wait till the HBA is ready before doing driver unload

 *

 * Input:

 *     ha - pointer to host adapter structure

 *

 * Note:

 *    Does context switching-Release SPIN_LOCK

 *    (if any) before calling this routine.

 *

/**************************************************************************

* qla2xxx_eh_abort

*

* Description:

*    The abort function will abort the specified command.

*

* Input:

*    cmd = Linux SCSI command packet to be aborted.

*

* Returns:

*    Either SUCCESS or FAILED.

*

* Note:

*    Only return FAILED if command not returned by firmware.

 Save any FAST_IO_FAIL value to return later if abort succeeds */

	/*

	 * Abort will release the original Command/sp from FW. Let the

	 * original command call scsi_done. In return, he will wakeup

	 * this sleeping thread.

 Wait for the command completion. */

/*

 * Returns: QLA_SUCCESS or QLA_FUNCTION_FAILED.

/**************************************************************************

* qla2xxx_eh_bus_reset

*

* Description:

*    The bus reset function will reset the bus and abort any executing

*    commands.

*

* Input:

*    cmd = Linux SCSI command packet of the command that cause the

*          bus reset.

*

* Returns:

*    SUCCESS/FAILURE (defined as macro in scsi.h).

*

 Flush outstanding commands. */

/**************************************************************************

* qla2xxx_eh_host_reset

*

* Description:

*    The reset function will reset the Adapter.

*

* Input:

*      cmd = Linux SCSI command packet of the command that cause the

*            adapter reset.

*

* Returns:

*      Either SUCCESS or FAILED.

*

* Note:

	/*

	 * No point in issuing another reset if one is active.  Also do not

	 * attempt a reset if we are updating flash.

 Ctx reset success */

 fall thru if ctx reset failed */

 failed. schedule dpc to try */

 Waiting for command to be returned to OS.*/

/*

* qla2x00_loop_reset

*      Issue loop reset.

*

* Input:

*      ha = adapter block pointer.

*

* Returns:

*      0 = success

 Issue marker command only when we are going to start the I/O */

/*

 * The caller must ensure that no completion interrupts will happen

 * while this function is in progress.

 Wait for command completion. */

 else FW return SP to driver */

/*

 * The caller must ensure that no completion interrupts will happen

 * while this function is in progress.

 Skip task management functions. */

/*

 * The caller must ensure that no completion interrupts will happen

 * while this function is in progress.

 Continue only if initialization complete. */

/**

 * qla2x00_config_dma_addressing() - Configure OS DMA addressing method.

 * @ha: HA context

 *

 * At exit, the @ha's flags.enable_64bit_addressing set to indicated

 * supported addressing method.

 Assume a 32bit DMA mask. */

 Any upper-dword bits set? */

 Ok, a 64bit DMA mask is applicable. */

 enable risc and host interrupts */

 disable risc and host interrupts */

 We only need PIO for Flash operations on ISP2312 v2 chips. */

 Use MMIO operations for all accesses. */

 Determine queue resources */

 Check if FW supports MQ or not */

 Read MSIX vector size of the board */

 Max queues are bounded by available msix vectors */

 MB interrupt uses 1 vector */

 Queue pairs is the max value minus the base queue pair */

 Use MMIO operations for all accesses. */

 64bit PCI BAR - BAR2 will correspoond to region 4 */

	/* 83XX 26XX always use MQ type access for queues

 Read MSIX vector size of the board */

		/*

		 * By default, driver uses at least two msix vectors

		 * (default & rspq)

 MB interrupt uses 1 vector */

 ATIOQ needs 1 vector. That's 1 less QPair */

			/* Queue pairs is the max value minus

 Initialize 82XX ISP flags */

 Initialize 82XX ISP flags */

 Get adapter physical port no from interrupt pin register. */

/*

 * PCI driver interface

 This may fail but that's ok */

 Clear our data area */

 Set ISP-type information. */

 Set EEH reset type to fundamental if required by hba */

 Assign ISP specific operations. */

 default value */

 Configure PCI I/O space */

 Setup fcport template structure. */

 Set the SG table size based on ISP type */

 Older HBAs support only 16-bit LUNs */

 Set up the irqs */

 Alloc arrays of request and response ring ptrs */

 number of hardware queues supported by blk/scsi-mq*/

 Assign back pointers */

 FWI2-capable only. */

 Check if FW supports MQ or not for ISP25xx */

 Create start of day qpairs for Block MQ */

	/*

	 * Startup the kernel thread for this host adapter

	/*

	 * If we're not coming up in initiator mode, we might sit for

	 * a while without waking up the dpc thread, which leads to a

	 * stuck process warning.  So just kick the dpc once here and

	 * let the kthread start (and go back to sleep in qla2x00_do_dpc).

 Initialized the timer */

 Register system information */

	/*

	 * Need to NULL out local req/rsp after

	 * qla2x00_free_device => qla2x00_free_queues frees

	 * what these are pointing to. Or else we'll

	 * fall over below in qla2x00_free_req/rsp_que.

	/*

	 * Indicate device removal to prevent future board_disable

	 * and wait until any pending board_disable has completed.

	/*

	 * Prevent future board_disable and wait

	 * until any pending board_disable has completed.

 Notify ISPFX00 firmware */

 Turn-off FCE trace */

 Turn-off EFT trace */

 Stop currently executing firmware. */

 Disable timer */

 Turn adapter off line */

 turn-off interrupts on the card */

 Deletes all the virtual ports for a given ha */

 This assumes first entry in ha->vp_list is always base vha */

 Stops all deferred work threads */

 Cancel all work and destroy DPC workqueues */

 Kill the kernel thread for this host */

		/*

		 * qla2xxx_wake_dpc checks for ->dpc_thread

		 * so we need to zero it out.

	/*

	 * If the PCI device is disabled then there was a PCI-disconnect and

	 * qla2x00_disable_board_on_pci_error has taken care of most of the

	 * resources.

	/*

	 * if UNLOADING flag is already set, then continue unload,

	 * where it was set first.

 Disable timer */

 free DMA memory */

 free DMA memory */

 Disable timer */

 turn-off interrupts on the card */

 Flush the work queue and remove it */

/*

 * qla2x00_mark_device_lost Updates fcport state when device goes offline.

 *

 * Input: ha = adapter block pointer.  fcport = port structure pointer.

 *

 * Return: None.

 *

 * Context:

	/*

	 * We may need to retry the login, so don't change the state of the

	 * port but do the retries.

/*

* qla2x00_mem_alloc

*      Allocates adapter memory.

*

* Returns:

*      0  = success.

*      !0  = failure.

 Allocate cache for CT6 Ctx. */

 Get memory for cached NVRAM */

 Creata a DMA pool of buffers for DIF bundling */

				/*

				 * if DMA buffer crosses 4G boundary,

				 * put it on bad list

 return the good ones back to the pool */

 Allocate memory for SNS commands */

 Get consistent memory allocated for SNS commands */

 Get consistent memory allocated for MS IOCB */

 Get consistent memory allocated for CT SNS commands */

 Allocate memory for request ring */

 Allocate memory for response ring */

 Allocate memory for NVRAM data for vports */

 Get consistent memory allocated for EX-INIT-CB. */

 Get consistent memory allocated for Special Features-CB. */

 Get consistent memory allocated for Async Port-Database. */

 Allocate memory for our loop_id bitmap */

 allocate the purex dma pool */

 Return if we don't need to alloacate any extended logins */

 Get consistent memory for extended logins */

 Now configure the dma buffer */

/*

* qla2x00_free_exlogin_buffer

*

* Input:

*	ha = adapter block pointer

 Get consistent memory for extended logins */

 pathological case */

 Now configure the dma buffer */

 re-adjust number of target exchange */

/*

* qla2x00_free_exchoffld_buffer

*

* Input:

*	ha = adapter block pointer

/*

* qla2x00_free_fw_dump

*	Frees fw dump stuff.

*

* Input:

*	ha = adapter block pointer

/*

* qla2x00_mem_free

*      Frees all adapter allocated memory.

*

* Input:

*      ha = adapter block pointer.

 clean up allocated prev pool */

 Clear our data area */

 todo: what about ext login? */

 do nothing */

			/* we took an extra ref_count to prevent PLOGI ACK when

			 * fcport/sess has not been created.

 search again to make sure no one else got ahead */

 should rarily happen */

				/*

				 * We have a conflict fcport with same NportID.

 put 'work' at head of 'vha->work_list' */

 For each work completed decrement vha ref count */

/* Relogins all the fcports of a vport

 * Context: dpc thread

		/*

		 * If the port is not ONLINE then try to login

		 * to it if we haven't run out of retries.

 retry the login again */

 Schedule work on any of the dpc-workqueues */

 0x8200 */

 0x1 */

 0x2 */

 0x3 */

 Work: Perform NIC Core Unrecoverable state handling */

 Work: Execute IDC state handler */

 Work: Perform NIC Core Reset handling */

 NIC Core reset failed. */

 Work: Handle 8200 IDC aens */

/*

 * Control the frequency of IDC lock retries

 Forcefully perform IDC UnLock */

 Clear lock-id by setting 0xff */

 Clear lock-recovery by setting 0x0 */

 MAX wait time before forcing IDC Lock recovery = 2 secs */

/*

 * Context: task, can sleep

 IDC-lock implementation using driver-lock/lock-id remote registers */

 Setting lock-id to our function-number */

 Retry/Perform IDC-Lock recovery */

 Domain Controller is always logged-out. */

 if RDP request is not from Domain Controller: */

 RDP request is from logged in port */

 if FW version allows RDP response length upto 2048 bytes: */

 RDP response length is to be reduced to maximum 256 bytes */

/*

 * Function Name: qla24xx_process_purex_iocb

 *

 * Description:

 * Prepare a RDP response and send to Fabric switch

 *

 * PARAMETERS:

 * vha:	SCSI qla host

 * purex: RDP request received by HBA

 Prepare Response IOCB */

 Prepare Response Payload */

 LS_ACC */

 Link service Request Info Descriptor */

 Link service Request Info Descriptor 2 */

 SFP Flags */

 SFP Flags bits 3-0: Port Tx Laser Type */

 short wave */

 long wave 1310nm */

 long wave 1550nm */

 SFP Type */

 optical */

 sfp+ */

 SFP Diagnostics */

 already be16 */

 Port Speed Descriptor */

 Link Error Status Descriptor */

 Portname Descriptor */

 F-Port Portname Descriptor */

 Bufer Credit Descriptor */

 Optical Element Descriptor, Temperature */

 Optical Element Descriptor, Voltage */

 Optical Element Descriptor, Tx Bias Current */

 Optical Element Descriptor, Tx Power */

 Optical Element Descriptor, Rx Power */

 already be16 */

 Optical Element Descriptor, Temperature */

 Optical Element Descriptor, Voltage */

 Optical Element Descriptor, Tx Bias Current */

 Optical Element Descriptor, Tx Power */

 Optical Element Descriptor, Rx Power */

 Temperature high/low alarm/warning */

 Voltage high/low alarm/warning */

 Tx Bias Current high/low alarm/warning */

 Tx Power high/low alarm/warning */

 Rx Power high/low alarm/warning */

 Optical Product Data Descriptor */

/*

 * Context: task, can sleep

	/* IDC-unlock implementation using driver-unlock/lock-id

	 * remote registers

 Clearing lock-id by setting 0xff */

 SV: XXX: IDC unlock retrying needed here? */

 Retry for IDC-unlock */

 Retry for IDC-unlock */

 XXX: IDC-unlock implementation using access-control mbx */

 Retry for IDC-unlock */

 Wait for IDC ACK from all functions (DRV-ACK == DRV-PRESENCE) */

			/*

			 * The function(s) which did not ack in time are forced

			 * to withdraw any further participation in the IDC

			 * reset.

 Clearing IDC-Control Graceful-Reset Bit before resetting f/w */

 Assumes idc_lock always held on entry */

 Wait for MAX-INIT-TIMEOUT for the device to go ready */

			/* Init timeout. Disable further NIC Core

			 * communication.

 Wait for AEN to change device-state */

 Wait for AEN to change device-state */

 Wait for AEN to change device-state */

 reset timeout value after need reset handler */

 XXX: DEBUG for now */

 XXX: DEBUG for now */

	/*

	 * if UNLOADING flag is already set, then continue unload,

	 * where it was set first.

	/*

	 * Do not try to stop beacon blink as it will issue a mailbox

	 * command.

	/*

	 * Let qla2x00_remove_one cleanup qla_hw_data on device removal.

/**************************************************************************

* qla2x00_do_dpc

*   This kernel thread is a task that is schedule by the interrupt handler

*   to perform the background processing for interrupts.

*

* Notes:

* This task always run in the context of a kernel thread.  It

* is kick-off by the driver's detect code and starts up

* up one per adapter. It immediately goes to sleep and waits for

* some fibre event.  When either the interrupt handler or

* the timer routine detects a event it will one of the task

* bits then wake us up.

						/* FCoE-ctx reset failed.

						 * Escalate to chip-reset

 Failed. Abort isp later. */

			/* Semantic:

			 *  - NO-OP -- await next ISP-ABORT. Preferred method

			 *             to minimize disruptions that will occur

			 *             when a forced chip-reset occurs.

			 *  - Force -- ISP-ABORT scheduled.

 set_bit(ISP_ABORT_NEEDED, &base_vha->dpc_flags); */

 failed. retry later */

 Retry each device up to login retry count */

 qpair online check */

 End of while(1) */

	/*

	 * Make sure that nobody tries to wake us up again.

 Cleanup any residual CTX SRBs. */

/*

*  qla2x00_rst_aen

*      Processes asynchronous reset.

*

* Input:

*      ha  = adapter block pointer.

			/*

			 * Issue marker command only when we are going to start

			 * the I/O.

	/*

	 * Allow do_heartbeat only if we don’t have any active interrupts,

	 * but there are still IOs outstanding with firmware.

/**************************************************************************

*   qla2x00_timer

*

* Description:

*   One second timer

*

* Context: Interrupt

	/*

	 * Hardware read to raise pending EEH errors during mailbox waits. If

	 * the read returns -1 then disable the board.

 Make sure qla82xx_watchdog is run only for physical port */

 Loop down handler. */

			/*

			 * Schedule an ISP abort to return any FCP2-device

			 * commands.

 NPIV - scan physical port only */

 if the loop has been down for 4 minutes, reinit adapter */

 Check if beacon LED needs to be blinked for physical host only */

 There is no beacon_blink function for ISP82xx */

 check if edif running */

 Process any deferred work. */

	/*

	 * FC-NVME

	 * see if the active AEN count has changed from what was last reported.

 Schedule the DPC routine if needed */

 Firmware interface routines. */

	/*

	 * purge mailbox might take a while. Slot Reset/chip reset

	 * will take care of the purge

 Clear all async request states across all VPs. */

 set PCI_ERS_RESULT_NEED_RESET to trigger call to qla2xxx_pci_slot_reset */

	/* Workaround: qla2xxx driver which access hardware earlier

	 * needs error state to be pci_channel_io_online.

	 * Otherwise mailbox command timesout.

	/* pci_restore_state() clears the saved_state flag of the device

	 * save restored state which resets saved_state flag

/*

 * this routine will schedule a task to pause IO from interrupt context

 * if caller sees a PCIE error event (register read = 0xf's)

	/*

	 * PCI FLR/function reset is about to reset the

	 * slot. Stop the chip to stop all DMA access.

	 * It is assumed that pci_reset_done will be called

	 * after FLR to resume Chip operation.

	/*

	 * FLR just completed by PCI layer. Resume adapter

/**

 * qla2x00_module_init - Module initialization.

 Allocate cache for SRBs. */

 Initialize target kmem_cache and mem_pools */

		/*

		 * If initiator mode is explictly disabled by qlt_init(),

		 * prevent scsi_transport_fc.c:fc_scsi_scan_rport() from

		 * performing scsi_scan_target() during LOOP UP event.

 Derive version string. */

/**

 * qla2x00_module_exit - Module cleanup.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

 QLAFX00 specific Mailbox implementation functions */

/*

 * qlafx00_mailbox_command

 *	Issue mailbox command and waits for completion.

 *

 * Input:

 *	ha = adapter block pointer.

 *	mcp = driver internal mbx struct pointer.

 *

 * Output:

 *	mb[MAX_MAILBOX_REGISTER_COUNT] = returned mailbox data.

 *

 * Returns:

 *	0 : QLA_SUCCESS = cmd performed success

 *	1 : QLA_FUNCTION_FAILED   (error encountered)

 *	6 : QLA_FUNCTION_TIMEOUT (timeout condition encountered)

 *

 * Context:

 *	Kernel context.

 Setting Link-Down error */

	/*

	 * Wait for active mailbox commands to finish by waiting at most tov

	 * seconds. This is to serialize actual issuing of mailbox cmds during

	 * non ISP abort time.

 Timeout occurred. Return error. */

 Save mailbox command for debug */

 Load mailbox registers. */

 Issue set host interrupt command to send cmd out. */

 Unlock mbx registers and wait for interrupt */

 Wait for mbx cmd completion until timeout */

 wait at most tov secs */

 Check for pending interrupts. */

 while */

 Check whether we timed out */

 Got interrupt. Clear the flag. */

 Load return mailbox registers. */

 Clean up */

 polling mode for non isp_abort commands. */

 not in dpc. schedule it for dpc to take over. */

 call abort directly since we are in the DPC thread */

 Failed. retry later. */

 Allow next mbx cmd to come in. */

/*

 * qlafx00_driver_shutdown

 *	Indicate a driver shutdown to firmware.

 *

 * Input:

 *	ha = adapter block pointer.

 *

 * Returns:

 *	local function return status code.

 *

 * Context:

 *	Kernel context.

/*

 * qlafx00_get_firmware_state

 *	Get adapter firmware state.

 *

 * Input:

 *	ha = adapter block pointer.

 *	TARGET_QUEUE_LOCK must be released.

 *	ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *	qla7xxx local function return status code.

 *

 * Context:

 *	Kernel context.

 Return firmware states. */

/*

 * qlafx00_init_firmware

 *	Initialize adapter firmware.

 *

 * Input:

 *	ha = adapter block pointer.

 *	dptr = Initialization control block pointer.

 *	size = size of initialization control block.

 *	TARGET_QUEUE_LOCK must be released.

 *	ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *	qlafx00 local function return status code.

 *

 * Context:

 *	Kernel context.

/*

 * qlafx00_mbx_reg_test

/**

 * qlafx00_pci_config() - Setup ISPFx00 PCI configuration registers.

 * @vha: HA context

 *

 * Returns 0 on success.

 PCIe -- adjust Maximum Read Request Size (2048). */

/**

 * qlafx00_soc_cpu_reset() - Perform warm reset of iSA(CPUs being reset on SOC).

 * @vha: HA context

 *

 stop the XOR DMA engines */

 stop the IDMA engines */

 Set all 4 cores in reset */

 Reset all units in Fabric */

 */

 Set all 4 core Memory Power Down Registers */

 Reset all interrupt control registers */

 Reset Timers control registers. per core */

 Reset per core IRQ ack register */

 Set Fabric control and config to defaults */

 Kick in Fabric units */

 Kick in Core0 to start boot process */

 Wait 10secs for soft-reset to complete. */

/**

 * qlafx00_soft_reset() - Soft Reset ISPFx00.

 * @vha: HA context

 *

 * Returns 0 on success.

/**

 * qlafx00_chip_diag() - Test ISPFx00 for proper operation.

 * @vha: HA context

 *

 * Returns 0 on success.

 Flag a successful rval */

 PCI posting */

 Use MMIO operations for all accesses. */

 Determine queue resources */

 Wait time */

 30 seconds wait - Adjust if required */

 wait time before firmware ready */

 Set the mbx and rqstq intr code */

			/* If fw is apparently not ready. In order to continue,

			 * we might need to issue Mbox cmd, but the problem is

			 * that the DoorBell vector values that come with the

			 * 8060 AEN are most likely gone by now (and thus no

			 * bell would be rung on the fw side when mbox cmd is

			 * issued). We have to therefore grab the 8060 AEN

			 * shadow regs (filled in by FW when the last 8060

			 * AEN was being posted).

			 * Do the following to determine what is needed in

			 * order to get the FW ready:

			 * 1. reload the 8060 AEN values from the shadow regs

			 * 2. clear int status to get rid of possible pending

			 *    interrupts

			 * 3. issue Get FW State Mbox cmd to determine fw state

			 * Set the mbx and rqstq intr code from Shadow Regs

 Get the FW state */

 Retry if timer has not expired */

				/* Firmware is waiting to be

				 * initialized by driver

			/* Issue driver shutdown and wait until f/w recovers.

			 * Driver should continue to poll until 8060 AEN is

			 * received indicating firmware recovery.

 Delay for a while */

/*

 * qlafx00_fw_ready() - Waits for firmware ready.

 * @ha: HA context

 *

 * Returns 0 on success.

 Wait time if loop is coming ready */

 wait time before firmware ready */

 Wait for ISP to finish init */

 Delay for a while */

 Allocate temporary rmtport for any new rmtports discovered. */

 Send get target node info */

 Locate matching device in database. */

			/*

			 * If tgt_id is same and state FCS_ONLINE, nothing

			 * changed.

			/*

			 * Tgt ID changed or device was marked to be updated.

 If device was not in our fcports list, then add it. */

 Allocate a new replacement fcport. */

/*

 * qlafx00_configure_all_targets

 *      Setup target devices with node ID's.

 *

 * Input:

 *      ha = adapter block pointer.

 *

 * Returns:

 *      0 = success.

 *      BIT_0 = error

	/*

	 * Delete all previous devices marked lost.

	/*

	 * Add the new devices to our devices list.

 Free all new device structures not processed. */

/*

 * qlafx00_configure_devices

 *      Updates Fibre Channel Device Database with what is actually on loop.

 *

 * Input:

 *      ha                = adapter block pointer.

 *

 * Returns:

 *      0 = success.

 *      1 = error.

 *      2 = database was full and device was not configured.

 Clear all async request states across all VPs. */

 Requeue all commands in outstanding command list. */

 Clear the Interrupts */

/**

 * qlafx00_init_response_q_entries() - Initializes response queue entries.

 * @rsp: response queue

 *

 * Beginning of request ring has initialization control block already built

 * by nvram config routine.

 *

 * Returns 0 on success.

 Clear the Interrupts */

 if no cable then assume it's good */

 Register system information */

 Check firmware health */

 Reset recovery to be performed in timer routine */

 Wake up DPC to rescan the targets */

		/*

		 * Critical temperature recovery to be

		 * performed in timer routine

		/*

		 * Incomplete host info might be sent to firmware

		 * durinng system boot - info should be resend

/*

 *  qlfx00a_reset_initialize

 *      Re-initialize after a iSA device reset.

 *

 * Input:

 *      ha  = adapter block pointer.

 *

 * Returns:

 *      0 = success

/*

 *  qlafx00_abort_isp

 *      Resets ISP and aborts all outstanding commands.

 *

 * Input:

 *      ha  = adapter block pointer.

 *

 * Returns:

 *      0 = success

 Clear the Interrupts */

 Check for matching device in remote port list. */

 Port database update */

 Critical temperature event */

/*

 * qlafx00_initialize_adapter

 *      Initialize board.

 *

 * Input:

 *      ha = adapter block pointer.

 *

 * Returns:

 *      0 = success

 Clear adapter flags. */

	/*

	 * Allocate the array of outstanding commands

	 * now that we know the firmware resources.

* QLAFX00 specific ISR implementation functions */

/**

 * qlafx00_status_entry() - Process a Status IOCB entry.

 * @vha: SCSI driver HA context

 * @rsp: response queue

 * @pkt: Entry pointer

 Validate handle. */

 Fast path completion. */

 Check for overrun. */

	/*

	 * Based on Host and scsi status generate status code for Linux

 Use F/W calculated residual length. */

			/*

			 * scsi status of task set and busy are considered

			 * to be task not completed.

		/*

		 * Check to see if SCSI Status is non zero. If so report SCSI

		 * Status.

		/*

		 * We are going to have the fc class block the rport

		 * while we try to recover so instruct the mid layer

		 * to requeue until the class decides how to handle this.

/**

 * qlafx00_status_cont_entry() - Process a Status Continuations entry.

 * @rsp: response queue

 * @pkt: Entry pointer

 *

 * Extended sense data.

 Move sense data. */

 Place command on done queue. */

/**

 * qlafx00_multistatus_entry() - Process Multi response queue entries.

 * @vha: SCSI driver HA context

 * @rsp: response queue

 * @pkt: received packet

 Validate handle. */

/**

 * qlafx00_error_entry() - Process an error entry.

 * @vha: SCSI driver HA context

 * @rsp: response queue

 * @pkt: Entry pointer

/**

 * qlafx00_process_response_queue() - Process response queue entries.

 * @vha: SCSI driver HA context

 * @rsp: response queue

 Type Not Supported. */

 Adjust ring index */

/**

 * qlafx00_async_event() - Process aynchronous events.

 * @vha: SCSI driver HA context

 Setup to process RIO completion. */

 System Error */

 Shutdown requested */

 Port database update */

 Over temperature event */

 Normal temperature event */

 Critical temperature event */

/**

 * qlafx00_mbx_completion() - Process mailbox command completions.

 * @vha: SCSI driver HA context

 * @mb0: value to be written into mailbox register 0

 Load return mailbox registers. */

/**

 * qlafx00_intr_handler() - Process interrupts for the ISPFX00.

 * @irq: interrupt number

 * @dev_id: SCSI driver HA context

 *

 * Called by system whenever the host adapter generates an interrupt.

 *

 * Returns handled flag.

* QLAFX00 specific IOCB implementation functions */

 Adjust ring index. */

 Load packet defaults. */

 Update entry type to indicate Command Type 3 IOCB */

 No data transfer */

 Set transfer direction */

 One DSD is available in the Command Type 3 IOCB */

 Load data segments */

 Allocate additional continuation packets? */

			/*

			 * Five DSDs are available in the Continuation

			 * Type 1 IOCB.

/**

 * qlafx00_start_scsi() - Send a SCSI command to the ISP

 * @sp: command to send to the ISP

 *

 * Returns non-zero if a failure occurred, else zero.

 Setup device pointers. */

 So we know we haven't pci_map'ed anything yet */

 Acquire ring specific lock */

 Map the sg table so we have an accurate count of sg entries needed */

 Build command packet. */

 Load SCSI command packet. */

 Build IOCB segments */

 Set total data segment count. */

 Specify response queue number where completion should happen */

 Adjust ring index. */

 Set chip new ring index. */

 Allocate additional continuation packets? */

					/*

					 * Five DSDs are available in the Cont.

					 * Type 1 IOCB.

 Allocate additional continuation packets? */

					/*

					* Five DSDs are available in the Cont.

					* Type 1 IOCB.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

/**

 * qla2x00_get_cmd_direction() - Determine control_flag data direction.

 * @sp: SCSI command

 *

 * Returns the proper CF_* direction based on CDB.

 Set transfer direction */

/**

 * qla2x00_calc_iocbs_32() - Determine number of Command Type 2 and

 * Continuation Type 0 IOCBs to allocate.

 *

 * @dsds: number of data segment descriptors needed

 *

 * Returns the number of IOCB entries needed to store @dsds.

/**

 * qla2x00_calc_iocbs_64() - Determine number of Command Type 3 and

 * Continuation Type 1 IOCBs to allocate.

 *

 * @dsds: number of data segment descriptors needed

 *

 * Returns the number of IOCB entries needed to store @dsds.

/**

 * qla2x00_prep_cont_type0_iocb() - Initialize a Continuation Type 0 IOCB.

 * @vha: HA context

 *

 * Returns a pointer to the Continuation Type 0 IOCB packet.

 Adjust ring index. */

 Load packet defaults. */

/**

 * qla2x00_prep_cont_type1_iocb() - Initialize a Continuation Type 1 IOCB.

 * @vha: HA context

 * @req: request queue

 *

 * Returns a pointer to the continuation type 1 IOCB packet.

 Adjust ring index. */

 Load packet defaults. */

 We always use DIFF Bundling for best performance */

 Translate SCSI opcode to a protection opcode */

 Normal Request */

/*

 * qla2x00_build_scsi_iocbs_32() - Build IOCB command utilizing 32bit

 * capable IOCB types.

 *

 * @sp: SRB command to process

 * @cmd_pkt: Command type 2 IOCB

 * @tot_dsds: Total number of segments to transfer

 Update entry type to indicate Command Type 2 IOCB */

 No data transfer */

 Three DSDs are available in the Command Type 2 IOCB */

 Load data segments */

 Allocate additional continuation packets? */

			/*

			 * Seven DSDs are available in the Continuation

			 * Type 0 IOCB.

/**

 * qla2x00_build_scsi_iocbs_64() - Build IOCB command utilizing 64bit

 * capable IOCB types.

 *

 * @sp: SRB command to process

 * @cmd_pkt: Command type 3 IOCB

 * @tot_dsds: Total number of segments to transfer

 Update entry type to indicate Command Type 3 IOCB */

 No data transfer */

 Two DSDs are available in the Command Type 3 IOCB */

 Load data segments */

 Allocate additional continuation packets? */

			/*

			 * Five DSDs are available in the Continuation

			 * Type 1 IOCB.

/*

 * Find the first handle that is not in use, starting from

 * req->current_outstanding_cmd + 1. The caller must hold the lock that is

 * associated with @req.

/**

 * qla2x00_start_scsi() - Send a SCSI command to the ISP

 * @sp: command to send to the ISP

 *

 * Returns non-zero if a failure occurred, else zero.

 Setup device pointers. */

 So we know we haven't pci_map'ed anything yet */

 Send marker if required */

 Acquire ring specific lock */

 Map the sg table so we have an accurate count of sg entries needed */

 Calculate the number of request entries needed. */

 If still no head room then bail out */

 Build command packet */

 Zero out remaining portion of packet. */

 Set target ID and LUN number*/

 Load SCSI command packet. */

 Build IOCB segments */

 Set total data segment count. */

 Adjust ring index. */

 Set chip new ring index. */

 PCI Posting. */

 Manage unprocessed RIO/ZIO commands in response queue. */

/**

 * qla2x00_start_iocbs() - Execute the IOCB command

 * @vha: HA context

 * @req: request queue

 Adjust ring index. */

 Set chip new ring index. */

/**

 * __qla2x00_marker() - Send a marker IOCB to the firmware.

 * @vha: HA context

 * @qpair: queue pair pointer

 * @loop_id: loop ID

 * @lun: LUN

 * @type: marker modifier

 *

 * Can be called from both normal and interrupt context.

 *

 * Returns non-zero if a failure occurred, else zero.

/*

 * qla2x00_issue_marker

 *

 * Issue marker

 * Caller CAN have hardware lock held as specified by ha_locked parameter.

 * Might release it, then reaquire.

 Update entry type to indicate Command Type 3 IOCB */

 No data transfer */

 Set transfer direction */

 Null termination */

/*

 * qla24xx_calc_dsd_lists() - Determine number of DSD list required

 * for Command Type 6.

 *

 * @dsds: number of data segment descriptors needed

 *

 * Returns the number of dsd list needed to store @dsds.

/**

 * qla24xx_build_scsi_iocbs() - Build IOCB command utilizing Command Type 7

 * IOCB types.

 *

 * @sp: SRB command to process

 * @cmd_pkt: Command type 3 IOCB

 * @tot_dsds: Total number of segments to transfer

 * @req: pointer to request queue

 Update entry type to indicate Command Type 3 IOCB */

 No data transfer */

 Set transfer direction */

 One DSD is available in the Command Type 3 IOCB */

 Load data segments */

 Allocate additional continuation packets? */

			/*

			 * Five DSDs are available in the Continuation

			 * Type 1 IOCB.

 Validation/Replacement Mask*/

 Validation/Replacement Mask*/

/*

 * qla24xx_set_t10dif_tags_from_cmd - Extract Ref and App tags from SCSI command

 *

 protection interval */

 Allocate additional continuation packets? */

 allocate tracking DS */

 allocate new list */

				/*

				 * Need to cleanup only this dsd_ptr, rest

				 * will be done by sp_free_dma()

 add new list to cmd iocb or last list */

 Got a full protection interval */

 So as to not re-enter this block */

 Null termination */

 Allocate additional continuation packets? */

 allocate tracking DS */

 allocate new list */

				/*

				 * Need to cleanup only this dsd_ptr, rest

				 * will be done by sp_free_dma()

 add new list to cmd iocb or last list */

 Null termination */

 if initiator doing write or target doing read */

 If SGE addr + len flips bits in upper 32-bits */

 Track DSD buffers */

 Track local DMA buffers */

					/*

					 * Allocate list item to store

					 * the DMA buffers

 allocate dma buffer */

						/*

						 * need to cleanup only this

						 * dsd_ptr rest will be done

						 * by sp_free_dma()

 xfrlen is min of dma pool size and sglen */

 replace with local allocated dma buffer */

 Allocate additional continuation packets? */

 allocate tracking DS */

 allocate new list */

					/*

					 * need to cleanup only this dsd_ptr

					 *  rest will be done by sp_free_dma()

 add new list to cmd iocb or last list */

 Allocate additional continuation packets? */

 allocate tracking DS */

 allocate new list */

 need to cleanup only this dsd_ptr */

 rest will be done by sp_free_dma() */

 add new list to cmd iocb or last list */

 Null termination */

/**

 * qla24xx_build_scsi_crc_2_iocbs() - Build IOCB command utilizing Command

 *							Type 6 IOCB types.

 *

 * @sp: SRB command to process

 * @cmd_pkt: Command type 3 IOCB

 * @tot_dsds: Total number of segments to transfer

 * @tot_prot_dsds: Total number of segments with protection information

 * @fw_prot_opts: Protection options to be passed to firmware

 Update entry type to indicate Command Type CRC_2 IOCB */

 No data transfer */

 Set transfer direction */

 Allocate CRC context from global pool */

 Set handle */

 Determine SCSI command length -- align to 4 byte boundary */

 SCSI cmd > 16 bytes must be multiple of 4 */

 Let response come in status iocb */

 Compute dif len and adjust data len to incude protection */

 Disable Guard tag checking */

 HBA error checking enabled */

		/*

		 * Configure Bundling if we need to fetch interlaving

		 * protection PCI accesses

 Finish the common fields of CRC pkt */

 Fibre channel byte count */

 Walks data segments */

 Walks dif segments */

 Cleanup will be performed by the caller */

/**

 * qla24xx_start_scsi() - Send a SCSI command to the ISP

 * @sp: command to send to the ISP

 *

 * Returns non-zero if a failure occurred, else zero.

 Setup device pointers. */

 So we know we haven't pci_map'ed anything yet */

 Send marker if required */

 Acquire ring specific lock */

 Map the sg table so we have an accurate count of sg entries needed */

 Build command packet. */

 Zero out remaining portion of packet. */

    tagged queuing modifier -- default is TSK_SIMPLE (0). */

 Set NPORT-ID and LUN number*/

 Load SCSI command packet. */

 Build IOCB segments */

 Set total data segment count. */

 Adjust ring index. */

 Set chip new ring index. */

 Manage unprocessed RIO/ZIO commands in response queue. */

/**

 * qla24xx_dif_start_scsi() - Send a SCSI command to the ISP

 * @sp: command to send to the ISP

 *

 * Returns non-zero if a failure occurred, else zero.

 Only process protection or >16 cdb in this routine */

 Setup device pointers. */

 So we know we haven't pci_map'ed anything yet */

 Send marker if required */

 Acquire ring specific lock */

 Compute number of required data segments */

 Map the sg table so we have an accurate count of sg entries needed */

 number of required data segments */

 Compute number of required protection segments */

 Total Data and protection sg segment(s) */

 Build header part of command packet (excluding the OPCODE). */

 Fill-in common area */

 Set NPORT-ID and LUN number*/

 Total Data and protection segment(s) */

 Build IOCB segments and adjust for data protection segments */

 Specify response queue number where completion should happen */

 Adjust ring index. */

 Set chip new ring index. */

 Manage unprocessed RIO/ZIO commands in response queue. */

 Cleanup will be performed by the caller (queuecommand) */

/**

 * qla2xxx_start_scsi_mq() - Send a SCSI command to the ISP

 * @sp: command to send to the ISP

 *

 * Returns non-zero if a failure occurred, else zero.

 Acquire qpair specific lock */

 Setup qpair pointers */

 So we know we haven't pci_map'ed anything yet */

 Send marker if required */

 Map the sg table so we have an accurate count of sg entries needed */

 Build command packet. */

 Zero out remaining portion of packet. */

    tagged queuing modifier -- default is TSK_SIMPLE (0). */

 Set NPORT-ID and LUN number*/

 Load SCSI command packet. */

 Build IOCB segments */

 Set total data segment count. */

 Adjust ring index. */

 Set chip new ring index. */

 Manage unprocessed RIO/ZIO commands in response queue. */

/**

 * qla2xxx_dif_start_scsi_mq() - Send a SCSI command to the ISP

 * @sp: command to send to the ISP

 *

 * Returns non-zero if a failure occurred, else zero.

 Check for host side state */

 Only process protection or >16 cdb in this routine */

 Setup qpair pointers */

 So we know we haven't pci_map'ed anything yet */

 Send marker if required */

 Compute number of required data segments */

 Map the sg table so we have an accurate count of sg entries needed */

 number of required data segments */

 Compute number of required protection segments */

 Total Data and protection sg segment(s) */

 Build header part of command packet (excluding the OPCODE). */

 Fill-in common area */

 Set NPORT-ID and LUN number*/

 Total Data and protection segment(s) */

 Build IOCB segments and adjust for data protection segments */

 Adjust ring index. */

 Set chip new ring index. */

 Manage unprocessed RIO/ZIO commands in response queue. */

 Cleanup will be performed by the caller (queuecommand) */

 Generic Control-SRB manipulation functions. */

 hardware_lock assumed to be held. */

 Adjust entry-counts as needed. */

 Check for room on request queue. */

 Prep command array. */

 Prep packet */

 Set service parameter BIT_7 for NVME CONF support */

 Set service parameter BIT_8 for SLER support */

 Set service parameter BIT_9 for PI control support */

 Implicit: mbx->mbx10 = 0. */

 Abort the exchange */

 Alloc SRB structure */

 For SID the byte order is different than DID */

 Abort the exchange */

 conflict Nport id */

					/*

					 * Another fcport shares the same

					 * loop_id & nport id; conflict

					 * fcport needs to finish cleanup

					 * before this fcport can proceed

					 * to login.

 Alloc SRB structure */

 it is assume qpair lock is held */

 For SID the byte order is different than DID */

 Allocate additional continuation packets? */

			/*

			* Five DSDs are available in the Cont.

			* Type 1 IOCB.

 Allocate additional continuation packets? */

			/*

			 * Five DSDs are available in the Cont.

			 * Type 1 IOCB.

 Allocate additional continuation packets? */

			/*

			* Five DSDs are available in the Cont.

			* Type 1 IOCB.

/*

 * qla82xx_start_scsi() - Send a SCSI command to the ISP

 * @sp: command to send to the ISP

 *

 * Returns non-zero if a failure occurred, else zero.

 Setup device pointers. */

 So we know we haven't pci_map'ed anything yet */

 Send marker if required */

 Acquire ring specific lock */

 Map the sg table so we have an accurate count of sg entries needed */

 Initialize the DSD list and dma handle */

				/* SCSI command bigger than 16 bytes must be

				 * multiple of 4

 Zero out remaining portion of packet. */

    tagged queuing modifier -- default is TSK_SIMPLE (0). */

 Set NPORT-ID and LUN number*/

 Build IOCB segments */

 build FCP_CMND IU */

 Populate the FCP_PRIO. */

 Set total data segment count. */

		/* Specify response queue number where

		 * completion should happen

 Zero out remaining portion of packet. */

 tagged queuing modifier -- default is TSK_SIMPLE (0).*/

 Set NPORT-ID and LUN number*/

 Populate the FCP_PRIO. */

 Load SCSI command packet. */

 Build IOCB segments */

 Set total data segment count. */

		/* Specify response queue number where

		 * completion should happen.

 Build command packet. */

 Adjust ring index. */

 Set chip new ring index. */

 write, read and verify logic */

 Manage unprocessed RIO/ZIO commands in response queue. */

 need to pass original sp */

 Send the command to the firmware */

/*

 * Build NVME LS request

	/*

	 * index map in firmware starts with 1; decrement index

	 * this is ok as we never use index 0

Update entry type to indicate bidir command */

	/* Set the transfer direction, in this set both flags

	 * Also set the BD_WRAP_BACK flag, firmware will take care

	 * assigning DID=SID for outgoing pkts.

	/* Only one dsd is available for bidirectional IOCB, remaining dsds

	 * are bundled in continuation iocb

 Allocate additional continuation packets */

			/* Continuation type 1 IOCB can accomodate

			 * 5 DSDS

	/* For read request DSD will always goes to continuation IOCB

	 * and follow the write DSD. If there is room on the current IOCB

	 * then it is added to that IOCB else new continuation IOCB is

	 * allocated.

 Allocate additional continuation packets */

			/* Continuation type 1 IOCB can accomodate

			 * 5 DSDS

 This value should be same as number of IOCB required for this cmd */

 Send marker if required */

 Acquire ring specific lock */

 Calculate number of IOCB required */

 Check for room on request queue. */

 Zero out remaining portion of packet. */

 tagged queuing modifier -- default is TSK_SIMPLE (0).*/

 Set NPORT-ID  (of vha)*/

 Build command packet. */

 Send the command to the firmware */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

/*

 * qla2x00_mailbox_command

 *	Issue mailbox command and waits for completion.

 *

 * Input:

 *	ha = adapter block pointer.

 *	mcp = driver internal mbx struct pointer.

 *

 * Output:

 *	mb[MAX_MAILBOX_REGISTER_COUNT] = returned mailbox data.

 *

 * Returns:

 *	0 : QLA_SUCCESS = cmd performed success

 *	1 : QLA_FUNCTION_FAILED   (error encountered)

 *	6 : QLA_FUNCTION_TIMEOUT (timeout condition encountered)

 *

 * Context:

 *	Kernel context.

 if PCI error, then avoid mbx processing.*/

 Setting Link-Down error */

 check if ISP abort is active and return cmd with timeout */

	/*

	 * Wait for active mailbox commands to finish by waiting at most tov

	 * seconds. This is to serialize actual issuing of mailbox cmds during

	 * non ISP abort time.

 Timeout occurred. Return error. */

 Save mailbox command for debug */

 Load mailbox registers. */

 Issue set host interrupt command to send cmd out. */

 Unlock mbx registers and wait for interrupt */

 Wait for mbx cmd completion until timeout */

 wait at most tov secs */

 Check for pending interrupts. */

 while */

 Check whether we timed out */

 Got interrupt. Clear the flag. */

 Setting Link-Down error */

 Load return mailbox registers. */

 Capture FW dump only, if PCI device active */

				/* This is special case if there is unload

				 * of driver happening and if PCI device go

				 * into bad state due to PCI error condition

				 * then only PCI ERR flag would be set.

				 * we will do premature exit for above case.

			/* Attempt to capture firmware dump for further

			 * anallysis of the current formware state. we do not

			 * need to do this if we are intentionally generating

			 * a dump

 Clean up */

 polling mode for non isp_abort commands. */

 not in dpc. schedule it for dpc to take over. */

 call abort directly since we are in the DPC thread */

 Allow next mbx cmd to come in. */

 Failed. retry later. */

 Allow next mbx cmd to come in. */

		/*

		 * The caller of this mailbox encounter pci error.

		 * Hold the thread until PCIE link reset complete to make

		 * sure caller does not unmap dma while recovery is

		 * in progress.

/*

 * qla2x00_execute_fw

 *     Start adapter firmware.

 *

 * Input:

 *     ha = adapter block pointer.

 *     TARGET_QUEUE_LOCK must be released.

 *     ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *     qla2x00 local function return status code.

 *

 * Context:

 *     Kernel context.

 Enable BPM? */

 set minimum speed if specified in nvram */

/*

 * qla_get_exlogin_status

 *	Get extended login status

 *	uses the memory offload control/status Mailbox

 *

 * Input:

 *	ha:		adapter state pointer.

 *	fwopt:		firmware options

 *

 * Returns:

 *	qla2x00 local function status

 *

 * Context:

 *	Kernel context.

/*

 * qla_set_exlogin_mem_cfg

 *	set extended login memory configuration

 *	Mbx needs to be issues before init_cb is set

 *

 * Input:

 *	ha:		adapter state pointer.

 *	buffer:		buffer pointer

 *	phys_addr:	physical address of buffer

 *	size:		size of buffer

 *	TARGET_QUEUE_LOCK must be released

 *	ADAPTER_STATE_LOCK must be release

 *

 * Returns:

 *	qla2x00 local funxtion status code.

 *

 * Context:

 *	Kernel context.

/*

 * qla_get_exchoffld_status

 *	Get exchange offload status

 *	uses the memory offload control/status Mailbox

 *

 * Input:

 *	ha:		adapter state pointer.

 *	fwopt:		firmware options

 *

 * Returns:

 *	qla2x00 local function status

 *

 * Context:

 *	Kernel context.

/*

 * qla_set_exchoffld_mem_cfg

 *	Set exchange offload memory configuration

 *	Mbx needs to be issues before init_cb is set

 *

 * Input:

 *	ha:		adapter state pointer.

 *	buffer:		buffer pointer

 *	phys_addr:	physical address of buffer

 *	size:		size of buffer

 *	TARGET_QUEUE_LOCK must be released

 *	ADAPTER_STATE_LOCK must be release

 *

 * Returns:

 *	qla2x00 local funxtion status code.

 *

 * Context:

 *	Kernel context.

EMPTY*/

/*

 * qla2x00_get_fw_version

 *	Get firmware version.

 *

 * Input:

 *	ha:		adapter state pointer.

 *	major:		pointer for major number.

 *	minor:		pointer for minor number.

 *	subminor:	pointer for subminor number.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

 Return mailbox data. */

 Defaults to 128KB. */

		/*

		 * FW supports nvme and driver load parameter requested nvme.

		 * BIT 26 of fw_attributes indicates NVMe support.

 BIT_13 of Extended FW Attributes informs about NVMe2 support */

 set BIT_15 of special feature control block for SLER */

 set BIT_14 of special feature control block for PI CTRL*/

EMPTY*/

EMPTY*/

/*

 * qla2x00_get_fw_options

 *	Set firmware options.

 *

 * Input:

 *	ha = adapter block pointer.

 *	fwopt = pointer for firmware options.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

EMPTY*/

/*

 * qla2x00_set_fw_options

 *	Set firmware options.

 *

 * Input:

 *	ha = adapter block pointer.

 *	fwopt = pointer for firmware options.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

 Undocumented, but used */

EMPTY*/

EMPTY*/

/*

 * qla2x00_mbx_reg_test

 *	Mailbox register wrap test.

 *

 * Input:

 *	ha = adapter block pointer.

 *	TARGET_QUEUE_LOCK must be released.

 *	ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

EMPTY*/

EMPTY*/

/*

 * qla2x00_verify_checksum

 *	Verify firmware checksum.

 *

 * Input:

 *	ha = adapter block pointer.

 *	TARGET_QUEUE_LOCK must be released.

 *	ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

/*

 * qla2x00_issue_iocb

 *	Issue IOCB using mailbox command

 *

 * Input:

 *	ha = adapter state pointer.

 *	buffer = buffer pointer.

 *	phys_addr = physical address of buffer.

 *	size = size of buffer.

 *	TARGET_QUEUE_LOCK must be released.

 *	ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

EMPTY*/

 Mask reserved bits. */

/*

 * qla2x00_abort_command

 *	Abort command aborts a specified IOCB.

 *

 * Input:

 *	ha = adapter block pointer.

 *	sp = SB structure pointer.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

 command not found */

 Issue marker IOCB. */

 Issue marker IOCB. */

/*

 * qla2x00_get_adapter_id

 *	Get adapter ID and topology.

 *

 * Input:

 *	ha = adapter block pointer.

 *	id = pointer for loop ID.

 *	al_pa = pointer for AL_PA.

 *	area = pointer for area.

 *	domain = pointer for domain.

 *	top = pointer for topology.

 *	TARGET_QUEUE_LOCK must be released.

 *	ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

 Return data. */

EMPTY*/

 If FA-WWN supported */

/*

 * qla2x00_get_retry_cnt

 *	Get current firmware login retry count and delay.

 *

 * Input:

 *	ha = adapter block pointer.

 *	retry_cnt = pointer to login retry count.

 *	tov = pointer to login timeout value.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

EMPTY*/

 Convert returned data and check our values. */

 mb[3] value is in 100ms */

 Update to the larger values */

/*

 * qla2x00_init_firmware

 *	Initialize adapter firmware.

 *

 * Input:

 *	ha = adapter block pointer.

 *	dptr = Initialization control block pointer.

 *	size = size of initialization control block.

 *	TARGET_QUEUE_LOCK must be released.

 *	ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

 1 and 2 should normally be captured. */

 mb3 is additional info about the installed SFP. */

EMPTY*/

/*

 * qla2x00_get_port_database

 *	Issue normal/enhanced get port database mailbox command

 *	and copy device name as necessary.

 *

 * Input:

 *	ha = adapter state pointer.

 *	dev = structure pointer.

 *	opt = enhanced cmd option byte.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

 Check for logged in state. */

 Check for logged in state. */

 We lost the device mid way. */

 Names are little-endian. */

 Get port_id of device. */

 If not target must be initiator or unknown type. */

 Passback COS information. */

 Check for logged in state. */

 We lost the device mid way. */

 Names are little-endian. */

 Get port_id of device. */

 If not target must be initiator or unknown type. */

 Passback COS information. */

/*

 * qla2x00_get_firmware_state

 *	Get adapter firmware state.

 *

 * Input:

 *	ha = adapter block pointer.

 *	dptr = pointer for firmware state.

 *	TARGET_QUEUE_LOCK must be released.

 *	ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

 Return firmware states. */

 SFP info */

 DPORT status */

EMPTY*/

/*

 * qla2x00_get_port_name

 *	Issue get port name mailbox command.

 *	Returned name is in big endian format.

 *

 * Input:

 *	ha = adapter block pointer.

 *	loop_id = loop ID of device.

 *	name = pointer for name.

 *	TARGET_QUEUE_LOCK must be released.

 *	ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

EMPTY*/

 This function returns name in big endian. */

/*

 * qla24xx_link_initialization

 *	Issue link initialization mailbox command.

 *

 * Input:

 *	ha = adapter block pointer.

 *	TARGET_QUEUE_LOCK must be released.

 *	ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

/*

 * qla2x00_lip_reset

 *	Issue LIP reset mailbox command.

 *

 * Input:

 *	ha = adapter block pointer.

 *	TARGET_QUEUE_LOCK must be released.

 *	ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

 Logout across all FCFs. */

EMPTY*/

EMPTY*/

/*

 * qla2x00_send_sns

 *	Send SNS command.

 *

 * Input:

 *	ha = adapter block pointer.

 *	sns = pointer for command.

 *	cmd_size = command size.

 *	buf_size = response/command size.

 *	TARGET_QUEUE_LOCK must be released.

 *	ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

EMPTY*/

EMPTY*/

 Passback COS information. */

 Class 2. */

 Class 3. */

			mb[10] |= BIT_7;	/* Confirmed Completion

						 * Allowed

/*

 * qla2x00_login_fabric

 *	Issue login fabric port mailbox command.

 *

 * Input:

 *	ha = adapter block pointer.

 *	loop_id = device loop ID.

 *	domain = device domain.

 *	area = device area.

 *	al_pa = device AL_PA.

 *	status = pointer for return status.

 *	opt = command options.

 *	TARGET_QUEUE_LOCK must be released.

 *	ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

 Return mailbox statuses. */

 COS retrieved from Get-Port-Database mailbox command. */

		/* RLU tmp code: need to change main mailbox_command function to

		 * return ok even when the mailbox completion value is not

		 * SUCCESS. The caller needs to be responsible to interpret

		 * the return values of this mailbox command if we're not

		 * to change too much of the existing code.

EMPTY*/

EMPTY*/

/*

 * qla2x00_login_local_device

 *           Issue login loop port mailbox command.

 *

 * Input:

 *           ha = adapter block pointer.

 *           loop_id = device loop ID.

 *           opt = command options.

 *

 * Returns:

 *            Return status code.

 *

 * Context:

 *            Kernel context.

 *

 Return mailbox statuses. */

 		/* AV tmp code: need to change main mailbox_command function to

 		 * return ok even when the mailbox completion value is not

 		 * SUCCESS. The caller needs to be responsible to interpret

 		 * the return values of this mailbox command if we're not

 		 * to change too much of the existing code.

EMPTY*/

EMPTY*/

/*

 * qla2x00_fabric_logout

 *	Issue logout fabric port mailbox command.

 *

 * Input:

 *	ha = adapter block pointer.

 *	loop_id = device loop ID.

 *	TARGET_QUEUE_LOCK must be released.

 *	ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

EMPTY*/

EMPTY*/

/*

 * qla2x00_full_login_lip

 *	Issue full login LIP mailbox command.

 *

 * Input:

 *	ha = adapter block pointer.

 *	TARGET_QUEUE_LOCK must be released.

 *	ADAPTER_STATE_LOCK must be released.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

EMPTY*/

EMPTY*/

/*

 * qla2x00_get_id_list

 *

 * Input:

 *	ha = adapter block pointer.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

EMPTY*/

/*

 * qla2x00_get_resource_cnts

 *	Get current firmware resource counts.

 *

 * Input:

 *	ha = adapter block pointer.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

EMPTY*/

/*

 * qla2x00_get_fcal_position_map

 *	Get FCAL (LILP) position map using mailbox command

 *

 * Input:

 *	ha = adapter state pointer.

 *	pos_map = buffer pointer (can be NULL).

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

/*

 * qla2x00_get_link_status

 *

 * Input:

 *	ha = adapter block pointer.

 *	loop_id = device loop ID.

 *	ret_buf = pointer to link status return buffer.

 *

 * Returns:

 *	0 = success.

 *	BIT_0 = mem alloc error.

 *	BIT_1 = mailbox error.

 Re-endianize - firmware data is le32. */

 Failed. */

 Re-endianize - firmware data is le32. */

 Failed. */

 Command not found. */

 Need to pass original sp */

 NPIV port */

 Issue marker IOCB. */

/**

 * qla2x00_set_serdes_params() -

 * @vha: HA context

 * @sw_em_1g: serial link options

 * @sw_em_2g: serial link options

 * @sw_em_4g: serial link options

 *

 * Returns

EMPTY*/

EMPTY*/

 Return mailbox statuses. */

 Return mailbox statuses. */

 loop */

 fabric */

 if our portname is higher then initiate N2N login */

 buffer to buffer credit flag */

 FA-WWN is only for physical port */

			/*

			 * Cannot configure here as we are still sitting on the

			 * response queue. Handle it in dpc context.

 N2N.  direct connect */

			/*

			 * For the case where remote port sending PRLO, FW

			 * sends up RIDA Format 2 as an indication of session

			 * loss. In other word, FW state change from PRLI

			 * complete back to PLOGI complete. Delete the

			 * session and let relogin drive the reconnect.

/*

 * qla24xx_modify_vp_config

 *	Change VP configuration for vha

 *

 * Input:

 *	vha = adapter block pointer.

 *

 * Returns:

 *	qla2xxx local function return status code.

 *

 * Context:

 *	Kernel context.

 This can be called by the parent */

 EMPTY */

/*

 * qla2x00_send_change_request

 *	Receive or disable RSCN request from fabric controller

 *

 * Input:

 *	ha = adapter block pointer

 *	format = registration format:

 *		0 - Reserved

 *		1 - Fabric detected registration

 *		2 - N_port detected registration

 *		3 - Full registration

 *		FF - clear registration

 *	vp_idx = Virtual port index

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel Context

 84XX Support **************************************************************/

 Force Update? */

 Diagnostic firmware? */

 options |= MENLO_DIAG_FW; */

 We update the firmware with only one data sequence. */

 NOTE: we only update OP firmware. */

 que in ptr index */

 que out ptr index */

 debug q create issue in SR-IOV */

 que in ptr index */

 que out ptr index */

 debug q create issue in SR-IOV */

 List of Purex ELS */

 sfp is not there */

 BIT_6 specifies 64 bit addressing

 transfer count */

 send data address */

 receive data address */

 Iteration count */

 Copy mailbox information */

 BIT_6 specifies 64bit address */

 Copy mailbox information */

 Write the MBC data to the registers */

 Poll for MBC interrupt */

 Check for pending interrupts. */

 Set the specified data rate */

 Copy all bits to preserve original value */

 Copy all bits to preserve original setting */

 Always copy back return mailbox values. */

 Perform Implicit LOGO. */

			/*

			 * During soft-reset CAMRAM register reads might

			 * return 0xbad0bad0. So retry for MAX of 2 sec

			 * while reading camram registers.

 Setting RAM ID to valid */

 For MCTP RAM ID is 0x40 */

 don't free sp here. Let the caller do the free */

/*

 * This mailbox uses the iocb interface to send MB command.

 * This allows non-critial (non chip setup) command to go

 * out in parrallel.

/*

 * qla24xx_gpdb_wait

 * NOTE: Do not call this routine from DPC thread

 Check for logged in state. */

 We lost the device mid way. */

 Names are little-endian. */

 Get port_id of device. */

 If not target must be initiator or unknown type. */

 Passback COS information. */

/*

 * qla24xx_gidlist__wait

 * NOTE: don't call this routine from DPC thread.

 Skip to next device address. */

/**

 * qla_no_op_mb(): This MB is used to check if FW is still alive and

 * able to generate an interrupt. Otherwise, a timeout will trigger

 * FW dump + reset

 * @vha: host adapter pointer

 * Return: None

 noop cmd= 0

 Receiving all 32 register's contents */

 passing all 32 register's contents */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

 Only supported for FC-NVMe devices that are registered. */

 Only supported for FC-NVMe devices that are registered. */

 CONFIG_NVME_FC */

 CONFIG_NVME_FC */

/*

 * Wrapper for getting fc_port fields.

 *

 * _attr    : Attribute name.

 * _get_val : Accessor macro to retrieve the value.

 lock is not require. It's an estimate. */

 DIF stats */

 Pause tracing to flush FCE buffers. */

 Re-enable FCE tracing. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Marvell Fibre Channel HBA Driver

 * Copyright (c)  2021     Marvell

 timeout called when no traffic and delayed rx sa_index delete */

	/*

	 * if delete_sa_index is valid then no one has serviced this

	 * delayed delete

	/*

	 * delete_sa_index is invalidated when we find the new sa_index in

	 * the incoming data stream.  If it is not invalidated then we are

	 * still looking for the new sa_index because there is no I/O and we

	 * need to just force the rx delete and move on.  Otherwise

	 * we could get another rekey which will result in an error 66.

/*

 * create a new list entry for this nport handle and

 * add an sa_update index to the list - called for sa_update

 if the entry exists, then just update the sa_index */

	/*

	 * This is the normal path - there should be no existing entry

	 * when update is called.  The exception is at startup

	 * when update is called for the first two sa_indexes

	 * followed by a delete of the first sa_index

 remove an entry from the list */

 Get response */

/**

 * qla_edif_app_check(): check for valid application id.

 * @vha: host adapter pointer

 * @appid: application id

 * Return: false = fail, true = pass

 check that the app is allow/known to the driver */

 return an index to the freepool */

 release the sa_ctl */

 Release the index */

 Delete timer on RX */

				/*

				 * valid delete_sa_index indicates there is a rx

				 * delayed delete queued

 build and send the aen */

 find an release all outstanding sadb sa_indicies */

/**

 * qla_edif_app_start:  application has announce its present

 * @vha: host adapter pointer

 * @bsg_job: user request

 *

 * Set/activate doorbell.  Reset current sessions and re-login with

 * secure flag.

 mark doorbell as active since an app is now present */

 no activity */

 mark as active since an app is now present */

/**

 * qla_edif_app_stop - app has announced it's exiting.

 * @vha: host adapter pointer

 * @bsg_job: user space command pointer

 *

 * Free any in flight messages, clear all doorbell events

 * to application. Reject any message relate to security.

 Call db stop and enode stop functions */

 if we leave this running short waits are operational < 16 secs */

 stop enode */

 stop db */

 qla_edif_flush_sa_ctl_lists(fcport); */

 no return interface to app - it assumes we cleaned up ok */

/**

 * qla_edif_app_authok - authentication by app succeeded.  Driver can proceed

 *   with prli

 * @vha: host adapter pointer

 * @bsg_job: user request

	/*

	 * if port is online then this is a REKEY operation

	 * Only do sa update checking

 make sure in AUTH_PENDING or else reject */

/**

 * qla_edif_app_authfail - authentication by app has failed.  Driver is given

 *   notice to tear down current session.

 * @vha: host adapter pointer

 * @bsg_job: user request

	/*

	 * TODO: edif: app has failed this plogi. Inform driver to

	 * take any action (if any).

 set/reset edif values and flags */

/**

 * qla_edif_app_getfcinfo - app would like to read session info (wwpn, nportid,

 *   [initiator|target] mode.  It can specific session with specific nport id or

 *   all sessions.

 * @vha: host adapter pointer

 * @bsg_job: user request pointer

 Ran out of space */

/**

 * qla_edif_app_getstats - app would like to read various statistics info

 * @vha: host adapter pointer

 * @bsg_job: user request

 couldn't get space */

	/*

	 * need to allocate sa_index here and save it

	 * in both sa_ctl->index and sa_frame->fast_sa_index;

	 * If alloc fails then delete sa_ctl and return NULL

 add the sa to the correct list */

 map the spi to an sa_index */

 process rx delete */

 build and send the aen */

 force a return of good bsg status; */

 This is a local copy of sa_frame. */

 create the sa_ctl */

 Check if host is online */

 make sure the nport_handle is valid */

 allocate and queue an sa_ctl */

 failure of bsg */

 rx delete failure */

 looking for rx index and delete */

		/*

		 * make sure we have an existing rx key, otherwise just process

		 * this as a straight delete just like TX

		 * This is NOT a normal case, it indicates an error recovery or key cleanup

		 * by the ipsec code above us.

		/*

		 * if we have a forced delete for rx, remove the sa_index from the edif list

		 * and proceed with normal delete.  The rx delay timer should not be running

		/*

		 * delayed rx delete

		 *

		 * if delete_sa_index is not invalid then there is already

		 * a delayed index in progress, return bsg bad status

 free up the sa_ctl that was allocated with the sa_index */

 release the sa_index */

 configure and start the rx delay timer */

		/*

		 * Start the timer when we queue the delayed rx delete.

		 * This is an activity timer that goes off if we have not

		 * received packets with the new sa_index

		/*

		 * sa_delete for rx key with an active rx key including this one

		 * add the delete rx sa index to the hash so we can look for it

		 * in the rsp queue.  Do this after making any changes to the

		 * edif_entry as part of the rx delete.

	/*

	 * rx index and update

	 * add the index to the list and continue with normal update

 sa_update for rx key */

		/*

		 * add the update rx sa index to the hash so we can look for it

		 * in the rsp queue and continue normally

	/*

	 * sa_update for both rx and tx keys, sa_delete for tx key

	 * immediately process the request

 sp->free = qla2x00_bsg_sp_free; */

/*

 * send back error status

/**

 * qla_enode_init - initialize enode structs & lock

 * @vha: host adapter pointer

 *

 * should only be called when driver attaching

 list still active - error */

 initialize lock which protects pur_core & init list */

/**

 * qla_enode_stop - stop and clear and enode data

 * @vha: host adapter pointer

 *

 * called when app notified it is exiting

 doorbell list not enabled */

 grab lock so list doesn't move */

 mark it not active */

 hopefully this is a null list at this point */

/*

 *  allocate enode struct and populate buffer

 *  returns: enode pointer with buffers

 *           NULL on error

 secure the list from moving under us */

 node type determines what p1 and p2 are */

 found it and its complete */

/**

 * qla_pur_get_pending - read/return authentication message sent

 *  from remote port

 * @vha: host adapter pointer

 * @fcport: session pointer

 * @bsg_job: user request where the message is copy to.

	/*

	 * enode is now off the linked list and is ours to deal with

 Copy info back to caller */

 data copy / passback completed - destroy enode */

 it is assume qpair lock is held */

 flush iocb to mem before notifying hw doorbell */

 list already init'd - error */

 initialize lock which protects doorbell & init list */

 create and initialize doorbell */

	/*

	 * releases the space held by this edb node entry

	 * this function does _not_ free the edb node itself

	 * NB: the edb node entry passed should not be on any list

	 *

	 * currently for doorbell there's no additional cleanup

	 * needed, but here as a placeholder for furture use.

 doorbell list not enabled */

 grab lock so list doesn't move */

 app wants to see this  */

 function called when app is stopping */

 doorbell list not enabled */

 grab lock so list doesn't move */

 mark it not active */

 hopefully this is a null list at this point */

 wake up doorbell waiters - they'll be dismissed with error code */

 couldn't get space */

 adds a already allocated enode to the linked list */

 doorbell list not enabled */

 ring doorbell for waiters */

 adds event to doorbell list */

 edif not enabled */

 doorbell list not enabled */

 populate the edb node */

 db nodes are fifo - no qualifications done */

			/*

			 * turn off auto 'Plogi Acc + secure=1' feature

			 * Set Add FW option[3]

			 * BIT_15, if.

/*

 * app uses separate thread to read this. It'll wait until the doorbell

 * is rung by the driver or the max wait time has expired

 TODO: app currently hardcoded to 256. Will transition to bsg */

 stop new threads from waiting if we're not init'd */

 edif not enabled */

 remove the next item from the doorbell list */

 unknown node type, rtn unknown ntype */

 we're done with the db node, so free it up */

 8bytes = ap->event_code + ap->event_data_size */

/*

 * Called from work queue

 * build and send the sa_update iocb to delete an rx sa_index

 Alloc SRB structure */

	/*

	 * if this is a sadb cleanup delete, mark it so the isr can

	 * take the correct action

 mark this srb as a cleanup delete */

 Invalidate the index. salt, spi, control & key are ignore */

 edif support not enabled */

 add the local enode to the list */

 find an sadb entry for an nport_handle */

 remove an sa_index from the nport_handle and return it to the free pool */

	/*

	 * each tx/rx direction has up to 2 sa indexes/slots. 1 slot for in flight traffic

	 * the other is use at re-key time.

 use sp->vha due to npiv */

	/*

	 * dig the nport handle out of the iocb, fcport->loop_id can not be trusted

	 * to be correct during cleanup sa_update iocbs.

 if rx delete, remove the timer */

	/*

	 * if this is a delete for either tx or rx, make sure it succeeded.

	 * The new_sa_info field should be 0xffff on success

 Process update and delete the same way */

 If this is an sadb cleanup delete, bypass sending events to IPSEC */

		/*

		 * Note: Wa are only keeping track of latest SA,

		 * so we know when we can start enableing encryption per I/O.

		 * If all SA's get deleted, let FW reject the IOCB.



		 * TODO: edif: don't set enabled here I think

		 * TODO: edif: prli complete is where it should be set

 for delete, release sa_ctl, sa_index */

 release the sa_ctl */

	/*

	 * check for a failed sa_update and remove

	 * the sadb entry.

/**

 * qla28xx_start_scsi_edif() - Send a SCSI type 6 command to the ISP

 * @sp: command to send to the ISP

 *

 * Return: non-zero if a failure occurred, else zero.

 Setup device pointers. */

 So we know we haven't pci_map'ed anything yet */

 Send marker if required */

 Acquire ring specific lock */

 Check for room in outstanding command list. */

 Map the sg table so we have an accurate count of sg entries needed */

 Initialize the DSD list and dma handle */

			/*

			 * SCSI command bigger than 16 bytes must be

			 * multiple of 4

	/*

	 * Zero out remaining portion of packet.

	 * tagged queuing modifier -- default is TSK_SIMPLE (0).

 No data transfer */

 Set transfer direction */

 One DSD is available in the Command Type 6 IOCB */

 Load data segments */

 Allocate additional continuation packets? */

			/*

			 * Five DSDs are available in the Continuation

			 * Type 1 IOCB.

 Set NPORT-ID and LUN number*/

 Set total data segment count. */

 build FCP_CMND IU */

 Populate the FCP_PRIO. */

 Set total data segment count. */

 Build command packet. */

 Adjust ring index. */

 Set chip new ring index. */

/**********************************************

 * edif update/delete sa_index list functions *

 clear the edif_indx_list for this port */

/******************

 * SADB functions *

 allocate/retrieve an sa_index for a given spi */

 if there is no entry for this nport, add one */

 see if we already have an entry for this spi */

 both slots are used */

 there is at least one free slot, use it */

 release any sadb entries -- only done at teardown */

/**************************

 * sadb freepool functions

 build the rx and tx sa_index free pools -- only done at fcport init */

 release the free pool - only done during fcport teardown */

 no pending delete for this handle */

	/*

	 * check for no pending delete for this index or iocb does not

	 * match rx sa_index

	/*

	 * wait until we have seen at least EDIF_DELAY_COUNT transfers before

	 * queueing RX delete

 sanity check on the nport handle */

 find the sa_ctl for the delete and schedule the delete */

 sa_index used by this iocb */

 find out if this status iosb is for a scsi read */

 find matching d_id in fcport list */

 pass through is supported only for ISP 4Gb or higher */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

/*

 * Table for showing the current message id in use for particular level

 * Change this table for addition of log/debug messages.

 * ----------------------------------------------------------------------

 * |             Level            |   Last Value Used  |     Holes	|

 * ----------------------------------------------------------------------

 * | Module Init and Probe        |       0x0199       |                |

 * | Mailbox commands             |       0x1206       | 0x11a5-0x11ff	|

 * | Device Discovery             |       0x2134       | 0x210e-0x2115  |

 * |                              |                    | 0x211c-0x2128  |

 * |                              |                    | 0x212c-0x2134  |

 * | Queue Command and IO tracing |       0x3074       | 0x300b         |

 * |                              |                    | 0x3027-0x3028  |

 * |                              |                    | 0x303d-0x3041  |

 * |                              |                    | 0x302d,0x3033  |

 * |                              |                    | 0x3036,0x3038  |

 * |                              |                    | 0x303a		|

 * | DPC Thread                   |       0x4023       | 0x4002,0x4013  |

 * | Async Events                 |       0x509c       |                |

 * | Timer Routines               |       0x6012       |                |

 * | User Space Interactions      |       0x70e3       | 0x7018,0x702e  |

 * |				  |		       | 0x7020,0x7024  |

 * |                              |                    | 0x7039,0x7045  |

 * |                              |                    | 0x7073-0x7075  |

 * |                              |                    | 0x70a5-0x70a6  |

 * |                              |                    | 0x70a8,0x70ab  |

 * |                              |                    | 0x70ad-0x70ae  |

 * |                              |                    | 0x70d0-0x70d6	|

 * |                              |                    | 0x70d7-0x70db  |

 * | Task Management              |       0x8042       | 0x8000         |

 * |                              |                    | 0x8019         |

 * |                              |                    | 0x8025,0x8026  |

 * |                              |                    | 0x8031,0x8032  |

 * |                              |                    | 0x8039,0x803c  |

 * | AER/EEH                      |       0x9011       |		|

 * | Virtual Port                 |       0xa007       |		|

 * | ISP82XX Specific             |       0xb157       | 0xb002,0xb024  |

 * |                              |                    | 0xb09e,0xb0ae  |

 * |				  |		       | 0xb0c3,0xb0c6  |

 * |                              |                    | 0xb0e0-0xb0ef  |

 * |                              |                    | 0xb085,0xb0dc  |

 * |                              |                    | 0xb107,0xb108  |

 * |                              |                    | 0xb111,0xb11e  |

 * |                              |                    | 0xb12c,0xb12d  |

 * |                              |                    | 0xb13a,0xb142  |

 * |                              |                    | 0xb13c-0xb140  |

 * |                              |                    | 0xb149		|

 * | MultiQ                       |       0xc010       |		|

 * | Misc                         |       0xd303       | 0xd031-0xd0ff	|

 * |                              |                    | 0xd101-0xd1fe	|

 * |                              |                    | 0xd214-0xd2fe	|

 * | Target Mode		  |	  0xe081       |		|

 * | Target Mode Management	  |	  0xf09b       | 0xf002		|

 * |                              |                    | 0xf046-0xf049  |

 * | Target Mode Task Management  |	  0x1000d      |		|

 * ----------------------------------------------------------------------

 Request queue. */

 Response queue. */

 Check for pending interrupts. */

 Clear this intr; it wasn't a mailbox intr */

 no interrupt, timed out*/

 error completion status */

 Check for pending interrupts. */

 no interrupt, timed out*/

 error completion status */

 Code RAM. */

 External Memory. */

 100 usec delay is sufficient enough for hardware to pause RISC */

	/*

	 * Reset RISC. The delay is dependent on system architecture.

	 * Driver can proceed with the reset sequence after waiting

	 * for a timeout period.

 Wait for soft-reset to complete. */

 PCI Posting. */

 Check for pending interrupts. */

 Release mailbox registers. */

 clear this intr; it wasn't a mailbox intr */

 aqp = ha->atio_q_map[que]; */

 Add header. */

 Add data. */

 Request queues */

 Add chain. */

 Add header. */

 Add data. */

 Response queues */

 Add chain. */

 Add header. */

 Add data. */

/**

 * qla2300_fw_dump() - Dumps binary data from the 2300 firmware.

 * @vha: HA context

 Pause RISC. */

 PCI Posting. */

 Reset RISC. */

 Get RISC SRAM. */

 Get stack SRAM. */

 Get data SRAM. */

/**

 * qla2100_fw_dump() - Dumps binary data from the 2100/2200 firmware.

 * @vha: HA context

 Pause RISC. */

 Reset the ISP. */

 Pause RISC. */

 Set memory configuration and timing. */

 PCI Posting. */

 Release RISC. */

 Get RISC SRAM. */

 Check for pending interrupts. */

	/*

	 * Pause RISC. No need to track timeout, as resetting the chip

	 * is the right approach incase of pause timeout

 Host interface registers. */

 Disable interrupts. */

 Shadow registers. */

 Mailbox registers. */

 Transfer sequence registers. */

 Receive sequence registers. */

 Command DMA registers. */

 Queues. */

 Transmit DMA registers. */

 Receive DMA registers. */

 RISC registers. */

 Local memory controller registers. */

 Fibre Protocol Module registers. */

 Frame Buffer registers. */

 Adjust valid length. */

	/*

	 * Pause RISC. No need to track timeout, as resetting the chip

	 * is the right approach incase of pause timeout

 Host/Risc registers. */

 PCIe registers. */

 Host interface registers. */

 Disable interrupts. */

 Shadow registers. */

 RISC I/O register. */

 Mailbox registers. */

 Transfer sequence registers. */

 Receive sequence registers. */

 Auxiliary sequence registers. */

 Command DMA registers. */

 Queues. */

 Transmit DMA registers. */

 Receive DMA registers. */

 RISC registers. */

 Local memory controller registers. */

 Fibre Protocol Module registers. */

 Frame Buffer registers. */

 Multi queue registers */

 Chain entries -- started with MQ. */

 Adjust valid length. */

	/*

	 * Pause RISC. No need to track timeout, as resetting the chip

	 * is the right approach incase of pause timeout

 Host/Risc registers. */

 PCIe registers. */

 Host interface registers. */

 Disable interrupts. */

 Shadow registers. */

 RISC I/O register. */

 Mailbox registers. */

 Transfer sequence registers. */

 Receive sequence registers. */

 Auxiliary sequence registers. */

 Command DMA registers. */

 Queues. */

 Transmit DMA registers. */

 Receive DMA registers. */

 RISC registers. */

 Local memory controller registers. */

 Fibre Protocol Module registers. */

 Frame Buffer registers. */

 Multi queue registers */

 Chain entries -- started with MQ. */

 Adjust valid length. */

	/*

	 * Pause RISC. No need to track timeout, as resetting the chip

	 * is the right approach incase of pause timeout

 select PCR and disable ecc checking and correction */

 write to F0h = PCR */

 Host/Risc registers. */

 PCIe registers. */

 Host interface registers. */

 Disable interrupts. */

 Shadow registers. */

 RISC I/O register. */

 Mailbox registers. */

 Transfer sequence registers. */

 Receive sequence registers. */

 Auxiliary sequence registers. */

 Command DMA registers. */

 Queues. */

 Transmit DMA registers. */

 Receive DMA registers. */

 RISC registers. */

 Local memory controller registers. */

 Fibre Protocol Module registers. */

 RQ0 Array registers. */

 RQ1 Array registers. */

 RP0 Array registers. */

 RP1 Array registers. */

 I/O Queue Control registers. */

 Frame Buffer registers. */

 Multi queue registers */

 Chain entries -- started with MQ. */

 Adjust valid length. */

***************************************************************************/

                         Driver Debug Functions.                          */

***************************************************************************/

 Write the debug message prefix into @pbuf. */

 <module-name> [<dev-name>]-<msg-id>:<host>: */

 <module-name> [<dev-name>]-<msg-id>: : */

/*

 * This function is for formatting and logging debug information.

 * It is to be used when vha is available. It formats the message

 * and logs it to the messages file.

 * parameters:

 * level: The level of the debug messages to be printed.

 *        If ql2xextended_error_logging value is correctly set,

 *        this message will appear in the messages file.

 * vha:   Pointer to the scsi_qla_host_t.

 * id:    This is a unique identifier for the level. It identifies the

 *        part of the code from where the message originated.

 * msg:   The message to be displayed.

/*

 * This function is for formatting and logging debug information.

 * It is to be used when vha is not available and pci is available,

 * i.e., before host allocation. It formats the message and logs it

 * to the messages file.

 * parameters:

 * level: The level of the debug messages to be printed.

 *        If ql2xextended_error_logging value is correctly set,

 *        this message will appear in the messages file.

 * pdev:  Pointer to the struct pci_dev.

 * id:    This is a unique id for the level. It identifies the part

 *        of the code from where the message originated.

 * msg:   The message to be displayed.

/*

 * This function is for formatting and logging log messages.

 * It is to be used when vha is available. It formats the message

 * and logs it to the messages file. All the messages will be logged

 * irrespective of value of ql2xextended_error_logging.

 * parameters:

 * level: The level of the log messages to be printed in the

 *        messages file.

 * vha:   Pointer to the scsi_qla_host_t

 * id:    This is a unique id for the level. It identifies the

 *        part of the code from where the message originated.

 * msg:   The message to be displayed.

 FATAL LOG */

/*

 * This function is for formatting and logging log messages.

 * It is to be used when vha is not available and pci is available,

 * i.e., before host allocation. It formats the message and logs

 * it to the messages file. All the messages are logged irrespective

 * of the value of ql2xextended_error_logging.

 * parameters:

 * level: The level of the log messages to be printed in the

 *        messages file.

 * pdev:  Pointer to the struct pci_dev.

 * id:    This is a unique id for the level. It identifies the

 *        part of the code from where the message originated.

 * msg:   The message to be displayed.

 FATAL LOG */

/*

 * This function is for formatting and logging log messages.

 * It is to be used when vha is available. It formats the message

 * and logs it to the messages file. All the messages will be logged

 * irrespective of value of ql2xextended_error_logging.

 * parameters:

 * level: The level of the log messages to be printed in the

 *        messages file.

 * vha:   Pointer to the scsi_qla_host_t

 * id:    This is a unique id for the level. It identifies the

 *        part of the code from where the message originated.

 * msg:   The message to be displayed.

 FATAL LOG */

/*

 * This function is for formatting and logging debug information.

 * It is to be used when vha is available. It formats the message

 * and logs it to the messages file.

 * parameters:

 * level: The level of the debug messages to be printed.

 *        If ql2xextended_error_logging value is correctly set,

 *        this message will appear in the messages file.

 * vha:   Pointer to the scsi_qla_host_t.

 * id:    This is a unique identifier for the level. It identifies the

 *        part of the code from where the message originated.

 * msg:   The message to be displayed.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

 CRB window related */

	/*

	 * Used only in P3 just define it for P2 also.

/*

 * top 12 bits of crb internal address (hub, agent)

 Device states */

/*

 * In: 'off_in' is offset from CRB space in 128M pci map

 * Out: 'off_out' is 2M pci map addr

 * side effect: lock crb window

	/* Read back value to make sure write has gone through before trying

	 * to use it.

 Try direct map */

 Not in direct map, use crb window */

 acquire semaphore3 from PCI HW block */

/*

 * Context: task, might sleep

 acquire semaphore5 from PCI HW block */

/*

 * check memory access boundary.

 * used by test agent. support ddr access only for now

 DDR network side */

 QDR network side */

		/*

		 * peg gdb frequently accesses memory that doesn't exist,

		 * this limits the chit chat so debugging isn't slowed down.

 check if address is in the same windows as the previous access */

 DDR network side */

 QDR network side */

	/*

	 * If attempting to access unknown address or straddle hw windows,

	 * do not access.

	/* Map two pages whenever user tries to access addresses in two

	* consecutive pages.

	/*

	 * If attempting to access unknown address or straddle hw windows,

	 * do not access.

	/* Map two pages whenever user tries to access addresses in two

	 * consecutive pages.

 acquire semaphore2 from PCI HW block */

 Read back value to make sure write has gone through */

 Dword reads to flash. */

/* This routine does CRB initialize sequence

 *  to put the ISP into operational state

 Halt all the individual PEGs and other blocks of the ISP */

 disable all I2Q */

 disable all niu interrupts */

 disable xge rx/tx */

 disable xg1 rx/tx */

 disable sideband mac */

 disable ap0 mac */

 disable ap1 mac */

 halt sre */

 halt epg */

 halt timers */

 halt pegs */

 big hammer */

 don't reset CAM block on reset */

	/* Read the signature value from the flash.

	 * Offset 0: Contain signature (0xcafecafe)

	 * Offset 4: Offset and number of addr/value pairs

	 * that present in CRB initialize sequence

	/* Offset in flash = lower 16 bits

	 * Number of entries = upper 16 bits

 number of addr/value pair should not exceed 1024 entries */

		/* Translate internal CRB initialization

		 * address to PCI bus address

		/* Not all CRB  addr/value pair to be written,

		 * some of them are skipped

 skipping cold reboot MAGIC */

 do not reset PCI */

 skip core clock, so that firmware can increase the clock */

 skip the function enable register */

		/* ISP requires much bigger delay to settle down,

		 * else crb_window returns 0xffffffff

		/* ISP requires millisec delay between

		 * successive CRB register updation

 Resetting the data and instruction cache */

 Clear all protocol processing engines */

	/*

	 * If not MN, go check for MS or invalid.

	/*

	 * If not MN, go check for MS or invalid.

 PCI related functions */

 Use MMIO operations for all accesses. */

 Mapping of IO base pointer */

		/* Mapping of IO base pointer,

		 * door bell read and write pointer

 GS related functions */

 Initialization related functions */

/**

 * qla82xx_pci_config() - Setup ISP82xx PCI configuration registers.

 * @vha: HA context

 *

 * Returns 0 on success.

/**

 * qla82xx_reset_chip() - Setup ISP82xx PCI configuration registers.

 * @vha: HA context

 *

 * Returns 0 on success.

 Setup ring parameters in initialization control block. */

	/* Write a magic value to CAMRAM register

	 * at a specified offset to indicate

	 * that all data is written and

	 * ready for firmware to initialize.

 Hardcoding mn_present flag for P3P */

 ISR related functions */

/*

 * qla82xx_mbx_completion() - Process mailbox command completions.

 * @ha: SCSI driver HA context

 * @mb0: Mailbox0 register

 Load return mailbox registers. */

/**

 * qla82xx_intr_handler() - Process interrupts for the ISP23xx and ISP63xx.

 * @irq: interrupt number

 * @dev_id: SCSI driver HA context

 *

 * Called by system whenever the host adapter generates an interrupt.

 *

 * Returns handled flag.

 clear the interrupt */

 read twice to ensure write is flushed */

 ISP 8021 initializations */

 If reset value is all FF's, initialize DRV_ACTIVE */

 If reset value is all FF's, initialize DRV_STATE */

 Bring QM and CAMRAM out of reset */

	/*

	 * FW Load priority:

	 * 1) Operational firmware residing in flash.

	 * 2) Firmware via request-firmware interface (.bin file).

 Load firmware blob. */

 Validating firmware blob */

 Fallback to URI format */

 scrub dma mask expansion register */

	/* Put both the PEG CMD and RCV PEG to default state

	 * of 0 before resetting the hardware

 Overwrite stale initialization register values */

 Handshake with the card before we register the devices. */

 Negotiated Link width */

 Synchronize with Receive peg */

 Dword reads to flash. */

 LOCK all sectors */

/*

 * Address and length are byte address

 Prepare burst-capable write on supported ISPs. */

 Are we at the beginning of a sector? */

 Go with burst-write. */

 Copy data to DMA'ble buffer. */

 Suspend HBA. */

 Convert return ISP82xx to generic */

 Adjust ring index. */

 Someone else is holding the lock. */

	/*

	 * Either we got the lock, or someone

	 * else died while holding it.

	 * In either case, unlock.

/*

 * qla82xx_device_bootstrap

 *    Initialize device, set DEV_READY, start fw

 *

 * Note:

 *      IDC lock must be held upon entry

 *

 * Return:

 *    Success : 0

 *    Failed  : 1

 We are trying to perform a recovery here. */

 set to DEV_INITIALIZING */

/*

* qla82xx_need_qsnt_handler

*    Code to start quiescence sequence

*

* Note:

*      IDC lock must be held upon entry

*

* Return: void

Block any further I/O and wait for pending cmnds to complete*/

 Set the quiescence ready bit */

wait for 30 secs for other functions to ack */

 Its 2 that is written when qsnt is acked, moving one bit */

			/* quiescence timeout, other functions didn't ack

			 * changing the state to DEV_READY

 everyone acked so set the state to DEV_QUIESCENCE */

/*

* qla82xx_wait_for_state_change

*    Wait for device state to change from given current state

*

* Note:

*     IDC lock must not be held upon entry

*

* Return:

*    Changed device state.

 Disable the board */

 Set DEV_FAILED flag to disable timer */

/*

 * qla82xx_need_reset_handler

 *    Code to start reset sequence

 *

 * Note:

 *      IDC lock must be held upon entry

 *

 * Return:

 *    Success : 0

 *    Failed  : 1

 wait for 10 seconds for reset ack from all functions */

 Force to DEV_COLD unless someone else is starting a reset */

 Release MiniDump resources */

 ALlocate MiniDump resources */

 all 0xff, assume AER/EEH in progress, ignore */

 FW not alive after 2 seconds */

/*

 * qla82xx_device_state_handler

 *	Main state handler

 *

 * Note:

 *      IDC lock must be held upon entry

 *

 * Return:

 *    Success : 0

 *    Failed  : 1

 wait for 30 seconds for device to go ready */

 Reset timeout value after quiescence handler */

			/* Owner will exit and other will wait for the state

			 * to get changed

 Reset timeout value after quiescence handler */

 don't poll if reset is going on */

 Decide the reset ownership */

/*

 *  qla82xx_abort_isp

 *      Resets ISP and aborts all outstanding commands.

 *

 * Input:

 *      ha           = adapter block pointer.

 *

 * Returns:

 *      0 = success

 Decide the reset ownership */

				/*

				 * The next call disables the board

				 * completely.

 schedule another ISP abort */

/*

 *  qla82xx_fcoe_ctx_reset

 *      Perform a quick reset and aborts all outstanding commands.

 *      This will only perform an FCoE context reset and avoids a full blown

 *      chip reset.

 *

 * Input:

 *      ha = adapter block pointer.

 *      is_reset_path = flag for identifying the reset path.

 *

 * Returns:

 *      0 = success

 Abort all outstanding commands, so as to be requeued later */

	/* Stop currently executing firmware.

	 * This will destroy existing FCoE context at the F/W end.

 Restart. Creates a new FCoE context on INIT_FIRMWARE. */

/*

 * qla2x00_wait_for_fcoe_ctx_reset

 *    Wait till the FCoE context is reset.

 *

 * Note:

 *    Does context switching here.

 *    Release SPIN_LOCK (if any) before calling this routine.

 *

 * Return:

 *    Success (fcoe_ctx reset is done) : 0

 *    Failed  (fcoe_ctx reset not completed within max loop timout ) : 1

	/* Check if 82XX firmware is alive or not

	 * We may have arrived here from NEED_RESET

	 * detection only

 Abort all commands gracefully if fw NOT hung */

 Wait for pending cmds (physical and virtual) to complete */

 Minidump related functions */

 capturing dump failed */

 capturing dump failed */

 Validate whether required debug level is set */

 Check whether template obtained is valid */

 Walk through the entry headers */

		/* Decode the entry type and take

 Release the template header allocated */

 Release the template data buffer allocated */

 Get Minidump template size */

 Get Minidump template */

 Allocate memory for minidump */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

/*

*  QLogic ISP2x00 Hardware Support Function Prototypes.

 SRB Extensions ---------------------------------------------------------- */

 Asynchronous Login/Logout Routines -------------------------------------- */

 Firmware should use switch negotiated r_a_tov for timeout. */

		/*

		 * Except for earlier ISPs where the timeout is seeded from the

		 * initialization control block.

 removing the abort */

 FW can send 2 x ABTS's timeout/20s */

 Retry as needed. */

 Don't re-login in target mode */

 deleted = 0 & logout_on_delete = force fw cleanup */

 target side must have changed it. */

/**

 * qla2x00_find_new_loop_id - scan through our port list and find a new usable loop ID

 * @vha: adapter state pointer.

 * @dev: port structure pointer.

 *

 * Returns:

 *	qla2x00 local function return status code.

 *

 * Context:

 *	Kernel context.

 rval */

			/*

			 * Another share fcport share the same loop_id &

			 * nport id. Conflict fcport needs to finish

			 * cleanup before this fcport can proceed to login.

 check to see if App support Secure */

				/*

				 * In the middle of PRLI. Let it finish.

				 * Allow relogin code to recheck state again

				 * with GNL. Push disc_state back to DELETED

				 * so GNL can go out again

 check to see if App support secure or not */

 local adapter is smaller */

 local adapter is bigger */

 switch (ha->current_topology) */

				/*

				 * FW already picked this loop id for

				 * another fcport

					/*

					 * remote port is not sending PLOGI.

					 * Reset link to kick start his state

					 * machine

				/*

				 * report port suppose to do PLOGI. Give him

				 * more time. FW will catch it.

 gnl_event */

 amnt xfered */

 mask out reserve bit */

 create new fcport if fw has knowledge of new sessions */

 retrigger gnl */

		/*

		 * We have an existing session. A late RSCN delivery

		 * must have triggered the session to be re-validate.

		 * Session is still valid.

 Start edif prli timer & ring doorbell for app */

 target side must have changed it. */

 Set discovery state back to GNL to Relogin attempt */

 gpdb event */

 initiator mode */

 Target won't initiate port login if fabric is present */

 this adapter is bigger */

 recheck login state */

				/*

				 * On ipsec start by remote port, Target port

				 * may use RSCN to trigger initiator to

				 * relogin. If driver is already in the

				 * process of a relogin, then ignore the RSCN

				 * and allow the current relogin to continue.

				 * This reduces thrashing of the connection.

					/*

					 * If state = online, then set scan_needed=1 to do relogin.

					 * Otherwise we're already in the middle of a relogin

 check to see if App support Secure */

 for pure Target Mode, PRLI will not be initiated */

/*

 * RSCN(s) came in for this fcport, but the RSCN(s) was not able

 * to be consumed by the fcport

 Issue Marker IOCB */

 Command not found. */

 reson 5=busy expl:0x0 */

				/*

				 * PRLI failed. Reset link to kick start

				 * state machine

			/*

			 * switch connect. login failed. Take connection down

			 * and allow relogin to retrigger

 conflict Nport id */

 target side must have changed it. */

		/*

		 * Driver must validate login state - If PRLI not complete,

		 * force a relogin attempt via implicit LOGO, PLOGI, and PRLI

		 * requests.

 data[1] = IO PARAM 1 = nport ID  */

			/*

			 * Another fcport share the same loop_id/nport id.

			 * Conflict fcport needs to finish cleanup before this

			 * fcport can proceed to login.

***************************************************************************/

                QLogic ISP2x00 Hardware Support Functions.                */

***************************************************************************/

	/* SV: TODO: Assign initialization timeout from

	 * flash-info / other param

 Set our fcoe function presence */

 Decide the reset ownership */

	/*

	 * On first protocol driver load:

	 * Init-Owner: Set IDC-Major-Version and Clear IDC-Lock-Recovery

	 * register.

	 * Others: Check compatibility with current IDC Major version.

 Set IDC Major version */

 Clearing IDC-Lock-Recovery register */

		/*

		 * Clear further IDC participation if we are not compatible with

		 * the current IDC Major Version.

 Each function sets its supported Minor version. */

/*

* qla2x00_initialize_adapter

*      Initialize board.

*

* Input:

*      ha = adapter block pointer.

*

* Returns:

*      0 = success

 Clear adapter flags. */

 Check for secure flash support */

		/* NOTE: If ql2xdontresethba==1, set IDC_CTRL DONTRESET_BIT0.

		 * If DONRESET_BIT0 is set, drivers should not set dev_state

		 * to NEED_RESET. But if NEED_RESET is set, drivers should

 Let priority default to FCP, can be overridden by nvram_config */

 Mask HBA via NVRAM settings? */

 If smartsan enabled then require fdmi and rdp enabled */

 No point in continuing if firmware initialization failed. */

 Issue verify 84xx FW IOCB to complete 84xx initialization */

 Load the NIC Core f/w if we are the first protocol driver. */

/**

 * qla2100_pci_config() - Setup ISP21xx PCI configuration registers.

 * @vha: HA context

 *

 * Returns 0 on success.

 Get PCI bus information. */

/**

 * qla2300_pci_config() - Setup ISP23xx PCI configuration registers.

 * @vha: HA context

 *

 * Returns 0 on success.

	/*

	 * If this is a 2300 card and not 2312, reset the

	 * COMMAND_INVALIDATE due to a bug in the 2300. Unfortunately,

	 * the 2310 also reports itself as a 2300 so we need to get the

	 * fb revision level -- a 6 indicates it really is a 2300 and

	 * not a 2310.

 Pause RISC. */

 Select FPM registers. */

 Get the fb rev level */

 Deselect FPM registers. */

 Release RISC module. */

 Get PCI bus information. */

/**

 * qla24xx_pci_config() - Setup ISP24xx PCI configuration registers.

 * @vha: HA context

 *

 * Returns 0 on success.

 PCI-X -- adjust Maximum Memory Read Byte Count (2048). */

 PCIe -- adjust Maximum Read Request Size (2048). */

 Get PCI bus information. */

/**

 * qla25xx_pci_config() - Setup ISP25xx PCI configuration registers.

 * @vha: HA context

 *

 * Returns 0 on success.

 PCIe -- adjust Maximum Read Request Size (2048). */

/**

 * qla2x00_isp_firmware() - Choose firmware image.

 * @vha: HA context

 *

 * Returns 0 on success.

 Assume loading risc code */

 Verify checksum of loaded RISC code. */

 And, verify we are not in ROM code. */

/**

 * qla2x00_reset_chip() - Reset ISP chip.

 * @vha: HA context

 *

 * Returns 0 on success.

 Turn off master enable */

 Pause RISC. */

 PCI Posting. */

 Select FPM registers. */

 PCI Posting. */

 FPM Soft Reset. */

 PCI Posting. */

 Toggle Fpm Reset. */

 PCI Posting. */

 Select frame buffer registers. */

 PCI Posting. */

 Reset frame buffer FIFOs. */

 PCI Posting. */

 Read back fb_cmd until zero or 3 seconds max */

 Select RISC module registers. */

 PCI Posting. */

 Reset RISC processor. */

 PCI Posting. */

 Release RISC processor. */

 PCI Posting. */

 Reset ISP chip. */

 Wait for RISC to recover from reset. */

		/*

		 * It is necessary to for a delay here since the card doesn't

		 * respond to PCI reads during a reset. On some architectures

		 * this will result in an MCA.

 Reset RISC processor. */

 Release RISC processor. */

 PCI Posting. */

 Turn on master enable */

 Disable RISC pause on FPM parity error. */

 PCI Posting. */

/**

 * qla81xx_reset_mpi() - Reset's MPI FW via Write MPI Register MBC.

 * @vha: HA context

 *

 * Returns 0 on success.

 this check is only valid after RISC reset */

/**

 * qla24xx_reset_risc() - Perform full reset of ISP24xx RISC.

 * @vha: HA context

 *

 * Returns 0 on success.

 ISP abort retry counts */

 Reset RISC. */

 Wait for firmware to complete NVRAM accesses. */

 Wait for soft-reset to complete. */

 If required, do an MPI FW reset now */

				/*

				 * We exhausted the ISP abort retries. We have to

				 * set the board offline.

/**

 * qla24xx_reset_chip() - Reset ISP24xx chip.

 * @vha: HA context

 *

 * Returns 0 on success.

 Perform RISC reset. */

/**

 * qla2x00_chip_diag() - Test chip for proper operation.

 * @vha: HA context

 *

 * Returns 0 on success.

 Assume a failed state */

 Reset ISP chip. */

	/*

	 * We need to have a delay here since the card will not respond while

	 * in reset causing an MCA on some architectures.

 Reset RISC processor. */

 Workaround for QLA2312 PCI parity error */

 Check product ID of chip */

 Adjust fw RISC transfer size */

 Limit firmware transfer size with a 2200A */

 Wrap Incoming Mailboxes Test. */

 Flag a successful rval */

/**

 * qla24xx_chip_diag() - Test ISP24xx for proper operation.

 * @vha: HA context

 *

 * Returns 0 on success.

 Flag a successful rval */

 Allocate memory for Fibre Channel Event Buffer. */

 Allocate memory for Extended Trace Buffer. */

			/*

			 * Allocate maximum buffer size for all queues - Q0.

			 * Resizing must be done at end-of-dump processing.

 Add space for spare MPI fw dump. */

 Don't try to reallocate the array */

		/*

		 * Try to allocate a minimal size just so we can get through

		 * initialization.

 media */

 link length */

/**

 * qla24xx_detect_sfp()

 *

 * @vha: adapter state pointer.

 *

 * @return

 *	0 -- Configure firmware to use short-range settings -- normal

 *	     buffer-to-buffer credits.

 *

 *	1 -- Configure firmware to use long-range settings -- extra

 *	     buffer-to-buffer credits should be allocated with

 *	     ha->lr_distance containing distance settings from NVRAM or SFP

 *	     (if supported).

 Seed with NVRAM settings. */

 Determine SR/LR capabilities of SFP/Transceiver. */

 Long range, track length. */

/**

 * qla2x00_setup_chip() - Load and start RISC firmware.

 * @vha: HA context

 *

 * Returns 0 on success.

 Disable SRAM, Instruction RAM and GP RAM parity.  */

 Load firmware sequences */

 Start firmware execution. */

 Retrieve firmware information. */

 Enable BPM support? */

 Best-effort - re-init. */

				/*

				 * Allocate the array of outstanding commands

				 * now that we know the firmware resources.

 Enable PUREX PASSTHRU */

 Enable proper parity. */

 SRAM parity */

 SRAM, Instruction RAM and GP RAM parity */

/**

 * qla2x00_init_response_q_entries() - Initializes response queue entries.

 * @rsp: response queue

 *

 * Beginning of request ring has initialization control block already built

 * by nvram config routine.

 *

 * Returns 0 on success.

/**

 * qla2x00_update_fw_options() - Read and process firmware options.

 * @vha: HA context

 *

 * Returns 0 on success.

 Serial Link options. */

  1G settings */

  2G settings */

 FCP2 options. */

  Return command IOCBs without waiting for an ABTS to complete. */

 LED scheme. */

 Detect ISP6312. */

 Set Retry FLOGI in case of P2P connection */

 Update firmware options. */

  Hold status IOCBs until ABTS response received. */

 Set Retry FLOGI in case of P2P connection */

 Move PUREX, ABTS RX & RIDA to ATIOQ */

		/*

		 * Tell FW to track each exchange to prevent

		 * driver from using stale exchange.

 Reserve 1/2 of emergency exchanges for ELS.*/

		/*

		 * N2N: set Secure=1 for PLOGI ACC and

		 * fw shal not send PRLI after PLOGI Acc

 Enable Async 8130/8131 events -- transceiver insertion/removal */

 Update Serial Link options. */

 Setup ring parameters in initialization control block. */

 PCI Posting. */

 Setup ring parameters in initialization control block. */

 Setup ATIO queue dma pointers for target mode */

 Use alternate PCI bus number */

 Use alternate PCI devfn */

 Use Disable MSIX Handshake mode for capable adapters */

 If the user has configured the speed, set it here */

 PCI posting */

/**

 * qla2x00_init_rings() - Initializes firmware.

 * @vha: HA context

 *

 * Beginning of request ring has initialization control block already built

 * by nvram config routine.

 *

 * Returns 0 on success.

 Clear outstanding commands array. */

 Initialize firmware. */

 Initialize response queue entries */

 Initialize ATIO queue entries */

 Update any ISP specific firmware options before initialization. */

 FA-WWPN Status */

 ELS pass through payload is limit by frame size. */

/**

 * qla2x00_fw_ready() - Waits for firmware ready.

 * @vha: HA context

 *

 * Returns 0 on success.

 Minimum wait time if loop is down */

 Wait time if loop is coming ready */

 Time to wait for loop down */

	/*

	 * Firmware should take at most one RATOV to login, plus 5 seconds for

	 * our own processing.

 Min wait time if loop down */

 wait time before firmware ready */

 Wait for ISP to finish LIP */

 Add time taken to initialize. */

				/* Loop down. Timeout on min_wait for states

				 * other than Wait for Login.

 Mailbox cmd failed. Timeout on min_wait. */

 Delay for a while */

/*

*  qla2x00_configure_hba

*      Setup adapter context.

*

* Input:

*      ha = adapter state pointer.

*

* Returns:

*      0 = success

*

* Context:

*      Kernel context.

 Get host addresses. */

 initialize */

 Save Host port and loop ID. */

 byte order - Big Endian */

/* On sparc systems, obtain port and node WWN from firmware

 * properties.

/*

* NVRAM configuration for ISP 2xxx

*

* Input:

*      ha                = adapter block pointer.

*

* Output:

*      initialization control block in response_ring

*      host adapters parameters in host adapter block

*

* Returns:

*      0 = success.

 Determine NVRAM starting address. */

 Get NVRAM data and calculate checksum. */

 Bad NVRAM data, set defaults parameters. */

 Reset NVRAM data. */

		/*

		 * Set default initialization control block.

		/*

		 * Set default host adapter parameters

 Reset Initialization control block */

	/*

	 * Setup driver NVRAM options.

		/*

		 * 'Point-to-point preferred, else loop' is not a safe

		 * connection mode setting.

 Force 'loop preferred, else point-to-point'. */

if (IS_QLA2100(ha))*/ {

	/*

	 * Copy over NVRAM RISC parameter block to initialization control block.

 Copy 2nd half. */

 Use alternate WWN? */

 Prepare nodename */

		/*

		 * Firmware will apply the following mask if the nodename was

		 * not provided.

	/*

	 * Set host adapter parameters.

	/*

	 * BIT_7 in the host-parameters section allows for modification to

	 * internal driver logging.

 Always load RISC code on non ISP2[12]00 chips. */

 save HBA serial number */

 Set minimum login_timeout to 4 seconds. */

 Set minimum RATOV to 100 tenths of a second. */

	/* Link Down Timeout = 0:

	 *

	 * 	When Port Down timer expires we will start returning

	 *	I/O's to OS with "DID_NO_CONNECT".

	 *

	 * Link Down Timeout != 0:

	 *

	 *	 The driver waits for the link to come up after link down

	 *	 before returning I/Os to OS with "DID_NO_CONNECT".

	/*

	 * Need enough time to try and get the port back.

 Set login_retry_count */

 Enable RIO */

 Enable ZIO. */

 Don't print state transitions during initial allocation of fcport */

/**

 * qla2x00_alloc_fcport() - Allocate a generic fcport.

 * @vha: HA context

 * @flags: allocation flags

 *

 * Returns a pointer to the allocated fcport, or NULL, if none available.

 Setup fcport template structure. */

/*

 * qla2x00_configure_loop

 *      Updates Fibre Channel Device Database with what is actually on loop.

 *

 * Input:

 *      ha                = adapter block pointer.

 *

 * Returns:

 *      0 = success.

 *      1 = error.

 *      2 = database was full and device was not configured.

 Get Initiator ID */

	/*

	 * If we have both an RSCN and PORT UPDATE pending then handle them

	 * both at the same time.

 Determine what we need to do */

			/*

			 * use link up to wake up app to get ready for

			 * authentication.

			/*

			 * Process any ATIO queue entries that came in

			 * while we weren't online.

 Restore state if a resync event occurred during processing */

/*

 * qla2x00_configure_local_loop

 *	Updates Fibre Channel Device Database with local loop devices.

 *

 * Input:

 *	ha = adapter block pointer.

 *

 * Returns:

 *	0 = success.

 Inititae N2N login. */

 Get list of logged in devices. */

 Allocate temporary fcport for any new fcports discovered. */

 Add devices to port list. */

 Bypass reserved domain fields. */

 Bypass if not same domain and area of adapter. */

 Bypass invalid local loop ID. */

 Fill in member data. */

 Skip retry if N2N */

 Check for matching device in port list. */

 New device, add to fcports list. */

 Allocate a new replacement fcport. */

 Base iIDMA settings on HBA port speed. */

 qla2x00_reg_remote_port is reserved for Initiator Mode only.*/

/*

 * qla2x00_update_fcport

 *	Updates device on list.

 *

 * Input:

 *	ha = adapter block pointer.

 *	fcport = port structure pointer.

 *

 * Return:

 *	0  - Success

 *  BIT_0 - error

 *

 * Context:

 *	Kernel context.

 RSCN(s) came in while registration */

/*

 * qla2x00_configure_fabric

 *      Setup SNS devices with loop ID's.

 *

 * Input:

 *      ha = adapter block pointer.

 *

 * Returns:

 *      0 = success.

 *      BIT_0 = error

 If FL port exists, then SNS is present */

 Ensure we are logged into the SNS. */

 FDMI support. */

 EMPTY */

 EMPTY */

 EMPTY */

 EMPTY */

		/* Mark the time right before querying FW for connected ports.

		 * This process is long, asynchronous and by the time it's done,

		 * collected information might not be accurate anymore. E.g.

		 * disconnected port might have re-connected and a brand new

		 * session has been created. In this case session's generation

/*

 * qla2x00_find_all_fabric_devs

 *

 * Input:

 *	ha = adapter block pointer.

 *	dev = database device entry pointer.

 *

 * Returns:

 *	0 = success.

 *

 * Context:

 *	Kernel context.

 Try GID_PT to get device list, else GAN. */

EMPTY*/

 If other queries succeeded probe for FC-4 type */

 Allocate temporary fcport for any new fcports discovered. */

 Set start port ID scan at adapter ID. */

 Starting free loop ID. */

 Send GA_NXT to the switch */

 If wrap on switch device list, exit. */

 Bypass if same physical adapter. */

 Bypass virtual ports of the same host. */

 Bypass if same domain and area of adapter. */

 Bypass reserved domain fields. */

 Bypass ports whose FCP-4 type is not FCP_SCSI */

 Locate matching device in database. */

 Update port state. */

			/*

			 * If address the same and state FCS_ONLINE

			 * (or in target mode), nothing changed.

			/*

			 * If device was not a fabric device before.

			/*

			 * Port ID changed or device was marked to be updated;

			 * Log it out if still logged in and mark it for

			 * relogin later.

 If device was not in our fcports list, then add it. */

 Allocate a new replacement fcport. */

	/*

	 * Logout all previous fabric dev marked lost, except FCP2 devices.

 FW does not set aside Loop id for MGMT Server/FFFFFAh */

 pick id from high and work down to low */

/*

 * qla2x00_fabric_login

 *	Issue fabric login command.

 *

 * Input:

 *	ha = adapter block pointer.

 *	device = pointer to FC device type structure.

 *

 * Returns:

 *      0 - Login successfully

 *      1 - Login failed

 *      2 - Initiator device

 *      3 - Fatal error

 Login fcport on switch. */

			/*

			 * Device has another loop ID.  The firmware team

			 * recommends the driver perform an implicit login with

			 * the specified ID again. The ID we just used is save

			 * here so we return with an ID that can be tried by

			 * the next login.

			/*

			 * Login succeeded.

 A retry occurred before. */

				/*

				 * No retry occurred before. Just increment the

				 * ID value for next login.

			/*

			 * Loop ID already used, try next loop ID.

 Ran out of loop IDs to use */

			/*

			 * Firmware possibly timed out during login. If NO

			 * retries are left to do then the device is declared

			 * dead.

			/*

			 * unrecoverable / not handled error

/*

 * qla2x00_local_device_login

 *	Issue local device login command.

 *

 * Input:

 *	ha = adapter block pointer.

 *	loop_id = loop id of device to login to.

 *

 * Returns (Where's the #define!!!!):

 *      0 - Login successfully

 *      1 - Login failed

 *      3 - Fatal error

 Interrogate mailbox registers for any errors */

 device not in PCB table */

/*

 *  qla2x00_loop_resync

 *      Resync with fibre channel devices.

 *

 * Input:

 *      ha = adapter block pointer.

 *

 * Returns:

 *      0 = success

 Wait at most MAX_TARGET RSCNs for a stable link. */

					/*

					 * Issue a marker after FW becomes

					 * ready.

 Remap devices on Loop. */

/*

* qla2x00_perform_loop_resync

* Description: This function will set the appropriate flags and call

*              qla2x00_loop_resync. If successful loop will be resynced

* Arguments : scsi_qla_host_t pointer

* returm    : Success or Failure

Configure the flags so that resync happens properly*/

 Go with deferred removal of rport references. */

 Assumes idc_lock always held on entry */

	/*

	 * Prepare drv-presence mask based on fcoe functions present.

	 * However consider only valid physical fcoe function numbers (0-15).

	/* We are the reset owner iff:

	 *    - No other protocol drivers present.

 Assumes idc-lock always held on entry */

 Assumes idc_lock always held on entry */

 Set NEED-RESET iff in READY state and we are the reset-owner */

 SV: XXX: Is timeout required here? */

 Wait for IDC state change READY -> NEED_RESET */

 Send IDC ack by writing to drv-ack register */

	/*

	 * Perform reset if we are the reset-owner,

	 * else wait till IDC state changes to READY/FAILED.

 This message can be removed from the final version */

 NIC Core reset failed. */

/*

* qla2x00_quiesce_io

* Description: This function will block the new I/Os

*              Its not aborting any I/Os as context

*              is not destroyed during quiescence

* Arguments: scsi_qla_host_t

* return   : void

 Wait for pending cmds to complete */

	/* For ISP82XX, driver waits for completion of the commands.

	 * online flag should be set.

	/* For ISP82XX, reset_chip is just disabling interrupts.

	 * Driver waits for the completion of the commands.

	 * the interrupts need to be enabled.

 purge MBox commands */

 Clear all async request states across all VPs. */

 Make sure for ISP 82XX IO DMA is complete */

 Done waiting for pending commands. Reset online flag */

 Requeue all commands in outstanding command list. */

 memory barrier */

/*

*  qla2x00_abort_isp

*      Resets ISP and aborts all outstanding commands.

*

* Input:

*      ha           = adapter block pointer.

*

* Returns:

*      0 = success

				/*

				 * Issue marker command only when we are going

				 * to start the I/O .

 failed the ISP abort */

					/*

					 * The next call disables the board

					 * completely.

 schedule another ISP abort */

/*

*  qla2x00_restart_isp

*      restarts the ISP after a reset

*

* Input:

*      ha = adapter block pointer.

*

* Returns:

*      0 = success

 If firmware needs to be loaded */

 Initialize the queues in use */

 if no cable then assume it's good */

 Issue a marker after FW becomes ready. */

 Clear outstanding commands array. */

/*

* qla2x00_reset_adapter

*      Reset adapter.

*

* Input:

*      ha = adapter block pointer.

 PCI Posting. */

 PCI Posting. */

/* On sparc systems, obtain port and node WWN from firmware

 * properties.

 Determine NVRAM starting address. */

 Get VPD data into cache */

 Get NVRAM data into cache and calculate checksum. */

 Bad NVRAM data, set defaults parameters. */

 Reset NVRAM data. */

		/*

		 * Set default initialization control block.

 Don't enable full login after initial LIP */

 Don't enable LIP full login for initiator */

 Reset Initialization control block */

 Copy 1st segment. */

 Copy 2nd segment. */

	/*

	 * Setup driver NVRAM options.

 Use alternate WWN? */

 Prepare nodename */

		/*

		 * Firmware will apply the following mask if the nodename was

		 * not provided.

 Set host adapter parameters. */

 save HBA serial number */

 Set minimum login_timeout to 4 seconds. */

 Set minimum RATOV to 100 tenths of a second. */

	/* Link Down Timeout = 0:

	 *

	 * 	When Port Down timer expires we will start returning

	 *	I/O's to OS with "DID_NO_CONNECT".

	 *

	 * Link Down Timeout != 0:

	 *

	 *	 The driver waits for the link to come up after link down

	 *	 before returning I/Os to OS with "DID_NO_CONNECT".

 Need enough time to try and get the port back. */

 Set login_retry_count */

 N2N: driver will initiate Login instead of FW */

 Enable ZIO. */

 calculate generation delta as uint16 (this accounts for wrap) */

 skip header and ignore checksum */

ldriver.qlogic.com/firmware/"

 Load firmware blob. */

 Validate firmware image by checking version. */

 Validate firmware image size. */

 Next segment. */

 skip header and ignore checksum */

	/*

	 * FW Load priority:

	 * 1) Firmware via request-firmware interface (.bin file).

	 * 2) Firmware residing in flash.

	/* FW Load priority:

	 * 1) Firmware residing in flash.

	 * 2) Firmware via request-firmware interface (.bin file).

	 * 3) Golden-Firmware residing in flash -- (limited operation).

 Login to SNS first */

 84XX Support **************************************************************/

 Find any shared 84xx chip. */

 81XX Support **************************************************************/

 Determine NVRAM starting address. */

 Get VPD data into cache */

 Get NVRAM data into cache and calculate checksum. */

 Bad NVRAM data, set defaults parameters. */

 Reset NVRAM data. */

		/*

		 * Set default initialization control block.

 Reset Initialization control block */

 Copy 1st segment. */

 Copy 2nd segment. */

 Some boards (with valid NVRAMs) still have NULL enode_mac!! */

 Use extended-initialization control block. */

	/*

	 * Setup driver NVRAM options.

 Use alternate WWN? */

 Prepare nodename */

		/*

		 * Firmware will apply the following mask if the nodename was

		 * not provided.

 Set host adapter parameters. */

 save HBA serial number */

 Set minimum login_timeout to 4 seconds. */

 Set minimum RATOV to 100 tenths of a second. */

	/* Link Down Timeout = 0:

	 *

	 *	When Port Down timer expires we will start returning

	 *	I/O's to OS with "DID_NO_CONNECT".

	 *

	 * Link Down Timeout != 0:

	 *

	 *	 The driver waits for the link to come up after link down

	 *	 before returning I/Os to OS with "DID_NO_CONNECT".

 Need enough time to try and get the port back. */

 Set login_retry_count */

 if not running MSI-X we need handshaking on interrupts */

 Enable ZIO. */

 enable RIDA Format2 */

 N2N: driver will initiate Login instead of FW */

 Determine NVMe/FCP priority for target ports */

 Issue a marker after FW becomes ready. */

 if no cable then assume it's good */

			/*

			 * Issue marker command only when we are going

			 * to start the I/O .

 Update the firmware version */

/*

 * qla24xx_get_fcp_prio

 *	Gets the fcp cmd priority value for the logged in port.

 *	Looks for a match of the port descriptors within

 *	each of the fcp prio config entries. If a match is found,

 *	the tag (priority) value is returned.

 *

 * Input:

 *	vha = scsi host structure pointer.

 *	fcport = port structure pointer.

 *

 * Return:

 *	non-zero (if found)

 *	-1 (if not found)

 *

 * Context:

 * 	Kernel context

 check source pid for a match */

 check destination pid for a match */

 check source WWN for a match */

 check destination WWN for a match */

 Found a matching entry */

/*

 * qla24xx_update_fcport_fcp_prio

 *	Activates fcp priority for the logged in fc port

 *

 * Input:

 *	vha = scsi host structure pointer.

 *	fcp = port structure pointer.

 *

 * Return:

 *	QLA_SUCCESS or QLA_FUNCTION_FAILED

 *

 * Context:

 *	Kernel context.

/*

 * qla24xx_update_all_fcp_prio

 *	Activates fcp priority for all the logged in ports

 *

 * Input:

 *	ha = adapter block pointer.

 *

 * Return:

 *	QLA_SUCCESS or QLA_FUNCTION_FAILED

 *

 * Context:

 *	Kernel context.

 We need to set priority for all logged in ports */

 Assign available que pair id */

 Create response queue first */

 Create request queue */

 init qpair to this cpu. Will adjust at run time. */

 Mark as online */

 Brian Kernighan's Algorithm */

 Copy stat type to work on it */

 unset BIT_17 */

	/* i will continue from previous loop, as target

	 * entries are after initiator

 Set the flag to 1, so that isp_abort can proceed */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * QLogic Fibre Channel HBA Driver

 * Copyright (c)  2003-2014 QLogic Corporation

/*

 * NVRAM support routines

/**

 * qla2x00_lock_nvram_access() -

 * @ha: HA context

 Lock resource */

 Lock failed */

/**

 * qla2x00_unlock_nvram_access() -

 * @ha: HA context

/**

 * qla2x00_nv_write() - Prepare for NVRAM read/write operation.

 * @ha: HA context

 * @data: Serial interface selector

 PCI Posting. */

 PCI Posting. */

 PCI Posting. */

/**

 * qla2x00_nvram_request() - Sends read command to NVRAM and gets data from

 *	NVRAM.

 * @ha: HA context

 * @nv_cmd: NVRAM command

 *

 * Bit definitions for NVRAM command:

 *

 *	Bit 26     = start bit

 *	Bit 25, 24 = opcode

 *	Bit 23-16  = address

 *	Bit 15-0   = write data

 *

 * Returns the word read from nvram @addr.

 Send command to NVRAM. */

 Read data from NVRAM. */

 PCI Posting. */

 PCI Posting. */

 Deselect chip. */

 PCI Posting. */

/**

 * qla2x00_get_nvram_word() - Calculates word position in NVRAM and calls the

 *	request routine to get the word from NVRAM.

 * @ha: HA context

 * @addr: Address in NVRAM to read

 *

 * Returns the word read from nvram @addr.

/**

 * qla2x00_nv_deselect() - Deselect NVRAM operations.

 * @ha: HA context

 PCI Posting. */

/**

 * qla2x00_write_nvram_word() - Write NVRAM data.

 * @ha: HA context

 * @addr: Address in NVRAM to write

 * @data: word to program

 Write data */

 Wait for NVRAM to become ready */

 PCI Posting. */

 Disable writes */

 Write data */

 Wait for NVRAM to become ready */

 PCI Posting. */

 Disable writes */

/**

 * qla2x00_clear_nvram_protection() -

 * @ha: HA context

 Clear NVRAM write protection. */

 Write enable. */

 Enable protection register. */

 Clear protection register (ffff is cleared). */

 Wait for NVRAM to become ready. */

 PCI Posting. */

 Set NVRAM write protection. */

 Write enable. */

 Enable protection register. */

 Enable protection register. */

 Wait for NVRAM to become ready. */

 PCI Posting. */

****************************************************************************/

 Flash Manipulation Routines                                               */

****************************************************************************/

 Dword reads to flash. */

 Check if man_id and flash_id are valid. */

		/* Read information using 0x9f opcode

		 * Device ID, Mfg ID would be read in the format:

		 *   <Ext Dev Info><Device ID Part2><Device ID Part 1><Mfg ID>

		 * Example: ATMEL 0x00 01 45 1F

		 * Extract MFG and Dev ID from last two bytes.

	/*

	 * FLT-location structure resides after the last PCI region.

 Begin with sane defaults. */

 Begin with first PCI expansion ROM header. */

 Verify PCI expansion ROM header. */

 Locate PCI data structure. */

 Validate signature of PCI data structure. */

 Locate next PCI expansion ROM. */

 Now verify FLT-location structure. */

 Good data.  Use specified location. */

	/* Assign FCP prio region since older adapters may not have FLT, or

	   FCP prio region in it's FLT.

 Store addresses as DWORD offsets. */

 Use hardcoded defaults. */

 STT flash. */

 ST M25P80. */

 Atmel 26DF081A. */

 Default to 64 kb sector size. */

 Enable flash write. */

 PCI Posting. */

 Disable flash write-protection, first clear SR protection bit */

 Then write zero again to clear remaining SR bits.*/

 Enable flash write-protection and wait for completion. */

 Disable flash write. */

 burst size in dwords */

 Allocate dma buffer for burst write */

 Are we at the beginning of a sector? */

 If smaller than a burst remaining */

 Copy to dma buffer */

 Burst write */

 Slow write */

 Word reads to NVRAM via registers. */

 Dword reads to flash. */

 Disable NVRAM write-protection. */

 Enable NVRAM write-protection. */

 Enable flash write. */

 PCI Posting. */

 Disable NVRAM write-protection. */

 Dword writes to flash. */

 Enable NVRAM write-protection. */

 Disable flash write. */

 PCI Posting. */

 Dword reads to flash. */

 Flip all colors. */

 Turn off. */

 Turn on. */

 Flip green led only. */

 Turn off. */

 Turn on. */

 Save the Original GPIOE. */

 Set the modified gpio_enable values */

 Clear out any previously set LED color. */

 Set the new input LED color to GPIOD. */

 Set the modified gpio_data values */

 Turn off LEDs. */

 Set the modified gpio_enable values. */

 Clear out previously set LED colour. */

	/*

	 * Let the per HBA timer kick off the blinking process based on

	 * the following flags. No need to do anything else now.

 Set the on flag so when it gets flipped it will be off. */

 This turns green LED off */

 Flip all colors. */

 Turn off. */

 Turn on. */

 Save the Original GPIOD. */

 Enable the gpio_data reg for update. */

 Set the color bits. */

 Clear out any previously set LED color. */

 Set the new input LED color to GPIOD. */

 Set the modified gpio_data values. */

 Save Current */

 Do the blink */

 On exit, restore original (presumes no status change) */

 let blink handle it */

 Enable firmware for update */

 Enable the gpio_data reg for update. */

 So all colors blink together. */

 Let the per HBA timer kick off the blinking process. */

 Will flip to all off. */

 Give control back to firmware. */

 Disable the gpio_data reg for update. */

/*

 * Flash support routines

/**

 * qla2x00_flash_enable() - Setup flash for reading and writing.

 * @ha: HA context

 PCI Posting. */

/**

 * qla2x00_flash_disable() - Disable flash and allow RISC to run.

 * @ha: HA context

 PCI Posting. */

/**

 * qla2x00_read_flash_byte() - Reads a byte from flash

 * @ha: HA context

 * @addr: Address in flash to read

 *

 * A word is read from the chip, but, only the lower byte is valid.

 *

 * Returns the byte read from flash @addr.

 Specify 64K address range: */

  clear out Module Select and Flash Address bits [19:16]. */

 PCI Posting. */

 Setup bit 16 of flash address. */

 PCI Posting. */

 PCI Posting. */

 Always perform IO mapped accesses to the FLASH registers. */

/**

 * qla2x00_write_flash_byte() - Write a byte to flash

 * @ha: HA context

 * @addr: Address in flash to write

 * @data: Data to write

 Specify 64K address range: */

  clear out Module Select and Flash Address bits [19:16]. */

 PCI Posting. */

 PCI Posting. */

 PCI Posting. */

 Setup bit 16 of flash address. */

 PCI Posting. */

 PCI Posting. */

 Always perform IO mapped accesses to the FLASH registers. */

 PCI Posting. */

 PCI Posting. */

/**

 * qla2x00_poll_flash() - Polls flash for completion.

 * @ha: HA context

 * @addr: Address in flash to poll

 * @poll_data: Data to be polled

 * @man_id: Flash manufacturer ID

 * @flash_id: Flash ID

 *

 * This function polls the device until bit 7 of what is read matches data

 * bit 7 or until data bit 5 becomes a 1.  If that hapens, the flash ROM timed

 * out (a fatal error).  The flash book recommeds reading bit 7 again after

 * reading bit 5 as a 1.

 *

 * Returns 0 on success, else non-zero.

 Wait for 30 seconds for command to finish. */

/**

 * qla2x00_program_flash_address() - Programs a flash address

 * @ha: HA context

 * @addr: Address in flash to program

 * @data: Data to be written in flash

 * @man_id: Flash manufacturer ID

 * @flash_id: Flash ID

 *

 * Returns 0 on success, else non-zero.

 Write Program Command Sequence. */

 Wait for write to complete. */

/**

 * qla2x00_erase_flash() - Erase the flash.

 * @ha: HA context

 * @man_id: Flash manufacturer ID

 * @flash_id: Flash ID

 *

 * Returns 0 on success, else non-zero.

 Individual Sector Erase Command Sequence */

 Wait for erase to complete. */

/**

 * qla2x00_erase_flash_sector() - Erase a flash sector.

 * @ha: HA context

 * @addr: Flash sector to erase

 * @sec_mask: Sector address mask

 * @man_id: Flash manufacturer ID

 * @flash_id: Flash ID

 *

 * Returns 0 on success, else non-zero.

 Individual Sector Erase Command Sequence */

 Wait for erase to complete. */

/**

 * qla2x00_get_flash_manufacturer() - Read manufacturer ID from flash chip.

 * @ha: host adapter

 * @man_id: Flash manufacturer ID

 * @flash_id: Flash ID

 Suspend HBA. */

 Pause RISC. */

 Resume HBA. */

 Suspend HBA. */

 Go with read. */

 PCI Posting. */

 PCI Posting. */

 Resume HBA. */

 Suspend HBA. */

 Reset ISP chip. */

 Go with write. */

 Loop once to provide quick error exit */

 Structure of flash memory based on manufacturer */

 OEM variant with special flash part. */

 ST flash. */

				/*

				 * ST m29w008at part - 64kb sector size with

				 * 32kb,8kb,8kb,16kb sectors at memory address

				 * 0xf0000.

			/*

			 * ST m29w010b part - 16kb sector size

			 * Default to 16kb sectors

 Mostel flash. */

 Mostel v29c51001 part - 512 byte sector size. */

 SST flash. */

 SST39sf10 part - 4kb sector size. */

 Winbond flash. */

 Winbond W29EE011 part - 256 byte sector size. */

 Macronix flash. */

 64k sector size. */

 Atmel flash. */

 512k sector size. */

 AMD flash. */

 Am29LV081 part - 64kb sector size. */

 Am29LV002BT part - 64kb sector size. */

				/*

				 * Am29LV008b part - 64kb sector size with

				 * 32kb,8kb,8kb,16kb sector at memory address

				 * h0xf0000.

				/*

				 * Am29LV010 part or AM29f010 - 16kb sector

				 * size.

 Am29LV001 part - 8kb sector size. */

 Default to 16 kb sector size. */

 Are we at the beginning of a sector? */

 Then erase it */

 Resume HBA. */

 Suspend HBA. */

 Go with read. */

 Resume HBA. */

 Extract SFUB from end of file */

 burst size in dwords */

 Retrieve region info - must be a start address passed in */

 Allocate dma buffer for burst write */

	/*

	 * If adapter supports secure flash and region is secure

	 * extract secure flash update block (SFUB) and verify

 1st fw array */

 2nd fw array */

 1st dump template */

 skip header and ignore checksum */

 2nd dump template */

 skip header and ignore checksum */

 1st fw array */

 Lock semaphore */

 If start of sector */

		/*

		 * If adapter supports secure flash but FW doesn't,

		 * disable write protect, release semaphore and reset

		 * chip to execute ROM code in order to update region securely

 Unprotect flash */

 If region is secure, send Secure Flash MB Cmd */

 re-init flash offset */

 If smaller than a burst remaining */

 Copy to dma buffer */

 Burst write */

 Schedule DPC to restart the RISC */

 Suspend HBA. */

 Go with write. */

/**

 * qla2x00_get_fcode_version() - Determine an FCODE image's version.

 * @ha: HA context

 * @pcids: Pointer to the FCODE PCI data structure

 *

 * The process of retrieving the FCODE version information is at best

 * described as interesting.

 *

 * Within the first 100h bytes of the image an ASCII string is present

 * which contains several pieces of information including the FCODE

 * version.  Unfortunately it seems the only reliable way to retrieve

 * the version is by scanning for another sentinel within the string,

 * the FCODE build date:

 *

 *	... 2.00.02 10/17/02 ...

 *

 * Returns QLA_SUCCESS on successful retrieval of version.

 Skip the PCI data structure. */

 Scan for the sentinel date string...eeewww. */

 Backtrack to previous ' ' (space). */

		/*

		 * Mark end of version tag, and find previous ' ' (space) or

		 * string length (recent FCODE images -- major hack ahead!!!).

 Mark beginning of version tag, and copy data. */

 Begin with first PCI expansion ROM header. */

 Verify PCI expansion ROM header. */

 No signature */

 Locate PCI data structure. */

 Validate signature of PCI data structure. */

 Incorrect header. */

 Read version */

 Intel x86, PC-AT compatible. */

 Open Firmware standard for PCI (FCode). */

 Eeeewww... */

 Extensible Firmware Interface (EFI). */

 Locate next PCI expansion ROM. */

 Read firmware image information. */

 values are in big endian */

 Begin with first PCI expansion ROM header. */

 Verify PCI expansion ROM header. */

 No signature */

 Locate PCI data structure. */

 Validate signature of PCI data structure. */

 Incorrect header. */

 Read version */

 Intel x86, PC-AT compatible. */

 Open Firmware standard for PCI (FCode). */

 Extensible Firmware Interface (EFI). */

 Locate next PCI expansion ROM. */

 Read firmware image information. */

 Validate signature of PCI data structure. */

 Verify PCI expansion ROM header. */

 No signature */

 Locate PCI data structure. */

 Validate signature of PCI data structure. */

 Incorrect header. */

 Read version */

 Intel x86, PC-AT compatible. */

 Open Firmware standard for PCI (FCode). */

 Extensible Firmware Interface (EFI). */

 Locate next PCI expansion ROM. */

 Read firmware image information. */

 Check for golden firmware and get version if available */

 Golden firmware is not present in non 81XX adapters */

 first read the fcp priority data header from flash */

 read remaining FCP CMD config data from flash */

 revalidate the entire FCP priority config data, including entries */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  qla_target.c SCSI LLD infrastructure for QLogic 22xx/23xx/24xx/25xx

 *

 *  based on qla2x00t.c code:

 *

 *  Copyright (C) 2004 - 2010 Vladislav Bolkhovitin <vst@vlnb.net>

 *  Copyright (C) 2004 - 2005 Leonid Stoljar

 *  Copyright (C) 2006 Nathaniel Clark <nate@misrule.us>

 *  Copyright (C) 2006 - 2010 ID7 Ltd.

 *

 *  Forward port and refactoring to modern qla2xxx and target/configfs

 *

 *  Copyright (C) 2010-2013 Nicholas A. Bellinger <nab@kernel.org>

 target core */

/*

 * From scsi/fc/fc_fcp.h

/*

 * fc_pri_ta from scsi/fc/fc_fcp.h

 simple task attribute */

 head of queue task attribute */

 ordered task attribute */

 auto. contingent allegiance */

 mask for task attribute field */

 priority field starts in bit 3 */

 reserved bits in priority field */

/*

 * This driver calls qla2x00_alloc_iocbs() and qla2x00_issue_marker(), which

 * must be called under HW lock and could unlock/lock it inside.

 * It isn't an issue, since in the current implementation on the time when

 * those functions are called:

 *

 *   - Either context is IRQ and only IRQ handler can modify HW data,

 *     including rings related fields,

 *

 *   - Or access to target mode variables from struct qla_tgt doesn't

 *     cross those functions boundaries, except tgt_stop, which

 *     additionally protected by irq_cmd_count.

 Predefs for callbacks handed to qla2xxx LLD */

/*

 * Global Variables

/* This API intentionally takes dest as a parameter, rather than returning

 memory barrier */

 Might release hw lock, then reaquire!! */

 Send marker if required */

 case PUREX_IOCB_TYPE: ql2xmvasynctoatio */

/*

 * All qlt_plogi_ack_t operations are protected by hardware_lock

 create sess has an extra kref */

/*

 * Called from qla2x00_reg_remote_port()

/*

 * This is a zero-base ref-counting solution, since hardware_lock

 * guarantees that ref_count is not modified concurrently.

 * Upon successful return content of iocb is undefined

 Inc ref_count first because link might already be pointing at pla */

 These fields must be initialized by the caller */

	/*

	 * number of cmds dropped while we were waiting for

	 * initiator to ack LOGO initialize to 1 if LOGO is

	 * triggered by a command, otherwise, to 0

 These fields are used by callee */

 if sess->logout_on_delete */

	/*

	 * Release the target session for FC Nexus from fabric module code.

			/*

			 * Driver timeout is set to 22 Sec, update count value to loop

			 * long enough for log-out to complete before advancing. Otherwise,

			 * straddling logout can interfere with re-login attempt.

 no-op */

 ha->tgt.sess_lock supposed to be held on entry */

	/*

	 * Use FCF_ASYNC_SENT flag to block other cmds used in sess

	 * management from being sent.

 Global event */

		/*

		 * This port is not done reporting to upper layer.

		 * let it finish

 At this point tgt could be already dead */

 Get list of logged in devices */

/*

 * Adds an extra ref to allow to drop hw lock after adding sess to the list.

 * Caller must put it.

	/*

	 * Under normal circumstances we want to logout from firmware when

	 * session eventually ends and release corresponding nport handle.

	 * In the exception cases (e.g. when new PLOGI is waiting) corresponding

	 * code will adjust these flags as necessary.

		/*

		 * Take an extra reference to ->sess_kref here to handle

		 * fc_port access across ->tgt.sess_lock reaquire.

/*

 * max_gen - specifies maximum session generation

 * at which this deletion requestion is still valid

	/*

	 * We need to protect against race, when tgt is freed before or

	 * inside wake_up()

 Called by tcm_qla2xxx configfs code */

	/*

	 * Mutex needed to sync with qla_tgt_fc_port_[added,deleted].

	 * Lock is needed, because we still can get an incoming packet.

 Big hammer */

 Wait for sessions to clear out (just in case) */

 Called by tcm_qla2xxx configfs code */

 Called from qlt_remove_target() -> qla2x00_remove_one() */

 ha->hardware_lock supposed to be held on entry */

/*

 * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire

 TODO qualify this with EDIF enable */

 Memory Barrier */

		/*

		 * CTIO type 7 from the firmware doesn't provide a way to

		 * know the initiator's LOOP ID, hence we can't find

		 * the session and, so, the command.

 Other bytes are zero */

 Memory Barrier */

/*

 * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire

 Other bytes are zero */

 Memory Barrier */

/*

 * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire

 abts from remote port */

 abts from this driver.  */

	/*

	 * We've got on entrance firmware's response on by us generated

	 * ABTS response. So, in it ID fields are reversed.

 Memory Barrier */

/* drop cmds for the given lun

 * XXX only looks for cmds on the port through which lun reset was recieved

 * XXX does not go through the list of other port (which may have cmds

 *     for the same lun)

 ha->hardware_lock supposed to be held on entry */

	/*

	 * LUN is looked up by target-core internally based on the passed

	 * abts->exchange_addr_to_abort tag.

/*

 * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire

/*

 * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire

 Memory Barrier */

/*

 * ha->hardware_lock supposed to be held on entry. Might drop it, then

 * reacquire

 Fixed format sense data. */

 Additional sense length */

 ASC and ASCQ */

 Memory Barrier */

 callback from target fabric module code */

		/*

		 * Either the port is not online or this request was from

		 * previous life, just abort the processing.

	/*

	 * Make the callback for ->free_mcmd() to queue_work() and invoke

	 * target_put_sess_cmd() to drop cmd_kref to 1.  The final

	 * target_put_sess_cmd() call will be made from TFO->check_stop_free()

	 * -> tcm_qla2xxx_check_stop_free() to release the TMR associated se_cmd

	 * descriptor after TFO->queue_tm_rsp() -> tcm_qla2xxx_queue_tm_rsp() ->

	 * qlt_xmit_tm_rsp() returns here..

 No locks */

		/*

		 * If greater than four sg entries then we need to allocate

		 * the continuation entries

 DIF */

 Dif Bundling not support here */

/*

 * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire

 Adjust ring index. */

 ha->hardware_lock supposed to be held on entry */

 ha->hardware_lock supposed to be held on entry */

		/*

		 * CTIO type 7 from the firmware doesn't provide a way to

		 * know the initiator's LOOP ID, hence we can't find

		 * the session and, so, the command.

/*

 * ha->hardware_lock supposed to be held on entry. We have already made sure

 * that there is sufficient amount of request entries to not drop it.

 Build continuation packets */

		/*

		 * Make sure that from cont_pkt64 none of

		 * 64-bit specific fields used for 32-bit

		 * addressing. Cast to (cont_entry_t *) for

		 * that.

 Load continuation entry data segments */

/*

 * ha->hardware_lock supposed to be held on entry. We have already made sure

 * that there is sufficient amount of request entries to not drop it.

 Setup packet address segment pointer */

 Set total data segment count */

 No data transfer */

 If scatter gather */

 Load command entry data segments */

 asc 0x10=dif error */

 ASCQ */

/*

 * Called without ha->hardware_lock held

		/*

		 * If QLA_TGT_XMIT_DATA is not set, add_status_pkt will be

		 * ignored in *xmit_response() below

 Sense with len > 24, is it possible ??? */

/*

 * qla_tgt_set_dif_tags - Extract Ref and App tags from SCSI command

	/*

	 * wait till Mode Sense/Select cmd, modepage Ah, subpage 2

	 * have been immplemented by TCM, before AppTag is avail.

	 * Look for modesense_handlers[]

		/*

		 * No check for ql2xenablehba_err_chk, as it

		 * would be an I/O error if hba tag generation

		 * is not done.

 enable ALL bytes of the ref tag */

	    /*

	     * For TYPE 1 protection: 16 bit GUARD tag, 32 bit

	     * REF tag, and 16 bit app tag.

 enable ALL bytes of the ref tag */

	    /*

	     * For TYPE 2 protection: 16 bit GUARD + 32 bit REF

	     * tag has to match LBA in CDB + N

 enable ALL bytes of the ref tag */

 For TYPE 3 protection: 16 bit GUARD only */

 Compute dif len and adjust data len to incude protection */

 Disable Guard tag checking */

 HBA error checking enabled */

 FUTURE: does tcm require T10CRC<->IPCKSUM conversion? */

 Normal Request */

 ---- PKT ---- */

 Update entry type to indicate Command Type CRC_2 IOCB */

		/*

		 * CTIO type 7 from the firmware doesn't provide a way to

		 * know the initiator's LOOP ID, hence we can't find

		 * the session and, so, the command.

 silence compile warning */

 Set transfer direction */

 Fibre channel byte count */

 ----- CRC context -------- */

 Allocate CRC context from global pool */

 Set handle */

		/*

		 * Configure Bundling if we need to fetch interlaving

		 * protection PCI accesses

 Finish the common fields of CRC pkt */

 Walks data segments */

 Walks dif segments */

 Cleanup will be performed by the caller */

/*

 * Callback to setup response of xmit_type of QLA_TGT_XMIT_DATA and *

 * QLA_TGT_XMIT_STATUS for >= 24xx silicon

		/*

		 * Either the port is not online or this request was from

		 * previous life, just abort the processing.

 Does F/W have an IOCBs for this request */

			/*

			 * We have already made sure that there is sufficient

			 * amount of request entries to not drop HW lock in

			 * req_pkt().

			/*

			 * T10Dif: ctio_crc2_to_fw overlay ontop of

			 * ctio7_to_24xx

 reset back to CTIO7 */

 Real finish is ctio_m1's finish */

			/* qlt_24xx_init_ctio_to_isp will correct

			 * all neccessary fields that's part of CTIO7.

			 * There should be no residual of CTIO-CRC2 data.

 Mid-level is done processing */

 Memory Barrier */

		/*

		 * Either the port is not online or this request was from

		 * previous life, just abort the processing.

 Calculate number of entries and segments required */

 Does F/W have an IOCBs for this request */

 Memory Barrier */

/*

 * it is assumed either hardware_lock or qpair lock is held.

 check appl tag */

 check ref tag */

 check guard */

 handle_data will load DIF error code  */

		/* assume scsi status gets out on the wire.

		 * Will not wait for completion.

 If hardware_lock held on entry, might drop it, then reaquire */

 This function sends the appropriate CTIO to ISP 2xxx or 24xx */

 terminate */

/*

 * If hardware_lock held on entry, might drop it, then reaquire

 * This function sends the appropriate CTIO to ISP 2xxx or 24xx

 Memory Barrier */

 why use different vha? NPIV */

			/* This cmd was never sent to TCM.  There is no need

			 * to schedule free or call free_cmd

		/*

		 * It's normal to see 2 calls in this path:

		 *  1) XFER Rdy completion + CMD_T_ABORT

		 *  2) TCM TMR - drain_state_list

/*

 * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire

 ha->hardware_lock supposed to be held on entry */

 We can't get loop ID from CTIO7 */

/*

 * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire

 That could happen only in case of an error/reset/abort */

 driver request abort via Terminate exchange */

 They are OK */

				/*

				 * Session is already logged out, but we need

				 * to notify initiator, who's not aware of this

		/* "cmd->aborted" means

		 * cmd is already aborted/terminated, we don't

		 * need to terminate again.  The exchange is already

		 * cleaned up/freed at FW level.  Just cleanup at driver

		 * level.

/*

 * Process context for I/O path into tcm_qla2xxx code

	/*

	 * Drop extra session reference from qlt_handle_cmd_for_atio().

	/*

	 * cmd has not sent to target yet, so pass NULL as the second

	 * argument to qlt_send_term_exchange() and free the memory here.

 spread lun to qpair ratio evently */

 ha->hardware_lock supposed to be held on entry */

	/* Another WWN used to have our s_id. Our PLOGI scheduled its

	/*

	 * Do kref_get() before returning + dropping qla_hw_data->hardware_lock.

 ha->hardware_lock supposed to be held on entry */

 no-op */

 ha->hardware_lock supposed to be held on entry */

 ha->hardware_lock supposed to be held on entry */

 ha->hardware_lock supposed to be held on entry */

/*

* ha->hardware_lock supposed to be held on entry (to protect tgt->sess_list)

*

* Schedules sessions with matching port_id/loop_id but different wwn for

* deletion. Returns existing session with matching wwn if present.

* Null otherwise.

 find other sess with nport_id collision */

				/*

				 * logout_on_delete is set by default, but another

				 * session that has the same s_id/loop_id combo

				 * might have cleared it when requested this session

				 * deletion, so don't touch it

				/*

				 * Another wwn used to have our s_id/loop_id

				 * kill the session, but don't free the loop_id

 find other sess with nport handle collision */

			/* Same loop_id but different s_id

 Abort any commands for this s_id waiting on qla_tgt_wq workqueue */

 Mark all stale commands sitting in qla_tgt_wq for deletion */

		/*

		 * Remote port registration is still going on from

		 * previous login. Allow it to finish before we

		 * accept the new login.

 remote port has assigned Port ID */

		/*

		 * Under normal circumstances we want to release nport handle

		 * during LOGO process to avoid nport handle leaks inside FW.

		 * The exception is when LOGO is done while another PLOGI with

		 * the same nport handle is waiting as might be the case here.

		 * Note: there is always a possibily of a race where session

		 * deletion has already started for other reasons (e.g. ACL

		 * removal) and now PLOGI arrives:

		 * 1. if PLOGI arrived in FW after nport handle has been freed,

		 *    FW must have assigned this PLOGI a new/same handle and we

		 *    can proceed ACK'ing it as usual when session deletion

		 *    completes.

		 * 2. if PLOGI arrived in FW before LOGO with LCF_FREE_NPORT

		 *    bit reached it, the handle has now been released. We'll

		 *    get an error when we ACK this PLOGI. Nothing will be sent

		 *    back to initiator. Initiator should eventually retry

		 *    PLOGI and situation will correct itself.

/*

 * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire

	/* res = 1 means ack at the end of thread

	 * res = 0 means ack async/later.

				/*

				 * Impatient initiator sent PRLI before last

				 * PLOGI could finish. Will force him to re-try,

				 * while last one finishes.

			/*

			 * This shouldn't happen under normal circumstances,

			 * since we have deleted the old session during PLOGI

 send notify ack */

 Make session global (not used in fabric mode) */

			/*

			 * cmd went upper layer, look for qlt_xmit_tm_rsp()

			 * for LOGO_ACK & sess delete

 cmd did not go to upper layer. */

 else logo will be ack */

 send notify ack */

 should never happen */

/*

 * ha->hardware_lock supposed to be held on entry.

 * Might drop it, then reacquire.

		/*

		 * QLogic requires to wait after LINK REINIT for possible

		 * PDISC or ADISC ELS commands

 The sessions will be cleared in the callback, if needed */

 The sessions will be cleared in the callback, if needed */

 The sessions will be cleared in the callback, if needed */

 I_T nexus loss */

/*

 * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire

 * This function sends busy to ISP 2xxx or 24xx.

 Sending marker isn't necessary, since we called from ISR */

	/*

	 * CTIO from fw w/o se_cmd doesn't provide enough info to retry it,

	 * if the explicit conformation is used.

 Memory Barrier */

/*

 * This routine is used to allocate a command for either a QFull condition

 * (ie reply SAM_STAT_BUSY) or to terminate an exchange that did not go

 * out previously.

 NOTE: borrowing the state field to carry the status */

 cmd->state is a borrowed field to hold status */

 piggy back on hardware_lock for protection */

		/* This cmd was never sent to TCM.  There is no need

		 * to schedule free or call free_cmd

 ha->hardware_lock supposed to be held on entry */

 called via callback from qla2xxx */

	/*

	 * In tgt_stop mode we also should allow all requests to pass.

	 * Otherwise, some commands can stuck.

/*

 * qpair lock is assume to be held

 * rc = 0 : send terminate & abts respond

 * rc != 0: do not send term & abts respond

	/*

	 * Detect unresolved exchange. If the same ABTS is unable

	 * to terminate an existing command and the same ABTS loops

	 * between FW & Driver, then force FW dump. Under 1 jiff,

	 * we should see multiple loops.

 found existing exchange */

 ha->hardware_lock supposed to be held on entry */

 called via callback from qla2xxx */

	/*

	 * In tgt_stop mode we also should allow all requests to pass.

	 * Otherwise, some commands can stuck.

/*

 * ha->hardware_lock supposed to be held on entry. Might drop it, then reaquire

	/*

	 * In tgt_stop mode we also should allow all requests to pass.

	 * Otherwise, some commands can stuck.

 Reset */

 System Error */

 Request Transfer Error */

 Response Transfer Error */

 Request Queue Wake-up. */

 exchange starvation. */

 Must be called under tgt_mutex */

		/*

		 * This is Domain Controller, so it should be

		 * OK to drop SCSI commands from it.

 sess has got an extra creation ref */

 sess has got an extra creation ref */

		/*

		 * This work can be scheduled on several CPUs at time, so we

		 * must delete the entry to eliminate double processing

 Must be called under tgt_host_action_mutex */

 3 is reserved */

 Must be called under tgt_host_action_mutex */

 free left over qfull cmds */

/**

 * qlt_lport_register - register lport with external module

 *

 * @target_lport_ptr: pointer for tcm_qla2xxx specific lport data

 * @phys_wwpn: physical port WWPN

 * @npiv_wwpn: NPIV WWPN

 * @npiv_wwnn: NPIV WWNN

 * @callback:  lport initialization callback for tcm_qla2xxx code

/**

 * qlt_lport_deregister - Degister lport

 *

 * @vha:  Registered scsi_qla_host pointer

	/*

	 * Clear the target_lport_ptr qla_target_template pointer in qla_hw_data

	/*

	 * Release the Scsi_Host reference for the underlying qla2xxx host

 Must be called under HW lock */

 Must be called under HW lock */

/*

 * qla_tgt_enable_vha - NO LOCK HELD

 *

 * host_reset, bring up w/ Target Mode Enabled

/*

 * qla_tgt_disable_vha - NO LOCK HELD

 *

 * Disable Target Mode and reset the adapter

	/*

	 * We are expecting the offline state.

	 * QLA_FUNCTION_FAILED means that adapter is offline.

/*

 * Called from qla_init.c:qla24xx_vport_create() contex to setup

 * the target mode specific struct scsi_qla_host and struct qla_hw_data

 * members.

	/*

	 * NOTE: Currently the value is kept the same for <24xx and

	 * >=24xx ISPs. If it is necessary to change it,

	 * the check should be added for specific ISPs,

	 * assigning the value appropriately.

	/*

	 * FC-4 Feature bit 0 indicates target functionality to the name server.

/*

 * qlt_init_atio_q_entries() - Initializes ATIO queue entries.

 * @ha: HA context

 *

 * Beginning of ATIO ring has initialization control block already built

 * by nvram config routine.

 *

 * Returns 0 on success.

/*

 * qlt_24xx_process_atio_queue() - Process ATIO queue entries.

 * @ha: SCSI driver HA context

			/*

			 * This packet is corrupted. The header + payload

			 * can not be trusted. There is no point in passing

			 * it further up.

 Adjust ring index */

 4 ports Baker: Enable Interrupt Handshake */

 INTx|MSI */

 We save only once */

 dual */

 Enable target mode */

 Disable ini mode, if requested */

 Disable Full Login after LIP */

 Enable initial LIP */

 Enable FC Tape support */

 Disable FC Tape support */

 Disable Full Login after LIP */

		/*

		 * clear BIT 15 explicitly as we have seen at least

		 * a couple of instances where this was set and this

		 * was causing the firmware to not be initialized.

 Enable target PRLI control */

 Change Loop-prefer to Pt-Pt */

 We save only once */

 dual */

 Enable target mode */

 Disable ini mode, if requested */

 Disable Full Login after LIP */

 Enable initial LIP */

		/*

		 * clear BIT 15 explicitly as we have seen at

		 * least a couple of instances where this was set

		 * and this was causing the firmware to not be

		 * initialized.

 Enable FC tape support */

 Disable FC tape support */

 Disable Full Login after LIP */

 Enable target PRLI control */

 Change Loop-prefer to Pt-Pt */

 For ATIO Q */

 enable target mode.  Bit5 = 1 => disable */

 Disable ini mode, if requested.  bit4 = 1 => disable */

		/* do not reach for ATIO queue here.  This is best effort err

		 * recovery at this point.

 vport_slock to be held by the caller */

	/*

	 * Return 1 to signal that initiator-mode is being disabled

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Linux MegaRAID driver for SAS based RAID controllers

 *

 *  Copyright (c) 2003-2013  LSI Corporation

 *  Copyright (c) 2013-2016  Avago Technologies

 *  Copyright (c) 2016-2018  Broadcom Inc.

 *

 *  Authors: Broadcom Inc.

 *           Sreenivas Bagalkote

 *           Sumant Patro

 *           Bo Yang

 *           Adam Radford

 *           Kashyap Desai <kashyap.desai@broadcom.com>

 *           Sumit Saxena <sumit.saxena@broadcom.com>

 *

 *  Send feedback to: megaraidlinux.pdl@broadcom.com

/*

 * Number of sectors per IO command

 * Will be set in megasas_init_mfi if user does not provide

/*

 * PCI ID table for all supported controllers

 xscale IOP */

 ppc IOP */

 ppc IOP */

 gen2*/

 gen2*/

 skinny*/

 skinny*/

 xscale IOP, vega */

 xscale IOP */

 Fusion */

 Plasma */

 Invader */

 Fury */

 Intruder */

 Intruder 24 port*/

 VENTURA */

 define lock for aen poll */

	/*

	 * Due to a HW errata in Aero controllers, reads to certain

	 * Fusion registers could intermittently return all zeroes.

	 * This behavior is transient in nature and subsequent reads will

	 * return valid value. As a workaround in driver, retry readl for

	 * upto three times until a non-zero value is read.

/**

 * megasas_set_dma_settings -	Populate DMA address, length and flags for DCMDs

 * @instance:			Adapter soft state

 * @dcmd:			DCMD frame inside MFI command

 * @dma_addr:			DMA address of buffer to be passed to FW

 * @dma_len:			Length of DMA buffer to be passed to FW

 * @return:			void

/**

 * megasas_get_cmd -	Get a command from the free pool

 * @instance:		Adapter soft state

 *

 * Returns a free command from the pool

/**

 * megasas_return_cmd -	Return a cmd to free command pool

 * @instance:		Adapter soft state

 * @cmd:		Command packet to be returned to free command pool

	/* This flag is used only for fusion adapter.

	 * Wait for Interrupt for Polled mode DCMD

/**

  * megasas_decode_evt: Decode FW AEN event and print critical event

  * for information.

  * @instance:			Adapter soft state

/*

 * The following functions are defined for xscale

 * (deviceid : 1064R, PERC5) controllers

/**

 * megasas_enable_intr_xscale -	Enables interrupts

 * @instance:	Adapter soft state

 Dummy readl to force pci flush */

/**

 * megasas_disable_intr_xscale -Disables interrupt

 * @instance:	Adapter soft state

 Dummy readl to force pci flush */

/**

 * megasas_read_fw_status_reg_xscale - returns the current FW status value

 * @instance:	Adapter soft state

/**

 * megasas_clear_intr_xscale -	Check & clear interrupt

 * @instance:	Adapter soft state

	/*

	 * Check if it is our interrupt

	/*

	 * Clear the interrupt by writing back the same value

 Dummy readl to force pci flush */

/**

 * megasas_fire_cmd_xscale -	Sends command to the FW

 * @instance:		Adapter soft state

 * @frame_phys_addr :	Physical address of cmd

 * @frame_count :	Number of frames for the command

 * @regs :		MFI register set

/**

 * megasas_adp_reset_xscale -  For controller reset

 * @instance:	Adapter soft state

 * @regs:	MFI register set

 sleep for 3 secs */

 need to wait 2 secs again */

/**

 * megasas_check_reset_xscale -	For controller reset check

 * @instance:	Adapter soft state

 * @regs:	MFI register set

/*

 * This is the end of set of functions & definitions specific

 * to xscale (deviceid : 1064R, PERC5) controllers

/*

 * The following functions are defined for ppc (deviceid : 0x60)

 * controllers

/**

 * megasas_enable_intr_ppc -	Enables interrupts

 * @instance:	Adapter soft state

 Dummy readl to force pci flush */

/**

 * megasas_disable_intr_ppc -	Disable interrupt

 * @instance:	Adapter soft state

 Dummy readl to force pci flush */

/**

 * megasas_read_fw_status_reg_ppc - returns the current FW status value

 * @instance:	Adapter soft state

/**

 * megasas_clear_intr_ppc -	Check & clear interrupt

 * @instance:	Adapter soft state

	/*

	 * Check if it is our interrupt

	/*

	 * Clear the interrupt by writing back the same value

 Dummy readl to force pci flush */

/**

 * megasas_fire_cmd_ppc -	Sends command to the FW

 * @instance:		Adapter soft state

 * @frame_phys_addr:	Physical address of cmd

 * @frame_count:	Number of frames for the command

 * @regs:		MFI register set

/**

 * megasas_check_reset_ppc -	For controller reset check

 * @instance:	Adapter soft state

 * @regs:	MFI register set

/**

 * megasas_enable_intr_skinny -	Enables interrupts

 * @instance:	Adapter soft state

 Dummy readl to force pci flush */

/**

 * megasas_disable_intr_skinny -	Disables interrupt

 * @instance:	Adapter soft state

 Dummy readl to force pci flush */

/**

 * megasas_read_fw_status_reg_skinny - returns the current FW status value

 * @instance:	Adapter soft state

/**

 * megasas_clear_intr_skinny -	Check & clear interrupt

 * @instance:	Adapter soft state

	/*

	 * Check if it is our interrupt

	/*

	 * Check if it is our interrupt

	/*

	 * Clear the interrupt by writing back the same value

	/*

	 * dummy read to flush PCI

/**

 * megasas_fire_cmd_skinny -	Sends command to the FW

 * @instance:		Adapter soft state

 * @frame_phys_addr:	Physical address of cmd

 * @frame_count:	Number of frames for the command

 * @regs:		MFI register set

/**

 * megasas_check_reset_skinny -	For controller reset check

 * @instance:	Adapter soft state

 * @regs:	MFI register set

/*

 * The following functions are defined for gen2 (deviceid : 0x78 0x79)

 * controllers

/**

 * megasas_enable_intr_gen2 -  Enables interrupts

 * @instance:	Adapter soft state

 write ~0x00000005 (4 & 1) to the intr mask*/

 Dummy readl to force pci flush */

/**

 * megasas_disable_intr_gen2 - Disables interrupt

 * @instance:	Adapter soft state

 Dummy readl to force pci flush */

/**

 * megasas_read_fw_status_reg_gen2 - returns the current FW status value

 * @instance:	Adapter soft state

/**

 * megasas_clear_intr_gen2 -      Check & clear interrupt

 * @instance:	Adapter soft state

	/*

	 * Check if it is our interrupt

	/*

	 * Clear the interrupt by writing back the same value

 Dummy readl to force pci flush */

/**

 * megasas_fire_cmd_gen2 -     Sends command to the FW

 * @instance:		Adapter soft state

 * @frame_phys_addr:	Physical address of cmd

 * @frame_count:	Number of frames for the command

 * @regs:		MFI register set

/**

 * megasas_adp_reset_gen2 -	For controller reset

 * @instance:	Adapter soft state

 * @reg_set:	MFI register set

/**

 * megasas_check_reset_gen2 -	For controller reset check

 * @instance:	Adapter soft state

 * @regs:	MFI register set

/*

 * This is the end of set of functions & definitions

 * specific to gen2 (deviceid : 0x78, 0x79) controllers

/*

 * Template added for TB (Fusion)

/**

 * megasas_issue_polled -	Issues a polling command

 * @instance:			Adapter soft state

 * @cmd:			Command packet to be issued

 *

 * For polling, MFI requires the cmd_status to be set to MFI_STAT_INVALID_STATUS before posting.

/**

 * megasas_issue_blocked_cmd -	Synchronous wrapper around regular FW cmds

 * @instance:			Adapter soft state

 * @cmd:			Command to be issued

 * @timeout:			Timeout in seconds

 *

 * This function waits on an event for the command to be returned from ISR.

 * Max wait time is MEGASAS_INTERNAL_CMD_WAIT_TIME secs

 * Used to issue ioctl commands.

/**

 * megasas_issue_blocked_abort_cmd -	Aborts previously issued cmd

 * @instance:				Adapter soft state

 * @cmd_to_abort:			Previously issued cmd to be aborted

 * @timeout:				Timeout in seconds

 *

 * MFI firmware can abort previously issued AEN comamnd (automatic event

 * notification). The megasas_issue_blocked_abort_cmd() issues such abort

 * cmd and waits for return status.

 * Max wait time is MEGASAS_INTERNAL_CMD_WAIT_TIME secs

	/*

	 * Prepare and issue the abort frame

/**

 * megasas_make_sgl32 -	Prepares 32-bit SGL

 * @instance:		Adapter soft state

 * @scp:		SCSI command from the mid-layer

 * @mfi_sgl:		SGL to be filled in

 *

 * If successful, this function returns the number of SG elements. Otherwise,

 * it returnes -1.

/**

 * megasas_make_sgl64 -	Prepares 64-bit SGL

 * @instance:		Adapter soft state

 * @scp:		SCSI command from the mid-layer

 * @mfi_sgl:		SGL to be filled in

 *

 * If successful, this function returns the number of SG elements. Otherwise,

 * it returnes -1.

/**

 * megasas_make_sgl_skinny - Prepares IEEE SGL

 * @instance:           Adapter soft state

 * @scp:                SCSI command from the mid-layer

 * @mfi_sgl:            SGL to be filled in

 *

 * If successful, this function returns the number of SG elements. Otherwise,

 * it returnes -1.

 /**

 * megasas_get_frame_count - Computes the number of frames

 * @frame_type		: type of frame- io or pthru frame

 * @sge_count		: number of sg elements

 *

 * Returns the number of frames required for numnber of sge's (sge_count)

	/*

	 * Main frame can contain 2 SGEs for 64-bit SGLs and

	 * 3 SGEs for 32-bit SGLs for ldio &

	 * 1 SGEs for 64-bit SGLs and

	 * 2 SGEs for 32-bit SGLs for pthru frame

 Main frame */

/**

 * megasas_build_dcdb -	Prepares a direct cdb (DCDB) command

 * @instance:		Adapter soft state

 * @scp:		SCSI command

 * @cmd:		Command to be prepared in

 *

 * This function prepares CDB commands. These are typcially pass-through

 * commands to the devices.

	/*

	 * Prepare the DCDB frame

	/*

	 * If the command is for the tape device, set the

	 * pthru timeout to the os layer timeout value.

	/*

	 * Construct SGL

	/*

	 * Sense info specific

	/*

	 * Compute the total number of frames this command consumes. FW uses

	 * this number to pull sufficient number of frames from host memory.

/**

 * megasas_build_ldio -	Prepares IOs to logical devices

 * @instance:		Adapter soft state

 * @scp:		SCSI command

 * @cmd:		Command to be prepared

 *

 * Frames (and accompanying SGLs) for regular SCSI IOs use this function.

	/*

	 * Prepare the Logical IO frame: 2nd bit is zero for all read cmds

	/*

	 * 6-byte READ(0x08) or WRITE(0x0A) cdb

	/*

	 * 10-byte READ(0x28) or WRITE(0x2A) cdb

	/*

	 * 12-byte READ(0xA8) or WRITE(0xAA) cdb

	/*

	 * 16-byte READ(0x88) or WRITE(0x8A) cdb

	/*

	 * Construct SGL

	/*

	 * Sense info specific

	/*

	 * Compute the total number of frames this command consumes. FW uses

	 * this number to pull sufficient number of frames from host memory.

/**

 * megasas_cmd_type -		Checks if the cmd is for logical drive/sysPD

 *				and whether it's RW or non RW

 * @cmd:			SCSI command

 *

 /**

 * megasas_dump_pending_frames -	Dumps the frame address of all pending cmds

 *					in FW

 * @instance:				Adapter soft state

for max_cmd*/

	/*

	 * Logical drive command

	/*

	 * Issue the command to the FW

/**

 * megasas_queue_command -	Queue entry point

 * @shost:			adapter SCSI host

 * @scmd:			SCSI command to be queued

 Check for an mpio path and adjust behavior */

/*

* megasas_set_dynamic_target_properties -

* Device property set by driver may not be static and it is required to be

* updated after OCR

*

* set tm_capable.

* set dma alignment (only for eedp protection enable vd).

*

* @sdev: OS provided scsi device

*

* Returns void

		/*

		 * If FW provides a target reset timeout value, driver will use

		 * it. If not set, fallback to default values.

/*

 * megasas_set_nvme_device_properties -

 * set nomerges=2

 * set virtual page boundary = 4K (current mr_nvme_pg_size is 4K).

 * set maximum io transfer = MDTS of NVME device provided by MR firmware.

 *

 * MR firmware provides value in KB. Caller of this function converts

 * kb into bytes.

 *

 * e.a MDTS=5 means 2^5 * nvme page size. (In case of 4K page size,

 * MR firmware provides value 128 as (32 * 4K) = 128K.

 *

 * @sdev:				scsi device

 * @max_io_size:				maximum io transfer size

 *

/*

 * megasas_set_fw_assisted_qd -

 * set device queue depth to can_queue

 * set device queue depth to fw assisted qd

 *

 * @sdev:				scsi device

 * @is_target_prop			true, if fw provided target properties.

/*

 * megasas_set_static_target_properties -

 * Device property set by driver are static and it is not required to be

 * updated after OCR.

 *

 * set io timeout

 * set device queue depth

 * set nvme device properties. see - megasas_set_nvme_device_properties

 *

 * @sdev:				scsi device

 * @is_target_prop			true, if fw provided target properties.

	/*

	 * The RAID firmware may require extended timeouts.

	/* max_io_size_kb will be set to non zero for

	 * nvme based vd and syspd.

 Send DCMD to Firmware and cache the information */

	/* Some ventura firmware may not have instance->nvme_page_size set.

	 * Do not send MR_DCMD_DRV_GET_TARGET_PROP

 This sdev property may change post OCR */

		/*

		 * Open the OS scan to the SYSTEM PD

/*

* megasas_complete_outstanding_ioctls - Complete outstanding ioctls after a

*                                       kill adapter

* @instance:				Adapter soft state

*

 Find all outstanding ioctls */

 Set critical error to block I/O & ioctls in case caller didn't */

 Wait 1 second to ensure IO or ioctls in build have posted */

 Flush */

 Complete outstanding ioctls when adapter is killed */

 /**

  * megasas_check_and_restore_queue_depth - Check if queue depth needs to be

  *					restored to max value

  * @instance:			Adapter soft state

  *

/**

 * megasas_complete_cmd_dpc	 -	Returns FW's controller structure

 * @instance_addr:			Address of adapter soft state

 *

 * Tasklet to complete cmds

 If we have already declared adapter dead, donot complete cmds */

	/*

	 * Check if we can restore can_queue

/**

 * megasas_start_timer - Initializes sriov heartbeat timer object

 * @instance:		Adapter soft state

 *

 Do a scan if we couldn't get affiliation */

 Do a scan if we couldn't get affiliation */

 This function will get the current SR-IOV LD/VF affiliation */

 This function will tell FW to start the SR-IOV heartbeat */

 Handler for SR-IOV heartbeat */

/**

 * megasas_wait_for_outstanding -	Wait for all outstanding cmds

 * @instance:				Adapter soft state

 *

 * This function waits for up to MEGASAS_RESET_WAIT_TIME seconds for FW to

 * complete all its outstanding commands. Returns error if one or more IOs

 * are pending after this time period. It also marks the controller dead.

			/*

			 * Call cmd completion routine. Cmd to be

			 * be completed directly without depending on isr.

 Reset not supported, kill adapter */

/**

 * megasas_generic_reset -	Generic reset routine

 * @scmd:			Mid-layer SCSI command

 *

 * This routine implements a generic reset handler for device, bus and host

 * reset requests. Device, bus and host specific reset handlers can use this

 * function after they do their specific tasks.

/**

 * megasas_reset_timer - quiesce the adapter if required

 * @scmd:		scsi cmnd

 *

 * Sets the FW busy flag and reduces the host->can_queue if the

 * cmd has not been completed within the timeout period.

 FW is busy, throttle IO */

/**

 * megasas_dump -	This function will print hexdump of provided buffer.

 * @buf:		Buffer to be dumped

 * @sz:		Size in bytes

 * @format:		Different formats of dumping e.g. format=n will

 *			cause only 'n' 32 bit words to be dumped in a single

 *			line.

/**

 * megasas_dump_reg_set -	This function will print hexdump of register set

 * @reg_set:	Register set to be dumped

/**

 * megasas_dump_fusion_io -	This function will print key details

 *				of SCSI IO

 * @scmd:			SCSI command pointer of SCSI IO

/*

 * megasas_dump_sys_regs - This function will dump system registers through

 *			    sysfs.

 * @reg_set:		    Pointer to System register set.

 * @buf:		    Buffer to which output is to be written.

 * @return:		    Number of bytes written to buffer.

/**

 * megasas_reset_bus_host -	Bus & host reset handler entry point

 * @scmd:			Mid-layer SCSI command

	/*

	 * First wait for all commands to complete

/**

 * megasas_task_abort - Issues task abort request to firmware

 *			(supported only for fusion adapters)

 * @scmd:		SCSI command pointer

/**

 * megasas_reset_target:  Issues target reset request to firmware

 *                        (supported only for fusion adapters)

 * @scmd:                 SCSI command pointer

/**

 * megasas_bios_param - Returns disk geometry for a disk

 * @sdev:		device handle

 * @bdev:		block device

 * @capacity:		drive capacity

 * @geom:		geometry parameters

 Default heads (64) & sectors (32) */

	/*

	 * Handle extended translation size for logical drives > 1Gb

 Setup Default hctx */

 Setup Poll hctx */

		/*

		 * The poll queue(s) doesn't have an IRQ (and hence IRQ

		 * affinity), so use the regular blk-mq cpu mapping

/**

 * megasas_service_aen -	Processes an event notification

 * @instance:			Adapter soft state

 * @cmd:			AEN command completed by the ISR

 *

 * For AEN, driver sends a command down to FW that is held by the FW till an

 * event occurs. When an event of interest occurs, FW completes the command

 * that it was previously holding.

 *

 * This routines sends SIGIO signal to processes that have registered with the

 * driver for AEN.

	/*

	 * Don't signal app if it is just an aborted previously registered aen

/*

 * Scsi host template for megaraid_sas driver

/**

 * megasas_complete_int_cmd -	Completes an internal command

 * @instance:			Adapter soft state

 * @cmd:			Command to be completed

 *

 * The megasas_issue_blocked_cmd() function waits for a command to complete

 * after it issues a command. This function wakes up that waiting routine by

 * calling wake_up() on the wait queue.

/**

 * megasas_complete_abort -	Completes aborting a command

 * @instance:			Adapter soft state

 * @cmd:			Cmd that was issued to abort another cmd

 *

 * The megasas_issue_blocked_abort_cmd() function waits on abort_cmd_wait_q

 * after it issues an abort on a previously issued command. This function

 * wakes up all functions waiting on the same wait queue.

/**

 * megasas_complete_cmd -	Completes a command

 * @instance:			Adapter soft state

 * @cmd:			Command to be completed

 * @alt_status:			If non-zero, use this value as status to

 *				SCSI mid-layer instead of the value returned

 *				by the FW. This should be used if caller wants

 *				an alternate status (as in the case of aborted

 *				commands)

 flag for the retry reset */

		/* Some older 1068 controller FW may keep a pended

		   MR_DCMD_CTRL_EVENT_GET_INFO left over from the main kernel

		   when booting the kdump kernel.  Ignore this command to

		/*

		 * MFI_CMD_PD_SCSI_IO and MFI_CMD_LD_SCSI_IO could have been

		 * issued either through an IO path or an IOCTL path. If it

		 * was via IOCTL, we will send it to internal completion.

 Check for LD map update */

			/*

			 * Set fast path IO to ZERO.

			 * Validate Map will set proper value.

			 * Meanwhile all IOs will go as LD IO.

 FW has an updated PD sequence */

 Re-register a pd sync seq num cmd */

		/*

		 * See if got an event notification

		/*

		 * Cmd issued to abort another cmd returned

/**

 * megasas_issue_pending_cmds_again -	issue all pending cmds

 *					in FW again because of the fw reset

 * @instance:				Adapter soft state

	/*

	 * Initiate AEN (Asynchronous Event Notification)

/*

 * Move the internal reset pending commands to a deferred queue.

 *

 * We move the commands pending at internal reset time to a

 * pending queue. This queue would be flushed after successful

 * completion of the internal reset sequence. if the internal reset

 * did not complete in time, the kernel reset handler would flush

 * these commands.

 waiting for about 20 second before start the second init */

/**

 * megasas_deplete_reply_queue -	Processes all completed commands

 * @instance:				Adapter soft state

 * @alt_status:				Alternate status to be returned to

 *					SCSI mid-layer instead of the status

 *					returned by the FW

 * Note: this must be called with hba lock held

 Hardware may not set outbound_intr_status in MSI-X mode */

/**

 * megasas_isr - isr entry point

 * @irq:	IRQ number

 * @devp:	IRQ context address

/**

 * megasas_transition_to_ready -	Move the FW to READY state

 * @instance:				Adapter soft state

 * @ocr:				Adapter reset state

 *

 * During the initialization, FW passes can potentially be in any one of

 * several possible states. If the FW in operational, waiting-for-handshake

 * states, driver must take steps to bring it to ready state. Otherwise, it

 * has to wait for the ready state.

			/*

			 * Set the CLR bit in inbound doorbell

			/*

			 * Bring it to READY state; assuming max wait 10 secs

			/*

			 * This state should not last for more than 2 seconds

		/*

		 * The cur_state should not last for more than max_wait secs

		/*

		 * Return error if fw_state hasn't changed after max_wait

/**

 * megasas_teardown_frame_pool -	Destroy the cmd frame DMA pool

 * @instance:				Adapter soft state

	/*

	 * Return all frames to pool

	/*

	 * Now destroy the pool itself

/**

 * megasas_create_frame_pool -	Creates DMA pool for cmd frames

 * @instance:			Adapter soft state

 *

 * Each command packet has an embedded DMA memory buffer that is used for

 * filling MFI frame and the SG list that immediately follows the frame. This

 * function creates those DMA memory buffers for each command packet by using

 * PCI pool facility.

	/*

	 * For MFI controllers.

	 * max_num_sge = 60

	 * max_sge_sz  = 16 byte (sizeof megasas_sge_skinny)

	 * Total 960 byte (15 MFI frame of 64 byte)

	 *

	 * Fusion adapter require only 3 extra frame.

	 * max_num_sge = 16 (defined as MAX_IOCTL_SGE)

	 * max_sge_sz  = 12 byte (sizeof  megasas_sge64)

	 * Total 192 byte (3 MFI frame of 64 byte)

	/*

	 * Use DMA pool facility provided by PCI layer

	/*

	 * Allocate and attach a frame to each of the commands in cmd_list.

	 * By making cmd->index as the context instead of the &cmd, we can

	 * always use 32bit context regardless of the architecture

		/*

		 * megasas_teardown_frame_pool() takes care of freeing

		 * whatever has been allocated

/**

 * megasas_free_cmds -	Free all the cmds in the free cmd pool

 * @instance:		Adapter soft state

 First free the MFI frame pool */

 Free all the commands in the cmd_list */

 Free the cmd_list buffer itself */

/**

 * megasas_alloc_cmds -	Allocates the command packets

 * @instance:		Adapter soft state

 *

 * Each command that is issued to the FW, whether IO commands from the OS or

 * internal commands like IOCTLs, are wrapped in local data structure called

 * megasas_cmd. The frame embedded in this megasas_cmd is actually issued to

 * the FW.

 *

 * Each frame has a 32-bit field called context (tag). This context is used

 * to get back the megasas_cmd from the frame when a frame gets completed in

 * the ISR. Typically the address of the megasas_cmd itself would be used as

 * the context. But we wanted to keep the differences between 32 and 64 bit

 * systems to the mininum. We always use 32 bit integers for the context. In

 * this driver, the 32 bit values are the indices into an array cmd_list.

 * This array is used only to look up the megasas_cmd given the context. The

 * free commands themselves are maintained in a linked list called cmd_pool.

	/*

	 * instance->cmd_list is an array of struct megasas_cmd pointers.

	 * Allocate the dynamic array first and then allocate individual

	 * commands.

	/*

	 * Create a frame pool and assign one frame to each cmd

/*

 * dcmd_timeout_ocr_possible -	Check if OCR is possible based on Driver/FW state.

 * @instance:				Adapter soft state

 *

 * Return 0 for only Fusion adapter, if driver load/unload is not in progress

 * or FW is not under OCR.

/*

 * megasas_get_pd_list_info -	Returns FW's pd_list structure

 * @instance:				Adapter soft state

 * @pd_list:				pd_list structure

 *

 * Issues an internal command (DCMD) to get the FW's controller PD

 * list structure.  This information is mainly used to find out SYSTEM

 * supported by the FW.

			/*

			 * DCMD failed from AEN path.

			 * AEN path already hold reset_mutex to avoid PCI access

			 * while OCR is in progress.

/*

 * megasas_get_ld_list_info -	Returns FW's ld_list structure

 * @instance:				Adapter soft state

 * @ld_list:				ld_list structure

 *

 * Issues an internal command (DCMD) to get the FW's controller PD

 * list structure.  This information is mainly used to find out SYSTEM

 * supported by the FW.

			/*

			 * DCMD failed from AEN path.

			 * AEN path already hold reset_mutex to avoid PCI access

			 * while OCR is in progress.

/**

 * megasas_ld_list_query -	Returns FW's ld_list structure

 * @instance:				Adapter soft state

 * @query_type:				ld_list structure type

 *

 * Issues an internal command (DCMD) to get the FW's controller PD

 * list structure.  This information is mainly used to find out SYSTEM

 * supported by the FW.

			/*

			 * DCMD failed from AEN path.

			 * AEN path already hold reset_mutex to avoid PCI access

			 * while OCR is in progress.

/**

 * megasas_host_device_list_query

 * dcmd.opcode            - MR_DCMD_CTRL_DEVICE_LIST_GET

 * dcmd.mbox              - reserved

 * dcmd.sge IN            - ptr to return MR_HOST_DEVICE_LIST structure

 * Desc:    This DCMD will return the combined device list

 * Status:  MFI_STAT_OK - List returned successfully

 *          MFI_STAT_INVALID_CMD - Firmware support for the feature has been

 *                                 disabled

 * @instance:			Adapter soft state

 * @is_probe:			Driver probe check

 * Return:			0 if DCMD succeeded

 *				 non-zero if failed

		/* Fill the internal pd_list and ld_ids array based on

		 * targetIds returned by FW

/*

 * megasas_update_ext_vd_details : Update details w.r.t Extended VD

 * instance			 : Controller's instance

 For MFI based controllers return dummy success */

 Below is additional check to address future FW enhancement */

 64k */

 irrespective of FW raid maps, driver raid map is constant */

/*

 * dcmd.opcode                - MR_DCMD_CTRL_SNAPDUMP_GET_PROPERTIES

 * dcmd.hdr.length            - number of bytes to read

 * dcmd.sge                   - Ptr to MR_SNAPDUMP_PROPERTIES

 * Desc:			 Fill in snapdump properties

 * Status:			 MFI_STAT_OK- Command successful

/**

 * megasas_get_ctrl_info -	Returns FW's controller structure

 * @instance:				Adapter soft state

 *

 * Issues an internal command (DCMD) to get the FW's controller structure.

 * This information is mainly used to find out the maximum IO transfer per

 * command supported by the FW.

		/* Save required controller information in

		 * CPU endianness format.

		/* Update the latest Ext VD info.

		 * From Init path, store current firmware details.

		 * From OCR path, detect any firmware properties changes.

		 * in case of Firmware upgrade without system reboot.

Check whether controller is iMR or MR */

/*

 * megasas_set_crash_dump_params -	Sends address of crash dump DMA buffer

 *					to firmware

 *

 * @instance:				Adapter soft state

 * @crash_buf_state		-	tell FW to turn ON/OFF crash dump feature

					MR_CRASH_BUF_TURN_OFF = 0

					MR_CRASH_BUF_TURN_ON = 1

 * @return 0 on success non-zero on failure.

 * Issues an internal command (DCMD) to set parameters for crash dump feature.

 * Driver will send address of crash dump DMA buffer and set mbox to tell FW

 * that driver supports crash dump feature. This DCMD will be sent only if

 * crash dump feature is supported by the FW.

 *

/**

 * megasas_issue_init_mfi -	Initializes the FW

 * @instance:		Adapter soft state

 *

 * Issues the INIT MFI cmd

	/*

	 * Prepare a init frame. Note the init frame points to queue info

	 * structure. Each frame has SGL allocated after first 64 bytes. For

	 * this frame - since we don't need any SGL - we use SGL's space as

	 * queue info structure

	 *

	 * We will not get a NULL command below. We just created the pool.

	/*

	 * disable the intr before firing the init frame to FW

	/*

	 * Issue the init frame in polled mode

	/*

	 * Get various operational parameters from status register

	/*

	 * Reduce the max supported cmds by 1. This is to ensure that the

	 * reply_q_sz (1 more than the max cmd that driver may send)

	 * does not exceed max cmds that the FW can support

	/*

	 * For MFI skinny adapters, MEGASAS_SKINNY_INT_CMDS commands

	 * are reserved for IOCTL + driver's internal DCMDs.

	/*

	 * Create a pool of commands

	/*

	 * Allocate memory for reply queue. Length of reply queue should

	 * be _one_ more than the maximum commands handled by the firmware.

	 *

	 * Note: When FW completes commands, it places corresponding contex

	 * values in this circular reply queue. This circular queue is a fairly

	 * typical producer-consumer queue. FW is the producer (of completed

	 * commands) and the driver is the consumer.

 Initialize IRQ poll */

/*

 * megasas_setup_irqs_ioapic -		register legacy interrupts.

 * @instance:				Adapter soft state

 *

 * Do not enable interrupt, only setup ISRs.

 *

 * Return 0 on success.

/**

 * megasas_setup_irqs_msix -		register MSI-x interrupts.

 * @instance:				Adapter soft state

 * @is_probe:				Driver probe check

 *

 * Do not enable interrupt, only setup ISRs.

 *

 * Return 0 on success.

 Try MSI-x */

 Retry irq register for IO_APIC*/

/*

 * megasas_destroy_irqs-		unregister interrupts.

 * @instance:				Adapter soft state

 * return:				void

/**

 * megasas_setup_jbod_map -	setup jbod map for FP seq_number.

 * @instance:				Adapter soft state

 *

 * Return 0 on success.

/**

 * megasas_get_device_list -	Get the PD and LD device list from FW.

 * @instance:			Adapter soft state

 * @return:			Success or failure

 *

 * Issue DCMDs to Firmware to get the PD and LD list.

 * Based on the FW support, driver sends the HOST_DEVICE_LIST or combination

 * of PD_LIST/LD_LIST_QUERY DCMDs to get the device list.

/**

 * megasas_set_high_iops_queue_affinity_hint -	Set affinity hint for high IOPS queues

 * @instance:					Adapter soft state

 * return:					void

	/* Do not allocate msix vectors for poll_queues.

	 * msix_vectors is always within a range of FW supported reply queue.

/**

 * megasas_alloc_irq_vectors -	Allocate IRQ vectors/enable MSI-x vectors

 * @instance:			Adapter soft state

 * return:			void

 reserve for default and non-mananged pre-vector. */

 Disable Balanced IOPS mode and try realloc vectors */

/**

 * megasas_init_fw -	Initializes the FW

 * @instance:		Adapter soft state

 *

 * This is the main function for initializing firmware

 Find first memory bar */

waiting for about 30 second before retry*/

 Check if MSI-X is supported while in ready state */

 Check max MSI-X vectors */

 Thunderbolt Series*/

				/*

				 * For Invader series, > 8 MSI-x vectors

				 * supported by FW/HW implies combined

				 * reply queue mode is enabled.

				 * For Ventura series, > 16 MSI-x vectors

				 * supported by FW/HW implies combined

				 * reply queue mode is enabled.

				/* Save 1-15 reply post index address to local memory

				 * Index 0 is already saved from reg offset

				 * MPI2_REPLY_POST_HOST_INDEX_OFFSET

 MFI adapters */

		/*

		 * For Aero (if some conditions are met), driver will configure a

		 * few additional reply queues with interrupt coalescing enabled.

		 * These queues with interrupt coalescing enabled are called

		 * High IOPS queues and rest of reply queues (based on number of

		 * logical CPUs) are termed as Low latency queues.

		 *

		 * Total Number of reply queues = High IOPS queues + low latency queues

		 *

		 * For rest of fusion adapters, 1 additional reply queue will be

		 * reserved for management commands, rest of reply queues

		 * (based on number of logical CPUs) will be used for IOs and

		 * referenced as IO queues.

		 * Total Number of reply queues = 1 + IO queues

		 *

		 * MFI adapters supports single MSI-x so single reply queue

		 * will be used for IO and management commands.

			/*

			 * For Aero, if PCIe link speed is <16 GT/s, then driver should operate

			 * in latency perf mode and enable R1 PCI bandwidth algorithm

			/*

			 * Performance mode settings provided through module parameter-perf_mode will

			 * take affect only for:

			 * 1. Aero family of adapters.

			 * 2. When user sets module parameter- perf_mode in range of 0-2.

			/*

			 * If intr coalescing is not supported by controller FW, then IOPS

			 * and Balanced modes are not feasible.

	/*

	 * MSI-X host index 0 is common for all adapter.

	 * It is used for all MPT based Adapters.

	/*

	 * Below are default value for legacy Firmware.

	 * non-fusion based controllers

 Get operational params, sge flags, send init cmd to controller */

 stream detection initialization */

	/*

	 * Compute the max allowed sectors per IO: The controller info has two

	 * limits on max sectors. Driver should use the minimum of these two.

	 *

	 * 1 << stripe_sz_ops.min = max sectors per strip

	 *

	 * Note that older firmwares ( < FW ver 30) didn't report information

	 * to calculate max_sectors_1. So the number ended up as zero always.

 Check for valid throttlequeuedepth module parameter */

 Launch SR-IOV heartbeat timer */

	/*

	 * Create and start watchdog thread which will monitor

	 * controller state every 1 sec and trigger OCR when

	 * it enters fault state

/**

 * megasas_release_mfi -	Reverses the FW initialization

 * @instance:			Adapter soft state

/**

 * megasas_get_seq_num -	Gets latest event sequence numbers

 * @instance:			Adapter soft state

 * @eli:			FW event log sequence numbers information

 *

 * FW maintains a log of all events in a non-volatile area. Upper layers would

 * usually find out the latest sequence number of the events, the seq number at

 * the boot etc. They would "read" all the events below the latest seq number

 * by issuing a direct fw cmd (DCMD). For the future events (beyond latest seq

 * number), they would subsribe to AEN (asynchronous event notification) and

 * wait for the events to happen.

	/*

	 * Copy the data back into callers buffer

/**

 * megasas_register_aen -	Registers for asynchronous event notification

 * @instance:			Adapter soft state

 * @seq_num:			The starting sequence number

 * @class_locale_word:		Class of the event

 *

 * This function subscribes for AEN for events beyond the @seq_num. It requests

 * to be notified if and only if the event is of type @class_locale

	/*

	 * If there an AEN pending already (aen_cmd), check if the

	 * class_locale of that pending AEN is inclusive of the new

	 * AEN request we currently have. If it is, then we don't have

	 * to do anything. In other words, whichever events the current

	 * AEN request is subscribing to, have already been subscribed

	 * to.

	 *

	 * If the old_cmd is _not_ inclusive, then we have to abort

	 * that command, form a class_locale that is superset of both

	 * old and current and re-issue to the FW

		/*

		 * A class whose enum value is smaller is inclusive of all

		 * higher values. If a PROGRESS (= -1) was previously

		 * registered, then a new registration requests for higher

		 * classes need not be sent to FW. They are automatically

		 * included.

		 *

		 * Locale numbers don't have such hierarchy. They are bitmap

		 * values

			/*

			 * Previously issued event registration includes

			 * current request. Nothing to do.

	/*

	 * Prepare DCMD for aen registration

	/*

	 * Store reference to the cmd used to register for AEN. When an

	 * application wants us to register for AEN, we have to abort this

	 * cmd and re-register with a new EVENT LOCALE supplied by that app

	/*

	 * Issue the aen registration frame

/* megasas_get_target_prop - Send DCMD with below details to firmware.

 *

 * This DCMD will fetch few properties of LD/system PD defined

 * in MR_TARGET_DEV_PROPERTIES. eg. Queue Depth, MDTS value.

 *

 * DCMD send by drivers whenever new target is added to the OS.

 *

 * dcmd.opcode         - MR_DCMD_DEV_GET_TARGET_PROP

 * dcmd.mbox.b[0]      - DCMD is to be fired for LD or system PD.

 *                       0 = system PD, 1 = LD.

 * dcmd.mbox.s[1]      - TargetID for LD/system PD.

 * dcmd.sge IN         - Pointer to return MR_TARGET_DEV_PROPERTIES.

 *

 * @instance:		Adapter soft state

 * @sdev:		OS provided scsi device

 *

 * Returns 0 on success non-zero on failure.

/**

 * megasas_start_aen -	Subscribes to AEN during driver load time

 * @instance:		Adapter soft state

	/*

	 * Get the latest sequence number from FW

	/*

	 * Register AEN with FW for latest sequence number plus 1

/**

 * megasas_io_attach -	Attaches this driver to SCSI mid-layer

 * @instance:		Adapter soft state

	/*

	 * Export parameters required by SCSI mid-layer

	/*

	 * Check if the module parameter value for max_sectors can be used

	/* Use shared host tagset only for fusion adaptors

	 * if there are managed interrupts (smp affinity enabled case).

	 * Single msix_vectors in kdump, so shared host tag is also disabled.

	/*

	 * Notify the mid-layer about the new controller

/**

 * megasas_set_dma_mask -	Set DMA mask for supported controllers

 *

 * @instance:		Adapter soft state

 * Description:

 *

 * For Ventura, driver/FW will operate in 63bit DMA addresses.

 *

 * For invader-

 *	By default, driver/FW will operate in 32bit DMA addresses

 *	for consistent DMA mapping but if 32 bit consistent

 *	DMA mask fails, driver will try with 63 bit consistent

 *	mask provided FW is true 63bit DMA capable

 *

 * For older controllers(Thunderbolt and MFI based adapters)-

 *	driver/FW will operate in 32 bit consistent DMA addresses.

			/*

			 * If 32 bit DMA mask fails, then try for 64 bit mask

			 * for FW capable of handling 64 bit DMA.

/*

 * megasas_set_adapter_type -	Set adapter type.

 *				Supported controllers can be divided in

 *				different categories-

 *					enum MR_ADAPTER_TYPE {

 *						MFI_SERIES = 1,

 *						THUNDERBOLT_SERIES = 2,

 *						INVADER_SERIES = 3,

 *						VENTURA_SERIES = 4,

 *						AERO_SERIES = 5,

 *					};

 * @instance:			Adapter soft state

 * return:			void

 For all other supported controllers */

/**

 * megasas_alloc_ctrl_mem -	Allocate per controller memory for core data

 *				structures which are not common across MFI

 *				adapters and fusion adapters.

 *				For MFI based adapters, allocate producer and

 *				consumer buffers. For fusion adapters, allocate

 *				memory for fusion context.

 * @instance:			Adapter soft state

 * return:			0 for SUCCESS

/*

 * megasas_free_ctrl_mem -	Free fusion context for fusion adapters and

 *				producer, consumer buffers for MFI adapters

 *

 * @instance -			Adapter soft instance

 *

/**

 * megasas_alloc_ctrl_dma_buffers -	Allocate consistent DMA buffers during

 *					driver load time

 *

 * @instance:				Adapter soft instance

 *

 * @return:				O for SUCCESS

/*

 * megasas_free_ctrl_dma_buffers -	Free consistent DMA buffers allocated

 *					during driver load time

 *

 * @instance-				Adapter soft instance

 *

/*

 * megasas_init_ctrl_params -		Initialize controller's instance

 *					parameters before FW init

 * @instance -				Adapter soft instance

 * @return -				void

	/*

	 * Initialize locks and queues

/**

 * megasas_probe_one -	PCI hotplug entry point

 * @pdev:		PCI device structure

 * @id:			PCI ids of supported hotplugged adapter

 Reset MSI-X in the kdump kernel */

	/*

	 * PCI prepping: enable device set bus mastering and dma mask

	/*

	 * Initialize PCI related and misc parameters

	/*

	 * Initialize MFI Firmware

	/*

	 * Store instance in PCI softstate

	/*

	 * Add this controller to megasas_mgmt_info structure so that it

	 * can be exported to management applications

	/*

	 * Register with SCSI mid-layer

	/*

	 * Trigger SCSI to scan our drives

	/*

	 * Initiate AEN (Asynchronous Event Notification)

 Get current SR-IOV LD/VF affiliation */

/**

 * megasas_flush_cache -	Requests FW to flush all its caches

 * @instance:			Adapter soft state

/**

 * megasas_shutdown_controller -	Instructs FW to shutdown the controller

 * @instance:				Adapter soft state

 * @opcode:				Shutdown/Hibernate

/**

 * megasas_suspend -	driver suspend entry point

 * @dev:		Device structure

 Shutdown SR-IOV heartbeat timer */

 Stop the FW fault detection watchdog */

 cancel the delayed work if this work still in queue */

/**

 * megasas_resume-      driver resume entry point

 * @dev:		Device structure

	/*

	 * We expect the FW state to be READY

 waiting for about 30 seconds before retry */

	/*

	 * Initialize MFI Firmware

 Now re-enable MSI-X */

 Re-launch SR-IOV heartbeat timer */

	/*

	 * Initiate AEN (Asynchronous Event Notification)

 Re-launch FW fault watchdog */

/**

 * megasas_detach_one -	PCI hot"un"plug entry point

 * @pdev:		PCI device structure

 Shutdown SR-IOV heartbeat timer */

 Stop the FW fault detection watchdog */

 cancel the delayed work if this work still in queue*/

 cancel all wait events */

	/*

	 * Take the instance off the instance array. Note that we will not

	 * decrement the max_index. We let this array be sparse array

/**

 * megasas_shutdown -	Shutdown entry point

 * @pdev:		PCI device structure

/*

 * megasas_mgmt_open -	char node "open" entry point

 * @inode:	char node inode

 * @filep:	char node file

	/*

	 * Allow only those users with admin rights

/*

 * megasas_mgmt_fasync -	Async notifier registration from applications

 * @fd:		char node file descriptor number

 * @filep:	char node file

 * @mode:	notifier on/off

 *

 * This function adds the calling process to a driver global queue. When an

 * event occurs, SIGIO will be sent to all processes in this queue.

 For sanity check when we get ioctl */

/*

 * megasas_mgmt_poll -  char node "poll" entry point

 * @filep:	char node file

 * @wait:	Events to poll for

/*

 * megasas_set_crash_dump_params_ioctl:

 *		Send CRASH_DUMP_MODE DCMD to all controllers

 * @cmd:	MFI command frame

/**

 * megasas_mgmt_fw_ioctl -	Issues management ioctls to FW

 * @instance:			Adapter soft state

 * @user_ioc:			User's ioctl packet

 * @ioc:			ioctl packet

	/*

	 * User's IOCTL packet has 2 frames (maximum). Copy those two

	 * frames into our cmd's frames. cmd->frame's context will get

	 * overwritten when we copy from user's frames. So set that value

	 * alone separately

	/*

	 * The management interface between applications and the fw uses

	 * MFI frames. E.g, RAID configuration changes, LD property changes

	 * etc are accomplishes through different kinds of MFI frames. The

	 * driver needs to care only about substituting user buffers with

	 * kernel buffers in SGLs. The location of SGL is embedded in the

	 * struct iocpacket itself.

	/*

	 * For each user buffer, create a mirror buffer and copy in

		/*

		 * We don't change the dma_coherent_mask, so

		 * dma_alloc_coherent only returns 32bit addresses

		/*

		 * We created a kernel buffer corresponding to the

		 * user buffer. Now copy in from the user buffer

 make sure the pointer is part of the frame */

 always store 64 bits regardless of addressing */

	/*

	 * Set the sync_cmd flag so that the ISR knows not to complete this

	 * cmd to the SCSI mid-layer

	/*

	 * copy out the kernel buffers to user buffers

	/*

	 * copy out the sense

		/*

		 * sense_ptr points to the location that has the user

		 * sense buffer address

	/*

	 * copy the status codes returned by the fw

 Block ioctls in VF mode */

/**

 * megasas_mgmt_ioctl -	char node ioctl entry point

 * @file:	char device file pointer

 * @cmd:	ioctl command

 * @arg:	ioctl command arguments address

/*

 * File operations structure for management interface

/*

 * PCI hotplug support registration structure

/*

 * Sysfs driver attributes

/**

 * megasas_update_device_list -	Update the PD and LD device list from FW

 *				after an AEN event notification

 * @instance:			Adapter soft state

 * @event_type:			Indicates type of event (PD or LD event)

 *

 * @return:			Success or failure

 *

 * Issue DCMDs to Firmware to update the internal device list in driver.

 * Based on the FW support, driver sends the HOST_DEVICE_LIST or combination

 * of PD_LIST/LD_LIST_QUERY DCMDs to get the device list.

/**

 * megasas_add_remove_devices -	Add/remove devices to SCSI mid-layer

 *				after an AEN event notification

 * @instance:			Adapter soft state

 * @scan_type:			Indicates type of devices (PD/LD) to add

 * @return			void

 Don't run the event workqueue thread if OCR is running */

 Register AEN with FW for latest sequence number plus 1 */

/**

 * megasas_init - Driver load entry point

	/*

	 * Booted in kdump kernel, minimize memory footprints by

	 * disabling few features

	/*

	 * Announce driver version and other information

	/*

	 * Register character device node

	/*

	 * Register ourselves as PCI hotplug module

/**

 * megasas_exit - Driver unload entry point

