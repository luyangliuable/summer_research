!/usr/bin/perl -w

 SPDX-License-Identifier: GPL-2.0-only



 Copyright 2015 - Steven Rostedt, Red Hat Inc.

 Copyright 2017 - Steven Rostedt, VMware, Inc.



 usage:

  config-bisect.pl [options] good-config bad-config [good|bad]



 Compares a good config to a bad config, then takes half of the diffs

 and produces a config that is somewhere between the good config and

 the bad config. That is, the resulting config will start with the

 good config and will try to make half of the differences of between

 the good and bad configs match the bad config. It tries because of

 dependencies between the two configs it may not be able to change

 exactly half of the configs that are different between the two config

 files.

 Here's a normal way to use it:



  $ cd /path/to/linux/kernel

  $ config-bisect.pl /path/to/good/config /path/to/bad/config

 This will now pull in good config (blowing away .config in that directory

 so do not make that be one of the good or bad configs), and then

 build the config with "make oldconfig" to make sure it matches the

 current kernel. It will then store the configs in that result for

 the good config. It does the same for the bad config as well.

 The algorithm will run, merging half of the differences between

 the two configs and building them with "make oldconfig" to make sure

 the result changes (dependencies may reset changes the tool had made).

 It then copies the result of its good config to /path/to/good/config.tmp

 and the bad config to /path/to/bad/config.tmp (just appends ".tmp" to the

 files passed in). And the ".config" that you should test will be in

 directory

 After the first run, determine if the result is good or bad then

 run the same command appending the result

 For good results:

  $ config-bisect.pl /path/to/good/config /path/to/bad/config good

 For bad results:

  $ config-bisect.pl /path/to/good/config /path/to/bad/config bad

 Do not change the good-config or bad-config, config-bisect.pl will

 copy the good-config to a temp file with the same name as good-config

 but with a ".tmp" after it. It will do the same with the bad-config.

 If "good" or "bad" is not stated at the end, it will copy the good and

 bad configs to the .tmp versions. If a .tmp version already exists, it will

 warn before writing over them (-r will not warn, and just write over them).

 If the last config is labeled "good", then it will copy it to the good .tmp

 version. If the last config is labeled "bad", it will copy it to the bad

 .tmp version. It will continue this until it can not merge the two any more

 without the result being equal to either the good or bad .tmp configs.

my $start = 0;

 "";

my $pwd = `pwd`;

chomp $pwd;

 $pwd;

  -b [optional] define location to build (O=build-dir) (default is linux-tree)

  good-config the config that is considered good

  bad-config the config that does not work

  "good" add this if the last run produced a good config

  "bad" add this if the last run produced a bad config

  If "good" or "bad" is not specified, then it is the start of a new bisect



  Note, each run will create copy of good and bad configs with ".tmp" appended.



EOF

;



    exit(-1);

}



sub doprint {

    print @_;

}



sub dodie {

    doprint "CRITICAL FAILURE... ", @_, "\n";



    die @_, "\n";

}



sub expand_path {

 @_;

    if ($file =~ m,^/,) {

	return $file;

    }

    return "$pwd/$file";

}



sub read_prompt {

 @_;

	$ans = <STDIN>;

	chomp $ans;

~ /^\s*$/) {

		$ans = "c";

	    } else {

 "n";

~ /^y$/i || $ans 
	    last if ($ans =~ /^c$/i);

	    print "Please answer either 'y', 'n' or 'c'.\n";

	} else {

	    print "Please answer either 'y' or 'n'.\n";

	}

    }

~ /^c/i) {

    my ($prompt) = @_;



    return read_prompt 0, $prompt;

}



sub read_ync {

 @_;

    my ($command, $redirect) = @_;

    my $start_time;

    my $end_time;

 0;

    $start_time = time;



    doprint("$command ... ");



 open(CMD, "$command 2>&1 |") or

	$dord = 1;

    }



    while (<CMD>) {

	print RD  if ($dord);

    }



    waitpid($pid, 0);

 $?;

    $end_time = time;

 $end_time - $start_time;

 config_ignore holds the configs that were set (or unset) for

 a good config and we will ignore these configs for the rest

 of a config bisect. These configs stay as they were.

 config_set holds what all configs were set as.

 config_off holds the set of configs that the bad config had disabled.

 We need to record them and set them in the .config when running

 olddefconfig, because olddefconfig keeps the defaults.

 config_off_tmp holds a set of configs to turn off for now

 config_list is the set of configs that are being tested

 Perhaps olddefconfig doesn't exist in this version of the kernel

 try oldnoconfig

 try a yes '' | oldconfig

    my ($hash, $config) = @_;



    doprint "Reading configs from $config\n";



    open (IN, $config)

	or dodie "Failed to read $config";



    while (<IN>) {

	chomp;

.*)/) {

	    ${$hash}{$2} = $1;

	} elsif (/^(# (CONFIG\S*) is not set)/) {

 $1;

    my ($config) = @_;



    assign_configs \%config_ignore, $config;

}



sub get_dependencies {

 @_;

    my $arr = $dependency{$config};

    if (!defined($arr)) {

	return ();

    }



 @{$arr};

	@deps = (@deps, get_dependencies $dep);

    }



    return @deps;

}



sub save_config {

 @_;

    my %configs = %{$pc};



    doprint "Saving configs into $file\n";



    open(OUT, ">$file") or dodie "Can not write to $file";



    foreach my $config (keys %configs) {

	print OUT "$configs{$config}\n";

    }

    close(OUT);

}



sub create_config {

 @_;

 compare two config hashes, and return configs with different vals.

 It returns B's config values, but you can use A to see what A was.

    my ($pa, $pb) = @_;



    # crappy Perl way to pass in hashes.

 %{$pa};

    my %b = %{$pb};



    my %ret;



    foreach my $item (keys %a) {

	if (defined($b{$item}) && $b{$item} ne $a{$item}) {

 $b{$item};

 compare two config hashes and return the configs in B but not A

    my ($pa, $pb) = @_;



    my %ret;



    # crappy Perl way to pass in hashes.

 %{$pa};

    my %b = %{$pb};



    foreach my $item (keys %b) {

	if (!defined($a{$item})) {

 $b{$item};

 return if two configs are equal or not

 0 is equal +1 b has something a does not

 +1 if a and b have a different item.

 -1 if a has something b does not

    my ($pa, $pb) = @_;



    my %ret;



    # crappy Perl way to pass in hashes.

 %{$pa};

    my %b = %{$pb};



    foreach my $item (keys %b) {

	if (!defined($a{$item})) {

	    return 1;

	}

	if ($a{$item} ne $b{$item}) {

	    return 1;

	}

    }



    foreach my $item (keys %a) {

	if (!defined($b{$item})) {

	    return -1;

	}

    }



    return 0;

}



sub process_failed {

 @_;

    my ($tc, $nc, $gc, $bc) = @_;



 %{$tc};

    my %good_configs = %{$gc};

 %{$bc};

    my $runtest = 1;

    my $ret;



    create_config "tmp_configs", \%tmp_config;

    assign_configs \%new_configs, $output_config;



 compare_configs \%new_configs, \%bad_configs;

	$runtest = 0;

    }



    if ($runtest) {

 compare_configs \%new_configs, \%good_configs;

	    $runtest = 0;

	}

    }



 %new_configs;

    my ($config) = @_;



 (.*) is not set/) {

 "$1
    $config =~ s/^CONFIG_//;

    return $config;

}



sub print_config {

 @_;

    $config = convert_config $config;

    doprint "$sym$config\n";

}



sub print_config_compare {

 @_;

    $good_config = convert_config $good_config;

 convert_config $bad_config;

    my $good_value = $good_config;

 $bad_config;

~ s/(.*)
    my $config = $1;



    $bad_value =~ s/.*=//;



    doprint " $config $good_value -> $bad_value\n";

}



# Pass in:

# $phalf: half of the configs names you want to add

# $oconfigs: The orginial configs to start with

# $sconfigs: The source to update $oconfigs with (from $phalf)

# $which: The name of which half that is updating (top / bottom)

# $type: The name of the source type (good / bad)

sub make_half {

 @_;

    my @half = @{$phalf};

 %{$oconfigs};

    my %source_configs = %{$sconfigs};



 %orig_configs;

	$tmp_config{$item} = $source_configs{$item};

    }



    return %tmp_config;

}



sub run_config_bisect {

 @_;

    my %good_configs = %{$pgood};

 %{$pbad};

    my %diff_configs = diff_config_vals \%good_configs, \%bad_configs;

 diff_configs \%good_configs, \%bad_configs;

    my %g_configs = diff_configs \%bad_configs, \%good_configs;



    # diff_arr is what is in both good and bad but are different (y->n)

 keys %diff_configs;

    my $len_diff = $#diff_arr + 1;



    # b_arr is what is in bad but not in good (has depends)

 keys %b_configs;

    my $len_b = $#b_arr + 1;



    # g_arr is what is in good but not in bad

 keys %g_configs;

    my $len_g = $#g_arr + 1;



 0;

 Look at the configs that are different between good and bad.

 This does not include those that depend on other configs

  (configs depending on other configs that are not set would

   not show up even as a "
 of configs to check:             $len_diff\n";

 of configs showing only in good: $len_g\n";

 of configs showing only in bad:  $len_b\n";

 Now test for different values

	my $half = int($#diff_arr / 2);

 @diff_arr[0 .. $half];

	my %tmp_config = make_half \@tophalf, \%good_configs,

	    \%bad_configs, "top", "bad";



 process_new_config \%tmp_config, \%new_configs,

	    my %tmp_config = make_half \@tophalf, \%bad_configs,

		\%good_configs, "top", "good";



 process_new_config \%tmp_config, \%new_configs,

 do the same thing, but this time with bottom half

	my $half = int($#diff_arr / 2);

diff_arr];

	my %tmp_config = make_half \@bottomhalf, \%good_configs,

	    \%bad_configs, "bottom", "bad";



 process_new_config \%tmp_config, \%new_configs,

	    my %tmp_config = make_half \@bottomhalf, \%bad_configs,

		\%good_configs, "bottom", "good";



 process_new_config \%tmp_config, \%new_configs,

    my ($good_config, $bad_config) = @_;

    my $ret;



    my %good_configs;

    my %bad_configs;

    my %tmp_configs;



    doprint "Run good configs through make oldconfig\n";

    assign_configs \%tmp_configs, $good_config;

    create_config "$good_config", \%tmp_configs;

    assign_configs \%good_configs, $output_config;



    doprint "Run bad configs through make oldconfig\n";

    assign_configs \%tmp_configs, $bad_config;

    create_config "$bad_config", \%tmp_configs;

    assign_configs \%bad_configs, $output_config;



    save_config \%good_configs, $good_config;

    save_config \%bad_configs, $bad_config;



    return run_config_bisect \%good_configs, \%bad_configs;

}



ARGV >= 0) {

    my $opt = shift @ARGV;



    if ($opt eq "-b") {

 shift @ARGV;

	$build = $val;

    }



    elsif ($opt eq "-l") {

 shift @ARGV;

	$tree = $val;

    }



    elsif ($opt eq "-r") {

 1;

$build = $tree if (!defined($build));



 expand_path $tree;

$build = expand_path $build;



if ( ! -d $tree ) {

    die "$tree not a directory\n";

}



if ( ! -d $build ) {

    die "$build not a directory\n";

}



usage if $#ARGV < 1;



if ($#ARGV == 1) {

 1;

ARGV == 2) {
 2) {

    $val = $ARGV[2];

    if ($val ne "good" && $val ne "bad") {

	die "Unknown command '$val', bust be either \"good\" or \"bad\"\n";

    }

} else {

    usage;

}



 expand_path $ARGV[0];

my $bad_start = expand_path $ARGV[1];



 "$good_start.tmp";

my $bad = "$bad_start.tmp";



 "make";

 "make O
$output_config = "$build/.config";



if ($start) {

    if ( ! -f $good_start ) {

	die "$good_start not found\n";

    }

    if ( ! -f $bad_start ) {

	die "$bad_start not found\n";

    }

    if ( -f $good || -f $bad ) {

 "";

	    $p = "$good exists\n";

	}



	if ( -f $bad ) {

 "$p$bad exists\n";

my $ret = config_bisect $good, $bad;



if (!$ret) {

    exit(0);

}



if ($ret > 0) {

    doprint "Cleaning temp files\n";

    run_command "rm $good";

    run_command "rm $bad";

    exit(1);

} else {

    doprint "See good and bad configs for details:\n";

    doprint "good: $good\n";

    doprint "bad:  $bad\n";

    doprint "%%%%%%%% FAILED TO FIND SINGLE BAD CONFIG %%%%%%%%\n";

}

exit(2);

!/usr/bin/perl -w

 SPDX-License-Identifier: GPL-2.0-only



 Copyright 2010 - Steven Rostedt <srostedt@redhat.com>, Red Hat Inc.



my $VERSION = "0.2";



 1;

default opts

my %default = (

 default mailer

    "EMAIL_ON_ERROR"		=> 1,

> 1,

    "EMAIL_WHEN_CANCELED"	=> 0,

> 0,

    "NUM_TESTS"			=> 1,

> "build",

    "BUILD_TYPE"		=> "oldconfig",

> "make",

    "CLOSE_CONSOLE_SIGNAL"	=> "INT",

> 120,

    "TMP_DIR"			=> "/tmp/ktest/\${MACHINE}",

 sleep time between tests

    "BUILD_NOCLEAN"		=> 0,

> 0,

    "POWEROFF_ON_ERROR"		=> 0,

> 1,

    "POWEROFF_ON_SUCCESS"	=> 0,

> "",

    "BISECT_SLEEP_TIME"		=> 60,		# sleep time between bisects

 sleep time between patch checks

    "CLEAR_LOG"			=> 0,

> 0,

    "BISECT_SKIP"		=> 1,

> 1,

    "MIN_CONFIG_TYPE"		=> "boot",

> "login:",

    "DETECT_TRIPLE_FAULT"	=> 1,

> 0,

    "BOOTED_TIMEOUT"		=> 1,

> 1,

    "SSH_EXEC"			=> "ssh \$SSH_USER\@\$MACHINE \$SSH_COMMAND",

> "scp \$SRC_FILE \$SSH_USER\@\$MACHINE:\$DST_FILE",

    "SCP_TO_TARGET_INSTALL"	=> "\${SCP_TO_TARGET}",

> "ssh \$SSH_USER\@\$MACHINE reboot",

    "REBOOT_RETURN_CODE"	=> 255,

> 10,

    "STOP_AFTER_FAILURE"	=> 60,

> 600,

    "MAX_MONITOR_WAIT"		=> 1800,

> "grub2-reboot",

> "grubby --info
    "SYSLINUX"			=> "extlinux",

> "/boot/extlinux",

    "CONNECT_TIMEOUT"		=> 25,



# required, and we will ask users if they don't have them but we keep the default

# value something that is common.

> "grub",

    "LOCALVERSION"		=> "-test",

> "root",

    "BUILD_TARGET"	 	=> "arch/x86/boot/bzImage",

> "/boot/vmlinuz-test",

    "LOG_FILE"			=> undef,

> 0,

my $test_log_start = 0;



 "ktest.conf";

my $have_version = 0;

my $machine;

my $last_machine;

my $ssh_user;

my $tmpdir;

my $builddir;

my $outputdir;

my $output_config;

my $test_type;

my $build_type;

my $build_options;

my $final_post_ktest;

my $pre_ktest;

my $post_ktest;

my $pre_test;

my $pre_test_die;

my $post_test;

my $pre_build;

my $post_build;

my $pre_build_die;

my $post_build_die;

my $reboot_type;

my $reboot_script;

my $power_cycle;

my $reboot;

my $reboot_return_code;

my $reboot_on_error;

my $switch_to_good;

my $switch_to_test;

my $poweroff_on_error;

my $reboot_on_success;

my $die_on_failure;

my $powercycle_after_reboot;

my $poweroff_after_halt;

my $max_monitor_wait;

my $ssh_exec;

my $scp_to_target;

my $scp_to_target_install;

my $power_off;

my $grub_menu;

my $last_grub_menu;

my $grub_file;

my $grub_number;

my $grub_reboot;

my $grub_bls_get;

my $syslinux;

my $syslinux_path;

my $syslinux_label;

my $target;

my $make;

my $pre_install;

my $post_install;

my $no_install;

my $noclean;

my $minconfig;

my $start_minconfig;

my $start_minconfig_defined;

my $output_minconfig;

my $minconfig_type;

my $use_output_minconfig;

my $warnings_file;

my $ignore_config;

my $ignore_errors;

my $addconfig;

 0;

my $bisect_bad_commit = "";

my $reverse_bisect;

my $bisect_manual;

my $bisect_skip;

my $bisect_tries;

my $config_bisect_good;

my $bisect_ret_good;

my $bisect_ret_bad;

my $bisect_ret_skip;

my $bisect_ret_abort;

my $bisect_ret_default;

 0;

my $monitor_cnt = 0;

my $sleep_time;

my $bisect_sleep_time;

my $patchcheck_sleep_time;

my $ignore_warnings;

my $store_failures;

my $store_successes;

my $test_name;

my $timeout;

my $connect_timeout;

my $config_bisect_exec;

my $booted_timeout;

my $detect_triplefault;

my $console;

my $close_console_signal;

my $reboot_success_line;

my $success_line;

my $stop_after_success;

my $stop_after_failure;

my $stop_test_after;

my $build_target;

my $target_image;

my $checkout;

my $localversion;

 0;

my $successes = 0;

my $stty_orig;

 0;

my $dirname = $FindBin::Bin;



my $mailto;

my $mailer;

my $mail_path;

my $mail_max_size;

my $mail_command;

my $email_on_error;

my $email_when_finished;

my $email_when_started;

my $email_when_canceled;



 localtime();

 set when a test is something other that just building or install

 which would require more options.

my $buildonly = 1;



# tell build not to worry about warnings, even when WARNINGS_FILE is set

 0;

 set when creating a new config

my $newconfig = 0;



my %entered_configs;

my %config_help;

my %variable;



# force_config is the list of configs that we force enabled (or disabled)

# in a .config file. The MIN_CONFIG and ADD_CONFIG configs.

my %force_config;



# do not force reboots on config problems

 1;

 reboot on success

my $reboot_success = 0;



 (

    "MAILTO"			=> \$mailto,

> \$mailer,

    "MAIL_PATH"			=> \$mail_path,

> \$mail_max_size,

    "MAIL_COMMAND"		=> \$mail_command,

> \$email_on_error,

    "EMAIL_WHEN_FINISHED"	=> \$email_when_finished,

> \$email_when_started,

    "EMAIL_WHEN_CANCELED"	=> \$email_when_canceled,

> \$machine,

    "SSH_USER"			=> \$ssh_user,

> \$tmpdir,

    "OUTPUT_DIR"		=> \$outputdir,

> \$builddir,

    "TEST_TYPE"			=> \$test_type,

> \$pre_ktest,

    "POST_KTEST"		=> \$post_ktest,

> \$pre_test,

    "PRE_TEST_DIE"		=> \$pre_test_die,

> \$post_test,

    "BUILD_TYPE"		=> \$build_type,

> \$build_options,

    "PRE_BUILD"			=> \$pre_build,

> \$post_build,

    "PRE_BUILD_DIE"		=> \$pre_build_die,

> \$post_build_die,

    "POWER_CYCLE"		=> \$power_cycle,

> \$reboot,

    "REBOOT_RETURN_CODE"	=> \$reboot_return_code,

> \$noclean,

    "MIN_CONFIG"		=> \$minconfig,

> \$output_minconfig,

    "START_MIN_CONFIG"		=> \$start_minconfig,

> \$minconfig_type,

    "USE_OUTPUT_MIN_CONFIG"	=> \$use_output_minconfig,

> \$warnings_file,

    "IGNORE_CONFIG"		=> \$ignore_config,

> \$run_test,

    "ADD_CONFIG"		=> \$addconfig,

> \$reboot_type,

    "GRUB_MENU"			=> \$grub_menu,

> \$grub_file,

    "GRUB_REBOOT"		=> \$grub_reboot,

> \$grub_bls_get,

    "SYSLINUX"			=> \$syslinux,

> \$syslinux_path,

    "SYSLINUX_LABEL"		=> \$syslinux_label,

> \$pre_install,

    "POST_INSTALL"		=> \$post_install,

> \$no_install,

    "REBOOT_SCRIPT"		=> \$reboot_script,

> \$reboot_on_error,

    "SWITCH_TO_GOOD"		=> \$switch_to_good,

> \$switch_to_test,

    "POWEROFF_ON_ERROR"		=> \$poweroff_on_error,

> \$reboot_on_success,

    "DIE_ON_FAILURE"		=> \$die_on_failure,

> \$power_off,

    "POWERCYCLE_AFTER_REBOOT"	=> \$powercycle_after_reboot,

> \$poweroff_after_halt,

    "MAX_MONITOR_WAIT"		=> \$max_monitor_wait,

> \$sleep_time,

    "BISECT_SLEEP_TIME"		=> \$bisect_sleep_time,

> \$patchcheck_sleep_time,

    "IGNORE_WARNINGS"		=> \$ignore_warnings,

> \$ignore_errors,

    "BISECT_MANUAL"		=> \$bisect_manual,

> \$bisect_skip,

    "BISECT_TRIES"		=> \$bisect_tries,

> \$config_bisect_good,

    "BISECT_RET_GOOD"		=> \$bisect_ret_good,

> \$bisect_ret_bad,

    "BISECT_RET_SKIP"		=> \$bisect_ret_skip,

> \$bisect_ret_abort,

    "BISECT_RET_DEFAULT"	=> \$bisect_ret_default,

> \$store_failures,

    "STORE_SUCCESSES"		=> \$store_successes,

> \$test_name,

    "TIMEOUT"			=> \$timeout,

> \$connect_timeout,

    "CONFIG_BISECT_EXEC"	=> \$config_bisect_exec,

> \$booted_timeout,

    "CONSOLE"			=> \$console,

> \$close_console_signal,

    "DETECT_TRIPLE_FAULT"	=> \$detect_triplefault,

> \$success_line,

    "REBOOT_SUCCESS_LINE"	=> \$reboot_success_line,

> \$stop_after_success,

    "STOP_AFTER_FAILURE"	=> \$stop_after_failure,

> \$stop_test_after,

    "BUILD_TARGET"		=> \$build_target,

> \$ssh_exec,

    "SCP_TO_TARGET"		=> \$scp_to_target,

> \$scp_to_target_install,

    "CHECKOUT"			=> \$checkout,

> \$target_image,

    "LOCALVERSION"		=> \$localversion,



> \$bisect_good,

    "BISECT_BAD"		=> \$bisect_bad,

> \$bisect_type,

    "BISECT_START"		=> \$bisect_start,

> \$bisect_replay,

    "BISECT_FILES"		=> \$bisect_files,

> \$bisect_reverse,

    "BISECT_CHECK"		=> \$bisect_check,



> \$config_bisect,

    "CONFIG_BISECT_TYPE"	=> \$config_bisect_type,

> \$config_bisect_check,

    "PATCHCHECK_TYPE"		=> \$patchcheck_type,

> \$patchcheck_start,

    "PATCHCHECK_CHERRY"		=> \$patchcheck_cherry,

> \$patchcheck_end,

 Options may be used by other options, record them.

 default variables that can be used

chomp ($variable{"PWD"} = `pwd`);

 $variable{"PWD"};

$config_help{"MACHINE"} = << "EOF"

 The machine hostname that you will test.

 For build only tests, it is still needed to differentiate log files.

EOF

    ;

 << "EOF"

$config_help{"BUILD_DIR"} = << "EOF"

 The directory that contains the Linux source code (full path).

 You can use \${PWD} that will be the path where ktest.pl is run, or use

 \${THIS_DIR} which is assigned \${PWD} but may be changed later.

EOF

    ;

 << "EOF"

$config_help{"BUILD_TARGET"} = << "EOF"

 The location of the compiled file to copy to the target.

 (relative to OUTPUT_DIR)

EOF

    ;

 << "EOF"

$config_help{"TARGET_IMAGE"} = << "EOF"

 The place to put your image on the test machine.

EOF

    ;

 << "EOF"

 wget --no-proxy -O /dev/null -q  --auth-no-challenge 'http://admin:admin\@power/outlet?5
 POWER_CYCLE = virsh destroy Guest; sleep 5; virsh start Guest

EOF

    ;

 << "EOF"

CONSOLE = nc -d localhost 3001



 For a virtual machine with guest name "Guest".

  virsh console Guest

$config_help{"LOCALVERSION"} = << "EOF"

 Required version ending to differentiate the test

 from other linux builds on the system.

EOF

    ;

 << "EOF"

$config_help{"GRUB_MENU"} = << "EOF"

 The grub title name for the test kernel to boot

 grub or grub2)

 GRUB_MENU = Test Kernel



 For grub2, a search of \$GRUB_FILE is performed for the lines

 that begin with "menuentry". It will not detect submenus. The

 menu must be a non-nested menu. Add the quotes used in the menu

 to guarantee your selection, as the first menuentry with the content

 of \$GRUB_MENU that is found will be used.



 For grub2bls, \$GRUB_MENU is searched on the result of \$GRUB_BLS_GET

 command for the lines that begin with "title".

EOF

    ;

 << "EOF"

$config_help{"SYSLINUX_LABEL"} = << "EOF"

 If syslinux is used, the label that boots the target kernel must

 be specified with SYSLINUX_LABEL.

EOF

    ;

 << "EOF"

 (Only mandatory if REBOOT_TYPE = script)

EOF

    ;



# used with process_expression()

 0;

 defined before get_test_name()

my $in_die = 0;



# defined before process_warning_line()

 ".*:.*(warning|error|Error):.*";

my $utf8_quote = "\\x{e2}\\x{80}(\\x{98}|\\x{99})";



# defined before child_finished()

my $child_done;



# config_ignore holds the configs that were set (or unset) for

# a good config and we will ignore these configs for the rest

# of a config bisect. These configs stay as they were.

my %config_ignore;



# config_set holds what all configs were set as.

my %config_set;



# config_off holds the set of configs that the bad config had disabled.

# We need to record them and set them in the .config when running

# olddefconfig, because olddefconfig keeps the defaults.

my %config_off;



# config_off_tmp holds a set of configs to turn off for now

my @config_off_tmp;



# config_list is the set of configs that are being tested

my %config_list;

my %null_config;



my %dependency;



# found above run_config_bisect()

 1;

 found above add_dep()

my $iflevel = 0;

my @ifdeps;



# prevent recursion

my %read_kconfigs;



# found above test_this_config()

my %min_configs;

my %keep_configs;

my %save_configs;

my %processed_configs;

my %nochange_config;



#

# These are first defined here, main function later on

#

sub run_command;

sub start_monitor;

sub end_monitor;

sub wait_for_monitor;



sub _logit {

    if (defined($opt{"LOG_FILE"})) {

	print LOG @_;

    }

}



sub logit {

    if (defined($opt{"LOG_FILE"})) {

	_logit @_;

    } else {

	print @_;

    }

}



sub doprint {

    print @_;

    _logit @_;

}



sub read_prompt {

 @_;

	$ans = <STDIN>;

	chomp $ans;

~ /^\s*$/) {

		$ans = "c";

	    } else {

 "y";

~ /^y$/i || $ans 
	    last if ($ans =~ /^c$/i);

	    print "Please answer either 'y', 'n' or 'c'.\n";

	} else {

	    print "Please answer either 'y' or 'n'.\n";

	}

    }

~ /^c/i) {

    my ($prompt) = @_;



    return read_prompt 0, $prompt;

}



sub read_ync {

 @_;

    my ($config) = @_;

    my $ans;



    return if (defined($opt{$config}));



    if (defined($config_help{$config})) {

	print "\n";

	print $config_help{$config};

    }



    for (;;) {

 ";

	$ans = <STDIN>;

~ s/^\s*(.*\S)\s*$/$1/;

	if ($ans =~ /^\s*$/) {

	    if ($default{$config}) {

 $default{$config};

	$entered_configs{$config} = ${ans};

	last;

    }

}



sub show_time {

 @_;

    my $hours = 0;

 0;

	$hours = int($time / 3600);

 $hours * 3600;

	$minutes = int($time / 60);

 $minutes * 60;

    doprint "s" if ($time != 1);

}



sub print_times {

    doprint "\n";

    if ($build_time) {

	doprint "Build time:   ";

	show_time($build_time);

	doprint "\n";

    }

    if ($install_time) {

	doprint "Install time: ";

	show_time($install_time);

	doprint "\n";

    }

    if ($reboot_time) {

	doprint "Reboot time:  ";

	show_time($reboot_time);

	doprint "\n";

    }

    if ($test_time) {

	doprint "Test time:    ";

	show_time($test_time);

	doprint "\n";

    }

    # reset for iterations like bisect

 0;

    $install_time = 0;

 0;

    $test_time = 0;

}



sub get_mandatory_configs {

    get_mandatory_config("MACHINE");

    get_mandatory_config("BUILD_DIR");

    get_mandatory_config("OUTPUT_DIR");



    if ($newconfig) {

	get_mandatory_config("BUILD_OPTIONS");

    }



    # options required for other than just building a kernel

    if (!$buildonly) {

	get_mandatory_config("POWER_CYCLE");

	get_mandatory_config("CONSOLE");

    }



    # options required for install and more

 1) {

    my $rtype = $opt{"REBOOT_TYPE"};



    if (!defined($rtype)) {

	if (!defined($opt{"GRUB_MENU"})) {

	    get_mandatory_config("REBOOT_TYPE");

 $entered_configs{"REBOOT_TYPE"};

	    $rtype = "grub";

	}

    }



    if (($rtype eq "grub") or ($rtype eq "grub2bls")) {

	get_mandatory_config("GRUB_MENU");

    }



    if ($rtype eq "grub2") {

	get_mandatory_config("GRUB_MENU");

	get_mandatory_config("GRUB_FILE");

    }



    if ($rtype eq "syslinux") {

	get_mandatory_config("SYSLINUX_LABEL");

    }

}



sub process_variables {

 @_;

    my $retval = "";



    # We want to check for '\', and it is just easier

    # to check the previous characet of '$' and not need

    # to worry if '$' is the first character. By adding

    # a space to $value, we can just check [^\\]\$ and

    # it will still work.

 " $value";

    while ($value =~ /(.*?[^\\])\$\{(.*?)\}(.*)/) {

 $1;

	my $var = $2;

 $3;

 append beginning of value to retval

	$retval = "$retval$begin";

	if (defined($variable{$var})) {

 "$retval$variable{$var}";

 for if statements, any variable that is not defined,

 we simple convert to 0

	    $retval = "${retval}0";

	} else {

	    # put back the origin piece.

 "$retval\$\{$var\}";

 This could be an option that is used later, save

 it so we don't warn if this option is not one of

 ktests options.

	    $used_options{$var} = 1;

	}

 $end;

    $retval = "$retval$value";



    # remove the space added in the beginning

~ s/ //;

    my ($lvalue, $rvalue, $override, $overrides, $name) = @_;



 process_variables($rvalue);

    if ($lvalue =~ /^(TEST|BISECT|CONFIG_BISECT)_TYPE(\[.*\])?$/ &&

	$prvalue !~ /^(config_|)bisect$/ &&

	$prvalue !~ /^build$/ &&

	$buildonly) {



	# Note if a test is something other than build, then we

	# will need other mandatory options.

	if ($prvalue ne "install") {

 0;

 install still limits some mandatory options.

	    $buildonly = 2;

	}

    }



    if (defined($opt{$lvalue})) {

	if (!$override || defined(${$overrides}{$lvalue})) {

 "";

		$extra = "In the same override section!\n";

	    }

	    die "$name: $.: Option $lvalue defined more than once!\n$extra";

	}

 $prvalue;

    $opt{$lvalue} = $prvalue;

}



sub set_eval {

 @_;

    my $prvalue = process_variables($rvalue);

    my $arr;



    if (defined($evals{$lvalue})) {

 $evals{$lvalue};

	$arr = [];

 $arr;

    my ($lvalue, $rvalue) = @_;



~ /^\s*$/) {

	$rvalue = process_variables($rvalue);

 $rvalue;

    my ($lval, $cmp, $rval) = @_;



    # remove whitespace



~ s/^\s*//;

    $lval =~ s/\s*$//;



~ s/^\s*//;

    $rval =~ s/\s*$//;



    if ($cmp eq "==") {

	return $lval eq $rval;

") {

    } elsif ($cmp eq "=~") {

~ m/$rval/;

    my $statement = "$lval $cmp $rval";

 eval $statement;

 $@ stores error of eval

    my ($val) = @_;



    return defined($variable{$2}) ||

	defined($opt{$2});

}



sub process_expression {

 @_;

    my $c = $d++;



~ s/\(([^\(]*?)\)/\&\&\&\&VAL\&\&\&\&/) {

	my $express = $1;



	if (process_expression($name, $express)) {

~ s/\&\&\&\&VAL\&\&\&\&/ 1 /;

	    $val =~ s/\&\&\&\&VAL\&\&\&\&/ 0 /;

	}

    }



    $d--;

 "\\|\\|";

    my $AND = "\\&\\&";



~ s/^(.*?)($OR|$AND)//) {

	my $express = $1;

 $2;

    if ($val =~ /(.*)(==|\!=|>=|<=|>|<|=~|\!~)(.*)/) {

 process_compare($1, $2, $3);

    if ($val =~ /^\s*(NOT\s*)?DEFINED\s+(\S+)\s*$/) {

	if (defined $1) {

	    return !value_defined($2);

	} else {

	    return value_defined($2);

	}

    }



~ s/^\s*NOT\s+(.*)//) {

	my $express = $1;

 process_expression($name, $express);

    if ($val =~ /^\s*0\s*$/) {

	return 0;

~ /^\s*\d+\s*$/) {

    my ($name, $value) = @_;



    # Convert variables and replace undefined ones with 0

 process_variables($value, 1);

    my $ret = process_expression $name, $val;



    return $ret;

}



sub __read_config {

 @_;

    my $name = $config;

~ s,.*/(.*),$1,;

    my $test_num = $$current_test_num;

 1;

    my $repeat = 1;

 0;

    my $skip = 0;

    my $rest;

    my $line;

 0;

    my $if = 0;

 0;

    my $override = 0;



    my %overrides;



    while (<$in>) {



	# ignore blank lines and comments

	next if (/^\s*$/ || /\s*\#/);



	if (/^\s*(TEST_START|DEFAULTS)\b(.*)/) {



 $1;

	    $rest = $2;

 $2;

	    $override = 0;



	    if ($type eq "TEST_START") {

		if ($num_tests_set) {

		    die "$name: $.: Can not specify both NUM_TESTS and TEST_START\n";

		}



 $test_num;

		$old_repeat = $repeat;



 $repeat;

		$default = 0;

 1;

		$default = 1;

	    }



	    # If SKIP is anywhere in the line, the command will be skipped

~ s/\s+SKIP\b//) {

		$skip = 1;

	    } else {

 1;

		$skip = 0;

	    }



~ s/\sELSE\b//) {

		$if = 0;



		if ($if_set) {

 1;

		    $skip = 0;

		}

	    }



~ s/\sIF\s+(.*)//) {

		    $if_set = 1;

		} else {

 1;

		$if = 1;

	    } else {

 0;

		$if_set = 0;

	    }



	    if (!$skip) {

		if ($type eq "TEST_START") {

~ s/\s+ITERATE\s+(\d+)//) {

			$repeat = $1;

 $repeat;

		} elsif ($rest =~ s/\sOVERRIDE\b//) {

		    # DEFAULT only

 1;

 Clear previous overrides

		    %overrides = ();

		}

	    }



	    if (!$skip && $rest !~ /^\s*$/) {

		die "$name: $.: Garbage found after $type\n$_";

	    }



	    if ($skip && $type eq "TEST_START") {

 $old_test_num;

		$repeat = $old_repeat;

	    }

	} elsif (/^\s*ELSE\b(.*)$/) {

	    if (!$if) {

		die "$name: $.: ELSE found with out matching IF section\n$_";

	    }

 $1;

		$skip = 1;

 "";

		$skip = 0;



~ /\sIF\s+(.*)/) {

 May be a ELSE IF section.

			$if_set = 1;

		    } else {

 1;

		    $rest = "";

		} else {

 0;

	    my $file = process_variables($1);



	    if ($file !~ m,^/,) {

		# check the path of the config file first

~ m,(.*)/,) {

			$file = "$1/$file";

		    }

		}

	    }



	    if ( ! -r $file ) {

		die "$name: $.: Can't read file $file\n$_";

	    }



	    if (__read_config($file, \$test_num)) {

 1;

	} elsif (/^\s*([A-Z_\[\]\d]+)\s*=~\s*(.*?)\s*$/) {



	    next if ($skip);



 $1;

	    my $rvalue = $2;



~ /\[\d+\]$/) {

		my $val = "$lvalue\[$test_num\]";

		set_eval($val, $rvalue, $name);

	    }



\s*(.*?)\s*$/) {

	    my $lvalue = $1;

 $2;

		$num_tests_set = 1;

	    }



~ /\[\d+\]$/) {

		my $val = "$lvalue\[$test_num\]";

		set_value($val, $rvalue, $override, \%overrides, $name);



		if ($repeat > 1) {

 $repeat;

	} elsif (/^\s*([A-Z_\[\]\d]+)\s*:=\s*(.*?)\s*$/) {

	    next if ($skip);



 $1;

	    my $rvalue = $2;



	    # process config variables.

	    # Config variables are only active while reading the

	    # config and can be defined anywhere. They also ignore

	    # TEST_START and DEFAULTS, but are skipped if they are in

	    # on of these sections that have SKIP defined.

	    # The save variable can be

	    # defined multiple times and the new one simply overrides

	    # the previous one.

	    set_variable($lvalue, $rvalue);



	} else {

	    die "$name: $.: Garbage found in config\n$_";

	}

    }



    if ($test_num) {

 $repeat - 1;

	$opt{"NUM_TESTS"} = $test_num;

    }



    close($in);



 $test_num;

    my $ans = <STDIN>;

    chomp $ans;

 $ans;

    my ($config) = @_;



    my $test_case;

 0;

    $test_case = __read_config $config, \$test_num;



    # make sure we have all mandatory configs

    get_mandatory_configs;



    # was a test specified?

    if (!$test_case) {

	print "No test case specified.\n";

	get_test_case;

    }



    # set any defaults



    foreach my $default (keys %default) {

	if (!defined($opt{$default})) {

 $default{$default};

 check if there are any stragglers (typos?)

	my $op = $option;

	# remove per test labels.

~ s/\[.*\]//;

	    $not_used{$op} = 1;

	}

    }



    if (%not_used) {

 "s are";

	$s = " is" if (keys %not_used == 1);

	print "The following option$s not used; could be a typo:\n";

	foreach my $option (keys %not_used) {

	    print "$option\n";

	}

 1 to have ktest ignore unused variables\n";

    my ($name, $option, $i) = @_;



    # Add space to evaluate the character before $

 " $option";

    my $retval = "";

 0;

    my $parent = 0;



    foreach my $test (keys %repeat_tests) {

 $test &&

	    $repeated = 1;

 $test;

    while ($option =~ /(.*?[^\\])\$\{(.*?)\}(.*)/) {

 $1;

	my $var = $2;

 $3;

 Append beginning of line

	$retval = "$retval$start";



	# If the iteration option OPT[$i] exists, then use that.

	# otherwise see if the default OPT (without [$i]) exists.



 "$var\[$i\]";

	my $parento = "$var\[$parent\]";



	# If a variable contains itself, use the default var

	if (($var eq $name) && defined($opt{$var})) {

 $opt{$var};

	    $retval = "$retval$o";

	} elsif (defined($opt{$o})) {

 $opt{$o};

	    $retval = "$retval$o";

	} elsif ($repeated && defined($opt{$parento})) {

 $opt{$parento};

	    $retval = "$retval$o";

	} elsif (defined($opt{$var})) {

 $opt{$var};

	    $retval = "$retval$o";

	} elsif ($var eq "KERNEL_VERSION" && defined($make)) {

	    # special option KERNEL_VERSION uses kernel version

	    get_version();

 "$retval$version";

	    $retval = "$retval\$\{$var\}";

	}



 $end;

    $retval = "$retval$option";



~ s/^ //;

    my ($name, $option, $i) = @_;



 "$name\[$i\]";

    my $old_option = $option;



    if (defined($evals{$option_name})) {

 $evals{$option_name};

	$ev = $evals{$name};

    } else {

	return $option;

    }



    for my $e (@{$ev}) {

~ $e";

    my ($name, $option, $i) = @_;



 "";

 Since an option can evaluate to another option,

 keep iterating until we do not evaluate any more

 options.

    my $r = 0;

    while ($prev ne $option) {

	# Check for recursive evaluations.

	# 100 deep should be more than enough.

	if ($r++ > 100) {

	    die "Over 100 evaluations occurred with $option\n" .

		"Check for recursive variables\n";

	}

 $option;

	$option = __eval_option($name, $option, $i);

    }



 process_evals($name, $option, $i);

    my ($time) = @_;

 0;

 test if the machine can be connected to within a few seconds

    my $stat = run_ssh("echo check machine status", $connect_timeout);

    if (!$stat) {

	doprint("power cycle\n");

 1;

 flush out current monitor

 May contain the reboot success line

 Make sure everything has been written to disk

 flush out current monitor

 May contain the reboot success line

 try to reboot normally

 nope? power cycle it.

 We only want to get to the new kernel, don't fail

 if we stumble over a call trace.

	my $save_ignore_errors = $ignore_errors;

 1;

 Look for the good kernel to boot

 reboot got stuck?

	$ignore_errors = $save_ignore_errors;



	# Still need to wait for the reboot to finish

	wait_for_monitor($time, $reboot_success_line);



	end_monitor;

    }

}



sub reboot_to_good {

 @_;

    my $i = $iteration;



    return $test_type eq "build" || $no_reboot ||

	($test_type eq "patchcheck" && $opt{"PATCHCHECK_TYPE[$i]"} eq "build") ||

	($test_type eq "bisect" && $opt{"BISECT_TYPE[$i]"} eq "build") ||

	($test_type eq "config_bisect" && $opt{"CONFIG_BISECT_TYPE[$i]"} eq "build");

}



sub get_test_name() {

    my $name;



    if (defined($test_name)) {

 "$test_name:$test_type";

	$name = $test_type;

    }

    return $name;

}



sub dodie {

    # avoid recursion

    return if ($in_die);

 1;

    my $i = $iteration;



    doprint "CRITICAL FAILURE... [TEST $i] ", @_, "\n";



    if ($reboot_on_error && !do_not_reboot) {

	doprint "REBOOTING\n";

	reboot_to_good;

    } elsif ($poweroff_on_error && defined($power_off)) {

	doprint "POWERING OFF\n";

	`$power_off`;

    }



    if (defined($opt{"LOG_FILE"})) {

	print " See $opt{LOG_FILE} for more info.\n";

    }



    if ($email_on_error) {

 get_test_name;

	    my $whence = 2; # End of file

 tell LOG;

	    my $size = $log_size - $test_log_start;



	    if (defined($mail_max_size)) {

		if ($size > $mail_max_size) {

 $mail_max_size;

	    my $pos = - $size;

 "$tmpdir/log";

 restore terminal settings

    my ($ptm, $pts) = @_;

    my $tmp;

 0x40045431;

    my $TIOCGPTN = 0x80045430;



    sysopen($ptm, "/dev/ptmx", O_RDWR | O_NONBLOCK) or

	dodie "Can't open /dev/ptmx";



    # unlockpt()

 pack("i", 0);

 ptsname()

    $tmp = unpack("i", $tmp);



    sysopen($pts, "/dev/pts/$tmp", O_RDWR | O_NONBLOCK) or

	dodie "Can't open /dev/pts/$tmp";

}



sub exec_console {

 @_;

    my ($ptm) = @_;

 \*PTSFD;

 save terminal settings

    $stty_orig = `stty -g`;



    # place terminal in cbreak mode so that stdin can be read one character at

    # a time without having to wait for a newline

    system("stty -icanon -echo -icrnl");



    create_pty($ptm, $pts);



 fork;

 child

 parent

    my ($fp, $pid) = @_;



    doprint "kill child process $pid\n";

    kill $close_console_signal, $pid;



    doprint "wait for child process $pid to exit\n";

    waitpid($pid, 0);



    print "closing!\n";

    close($fp);



    # restore terminal settings

    system("stty $stty_orig");

}



sub start_monitor {

    if ($monitor_cnt++) {

	return;

    }

 \*MONFD;

    $monitor_pid = open_console $monitor_fp;



    return;



    open(MONFD, "Stop perl from warning about single use of MONFD");

}



sub end_monitor {

    return if (!defined $console);

    if (--$monitor_cnt) {

	return;

    }

    close_console($monitor_fp, $monitor_pid);

}



sub wait_for_monitor {

 @_;

    my $full_line = "";

    my $line;

 0;

    my $start_time = time;

 0;

    my $bug = 0;

 0;

 read the monitor and wait for the system to calm down

	$line = wait_for_input($monitor_fp, $time);

	last if (!defined($line));

	print "$line";

 $line;

	if (defined($stop) && $full_line =~ /$stop/) {

	    doprint "wait for monitor detected $stop\n";

 1;

	if ($full_line =~ /\[ backtrace testing \]/) {

 1;

	if ($full_line =~ /call trace:/i) {

	    if (!$bug && !$skip_call_trace) {

		if ($ignore_errors) {

 1;

		    $bug = 1;

		}

	    }

	}



~ /\[ end of backtrace testing \]/) {

	    $skip_call_trace = 0;

	}



~ /Kernel panic -/) {

	    $bug = 1;

	}



~ /\n/) {

	    $full_line = "";

	}

 time;

	if ($now - $start_time >= $max_monitor_wait) {

	    doprint "Exiting monitor flush due to hitting MAX_MONITOR_WAIT\n";

	    return 1;

	}

    }

    print "** Monitor flushed **\n";



    # if stop is defined but wasn't hit, return error

    # used by reboot (which wants to see a reboot)

    if (defined($stop) && !$booted) {

 1;

    my ($result, $basedir) = @_;

 localtime;

    my $date = sprintf "%04d%02d%02d%02d%02d%02d",

	1900+$t[5],$t[4],$t[3],$t[2],$t[1],$t[0];



 $build_type;

    if ($type =~ /useconfig/) {

 "useconfig";

    my $dir = "$machine-$test_type-$type-$result-$date";



 "$basedir/$dir";

    my %files = (

> $output_config,

	"buildlog" => $buildlog,

> $dmesg,

	"testlog" => $testlog,

    );



 each(%files)) {

    my $i = $iteration;



    # no need to reboot for just building.

    if (!do_not_reboot) {

	doprint "REBOOTING\n";

	reboot_to_good $sleep_time;

    }



 "";

	$name = " ($test_name)";

    }



    print_times;



    doprint "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n";

    doprint "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n";

    doprint "KTEST RESULT: TEST $i$name Failed: ", @_, "\n";

    doprint "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n";

    doprint "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n";



    if (defined($store_failures)) {

	save_logs "fail", $store_failures;

    }



    if (defined($post_test)) {

	run_command $post_test;

    }



    return 1;

}



sub run_command {

 @_;

    my $dolog = 0;

 0;

    my $dostdout = 0;

    my $pid;

 $command;

    $command =~ s/\$SSH_USER/$ssh_user/g;

~ s/\$MACHINE/$machine/g;

    $start_time = time;



 open(CMD, "$command 2>&1 |") or

	$dolog = 1;

    }



    if (defined($redirect)) {

	if ($redirect eq 1) {

 1;

 Have the output of the command on its own line

	    $dord = 1;

	}

    }



 0;

	my $fp = \*CMD;

	if (defined($timeout)) {

 $timeout\n";

	my $line = wait_for_input($fp, $timeout);

	if (!defined($line)) {

 time;

	    if (defined($timeout) && (($now - $start_time) >= $timeout)) {

		doprint "Hit timeout of $timeout, killing process\n";

 1;

 shift 8 for real exit status

    $run_command_status = $? >> 8;



    if ($command_orig eq $default{REBOOT} &&

	$run_command_status == $reboot_return_code) {

 0;

    $end_time = time;

 $end_time - $start_time;

	$run_command_status = 1;

    }



    if ($run_command_status) {

	doprint "FAILED!\n";

    } else {

	doprint "SUCCESS\n";

    }



    return !$run_command_status;

}



sub run_ssh {

 @_;

    my $cp_exec = $ssh_exec;



~ s/\$SSH_COMMAND/$cmd/g;

    my ($src, $dst, $cp_scp) = @_;



~ s/\$SRC_FILE/$src/g;

    $cp_scp =~ s/\$DST_FILE/$dst/g;



    return run_command "$cp_scp";

}



sub run_scp_install {

 @_;

    my $cp_scp = $scp_to_target_install;



    return run_scp($src, $dst, $cp_scp);

}



sub run_scp_mod {

 @_;

    my $cp_scp = $scp_to_target;



    return run_scp($src, $dst, $cp_scp);

}



sub _get_grub_index {



 @_;

    $grub_number = -1;



 $ssh_exec;

    $ssh_grub =~ s,\$SSH_COMMAND,$command,g;



    open(IN, "$ssh_grub |") or

	dodie "unable to execute $command";



 0;

	    $found = 1;

	    last;

	} elsif (/$skip/) {

	    $grub_number++;

	}

    }

    close(IN);



    dodie "Could not find '$grub_menu' through $command on $machine"

	if (!$found);

    doprint "$grub_number\n";

 $grub_menu;

    $last_machine = $machine;

}



sub get_grub_index {



    my $command;

    my $target;

    my $skip;

    my $grub_menu_qt;



    if ($reboot_type !~ /^grub/) {

	return;

    }



 quotemeta($grub_menu);

	$command = "cat /boot/grub/menu.lst";

 '^\s*title\s+' . $grub_menu_qt . '\s*$';

	$skip = '^\s*title\s';

    } elsif ($reboot_type eq "grub2") {

 "cat $grub_file";

	$target = '^menuentry.*' . $grub_menu_qt;

 '^menuentry\s|^submenu\s';

	$command = $grub_bls_get;

	$target = '^title=.*' . $grub_menu_qt;

	$skip = '^title=';

    } else {

	return;

    }



    _get_grub_index($command, $target, $skip);

}



sub wait_for_input {

 @_;

	$time = $timeout;

    }



 '';

    vec($rin, fileno($fp), 1) = 1;

 1;

    $start_time = time;



    while (1) {

	$nr = select($rout=$rin, undef, undef, $time);



 0);

 copy data from stdin to the console

	    $nr = sysread(\*STDIN, $buf, 1000);

	    syswrite($fp, $buf, $nr) if ($nr > 0);

	}



	# The timeout is based on time waiting for the fp data

 1) {

	$line = "";



	# try to read one char at a time

	while (sysread $fp, $ch, 1) {

 $ch;

	run_ssh "'(echo \"savedefault --default=$grub_number --once\" | grub --batch)'";

    } elsif (($reboot_type eq "grub2") or ($reboot_type eq "grub2bls")) {

	run_ssh "$grub_reboot $grub_number";

    } elsif ($reboot_type eq "syslinux") {

	run_ssh "$syslinux --once \\\"$syslinux_label\\\" $syslinux_path";

    } elsif (defined $reboot_script) {

	run_command "$reboot_script";

    }

    reboot;

}



sub get_sha1 {

 @_;

    doprint "git rev-list --max-count=1 $commit ... ";

    my $sha1 = `git rev-list --max-count=1 $commit`;

 $?;

    my $booted = 0;

 0;

    my $bug_ignored = 0;

 0;

    my $start_time = time;



    wait_for_monitor 5;



    my $line;

 "";

    my $monitor_start = time;

 0;

    my $version_found = 0;



    while (!$done) {

	if ($bug && defined($stop_after_failure) &&

 0) {

	    my $time = $stop_after_failure - (time - $failure_start);

 wait_for_input($monitor_fp, $time);

	    $line = wait_for_input($monitor_fp, $booted_timeout);

	    if (!defined($line)) {

 $booted_timeout  1 ? "" : "s";

	    $line = wait_for_input($monitor_fp);

	    if (!defined($line)) {

 $timeout  1 ? "" : "s";

 we are not guaranteed to get a full line

	$full_line .= $line;



~ /$success_line/) {

	    $booted = 1;

 time;

	    $stop_after_success >= 0) {

 time;

	    if ($now - $success_start >= $stop_after_success) {

		doprint "Test forced to stop after $stop_after_success seconds after success\n";

		last;

	    }

	}



~ /\[ backtrace testing \]/) {

	    $skip_call_trace = 1;

	}



~ /call trace:/i) {

		    $bug_ignored = 1;

		} else {

 1;

		    $failure_start = time;

		}

	    }

	}



	if ($bug && defined($stop_after_failure) &&

 0) {

	    my $now = time;

 $stop_after_failure) {

	if ($full_line =~ /\[ end of backtrace testing \]/) {

 0;

	if ($full_line =~ /Kernel panic -/) {

 time;

	    $bug = 1;

	}



	# Detect triple faults by testing the banner

~ /\bLinux version (\S+).*\n/) {

		$version_found = 1;

	    } elsif ($version_found && $detect_triplefault) {

		# We already booted into the kernel we are testing,

		# but now we booted into another kernel?

		# Consider this a triple fault.

		doprint "Already booted in Linux kernel $version, but now\n";

		doprint "we booted into Linux kernel $1.\n";

		doprint "Assuming that this is a triple fault.\n";

		doprint "To disable this: set DETECT_TRIPLE_FAULT to 0\n";

		last;

	    }

	}



~ /\n/) {

	    $full_line = "";

	}



	if ($stop_test_after > 0 && !$booted && !$bug) {

	    if (time - $monitor_start > $stop_test_after) {

		doprint "STOP_TEST_AFTER ($stop_test_after seconds) timed out\n";

 1;

    my $end_time = time;

 $end_time - $start_time;

	doprint "WARNING: Call Trace detected but ignored due to IGNORE_ERRORS=1\n";

    }



    return 1;

}



sub eval_kernel_version {

 @_;

    $option =~ s/\$KERNEL_VERSION/$version/g;



    return $option;

}



sub do_post_install {



    return if (!defined($post_install));



 eval_kernel_version $post_install;

 Sometimes the reboot fails, and will hang. We try to ssh to the box

 and if we fail, we force another reboot, that should powercycle it.

    my $start_time = time;



    if (defined($pre_install)) {

 eval_kernel_version $pre_install;

    my $cp_target = eval_kernel_version $target_image;



    test_booted;



    run_scp_install "$outputdir/$build_target", "$cp_target" or

	dodie "failed to copy image";



 0;

 should we process modules?

    $install_mods = 0;

    open(IN, "$output_config") or dodie("Can't read config file");

    while (<IN>) {

y)?/) {

		$install_mods = 1;

		last;

	    }

	}

    }

    close(IN);



    if (!$install_mods) {

	do_post_install;

	doprint "No modules needed\n";

 time;

	$install_time = $end_time - $start_time;

	return;

    }



    run_command "$make INSTALL_MOD_STRIP=1 INSTALL_MOD_PATH=$tmpdir modules_install" or

	dodie "Failed to install modules";



 "/lib/modules/$version";

    my $modtar = "ktest-mods.tar.bz2";



    run_ssh "rm -rf $modlib" or

	dodie "failed to remove old mods: $modlib";



    # would be nice if scp -r did not follow symbolic links

    run_command "cd $tmpdir && tar -cjf $modtar lib/modules/$version" or

	dodie "making tarball";



    run_scp_mod "$tmpdir/$modtar", "/tmp" or

	dodie "failed to copy modules";



    unlink "$tmpdir/$modtar";



    run_ssh "'(cd / && tar xjf /tmp/$modtar)'" or

	dodie "failed to tar modules";



    run_ssh "rm -f /tmp/$modtar";



    do_post_install;



 time;

    $install_time = $end_time - $start_time;

}



sub get_version {

    # get the release name

    return if ($have_version);

    doprint "$make kernelrelease ... ";

 `$make -s kernelrelease | tail -1`;

    $have_version = 1;

}



sub start_monitor_and_install {

    # Make sure the stable kernel has finished booting



    # Install bisects, don't need console

    if (defined $console) {

	start_monitor;

	wait_for_monitor 5;

	end_monitor;

    }



    get_grub_index;

    get_version;

    install;



    start_monitor if (defined $console);

    return monitor;

}



sub process_warning_line {

 @_;

 for distcc heterogeneous systems, some compilers

 do things differently causing warning lines

 to be slightly different. This makes an attempt

 to fixe those issues.

 chop off the index into the line

 using distcc, some compilers give different indexes

 depending on white space

    $line =~ s/^(\s*\S+:\d+:)\d+/$1/;



    # Some compilers use UTF-8 extended for quotes and some don't.

~ s/$utf8_quote/'/g;

 Read buildlog and check against warnings file for any

 new warnings.



 Returns 1 if OK

         0 otherwise

 Failed builds should not reboot the target

    my $save_no_reboot = $no_reboot;

 1;

		my $warning = process_warning_line $_;



 1;

 If warnings file didn't exist, and WARNINGS_FILE exist,

 then we fail on any warning!

	    my $warning = process_warning_line $_;



	    if (!defined $warnings_list{$warning}) {

		fail "New warning found (not in $warnings_file)\n$_\n";

 $save_no_reboot;

    $no_reboot = $save_no_reboot;

    close(IN);

}



sub check_patch_buildlog {

 @_;

    my @files = `git show $patch | diffstat -l`;



    foreach my $file (@files) {

	chomp $file;

    }



    open(IN, "git show $patch |") or

	dodie "failed to show $patch";

    while (<IN>) {

	if (m,^--- a/(.*),) {

	    chomp $1;

files] = $1;

	    my $err = $1;

	    foreach my $file (@files) {

 "$builddir/$file";

    my $outconfig = "$output_config.new";



    # Read the config file and remove anything that

    # is in the force_config hash (from minconfig and others)

    # then add the force config back.



    doprint "Applying minimum configurations into $output_config.new\n";



    open (OUT, ">$outconfig") or

	dodie "Can't create $outconfig";



    if (-f $output_config) {

	open (IN, $output_config) or

	    dodie "Failed to open $output_config";

	while (<IN>) {

 )?(CONFIG_[^\s=]*)/) {

    my @force_list = keys %force_config;



force_list >= 0) {

 Perhaps olddefconfig doesn't exist in this version of the kernel

 try oldnoconfig

 try a yes '' | oldconfig

 read a config file and use this to force new configs.

    my ($config) = @_;



    doprint "Loading force configs from $config\n";

    open(IN, $config) or

	dodie "failed to read $config";

    while (<IN>) {

	chomp;

	if (/^(CONFIG[^\s=]*)(\s*=.*)/) {

 $_;

 (CONFIG_\S*) is not set/) {

	    $force_config{$1} = $_;

	}

    }

    close IN;

}



sub build {

 @_;

    my $start_time = time;



    # Failed builds should not reboot the target

 $no_reboot;

    $no_reboot = 1;



    # Calculate a new version from here.

 0;

	my $ret = run_command $pre_build;

	if (!$ret && defined($pre_build_die) &&

	    $pre_build_die) {

	    dodie "failed to pre_build\n";

	}

    }



~ /^useconfig:(.*)/) {

	$type = "oldconfig";

    }



    # old config can ask questions

    if ($type eq "oldconfig") {

 "olddefconfig";

 allow for empty configs

 add something to distinguish this build

 Run old config regardless, to enforce min configurations

	$build_options = "";

    }

 run_command "$make $build_options", $buildlog;

 Because a post build may change the kernel version

 do it now.

	my $ret = run_command $post_build;

	if (!$ret && defined($post_build_die) &&

	    $post_build_die) {

	    dodie "failed to post_build\n";

	}

    }



    if (!$build_ret) {

	# bisect may need this to pass

	if ($in_bisect) {

 $save_no_reboot;

    $no_reboot = $save_no_reboot;



 time;

    $build_time = $end_time - $start_time;



    return 1;

}



sub halt {

    if (!run_ssh "halt" or defined($power_off)) {

	if (defined($poweroff_after_halt)) {

	    sleep $poweroff_after_halt;

	    run_command "$power_off";

	}

    } else {

	# nope? the zap it!

	run_command "$power_off";

    }

}



sub success {

 @_;

    my $name = "";



    if (defined($test_name)) {

 " ($test_name)";

    if ($i != $opt{"NUM_TESTS"} && !do_not_reboot) {

	doprint "Reboot and wait $sleep_time seconds\n";

	reboot_to_good $sleep_time;

    }



    if (defined($post_test)) {

	run_command $post_test;

    }

}



sub answer_bisect {

    for (;;) {

	doprint "Pass, fail, or skip? [p/f/s]";

 <STDIN>;

 child should have no power

    $reboot_on_error = 0;

 0;

    $die_on_failure = 1;



    run_command $run_test, $testlog;



    exit $run_command_status;

}



sub child_finished {

 1;

    my $bug = 0;

 0;

    my $start_time = time;



    wait_for_monitor 1;



    doprint "run test $run_test\n";



 0;

    $SIG{CHLD} = qw(child_finished);



 fork;

    $full_line = "";



    do {

 wait_for_input($monitor_fp, 1);

 we are not guaranteed to get a full line

	    $full_line .= $line;

	    doprint $line;



~ /call trace:/i) {

		    $bug_ignored = 1;

		} else {

 1;

	    if ($full_line =~ /Kernel panic -/) {

 1;

	    if ($line =~ /\n/) {

 "";

	doprint "WARNING: Call Trace detected but ignored due to IGNORE_ERRORS=1\n";

    }



    if ($bug) {

 time;

	    $line = wait_for_input($monitor_fp, 1);

	    if (defined($line)) {

		doprint $line;

	    }

 time;

	    if ($now - $failure_start >= $stop_after_failure) {

		last;

	    }

	} while (defined($line));



	doprint "Detected kernel crash!\n";

	# kill the child with extreme prejudice

	kill 9, $child_pid;

    }



    waitpid $child_pid, 0;

 $? >> 8;

    my $end_time = time;

 $end_time - $start_time;

    my ($command) = @_;



    doprint "$command ... ";



 `$command 2>&1`;

    my $ret = $?;



    logit $output;



    if ($ret) {

	doprint "FAILED\n";

	dodie "Failed to git bisect";

    }



    doprint "SUCCESS\n";

~ m/^(Bisecting: .*\(roughly \d+ steps?\))\s+\[([[:xdigit:]]+)\]/) {

    } elsif ($output =~ m/^([[:xdigit:]]+) is the first bad commit/) {

 $1;

 we already logged it, just print it now.

 returns 1 on success, 0 on failure, -1 on skip

    my ($type, $buildtype) = @_;



 0;

    $in_bisect = 1;



 1;

	    $in_bisect = 0;

	    return -1;

	}

	dodie "Failed on build" if $failed;



	# Now boot the box

 1;

		$in_bisect = 0;

		return -1;

	    }

	    dodie "Failed on boot" if $failed;



 1;

	$result = 0;

    } else {

 1;

 reboot the box to a kernel we can ssh to

    $in_bisect = 0;



    return $result;

}



sub run_bisect {

 @_;

    my $buildtype = "oldconfig";



    # We should have a minconfig to use?

    if (defined($minconfig)) {

 "useconfig:$minconfig";

 If the user sets bisect_tries to less than 1, then no tries

 is a success.

    my $ret = 1;



    # Still let the user manually decide that though.

    if ($bisect_tries < 1 && $bisect_manual) {

 answer_bisect;

    for (my $i = 0; $i < $bisect_tries; $i++) {

	if ($bisect_tries > 1) {

 $i + 1;

	$ret = run_bisect_test $type, $buildtype;



	if ($bisect_manual) {

 answer_bisect;

 Are we looking for where it worked, not failed?

    if ($reverse_bisect && $ret >= 0) {

 !$ret;

    my $tmp_log = "$tmpdir/ktest_bisect_log";

    run_command "git bisect log > $tmp_log" or

	dodie "can't create bisect log";

    return $tmp_log;

}



sub bisect {

 @_;

    my $good = $bisect_good;

 $bisect_bad;

    my $type = $bisect_type;

 $bisect_start;

    my $replay = $bisect_replay;

 $bisect_files;

	$start_files = " -- " . $start_files;

    } else {

 "";

 convert to true sha1's

    $good = get_sha1($good);

 get_sha1($bad);

	$reverse_bisect = 1;

    } else {

 0;

 Can't have a test without having a test to run

	$type = "boot";

    }



    # Check if a bisect was running

 "$builddir/.git/BISECT_START";

    my $check = $bisect_check;

 defined($check) && $check ne "0";

		$replay = update_bisect_replay;

 0;

	    $replay = update_bisect_replay;

 0;

 get current HEAD

	my $head = get_sha1("HEAD");



	if ($check ne "good") {

	    doprint "TESTING BISECT BAD [$bad]\n";

	    run_command "git checkout $bad" or

		dodie "Failed to checkout $bad";



 run_bisect $type;

	    $result = run_bisect $type;



	    if ($result ne "good") {

		fail "Tested BISECT_GOOD [$good] and it failed" and return 0;

	    }

	}



	# checkout where we started

	run_command "git checkout $head" or

	    dodie "Failed to checkout $head";

    }



    run_command "git bisect start$start_files" or

	dodie "could not start bisect";



    if (defined($replay)) {

	run_command "git bisect replay $replay" or

	    dodie "failed to run replay";

    } else {

	run_command "git bisect good $good" or

	    dodie "could not set bisect good to $good";



	run_git_bisect "git bisect bad $bad" or

	    dodie "could not set bisect bad to $bad";

    }



    if (defined($start)) {

	run_command "git checkout $start" or

	    dodie "failed to checkout $start";

    }



    my $test;

    do {

 run_bisect $type;

	$test = run_git_bisect "git bisect $result";

	print_times;

    } while ($test);



    run_command "git bisect log" or

	dodie "could not capture git bisect log";



    run_command "git bisect reset" or

	dodie "could not reset git bisect";



    doprint "Bad commit was [$bisect_bad_commit]\n";



    success $i;

}



sub assign_configs {

 @_;

	if (/^((CONFIG\S*)=.*)/) {

 $1;

 (CONFIG\S*) is not set)/) {

	    ${$hash}{$2} = $1;

	}

    }



    close(IN);

}



sub process_config_ignore {

 @_;

    my ($config) = @_;



 $dependency{$config};

    my @deps = @{$arr};



    foreach my $dep (@{$arr}) {

	print "ADD DEP $dep\n";

 (@deps, get_dependencies $dep);

    my ($pc, $file) = @_;



 %{$pc};

    my ($name, $pc) = @_;



    doprint "Creating old config from $name configs\n";



    save_config $pc, $output_config;



    make_oldconfig;

}



sub run_config_bisect_test {

 @_;

    my $ret = run_bisect_test $type, "oldconfig";



    if ($bisect_manual) {

 answer_bisect;

    my ($good, $bad) = @_;

 "diff -u";

	$diffexec = "$builddir/scripts/diffconfig";

    }

    doprint "\n\n***************************************\n";

    doprint "No more config bisecting possible.\n";

    run_command "$diffexec $good $bad", 1;

    doprint "***************************************\n\n";

}



sub run_config_bisect {

 @_;

    my $reset = "";

    my $cmd;

    my $ret;



    if (!length($last_result)) {

 "-r";

 config-bisect returns:

   0 if there is more to bisect

   1 for finding a good config

   2 if it can not find any more configs

  -1 (255) on error

    $ret = run_config_bisect_test $config_bisect_type;

    if ($ret) {

	doprint "NEW GOOD CONFIG ($pass)\n";

	system("cp $output_config $tmpdir/good_config.tmp.$pass");

	$pass++;

	# Return 3 for good config

	return 3;

    } else {

	doprint "NEW BAD CONFIG ($pass)\n";

	system("cp $output_config $tmpdir/bad_config.tmp.$pass");

	$pass++;

	# Return 4 for bad config

	return 4;

    }

}



sub config_bisect {

 @_;

    my $type = $config_bisect_type;

    my $ret;



 $config_bisect;

	$good_config = $config_bisect_good;

    } elsif (defined($minconfig)) {

 $minconfig;

	$ret = run_bisect_test $type, "defconfig";

	if (!$ret) {

	    fail "Have no good config to compare with, please set CONFIG_BISECT_GOOD";

	    return 1;

	}

 $output_config;

 First check the location that ktest.pl ran

	my @locations = (

		"$pwd/config-bisect.pl",

		"$dirname/config-bisect.pl",

		"$builddir/tools/testing/ktest/config-bisect.pl",

		undef );

	foreach my $loc (@locations) {

 $loc\n";

	    $config_bisect_exec = $loc;

	    last if (defined($config_bisect_exec && -x $config_bisect_exec));

	}

	if (!defined($config_bisect_exec)) {

	    fail "Could not find an executable config-bisect.pl\n",

		"  Set CONFIG_BISECT_EXEC to point to config-bisect.pl";

	    return 1;

	}

    }



    # we don't want min configs to cause issues here.

    doprint "Disabling 'MIN_CONFIG' for this test\n";

    undef $minconfig;



    my %good_configs;

    my %bad_configs;

    my %tmp_configs;



    if (-f "$tmpdir/good_config.tmp" || -f "$tmpdir/bad_config.tmp") {

	if (read_yn "Interrupted config-bisect. Continue (n - will start new)?") {

	    if (-f "$tmpdir/good_config.tmp") {

 "$tmpdir/good_config.tmp";

		$good_config = "$tmpdir/good_config";

	    }

	    if (-f "$tmpdir/bad_config.tmp") {

 "$tmpdir/bad_config.tmp";

		$bad_config = "$tmpdir/bad_config";

	    }

	}

    }

    doprint "Run good configs through make oldconfig\n";

    assign_configs \%tmp_configs, $good_config;

    create_config "$good_config", \%tmp_configs;

 "$tmpdir/good_config";

    $bad_config = "$tmpdir/bad_config";

    system("cp $output_config $bad_config") == 0 or dodie "cp bad config";



    if (defined($config_bisect_check) && $config_bisect_check ne "0") {

	if ($config_bisect_check ne "good") {

	    doprint "Testing bad config\n";



 run_bisect_test $type, "useconfig:$bad_config";

	    $ret = run_bisect_test $type, "useconfig:$good_config";

	    if (!$ret) {

		fail "Good config failed when expected to succeed!";

		return 0;

	    }

	}

    }



 "";

	$ret = run_config_bisect $good_config, $bad_config, $last_run;

	if ($ret == 3) {

 "good";

	    $last_run = "bad";

	}

	print_times;

    } while ($ret == 3 || $ret == 4);



    if ($ret == 2) {

	config_bisect_end "$good_config.tmp", "$bad_config.tmp";

    }



    return $ret if ($ret < 0);



    success $i;

}



sub patchcheck_reboot {

    doprint "Reboot and sleep $patchcheck_sleep_time seconds\n";

    reboot_to_good $patchcheck_sleep_time;

}



sub patchcheck {

 @_;

    my $start = $patchcheck_start;



 $patchcheck_cherry;

	$cherry = 0;

    }



 "HEAD";

	$end = $patchcheck_end;

    } elsif ($cherry) {

	dodie "PATCHCHECK_END must be defined with PATCHCHECK_CHERRY\n";

    }



    # Get the true sha1's since we can use things like HEAD~3

 get_sha1($start);

    $end = get_sha1($end);



 $patchcheck_type;

 Can't have a test without having a test to run

	$type = "boot";

    }



    if ($cherry) {

	open (IN, "git cherry -v $start $end|") or

	    dodie "could not get git list";

    } else {

oneline $end|") or

 git cherry adds a '+' we want to remove

	$list[$#list+1] = $_;

	last if (/^$start/);

    }

    close(IN);



    if (!$cherry) {

	if ($list[$#list] !~ /^$start/) {

	    fail "SHA1 $start not found";

	}



	# go backwards in the list

 reverse @list;

    my $save_clean = $noclean;

    my %ignored_warnings;



    if (defined($ignore_warnings)) {

	foreach my $sha1 (split /\s+/, $ignore_warnings) {

 1;

    $in_patchcheck = 1;

    foreach my $item (@list) {

 $item;

	$sha1 =~ s/^([[:xdigit:]]+).*/$1/;



	doprint "\nProcessing commit \"$item\"\n\n";



	run_command "git checkout $sha1" or

	    dodie "Failed to checkout $sha1";



	# only clean on the first and last patch

	if ($item eq $list[0] ||

	    $item eq $list[$#list]) {

 $save_clean;

	    $noclean = 1;

	}



	if (defined($minconfig)) {

	    build "useconfig:$minconfig" or return 0;

	} else {

	    # ?? no config to use?

	    build "oldconfig" or return 0;

	}



	# No need to do per patch checking if warnings file exists

	if (!defined($warnings_file) && !defined($ignored_warnings{$sha1})) {

	    check_patch_buildlog $sha1 or return 0;

	}



	check_buildlog or return 0;



	next if ($type eq "build");



 0;

	start_monitor_and_install or $failed = 1;



	if (!$failed && $type ne "boot"){

 1;

    $in_patchcheck = 0;

    success $i;



    return 1;

}



sub add_dep {

    # $config depends on $dep

 @_;

	$depends{$config} .= " " . $dep;

    } else {

 $dep;

 record the number of configs depending on $dep

	$depcount{$dep} = 1;

    } 

}



# taken from streamline_config.pl

sub read_kconfig {

 @_;

    my $state = "NONE";

    my $config;

    my @kconfigs;



 0;

 Make sure that lines ending with \ continue

	    $_ = $line . " " . $_;

	}



	if (s/\\$//) {

 1;

	    $line = $_;

	    next;

	}



 0;

 collect any Kconfig sources

	    $kconfigs[$#kconfigs+1] = $1;

	}



	# configs found

	if (/^\s*(menu)?config\s+(\S+)\s*$/) {

 "NEW";

	    $config = $2;



 0; $i < $iflevel; $i++) {

 collect the depends for the config

 Get the configs that select this config

 selected by depends on config

 Check for if statements

	    my $deps = $1;

	    # remove beginning and ending non text

~ s/^[^a-zA-Z0-9_]*//;

	    $deps =~ s/[^a-zA-Z0-9_]*$//;



 split /[^a-zA-Z0-9_]+/, $deps;

	    $ifdeps[$iflevel++] = join ':', @deps;



	} elsif (/^endif/) {



	    $iflevel-- if ($iflevel);



	# stop on "help"

	} elsif (/^\s*help\s*$/) {

 "NONE";

 read in any configs that were found.

	    $read_kconfigs{$kconfig} = 1;

	    read_kconfig("$builddir/$kconfig");

	}

    }

}



sub read_depends {

    # find out which arch this is by the kconfig file

    open (IN, $output_config) or

	dodie "Failed to read $output_config";

    my $arch;

    while (<IN>) {

	if (m,Linux/(\S+)\s+\S+\s+Kernel Configuration,) {

 $1;

 arch is really the subarch, we need to know

 what directory to look at.

	$arch = "x86";

    }



 "$builddir/arch/$arch/Kconfig";

    if (! -f $kconfig && $arch =~ /\d$/) {

 $arch;

 some subarchs have numbers, truncate them

	$arch =~ s/\d*$//;

 "$builddir/arch/$arch/Kconfig";

    my @configs = @_;



    open (OUT, ">$output_config")

	or dodie "Failed to write $output_config";



    foreach my $config (@configs) {

	print OUT "$config\n";

    }

    close OUT;

}



sub chomp_config {

 @_;

    $config =~ s/CONFIG_//;



    return $config;

}



sub get_depends {

 @_;

    my $kconfig = chomp_config $dep;



 $depends{"$kconfig"};

 the dep string we have saves the dependencies as they

 were found, including expressions like ! && ||. We

 want to split this out into just an array of configs.

    my $valid = "A-Za-z_0-9";



    my @configs;



~ /[$valid]/) {

	if ($dep =~ /^[^$valid]*([$valid]+)/) {

 "CONFIG_" . $1;

	    $configs[$#configs + 1] = $conf;



~ s/^[^$valid]*[$valid]+//;

    my ($config) = @_;



    my $found;



    # if we already processed this config, skip it

    if (defined($processed_configs{$config})) {

	return undef;

    }

 1;

 if this config failed during this round, skip it

    my $kconfig = chomp_config $config;



    # Test dependencies first

    if (defined($depends{"$kconfig"})) {

 get_depends $config;

 if the parent is in the min config, check it first

	    $found = test_this_config($parent);

	    if (defined($found)) {

		return $found;

	    }

	}

    }



    # Remove this config from the list of configs

    # do a make olddefconfig and then read the resulting

    # .config to make sure it is missing the config that

    # we had before

 %min_configs;

    if (!defined($configs{$config}) || $configs{$config} =~ /^#/) {

	return $config;

    }



    doprint "disabling config $config did not change .config\n";



 1;

    my ($i) = @_;



 $minconfig_type;

 If output_minconfig exists, and the start_minconfig

 came from min_config, than ask if we should use

 that instead.

		$start_minconfig = $output_minconfig;

	    }

	} elsif ($use_output_minconfig > 0) {

	    doprint "Using $output_minconfig as MIN_CONFIG\n";

 $output_minconfig;

    my $temp_config = "$tmpdir/temp_config";



    # First things first. We build an allnoconfig to find

    # out what the defaults are that we can't touch.

    # Some are selections, but we really can't handle selections.



 $minconfig;

 make sure the file exists

    %keep_configs = %save_configs;



    doprint "Load initial configs from $start_minconfig\n";



    # Look at the current min configs, and save off all the

    # ones that were set via the allnoconfig

    assign_configs \%min_configs, $start_minconfig;



 keys %min_configs;

 All configs need a depcount

	my $kconfig = chomp_config $config;

	if (!defined $depcount{$kconfig}) {

 0;

 Remove anything that was set by the make allnoconfig

 we shouldn't need them as they get set for us anyway.

 Remove anything in the ignore_config

	    my $file = $ignore_config;

~ s,.*/(.*?)$,$1,;

 But make sure the settings are the same. If a min config

 sets a selection, we do not want to get rid of it if

 it is not the same as what we have. Just move it into

 the keep configs.

		$keep_configs{$config} = $min_configs{$config};

	    } else {

		doprint "$config set by allnoconfig ... ignored\n";

	    }

	    delete $min_configs{$config};

	}

    }



 0;

    my $take_two = 0;



    while (!$done) {

	my $config;

	my $found;



	# Now disable each config one by one and do a make oldconfig

	# till we find a config that changes our list.



 keys %min_configs;

 Sort keys by who is most dependent on

 sort  { $depcount{chomp_config($b)} <
 Put configs that did not modify the config at the end.

	my $reset = 1;

test_configs; $i++) {

		$reset = 0;

		last;

	    }

	    # This config didn't change the .config last time.

	    # Place it at the end

 shift @test_configs;

 if every test config has failed to modify the .config file

 in the past, then reset and start over.

	    $found = test_this_config $config;



	    last if (defined($found));



	    # oh well, try another config

	}



	if (!defined($found)) {

	    # we could have failed due to the nochange_config hash

	    # reset and try again

	    if (!$take_two) {

		undef %nochange_config;

 1;

	    $done = 1;

	    last;

	}

 0;

	$config = $found;



	doprint "Test with $config disabled\n";



	# set in_bisect to keep build and monitor from dieing

 1;

	my $failed = 0;

 1;

	    start_monitor_and_install or $failed = 1;



	    if ($type eq "test" && !$failed) {

 1;

	$in_bisect = 0;



	if ($failed) {

	    doprint "$min_configs{$config} is needed to boot the box... keeping\n";

	    # this config is needed, add it to the ignore list.

 $min_configs{$config};

	    $save_configs{$config} = $min_configs{$config};

	    delete $min_configs{$config};



	    # update new ignore configs

	    if (defined($ignore_config)) {

		open (OUT, ">$temp_config") or

		    dodie "Can't write to $temp_config";

		foreach my $config (keys %save_configs) {

		    print OUT "$save_configs{$config}\n";

		}

		close OUT;

		run_command "mv $temp_config $ignore_config" or

		    dodie "failed to copy update to $ignore_config";

	    }



	} else {

	    # We booted without this config, remove it from the minconfigs.

	    doprint "$config is not needed, disabling\n";



	    delete $min_configs{$config};



	    # Also disable anything that is not enabled in this config

	    my %configs;

	    assign_configs \%configs, $output_config;

 keys %min_configs;

 Save off all the current mandatory configs

    my ($i) = @_;



    if (!defined($warnings_file)) {

	dodie "Must define WARNINGS_FILE for make_warnings_file test";

    }



    if ($build_type eq "nobuild") {

	dodie "BUILD_TYPE can not be 'nobuild' for make_warnings_file test";

    }



    build $build_type or dodie "Failed to build";



    open(OUT, ">$warnings_file") or dodie "Can't create $warnings_file";



    open(IN, $buildlog) or dodie "Can't open $buildlog";

    while (<IN>) {

	# Some compilers use UTF-8 extended for quotes

	# for distcc heterogeneous systems, this causes issues

	s/$utf8_quote/'/g;



	if (/$check_build_re/) {

	    print OUT;

	}

    }

    close(IN);



    close(OUT);



    success $i;

}



sub option_defined {

 @_;

    my ($name, $i) = @_;



 "$name\[$i\]";

	if ($i >= $test &&

	    $i < $test + $repeat_tests{$test}) {

 "$name\[$test\]";

    my ($name, $i) = @_;



 __set_test_option($name, $i);

    my ($mailer) = @_;



 split /:/, $ENV{PATH};

 sendmail is usually in /usr/sbin

    $paths[$#paths + 1] = "/usr/sbin";



    foreach my $path (@paths) {

	if (-x "$path/$mailer") {

	    return $path;

	}

    }



    return undef;

}



sub do_send_mail {

 @_;

 find the mailer

	$mail_path = find_mailer $mailer;

	if (!defined($mail_path)) {

	    die "\nCan not find $mailer in PATH\n";

	}

    }



 "$tmpdir/header";

	    $mail_command = "cat \$HEADER_FILE \$BODY_FILE | \$MAIL_PATH/\$MAILER -s \'\$SUBJECT\' \$MAILTO";

	} elsif ($mailer eq "sendmail" ) {

  "cat \$HEADER_FILE \$BODY_FILE | \$MAIL_PATH/\$MAILER -t \$MAILTO";

	$mail_command =~ s/\$BODY_FILE/$file/g;

    } else {

~ s/\$BODY_FILE//g;

    $mail_command =~ s/\$HEADER_FILE/$header_file/g;

~ s/\$MAILER/$mailer/g;

    $mail_command =~ s/\$MAIL_PATH/$mail_path/g;

~ s/\$MAILTO/$mailto/g;

    $mail_command =~ s/\$SUBJECT/$subject/g;

~ s/\$MESSAGE/$message/g;

    my $ret = run_command $mail_command;

    if (!$ret && defined($file)) {

	# try again without the file

 "\n\n*** FAILED TO SEND LOG ***\n\n";

	my $name = get_test_name;

	send_email("KTEST: Your [$name] test was cancelled",

	    "Your test started at $script_start_time was cancelled: sig int");

    }

    die "\nCaught Sig Int, test interrupted: $!\n"

}



$#ARGV < 1 or die "ktest.pl version: $VERSION\n   usage: ktest.pl [config-file]\n";



if ($#ARGV == 0) {

 $ARGV[0];

    $newconfig = 1;

    get_test_case;

    open(OUT, ">$ktest_config") or die "Can not create $ktest_config";

    print OUT << "EOF"

# Generated by ktest.pl

#



# PWD is a ktest.pl variable that will result in the process working

# directory that ktest.pl is executed in.



# THIS_DIR is automatically assigned the PWD of the path that generated

# the config file. It is best to use this variable when assigning other

# directory paths within this directory. This allows you to easily

# move the test cases to other locations or to other machines.

#

 $variable{"PWD"}

 Define each test with TEST_START

 The config options below it will override the defaults

TEST_TYPE = $default{"TEST_TYPE"}



DEFAULTS

EOF

;

    close(OUT);

}

read_config $ktest_config;



if (defined($opt{"LOG_FILE"})) {

 eval_option("LOG_FILE", $opt{"LOG_FILE"}, -1);

 Append any configs entered in manually to the config file.

my @new_configs = keys %entered_configs;

new_configs >= 0) {

	print OUT "$config = $entered_configs{$config}\n";

 process_variables($entered_configs{$config});

 0, my $repeat  $opt{"NUM_TESTS"}; $i +
	    $repeat = $repeat_tests{$i};

	    doprint " ITERATE $repeat";

	}

	doprint "\n";

    }



    foreach my $option (sort keys %opt) {

~ /\[(\d+)\]$/) {

	    next if ($i != $1);

	} else {

	    next if ($i);

	}



 $opt{$option}\n";

$SIG{INT} = qw(cancel_test);



# First we need to do is the builds

for (my $i = 1; $i <= $opt{"NUM_TESTS"}; $i++) {



    # Do not reboot on failing test options

 1;

    $reboot_success = 0;



 0;

    $iteration = $i;



 0;

    $install_time = 0;

 0;

    $test_time = 0;



    undef %force_config;



 set_test_option("MAKE_CMD", $i);

    $outputdir = set_test_option("OUTPUT_DIR", $i);

 set_test_option("BUILD_DIR", $i);

 "$makecmd O
 Load all the options into their mapped variable names

	${$option_map{$opt}} = set_test_option($opt, $i);

    }



 1;

 The first test may override the PRE_KTEST option

	    my $name = get_test_name;

	    send_email("KTEST: Your [$name] test was started",

		"Your test was started on $script_start_time");

	}

    }



    # Any test can override the POST_KTEST option

    # The last test takes precedence.

    if (defined($post_ktest)) {

 $post_ktest;

	$start_minconfig_defined = 0;

 $minconfig;

    $ENV{"SSH_USER"} = $ssh_user;

 $machine;

    $buildlog = "$tmpdir/buildlog-$machine";

 "$tmpdir/testlog-$machine";

    $dmesg = "$tmpdir/dmesg-$machine";

 "$outputdir/.config";

	$target = "$ssh_user\@$machine";

	if (($reboot_type eq "grub") or ($reboot_type eq "grub2bls")) {

	    dodie "GRUB_MENU not defined" if (!defined($grub_menu));

	} elsif ($reboot_type eq "grub2") {

	    dodie "GRUB_MENU not defined" if (!defined($grub_menu));

	    dodie "GRUB_FILE not defined" if (!defined($grub_file));

	} elsif ($reboot_type eq "syslinux") {

	    dodie "SYSLINUX_LABEL not defined" if (!defined($syslinux_label));

	}

    }



 $build_type;

	$run_type = $patchcheck_type;

    } elsif ($test_type eq "bisect") {

 $bisect_type;

	$run_type = $config_bisect_type;

    } elsif ($test_type eq "make_min_config") {

 "";

	$run_type = "";

    }



    # mistake in config file?

    if (!defined($run_type)) {

 "ERROR";

    my $installme = "";

 " no_install" if ($no_install);

    my $name = "";



    if (defined($test_name)) {

 " ($test_name)";

	$test_log_start = tell(LOG);

    }



    doprint "RUNNING TEST $i of $opt{NUM_TESTS}$name with option $test_type $run_type$installme\n\n";



    if (defined($pre_test)) {

 run_command $pre_test;

	my $min = $minconfig;

	if (!defined($minconfig)) {

 "";

	$minconfig = "$tmpdir/add_config";

    }



    if (defined($checkout)) {

	run_command "git checkout $checkout" or

	    dodie "failed to checkout $checkout";

    }



 0;

 A test may opt to not reboot the box

	$reboot_success = 1;

    }



    if ($test_type eq "bisect") {

	bisect $i;

	next;

    } elsif ($test_type eq "config_bisect") {

	config_bisect $i;

	next;

    } elsif ($test_type eq "patchcheck") {

	patchcheck $i;

	next;

    } elsif ($test_type eq "make_min_config") {

	make_min_config $i;

	next;

    } elsif ($test_type eq "make_warnings_file") {

 1;

	my $failed = 0;

 1;

	    do_run_test or $failed = 1;

	}

	end_monitor;

	if ($failed) {

	    print_times;

	    next;

	}

    }



    print_times;



    success $i;

}



if (defined($final_post_ktest)) {



 eval_kernel_version $final_post_ktest;

 still need to get to the good kernel

 The following are here to standardize tabs/spaces/etc across the most likely editors



 Local Variables:

 mode: perl

 End:

# vim: softtabstop=4

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0

 hashes are now used

	/^\s*"?([A-Z].*?)"?\s*=>\s*/ ||

	/set_test_option\("(.*?)"/) {

 1;

    if (/^\s*#?\s*([A-Z]\S*)\s*=/) {

 1;

	print "opt = $opt\n";

    }

}



foreach $samp (keys %samp) {

    if (!defined($opt{$samp})) {

 $samp\n";

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0

 Prefix all lines with "
 to have unbuffering forced with "stdbuf -i0 -o0 -e0 $cmd".

my $needed = 1;

while (1) {

	my $char;

 sysread(STDIN, $char, 1);

 ";

		$needed = 0;

	}

	print $char;

 1 if ($char eq "\n");

 perf script event handlers, generated by perf script -g perl

 (c) 2009, Tom Zanussi <tzanussi@gmail.com>

 Licensed under the terms of the GNU GPL License version 2

 This script tests basic functionality such as flag and symbol

 strings, common_xxx() calls back into perf, begin, end, unhandled

 events, etc.  Basically, if this script runs successfully and

 displays expected results, perl scripting support should be ok.

	    $vec) = @_;



	print_header($event_name, $common_cpu, $common_secs, $common_nsecs,

		     $common_pid, $common_comm);



	print_uncommon($context);



%s\n",

	    $gfp_flags) = @_;



	print_header($event_name, $common_cpu, $common_secs, $common_nsecs,

		     $common_pid, $common_comm);



	print_uncommon($context);



	printf("call_site=%p, ptr=%p, bytes_req=%u, bytes_alloc=%u, ".

%s\n",

 print trace fields not included in handler args

    my ($context) = @_;



%d, common_flags%d, ",

	$common_pid, $common_comm, $common_callchain) = @_;



    $unhandled{$event_name}++;

}



sub print_header

{

 @_;

!/usr/bin/perl -w

 SPDX-License-Identifier: GPL-2.0-only

 (c) 2009, Tom Zanussi <tzanussi@gmail.com>

 Display r/w activity for files read/written to for a given program

 The common_* event handler fields are the most useful fields common to

 all events.  They don't necessarily correspond to the 'common_*' fields

 in the status files.  Those fields not available as handler params can

 be retrieved via script functions of the form get_common_*().

my $usage = "perf script -s rw-by-file.pl <comm>\n";



 shift or die $usage;

	$common_pid, $common_comm, $common_callchain, $nr, $fd, $buf, $count) = @_;



    if ($common_comm eq $for_comm) {

 $count;

	$common_pid, $common_comm, $common_callchain, $nr, $fd, $buf, $count) = @_;



    if ($common_comm eq $for_comm) {

 $count;

 reads", "bytes_requested");

    foreach my $fd (sort {$reads{$b}{bytes_requested} <=>

			      $reads{$a}{bytes_requested}} keys %reads) {

 $reads{$fd}{total_reads};

	my $bytes_requested = $reads{$fd}{bytes_requested};

	printf("%6u  %10u  %10u\n", $fd, $total_reads, $bytes_requested);

    }



    printf("\nfile write counts for $for_comm:\n\n");



    printf("%6s  %10s  %10s\n", "fd", "# writes", "bytes_written");

    printf("%6s  %10s  %10s\n", "------", "----------", "-----------");



>

	my $total_writes = $writes{$fd}{total_writes};

 $writes{$fd}{bytes_written};

	$common_pid, $common_comm, $common_callchain) = @_;



    $unhandled{$event_name}++;

}





!/usr/bin/perl -w

 SPDX-License-Identifier: GPL-2.0-only

 (c) 2010, Tom Zanussi <tzanussi@gmail.com>

 read/write top



 Periodically displays system-wide r/w call activity, broken down by

 pid.  If an [interval] arg is specified, the display will be

 refreshed every [interval] seconds.  The default interval is 3

 seconds.

my $default_interval = 3;

 20;

my $print_pending = 0;



my %reads;

my %writes;



 shift;

    $interval = $default_interval;

}



sub syscalls::sys_exit_read

{

    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,

	$common_pid, $common_comm, $common_callchain,

 @_;

	$reads{$common_pid}{bytes_read} += $ret;

    } else {

	if (!defined ($reads{$common_pid}{bytes_read})) {

 0;

	$nr, $fd, $buf, $count) = @_;



    print_check();



 $count;

    $reads{$common_pid}{comm} = $common_comm;

}



sub syscalls::sys_exit_write

{

    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,

	$common_pid, $common_comm, $common_callchain,

 @_;

    if ($ret <= 0) {

	$writes{$common_pid}{errors}{$ret}++;

    }

}



sub syscalls::sys_enter_write

{

    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,

	$common_pid, $common_comm, $common_callchain,

 @_;

    $writes{$common_pid}{bytes_written} += $count;

    $writes{$common_pid}{total_writes}++;

 $common_comm;

    my $sa = POSIX::SigAction->new(\&set_print_pending);

    $sa->flags(SA_RESTART);

    $sa->safe(1);

    POSIX::sigaction(SIGALRM, $sa) or die "Can't set SIGALRM handler: $!\n";

    alarm 1;

}



sub trace_end

{

    print_unhandled();

    print_totals();

}



sub print_check()

{

    if ($print_pending == 1) {

 0;

    $print_pending = 1;

    alarm $interval;

}



sub print_totals

{

    my $count;



 0;

 reads", "bytes_req", "bytes_read");

    foreach my $pid (sort { ($reads{$b}{bytes_read} || 0) <=>

			       ($reads{$a}{bytes_read} || 0) } keys %reads) {

 $reads{$pid}{comm} || "";

	my $total_reads = $reads{$pid}{total_reads} || 0;

 $reads{$pid}{bytes_requested} || 0;

	my $bytes_read = $reads{$pid}{bytes_read} || 0;



	printf("%6s  %-20s  %10s  %10s  %10s\n", $pid, $comm,

	       $total_reads, $bytes_requested, $bytes_read);



	if (++$count == $nlines) {

	    last;

	}

    }



 0;

 writes", "bytes_written");

    foreach my $pid (sort { ($writes{$b}{bytes_written} || 0) <=>

			($writes{$a}{bytes_written} || 0)} keys %writes) {

 $writes{$pid}{comm} || "";

	my $total_writes = $writes{$pid}{total_writes} || 0;

 $writes{$pid}{bytes_written} || 0;

    %reads = ();

 ();

	$common_pid, $common_comm, $common_callchain) = @_;



    $unhandled{$event_name}++;

}

!/usr/bin/perl -w

 SPDX-License-Identifier: GPL-2.0-only

 (c) 2009, Tom Zanussi <tzanussi@gmail.com>

 Display avg/min/max wakeup latency

 The common_* event handler fields are the most useful fields common to

 all events.  They don't necessarily correspond to the 'common_*' fields

 in the status files.  Those fields not available as handler params can

 be retrieved via script functions of the form get_common_*().

my $total_wakeup_latency = 0;

 0;

	$next_prio) = @_;



 $last_wakeup{$common_cpu}{ts};

	my $switch_ts = nsecs($common_secs, $common_nsecs);

 $switch_ts - $wakeup_ts;

	    $max_wakeup_latency = $wakeup_latency;

	}

	if ($wakeup_latency < $min_wakeup_latency) {

 $wakeup_latency;

	$total_wakeup_latency += $wakeup_latency;

	$total_wakeups++;

    }

 0;

	$comm, $pid, $prio, $success, $target_cpu) = @_;



 nsecs($common_secs, $common_nsecs);

    $min_wakeup_latency = 1000000000;

 0;

	$common_pid, $common_comm, $common_callchain) = @_;



    $unhandled{$event_name}++;

}

!/usr/bin/perl -w

 SPDX-License-Identifier: GPL-2.0-only

 (c) 2009, Tom Zanussi <tzanussi@gmail.com>

 Display r/w activity for all processes

 The common_* event handler fields are the most useful fields common to

 all events.  They don't necessarily correspond to the 'common_*' fields

 in the status files.  Those fields not available as handler params can

 be retrieved via script functions of the form get_common_*().

	$nr, $ret) = @_;



    if ($ret > 0) {

 $ret;

	    $reads{$common_pid}{bytes_read} = 0;

	}

	$reads{$common_pid}{errors}{$ret}++;

    }

}



sub syscalls::sys_enter_read

{

    my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,

	$common_pid, $common_comm, $common_callchain,

 @_;

    $reads{$common_pid}{bytes_requested} += $count;

    $reads{$common_pid}{total_reads}++;

 $common_comm;

	$nr, $ret) = @_;



 0) {

	$nr, $fd, $buf, $count) = @_;



 $count;

    $writes{$common_pid}{comm} = $common_comm;

}



sub trace_end

{

    printf("read counts by pid:\n\n");



    printf("%6s  %20s  %10s  %10s  %10s\n", "pid", "comm",

	   "# reads", "bytes_requested", "bytes_read");

    printf("%6s  %-20s  %10s  %10s  %10s\n", "------", "--------------------",

	   "-----------", "----------", "----------");



>

	my $comm = $reads{$pid}{comm} || "";

 $reads{$pid}{total_reads} || 0;

	my $bytes_requested = $reads{$pid}{bytes_requested} || 0;

 $reads{$pid}{bytes_read} || 0;

", "
    my @errcounts = ();



    foreach my $pid (keys %reads) {

	foreach my $error (keys %{$reads{$pid}{errors}}) {

 $reads{$pid}{comm} || "";

	    my $errcount = $reads{$pid}{errors}{$error} || 0;

	    push @errcounts, [$pid, $comm, $error, $errcount];

	}

    }



    @errcounts = sort { $b->[3] <=> $a->[3] } @errcounts;



    for my $i (0 .. $#errcounts) {

	printf("%6d  %-20s  %6d  %10s\n", $errcounts[$i][0],

	       $errcounts[$i][1], $errcounts[$i][2], $errcounts[$i][3]);

    }



    printf("\nwrite counts by pid:\n\n");



    printf("%6s  %20s  %10s  %10s\n", "pid", "comm",

	   "# writes", "bytes_written");

    printf("%6s  %-20s  %10s  %10s\n", "------", "--------------------",

	   "-----------", "----------");



>

	my $comm = $writes{$pid}{comm} || "";

 $writes{$pid}{total_writes} || 0;

	my $bytes_written = $writes{$pid}{bytes_written} || 0;



	printf("%6s  %-20s  %10s  %10s\n", $pid, $comm,

	       $total_writes, $bytes_written);

    }



    printf("\nfailed writes by pid:\n\n");



    printf("%6s  %20s  %6s  %10s\n", "pid", "comm", "error #", "# errors");

    printf("%6s  %20s  %6s  %10s\n", "------", "--------------------",

	   "------", "----------");



 ();

	    my $comm = $writes{$pid}{comm} || "";

 $writes{$pid}{errors}{$error} || 0;

 sort { $b->[3] <
errcounts) {

	$common_pid, $common_comm, $common_callchain) = @_;



    $unhandled{$event_name}++;

}

 failed system call counts

 (c) 2010, Tom Zanussi <tzanussi@gmail.com>

 Licensed under the terms of the GNU GPL License version 2



 Displays system-wide failed system call totals

 If a [comm] arg is specified, only syscalls called by [comm] are displayed.

my $for_comm = shift;



my %failed_syscalls;



sub raw_syscalls::sys_exit

{

	my ($event_name, $context, $common_cpu, $common_secs, $common_nsecs,

	    $common_pid, $common_comm, $common_callchain,

 @_;

 errors");

    foreach my $comm (sort {$failed_syscalls{$b} <=> $failed_syscalls{$a}}

		      keys %failed_syscalls) {

	next if ($for_comm && $comm ne $for_comm);



	printf("%-20s  %10s\n", $comm, $failed_syscalls{$comm});

    }

}

%option prefix="perf_pmu_"



%{

#include <stdlib.h>

#include <linux/bitops.h>

#include "pmu.h"

#include "pmu-bison.h"



static int value(int base)

{

	long num;



 0;

	num = strtoul(perf_pmu_text, NULL, base);

	if (errno)

		return PP_ERROR;



 num;

%option prefix="expr_"

%option reentrant

%option bison-bridge



%{

#include <linux/compiler.h>

#include "expr.h"

#include "expr-bison.h"

#include <math.h>



char *expr_get_text(yyscan_t yyscanner);

YYSTYPE *expr_get_lval(yyscan_t yyscanner);



static double __value(YYSTYPE *yylval, char *str, int token)

{

	double num;



 0;

	num = strtod(str, NULL);

	if (errno)

		return EXPR_ERROR;



 num;

	YYSTYPE *yylval = expr_get_lval(scanner);

 expr_get_text(scanner);

	char *ret = str;

 str;

			*dst++ = *++str;

		else if (*str == '?') {

			char *paramval;

 0;

			int size = asprintf(&paramval, "%d", runtime);



			if (size < 0)

 '0';

					*dst++ = paramval[i++];

				free(paramval);

			}

		}

		else

 *str;

	*dst = 0x0;

	return ret;

}



static int str(yyscan_t scanner, int token, int runtime)

{

 expr_get_lval(scanner);

	char *text = expr_get_text(scanner);



 normalize(strdup(text), runtime);

	yylval->str = normalize(yylval->str, runtime);

	return token;

}



static int literal(yyscan_t scanner)

{

 expr_get_lval(scanner);

	yylval->num = expr__get_literal(expr_get_text(scanner));

	if (isnan(yylval->num))

		return EXPR_ERROR;



	return LITERAL;

}

%}



number		([0-9]+\.?[0-9]*|[0-9]*\.?[0-9]+)



]

[0-9a-zA-Z_\.\-]+

	struct expr_scanner_ctx *sctx = expr_get_extra(yyscanner);



d_ratio		{ return D_RATIO; }

max		{ return MAX; }

min		{ return MIN; }

if		{ return IF; }

else		{ return ELSE; }

source_count	{ return SOURCE_COUNT; }

{literal}	{ return literal(yyscanner); }

{number}	{ return value(yyscanner); }

{symbol}	{ return str(yyscanner, ID, sctx->runtime); }

"|"		{ return '|'; }

"^"		{ return '^'; }

"&"		{ return '&'; }

"<"		{ return '<'; }

">"		{ return '>'; }

"-"		{ return '-'; }

"+"		{ return '+'; }

"*"		{ return '*'; }

"/"		{ return '/'; }

"%"		{ return '%'; }

"("		{ return '('; }

")"		{ return ')'; }

","		{ return ','; }

.		{ }

%%



int expr_wrap(void *scanner __maybe_unused)

{

	return 1;

}

%option prefix="parse_events_"

%option stack

%option bison-locations

%option yylineno

%option reject



%{

#include <errno.h>

#include <sys/types.h>

#include <sys/stat.h>

#include <unistd.h>

#include "parse-events.h"

#include "parse-events-bison.h"

#include "evsel.h"



char *parse_events_get_text(yyscan_t yyscanner);

YYSTYPE *parse_events_get_lval(yyscan_t yyscanner);



static int __value(YYSTYPE *yylval, char *str, int base, int token)

{

	u64 num;



 0;

	num = strtoull(str, NULL, base);

	if (errno)

		return PE_ERROR;



 num;

	YYSTYPE *yylval = parse_events_get_lval(scanner);

 parse_events_get_text(scanner);

	YYSTYPE *yylval = parse_events_get_lval(scanner);

 parse_events_get_text(scanner);

	if (text[0] != '\'') {

 strdup(text);

\'CPU_CLK_UNHALTED.THREAD:cmask
		yylval->str = strndup(&text[1], strlen(text) - 2);

	}



	return token;

}



static int raw(yyscan_t scanner)

{

 parse_events_get_lval(scanner);

	char *text = parse_events_get_text(scanner);



	if (perf_pmu__parse_check(text) == PMU_EVENT_SYMBOL)

		return str(scanner, PE_NAME);



	return __value(yylval, text + 1, 16, PE_RAW);

}



static bool isbpf_suffix(char *text)

{

 strlen(text);

	char *text = parse_events_get_text(scanner);

	struct stat st;



	if (!isbpf_suffix(text))

		return false;



	return stat(text, &st) == 0;

}



/*

 * This function is called when the parser gets two kind of input:

 *

config

 * The leading '@' is stripped off before 'cfg1' and 'cfg2=config' are given to

 * bison.  In the latter case it is necessary to keep the string intact so that

 * the PMU kernel driver can determine what configurable is associated to

 * 'config'.

 */

static int drv_str(yyscan_t scanner, int token)

{

 parse_events_get_lval(scanner);

	char *text = parse_events_get_text(scanner);



	/* Strip off the '@' */

 strdup(text + 1);

define REWIND(__alloc)				\

	YYSTYPE *__yylval = parse_events_get_lval(yyscanner);	\

 parse_events_get_text(yyscanner);		\

		__yylval->str = strdup(text);			\

								\

 strlen(text);				\

	YYSTYPE *yylval = parse_events_get_lval(scanner);

 parse_events_get_text(scanner);

	yylval->str = strdup(text);



	/*

	 * If we're not testing then parse check determines the PMU event type

	 * which if it isn't a PMU returns PE_NAME. When testing the result of

	 * parse check can't be trusted so we return PE_PMU_EVENT_FAKE unless

	 * an '!' is present in which case the text can't be a PMU name.

	 */

	switch (perf_pmu__parse_check(text)) {

		case PMU_EVENT_SYMBOL_PREFIX:

			return PE_PMU_EVENT_PRE;

		case PMU_EVENT_SYMBOL_SUFFIX:

			return PE_PMU_EVENT_SUF;

		case PMU_EVENT_SYMBOL:

			return parse_state->fake_pmu

				? PE_PMU_EVENT_FAKE : PE_KERNEL_PMU_EVENT;

		default:

			return parse_state->fake_pmu && !strchr(text,'!')

				? PE_PMU_EVENT_FAKE : PE_NAME;

	}

}



static int sym(yyscan_t scanner, int type, int config)

{

 parse_events_get_lval(scanner);

	yylval->num = (type << 16) + config;

	return type == PERF_TYPE_HARDWARE ? PE_VALUE_SYM_HW : PE_VALUE_SYM_SW;

}



static int tool(yyscan_t scanner, enum perf_tool_event event)

{

 parse_events_get_lval(scanner);

	yylval->num = event;

	return PE_VALUE_SYM_TOOL;

}



static int term(yyscan_t scanner, int type)

{

 parse_events_get_lval(scanner);

	yylval->num = type;

	return PE_TERM;

}



#define YY_USER_ACTION					\

do {							\

 yylloc->first_column;	\

	yylloc->first_column = yycolumn;		\

 yyleng;				\

define USER_REJECT		\

	yycolumn -= yyleng;	\

	REJECT



%}



%x mem

%s config

%x event

%x array



group		[^,{}/]*[{][^}]*[}][^,{}/]*

event_pmu	[^,{}/]+[/][^/]*[/][^,{}/]*

event		[^,{}/]+

bpf_object	[^,{}]+\.(o|bpf)[a-zA-Z0-9._]*

bpf_source	[^,{}]+\.c[a-zA-Z0-9._]*



num_dec		[0-9]+

num_hex		0x[a-fA-F0-9]+

num_raw_hex	[a-fA-F0-9]+

name		[a-zA-Z_*?\[\]][a-zA-Z0-9_*?.\[\]!]*

]*[\']

drv_cfg_term	[a-zA-Z0-9_\.]+(=[a-zA-Z0-9_*?\.:]+)?

/* If you add a modifier you need to update check_modifier() */

modifier_event	[ukhpPGHSDIWeb]+

modifier_bp	[rwx]{1,3}



%%



%{

 parse_events_get_extra(yyscanner);

		int start_token = _parse_state->stoken;



		if (start_token == PE_START_TERMS)

			BEGIN(config);

		else if (start_token == PE_START_EVENTS)

			BEGIN(event);



		if (start_token) {

 0;

			yycolumn = 0;

			return start_token;

		}

         }

%}



<event>{



{group}		{

			BEGIN(INITIAL);

			REWIND(0);

		}



{event_pmu}	|

{bpf_object}	|

{bpf_source}	|

{event}		{

			BEGIN(INITIAL);

			REWIND(1);

			return PE_EVENT_NAME;

		}



<<EOF>>		{

			BEGIN(INITIAL);

			REWIND(0);

		}

,		{

			return ',';

		}

}



<array>{

"]"			{ BEGIN(config); return ']'; }

{num_dec}		{ return value(yyscanner, 10); }

{num_hex}		{ return value(yyscanner, 16); }

,			{ return ','; }

"\.\.\."		{ return PE_ARRAY_RANGE; }

}



<config>{

	/*

	 * Please update config_term_names when new static term is added.

	 */

config			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_CONFIG); }

config1			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_CONFIG1); }

config2			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_CONFIG2); }

name			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_NAME); }

period			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_SAMPLE_PERIOD); }

freq			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_SAMPLE_FREQ); }

branch_type		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_BRANCH_SAMPLE_TYPE); }

time			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_TIME); }

call-graph		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_CALLGRAPH); }

stack-size		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_STACKSIZE); }

max-stack		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_MAX_STACK); }

nr			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_MAX_EVENTS); }

inherit			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_INHERIT); }

no-inherit		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_NOINHERIT); }

overwrite		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_OVERWRITE); }

no-overwrite		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_NOOVERWRITE); }

percore			{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_PERCORE); }

aux-output		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_AUX_OUTPUT); }

aux-sample-size		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_AUX_SAMPLE_SIZE); }

metric-id		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_METRIC_ID); }

r{num_raw_hex}		{ return raw(yyscanner); }

r0x{num_raw_hex}	{ return raw(yyscanner); }

,			{ return ','; }

"/"			{ BEGIN(INITIAL); return '/'; }

{name_minus}		{ return str(yyscanner, PE_NAME); }

\[all\]			{ return PE_ARRAY_ALL; }

"["			{ BEGIN(array); return '['; }

@{drv_cfg_term}		{ return drv_str(yyscanner, PE_DRV_CFG_TERM); }

}



<mem>{

{modifier_bp}		{ return str(yyscanner, PE_MODIFIER_BP); }

:			{ return ':'; }

"/"			{ return '/'; }

{num_dec}		{ return value(yyscanner, 10); }

{num_hex}		{ return value(yyscanner, 16); }

	/*

	 * We need to separate 'mem:' scanner part, in order to get specific

	 * modifier bits parsed out. Otherwise we would need to handle PE_NAME

	 * and we'd need to parse it manually. During the escape from <mem>

	 * state we need to put the escaping char back, so we dont miss it.

	 */

.			{ unput(*yytext); BEGIN(INITIAL); }

	/*

	 * We destroy the scanner after reaching EOF,

	 * but anyway just to be sure get back to INIT state.

	 */

<<EOF>>			{ BEGIN(INITIAL); }

}



cpu-cycles|cycles				{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_CPU_CYCLES); }

stalled-cycles-frontend|idle-cycles-frontend	{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_STALLED_CYCLES_FRONTEND); }

stalled-cycles-backend|idle-cycles-backend	{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_STALLED_CYCLES_BACKEND); }

instructions					{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_INSTRUCTIONS); }

cache-references				{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_CACHE_REFERENCES); }

cache-misses					{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_CACHE_MISSES); }

branch-instructions|branches			{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_BRANCH_INSTRUCTIONS); }

branch-misses					{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_BRANCH_MISSES); }

bus-cycles					{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_BUS_CYCLES); }

ref-cycles					{ return sym(yyscanner, PERF_TYPE_HARDWARE, PERF_COUNT_HW_REF_CPU_CYCLES); }

cpu-clock					{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_CPU_CLOCK); }

task-clock					{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_TASK_CLOCK); }

page-faults|faults				{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_PAGE_FAULTS); }

minor-faults					{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_PAGE_FAULTS_MIN); }

major-faults					{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_PAGE_FAULTS_MAJ); }

context-switches|cs				{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_CONTEXT_SWITCHES); }

cpu-migrations|migrations			{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_CPU_MIGRATIONS); }

alignment-faults				{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_ALIGNMENT_FAULTS); }

emulation-faults				{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_EMULATION_FAULTS); }

dummy						{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_DUMMY); }

duration_time					{ return tool(yyscanner, PERF_TOOL_DURATION_TIME); }

bpf-output					{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_BPF_OUTPUT); }

cgroup-switches					{ return sym(yyscanner, PERF_TYPE_SOFTWARE, PERF_COUNT_SW_CGROUP_SWITCHES); }



	/*

	 * We have to handle the kernel PMU event cycles-ct/cycles-t/mem-loads/mem-stores separately.

	 * Because the prefix cycles is mixed up with cpu-cycles.

	 * loads and stores are mixed up with cache event

	 */

cycles-ct				|

cycles-t				|

mem-loads				|

mem-loads-aux				|

mem-stores				|

topdown-[a-z-]+				|

tx-capacity-[a-z-]+			|

el-capacity-[a-z-]+			{ return str(yyscanner, PE_KERNEL_PMU_EVENT); }



L1-dcache|l1-d|l1d|L1-data		|

L1-icache|l1-i|l1i|L1-instruction	|

LLC|L2					|

dTLB|d-tlb|Data-TLB			|

iTLB|i-tlb|Instruction-TLB		|

branch|branches|bpu|btb|bpc		|

node					{ return str(yyscanner, PE_NAME_CACHE_TYPE); }



load|loads|read				|

store|stores|write			|

prefetch|prefetches			|

speculative-read|speculative-load	|

refs|Reference|ops|access		|

misses|miss				{ return str(yyscanner, PE_NAME_CACHE_OP_RESULT); }



mem:			{ BEGIN(mem); return PE_PREFIX_MEM; }

r{num_raw_hex}		{ return raw(yyscanner); }

{num_dec}		{ return value(yyscanner, 10); }

{num_hex}		{ return value(yyscanner, 16); }



{modifier_event}	{ return str(yyscanner, PE_MODIFIER_EVENT); }

{bpf_object}		{ if (!isbpf(yyscanner)) { USER_REJECT }; return str(yyscanner, PE_BPF_OBJECT); }

{bpf_source}		{ if (!isbpf(yyscanner)) { USER_REJECT }; return str(yyscanner, PE_BPF_SOURCE); }

{name}			{ return pmu_str_check(yyscanner, _parse_state); }

{name_tag}		{ return str(yyscanner, PE_NAME); }

"/"			{ BEGIN(config); return '/'; }

-			{ return '-'; }

,			{ BEGIN(event); return ','; }

:			{ return ':'; }

"{"			{ BEGIN(event); return '{'; }

"}"			{ return '}'; }

=			{ return '='; }

\n			{ }

.			{ }



%%



int parse_events_wrap(void *scanner __maybe_unused)

{

	return 1;

}

include <stdio.h>

include <stdint.h>

include <stdlib.h>

include <string.h>

include <linux/filter.h>

include "bpf_exp.yacc.h"

"?("len")	{ return K_PKT_LEN; }

"?("proto")	{

		yylval.number = SKF_AD_PROTOCOL;

		return extension;

	}

"#"?("type")	{

 SKF_AD_PKTTYPE;

"?("poff")	{

		yylval.number = SKF_AD_PAY_OFFSET;

		return extension;

	}

"#"?("ifidx")	{

 SKF_AD_IFINDEX;

"?("nla")	{

		yylval.number = SKF_AD_NLATTR;

		return extension;

	}

"#"?("nlan")	{

 SKF_AD_NLATTR_NEST;

"?("mark")	{

		yylval.number = SKF_AD_MARK;

		return extension;

	}

"#"?("queue")	{

 SKF_AD_QUEUE;

"?("hatype")	{

		yylval.number = SKF_AD_HATYPE;

		return extension;

	}

"#"?("rxhash")	{

 SKF_AD_RXHASH;

"?("cpu")	{

		yylval.number = SKF_AD_CPU;

		return extension;

	}

"#"?("vlan_tci") {

 SKF_AD_VLAN_TAG;

"?("vlan_pr")	{

		yylval.number = SKF_AD_VLAN_TAG_PRESENT;

		return extension;

	}

"#"?("vlan_avail") {

 SKF_AD_VLAN_TAG_PRESENT;

"?("vlan_tpid") {

		yylval.number = SKF_AD_VLAN_TPID;

		return extension;

	}

"#"?("rand")	{

 SKF_AD_RANDOM;

"		{ return '
			yylval.number = strtoul(yytext, NULL, 16);

			return number;

		}

([0][b][0-1]+)	{

 strtol(yytext + 2, NULL, 2);

			yylval.number = strtol(yytext, NULL, 10);

			return number;

		}

([0][0-7]+)	{

 strtol(yytext + 1, NULL, 8);

			yylval.label = strdup(yytext);

			return label;

		}



"/*"([^\*]|\*[^/])*"*/"		{ /* NOP */ }

";"[^\n]*			{ /* NOP */ }

^#.*				{ /* NOP */ }

[ \t]+				{ /* NOP */ }

[ \n]+				{ /* NOP */ }



.		{

			printf("unknown character \'%s\'", yytext);

			yyerror("lex unknown character");

		}



%%

! /usr/bin/perl -w

 SPDX-License-Identifier: GPL-2.0

 convert an Intel HEX file into a set of C records usable by the firmware

 loading code in usb-serial.c (or others)

 accepts the .hex file(s) on stdin, a basename (to name the initialized

 array) as an argument, and prints the .h file to stdout. Typical usage:

  perl ezusb_convert.pl foo <foo.hex >fw_foo.h

my $basename = $ARGV[0];

die "no base name specified" unless $basename;



while (<STDIN>) {

    # ':' <len> <addr> <type> <len-data> <crc> '\r'

    #  len, type, crc are 2-char hex, addr is 4-char hex. type is 00 for

    # normal records, 01 for EOF



    my($len) = hex($lenstring);

 hex($addrstring);

    my(@bytes) = unpack("C*", pack("H".(2*$len), $reststring));

    #pop(@bytes); # last byte is a CRC

    push(@records, [$addr, \@bytes]);

}



@sorted_records = sort { $a->[0] <=> $b->[0] } @records;



print <<"EOF";

/*

 * ${basename}_fw.h

 *

 * Generated from ${basename}.s by ezusb_convert.pl

 * This file is presumed to be under the same copyright as the source file

 * from which it was derived.

 */



EOF



 {\n";

!/usr/bin/perl -s

 SPDX-License-Identifier: GPL-2.0-or-later

 NCR 53c810 script assembler

 Sponsored by 

       iX Multiuser Multitasking Magazine



 Copyright 1993, Drew Eckhardt

      Visionary Computing 

      (Unix and Linux consulting and custom programming)

      drew@Colorado.EDU

      +1 (303) 786-7975 



   Support for 53c710 (via -ncr7x0_family switch) added by Richard

   Hirst <richard@sleepie.demon.co.uk> - 15th March 1997



 TolerANT and SCSI SCRIPTS are registered trademarks of NCR Corporation.



 

 Basically, I follow the NCR syntax documented in the NCR53c710 

 Programmer's guide, with the new instructions, registers, etc.

 from the NCR53c810.



 Differences between this assembler and NCR's are that 

 1.  PASS, REL (data, JUMPs work fine), and the option to start a new 

	script,  are unimplemented, since I didn't use them in my scripts.

 

 2.  I also emit a script_u.h file, which will undefine all of 

 	the A_*, E_*, etc. symbols defined in the script.  This 

	makes including multiple scripts in one program easier

 	

 3.  This is a single pass assembler, which only emits 

	.h files.



 XXX - set these with command line options

$debug = 0;		# Print general debugging messages

 Print external/forward reference messages

$list_in_array = 1;	# Emit original SCRIPTS assembler in comments in

			# script.h

#$prefix;		# (set by perl -s)

                        # define all arrays having this prefix so we 

			# don't have name space collisions after 

			# assembling this file in different ways for

			# different host adapters



# Constants





# Table of the SCSI phase encodings

 ( 			

 XXX - replace references to the *_810 constants with general constants

 assigned at compile time based on chip type.

 Table of operator encodings

 XXX - NCR53c710 only implements 

# 	move (nop) = 0x00_00_00_00

	or = 0x02_00_00_00

# 	and = 0x04_00_00_00

 	add = 0x06_00_00_00

  %operators = (

    '|', 0x02_00_00_00, 'OR', 0x02_00_00_00,

    '&', 0x04_00_00_00, 'AND', 0x04_00_00_00,

    '+', 0x06_00_00_00

  );

}

else {

 (

 Note : low bit of the operator bit should be set for add with 

 carry.

 Table of register addresses

  %registers = (

    'SCNTL0', 0, 'SCNTL1', 1, 'SDID', 2, 'SIEN', 3,

    'SCID', 4, 'SXFER', 5, 'SODL', 6, 'SOCL', 7,

    'SFBR', 8, 'SIDL', 9, 'SBDL', 10, 'SBCL', 11,

    'DSTAT', 12, 'SSTAT0', 13, 'SSTAT1', 14, 'SSTAT2', 15,

    'DSA0', 16, 'DSA1', 17, 'DSA2', 18, 'DSA3', 19,

    'CTEST0', 20, 'CTEST1', 21, 'CTEST2', 22, 'CTEST3', 23,

    'CTEST4', 24, 'CTEST5', 25, 'CTEST6', 26, 'CTEST7', 27,

    'TEMP0', 28, 'TEMP1', 29, 'TEMP2', 30, 'TEMP3', 31,

    'DFIFO', 32, 'ISTAT', 33, 'CTEST8', 34, 'LCRC', 35,

    'DBC0', 36, 'DBC1', 37, 'DBC2', 38, 'DCMD', 39,

    'DNAD0', 40, 'DNAD1', 41, 'DNAD2', 42, 'DNAD3', 43,

    'DSP0', 44, 'DSP1', 45, 'DSP2', 46, 'DSP3', 47,

    'DSPS0', 48, 'DSPS1', 49, 'DSPS2', 50, 'DSPS3', 51,

    'SCRATCH0', 52, 'SCRATCH1', 53, 'SCRATCH2', 54, 'SCRATCH3', 55,

    'DMODE', 56, 'DIEN', 57, 'DWT', 58, 'DCNTL', 59,

    'ADDER0', 60, 'ADDER1', 61, 'ADDER2', 62, 'ADDER3', 63,

  );

}

else {

 (

 Parsing regular expressions

$identifier = '[A-Za-z_][A-Za-z_0-9]*';		

 '-?\\d+';

$hexnum = '0[xX][0-9A-Fa-f]+';		

 "$hexnum|$decnum";

 yucky - since we can't control grouping of 
 expand out each alternative for $value.

$value = "$identifier|$identifier\\s*[+\-]\\s*$decnum|".

    "$identifier\\s*[+-]\s*$hexnum|$constant";



 $value\n" if ($debug);

$phase = join ('|', keys %scsi_phases);

 $phase\n" if ($debug);

$register = join ('|', keys %registers);



# yucky - since %operators includes meta-characters which must

# be escaped, I can't use the join() trick I used for the register

# regex



if ($ncr7x0_family) {

 '\||OR|AND|\&|\+';

  $operator = '\||OR|AND|XOR|\&|\+';

}



# Global variables



 Traditional symbol table

%symbol_references = () ;		# Table of symbol references, where

					# the index is the symbol name, 

					# and the contents a white space 

					# delimited list of address,size

					# tuples where size is in bytes.



 Array of 32 bit words for SIOP 

@entry = ();				# Array of entry point names



 Array of label names

@absolute = ();				# Array of absolute names



 Array of relative names

@external = ();				# Array of external names



 Address of current instruction

$lineno = 0;				# Line number we are parsing



 Output file

$outputu = 'scriptu.h';



# &patch ($address, $offset, $length, $value) patches $code[$address]

# 	so that the $length bytes at $offset have $value added to

# 	them.  



 (0x00_00_00_00, 0x00_00_00_ff, 0x00_00_ff_ff, 0x00_ff_ff_ff, 

    local ($address, $offset, $length, $value) = @_;

    if ($debug) {

	print STDERR "Patching $address at offset $offset, length $length to $value\n";

	printf STDERR "Old code : %08x\n", $code[$address];

     }



 ($inverted_masks[$length] << ($offset * 8));

    $code[$address] = ($code[$address] & ~$mask) | 

	(($code[$address] & $mask) + ($value << ($offset * 8)) & 

	$mask);

    

    printf STDERR "New code : %08x\n", $code[$address] if ($debug);

}



# &parse_value($value, $word, $offset, $length) where $value is 

# 	an identifier or constant, $word is the word offset relative to 

#	$address, $offset is the starting byte within that word, and 

#	$length is the length of the field in bytes.

#

# Side effects are that the bytes are combined into the @code array

#	relative to $address, and that the %symbol_references table is 

# 	updated as appropriate.



sub parse_value {

 @_;

    $symbol = '';



~ /^REL\s*\(\s*($identifier)\s*\)\s*(.*)/i) {

	$relative = 'REL';

 $1;

	$value = $2;

print STDERR "Relative reference $symbol\n" if ($debug);

~ /^($identifier)\s*(.*)/) {

	$relative = 'ABS';

 $1;

	$value = $2;

print STDERR "Absolute reference $symbol\n" if ($debug);

    } 



    if ($symbol ne '') {

 $length in $_\n" if ($debug);

     	$tmp = ($address + $word) * 4 + $offset;

	if ($symbol_references{$symbol} ne undef) {

 

		$forward{$symbol} = "line $lineno : $_";

	    } 

 "$relative,$tmp,$length";

    $value = eval $value;

    &patch ($address + $word, $offset, $length, $value);

}



# &parse_conditional ($conditional) where $conditional is the conditional

# clause from a transfer control instruction (RETURN, CALL, JUMP, INT).



sub parse_conditional {

 @_;

    if ($conditional =~ /^\s*(IF|WHEN)\s*(.*)/i) {

 $1;

	$conditional = $2;

~ /WHEN/i) {

	    $allow_atn = 0;

 0x00_01_00_00;

	    $allow_atn = 0;

	    print STDERR "$0 : parsed WHEN\n" if ($debug);

	} else {

 1;

    if ($conditional =~ /^NOT\s+(.*)$/i) {

 'NOT ';

	$other = 'OR';

 $1;

	$code[$address] |= 0x00_08_00_00;

 '';

	$other = 'AND'

    }



 0;

    if ($conditional =~ /^ATN\s*(.*)/i) {#

	die "$0 : syntax error in line $lineno : $_

	WHEN conditional is incompatible with ATN 

" if (!$allow_atn);

 0x00_02_00_00;

	$conditional = $1;

	print STDERR "$0 : parsed ATN\n" if ($debug);

~ /^($phase)\s*(.*)/i) {

	$phase_index = "\U$1\E";

 $scsi_phases{$phase_index};

	$code[$address] |= $p | 0x00_02_00_00;

 $2;

	$other = '';

 1;

    if ($conditional =~ /^(AND|OR)\s*(.*)/i) {

 $1;

	$conditional = $2;

 1;

	if ($conditional=~ /^($value)\s*(.*)/i) {

 0x00_04_00_00;

	    $conditional = $2;

	    &parse_value($1, 0, 0, 1);

	    print STDERR "$0 : parsed data\n" if ($debug);

	} else {

	die "$0 : syntax error in line $lineno : $_

	expected <data>.

";

	}

    }



~ /^\s*,\s*(.*)/) {

	$conditional = $1;

~ /^AND\s\s*MASK\s\s*($value)\s*(.*)/i) {

 Parse command line

$output = shift;

 shift;

 Main loop

    $lineno = $lineno + 1;

 $list[$address].$_;

 Strip comments

 Leave new line out of error messages

 Handle symbol definitions of the form label:

	    $symbol_values{$1} = $address * 4;	# Address is an index into

	    delete $forward{$1};		# an array of longs

	    push (@label, $1);

 $2;

# Handle symbol definitions of the form ABSOLUTE or RELATIVE identifier = 

# value

    if (/^\s*(ABSOLUTE|RELATIVE)\s+(.*)/i) {

 $1;

	$rest = $2;

	foreach $rest (split (/\s*,\s*/, $rest)) {

	    if ($rest =~ /^($identifier)\s*=\s*($constant)\s*$/) {

 ($1, $2);

		    $symbol_values{$id} = eval $cnst;

		    delete $forward{$id};

~ /ABSOLUTE/i) {

	    expected <identifier> = <value>

";

	    }

	}

    } elsif (/^\s*EXTERNAL\s+(.*)/i) {

 $1;

	    if ($external =~ /\s*($identifier)\s*$/) {

 $1;

		$symbol_values{$external} = $external;

print STDERR "defined external $1 to $external\n" if ($debug_external);

	    } else {

		die 

"$0 : syntax error in line $lineno : $_

	expected <identifier>, got $external

";

	    }

	}

# Process ENTRY identifier declarations

    } elsif (/^\s*ENTRY\s+(.*)/i) {

~ /^($identifier)\s*$/) {

 Process MOVE length, address, WITH|WHEN phase instruction

	$rest = $1;

~ /^FROM\s+($value)\s*,\s*(WITH|WHEN)\s+($phase)\s*$/i) {

	    $transfer_addr = $1;

 $2;

	    $scsi_phase = $3;

print STDERR "Parsing MOVE FROM $transfer_addr, $with_when $3\n" if ($debug);

	    $code[$address] = 0x18_00_00_00 | (($with_when =~ /WITH/i) ? 

		0x00_00_00_00 : 0x08_00_00_00) | $scsi_phases{$scsi_phase};

	    &parse_value ($transfer_addr, 1, 0, 4);

 2;

	} elsif ($rest =~ /^($value)\s*,\s*(PTR\s+|)($value)\s*,\s*(WITH|WHEN)\s+($phase)\s*$/i) {

 $1;

	    $ptr = $2;

 $3;

	    $with_when = $4;

 $5;

 (($with_when 
		0x08_00_00_00)  | (($ptr =~ /PTR/i) ? (1 << 29) : 0) | 

		$scsi_phases{$scsi_phase};

	    &parse_value ($transfer_len, 0, 0, 3);

	    &parse_value ($transfer_addr, 1, 0, 4);

 2;

	} elsif ($rest =~ /^MEMORY\s+(.*)/i) {

 $1;

	    $code[$address] = 0xc0_00_00_00; 

~ /^($value)\s*,\s*($value)\s*,\s*($value)\s*$/) {

		$count = $1;

 $2;

		$dest =  $3;

print STDERR "Parsing MOVE MEMORY $count, $source, $dest\n" if ($debug);

		&parse_value ($count, 0, 0, 3);

		&parse_value ($source, 1, 0, 4);

		&parse_value ($dest, 2, 0, 4);

 %08x,%08x,%08x\n", 

		$address += 3;

	

	    } else {

		die 

"$0 : syntax error in line $lineno : $_

	expected <count>, <source>, <destination>

"

	    }

~ /^(.*)\s+(TO|SHL|SHR)\s+(.*)/i) {

	    $src = $1;

 "\U$2\E";

	    $rest = $3;



 0x40_00_00_00;

	    $force = ($op !~ /TO/i); 





print STDERR "Forcing register source \n" if ($force && $debug);



~ 

		$src_reg = "\U$1\E";

 "\U$2\E";

		    $data8 = $3;

		} else {

		    die "- is not implemented yet.\n"

		}

~ /^($register)\s*$/i) {

		$src_reg = "\U$1\E";

		# Encode register to register move as a register | 0 

		# move to register.

		if (!$force) {

 '|';

		$data8 = 0;

~ /^($value)\s*$/i) {

		$src_reg = undef;

 'NONE';

		$data8 = $1;

	    } else {

		if (!$force) {

		    die 

"$0 : syntax error in line $lineno : $_

	expected <register>

		<data8>

		<register> <operand> <data8>

";

		} else {

		    die

"$0 : syntax error in line $lineno : $_

	expected <register>

";

		}

	    }

~ /^($register)\s*(.*)$/i) {

		$dst_reg = "\U$1\E";

 $2;

	    if ($rest =~ /^WITH\s+CARRY\s*(.*)/i) {

 $1;

		    $code[$address] |= 0x01_00_00_00;

		} else {

		    die

"$0 : syntax error in $lineno : $_

	WITH CARRY option is incompatible with the $op operator.

";

		}

	    }



	    if ($rest !~ /^\s*$/) {

		die

"$0 : syntax error in $lineno : $_

	Expected end of line, got $rest

";

	    }



 $src_reg, data  $dst_reg\n"

 Note that Move data8 to reg is encoded as a read-modify-write

 instruction.

		$code[$address] |= 0x38_00_00_00 | 

		    ($registers{$dst_reg} << 16);

~ /SFBR/i) {

		$code[$address] |= 0x30_00_00_00 |

		    ($registers{$src_reg} << 16);

~ /SFBR/i) {

		$code[$address] |= 0x28_00_00_00 |

		    ($registers{$dst_reg} << 16);

	    } else {

		die

"$0 : Illegal combination of registers in line $lineno : $_

	Either source and destination registers must be the same,

	or either source or destination register must be SFBR.

";

	    }



 $operators{$op};

	    $code[$address] |= $operators{$op};

 Reserved

	    $address += 2;

	} else {

	    die 

"$0 : syntax error in line $lineno : $_

	expected (initiator) <length>, <address>, WHEN <phase>

		 (target) <length>, <address>, WITH <phase>

		 MEMORY <length>, <source>, <destination>

		 <expression> TO <register>

";

	}

# Process SELECT {ATN|} id, fail_address

    } elsif (/^\s*(SELECT|RESELECT)\s+(.*)/i) {

 $2;

	if ($rest =~ /^(ATN|)\s*($value)\s*,\s*($identifier)\s*$/i) {

 $1;

	    $id = $2;

 $3;

	    $code[$address] = 0x40_00_00_00 | 

~ /ATN/i) ? 0x01_00_00_00 : 0);

	    $code[$address + 1] = 0x00_00_00_00;

	    &parse_value($id, 0, 2, 1);

	    &parse_value($alt_addr, 1, 0, 4);

 2;

	} elsif ($rest =~ /^(ATN|)\s*FROM\s+($value)\s*,\s*($identifier)\s*$/i) {

 $1;

	    $addr = $2;

 $3;

	    $code[$address] = 0x42_00_00_00 | 

~ /ATN/i) ? 0x01_00_00_00 : 0);

	    $code[$address + 1] = 0x00_00_00_00;

	    &parse_value($addr, 0, 0, 3);

	    &parse_value($alt_addr, 1, 0, 4);

 2;

	    $rest = $1;

print STDERR "Parsing WAIT $rest\n" if ($debug);

~ /^DISCONNECT\s*$/i) {

	    $code[$address] = 0x48_00_00_00;

 0x00_00_00_00;

	    $address += 2;

~ /^(RESELECT|SELECT)\s+($identifier)\s*$/i) {

	    $alt_addr = $2;

 0x50_00_00_00;

	    $address += 2;

	} else {

	    die

"$0 : syntax error in line $lineno : $_

	expected (initiator) WAIT DISCONNECT or 

		 (initiator) WAIT RESELECT alternate_address or

		 (target) WAIT SELECT alternate_address

";

	}

# Handle SET and CLEAR instructions.  Note that we should also do something

# with this syntax to set target mode.

    } elsif (/^\s*(SET|CLEAR)\s+(.*)/i) {

 $1;

	$list = $2;

	$code[$address] = ($set =~ /SET/i) ?  0x58_00_00_00 : 

	    0x60_00_00_00;

	foreach $arg (split (/\s+AND\s+/i,$list)) {

~ /ATN/i) {

		$code[$address] |= 0x00_00_00_08;

~ /ACK/i) {

		$code[$address] |= 0x00_00_00_40;

~ /TARGET/i) {

		$code[$address] |= 0x00_00_02_00;

~ /CARRY/i) {

		$code[$address] |= 0x00_00_04_00;

	    } else {

		die 

"$0 : syntax error in line $lineno : $_

	expected $set followed by a AND delimited list of one or 

	more strings from the list ACK, ATN, CARRY, TARGET.

";

	    }

	}

 0x00_00_00_00;

	$address += 2;

    } elsif (/^\s*(JUMP|CALL|INT)\s+(.*)/i) {

 $1;

	$rest = $2;

~ /JUMP/i) {

	    $code[$address] = 0x80_00_00_00;

~ /CALL/i) {

	    $code[$address] = 0x88_00_00_00;

	} else {

 0x98_00_00_00;

print STDERR "parsing JUMP, rest = $rest\n" if ($debug);



# Relative jump. 

~ /^(REL\s*\(\s*$identifier\s*\))\s*(.*)/i) { 

	    $addr = $1;

 $2;

 $addr, rest 
	    $code[$address]  |= 0x00_80_00_00;

	    &parse_value($addr, 1, 0, 4);

# Absolute jump, requires no more gunk

~ /^($value)\s*(.*)/) {

	    $addr = $1;

 $2;

	if ($rest =~ /^,\s*(.*)/) {

	    &parse_conditional($1);

~ /^\s*$/) {

	    $code[$address] |= (1 << 19);

	} else {

	    die

"$0 : syntax error in line $lineno : $_

	expected , <conditional> or end of line, got $1

";

	}

	

 2;

	$instruction = $1;

 $2; 

 ($instruction 
	if ($conditional =~ /^,\s*(.*)/) {

 $1;

	    $code[$address] |= 0x00_08_00_00;

	}

	   

 0x00_00_00_00;

	$address += 2;

    } elsif (/^\s*DISCONNECT\s*$/) {

 0x48_00_00_00;

	$code[$address + 1] = 0x00_00_00_00;

 2;

 I'm not sure that I should be including this extension, but 

 what the hell?

	$code[$address] = 0x80_88_00_00;

 0x00_00_00_00;

	$address += 2;

# Ignore lines consisting entirely of white space

    } elsif (/^\s*$/) {

    } else {

	die 

"$0 : syntax error in line $lineno: $_

	expected label:, ABSOLUTE, CLEAR, DISCONNECT, EXTERNAL, MOVE, RESELECT,

	    SELECT SET, or WAIT

";

    }

}



# Fill in label references



 keys %forward;

if ($#undefined >= 0) {

    print STDERR "Undefined symbols : \n";

    foreach $undef (@undefined) {

	print STDERR "$undef in $forward{$undef}\n";

    }

    exit 1;

}



 ();

@external_patches = ();



 sort @absolute;

	$j =~ /(REL|ABS),(.*),(.*)/;

 $1;

	$address = $2;

 $3;

	    $reference =~ /(REL|ABS),(.*),(.*)/;

 $1;

	    $address = $2;

 $3;

0) || ($length !
	    $symbol = $symbol_values{$external};

 $code[$address / 4];

		$code[$address / 4] = $symbol;

	    } else {

 sprintf ("0x%08x", $add);

		$code[$address / 4] = "$symbol + $add";

	    }

		

print STDERR "referenced external $external at $1\n" if ($debug_external);

	}

    }

}



foreach $label (@label) {

    if ($symbol_references{$label} ne undef) {

	for $reference (split(/\s+/,$symbol_references{$label})) {

~ /(REL|ABS),(.*),(.*)/;

	    $type = $1;

 $2;

	    $length = $3;



	    if ((($address % 4) !=0) || ($length != 4)) {

		die "$0 : symbol $label has invalid reference at $1, size $2\n";

	    }



	    if ($type eq 'ABS') {

 $symbol_values{$label};

 

 - The address of the reference should be in the second and last word

	of an instruction

 - Relative jumps, etc. are relative to the DSP of the _next_ instruction



 So, we need to add four to the address of the reference, to get 

 the address of the next instruction, when computing the reference.

		$tmp = $symbol_values{$label} - 

		    ($address + 4);

		die 

# Relative addressing is limited to 24 bits.

"$0 : symbol $label is too far ($tmp) from $address to reference as 

 0x80_00_00) || ($tmp < -0x80_00_00));

		$code[$address / 4] = $tmp & 0x00_ff_ff_ff;

	    }

	}

    }

}



# Output SCRIPT[] array, one instruction per line.  Optionally 

# print the original code too.



open (OUTPUT, ">$output") || die "$0 : can't open $output for writing\n";

open (OUTPUTU, ">$outputu") || die "$0 : can't open $outputu for writing\n";



($_ = $0) =~ s:.*/::;

print OUTPUT "/* DO NOT EDIT - Generated automatically by ".$_." */\n";

 {\n";

$instructions = 0;

code; ) {

    printf STDERR "Address $i = %x\n", $code[$i] if ($debug);

~ /\s*($identifier)(.*)$/) {

	if ($code[$i + 2] =~ /$identifier/) {

	    push (@external_patches, $i+2, $code[$i+2]);

	    printf OUTPUT "0,\n";

	} else {

	    printf OUTPUT "0x%08x,\n",$code[$i+2];

	}

 3;

	$i += 2;

    }

 1;

define A_$i\t0x%08x\n", $symbol_values{$i};

define A_".$i."_used ".$prefix."A_".$i."_used\n";

undef A_".$i."_used\n";

undef A_$i\n";

    printf OUTPUT "static u32 A_".$i."_used\[\] __attribute((unused)) = {\n";

printf STDERR "$i is used $symbol_references{$i}\n" if ($debug);

    foreach $j (split (/\s+/,$symbol_references{$i})) {

~ /(ABS|REL),(.*),(.*)/;

	    $address = $2;

 $3;

define Ent_$i\t0x%08x\n", $symbol_values{$i};

undef Ent_$i\n", $symbol_values{$i};



 NCR assembler outputs label patches in the form of indices into 

 the code.



printf OUTPUT "static u32 ".$prefix."LABELPATCHES[] __attribute((unused)) = {\n";

> $b} @label_patches) {

$num_external_patches = 0;

printf OUTPUT "static struct {\n\tu32\toffset;\n\tvoid\t\t*address;\n".

 {\n";

while ($ident = pop(@external_patches)) {

 pop(@external_patches);

printf OUTPUT "static u32 ".$prefix."INSTRUCTIONS __attribute((unused))\t= %d;\n", 

    $instructions;

 %d;\n", 

label_patches+1;

printf OUTPUT "static u32 ".$prefix."EXTERNAL_PATCHES_LEN __attribute((unused))\t= %d;\n",

    $num_external_patches;

close OUTPUT;

close OUTPUTU;

20 $

include <sys/types.h>

include <inttypes.h>

include <limits.h>

include <regex.h>

include <stdio.h>

include <string.h>

include <sysexits.h>

include "../queue.h"

include "aicasm.h"

include "aicasm_symbol.h"

include "aicasm_gram.h"

define MAX_STR_CONST 4096

				string_buf_ptr = string_buf;

 1;

<CEXPR>\(		{	*string_buf_ptr++ = '('; parren_count++; }

<CEXPR>\)		{

				parren_count--;

				if (parren_count == 0) {

					/* All done */

					BEGIN INITIAL;

 '\0';

					yylval.sym = symtable_get(string_buf);

					return T_CEXPR;

				} else {

 ')';

				yptr = yytext;

 '\0') {

						*yptr = ' ';

					if (*yptr == ' '

 string_buf

						*string_buf_ptr++ = *yptr++;

				}

			}

else			{ return T_ELSE; }

VERSION			{ return T_VERSION; }

PREFIX			{ return T_PREFIX; }

PATCH_ARG_LIST		{ return T_PATCH_ARG_LIST; }

\"			{

 string_buf;

				yptr = yytext;

				while (*yptr)

 *yptr++;

				*string_buf_ptr = '\0';

 string_buf;

const			{ yylval.value = FALSE; return T_CONST; }

download		{ return T_DOWNLOAD; }

address			{ return T_ADDRESS; }

count			{ return T_COUNT; }

access_mode		{ return T_ACCESS_MODE; }

dont_generate_debug_code { return T_DONT_GENERATE_DEBUG_CODE; }

modes			{ return T_MODES; }

RW|RO|WO		{

				 if (strcmp(yytext, "RW") == 0)

 RW;

					yylval.value = RO;

				 else

 WO;

[-+,:()~|&."{};<>[\]/*!=] { return yytext[0]; }



	/* Number processing */

0[0-7]*			{

 strtol(yytext, NULL, 8);

				yylval.value = strtoul(yytext + 2, NULL, 16);

				return T_NUMBER;

			}



[1-9][0-9]*		{

 strtol(yytext, NULL, 10);

include{SPACE}		{

				quote_count = 0;

				return T_INCLUDE;

			}

<INCLUDE>[<]		{ return yytext[0]; }

<INCLUDE>[>]		{ BEGIN INITIAL; return yytext[0]; }

<INCLUDE>[\"]		{

 0)

				yptr = yytext;

 string_buf;

					*string_buf_ptr++ = *yptr++;

 string_buf;

				*string_buf_ptr = '\0';

				return T_PATH;

			}

<INCLUDE>.		{ stop("Invalid include line", EX_DATAERR); }

#define{SPACE}		{

				BEGIN MACRODEF;

				return T_DEFINE;

			}

<MACRODEF>{WORD}{SPACE}	{ 

				char *yptr;



				/* Strip space and return as a normal symbol */

 yytext;

 ' ' && *yptr !
				*yptr = '\0';

 symtable_get(yytext);

				string_buf_ptr = string_buf;

				BEGIN MACROBODY;

				return T_SYMBOL;

			}

<MACRODEF>{WORD}\(	{

				/*

				 * We store the symbol with its opening

				 * parren so we can differentiate macros

				 * that take args from macros with the

				 * same name that do not take args as

				 * is allowed in C.

				 */

				BEGIN MACROARGLIST;

 symtable_get(yytext);

				yylval.str = yytext;

				return T_ARG;

			}

<MACROARGLIST>{SPACE}   ;

<MACROARGLIST>[(,]	{

				return yytext[0];

			}

<MACROARGLIST>[)]	{

 string_buf;

				*string_buf_ptr++ = '(';

			}

<MACROCALLARGS>\)	{

				parren_count--;

				if (parren_count == 0) {

					BEGIN INITIAL;

					return (')');

				}

 ')';

				yptr = yytext;

				while (*yptr)

 *yptr++;

				if (string_buf_ptr != string_buf) {

					/*

					 * Return an argument and

					 * rescan this comma so we

					 * can return it as well.

					 */

 '\0';

					yylval.str = string_buf;

 string_buf;

				*string_buf_ptr = '\0';

 string_buf;

				yptr = yytext;

 *yptr++) {

					*string_buf_ptr++ = c;

				}

			}

{WORD}\(		{

				char *yptr;

				char *ycopy;



				/* May be a symbol or a macro invocation. */

 symtable_get(yytext);

					ycopy = strdup(yytext);

 ycopy + yyleng;

					old_state = YY_CURRENT_BUFFER;



						yytext[yyleng-1] = '\0';



				yylval.sym = symtable_get(yytext);

				if (yylval.sym->type == MACRO) {

					expand_macro(yylval.sym);

				} else {

					return T_SYMBOL;

				}

			}

.			{ 

				snprintf(buf, sizeof(buf), "Invalid character "

					 "'%c'", yytext[0]);

				stop(buf, EX_DATAERR);

			}

%%



typedef struct include {

        YY_BUFFER_STATE  buffer;

        int              lineno;

        char            *filename;

	SLIST_ENTRY(include) links;

}include_t;



SLIST_HEAD(, include) include_stack;



void

include_file(char *file_name, include_type type)

{

	FILE *newfile;

	include_t *include;



 NULL;

	if (includes_search_curdir != 0 || type == SOURCE_FILE)

 fopen(file_name, "r");

	if (newfile == NULL && type != SOURCE_FILE) {

                path_entry_t include_dir;

 search_path.slh_first;

                     include_dir != NULL;                

 include_dir->links.sle_next) {

			 && (type != QUOTED_INCLUDE))

				continue;



			snprintf(fullname, sizeof(fullname),

				 "%s/%s", include_dir->directory, file_name);



			if ((newfile = fopen(fullname, "r")) != NULL)

				break;

                }

        }



	if (newfile == NULL) {

		perror(file_name);

		stop("Unable to open input file", EX_SOFTWARE);

		/* NOTREACHED */

	}



 SOURCE_FILE) {

		include = (include_t *)malloc(sizeof(include_t));

		if (include == NULL) {

			stop("Unable to allocate include stack entry",

			     EX_SOFTWARE);

			/* NOTREACHED */

		}

 YY_CURRENT_BUFFER;

		include->lineno = yylineno;

 yyfilename;

	yylineno = 1;

 strdup(file_name);

	body_head = macro_symbol->info.macroinfo->body;

 body_head + strlen(body_head);

		next_match = body_head;

 NULL;

		if (match_marg != NULL) {

			const char *strp;



 match_marg->replacement_text;

			strp = next_match + strlen(next_match);

			while (strp > next_match)

				unput(*--strp);



			/* Skip past the unexpanded macro arg. */

 match.rm_eo - match.rm_so;

		search_pos = *next_match;



		STAILQ_FOREACH(marg, &mac_symbol->info.macroinfo->args, links) {



 regexec(&marg->arg_regex, search_pos, 2,

			 && (matches[1].rm_eo + search_pos) <= body_pos

			 && (matches[1].rm_eo + search_pos) > *next_match) {

 matches[1];

				*next_match = match->rm_eo + search_pos;

 marg;

	} while (search_pos != *next_match);

}



int

yywrap()

{

	include_t *include;



	yy_delete_buffer(YY_CURRENT_BUFFER);

	(void)fclose(yyin);

 NULL)

	yyfilename = NULL;

 include_stack.slh_first;

	if (include != NULL) {

		yy_switch_to_buffer(include->buffer);

 include->lineno;

		yyfilename = include->filename;

		SLIST_REMOVE_HEAD(&include_stack, links);

		free(include);

		return (0);

	}

	return (1);

}

8 $

include <sys/types.h>

include <inttypes.h>

include <limits.h>

include <regex.h>

include <stdio.h>

include <string.h>

include <sysexits.h>

include "../queue.h"

include "aicasm.h"

include "aicasm_symbol.h"

include "aicasm_macro_gram.h"

define MAX_STR_CONST 4096

					string_buf_ptr = string_buf;

					return ('(');

				}

 '(';

					if (string_buf_ptr != string_buf) {

						/*

						 * Return an argument and

						 * rescan this parren so we

						 * can return it as well.

						 */

 '\0';

						mmlval.str = string_buf;

 string_buf;

				*string_buf_ptr++ = ')';

			}

<ARGLIST>{MCARG}	{

				char *yptr;



 mmtext;

					*string_buf_ptr++ = *yptr++;

			}

<ARGLIST>\,		{

 string_buf) {

					*string_buf_ptr = '\0';

 string_buf;

					string_buf_ptr = string_buf;

					unput(',');

					return T_ARG;

				}

				return ',';

			}

{WORD}[(]		{

				/* May be a symbol or a macro invocation. */

 symtable_get(mmtext);

				if (mmlval.sym->type != MACRO) {

					stop("Expecting Macro Name",

					     EX_DATAERR);

				}

				unput('(');

 0;

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0

 This code is taken from the OpenSSL project but the author (Andy Polyakov)

 has relicensed it under the GPLv2. Therefore this program is free software;

 you can redistribute it and/or modify it under the terms of the GNU General

 Public License version 2 as published by the Free Software Foundation.



 The original headers, including the original license headers, are

 included below for completeness.

 ====================================================================


 Written by Andy Polyakov <appro@openssl.org> for the OpenSSL

 project. The module is, however, dual licensed under OpenSSL and

 CRYPTOGAMS licenses depending on where you obtain it. For further

 details see https://www.openssl.org/~appro/cryptogams/.

 ====================================================================




 GHASH for for PowerISA v2.07.



 July 2014



 Accurate performance measurements are problematic, because it's

 always virtualized setup with possibly throttled processor.

 Relative comparison is therefore more informative. This initial

 version is ~2.1x slower than hardware-assisted AES-128-CTR, ~12x

 faster than "4-bit" integer-only compiler-generated 64-bit code.

 "Initial version" means that there is room for futher improvement.

$flavour=shift;

shift;

if ($flavour =~ /64/) {

8;

	$LRSAVE=2*$SIZE_T;

"stdu";

	$POP="ld";

"std";

} elsif ($flavour =~ /32/) {

4;

	$LRSAVE=$SIZE_T;

"stwu";

	$POP="lwz";

"stw";

~ m/(.*[\/\\])[^\/\\]+$/; $dir
( $xlate="${dir}ppc-xlate.pl" and -f $xlate ) or

"${dir}../../perlasm/ppc-xlate.pl" and -f $xlate) or

my ($Xip,$Htbl,$inp,$len)=map("r$_",(3..6));	# argument block



map("v$_",(0..3));

my ($zero,$t0,$t1,$t2,$xC2,$H,$Hh,$Hl,$lemask)=map("v$_",(4..12));

"r12";

$code=<<___;

.machine	"any"



.text



.globl	.gcm_init_p8

	lis		r0,0xfff0

	li		r8,0x10

	mfspr		$vrsave,256

	li		r9,0x20

	mtspr		256,r0

	li		r10,0x30

	lvx_u		$H,0,r4			# load H

	le?xor		r7,r7,r7

	le?addi		r7,r7,0x8		# need a vperm start with 08

	le?lvsr		5,0,r7

	le?vspltisb	6,0x0f

	le?vxor		5,5,6			# set a b-endian mask

	le?vperm	$H,$H,$H,5



	vspltisb	$xC2,-16		# 0xf0

	vspltisb	$t0,1			# one

	vaddubm		$xC2,$xC2,$xC2		# 0xe0

	vxor		$zero,$zero,$zero

	vor		$xC2,$xC2,$t0		# 0xe1

	vsldoi		$xC2,$xC2,$zero,15	# 0xe1...

	vsldoi		$t1,$zero,$t0,1		# ...1

	vaddubm		$xC2,$xC2,$xC2		# 0xc2...

	vspltisb	$t2,7

	vor		$xC2,$xC2,$t1		# 0xc2....01

	vspltb		$t1,$H,0		# most significant byte

 H<<=1

 broadcast carry bit

 twisted H

 twist even more ...

 0xc2.0

 ... and split

 save pre-computed table

 load Xi

 load pre-computed table

 H.loXi.lo

 H.hiXi.lo+H.loXi.hi

 H.hiXi.hi

 1st phase

 2nd phase

 write out Xi

 load Xi

 load pre-computed table

 H.loXi.lo

 borrow?-1:0

 H.hiXi.lo+H.loXi.hi

 H.hiXi.hi

 1st phase

 2nd phase

	beq		Loop			# did $len-=16 borrow?



	vxor		$Xl,$Xl,$t1

	le?vperm	$Xl,$Xl,$Xl,$lemask

	stvx_u		$Xl,0,$Xip		# write out Xi



	mtspr		256,$vrsave

	blr

	.long		0

	.byte		0,12,0x14,0,0,0,4,0

	.long		0

.size	.gcm_ghash_p8,.-.gcm_ghash_p8



.asciz  "GHASH for PowerISA 2.07, CRYPTOGAMS by <appro\@openssl.org>"

.align  2

___



foreach (split("\n",$code)) {

 little-endian

be
le
 enforce flush

! /usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0

 This code is taken from CRYPTOGAMs[1] and is included here using the option

 in the license to distribute the code under the GPL. Therefore this program

 is free software; you can redistribute it and/or modify it under the terms of

 the GNU General Public License version 2 as published by the Free Software

 Foundation.



 [1] https://www.openssl.org/~appro/cryptogams/

 Copyright (c) 2006-2017, CRYPTOGAMS by <appro@openssl.org>

 All rights reserved.



 Redistribution and use in source and binary forms, with or without

 modification, are permitted provided that the following conditions

 are met:



       * Redistributions of source code must retain copyright notices,

         this list of conditions and the following disclaimer.



       * Redistributions in binary form must reproduce the above

         copyright notice, this list of conditions and the following

         disclaimer in the documentation and/or other materials

         provided with the distribution.



       * Neither the name of the CRYPTOGAMS nor the names of its

         copyright holder and contributors may be used to endorse or

         promote products derived from this software without specific

         prior written permission.



 ALTERNATIVELY, provided that this notice is retained in full, this

 product may be distributed under the terms of the GNU General Public

 License (GPL), in which case the provisions of the GPL apply INSTEAD OF

 those given above.



 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS

 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR

 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,

 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT

 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 ====================================================================


 Written by Andy Polyakov <appro@openssl.org> for the OpenSSL

 project. The module is, however, dual licensed under OpenSSL and

 CRYPTOGAMS licenses depending on where you obtain it. For further

 details see https://www.openssl.org/~appro/cryptogams/.

 ====================================================================




 This module implements support for AES instructions as per PowerISA

 specification version 2.07, first implemented by POWER8 processor.

 The module is endian-agnostic in sense that it supports both big-

 and little-endian cases. Data alignment in parallelizable modes is

 handled with VSX loads and stores, which implies MSR.VSX flag being

 set. It should also be noted that ISA specification doesn't prohibit

 alignment exceptions for these instructions on page boundaries.

 Initially alignment was handled in pure AltiVec/VMX way [when data

 is aligned programmatically, which in turn guarantees exception-

 free execution], but it turned to hamper performance when vcipher

 instructions are interleaved. It's reckoned that eventual

 misalignment penalties at page boundaries are in average lower

 than additional overhead in pure AltiVec approach.



 May 2016



 Add XTS subroutine, 9x on little- and 12x improvement on big-endian

 systems were measured.



 Current large-block performance in cycles per byte processed with

 128-bit key (less is better).



		CBC en-/decrypt	CTR	XTS

 POWER8[le]	3.96/0.72	0.74	1.1

 POWER8[be]	3.75/0.65	0.66	1.0

$flavour = shift;



~ /64/) {

	$SIZE_T	=8;

2*$SIZE_T;

	$STU	="stdu";

"ld";

	$PUSH	="std";

"cmpld";

	$SHL	="sldi";

~ /32/) {

	$SIZE_T	=4;

$SIZE_T;

	$STU	="stwu";

"lwz";

	$PUSH	="stw";

"cmplw";

	$SHL	="slwi";

} else { die "nonsense $flavour"; }



$LITTLE_ENDIAN = ($flavour=~/le$/) ? $SIZE_T : 0;



$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;

"${dir}ppc-xlate.pl" and -f $xlate ) or

( $xlate="${dir}../../perlasm/ppc-xlate.pl" and -f $xlate) or

die "can't locate ppc-xlate.pl";



open STDOUT,"| $^X $xlate $flavour ".shift || die "can't call $xlate: $!";



8*$SIZE_T;

$prefix="aes_p8";



"r1";

$vrsave="r12";



#########################################################################

{{{	# Key setup procedures						#

map("r$_",(3..8));

my ($zero,$in0,$in1,$key,$rcon,$mask,$tmp)=map("v$_",(0..6));

map("v$_",(7..11));

$code.=<<___;

.machine	"any"



.text



.align	7

rcon:

.long	0x01000000, 0x01000000, 0x01000000, 0x01000000	?rev

.long	0x1b000000, 0x1b000000, 0x1b000000, 0x1b000000	?rev

.long	0x0d0e0f0c, 0x0d0e0f0c, 0x0d0e0f0c, 0x0d0e0f0c	?rev

.long	0,0,0,0						?asis

Lconsts:

	mflr	r0

	bcl	20,31,\$+4

	mflr	$ptr	 #vvvvv "distance between . and rcon

	addi	$ptr,$ptr,-0x48

	mtlr	r0

	blr

	.long	0

	.byte	0,12,0x14,0,0,0,0,0

.asciz	"AES for PowerISA 2.07, CRYPTOGAMS by <appro\@openssl.org>"



.globl	.${prefix}_set_encrypt_key

Lset_encrypt_key:

	mflr		r11

	$PUSH		r11,$LRSAVE($sp)



	li		$ptr,-1

	${UCMP}i	$inp,0

	beq-		Lenc_key_abort		# if ($inp==0) return -1;

	${UCMP}i	$out,0

	beq-		Lenc_key_abort		# if ($out==0) return -1;

	li		$ptr,-2

	cmpwi		$bits,128

	blt-		Lenc_key_abort

	cmpwi		$bits,256

	bgt-		Lenc_key_abort

	andi.		r0,$bits,0x3f

	bne-		Lenc_key_abort



	lis		r0,0xfff0

	mfspr		$vrsave,256

	mtspr		256,r0



	bl		Lconsts

	mtlr		r11



	neg		r9,$inp

	lvx		$in0,0,$inp

	addi		$inp,$inp,15		# 15 is not typo

	lvsr		$key,0,r9		# borrow $key

	li		r8,0x20

	cmpwi		$bits,192

	lvx		$in1,0,$inp

	le?vspltisb	$mask,0x0f		# borrow $mask

	lvx		$rcon,0,$ptr

	le?vxor		$key,$key,$mask		# adjust for byte swap

	lvx		$mask,r8,$ptr

	addi		$ptr,$ptr,0x10

	vperm		$in0,$in0,$in1,$key	# align [and byte swap in LE]

	li		$cnt,8

	vxor		$zero,$zero,$zero

	mtctr		$cnt



	?lvsr		$outperm,0,$out

	vspltisb	$outmask,-1

	lvx		$outhead,0,$out

	?vperm		$outmask,$zero,$outmask,$outperm



	blt		Loop128

	addi		$inp,$inp,8

	beq		L192

	addi		$inp,$inp,8

	b		L256



.align	4

Loop128:

	vperm		$key,$in0,$in0,$mask	# rotate-n-splat

	vsldoi		$tmp,$zero,$in0,12	# >>32

	 vperm		$outtail,$in0,$in0,$outperm	# rotate

	 vsel		$stage,$outhead,$outtail,$outmask

	 vmr		$outhead,$outtail

	vcipherlast	$key,$key,$rcon

	 stvx		$stage,0,$out

	 addi		$out,$out,16



	vxor		$in0,$in0,$tmp

	vsldoi		$tmp,$zero,$tmp,12	# >>32

	vxor		$in0,$in0,$tmp

	vsldoi		$tmp,$zero,$tmp,12	# >>32

	vxor		$in0,$in0,$tmp

	 vadduwm	$rcon,$rcon,$rcon

	vxor		$in0,$in0,$key

	bdnz		Loop128



	lvx		$rcon,0,$ptr		# last two round keys



	vperm		$key,$in0,$in0,$mask	# rotate-n-splat

	vsldoi		$tmp,$zero,$in0,12	# >>32

	 vperm		$outtail,$in0,$in0,$outperm	# rotate

	 vsel		$stage,$outhead,$outtail,$outmask

	 vmr		$outhead,$outtail

	vcipherlast	$key,$key,$rcon

	 stvx		$stage,0,$out

	 addi		$out,$out,16



	vxor		$in0,$in0,$tmp

	vsldoi		$tmp,$zero,$tmp,12	# >>32

	vxor		$in0,$in0,$tmp

	vsldoi		$tmp,$zero,$tmp,12	# >>32

	vxor		$in0,$in0,$tmp

	 vadduwm	$rcon,$rcon,$rcon

	vxor		$in0,$in0,$key



	vperm		$key,$in0,$in0,$mask	# rotate-n-splat

	vsldoi		$tmp,$zero,$in0,12	# >>32

	 vperm		$outtail,$in0,$in0,$outperm	# rotate

	 vsel		$stage,$outhead,$outtail,$outmask

	 vmr		$outhead,$outtail

	vcipherlast	$key,$key,$rcon

	 stvx		$stage,0,$out

	 addi		$out,$out,16



	vxor		$in0,$in0,$tmp

	vsldoi		$tmp,$zero,$tmp,12	# >>32

	vxor		$in0,$in0,$tmp

	vsldoi		$tmp,$zero,$tmp,12	# >>32

	vxor		$in0,$in0,$tmp

	vxor		$in0,$in0,$key

	 vperm		$outtail,$in0,$in0,$outperm	# rotate

	 vsel		$stage,$outhead,$outtail,$outmask

	 vmr		$outhead,$outtail

	 stvx		$stage,0,$out



	addi		$inp,$out,15		# 15 is not typo

	addi		$out,$out,0x50



	li		$rounds,10

	b		Ldone



.align	4

L192:

	lvx		$tmp,0,$inp

	li		$cnt,4

	 vperm		$outtail,$in0,$in0,$outperm	# rotate

	 vsel		$stage,$outhead,$outtail,$outmask

	 vmr		$outhead,$outtail

	 stvx		$stage,0,$out

	 addi		$out,$out,16

	vperm		$in1,$in1,$tmp,$key	# align [and byte swap in LE]

	vspltisb	$key,8			# borrow $key

	mtctr		$cnt

	vsububm		$mask,$mask,$key	# adjust the mask



Loop192:

	vperm		$key,$in1,$in1,$mask	# roate-n-splat

	vsldoi		$tmp,$zero,$in0,12	# >>32

	vcipherlast	$key,$key,$rcon



	vxor		$in0,$in0,$tmp

	vsldoi		$tmp,$zero,$tmp,12	# >>32

	vxor		$in0,$in0,$tmp

	vsldoi		$tmp,$zero,$tmp,12	# >>32

	vxor		$in0,$in0,$tmp



	 vsldoi		$stage,$zero,$in1,8

	vspltw		$tmp,$in0,3

	vxor		$tmp,$tmp,$in1

	vsldoi		$in1,$zero,$in1,12	# >>32

	 vadduwm	$rcon,$rcon,$rcon

	vxor		$in1,$in1,$tmp

	vxor		$in0,$in0,$key

	vxor		$in1,$in1,$key

	 vsldoi		$stage,$stage,$in0,8



	vperm		$key,$in1,$in1,$mask	# rotate-n-splat

	vsldoi		$tmp,$zero,$in0,12	# >>32

	 vperm		$outtail,$stage,$stage,$outperm	# rotate

	 vsel		$stage,$outhead,$outtail,$outmask

	 vmr		$outhead,$outtail

	vcipherlast	$key,$key,$rcon

	 stvx		$stage,0,$out

	 addi		$out,$out,16



	 vsldoi		$stage,$in0,$in1,8

	vxor		$in0,$in0,$tmp

	vsldoi		$tmp,$zero,$tmp,12	# >>32

	 vperm		$outtail,$stage,$stage,$outperm	# rotate

	 vsel		$stage,$outhead,$outtail,$outmask

	 vmr		$outhead,$outtail

	vxor		$in0,$in0,$tmp

	vsldoi		$tmp,$zero,$tmp,12	# >>32

	vxor		$in0,$in0,$tmp

	 stvx		$stage,0,$out

	 addi		$out,$out,16



	vspltw		$tmp,$in0,3

	vxor		$tmp,$tmp,$in1

	vsldoi		$in1,$zero,$in1,12	# >>32

	 vadduwm	$rcon,$rcon,$rcon

	vxor		$in1,$in1,$tmp

	vxor		$in0,$in0,$key

	vxor		$in1,$in1,$key

	 vperm		$outtail,$in0,$in0,$outperm	# rotate

	 vsel		$stage,$outhead,$outtail,$outmask

	 vmr		$outhead,$outtail

	 stvx		$stage,0,$out

	 addi		$inp,$out,15		# 15 is not typo

	 addi		$out,$out,16

	bdnz		Loop192



	li		$rounds,12

	addi		$out,$out,0x20

	b		Ldone



.align	4

L256:

	lvx		$tmp,0,$inp

	li		$cnt,7

	li		$rounds,14

	 vperm		$outtail,$in0,$in0,$outperm	# rotate

	 vsel		$stage,$outhead,$outtail,$outmask

	 vmr		$outhead,$outtail

	 stvx		$stage,0,$out

	 addi		$out,$out,16

	vperm		$in1,$in1,$tmp,$key	# align [and byte swap in LE]

	mtctr		$cnt



Loop256:

	vperm		$key,$in1,$in1,$mask	# rotate-n-splat

	vsldoi		$tmp,$zero,$in0,12	# >>32

	 vperm		$outtail,$in1,$in1,$outperm	# rotate

	 vsel		$stage,$outhead,$outtail,$outmask

	 vmr		$outhead,$outtail

	vcipherlast	$key,$key,$rcon

	 stvx		$stage,0,$out

	 addi		$out,$out,16



	vxor		$in0,$in0,$tmp

	vsldoi		$tmp,$zero,$tmp,12	# >>32

	vxor		$in0,$in0,$tmp

	vsldoi		$tmp,$zero,$tmp,12	# >>32

	vxor		$in0,$in0,$tmp

	 vadduwm	$rcon,$rcon,$rcon

	vxor		$in0,$in0,$key

	 vperm		$outtail,$in0,$in0,$outperm	# rotate

	 vsel		$stage,$outhead,$outtail,$outmask

	 vmr		$outhead,$outtail

	 stvx		$stage,0,$out

	 addi		$inp,$out,15		# 15 is not typo

	 addi		$out,$out,16

	bdz		Ldone



	vspltw		$key,$in0,3		# just splat

	vsldoi		$tmp,$zero,$in1,12	# >>32

	vsbox		$key,$key



	vxor		$in1,$in1,$tmp

	vsldoi		$tmp,$zero,$tmp,12	# >>32

	vxor		$in1,$in1,$tmp

	vsldoi		$tmp,$zero,$tmp,12	# >>32

	vxor		$in1,$in1,$tmp



	vxor		$in1,$in1,$key

	b		Loop256



.align	4

Ldone:

	lvx		$in1,0,$inp		# redundant in aligned case

	vsel		$in1,$outhead,$in1,$outmask

	stvx		$in1,0,$inp

	li		$ptr,0

	mtspr		256,$vrsave

	stw		$rounds,0($out)



Lenc_key_abort:

	mr		r3,$ptr

	blr

	.long		0

	.byte		0,12,0x14,1,0,0,3,0

	.long		0

.size	.${prefix}_set_encrypt_key,.-.${prefix}_set_encrypt_key



.globl	.${prefix}_set_decrypt_key

	$STU		$sp,-$FRAME($sp)

	mflr		r10

	$PUSH		r10,$FRAME+$LRSAVE($sp)

	bl		Lset_encrypt_key

	mtlr		r10



	cmpwi		r3,0

	bne-		Ldec_key_abort



	slwi		$cnt,$rounds,4

	subi		$inp,$out,240		# first round key

	srwi		$rounds,$rounds,1

	add		$out,$inp,$cnt		# last round key

	mtctr		$rounds



Ldeckey:

	lwz		r0, 0($inp)

	lwz		r6, 4($inp)

	lwz		r7, 8($inp)

	lwz		r8, 12($inp)

	addi		$inp,$inp,16

	lwz		r9, 0($out)

	lwz		r10,4($out)

	lwz		r11,8($out)

	lwz		r12,12($out)

	stw		r0, 0($out)

	stw		r6, 4($out)

	stw		r7, 8($out)

	stw		r8, 12($out)

	subi		$out,$out,16

	stw		r9, -16($inp)

	stw		r10,-12($inp)

	stw		r11,-8($inp)

	stw		r12,-4($inp)

	bdnz		Ldeckey



	xor		r3,r3,r3		# return value

Ldec_key_abort:

	addi		$sp,$sp,$FRAME

	blr

	.long		0

	.byte		0,12,4,1,0x80,0,3,0

	.long		0

.size	.${prefix}_set_decrypt_key,.-.${prefix}_set_decrypt_key

___

}}}

#########################################################################

{{{	# Single block en- and decrypt procedures			#

sub gen_block () {

 shift;

my $n   = $dir eq "de" ? "n" : "";

map("r$_",(3..7));

$code.=<<___;

.globl	.${prefix}_${dir}crypt

	lwz		$rounds,240($key)

	lis		r0,0xfc00

	mfspr		$vrsave,256

	li		$idx,15			# 15 is not typo

	mtspr		256,r0



	lvx		v0,0,$inp

	neg		r11,$out

	lvx		v1,$idx,$inp

	lvsl		v2,0,$inp		# inpperm

	le?vspltisb	v4,0x0f

	?lvsl		v3,0,r11		# outperm

	le?vxor		v2,v2,v4

	li		$idx,16

	vperm		v0,v0,v1,v2		# align [and byte swap in LE]

	lvx		v1,0,$key

	?lvsl		v5,0,$key		# keyperm

	srwi		$rounds,$rounds,1

	lvx		v2,$idx,$key

	addi		$idx,$idx,16

	subi		$rounds,$rounds,1

	?vperm		v1,v1,v2,v5		# align round key



	vxor		v0,v0,v1

	lvx		v1,$idx,$key

	addi		$idx,$idx,16

	mtctr		$rounds



Loop_${dir}c:

	?vperm		v2,v2,v1,v5

	v${n}cipher	v0,v0,v2

	lvx		v2,$idx,$key

	addi		$idx,$idx,16

	?vperm		v1,v1,v2,v5

	v${n}cipher	v0,v0,v1

	lvx		v1,$idx,$key

	addi		$idx,$idx,16

	bdnz		Loop_${dir}c



	?vperm		v2,v2,v1,v5

	v${n}cipher	v0,v0,v2

	lvx		v2,$idx,$key

	?vperm		v1,v1,v2,v5

	v${n}cipherlast	v0,v0,v1



	vspltisb	v2,-1

	vxor		v1,v1,v1

	li		$idx,15			# 15 is not typo

	?vperm		v2,v1,v2,v3		# outmask

	le?vxor		v3,v3,v4

	lvx		v1,0,$out		# outhead

	vperm		v0,v0,v0,v3		# rotate [and byte swap in LE]

	vsel		v1,v1,v0,v2

	lvx		v4,$idx,$out

	stvx		v1,0,$out

	vsel		v0,v0,v4,v2

	stvx		v0,$idx,$out



	mtspr		256,$vrsave

	blr

	.long		0

	.byte		0,12,0x14,0,0,0,3,0

	.long		0

.size	.${prefix}_${dir}crypt,.-.${prefix}_${dir}crypt

___

}

&gen_block("en");

&gen_block("de");

}}}

#########################################################################

{{{	# CBC en- and decrypt procedures				#

map("r$_",(3..10));

my ($rndkey0,$rndkey1,$inout,$tmp)=		map("v$_",(0..3));



$code.=<<___;

.globl	.${prefix}_cbc_encrypt

	${UCMP}i	$len,16

	bltlr-



	cmpwi		$enc,0			# test direction

	lis		r0,0xffe0

	mfspr		$vrsave,256

	mtspr		256,r0



	li		$idx,15

	vxor		$rndkey0,$rndkey0,$rndkey0

	le?vspltisb	$tmp,0x0f



	lvx		$ivec,0,$ivp		# load [unaligned] iv

	lvsl		$inpperm,0,$ivp

	lvx		$inptail,$idx,$ivp

	le?vxor		$inpperm,$inpperm,$tmp

	vperm		$ivec,$ivec,$inptail,$inpperm



	neg		r11,$inp

	?lvsl		$keyperm,0,$key		# prepare for unaligned key

	lwz		$rounds,240($key)



	lvsr		$inpperm,0,r11		# prepare for unaligned load

	lvx		$inptail,0,$inp

	addi		$inp,$inp,15		# 15 is not typo

	le?vxor		$inpperm,$inpperm,$tmp



	?lvsr		$outperm,0,$out		# prepare for unaligned store

	vspltisb	$outmask,-1

	lvx		$outhead,0,$out

	?vperm		$outmask,$rndkey0,$outmask,$outperm

	le?vxor		$outperm,$outperm,$tmp



	srwi		$rounds,$rounds,1

	li		$idx,16

	subi		$rounds,$rounds,1

	beq		Lcbc_dec



Lcbc_enc:

	vmr		$inout,$inptail

	lvx		$inptail,0,$inp

	addi		$inp,$inp,16

	mtctr		$rounds

 len-=16

	subi		$len,$len,16		# len-=16



	lvx		$rndkey0,0,$key

	 vperm		$tmp,$tmp,$inptail,$inpperm

	lvx		$rndkey1,$idx,$key

	addi		$idx,$idx,16

	?vperm		$rndkey0,$rndkey0,$rndkey1,$keyperm

	vxor		$inout,$tmp,$rndkey0

	lvx		$rndkey0,$idx,$key

	addi		$idx,$idx,16



Loop_cbc_dec:

	?vperm		$rndkey1,$rndkey1,$rndkey0,$keyperm

	vncipher	$inout,$inout,$rndkey1

	lvx		$rndkey1,$idx,$key

	addi		$idx,$idx,16

	?vperm		$rndkey0,$rndkey0,$rndkey1,$keyperm

	vncipher	$inout,$inout,$rndkey0

	lvx		$rndkey0,$idx,$key

	addi		$idx,$idx,16

	bdnz		Loop_cbc_dec



	?vperm		$rndkey1,$rndkey1,$rndkey0,$keyperm

	vncipher	$inout,$inout,$rndkey1

	lvx		$rndkey1,$idx,$key

	li		$idx,16

	?vperm		$rndkey0,$rndkey0,$rndkey1,$keyperm

	vncipherlast	$inout,$inout,$rndkey0

	${UCMP}i	$len,16



	vxor		$inout,$inout,$ivec

	vmr		$ivec,$tmp

	vperm		$tmp,$inout,$inout,$outperm

	vsel		$inout,$outhead,$tmp,$outmask

	vmr		$outhead,$tmp

	stvx		$inout,0,$out

	addi		$out,$out,16

	bge		Lcbc_dec



Lcbc_done:

	addi		$out,$out,-1

	lvx		$inout,0,$out		# redundant in aligned case

	vsel		$inout,$outhead,$inout,$outmask

	stvx		$inout,0,$out



	neg		$enc,$ivp		# write [unaligned] iv

	li		$idx,15			# 15 is not typo

	vxor		$rndkey0,$rndkey0,$rndkey0

	vspltisb	$outmask,-1

	le?vspltisb	$tmp,0x0f

	?lvsl		$outperm,0,$enc

	?vperm		$outmask,$rndkey0,$outmask,$outperm

	le?vxor		$outperm,$outperm,$tmp

	lvx		$outhead,0,$ivp

	vperm		$ivec,$ivec,$ivec,$outperm

	vsel		$inout,$outhead,$ivec,$outmask

	lvx		$inptail,$idx,$ivp

	stvx		$inout,0,$ivp

	vsel		$inout,$ivec,$inptail,$outmask

	stvx		$inout,$idx,$ivp



	mtspr		256,$vrsave

	blr

	.long		0

	.byte		0,12,0x14,0,0,0,6,0

	.long		0

___

#########################################################################

{{	# Optimized CBC decrypt procedure				#

"r11";

my ($x00,$x10,$x20,$x30,$x40,$x50,$x60,$x70)=map("r$_",(0,8,26..31));

map("v$_",(0..3,10..13));

my ($out0,$out1,$out2,$out3,$out4,$out5,$out6,$out7)=map("v$_",(14..21));

 v24-v25 rotating buffer for first found keys

 v26-v31 last 6 round keys

my ($tmp,$keyperm)=($in3,$in4);	# aliases with "caller", redundant assignment



<<___;

 ABI says so

 save vrsave

 -4 in total

 bias

 load key schedule

 off-load round[1]

 off-load round[2]

 off-load round[3]

 off-load round[4]

 rewind $key_

 borrow $out0

 pre-load round[1]

 pre-load round[2]

lvx		$inptail,0,$inp		
addi		$inp,$inp,15		
 undo "caller"

 load first 8 "words"

 transform for lvx_u/stvx_u

 round[3]

 round[4]

	subic		$len,$len,128		# $len-=128

	vncipher	$out0,$out0,v24

	vncipher	$out1,$out1,v24

	vncipher	$out2,$out2,v24

	vncipher	$out3,$out3,v24

	vncipher	$out4,$out4,v24

	vncipher	$out5,$out5,v24

	vncipher	$out6,$out6,v24

	vncipher	$out7,$out7,v24



	subfe.		r0,r0,r0		# borrow?-1:0

	vncipher	$out0,$out0,v25

	vncipher	$out1,$out1,v25

	vncipher	$out2,$out2,v25

	vncipher	$out3,$out3,v25

	vncipher	$out4,$out4,v25

	vncipher	$out5,$out5,v25

	vncipher	$out6,$out6,v25

	vncipher	$out7,$out7,v25



	and		r0,r0,$len

	vncipher	$out0,$out0,v26

	vncipher	$out1,$out1,v26

	vncipher	$out2,$out2,v26

	vncipher	$out3,$out3,v26

	vncipher	$out4,$out4,v26

	vncipher	$out5,$out5,v26

	vncipher	$out6,$out6,v26

	vncipher	$out7,$out7,v26



	add		$inp,$inp,r0		# $inp is adjusted in such

						# way that at exit from the

						# loop inX-in7 are loaded

						# with last "words"

	vncipher	$out0,$out0,v27

	vncipher	$out1,$out1,v27

	vncipher	$out2,$out2,v27

	vncipher	$out3,$out3,v27

	vncipher	$out4,$out4,v27

	vncipher	$out5,$out5,v27

	vncipher	$out6,$out6,v27

	vncipher	$out7,$out7,v27



	addi		$key_,$sp,$FRAME+15	# rewind $key_

	vncipher	$out0,$out0,v28

	vncipher	$out1,$out1,v28

	vncipher	$out2,$out2,v28

	vncipher	$out3,$out3,v28

	vncipher	$out4,$out4,v28

	vncipher	$out5,$out5,v28

	vncipher	$out6,$out6,v28

	vncipher	$out7,$out7,v28

	lvx		v24,$x00,$key_		# re-pre-load round[1]



	vncipher	$out0,$out0,v29

	vncipher	$out1,$out1,v29

	vncipher	$out2,$out2,v29

	vncipher	$out3,$out3,v29

	vncipher	$out4,$out4,v29

	vncipher	$out5,$out5,v29

	vncipher	$out6,$out6,v29

	vncipher	$out7,$out7,v29

	lvx		v25,$x10,$key_		# re-pre-load round[2]



	vncipher	$out0,$out0,v30

	 vxor		$ivec,$ivec,v31		# xor with last round key

	vncipher	$out1,$out1,v30

	 vxor		$in0,$in0,v31

	vncipher	$out2,$out2,v30

	 vxor		$in1,$in1,v31

	vncipher	$out3,$out3,v30

	 vxor		$in2,$in2,v31

	vncipher	$out4,$out4,v30

	 vxor		$in3,$in3,v31

	vncipher	$out5,$out5,v30

	 vxor		$in4,$in4,v31

	vncipher	$out6,$out6,v30

	 vxor		$in5,$in5,v31

	vncipher	$out7,$out7,v30

	 vxor		$in6,$in6,v31



	vncipherlast	$out0,$out0,$ivec

	vncipherlast	$out1,$out1,$in0

	 lvx_u		$in0,$x00,$inp		# load next input block

	vncipherlast	$out2,$out2,$in1

	 lvx_u		$in1,$x10,$inp

	vncipherlast	$out3,$out3,$in2

	 le?vperm	$in0,$in0,$in0,$inpperm

	 lvx_u		$in2,$x20,$inp

	vncipherlast	$out4,$out4,$in3

	 le?vperm	$in1,$in1,$in1,$inpperm

	 lvx_u		$in3,$x30,$inp

	vncipherlast	$out5,$out5,$in4

	 le?vperm	$in2,$in2,$in2,$inpperm

	 lvx_u		$in4,$x40,$inp

	vncipherlast	$out6,$out6,$in5

	 le?vperm	$in3,$in3,$in3,$inpperm

	 lvx_u		$in5,$x50,$inp

	vncipherlast	$out7,$out7,$in6

	 le?vperm	$in4,$in4,$in4,$inpperm

	 lvx_u		$in6,$x60,$inp

	vmr		$ivec,$in7

	 le?vperm	$in5,$in5,$in5,$inpperm

	 lvx_u		$in7,$x70,$inp

	 addi		$inp,$inp,0x80



	le?vperm	$out0,$out0,$out0,$inpperm

	le?vperm	$out1,$out1,$out1,$inpperm

	stvx_u		$out0,$x00,$out

	 le?vperm	$in6,$in6,$in6,$inpperm

	 vxor		$out0,$in0,$rndkey0

	le?vperm	$out2,$out2,$out2,$inpperm

	stvx_u		$out1,$x10,$out

	 le?vperm	$in7,$in7,$in7,$inpperm

	 vxor		$out1,$in1,$rndkey0

	le?vperm	$out3,$out3,$out3,$inpperm

	stvx_u		$out2,$x20,$out

	 vxor		$out2,$in2,$rndkey0

	le?vperm	$out4,$out4,$out4,$inpperm

	stvx_u		$out3,$x30,$out

	 vxor		$out3,$in3,$rndkey0

	le?vperm	$out5,$out5,$out5,$inpperm

	stvx_u		$out4,$x40,$out

	 vxor		$out4,$in4,$rndkey0

	le?vperm	$out6,$out6,$out6,$inpperm

	stvx_u		$out5,$x50,$out

	 vxor		$out5,$in5,$rndkey0

	le?vperm	$out7,$out7,$out7,$inpperm

	stvx_u		$out6,$x60,$out

	 vxor		$out6,$in6,$rndkey0

	stvx_u		$out7,$x70,$out

	addi		$out,$out,0x80

	 vxor		$out7,$in7,$rndkey0



	mtctr		$rounds

 did $len-=128 borrow?

 up to 7 "words" tail...

 round[3]

 round[4]

 last round key

 switch($len)

 write [unaligned] iv

 wipe copies of round keys

 ABI says so



 CTR procedure[s]						
 WARNING: Here be dragons! 


 This code is written as 'ctr32', based on a 32-bit counter used

 upstream. The kernel does *not* use a 32-bit counter. The kernel uses

 a 128-bit counter.



 This leads to subtle changes from the upstream code: the counter

 is incremented with vaddu_q_m rather than vaddu_w_m. This occurs in

 both the bulk (8 blocks at a time) path, and in the individual block

 path. Be aware of this when doing updates.



 See:

 1d4aa0b4c181 ("crypto: vmx - Fixing AES-CTR counter bug")

 009b30ac7444 ("crypto: vmx - CTR: always increment IV as quadword")

 https://github.com/openssl/openssl/pull/8942





my ($inp,$out,$len,$key,$ivp,$x10,$rounds,$idx)=map("r$_",(3..10));

		map("v$_",(0..3));

my ($ivec,$inptail,$inpperm,$outhead,$outperm,$outmask,$keyperm,$one)=

						map("v$_",(4..11));

$tmp;

$code.=<<___;

.globl	.${prefix}_ctr32_encrypt_blocks

	${UCMP}i	$len,1

	bltlr-



	lis		r0,0xfff0

	mfspr		$vrsave,256

	mtspr		256,r0



	li		$idx,15

	vxor		$rndkey0,$rndkey0,$rndkey0

	le?vspltisb	$tmp,0x0f



	lvx		$ivec,0,$ivp		# load [unaligned] iv

	lvsl		$inpperm,0,$ivp

	lvx		$inptail,$idx,$ivp

	 vspltisb	$one,1

	le?vxor		$inpperm,$inpperm,$tmp

	vperm		$ivec,$ivec,$inptail,$inpperm

	 vsldoi		$one,$rndkey0,$one,1



	neg		r11,$inp

	?lvsl		$keyperm,0,$key		# prepare for unaligned key

	lwz		$rounds,240($key)



	lvsr		$inpperm,0,r11		# prepare for unaligned load

	lvx		$inptail,0,$inp

	addi		$inp,$inp,15		# 15 is not typo

	le?vxor		$inpperm,$inpperm,$tmp



	srwi		$rounds,$rounds,1

	li		$idx,16

	subi		$rounds,$rounds,1



	${UCMP}i	$len,8

	bge		_aesp8_ctr32_encrypt8x



	?lvsr		$outperm,0,$out		# prepare for unaligned store

	vspltisb	$outmask,-1

	lvx		$outhead,0,$out

	?vperm		$outmask,$rndkey0,$outmask,$outperm

	le?vxor		$outperm,$outperm,$tmp



	lvx		$rndkey0,0,$key

	mtctr		$rounds

	lvx		$rndkey1,$idx,$key

	addi		$idx,$idx,16

	?vperm		$rndkey0,$rndkey0,$rndkey1,$keyperm

	vxor		$inout,$ivec,$rndkey0

	lvx		$rndkey0,$idx,$key

	addi		$idx,$idx,16

	b		Loop_ctr32_enc



.align	5

Loop_ctr32_enc:

	?vperm		$rndkey1,$rndkey1,$rndkey0,$keyperm

	vcipher		$inout,$inout,$rndkey1

	lvx		$rndkey1,$idx,$key

	addi		$idx,$idx,16

	?vperm		$rndkey0,$rndkey0,$rndkey1,$keyperm

	vcipher		$inout,$inout,$rndkey0

	lvx		$rndkey0,$idx,$key

	addi		$idx,$idx,16

	bdnz		Loop_ctr32_enc



	vadduqm		$ivec,$ivec,$one	# Kernel change for 128-bit

	 vmr		$dat,$inptail

	 lvx		$inptail,0,$inp

	 addi		$inp,$inp,16

	 subic.		$len,$len,1		# blocks--



	?vperm		$rndkey1,$rndkey1,$rndkey0,$keyperm

	vcipher		$inout,$inout,$rndkey1

	lvx		$rndkey1,$idx,$key

	 vperm		$dat,$dat,$inptail,$inpperm

	 li		$idx,16

	?vperm		$rndkey1,$rndkey0,$rndkey1,$keyperm

	 lvx		$rndkey0,0,$key

	vxor		$dat,$dat,$rndkey1	# last round key

	vcipherlast	$inout,$inout,$dat



	 lvx		$rndkey1,$idx,$key

	 addi		$idx,$idx,16

	vperm		$inout,$inout,$inout,$outperm

	vsel		$dat,$outhead,$inout,$outmask

	 mtctr		$rounds

	 ?vperm		$rndkey0,$rndkey0,$rndkey1,$keyperm

	vmr		$outhead,$inout

	 vxor		$inout,$ivec,$rndkey0

	 lvx		$rndkey0,$idx,$key

	 addi		$idx,$idx,16

	stvx		$dat,0,$out

	addi		$out,$out,16

	bne		Loop_ctr32_enc



	addi		$out,$out,-1

	lvx		$inout,0,$out		# redundant in aligned case

	vsel		$inout,$outhead,$inout,$outmask

	stvx		$inout,0,$out



	mtspr		256,$vrsave

	blr

	.long		0

	.byte		0,12,0x14,0,0,0,6,0

	.long		0

___

#########################################################################

{{	# Optimized CTR procedure					#

"r11";

my ($x00,$x10,$x20,$x30,$x40,$x50,$x60,$x70)=map("r$_",(0,8,26..31));

map("v$_",(0..3,10,12..14));

my ($out0,$out1,$out2,$out3,$out4,$out5,$out6,$out7)=map("v$_",(15..22));

 v24-v25 rotating buffer for first found keys

 v26-v31 last 6 round keys

my ($tmp,$keyperm)=($in3,$in4);	# aliases with "caller", redundant assignment

($outhead,$outperm,$outmask);

$code.=<<___;

.align	5

_aesp8_ctr32_encrypt8x:

	$STU		$sp,-`($FRAME+21*16+6*$SIZE_T)`($sp)

	li		r10,`$FRAME+8*16+15`

	li		r11,`$FRAME+8*16+31`

	stvx		v20,r10,$sp		# ABI says so

	addi		r10,r10,32

	stvx		v21,r11,$sp

	addi		r11,r11,32

	stvx		v22,r10,$sp

	addi		r10,r10,32

	stvx		v23,r11,$sp

	addi		r11,r11,32

	stvx		v24,r10,$sp

	addi		r10,r10,32

	stvx		v25,r11,$sp

	addi		r11,r11,32

	stvx		v26,r10,$sp

	addi		r10,r10,32

	stvx		v27,r11,$sp

	addi		r11,r11,32

	stvx		v28,r10,$sp

	addi		r10,r10,32

	stvx		v29,r11,$sp

	addi		r11,r11,32

	stvx		v30,r10,$sp

	stvx		v31,r11,$sp

	li		r0,-1

	stw		$vrsave,`$FRAME+21*16-4`($sp)	# save vrsave

	li		$x10,0x10

	$PUSH		r26,`$FRAME+21*16+0*$SIZE_T`($sp)

	li		$x20,0x20

	$PUSH		r27,`$FRAME+21*16+1*$SIZE_T`($sp)

	li		$x30,0x30

	$PUSH		r28,`$FRAME+21*16+2*$SIZE_T`($sp)

	li		$x40,0x40

	$PUSH		r29,`$FRAME+21*16+3*$SIZE_T`($sp)

	li		$x50,0x50

	$PUSH		r30,`$FRAME+21*16+4*$SIZE_T`($sp)

	li		$x60,0x60

	$PUSH		r31,`$FRAME+21*16+5*$SIZE_T`($sp)

	li		$x70,0x70

	mtspr		256,r0



	subi		$rounds,$rounds,3	# -4 in total



	lvx		$rndkey0,$x00,$key	# load key schedule

	lvx		v30,$x10,$key

	addi		$key,$key,0x20

	lvx		v31,$x00,$key

	?vperm		$rndkey0,$rndkey0,v30,$keyperm

	addi		$key_,$sp,$FRAME+15

	mtctr		$rounds



Load_ctr32_enc_key:

	?vperm		v24,v30,v31,$keyperm

	lvx		v30,$x10,$key

	addi		$key,$key,0x20

	stvx		v24,$x00,$key_		# off-load round[1]

	?vperm		v25,v31,v30,$keyperm

	lvx		v31,$x00,$key

	stvx		v25,$x10,$key_		# off-load round[2]

	addi		$key_,$key_,0x20

	bdnz		Load_ctr32_enc_key



	lvx		v26,$x10,$key

	?vperm		v24,v30,v31,$keyperm

	lvx		v27,$x20,$key

	stvx		v24,$x00,$key_		# off-load round[3]

	?vperm		v25,v31,v26,$keyperm

	lvx		v28,$x30,$key

	stvx		v25,$x10,$key_		# off-load round[4]

	addi		$key_,$sp,$FRAME+15	# rewind $key_

	?vperm		v26,v26,v27,$keyperm

	lvx		v29,$x40,$key

	?vperm		v27,v27,v28,$keyperm

	lvx		v30,$x50,$key

	?vperm		v28,v28,v29,$keyperm

	lvx		v31,$x60,$key

	?vperm		v29,v29,v30,$keyperm

	lvx		$out0,$x70,$key		# borrow $out0

	?vperm		v30,v30,v31,$keyperm

	lvx		v24,$x00,$key_		# pre-load round[1]

	?vperm		v31,v31,$out0,$keyperm

	lvx		v25,$x10,$key_		# pre-load round[2]



	vadduqm		$two,$one,$one

	subi		$inp,$inp,15		# undo "caller"

	$SHL		$len,$len,4



	vadduqm		$out1,$ivec,$one	# counter values ...

	vadduqm		$out2,$ivec,$two	# (do all ctr adds as 128-bit)

	vxor		$out0,$ivec,$rndkey0	# ... xored with rndkey[0]

	 le?li		$idx,8

	vadduqm		$out3,$out1,$two

	vxor		$out1,$out1,$rndkey0

	 le?lvsl	$inpperm,0,$idx

	vadduqm		$out4,$out2,$two

	vxor		$out2,$out2,$rndkey0

	 le?vspltisb	$tmp,0x0f

	vadduqm		$out5,$out3,$two

	vxor		$out3,$out3,$rndkey0

	 le?vxor	$inpperm,$inpperm,$tmp	# transform for lvx_u/stvx_u

	vadduqm		$out6,$out4,$two

	vxor		$out4,$out4,$rndkey0

	vadduqm		$out7,$out5,$two

	vxor		$out5,$out5,$rndkey0

	vadduqm		$ivec,$out6,$two	# next counter value

	vxor		$out6,$out6,$rndkey0

	vxor		$out7,$out7,$rndkey0



	mtctr		$rounds

	b		Loop_ctr32_enc8x

.align	5

Loop_ctr32_enc8x:

	vcipher 	$out0,$out0,v24

	vcipher 	$out1,$out1,v24

	vcipher 	$out2,$out2,v24

	vcipher 	$out3,$out3,v24

	vcipher 	$out4,$out4,v24

	vcipher 	$out5,$out5,v24

	vcipher 	$out6,$out6,v24

	vcipher 	$out7,$out7,v24

Loop_ctr32_enc8x_middle:

	lvx		v24,$x20,$key_		# round[3]

	addi		$key_,$key_,0x20



	vcipher 	$out0,$out0,v25

	vcipher 	$out1,$out1,v25

	vcipher 	$out2,$out2,v25

	vcipher 	$out3,$out3,v25

	vcipher 	$out4,$out4,v25

	vcipher 	$out5,$out5,v25

	vcipher 	$out6,$out6,v25

	vcipher 	$out7,$out7,v25

	lvx		v25,$x10,$key_		# round[4]

	bdnz		Loop_ctr32_enc8x



	subic		r11,$len,256		# $len-256, borrow $key_

	vcipher 	$out0,$out0,v24

	vcipher 	$out1,$out1,v24

	vcipher 	$out2,$out2,v24

	vcipher 	$out3,$out3,v24

	vcipher 	$out4,$out4,v24

	vcipher 	$out5,$out5,v24

	vcipher 	$out6,$out6,v24

	vcipher 	$out7,$out7,v24



	subfe		r0,r0,r0		# borrow?-1:0

	vcipher 	$out0,$out0,v25

	vcipher 	$out1,$out1,v25

	vcipher 	$out2,$out2,v25

	vcipher 	$out3,$out3,v25

	vcipher 	$out4,$out4,v25

	vcipher		$out5,$out5,v25

	vcipher		$out6,$out6,v25

	vcipher		$out7,$out7,v25



	and		r0,r0,r11

	addi		$key_,$sp,$FRAME+15	# rewind $key_

	vcipher		$out0,$out0,v26

	vcipher		$out1,$out1,v26

	vcipher		$out2,$out2,v26

	vcipher		$out3,$out3,v26

	vcipher		$out4,$out4,v26

	vcipher		$out5,$out5,v26

	vcipher		$out6,$out6,v26

	vcipher		$out7,$out7,v26

	lvx		v24,$x00,$key_		# re-pre-load round[1]



 $len-=129

	addi		$len,$len,1		# $len-=128 really

	vcipher		$out1,$out1,v27

	vcipher		$out2,$out2,v27

	vcipher		$out3,$out3,v27

	vcipher		$out4,$out4,v27

	vcipher		$out5,$out5,v27

	vcipher		$out6,$out6,v27

	vcipher		$out7,$out7,v27

	lvx		v25,$x10,$key_		# re-pre-load round[2]



	vcipher		$out0,$out0,v28

	 lvx_u		$in0,$x00,$inp		# load input

	vcipher		$out1,$out1,v28

	 lvx_u		$in1,$x10,$inp

	vcipher		$out2,$out2,v28

	 lvx_u		$in2,$x20,$inp

	vcipher		$out3,$out3,v28

	 lvx_u		$in3,$x30,$inp

	vcipher		$out4,$out4,v28

	 lvx_u		$in4,$x40,$inp

	vcipher		$out5,$out5,v28

	 lvx_u		$in5,$x50,$inp

	vcipher		$out6,$out6,v28

	 lvx_u		$in6,$x60,$inp

	vcipher		$out7,$out7,v28

	 lvx_u		$in7,$x70,$inp

	 addi		$inp,$inp,0x80



	vcipher		$out0,$out0,v29

	 le?vperm	$in0,$in0,$in0,$inpperm

	vcipher		$out1,$out1,v29

	 le?vperm	$in1,$in1,$in1,$inpperm

	vcipher		$out2,$out2,v29

	 le?vperm	$in2,$in2,$in2,$inpperm

	vcipher		$out3,$out3,v29

	 le?vperm	$in3,$in3,$in3,$inpperm

	vcipher		$out4,$out4,v29

	 le?vperm	$in4,$in4,$in4,$inpperm

	vcipher		$out5,$out5,v29

	 le?vperm	$in5,$in5,$in5,$inpperm

	vcipher		$out6,$out6,v29

	 le?vperm	$in6,$in6,$in6,$inpperm

	vcipher		$out7,$out7,v29

	 le?vperm	$in7,$in7,$in7,$inpperm



	add		$inp,$inp,r0		# $inp is adjusted in such

						# way that at exit from the

						# loop inX-in7 are loaded

						# with last "words"

	subfe.		r0,r0,r0		# borrow?-1:0

	vcipher		$out0,$out0,v30

	 vxor		$in0,$in0,v31		# xor with last round key

	vcipher		$out1,$out1,v30

	 vxor		$in1,$in1,v31

	vcipher		$out2,$out2,v30

	 vxor		$in2,$in2,v31

	vcipher		$out3,$out3,v30

	 vxor		$in3,$in3,v31

	vcipher		$out4,$out4,v30

	 vxor		$in4,$in4,v31

	vcipher		$out5,$out5,v30

	 vxor		$in5,$in5,v31

	vcipher		$out6,$out6,v30

	 vxor		$in6,$in6,v31

	vcipher		$out7,$out7,v30

	 vxor		$in7,$in7,v31



	bne		Lctr32_enc8x_break	# did $len-129 borrow?



	vcipherlast	$in0,$out0,$in0

	vcipherlast	$in1,$out1,$in1

	 vadduqm	$out1,$ivec,$one	# counter values ...

	vcipherlast	$in2,$out2,$in2

	 vadduqm	$out2,$ivec,$two

	 vxor		$out0,$ivec,$rndkey0	# ... xored with rndkey[0]

	vcipherlast	$in3,$out3,$in3

	 vadduqm	$out3,$out1,$two

	 vxor		$out1,$out1,$rndkey0

	vcipherlast	$in4,$out4,$in4

	 vadduqm	$out4,$out2,$two

	 vxor		$out2,$out2,$rndkey0

	vcipherlast	$in5,$out5,$in5

	 vadduqm	$out5,$out3,$two

	 vxor		$out3,$out3,$rndkey0

	vcipherlast	$in6,$out6,$in6

	 vadduqm	$out6,$out4,$two

	 vxor		$out4,$out4,$rndkey0

	vcipherlast	$in7,$out7,$in7

	 vadduqm	$out7,$out5,$two

	 vxor		$out5,$out5,$rndkey0

	le?vperm	$in0,$in0,$in0,$inpperm

	 vadduqm	$ivec,$out6,$two	# next counter value

	 vxor		$out6,$out6,$rndkey0

	le?vperm	$in1,$in1,$in1,$inpperm

	 vxor		$out7,$out7,$rndkey0

	mtctr		$rounds



	 vcipher	$out0,$out0,v24

	stvx_u		$in0,$x00,$out

	le?vperm	$in2,$in2,$in2,$inpperm

	 vcipher	$out1,$out1,v24

	stvx_u		$in1,$x10,$out

	le?vperm	$in3,$in3,$in3,$inpperm

	 vcipher	$out2,$out2,v24

	stvx_u		$in2,$x20,$out

	le?vperm	$in4,$in4,$in4,$inpperm

	 vcipher	$out3,$out3,v24

	stvx_u		$in3,$x30,$out

	le?vperm	$in5,$in5,$in5,$inpperm

	 vcipher	$out4,$out4,v24

	stvx_u		$in4,$x40,$out

	le?vperm	$in6,$in6,$in6,$inpperm

	 vcipher	$out5,$out5,v24

	stvx_u		$in5,$x50,$out

	le?vperm	$in7,$in7,$in7,$inpperm

	 vcipher	$out6,$out6,v24

	stvx_u		$in6,$x60,$out

	 vcipher	$out7,$out7,v24

	stvx_u		$in7,$x70,$out

	addi		$out,$out,0x80



	b		Loop_ctr32_enc8x_middle



.align	5

Lctr32_enc8x_break:

	cmpwi		$len,-0x60

	blt		Lctr32_enc8x_one

	nop

	beq		Lctr32_enc8x_two

	cmpwi		$len,-0x40

	blt		Lctr32_enc8x_three

	nop

	beq		Lctr32_enc8x_four

	cmpwi		$len,-0x20

	blt		Lctr32_enc8x_five

	nop

	beq		Lctr32_enc8x_six

	cmpwi		$len,0x00

	blt		Lctr32_enc8x_seven



Lctr32_enc8x_eight:

	vcipherlast	$out0,$out0,$in0

	vcipherlast	$out1,$out1,$in1

	vcipherlast	$out2,$out2,$in2

	vcipherlast	$out3,$out3,$in3

	vcipherlast	$out4,$out4,$in4

	vcipherlast	$out5,$out5,$in5

	vcipherlast	$out6,$out6,$in6

	vcipherlast	$out7,$out7,$in7



	le?vperm	$out0,$out0,$out0,$inpperm

	le?vperm	$out1,$out1,$out1,$inpperm

	stvx_u		$out0,$x00,$out

	le?vperm	$out2,$out2,$out2,$inpperm

	stvx_u		$out1,$x10,$out

	le?vperm	$out3,$out3,$out3,$inpperm

	stvx_u		$out2,$x20,$out

	le?vperm	$out4,$out4,$out4,$inpperm

	stvx_u		$out3,$x30,$out

	le?vperm	$out5,$out5,$out5,$inpperm

	stvx_u		$out4,$x40,$out

	le?vperm	$out6,$out6,$out6,$inpperm

	stvx_u		$out5,$x50,$out

	le?vperm	$out7,$out7,$out7,$inpperm

	stvx_u		$out6,$x60,$out

	stvx_u		$out7,$x70,$out

	addi		$out,$out,0x80

	b		Lctr32_enc8x_done



.align	5

Lctr32_enc8x_seven:

	vcipherlast	$out0,$out0,$in1

	vcipherlast	$out1,$out1,$in2

	vcipherlast	$out2,$out2,$in3

	vcipherlast	$out3,$out3,$in4

	vcipherlast	$out4,$out4,$in5

	vcipherlast	$out5,$out5,$in6

	vcipherlast	$out6,$out6,$in7



	le?vperm	$out0,$out0,$out0,$inpperm

	le?vperm	$out1,$out1,$out1,$inpperm

	stvx_u		$out0,$x00,$out

	le?vperm	$out2,$out2,$out2,$inpperm

	stvx_u		$out1,$x10,$out

	le?vperm	$out3,$out3,$out3,$inpperm

	stvx_u		$out2,$x20,$out

	le?vperm	$out4,$out4,$out4,$inpperm

	stvx_u		$out3,$x30,$out

	le?vperm	$out5,$out5,$out5,$inpperm

	stvx_u		$out4,$x40,$out

	le?vperm	$out6,$out6,$out6,$inpperm

	stvx_u		$out5,$x50,$out

	stvx_u		$out6,$x60,$out

	addi		$out,$out,0x70

	b		Lctr32_enc8x_done



.align	5

Lctr32_enc8x_six:

	vcipherlast	$out0,$out0,$in2

	vcipherlast	$out1,$out1,$in3

	vcipherlast	$out2,$out2,$in4

	vcipherlast	$out3,$out3,$in5

	vcipherlast	$out4,$out4,$in6

	vcipherlast	$out5,$out5,$in7



	le?vperm	$out0,$out0,$out0,$inpperm

	le?vperm	$out1,$out1,$out1,$inpperm

	stvx_u		$out0,$x00,$out

	le?vperm	$out2,$out2,$out2,$inpperm

	stvx_u		$out1,$x10,$out

	le?vperm	$out3,$out3,$out3,$inpperm

	stvx_u		$out2,$x20,$out

	le?vperm	$out4,$out4,$out4,$inpperm

	stvx_u		$out3,$x30,$out

	le?vperm	$out5,$out5,$out5,$inpperm

	stvx_u		$out4,$x40,$out

	stvx_u		$out5,$x50,$out

	addi		$out,$out,0x60

	b		Lctr32_enc8x_done



.align	5

Lctr32_enc8x_five:

	vcipherlast	$out0,$out0,$in3

	vcipherlast	$out1,$out1,$in4

	vcipherlast	$out2,$out2,$in5

	vcipherlast	$out3,$out3,$in6

	vcipherlast	$out4,$out4,$in7



	le?vperm	$out0,$out0,$out0,$inpperm

	le?vperm	$out1,$out1,$out1,$inpperm

	stvx_u		$out0,$x00,$out

	le?vperm	$out2,$out2,$out2,$inpperm

	stvx_u		$out1,$x10,$out

	le?vperm	$out3,$out3,$out3,$inpperm

	stvx_u		$out2,$x20,$out

	le?vperm	$out4,$out4,$out4,$inpperm

	stvx_u		$out3,$x30,$out

	stvx_u		$out4,$x40,$out

	addi		$out,$out,0x50

	b		Lctr32_enc8x_done



.align	5

Lctr32_enc8x_four:

	vcipherlast	$out0,$out0,$in4

	vcipherlast	$out1,$out1,$in5

	vcipherlast	$out2,$out2,$in6

	vcipherlast	$out3,$out3,$in7



	le?vperm	$out0,$out0,$out0,$inpperm

	le?vperm	$out1,$out1,$out1,$inpperm

	stvx_u		$out0,$x00,$out

	le?vperm	$out2,$out2,$out2,$inpperm

	stvx_u		$out1,$x10,$out

	le?vperm	$out3,$out3,$out3,$inpperm

	stvx_u		$out2,$x20,$out

	stvx_u		$out3,$x30,$out

	addi		$out,$out,0x40

	b		Lctr32_enc8x_done



.align	5

Lctr32_enc8x_three:

	vcipherlast	$out0,$out0,$in5

	vcipherlast	$out1,$out1,$in6

	vcipherlast	$out2,$out2,$in7



	le?vperm	$out0,$out0,$out0,$inpperm

	le?vperm	$out1,$out1,$out1,$inpperm

	stvx_u		$out0,$x00,$out

	le?vperm	$out2,$out2,$out2,$inpperm

	stvx_u		$out1,$x10,$out

	stvx_u		$out2,$x20,$out

	addi		$out,$out,0x30

	b		Lctr32_enc8x_done



.align	5

Lctr32_enc8x_two:

	vcipherlast	$out0,$out0,$in6

	vcipherlast	$out1,$out1,$in7



	le?vperm	$out0,$out0,$out0,$inpperm

	le?vperm	$out1,$out1,$out1,$inpperm

	stvx_u		$out0,$x00,$out

	stvx_u		$out1,$x10,$out

	addi		$out,$out,0x20

	b		Lctr32_enc8x_done



.align	5

Lctr32_enc8x_one:

	vcipherlast	$out0,$out0,$in7



	le?vperm	$out0,$out0,$out0,$inpperm

	stvx_u		$out0,0,$out

	addi		$out,$out,0x10



Lctr32_enc8x_done:

	li		r10,`$FRAME+15`

	li		r11,`$FRAME+31`

	stvx		$inpperm,r10,$sp	# wipe copies of round keys

	addi		r10,r10,32

	stvx		$inpperm,r11,$sp

	addi		r11,r11,32

	stvx		$inpperm,r10,$sp

	addi		r10,r10,32

	stvx		$inpperm,r11,$sp

	addi		r11,r11,32

	stvx		$inpperm,r10,$sp

	addi		r10,r10,32

	stvx		$inpperm,r11,$sp

	addi		r11,r11,32

	stvx		$inpperm,r10,$sp

	addi		r10,r10,32

	stvx		$inpperm,r11,$sp

	addi		r11,r11,32



	mtspr		256,$vrsave

	lvx		v20,r10,$sp		# ABI says so

	addi		r10,r10,32

	lvx		v21,r11,$sp

	addi		r11,r11,32

	lvx		v22,r10,$sp

	addi		r10,r10,32

	lvx		v23,r11,$sp

	addi		r11,r11,32

	lvx		v24,r10,$sp

	addi		r10,r10,32

	lvx		v25,r11,$sp

	addi		r11,r11,32

	lvx		v26,r10,$sp

	addi		r10,r10,32

	lvx		v27,r11,$sp

	addi		r11,r11,32

	lvx		v28,r10,$sp

	addi		r10,r10,32

	lvx		v29,r11,$sp

	addi		r11,r11,32

	lvx		v30,r10,$sp

	lvx		v31,r11,$sp

	$POP		r26,`$FRAME+21*16+0*$SIZE_T`($sp)

	$POP		r27,`$FRAME+21*16+1*$SIZE_T`($sp)

	$POP		r28,`$FRAME+21*16+2*$SIZE_T`($sp)

	$POP		r29,`$FRAME+21*16+3*$SIZE_T`($sp)

	$POP		r30,`$FRAME+21*16+4*$SIZE_T`($sp)

	$POP		r31,`$FRAME+21*16+5*$SIZE_T`($sp)

	addi		$sp,$sp,`$FRAME+21*16+6*$SIZE_T`

	blr

	.long		0

	.byte		0,12,0x14,0,0x80,6,6,0

	.long		0

.size	.${prefix}_ctr32_encrypt_blocks,.-.${prefix}_ctr32_encrypt_blocks

___

}}	}}}



#########################################################################

{{{	# XTS procedures						#

# int aes_p8_xts_[en|de]crypt(const char *inp, char *out, size_t len,	#

#                             const AES_KEY *key1, const AES_KEY *key2,	#

#                             [const] unsigned char iv[16]);		#

# If $key2 is NULL, then a "tweak chaining" mode is engaged, in which	#

# input tweak value is assumed to be encrypted already, and last tweak	#

# value, one suitable for consecutive call on same chunk of data, is	#

# written back to original buffer. In addition, in "tweak chaining"	#

# mode only complete input blocks are processed.			#



	map("r$_",(3..10));

my ($rndkey0,$rndkey1,$inout) =				map("v$_",(0..2));

	map("v$_",(3..7));

my ($tweak,$seven,$eighty7,$tmp,$tweak1) =		map("v$_",(8..12));

 $key2;

   ($inp,$idx) = ($idx,$inp);				# reassign



<<___;

 reassign

 save vrsave

 0x070707..07

 load [unaligned] iv

 prepare for unaligned load

 15 is not typo

 key2==NULL?
NULL?

 prepare for unaligned key

 don't chain the tweak

 in "tweak chaining"

 mode only complete

 blocks are processed

 prepare for unaligned key

 0x808080..80

 0x878787..87

 0x010101..01

 0x870101..01

 next tweak value

 just in case $len<16

 $inpperm is no longer needed

 $inptail is no longer needed

 one more time...

 next tweak value

 restore vrsave

 reassign

 save vrsave

 0x070707..07

 load [unaligned] iv

 prepare for unaligned load

 15 is not typo

 key2==NULL?
NULL?

 prepare for unaligned key

 don't chain the tweak

 in "tweak chaining"

 mode only complete

 blocks are processed

 prepare for unaligned key

 0x808080..80

 0x878787..87

 0x010101..01

 0x870101..01

 next tweak value

 next tweak value

 :-(

 :-)

addi		$inp,$inp,16

 $inpperm is no longer needed

 $inptail is no longer needed

 one more time...

 next tweak value

 restore vrsave



 Optimized XTS procedures					
my $key_=$key2;

map("r$_",(0,3,26..31));

0 if ($flavour 
my ($in0,  $in1,  $in2,  $in3,  $in4,  $in5 )=map("v$_",(0..5));

map("v$_",(7,12..16));

my ($twk0, $twk1, $twk2, $twk3, $twk4, $twk5)=map("v$_",(17..22));

 v24-v25 rotating buffer for first found keys

 v26-v31 last 6 round keys

my ($keyperm)=($out0);	# aliases with "caller", redundant assignment

$x70;

$code.=<<___;

.align	5

_aesp8_xts_encrypt6x:

	$STU		$sp,-`($FRAME+21*16+6*$SIZE_T)`($sp)

	mflr		r11

	li		r7,`$FRAME+8*16+15`

	li		r3,`$FRAME+8*16+31`

	$PUSH		r11,`$FRAME+21*16+6*$SIZE_T+$LRSAVE`($sp)

	stvx		v20,r7,$sp		# ABI says so

	addi		r7,r7,32

	stvx		v21,r3,$sp

	addi		r3,r3,32

	stvx		v22,r7,$sp

	addi		r7,r7,32

	stvx		v23,r3,$sp

	addi		r3,r3,32

	stvx		v24,r7,$sp

	addi		r7,r7,32

	stvx		v25,r3,$sp

	addi		r3,r3,32

	stvx		v26,r7,$sp

	addi		r7,r7,32

	stvx		v27,r3,$sp

	addi		r3,r3,32

	stvx		v28,r7,$sp

	addi		r7,r7,32

	stvx		v29,r3,$sp

	addi		r3,r3,32

	stvx		v30,r7,$sp

	stvx		v31,r3,$sp

	li		r0,-1

	stw		$vrsave,`$FRAME+21*16-4`($sp)	# save vrsave

	li		$x10,0x10

	$PUSH		r26,`$FRAME+21*16+0*$SIZE_T`($sp)

	li		$x20,0x20

	$PUSH		r27,`$FRAME+21*16+1*$SIZE_T`($sp)

	li		$x30,0x30

	$PUSH		r28,`$FRAME+21*16+2*$SIZE_T`($sp)

	li		$x40,0x40

	$PUSH		r29,`$FRAME+21*16+3*$SIZE_T`($sp)

	li		$x50,0x50

	$PUSH		r30,`$FRAME+21*16+4*$SIZE_T`($sp)

	li		$x60,0x60

	$PUSH		r31,`$FRAME+21*16+5*$SIZE_T`($sp)

	li		$x70,0x70

	mtspr		256,r0



	subi		$rounds,$rounds,3	# -4 in total



	lvx		$rndkey0,$x00,$key1	# load key schedule

	lvx		v30,$x10,$key1

	addi		$key1,$key1,0x20

	lvx		v31,$x00,$key1

	?vperm		$rndkey0,$rndkey0,v30,$keyperm

	addi		$key_,$sp,$FRAME+15

	mtctr		$rounds



Load_xts_enc_key:

	?vperm		v24,v30,v31,$keyperm

	lvx		v30,$x10,$key1

	addi		$key1,$key1,0x20

	stvx		v24,$x00,$key_		# off-load round[1]

	?vperm		v25,v31,v30,$keyperm

	lvx		v31,$x00,$key1

	stvx		v25,$x10,$key_		# off-load round[2]

	addi		$key_,$key_,0x20

	bdnz		Load_xts_enc_key



	lvx		v26,$x10,$key1

	?vperm		v24,v30,v31,$keyperm

	lvx		v27,$x20,$key1

	stvx		v24,$x00,$key_		# off-load round[3]

	?vperm		v25,v31,v26,$keyperm

	lvx		v28,$x30,$key1

	stvx		v25,$x10,$key_		# off-load round[4]

	addi		$key_,$sp,$FRAME+15	# rewind $key_

	?vperm		v26,v26,v27,$keyperm

	lvx		v29,$x40,$key1

	?vperm		v27,v27,v28,$keyperm

	lvx		v30,$x50,$key1

	?vperm		v28,v28,v29,$keyperm

	lvx		v31,$x60,$key1

	?vperm		v29,v29,v30,$keyperm

	lvx		$twk5,$x70,$key1	# borrow $twk5

	?vperm		v30,v30,v31,$keyperm

	lvx		v24,$x00,$key_		# pre-load round[1]

	?vperm		v31,v31,$twk5,$keyperm

	lvx		v25,$x10,$key_		# pre-load round[2]



	 vperm		$in0,$inout,$inptail,$inpperm

	 subi		$inp,$inp,31		# undo "caller"

	vxor		$twk0,$tweak,$rndkey0

	vsrab		$tmp,$tweak,$seven	# next tweak value

	vaddubm		$tweak,$tweak,$tweak

	vsldoi		$tmp,$tmp,$tmp,15

	vand		$tmp,$tmp,$eighty7

	 vxor		$out0,$in0,$twk0

	vxor		$tweak,$tweak,$tmp



	 lvx_u		$in1,$x10,$inp

	vxor		$twk1,$tweak,$rndkey0

	vsrab		$tmp,$tweak,$seven	# next tweak value

	vaddubm		$tweak,$tweak,$tweak

	vsldoi		$tmp,$tmp,$tmp,15

	 le?vperm	$in1,$in1,$in1,$leperm

	vand		$tmp,$tmp,$eighty7

	 vxor		$out1,$in1,$twk1

	vxor		$tweak,$tweak,$tmp



	 lvx_u		$in2,$x20,$inp

	 andi.		$taillen,$len,15

	vxor		$twk2,$tweak,$rndkey0

	vsrab		$tmp,$tweak,$seven	# next tweak value

	vaddubm		$tweak,$tweak,$tweak

	vsldoi		$tmp,$tmp,$tmp,15

	 le?vperm	$in2,$in2,$in2,$leperm

	vand		$tmp,$tmp,$eighty7

	 vxor		$out2,$in2,$twk2

	vxor		$tweak,$tweak,$tmp



	 lvx_u		$in3,$x30,$inp

	 sub		$len,$len,$taillen

	vxor		$twk3,$tweak,$rndkey0

	vsrab		$tmp,$tweak,$seven	# next tweak value

	vaddubm		$tweak,$tweak,$tweak

	vsldoi		$tmp,$tmp,$tmp,15

	 le?vperm	$in3,$in3,$in3,$leperm

	vand		$tmp,$tmp,$eighty7

	 vxor		$out3,$in3,$twk3

	vxor		$tweak,$tweak,$tmp



	 lvx_u		$in4,$x40,$inp

	 subi		$len,$len,0x60

	vxor		$twk4,$tweak,$rndkey0

	vsrab		$tmp,$tweak,$seven	# next tweak value

	vaddubm		$tweak,$tweak,$tweak

	vsldoi		$tmp,$tmp,$tmp,15

	 le?vperm	$in4,$in4,$in4,$leperm

	vand		$tmp,$tmp,$eighty7

	 vxor		$out4,$in4,$twk4

	vxor		$tweak,$tweak,$tmp



	 lvx_u		$in5,$x50,$inp

	 addi		$inp,$inp,0x60

	vxor		$twk5,$tweak,$rndkey0

	vsrab		$tmp,$tweak,$seven	# next tweak value

	vaddubm		$tweak,$tweak,$tweak

	vsldoi		$tmp,$tmp,$tmp,15

	 le?vperm	$in5,$in5,$in5,$leperm

	vand		$tmp,$tmp,$eighty7

	 vxor		$out5,$in5,$twk5

	vxor		$tweak,$tweak,$tmp



	vxor		v31,v31,$rndkey0

	mtctr		$rounds

	b		Loop_xts_enc6x



.align	5

Loop_xts_enc6x:

	vcipher		$out0,$out0,v24

	vcipher		$out1,$out1,v24

	vcipher		$out2,$out2,v24

	vcipher		$out3,$out3,v24

	vcipher		$out4,$out4,v24

	vcipher		$out5,$out5,v24

	lvx		v24,$x20,$key_		# round[3]

	addi		$key_,$key_,0x20



	vcipher		$out0,$out0,v25

	vcipher		$out1,$out1,v25

	vcipher		$out2,$out2,v25

	vcipher		$out3,$out3,v25

	vcipher		$out4,$out4,v25

	vcipher		$out5,$out5,v25

	lvx		v25,$x10,$key_		# round[4]

	bdnz		Loop_xts_enc6x



 $len-=96

 xor with last round key

 next tweak value

 borrow?-1:0

 next tweak value

 $inp is adjusted in such

 way that at exit from the

 loop inX-in5 are loaded

 with last "words"

 next tweak value

 rewind $key_

 next tweak value

 re-pre-load round[1]

 next tweak value

 re-pre-load round[2]

 next tweak value

 load next input block

 last block might be needed

 in stealing mode

 store output

	beq		Loop_xts_enc6x		# did $len-=96 borrow?



	addic.		$len,$len,0x60

	beq		Lxts_enc6x_zero

	cmpwi		$len,0x20

	blt		Lxts_enc6x_one

	nop

	beq		Lxts_enc6x_two

	cmpwi		$len,0x40

	blt		Lxts_enc6x_three

	nop

	beq		Lxts_enc6x_four



Lxts_enc6x_five:

	vxor		$out0,$in1,$twk0

	vxor		$out1,$in2,$twk1

	vxor		$out2,$in3,$twk2

	vxor		$out3,$in4,$twk3

	vxor		$out4,$in5,$twk4



	bl		_aesp8_xts_enc5x



	le?vperm	$out0,$out0,$out0,$leperm

	vmr		$twk0,$twk5		# unused tweak

	le?vperm	$out1,$out1,$out1,$leperm

	stvx_u		$out0,$x00,$out		# store output

	le?vperm	$out2,$out2,$out2,$leperm

	stvx_u		$out1,$x10,$out

	le?vperm	$out3,$out3,$out3,$leperm

	stvx_u		$out2,$x20,$out

	vxor		$tmp,$out4,$twk5	# last block prep for stealing

	le?vperm	$out4,$out4,$out4,$leperm

	stvx_u		$out3,$x30,$out

	stvx_u		$out4,$x40,$out

	addi		$out,$out,0x50

	bne		Lxts_enc6x_steal

	b		Lxts_enc6x_done



.align	4

Lxts_enc6x_four:

	vxor		$out0,$in2,$twk0

	vxor		$out1,$in3,$twk1

	vxor		$out2,$in4,$twk2

	vxor		$out3,$in5,$twk3

	vxor		$out4,$out4,$out4



	bl		_aesp8_xts_enc5x



	le?vperm	$out0,$out0,$out0,$leperm

	vmr		$twk0,$twk4		# unused tweak

	le?vperm	$out1,$out1,$out1,$leperm

	stvx_u		$out0,$x00,$out		# store output

	le?vperm	$out2,$out2,$out2,$leperm

	stvx_u		$out1,$x10,$out

	vxor		$tmp,$out3,$twk4	# last block prep for stealing

	le?vperm	$out3,$out3,$out3,$leperm

	stvx_u		$out2,$x20,$out

	stvx_u		$out3,$x30,$out

	addi		$out,$out,0x40

	bne		Lxts_enc6x_steal

	b		Lxts_enc6x_done



.align	4

Lxts_enc6x_three:

	vxor		$out0,$in3,$twk0

	vxor		$out1,$in4,$twk1

	vxor		$out2,$in5,$twk2

	vxor		$out3,$out3,$out3

	vxor		$out4,$out4,$out4



	bl		_aesp8_xts_enc5x



	le?vperm	$out0,$out0,$out0,$leperm

	vmr		$twk0,$twk3		# unused tweak

	le?vperm	$out1,$out1,$out1,$leperm

	stvx_u		$out0,$x00,$out		# store output

	vxor		$tmp,$out2,$twk3	# last block prep for stealing

	le?vperm	$out2,$out2,$out2,$leperm

	stvx_u		$out1,$x10,$out

	stvx_u		$out2,$x20,$out

	addi		$out,$out,0x30

	bne		Lxts_enc6x_steal

	b		Lxts_enc6x_done



.align	4

Lxts_enc6x_two:

	vxor		$out0,$in4,$twk0

	vxor		$out1,$in5,$twk1

	vxor		$out2,$out2,$out2

	vxor		$out3,$out3,$out3

	vxor		$out4,$out4,$out4



	bl		_aesp8_xts_enc5x



	le?vperm	$out0,$out0,$out0,$leperm

	vmr		$twk0,$twk2		# unused tweak

	vxor		$tmp,$out1,$twk2	# last block prep for stealing

	le?vperm	$out1,$out1,$out1,$leperm

	stvx_u		$out0,$x00,$out		# store output

	stvx_u		$out1,$x10,$out

	addi		$out,$out,0x20

	bne		Lxts_enc6x_steal

	b		Lxts_enc6x_done



.align	4

Lxts_enc6x_one:

	vxor		$out0,$in5,$twk0

	nop

Loop_xts_enc1x:

	vcipher		$out0,$out0,v24

	lvx		v24,$x20,$key_		# round[3]

	addi		$key_,$key_,0x20



	vcipher		$out0,$out0,v25

	lvx		v25,$x10,$key_		# round[4]

	bdnz		Loop_xts_enc1x



	add		$inp,$inp,$taillen

	cmpwi		$taillen,0

	vcipher		$out0,$out0,v24



	subi		$inp,$inp,16

	vcipher		$out0,$out0,v25



	lvsr		$inpperm,0,$taillen

	vcipher		$out0,$out0,v26



	lvx_u		$in0,0,$inp

	vcipher		$out0,$out0,v27



	addi		$key_,$sp,$FRAME+15	# rewind $key_

	vcipher		$out0,$out0,v28

	lvx		v24,$x00,$key_		# re-pre-load round[1]



	vcipher		$out0,$out0,v29

	lvx		v25,$x10,$key_		# re-pre-load round[2]

	 vxor		$twk0,$twk0,v31



	le?vperm	$in0,$in0,$in0,$leperm

	vcipher		$out0,$out0,v30



	vperm		$in0,$in0,$in0,$inpperm

	vcipherlast	$out0,$out0,$twk0



	vmr		$twk0,$twk1		# unused tweak

	vxor		$tmp,$out0,$twk1	# last block prep for stealing

	le?vperm	$out0,$out0,$out0,$leperm

	stvx_u		$out0,$x00,$out		# store output

	addi		$out,$out,0x10

	bne		Lxts_enc6x_steal

	b		Lxts_enc6x_done



.align	4

Lxts_enc6x_zero:

	cmpwi		$taillen,0

	beq		Lxts_enc6x_done



	add		$inp,$inp,$taillen

	subi		$inp,$inp,16

	lvx_u		$in0,0,$inp

	lvsr		$inpperm,0,$taillen	# $in5 is no more

	le?vperm	$in0,$in0,$in0,$leperm

	vperm		$in0,$in0,$in0,$inpperm

	vxor		$tmp,$tmp,$twk0

Lxts_enc6x_steal:

	vxor		$in0,$in0,$twk0

	vxor		$out0,$out0,$out0

	vspltisb	$out1,-1

	vperm		$out0,$out0,$out1,$inpperm

	vsel		$out0,$in0,$tmp,$out0	# $tmp is last block, remember?



	subi		r30,$out,17

	subi		$out,$out,16

	mtctr		$taillen

Loop_xts_enc6x_steal:

	lbzu		r0,1(r30)

	stb		r0,16(r30)

	bdnz		Loop_xts_enc6x_steal



	li		$taillen,0

	mtctr		$rounds

	b		Loop_xts_enc1x		# one more time...



.align	4

Lxts_enc6x_done:

	${UCMP}i	$ivp,0

	beq		Lxts_enc6x_ret



	vxor		$tweak,$twk0,$rndkey0

	le?vperm	$tweak,$tweak,$tweak,$leperm

	stvx_u		$tweak,0,$ivp



Lxts_enc6x_ret:

	mtlr		r11

	li		r10,`$FRAME+15`

	li		r11,`$FRAME+31`

	stvx		$seven,r10,$sp		# wipe copies of round keys

	addi		r10,r10,32

	stvx		$seven,r11,$sp

	addi		r11,r11,32

	stvx		$seven,r10,$sp

	addi		r10,r10,32

	stvx		$seven,r11,$sp

	addi		r11,r11,32

	stvx		$seven,r10,$sp

	addi		r10,r10,32

	stvx		$seven,r11,$sp

	addi		r11,r11,32

	stvx		$seven,r10,$sp

	addi		r10,r10,32

	stvx		$seven,r11,$sp

	addi		r11,r11,32



	mtspr		256,$vrsave

	lvx		v20,r10,$sp		# ABI says so

	addi		r10,r10,32

	lvx		v21,r11,$sp

	addi		r11,r11,32

	lvx		v22,r10,$sp

	addi		r10,r10,32

	lvx		v23,r11,$sp

	addi		r11,r11,32

	lvx		v24,r10,$sp

	addi		r10,r10,32

	lvx		v25,r11,$sp

	addi		r11,r11,32

	lvx		v26,r10,$sp

	addi		r10,r10,32

	lvx		v27,r11,$sp

	addi		r11,r11,32

	lvx		v28,r10,$sp

	addi		r10,r10,32

	lvx		v29,r11,$sp

	addi		r11,r11,32

	lvx		v30,r10,$sp

	lvx		v31,r11,$sp

	$POP		r26,`$FRAME+21*16+0*$SIZE_T`($sp)

	$POP		r27,`$FRAME+21*16+1*$SIZE_T`($sp)

	$POP		r28,`$FRAME+21*16+2*$SIZE_T`($sp)

	$POP		r29,`$FRAME+21*16+3*$SIZE_T`($sp)

	$POP		r30,`$FRAME+21*16+4*$SIZE_T`($sp)

	$POP		r31,`$FRAME+21*16+5*$SIZE_T`($sp)

	addi		$sp,$sp,`$FRAME+21*16+6*$SIZE_T`

	blr

	.long		0

	.byte		0,12,0x04,1,0x80,6,6,0

	.long		0



.align	5

_aesp8_xts_enc5x:

	vcipher		$out0,$out0,v24

	vcipher		$out1,$out1,v24

	vcipher		$out2,$out2,v24

	vcipher		$out3,$out3,v24

	vcipher		$out4,$out4,v24

	lvx		v24,$x20,$key_		# round[3]

	addi		$key_,$key_,0x20



	vcipher		$out0,$out0,v25

	vcipher		$out1,$out1,v25

	vcipher		$out2,$out2,v25

	vcipher		$out3,$out3,v25

	vcipher		$out4,$out4,v25

	lvx		v25,$x10,$key_		# round[4]

	bdnz		_aesp8_xts_enc5x



	add		$inp,$inp,$taillen

	cmpwi		$taillen,0

	vcipher		$out0,$out0,v24

	vcipher		$out1,$out1,v24

	vcipher		$out2,$out2,v24

	vcipher		$out3,$out3,v24

	vcipher		$out4,$out4,v24



	subi		$inp,$inp,16

	vcipher		$out0,$out0,v25

	vcipher		$out1,$out1,v25

	vcipher		$out2,$out2,v25

	vcipher		$out3,$out3,v25

	vcipher		$out4,$out4,v25

	 vxor		$twk0,$twk0,v31



	vcipher		$out0,$out0,v26

	lvsr		$inpperm,r0,$taillen	# $in5 is no more

	vcipher		$out1,$out1,v26

	vcipher		$out2,$out2,v26

	vcipher		$out3,$out3,v26

	vcipher		$out4,$out4,v26

	 vxor		$in1,$twk1,v31



	vcipher		$out0,$out0,v27

	lvx_u		$in0,0,$inp

	vcipher		$out1,$out1,v27

	vcipher		$out2,$out2,v27

	vcipher		$out3,$out3,v27

	vcipher		$out4,$out4,v27

	 vxor		$in2,$twk2,v31



	addi		$key_,$sp,$FRAME+15	# rewind $key_

	vcipher		$out0,$out0,v28

	vcipher		$out1,$out1,v28

	vcipher		$out2,$out2,v28

	vcipher		$out3,$out3,v28

	vcipher		$out4,$out4,v28

	lvx		v24,$x00,$key_		# re-pre-load round[1]

	 vxor		$in3,$twk3,v31



	vcipher		$out0,$out0,v29

	le?vperm	$in0,$in0,$in0,$leperm

	vcipher		$out1,$out1,v29

	vcipher		$out2,$out2,v29

	vcipher		$out3,$out3,v29

	vcipher		$out4,$out4,v29

	lvx		v25,$x10,$key_		# re-pre-load round[2]

	 vxor		$in4,$twk4,v31



	vcipher		$out0,$out0,v30

	vperm		$in0,$in0,$in0,$inpperm

	vcipher		$out1,$out1,v30

	vcipher		$out2,$out2,v30

	vcipher		$out3,$out3,v30

	vcipher		$out4,$out4,v30



	vcipherlast	$out0,$out0,$twk0

	vcipherlast	$out1,$out1,$in1

	vcipherlast	$out2,$out2,$in2

	vcipherlast	$out3,$out3,$in3

	vcipherlast	$out4,$out4,$in4

	blr

        .long   	0

        .byte   	0,12,0x14,0,0,0,0,0



.align	5

_aesp8_xts_decrypt6x:

	$STU		$sp,-`($FRAME+21*16+6*$SIZE_T)`($sp)

	mflr		r11

	li		r7,`$FRAME+8*16+15`

	li		r3,`$FRAME+8*16+31`

	$PUSH		r11,`$FRAME+21*16+6*$SIZE_T+$LRSAVE`($sp)

	stvx		v20,r7,$sp		# ABI says so

	addi		r7,r7,32

	stvx		v21,r3,$sp

	addi		r3,r3,32

	stvx		v22,r7,$sp

	addi		r7,r7,32

	stvx		v23,r3,$sp

	addi		r3,r3,32

	stvx		v24,r7,$sp

	addi		r7,r7,32

	stvx		v25,r3,$sp

	addi		r3,r3,32

	stvx		v26,r7,$sp

	addi		r7,r7,32

	stvx		v27,r3,$sp

	addi		r3,r3,32

	stvx		v28,r7,$sp

	addi		r7,r7,32

	stvx		v29,r3,$sp

	addi		r3,r3,32

	stvx		v30,r7,$sp

	stvx		v31,r3,$sp

	li		r0,-1

	stw		$vrsave,`$FRAME+21*16-4`($sp)	# save vrsave

	li		$x10,0x10

	$PUSH		r26,`$FRAME+21*16+0*$SIZE_T`($sp)

	li		$x20,0x20

	$PUSH		r27,`$FRAME+21*16+1*$SIZE_T`($sp)

	li		$x30,0x30

	$PUSH		r28,`$FRAME+21*16+2*$SIZE_T`($sp)

	li		$x40,0x40

	$PUSH		r29,`$FRAME+21*16+3*$SIZE_T`($sp)

	li		$x50,0x50

	$PUSH		r30,`$FRAME+21*16+4*$SIZE_T`($sp)

	li		$x60,0x60

	$PUSH		r31,`$FRAME+21*16+5*$SIZE_T`($sp)

	li		$x70,0x70

	mtspr		256,r0



	subi		$rounds,$rounds,3	# -4 in total



	lvx		$rndkey0,$x00,$key1	# load key schedule

	lvx		v30,$x10,$key1

	addi		$key1,$key1,0x20

	lvx		v31,$x00,$key1

	?vperm		$rndkey0,$rndkey0,v30,$keyperm

	addi		$key_,$sp,$FRAME+15

	mtctr		$rounds



Load_xts_dec_key:

	?vperm		v24,v30,v31,$keyperm

	lvx		v30,$x10,$key1

	addi		$key1,$key1,0x20

	stvx		v24,$x00,$key_		# off-load round[1]

	?vperm		v25,v31,v30,$keyperm

	lvx		v31,$x00,$key1

	stvx		v25,$x10,$key_		# off-load round[2]

	addi		$key_,$key_,0x20

	bdnz		Load_xts_dec_key



	lvx		v26,$x10,$key1

	?vperm		v24,v30,v31,$keyperm

	lvx		v27,$x20,$key1

	stvx		v24,$x00,$key_		# off-load round[3]

	?vperm		v25,v31,v26,$keyperm

	lvx		v28,$x30,$key1

	stvx		v25,$x10,$key_		# off-load round[4]

	addi		$key_,$sp,$FRAME+15	# rewind $key_

	?vperm		v26,v26,v27,$keyperm

	lvx		v29,$x40,$key1

	?vperm		v27,v27,v28,$keyperm

	lvx		v30,$x50,$key1

	?vperm		v28,v28,v29,$keyperm

	lvx		v31,$x60,$key1

	?vperm		v29,v29,v30,$keyperm

	lvx		$twk5,$x70,$key1	# borrow $twk5

	?vperm		v30,v30,v31,$keyperm

	lvx		v24,$x00,$key_		# pre-load round[1]

	?vperm		v31,v31,$twk5,$keyperm

	lvx		v25,$x10,$key_		# pre-load round[2]



	 vperm		$in0,$inout,$inptail,$inpperm

	 subi		$inp,$inp,31		# undo "caller"

	vxor		$twk0,$tweak,$rndkey0

	vsrab		$tmp,$tweak,$seven	# next tweak value

	vaddubm		$tweak,$tweak,$tweak

	vsldoi		$tmp,$tmp,$tmp,15

	vand		$tmp,$tmp,$eighty7

	 vxor		$out0,$in0,$twk0

	vxor		$tweak,$tweak,$tmp



	 lvx_u		$in1,$x10,$inp

	vxor		$twk1,$tweak,$rndkey0

	vsrab		$tmp,$tweak,$seven	# next tweak value

	vaddubm		$tweak,$tweak,$tweak

	vsldoi		$tmp,$tmp,$tmp,15

	 le?vperm	$in1,$in1,$in1,$leperm

	vand		$tmp,$tmp,$eighty7

	 vxor		$out1,$in1,$twk1

	vxor		$tweak,$tweak,$tmp



	 lvx_u		$in2,$x20,$inp

	 andi.		$taillen,$len,15

	vxor		$twk2,$tweak,$rndkey0

	vsrab		$tmp,$tweak,$seven	# next tweak value

	vaddubm		$tweak,$tweak,$tweak

	vsldoi		$tmp,$tmp,$tmp,15

	 le?vperm	$in2,$in2,$in2,$leperm

	vand		$tmp,$tmp,$eighty7

	 vxor		$out2,$in2,$twk2

	vxor		$tweak,$tweak,$tmp



	 lvx_u		$in3,$x30,$inp

	 sub		$len,$len,$taillen

	vxor		$twk3,$tweak,$rndkey0

	vsrab		$tmp,$tweak,$seven	# next tweak value

	vaddubm		$tweak,$tweak,$tweak

	vsldoi		$tmp,$tmp,$tmp,15

	 le?vperm	$in3,$in3,$in3,$leperm

	vand		$tmp,$tmp,$eighty7

	 vxor		$out3,$in3,$twk3

	vxor		$tweak,$tweak,$tmp



	 lvx_u		$in4,$x40,$inp

	 subi		$len,$len,0x60

	vxor		$twk4,$tweak,$rndkey0

	vsrab		$tmp,$tweak,$seven	# next tweak value

	vaddubm		$tweak,$tweak,$tweak

	vsldoi		$tmp,$tmp,$tmp,15

	 le?vperm	$in4,$in4,$in4,$leperm

	vand		$tmp,$tmp,$eighty7

	 vxor		$out4,$in4,$twk4

	vxor		$tweak,$tweak,$tmp



	 lvx_u		$in5,$x50,$inp

	 addi		$inp,$inp,0x60

	vxor		$twk5,$tweak,$rndkey0

	vsrab		$tmp,$tweak,$seven	# next tweak value

	vaddubm		$tweak,$tweak,$tweak

	vsldoi		$tmp,$tmp,$tmp,15

	 le?vperm	$in5,$in5,$in5,$leperm

	vand		$tmp,$tmp,$eighty7

	 vxor		$out5,$in5,$twk5

	vxor		$tweak,$tweak,$tmp



	vxor		v31,v31,$rndkey0

	mtctr		$rounds

	b		Loop_xts_dec6x



.align	5

Loop_xts_dec6x:

	vncipher	$out0,$out0,v24

	vncipher	$out1,$out1,v24

	vncipher	$out2,$out2,v24

	vncipher	$out3,$out3,v24

	vncipher	$out4,$out4,v24

	vncipher	$out5,$out5,v24

	lvx		v24,$x20,$key_		# round[3]

	addi		$key_,$key_,0x20



	vncipher	$out0,$out0,v25

	vncipher	$out1,$out1,v25

	vncipher	$out2,$out2,v25

	vncipher	$out3,$out3,v25

	vncipher	$out4,$out4,v25

	vncipher	$out5,$out5,v25

	lvx		v25,$x10,$key_		# round[4]

	bdnz		Loop_xts_dec6x



 $len-=96

 xor with last round key

 next tweak value

 borrow?-1:0

 next tweak value

 $inp is adjusted in such

 way that at exit from the

 loop inX-in5 are loaded

 with last "words"

 next tweak value

 rewind $key_

 next tweak value

 re-pre-load round[1]

 next tweak value

 re-pre-load round[2]

 next tweak value

 load next input block

 store output

	beq		Loop_xts_dec6x		# did $len-=96 borrow?



	addic.		$len,$len,0x60

	beq		Lxts_dec6x_zero

	cmpwi		$len,0x20

	blt		Lxts_dec6x_one

	nop

	beq		Lxts_dec6x_two

	cmpwi		$len,0x40

	blt		Lxts_dec6x_three

	nop

	beq		Lxts_dec6x_four



Lxts_dec6x_five:

	vxor		$out0,$in1,$twk0

	vxor		$out1,$in2,$twk1

	vxor		$out2,$in3,$twk2

	vxor		$out3,$in4,$twk3

	vxor		$out4,$in5,$twk4



	bl		_aesp8_xts_dec5x



	le?vperm	$out0,$out0,$out0,$leperm

	vmr		$twk0,$twk5		# unused tweak

	vxor		$twk1,$tweak,$rndkey0

	le?vperm	$out1,$out1,$out1,$leperm

	stvx_u		$out0,$x00,$out		# store output

	vxor		$out0,$in0,$twk1

	le?vperm	$out2,$out2,$out2,$leperm

	stvx_u		$out1,$x10,$out

	le?vperm	$out3,$out3,$out3,$leperm

	stvx_u		$out2,$x20,$out

	le?vperm	$out4,$out4,$out4,$leperm

	stvx_u		$out3,$x30,$out

	stvx_u		$out4,$x40,$out

	addi		$out,$out,0x50

	bne		Lxts_dec6x_steal

	b		Lxts_dec6x_done



.align	4

Lxts_dec6x_four:

	vxor		$out0,$in2,$twk0

	vxor		$out1,$in3,$twk1

	vxor		$out2,$in4,$twk2

	vxor		$out3,$in5,$twk3

	vxor		$out4,$out4,$out4



	bl		_aesp8_xts_dec5x



	le?vperm	$out0,$out0,$out0,$leperm

	vmr		$twk0,$twk4		# unused tweak

	vmr		$twk1,$twk5

	le?vperm	$out1,$out1,$out1,$leperm

	stvx_u		$out0,$x00,$out		# store output

	vxor		$out0,$in0,$twk5

	le?vperm	$out2,$out2,$out2,$leperm

	stvx_u		$out1,$x10,$out

	le?vperm	$out3,$out3,$out3,$leperm

	stvx_u		$out2,$x20,$out

	stvx_u		$out3,$x30,$out

	addi		$out,$out,0x40

	bne		Lxts_dec6x_steal

	b		Lxts_dec6x_done



.align	4

Lxts_dec6x_three:

	vxor		$out0,$in3,$twk0

	vxor		$out1,$in4,$twk1

	vxor		$out2,$in5,$twk2

	vxor		$out3,$out3,$out3

	vxor		$out4,$out4,$out4



	bl		_aesp8_xts_dec5x



	le?vperm	$out0,$out0,$out0,$leperm

	vmr		$twk0,$twk3		# unused tweak

	vmr		$twk1,$twk4

	le?vperm	$out1,$out1,$out1,$leperm

	stvx_u		$out0,$x00,$out		# store output

	vxor		$out0,$in0,$twk4

	le?vperm	$out2,$out2,$out2,$leperm

	stvx_u		$out1,$x10,$out

	stvx_u		$out2,$x20,$out

	addi		$out,$out,0x30

	bne		Lxts_dec6x_steal

	b		Lxts_dec6x_done



.align	4

Lxts_dec6x_two:

	vxor		$out0,$in4,$twk0

	vxor		$out1,$in5,$twk1

	vxor		$out2,$out2,$out2

	vxor		$out3,$out3,$out3

	vxor		$out4,$out4,$out4



	bl		_aesp8_xts_dec5x



	le?vperm	$out0,$out0,$out0,$leperm

	vmr		$twk0,$twk2		# unused tweak

	vmr		$twk1,$twk3

	le?vperm	$out1,$out1,$out1,$leperm

	stvx_u		$out0,$x00,$out		# store output

	vxor		$out0,$in0,$twk3

	stvx_u		$out1,$x10,$out

	addi		$out,$out,0x20

	bne		Lxts_dec6x_steal

	b		Lxts_dec6x_done



.align	4

Lxts_dec6x_one:

	vxor		$out0,$in5,$twk0

	nop

Loop_xts_dec1x:

	vncipher	$out0,$out0,v24

	lvx		v24,$x20,$key_		# round[3]

	addi		$key_,$key_,0x20



	vncipher	$out0,$out0,v25

	lvx		v25,$x10,$key_		# round[4]

	bdnz		Loop_xts_dec1x



	subi		r0,$taillen,1

	vncipher	$out0,$out0,v24



	andi.		r0,r0,16

	cmpwi		$taillen,0

	vncipher	$out0,$out0,v25



	sub		$inp,$inp,r0

	vncipher	$out0,$out0,v26



	lvx_u		$in0,0,$inp

	vncipher	$out0,$out0,v27



	addi		$key_,$sp,$FRAME+15	# rewind $key_

	vncipher	$out0,$out0,v28

	lvx		v24,$x00,$key_		# re-pre-load round[1]



	vncipher	$out0,$out0,v29

	lvx		v25,$x10,$key_		# re-pre-load round[2]

	 vxor		$twk0,$twk0,v31



	le?vperm	$in0,$in0,$in0,$leperm

	vncipher	$out0,$out0,v30



	mtctr		$rounds

	vncipherlast	$out0,$out0,$twk0



	vmr		$twk0,$twk1		# unused tweak

	vmr		$twk1,$twk2

	le?vperm	$out0,$out0,$out0,$leperm

	stvx_u		$out0,$x00,$out		# store output

	addi		$out,$out,0x10

	vxor		$out0,$in0,$twk2

	bne		Lxts_dec6x_steal

	b		Lxts_dec6x_done



.align	4

Lxts_dec6x_zero:

	cmpwi		$taillen,0

	beq		Lxts_dec6x_done



	lvx_u		$in0,0,$inp

	le?vperm	$in0,$in0,$in0,$leperm

	vxor		$out0,$in0,$twk1

Lxts_dec6x_steal:

	vncipher	$out0,$out0,v24

	lvx		v24,$x20,$key_		# round[3]

	addi		$key_,$key_,0x20



	vncipher	$out0,$out0,v25

	lvx		v25,$x10,$key_		# round[4]

	bdnz		Lxts_dec6x_steal



	add		$inp,$inp,$taillen

	vncipher	$out0,$out0,v24



	cmpwi		$taillen,0

	vncipher	$out0,$out0,v25



	lvx_u		$in0,0,$inp

	vncipher	$out0,$out0,v26



	lvsr		$inpperm,0,$taillen	# $in5 is no more

	vncipher	$out0,$out0,v27



	addi		$key_,$sp,$FRAME+15	# rewind $key_

	vncipher	$out0,$out0,v28

	lvx		v24,$x00,$key_		# re-pre-load round[1]



	vncipher	$out0,$out0,v29

	lvx		v25,$x10,$key_		# re-pre-load round[2]

	 vxor		$twk1,$twk1,v31



	le?vperm	$in0,$in0,$in0,$leperm

	vncipher	$out0,$out0,v30



	vperm		$in0,$in0,$in0,$inpperm

	vncipherlast	$tmp,$out0,$twk1



	le?vperm	$out0,$tmp,$tmp,$leperm

	le?stvx_u	$out0,0,$out

	be?stvx_u	$tmp,0,$out



	vxor		$out0,$out0,$out0

	vspltisb	$out1,-1

	vperm		$out0,$out0,$out1,$inpperm

	vsel		$out0,$in0,$tmp,$out0

	vxor		$out0,$out0,$twk0



	subi		r30,$out,1

	mtctr		$taillen

Loop_xts_dec6x_steal:

	lbzu		r0,1(r30)

	stb		r0,16(r30)

	bdnz		Loop_xts_dec6x_steal



	li		$taillen,0

	mtctr		$rounds

	b		Loop_xts_dec1x		# one more time...



.align	4

Lxts_dec6x_done:

	${UCMP}i	$ivp,0

	beq		Lxts_dec6x_ret



	vxor		$tweak,$twk0,$rndkey0

	le?vperm	$tweak,$tweak,$tweak,$leperm

	stvx_u		$tweak,0,$ivp



Lxts_dec6x_ret:

	mtlr		r11

	li		r10,`$FRAME+15`

	li		r11,`$FRAME+31`

	stvx		$seven,r10,$sp		# wipe copies of round keys

	addi		r10,r10,32

	stvx		$seven,r11,$sp

	addi		r11,r11,32

	stvx		$seven,r10,$sp

	addi		r10,r10,32

	stvx		$seven,r11,$sp

	addi		r11,r11,32

	stvx		$seven,r10,$sp

	addi		r10,r10,32

	stvx		$seven,r11,$sp

	addi		r11,r11,32

	stvx		$seven,r10,$sp

	addi		r10,r10,32

	stvx		$seven,r11,$sp

	addi		r11,r11,32



	mtspr		256,$vrsave

	lvx		v20,r10,$sp		# ABI says so

	addi		r10,r10,32

	lvx		v21,r11,$sp

	addi		r11,r11,32

	lvx		v22,r10,$sp

	addi		r10,r10,32

	lvx		v23,r11,$sp

	addi		r11,r11,32

	lvx		v24,r10,$sp

	addi		r10,r10,32

	lvx		v25,r11,$sp

	addi		r11,r11,32

	lvx		v26,r10,$sp

	addi		r10,r10,32

	lvx		v27,r11,$sp

	addi		r11,r11,32

	lvx		v28,r10,$sp

	addi		r10,r10,32

	lvx		v29,r11,$sp

	addi		r11,r11,32

	lvx		v30,r10,$sp

	lvx		v31,r11,$sp

	$POP		r26,`$FRAME+21*16+0*$SIZE_T`($sp)

	$POP		r27,`$FRAME+21*16+1*$SIZE_T`($sp)

	$POP		r28,`$FRAME+21*16+2*$SIZE_T`($sp)

	$POP		r29,`$FRAME+21*16+3*$SIZE_T`($sp)

	$POP		r30,`$FRAME+21*16+4*$SIZE_T`($sp)

	$POP		r31,`$FRAME+21*16+5*$SIZE_T`($sp)

	addi		$sp,$sp,`$FRAME+21*16+6*$SIZE_T`

	blr

	.long		0

	.byte		0,12,0x04,1,0x80,6,6,0

	.long		0



.align	5

_aesp8_xts_dec5x:

	vncipher	$out0,$out0,v24

	vncipher	$out1,$out1,v24

	vncipher	$out2,$out2,v24

	vncipher	$out3,$out3,v24

	vncipher	$out4,$out4,v24

	lvx		v24,$x20,$key_		# round[3]

	addi		$key_,$key_,0x20



	vncipher	$out0,$out0,v25

	vncipher	$out1,$out1,v25

	vncipher	$out2,$out2,v25

	vncipher	$out3,$out3,v25

	vncipher	$out4,$out4,v25

	lvx		v25,$x10,$key_		# round[4]

	bdnz		_aesp8_xts_dec5x



	subi		r0,$taillen,1

	vncipher	$out0,$out0,v24

	vncipher	$out1,$out1,v24

	vncipher	$out2,$out2,v24

	vncipher	$out3,$out3,v24

	vncipher	$out4,$out4,v24



	andi.		r0,r0,16

	cmpwi		$taillen,0

	vncipher	$out0,$out0,v25

	vncipher	$out1,$out1,v25

	vncipher	$out2,$out2,v25

	vncipher	$out3,$out3,v25

	vncipher	$out4,$out4,v25

	 vxor		$twk0,$twk0,v31



	sub		$inp,$inp,r0

	vncipher	$out0,$out0,v26

	vncipher	$out1,$out1,v26

	vncipher	$out2,$out2,v26

	vncipher	$out3,$out3,v26

	vncipher	$out4,$out4,v26

	 vxor		$in1,$twk1,v31



	vncipher	$out0,$out0,v27

	lvx_u		$in0,0,$inp

	vncipher	$out1,$out1,v27

	vncipher	$out2,$out2,v27

	vncipher	$out3,$out3,v27

	vncipher	$out4,$out4,v27

	 vxor		$in2,$twk2,v31



	addi		$key_,$sp,$FRAME+15	# rewind $key_

	vncipher	$out0,$out0,v28

	vncipher	$out1,$out1,v28

	vncipher	$out2,$out2,v28

	vncipher	$out3,$out3,v28

	vncipher	$out4,$out4,v28

	lvx		v24,$x00,$key_		# re-pre-load round[1]

	 vxor		$in3,$twk3,v31



	vncipher	$out0,$out0,v29

	le?vperm	$in0,$in0,$in0,$leperm

	vncipher	$out1,$out1,v29

	vncipher	$out2,$out2,v29

	vncipher	$out3,$out3,v29

	vncipher	$out4,$out4,v29

	lvx		v25,$x10,$key_		# re-pre-load round[2]

	 vxor		$in4,$twk4,v31



	vncipher	$out0,$out0,v30

	vncipher	$out1,$out1,v30

	vncipher	$out2,$out2,v30

	vncipher	$out3,$out3,v30

	vncipher	$out4,$out4,v30



	vncipherlast	$out0,$out0,$twk0

	vncipherlast	$out1,$out1,$in1

	vncipherlast	$out2,$out2,$in2

	vncipherlast	$out3,$out3,$in3

	vncipherlast	$out4,$out4,$in4

	mtctr		$rounds

	blr

        .long   	0

        .byte   	0,12,0x14,0,0,0,0,0

___

}}	}}}



1;

 constants table endian-specific conversion

	    my $conv=$3;

();

 convert to endian-agnostic format

		my $l = /^0/?oct:int;

		push @bytes,($l>>24)&0xff,($l>>16)&0xff,($l>>8)&0xff,$l&0xff;

	      }

	    } else {

 map(/^0/?oct:int,split(/,\s*/,$2));

 little-endian conversion

	    if ($flavour =~ /le$/o) {

		SWITCH: for($conv)  {

map($_^0xf,@bytes); last; };

		    /\?rev/ && do   { @bytes=reverse(@bytes);    last; };

		}

	    }



	    #emit

	    print ".byte\t",join(',',map (sprintf("0x%02x",$_),@bytes)),"\n";

	    next;

	}

 end of table

 instructions prefixed with '?' are endian-specific and need

 to be adjusted accordingly...

	if ($flavour =~ /le$/o) {	# little-endian

	    s/le\?//o		or

	    s/be\?/#be#/o	or

	    s/\?lvsr/lvsl/o	or

	    s/\?lvsl/lvsr/o	or

	    s/\?(vperm\s+v[0-9]+,\s*)(v[0-9]+,\s*)(v[0-9]+,\s*)(v[0-9]+)/$1$3$2$4/o or

	    s/\?(vsldoi\s+v[0-9]+,\s*)(v[0-9]+,)\s*(v[0-9]+,\s*)([0-9]+)/$1$3$2 16-$4/o or

	    s/\?(vspltw\s+v[0-9]+,\s*)(v[0-9]+,)\s*([0-9])/$1$2 3-$3/o;

	} else {			# big-endian

	    s/le\?/#le#/o	or

	    s/be\?//o		or

	    s/\?([a-z]+)/$1/o;

	}



        print $_,"\n";

}



close STDOUT;

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0

 PowerPC assembler distiller by <appro>.

my $flavour = shift;

 shift;

($flavour
 directives which need special treatment on different platforms

my $globl = sub {

 shift;

    my $name = shift;

 \$GLOBALS{$name};

    $name =~ s|^[\.\_]||;

 

    SWITCH: for ($flavour) {

 ".$name";

	/osx/		&& do { $name = "_$name";

				last;

			      };

	/linux/

 "_GLOBAL($name)";

    $ret = ".globl	$name\nalign 5\n$name:" if (!$ret);

 $name;

my $text = sub {

    my $ret = ($flavour =~ /aix/) ? ".csect\t.text[PR],7" : ".text";

    $ret = ".abiversion	2\n".$ret	if ($flavour =~ /linux.*64le/);

    $ret;

};

 sub {

    my $junk = shift;

 shift;

    if ($flavour =~ /osx/)

~ s/\"//g;

 ($flavour
my $size = sub {

~ /linux/)

 shift; $name 
 ".size	$name,.-".($flavour
 "\n.size	.$name,.-.$name" if ($flavour
my $asciz = sub {

    shift;

 join(",",@_);

    if ($line =~ /^"(.*)"$/)

    {	".byte	" . join(",",unpack("C*",$1),0) . "\n.align	2";	}

    else

    {	"";	}

};

 sub {

$1?"0x$1":"0"; $lo
 error-prone with 32-bit perl
$1&0xffffffff;  } # error-prone with 32-bit perl

undef; $lo
	{  push(@ret,$flavour=~/le$/o?".long\t$lo,$hi":".long\t$hi,$lo");  }

	else

	{  push(@ret,".quad	$lo");  }

    }

    join("\n",@ret);

};



################################################################

# simplified mnemonics not handled by at least one assembler

################################################################

 sub {

    my $f = shift;

    my $cr = 0; $cr = shift if ($#_>1);

    # Some out-of-date 32-bit GNU assembler just can't handle cmplw...

~ /linux.*32/) ?

my $bdnz = sub {

 shift;

 optional "to be taken" hint
~/[\+\-]/ ? 16+9 : 16;	# optional "to be taken" hint

my $bltlr = sub {

 shift;

 optional "not to be taken" hint
~/\-/ ? 12+2 : 12;	# optional "not to be taken" hint

    ($flavour =~ /linux/) ?		# GNU as doesn't allow most recent hints

	"	.long	".sprintf "0x%x",19<<26|$bo<<21|16<<1 :

	"	bclr	$bo,0";

};

 sub {

    my $f = shift;

    my $bo = $f=~/\-/ ? 4+2 : 4;	# optional "not to be taken" hint

 GNU as doesn't allow most recent hints

my $beqlr = sub {

 shift;

 optional "not to be taken" hint
~/-/ ? 12+2 : 12;	# optional "not to be taken" hint

    ($flavour =~ /linux/) ?		# GNU as doesn't allow most recent hints

	"	.long	".sprintf "0x%X",19<<26|$bo<<21|2<<16|16<<1 :

	"	bclr	$bo,2";

};

# GNU assembler can't handle extrdi rA,rS,16,48, or when sum of last two

# arguments is 64, with "operand out of range" error.

 sub {

    my ($f,$ra,$rs,$n,$b) = @_;

    $b = ($b+$n)&63; $n = 64-$n;

    "	rldicl	$ra,$rs,$b,$n";

};

 sub {

    my ($f,$vx,$vy) = @_;

    "	vor	$vx,$vy,$vy";

};



# Some ABIs specify vrsave, special-purpose register #256, as reserved

# for system use.

my $no_vrsave = ($flavour =~ /linux-ppc64le/);

 sub {

    my ($f,$idx,$ra) = @_;

    if ($idx == 256 && $no_vrsave) {

	"	or	$ra,$ra,$ra";

    } else {

	"	mtspr	$idx,$ra";

    }

};

 sub {

    my ($f,$rd,$idx) = @_;

    if ($idx == 256 && $no_vrsave) {

	"	li	$rd,-1";

    } else {

	"	mfspr	$rd,$idx";

    }

};



# PowerISA 2.06 stuff

sub vsxmem_op {

 @_;

 made-up unaligned memory reference AltiVec/VMX instructions

my $lvx_u	= sub {	vsxmem_op(@_, 844); };	# lxvd2x

 stxvd2x

my $lvdx_u	= sub {	vsxmem_op(@_, 588); };	# lxsdx

 stxsdx

my $lvx_4w	= sub { vsxmem_op(@_, 780); };	# lxvw4x

 stxvw4x

 PowerISA 2.07 stuff

    my ($f, $vrt, $vra, $vrb, $op) = @_;

    "	.long	".sprintf "0x%X",(4<<26)|($vrt<<21)|($vra<<16)|($vrb<<11)|$op;

}

 sub { vcrypto_op(@_, 1288); };

my $vcipherlast	= sub { vcrypto_op(@_, 1289); };

 sub { vcrypto_op(@_, 1352); };

my $vncipherlast= sub { vcrypto_op(@_, 1353); };

 sub { vcrypto_op(@_, 0, 1480); };

 sub { my ($st,$six)
 sub { my ($st,$six)
my $vpmsumb	= sub { vcrypto_op(@_, 1032); };

 sub { vcrypto_op(@_, 1224); };

my $vpmsubh	= sub { vcrypto_op(@_, 1096); };

 sub { vcrypto_op(@_, 1160); };

my $vaddudm	= sub { vcrypto_op(@_, 192);  };

 sub { vcrypto_op(@_, 256);  };

my $mtsle	= sub {

 @_;

print "#include <asm/ppc_asm.h>\n" if $flavour =~ /linux/;



<>) {

    $line =~ s|[#!;].*$||;	# get rid of asm-style comments...

 ... and C-style comments...

    $line =~ s|^\s+||;		# ... and skip white spaces in beginning...

 ... and at the end

	$line =~ s|\b\.L(\w+)|L$1|g;	# common denominator for Locallabel

~ s|\bL(\w+)|\.L$1|g	if ($dotinlocallabels);

	$line =~ s|^\s*(\.?)(\w+)([\.\+\-]?)\s*||;

	my $c = $1; $c = "\t" if ($c eq "");

 $2;

	my $f = $3;

 eval("\$$mnemonic");

	$line =~ s/\b(c?[rf]|v|vs)([0-9]+)\b/$2/g if ($c ne "." and $flavour !~ /osx/);

 &$opcode($f,split(',',$line)); }

	elsif ($mnemonic)           { $line = $c.$mnemonic.$f."\t".$line; }

    }



    print $line if ($line);

    print "\n";

}



close STDOUT;

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0-only



 (c) 2017 Tobin C. Harding <me@tobin.cc>



 leaking_addresses.pl: Scan the kernel for potential leaking addresses.

  - Scans dmesg output.

  - Walks directory tree and parses each file (for each directory in @DIRS).



 Use --debug to output path before parsing, this is useful to find files that

 cause the script to choke.



 When the system is idle it is likely that most files under /proc/PID will be

 identical for various processes.  Scanning _all_ the PIDs under /proc is

 unnecessary and implies that we are thoroughly scanning /proc.  This is _not_

 the case because there may be ways userspace can trigger creation of /proc

 files that leak addresses but were not present during a scan.  For these two

 reasons we exclude all PID directories under /proc except '1/'

my $P = $0;



# Directories to scan.

 ('/proc', '/sys');

 Timer for parsing each file, in seconds.

my $TIMEOUT = 10;



# Kernel addresses vary by architecture.  We can only auto-detect the following

# architectures (using `uname -m`).  (flag --32-bit overrides auto-detection.)

 ('x86_64', 'ppc64', 'x86');

 Command line options.

my $help = 0;

 0;

my $raw = 0;

 Write raw results to file.

my $input_raw = "";	# Read raw results from file instead of scanning.

 Don't show dmesg in output.

my $squash_by_path = 0;		# Summary report grouped by absolute path.

 Summary report grouped by filename.

my $kernel_config_file = "";	# Kernel configuration file.

 Scan 32-bit kernel.

my $page_offset_32bit = 0;	# Page offset for 32-bit kernel.



# Skip these absolute paths.

 (

 Skip these under any subdirectory.

my @skip_any = (

	'pagemap',

	'events',

	'access',

	'registers',

	'snapshot_raw',

	'trace_pipe_raw',

	'ptmx',

	'trace_pipe',

	'fd',

	'usbmon');



sub help

{

 @_;

	-o, --output-raw=<file>		Save results for future processing.

<file>		Read results from file instead of scanning.

	--kernel-config-file=<file>     Kernel configuration file (e.g /boot/config)

	--32-bit			Scan 32-bit kernel.

o		Page offset (for 32-bit kernel 0xABCD1234).

	'd|debug'		=> \$debug,

> \$help,

s'        
s'         
	'suppress-dmesg'        => \$suppress_dmesg,

> \$squash_by_path,

	'squash-by-filename'    => \$squash_by_filename,

> \$raw,

s'	
	'32-bit'		=> \$opt_32bit,

	'page-offset-32-bit=o'	=> \$page_offset_32bit,

) or help(1);



help(0) if ($help);



if ($input_raw) {

	format_output($input_raw);

	exit(0);

}



if (!$input_raw and ($squash_by_path or $squash_by_filename)) {

<file>\n";

	printf "(First run scan with --output-raw=<file>.)\n";

	exit(128);

}



if (!(is_supported_architecture() or $opt_32bit or $page_offset_32bit)) {

	printf "\nScript does not support your architecture, sorry.\n";

	printf "\nCurrently we support: \n\n";

	foreach(@SUPPORTED_ARCHITECTURES) {

		printf "\t%s\n", $_;

	}

	printf("\n");



	printf("If you are running a 32-bit architecture you may use:\n");

<page offset>\n\n");

	my $archname = `uname -m`;

	printf("Machine hardware name (`uname -m`): %s\n", $archname);



	exit(129);

}



if ($output_raw) {

	open my $fh, '>', $output_raw or die "$0: $output_raw: $!\n";

	select $fh;

}



parse_dmesg();

walk(@DIRS);



exit 0;



sub dprint

{

	printf(STDERR @_) if $debug;

}



sub is_supported_architecture

{

	return (is_x86_64() or is_ppc64() or is_ix86_32());

}



sub is_32bit

{

	# Allow --32-bit or --page-offset-32-bit to override

	if ($opt_32bit or $page_offset_32bit) {

		return 1;

	}



	return is_ix86_32();

}



sub is_ix86_32

{

 `uname -m`;

       if ($arch =~ m/i[3456]86/) {

               return 1;

       }

       return 0;

}



sub is_arch

{

 @_;

       my $arch = `uname -m`;



       chomp $arch;

       if ($arch eq $desc) {

               return 1;

       }

       return 0;

}



sub is_x86_64

{

 is_arch('x86_64');

	state $is = is_arch('ppc64');

	return $is;

}



# Gets config option value from kernel config file.

# Returns "" on error or if config option not found.

sub get_kernel_config_option

{

 @_;

	my $value = "";

 "";

 Allow --kernel-config-file to override.

		@config_files = ($kernel_config_file);

	} elsif (-R "/proc/config.gz") {

 "/tmp/tmpkconf";

			@config_files = ($tmp_file);

		}

	} else {

 '/boot/config-' . `uname -r`;

		@config_files = ($file, '/boot/config');

	}



	foreach my $file (@config_files) {

		dprint("parsing config file: $file\n");

 option_from_file($option, $file);

 Parses $file and returns kernel configuration option value.

	my ($option, $file) = @_;

 "";

	my $val = "";



	open(my $fh, "<", $file) or return "";

 <$fh> ) {

		if ($line =~ /^$option/) {

			($str, $val) = split /=/, $line;

			chomp $val;

			last;

		}

	}



	close $fh;

	return $val;

}



sub is_false_positive

{

 @_;

 64 bit false positives.

	if ($match =~ '\b(0x)?(f|F){16}\b' or

~ '\b(0x)?0{16}\b') {

       my ($match) = @_;

 get_page_offset();

       if ($match =~ '\b(0x)?(f|F){8}\b') {

               return 1;

       }



       if (hex($match) < $page_offset) {

               return 1;

       }



       return 0;

}



# returns integer value

sub get_page_offset

{

       my $page_offset;

 0xc0000000;

 Allow --page-offset-32bit to override.

       if ($page_offset_32bit != 0) {

               return $page_offset_32bit;

       }



 get_kernel_config_option('CONFIG_PAGE_OFFSET');

	my ($match) = @_;



 hex($match);

	my $region_min = hex("0xffffffffff600000");

 hex("0xffffffffff601000");

 $region_min and $hex <
 True if argument potentially contains a kernel address.

	my ($line) = @_;

	my $address_re;



	# Signal masks.

~ '^SigBlk:' or

	    $line =~ '^SigIgn:' or

~ '^SigCgt:') {

~ '\bKEY
	    $line =~ '\b[[:xdigit:]]{14} [[:xdigit:]]{16} [[:xdigit:]]{16}\b') {

		return 0;

	}



 get_address_re();

	while ($line =~ /($address_re)/g) {

		if (!is_false_positive($1)) {

			return 1;

		}

	}



	return 0;

}



sub get_address_re

{

	if (is_ppc64()) {

		return '\b(0x)?[89abcdef]00[[:xdigit:]]{13}\b';

	} elsif (is_32bit()) {

		return '\b(0x)?[[:xdigit:]]{8}\b';

	}



	return get_x86_64_re();

}



sub get_x86_64_re

{

	# We handle page table levels but only if explicitly configured using

	# CONFIG_PGTABLE_LEVELS.  If config file parsing fails or config option

	# is not found we default to using address regular expression suitable

	# for 4 page table levels.

 get_kernel_config_option('CONFIG_PGTABLE_LEVELS');

 True if we should skip this path.

	my ($path) = @_;



	foreach (@skip_abs) {

		return 1 if (/^$path$/);

	}



 fileparse($path);

	my ($file) = @_;



	eval {

 NB: \n required.

 Propagate unexpected errors.

	my ($file) = @_;



	if (! -R $file) {

		return;

	}



	if (! -T $file) {

		return;

	}



	open my $fh, "<", $file or return;

	while ( <$fh> ) {

		chomp;

		if (may_leak_address($_)) {

			printf("$file: $_\n");

		}

	}

	close $fh;

}



# Checks if the actual path name is leaking a kernel address.

sub check_path_for_leaks

{

 @_;

 Recursively walk directory tree.

	my @dirs = @_;



 shift @dirs) {

		my @files = readdir(DIR);

		closedir(DIR);



		foreach my $file (@files) {

			next if ($file eq '.' or $file eq '..');



 "$pwd/$file";

 skip /proc/PID except /proc/1

			next if (($path =~ /^\/proc\/[0-9]+$/) &&

				 ($path !~ /^\/proc\/1$/));



			next if (skip($path));



			check_path_for_leaks($path);



			if (-d $path) {

				push @dirs, $path;

				next;

			}



			dprint("parsing: $path\n");

			timed_parse_file($path);

		}

	}

}



sub format_output

{

 @_;

 Default is to show raw results.

	my ($total, $dmesg, $paths, $files) = parse_raw_file($file);



	printf "\nTotal number of results from scan (incl dmesg): %d\n", $total;



	if (!$suppress_dmesg) {

		print_dmesg($dmesg);

	}



	if ($squash_by_filename) {

		squash_by($files, 'filename');

	}



	if ($squash_by_path) {

		squash_by($paths, 'path');

	}

}



sub dump_raw_output

{

 @_;

	my ($file) = @_;



 Total number of lines parsed.

 dmesg output.

 Unique filenames containing leaks.

 Unique paths containing leaks.

	while (my $line = <$fh>) {

		$total++;



		if ("dmesg:" eq substr($line, 0, 6)) {

			push @dmesg, $line;

			next;

		}



		cache_path(\%paths, $line);

		cache_filename(\%files, $line);

	}



	return $total, \@dmesg, \%paths, \%files;

}



sub print_dmesg

{

 @_;

		my $index = index($_, ': ');

 skid ': '

	my ($ref, $desc) = @_;



	print "\nResults squashed by $desc (excl dmesg). ";

	print "Displaying [<number of results> <$desc>], <example result>\n";



	if (keys %$ref == 0) {

		print "<no results>\n";

		return;

	}



	foreach(keys %$ref) {

 $ref->{$_};

		my $length = @$lines;

		printf "[%d %s] %s", $length, $_, @$lines[0];

	}

}



sub cache_path

{

 @_;

	my $index = index($line, ': ');

 substr($line, 0, $index);

	$index += 2;            # skip ': '

	add_to_cache($paths, $path, substr($line, $index));

}



sub cache_filename

{

 @_;

	my $index = index($line, ': ');

 substr($line, 0, $index);

	my $filename = basename($path);



 skip ': '

	my ($cache, $key, $value) = @_;



	if (!$cache->{$key}) {

 ();

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0



 checkincludes: find/remove files included more than once



 Copyright abandoned, 2000, Niels Kristian Bech Jensen <nkbj@image.dk>.

 Copyright 2009 Luis R. Rodriguez <mcgrof@gmail.com>



 This script checks for duplicate includes. It also has support

 to remove them in place. Note that this will not take into

 consideration macros so you should run this only if you know

 you do have real dups and do not have them under 
 could also just review the results.

my $remove = 0;



if ($#ARGV < 0) {

	usage();

}



ARGV >= 1) {

	if ($ARGV[0] =~ /^-/) {

		if ($ARGV[0] eq "-r") {

 1;

my $dup_counter = 0;



foreach my $file (@ARGV) {

	open(my $f, '<', $file)

	    or die "Cannot open $file: $!.\n";



 ();

	my @file_lines = ();



	while (<$f>) {

		if (m/^\s*#\s*include\s*[<"](\S*)[>"]/o) {

			++$includedfiles{$1};

		}

		push(@file_lines, $_);

	}



	close($f);



	if (!$remove) {

		foreach my $filename (keys %includedfiles) {

			if ($includedfiles{$filename} > 1) {

				print "$file: $filename is included more than once.\n";

				++$dup_counter;

			}

		}

		next;

	}



	open($f, '>', $file)

	    or die("Cannot write to $file: $!");



 0;

\s*include\s*[<"](\S*)[>"]/o) {

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0-only

 (c) 2008, Steven Rostedt <srostedt@redhat.com>



 recordmcount.pl - makes a section called __mcount_loc that holds

                   all the offsets to the calls to mcount.





 What we want to end up with this is that each object file will have a

 section called __mcount_loc that will hold the list of pointers to mcount

 callers. After final linking, the vmlinux will have within .init.data the

 list of all callers to mcount between __start_mcount_loc and __stop_mcount_loc.

 Later on boot up, the kernel will read this list, save the locations and turn

 them into nops. When tracing or profiling is later enabled, these locations

 will then be converted back to pointers to some function.



 This is no easy feat. This script is called just after the original

 object is compiled and before it is linked.



 When parse this object file using 'objdump', the references to the call

 sites are offsets from the section that the call site is in. Hence, all

 functions in a section that has a call site to mcount, will have the

 offset from the beginning of the section and not the beginning of the

 function.



 But where this section will reside finally in vmlinx is undetermined at

 this point. So we can't use this kind of offsets to record the final

 address of this call site.



 The trick is to change the call offset referring the start of a section to

 referring a function symbol in this section. During the link step, 'ld' will

 compute the final address according to the information we record.



 e.g.



  .section ".sched.text", "ax"

        [...]

  func1:

        [...]

        call mcount  (offset: 0x10)

        [...]

        ret

  .globl fun2

  func2:             (offset: 0x20)

        [...]

        [...]

        ret

  func3:

        [...]

        call mcount (offset: 0x30)

        [...]



 Both relocation offsets for the mcounts in the above example will be

 offset from .sched.text. If we choose global symbol func2 as a reference and

 make another file called tmp.s with the new offsets:



  .section __mcount_loc

  .quad  func2 - 0x10

  .quad  func2 + 0x10



 We can then compile this tmp.s into tmp.o, and link it back to the original

 object.



 In our algorithm, we will choose the first global function we meet in this

 section as the reference. But this gets hard if there is no global functions

 in this section. In such a case we have to select a local one. E.g. func1:



  .section ".sched.text", "ax"

  func1:

        [...]

        call mcount  (offset: 0x10)

        [...]

        ret

  func2:

        [...]

        call mcount (offset: 0x20)

        [...]

  .section "other.section"



 If we make the tmp.s the same as above, when we link together with

 the original object, we will end up with two symbols for func1:

 one local, one global.  After final compile, we will end up with

 an undefined reference to func1 or a wrong reference to another global

 func1 in other files.



 Since local objects can reference local variables, we need to find

 a way to make tmp.o reference the local objects of the original object

 file after it is linked together. To do this, we convert func1

 into a global symbol before linking tmp.o. Then after we link tmp.o

 we will only have a single symbol for func1 that is global.

 We can convert func1 back into a local symbol and we are done.



 Here are the steps we take:



 1) Record all the local and weak symbols by using 'nm'

 2) Use objdump to find all the call site offsets and sections for

    mcount.

 3) Compile the list into its own object.

 4) Do we have to deal with local functions? If not, go to step 8.

 5) Make an object that converts these local functions to global symbols

    with objcopy.

 6) Link together this new object with the list object.

 7) Convert the local functions back to local symbols and rename

    the result as the original object.

 8) Link the object with the list object.

 9) Move the result back to the original object.



my $P = $0;

~ s@.*/@@g;

my $V = '0.1';



ARGV != 11) {

    $ld, $nm, $rm, $mv, $is_module, $inputfile) = @ARGV;



# This file refers to mcount and shouldn't be ftraced, so lets' ignore it

~ m,kernel/trace/ftrace\.o$,) {

 Acceptable sections to record.

my %text_sections = (

> 1,

     ".init.text" => 1,

> 1,

     ".sched.text" => 1,

> 1,

     ".irqentry.text" => 1,

> 1,

     ".kprobes.text" => 1,

> 1,

     ".text.unlikely" => 1,

);



# Acceptable section-prefixes to record.

 (

     ".text." => 1,

);



 Note: we are nice to C-programmers here, thus we skip the '||='-idiom.

$objdump = 'objdump' if (!$objdump);

 'objcopy' if (!$objcopy);

$cc = 'gcc' if (!$cc);

 'ld' if (!$ld);

$nm = 'nm' if (!$nm);

 'rm' if (!$rm);

$mv = 'mv' if (!$mv);



#print STDERR "running: $P '$arch' '$objdump' '$objcopy' '$cc' '$ld' " .

#    "'$nm' '$rm' '$mv' '$inputfile'\n";



my %locals;		# List of local (static) functions

my %weak;		# List of weak functions

my %convert;		# List of local functions used that needs conversion



my $type;

my $local_regex;	# Match a local function (return function)

my $weak_regex; 	# Match a weak function (return function)

my $section_regex;	# Find the start of a section

my $function_regex;	# Find the name of a function

			#    (return offset and func name)

my $mcount_regex;	# Find the call site to mcount (return offset)

my $mcount_adjust;	# Address adjustment to mcount offset

my $alignment;		# The .align value to use for $mcount_section

my $section_type;	# Section header plus possible alignment command



~ /(x86(_64)?)|(i386)/) {

	$arch = "x86_64";

    } else {

 "i386";



 We base the defaults off of i386, the other archs may

 feel free to change them in the below if statements.



$local_regex = "^[0-9a-fA-F]+\\s+t\\s+(\\S+)";

 "^[0-9a-fA-F]+\\s+([wW])\\s+(\\S+)";

$section_regex = "Disassembly of section\\s+(\\S+):";

 "^([0-9a-fA-F]+)\\s+<([^^]*?)>:";

$mcount_regex = "^\\s*([0-9a-fA-F]+):.*\\s(mcount|__fentry__)\$";

 '@progbits';

$mcount_adjust = 0;

 ".long";

    $mcount_regex = "^\\s*([0-9a-fA-F]+):.*\\s(mcount|__fentry__)([+-]0x[0-9a-zA-Z]+)?\$";

 ".quad";

    $alignment = 8;

 -1;

 force flags for this arch

    $ld .= " -m elf_x86_64";

 " -M x86-64";

    $objcopy .= " -O elf64-x86-64";

 " -m64";

    $alignment = 4;

 -1;

 force flags for this arch

    $ld .= " -m elf_i386";

 " -M i386";

    $objcopy .= " -O elf32-i386";

 " -m32";

    if ($cc =~ /-DCC_USING_HOTPATCH/) {

 "^\\s*([0-9a-fA-F]+):\\s*c0 04 00 00 00 00\\s*brcl\\s*0,[0-9a-f]+ <([^\+]*)>\$";

	$mcount_adjust = 0;

    }

 8;

    $type = ".quad";

 " -m elf64_s390";

    $cc .= " -m64";



} elsif ($arch eq "sh") {

 2;

 force flags for this arch

    $ld .= " -m shlelf_linux";

    if ($endian eq "big") {

 " -O elf32-shbig-linux";

	$objcopy .= " -O elf32-sh-linux";

    }



} elsif ($arch eq "powerpc") {

    my $ldemulation;



 "^[0-9a-fA-F]+\\s+t\\s+(\\.?\\S+)";

 See comment in the sparc64 section for why we use '\w'.

    $function_regex = "^([0-9a-fA-F]+)\\s+<(\\.?\\w*?)>:";

 "^\\s*([0-9a-fA-F]+):.*\\s\\.?_mcount\$";

	    $cc .= " -mbig-endian ";

 " -EB ";

	    $ldemulation = "ppc"

    } else {

 " -mlittle-endian ";

	    $ld .= " -EL ";

 "lppc"

	$type = ".quad";

 " -m64 ";

	$ld .= " -m elf64".$ldemulation." ";

    } else {

 " -m32 ";

	$ld .= " -m elf32".$ldemulation." ";

    }



} elsif ($arch eq "arm") {

 2;

    $section_type = '%progbits';

 "^\\s*([0-9a-fA-F]+):\\s*R_ARM_(CALL|PC24|THM_CALL)" .

    $alignment = 3;

 '%progbits';

    $mcount_regex = "^\\s*([0-9a-fA-F]+):\\s*R_AARCH64_CALL26\\s+_mcount\$";

 ".quad";

    $mcount_regex = "^\\s*([0-9a-fA-F]+):.*\\s_mcount\$";

 "data8";

	$cc .= " -mconstant-gp";

    }

} elsif ($arch eq "sparc64") {

    # In the objdump output there are giblets like:

    # 0000000000000000 <igmp_net_exit-0x18>:

    # As there's some data blobs that get emitted into the

    # text section before the first instructions and the first

    # real symbols.  We don't want to match that, so to combat

    # this we use '\w' so we'll match just plain symbol names,

    # and not those that also include hex offsets inside of the

    # '<>' brackets.  Actually the generic function_regex setting

    # could safely use this too.

 "^([0-9a-fA-F]+)\\s+<(\\w*?)>:";

 Sparc64 calls '_mcount' instead of plain 'mcount'.

    $mcount_regex = "^\\s*([0-9a-fA-F]+):.*\\s_mcount\$";



 8;

    $type = ".xword";

 " -m elf64_sparc";

    $cc .= " -m64";

 " -O elf64-sparc";

 To enable module support, we need to enable the -mlong-calls option

 of gcc for module, after using this option, we can not get the real

 offset of the calling to _mcount, but the offset of the lui

 instruction or the addiu one. herein, we record the address of the

 first one, and then we can replace this instruction by a branch

 instruction to jump over the profiling function to filter the

 indicated functions, or switch back to the lui instruction to trace

 them, which means dynamic tracing.



       c:	3c030000 	lui	v1,0x0

			c: R_MIPS_HI16	_mcount

			c: R_MIPS_NONE	*ABS*

			c: R_MIPS_NONE	*ABS*

      10:	64630000 	daddiu	v1,v1,0

			10: R_MIPS_LO16	_mcount

			10: R_MIPS_NONE	*ABS*

			10: R_MIPS_NONE	*ABS*

      14:	03e0082d 	move	at,ra

      18:	0060f809 	jalr	v1



 for the kernel:



     10:   03e0082d        move    at,ra

	  14:   0c000000        jal     0 <loongson_halt>

                    14: R_MIPS_26   _mcount

                    14: R_MIPS_NONE *ABS*

                    14: R_MIPS_NONE *ABS*

	 18:   00020021        nop

	    $mcount_regex = "^\\s*([0-9a-fA-F]+): R_MIPS_26\\s+_mcount\$";

    } else {

 "^\\s*([0-9a-fA-F]+): R_MIPS_HI16\\s+_mcount\$";

    $objdump .= " -Melf-trad".$endian."mips ";



    if ($endian eq "big") {

 " -EB ";

	    $ld .= " -melf".$bits."btsmip";

    } else {

 " -EL ";

	    $ld .= " -melf".$bits."ltsmip";

    }



    $cc .= " -mno-abicalls -fno-pic -mabi=" . $bits . $endian;

 $endian;

	    $function_regex =

		"^([0-9a-fA-F]+)\\s+<(.|[^\$]L.*?|\$[^L].*?|[^\$][^L].*?)>:";

 ".dword";

 Microblaze calls '_mcount' instead of plain 'mcount'.

    $mcount_regex = "^\\s*([0-9a-fA-F]+):.*\\s_mcount\$";

} elsif ($arch eq "riscv") {

 "^([0-9a-fA-F]+)\\s+<([^.0-9][0-9a-zA-Z_\\.]+)>:";

    $mcount_regex = "^\\s*([0-9a-fA-F]+):\\sR_RISCV_CALL(_PLT)?\\s_?mcount\$";

 ".quad";

    $alignment = 2;

} elsif ($arch eq "nds32") {

 "^\\s*([0-9a-fA-F]+):\\s*R_NDS32_HI20_RELA\\s+_mcount\$";

    $alignment = 2;

} elsif ($arch eq "csky") {

 "^\\s*([0-9a-fA-F]+):\\s*R_CKCORE_PCREL_JSR_IMM26BY2\\s+_mcount\$";

    $alignment = 2;

} else {

    die "Arch $arch is not supported with CONFIG_FTRACE_MCOUNT_RECORD";

}



 0;

my $read_function = 0;

 0;

my $mcount_section = "__mcount_loc";



my $dirname;

my $filename;

my $prefix;

my $ext;



~ m,^(.*)/([^/]*)$,) {

    $dirname = $1;

 $2;

    $dirname = ".";

 $inputfile;

if ($filename =~ m,^(.*)(\.\S),) {

 $1;

    $ext = $2;

} else {

 $filename;

    $ext = "";

}



 $dirname . "/.tmp_mc_" . $prefix . ".s";

my $mcount_o = $dirname . "/.tmp_mc_" . $prefix . ".o";



#

# Step 1: find all the local (static functions) and weak symbols.

#         't' is local, 'w/W' is weak

#

open (IN, "$nm $inputfile|") || die "error running $nm";

while (<IN>) {

    if (/$local_regex/) {

 1;

	$weak{$2} = $1;

    }

}

close(IN);



my @offsets;		# Array of offsets of mcount callers

my $ref_func;		# reference function to use for offsets

 offset of ref_func to section beginning

 update_funcs - print out the current mcount callers



  Go through the list of offsets to callers and write them to

  the output file in a format that can be read by an assembler.



 Sanity check on weak function. A weak function may be overwritten by

 another function of the same name, making all these offsets incorrect.

 is this function static? If so, note this fact.

	$convert{$ref_func} = 1;

    }



    # Loop through all the mcount caller offsets and print a reference

    # to the caller based from the ref_func.

    if (!$opened) {

	open(FILE, ">$mcount_s") || die "can't create $mcount_s\n";

 1;



 Step 2: find the sections and mcount call sites



open(IN, "LC_ALL=C $objdump -hdr $inputfile|") || die "error running $objdump";



my $text;





# read headers first

 1;



 Somehow the make process can execute this script on an

 object twice. If it does, we would duplicate the mcount

 section and it will cause the function tracer self test

 to fail. Check if the mcount section exists, and if it does,

 warn and exit.



 is it a section?

	$read_headers = 0;



	# Only record text sections that we know are safe

 defined($text_sections{$1});

		    $read_function = 1;

		    last;

		}

	    }

	}

	# print out any recorded offsets

	update_funcs();



	# reset all markers and arrays

 0;

 section found, now is this a start of a function?

	$text_found = 1;

 $2;

 if this is either a local function or a weak function

 keep looking for functions that are global that

 we can use safely.

	    $ref_func = $text;

 0;

	    $offset = hex $1;

	} else {

	    # if we already have a function, and this is weak, skip it

	    if (!defined($ref_func) && !defined($weak{$text}) &&

		 # PPC64 can have symbols that start with .L and

		 # gcc considers these special. Don't use them!

		 $text !~ /^\.L/) {

 $text;

		$offset = hex $1;

	    }

	}

    }

    # is this a call site to mcount? If so, record it to print later

    if ($text_found && /$mcount_regex/) {

	push(@offsets, (hex $1) + $mcount_adjust);

    }

}



# dump out anymore offsets that may have been found

update_funcs();



# If we did not find any mcount callers, we are done (do nothing).

if (!$opened) {

    exit(0);

}



close(FILE);



#

# Step 3: Compile the file that holds the list of call sites to mcount.

#

`$cc -o $mcount_o -c $mcount_s`;



 keys %convert;



 Step 4: Do we have sections that started with local functions?



if ($#converts >= 0) {

 "";

    my $locallist = "";



    foreach my $con (@converts) {

 " --globalize-symbol $con";

	$locallist .= " --localize-symbol $con";

    }



 $dirname . "/.tmp_gl_" . $filename;

    my $globalmix = $dirname . "/.tmp_mx_" . $filename;



    #

    # Step 5: set up each local function as a global

    #

    `$objcopy $globallist $inputfile $globalobj`;



    #

    # Step 6: Link the global version to our list.

    #

    `$ld -r $globalobj $mcount_o -o $globalmix`;



    #

    # Step 7: Convert the local functions back into local symbols

    #

    `$objcopy $locallist $globalmix $inputfile`;



    # Remove the temp files

    `$rm $globalobj $globalmix`;



} else {



 $dirname . "/.tmp_mx_" . $filename;



 Step 8: Link the object with our list of call sites object.





 Step 9: Move the result back to the original object.



 Clean up the temp files

# vim: softtabstop=4

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0



 Generates a linker script that specifies the correct initcall order.



 Copyright (C) 2019 Google LLC

my $nm = $ENV{'NM'} || die "$0: ERROR: NM not set?";

 $ENV{'objtree'} || '.';

my $jobs = {};		# child process pid -> file handle

## results from child processes

 object index -> [ { level, secname }, ... ]

	my $procs = <$fh>;

	close($fh);



~ /^\d+$/)) {

	my ($index, $initcalls) = @_;



	# sort by the counter value to ensure the order of initcalls within

	# each object file is correct

> $b } keys(%{$initcalls})) {

		my $level = $initcalls->{$counter}->{'level'};



		# section name for the initcall function

 $initcalls->{$counter}->{'module'} . '__' .

	my ($fh) = @_;



	# each child prints out a full line w/ autoflush and exits after the

	# last line, so even if buffered I/O blocks here, it shouldn't block

	# very long

 <$fh>;

 $data 
	$index = int($index);



	if (!exists($results->{$index})) {

 [];

		'level'   => $level,

> $secname

	my ($index, $file) = @_;



	die "$0: ERROR: file $file doesn't exist?" if (! -f $file);



	open(my $fh, "\"$nm\" --defined-only \"$file\" 2>/dev/null |")

		or die "$0: ERROR: failed to execute \"$nm\": $!";



 {};

 check for the start of a new object file (if processing an

 archive)

 $_ 
			$initcalls = {};

			next;

		}



		# look for an initcall

		my ($module, $counter, $line, $symbol) = $_ =~

			/[a-z]\s+__initcall__(\S*)__(\d+)_(\d+)_(.*)$/;



		if (!defined($module)) {

 ''

 parse initcall level

 $symbol 
		$initcalls->{$counter} = {

> $module,

			'line'     => $line,

> $function,

			'level'    => $level,

		};

	}



	close($fh);

	write_results($index, $initcalls);

}



## waits for any child process to complete, reads the results, and adds them to

## the $results array for later processing

sub wait_for_results {

 @_;

	my $pid = 0;

	do {

		# unblock children that may have a full write buffer

		foreach my $fh ($select->can_read(0)) {

			read_results($fh);

		}



		# check for children that have exited, read the remaining data

		# from them, and clean up

 waitpid(-1, WNOHANG);

			my $fh = $jobs->{$pid};

			$select->remove($fh);



			while (read_results($fh)) {

				# until eof

			}



			close($fh);

			delete($jobs->{$pid});

		}

	} while ($pid > 0);

}



## forks a child to process each file passed in the command line and collects

## the results

sub process_files {

 0;

	my $njobs = $ENV{'PARALLELISM'} || get_online_processors();

 IO::Select->new();

	while (my $file = shift(@ARGV)) {

		# fork a child process and read it's stdout

 open(my $fh, '-|');

 save the child process pid and the file handle

			$jobs->{$pid} = $fh;

		} else {

			# in the child process

			STDOUT->autoflush(1);

			find_initcalls($index, "$objtree/$file");

			exit;

		}



		$index++;



		# limit the number of children to $njobs

 $njobs) {

 wait for the remaining children to complete

	my $sections = {};	# level -> [ secname, ...]



	# sort results to retain link order and split to sections per

	# initcall level

> $b } keys(%{$results})) {

			my $level = $result->{'level'};



			if (!exists($sections->{$level})) {

 [];

 print out a linker script that defines the order of initcalls for

 each level

			$section = '.con_initcall.init';

		} else {

 ".initcall${level}.init";

!/usr/bin/perl -w

 SPDX-License-Identifier: GPL-2.0

my $input_file = "MAINTAINERS";

 "MAINTAINERS.new";

my $output_section = "SECTION.new";

 0;

my $order = 0;

 $0;

s' 
s' 
s' 
		'order!' => \$order,

> \$help,

if ($help != 0) {

    usage();

    exit 0;

}



sub usage {

    print <<EOT;

usage: $P [options] <pattern matching regexes>



> MAINTAINERS file to read (default: MAINTAINERS)

  --output => sorted MAINTAINERS file to write (default: MAINTAINERS.new)

> new sorted MAINTAINERS file to write to (default: SECTION.new)

  --order => Use the preferred section content output ordering (default: 0)

    Preferred ordering of section output is:

      M:  Person acting as a maintainer

      R:  Person acting as a patch reviewer

      L:  Mailing list where patches should be sent

      S:  Maintenance status

      W:  URI for general information

      Q:  URI for patchwork tracking

      B:  URI for bug tracking/submission

      C:  URI for chat

      P:  URI or file for subsystem specific coding styles

      T:  SCM tree type and location

      F:  File and directory pattern

      X:  File and directory exclusion pattern

      N:  File glob

      K:  Keyword - patch content regex



If <pattern match regexes> exist, then the sections that match the

regexes are not written to the output file but are written to the

section file.



EOT

}



# sort comparison functions

sub by_category($$) {

 @_;

    $a = uc $a;

 uc $b;

 This always sorts last

    $a =~ s/THE REST/ZZZZZZ/g;

~ s/THE REST/ZZZZZZ/g;

    my ($a, $b) = @_;

 'MRLSWQBCPTFXNK';

    my $a1 = uc(substr($a, 0, 1));

 uc(substr($b, 0, 1));

    my $a_index = index($preferred_order, $a1);

 index($preferred_order, $b1);

    $a_index = 1000 if ($a_index == -1);

 1000 if ($b_index  -1);

~ /^F$/ && $b1 
~ /^X$/ && $b1 
    my $s = shift;

~ s/\s+$//;

    $s =~ s/^\s+//;

    return $s;

}



sub alpha_output {

 (@_);

		$separator = "\n";

	    } else {

		print $file $separator;

	    }

	    print $file $key . "\n";

	    if ($order) {

		foreach my $pattern (sort by_pattern split('\n', %$hashref{$key})) {

		    print $file ($pattern . "\n");

		}

	    } else {

		foreach my $pattern (split('\n', %$hashref{$key})) {

		    print $file ($pattern . "\n");

		}

	    }

	}

    }

    close($file);

}



sub file_input {

 (@_);

    my $lastline = "";

 " ";

    $$hashref{$case} = "";



    open(my $file, '<', "$filename") or die "$P: $filename: open failed - $!\n";



    while (<$file>) {

 $_;

 Pattern line?

        if ($line =~ m/^([A-Z]):\s*(.*)/) {

 $1 . ":\t" . trim($2) . "\n";

                $$hashref{$case} = $$hashref{$case} . $line;

                next;

            }

 trim($lastline);

            $$hashref{$case} = $line;

 "";

            $$hashref{$case} = $$hashref{$case} . $lastline;

 $line;

        $lastline = $line;

    }

 $$hashref{$case} . $lastline;

~ /$type/ || $hash{$key} 
	    $new_hash{$key} = $hash{$key};

	    delete $hash{$key};

	}

    }

}



alpha_output(\%hash, $output_file);

alpha_output(\%new_hash, $output_section);



exit(0);

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0



 Author: Mauro Carvalho Chehab <mchehab+samsung@kernel.org>



 Produce manpages from kernel-doc.

 See Documentation/doc-guide/kernel-doc.rst for instructions

ARGV < 0) {

$state = 0;

while (<STDIN>) {

    if (/^\.TH \"[^\"]*\" 9 \"([^\"]*)\"/) {

	if ($state == 1) { close OUT }

 1;

	$fn = "$ARGV[0]/$1.9";

	print STDERR "Creating $fn\n";

	open OUT, ">$fn" or die "can't open $fn: $!\n";

	print OUT $_;

 0) {

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0



 headers_check.pl execute a number of trivial consistency checks



 Usage: headers_check.pl dir arch [files...]

 dir:   dir to look for included files

 arch:  architecture

 files: list of files to check



 The script reads the supplied files line by line and:



 1) for each include statement it checks if the

    included file actually exists.

    Only include files located in asm* and linux* are checked.

    The rest are assumed to be system include files.



 2) It is checked that prototypes does not use "extern"



 3) Check for leaked CONFIG_ symbols

my ($dir, $arch, @files) = @ARGV;



 0;

my $lineno = 0;

my $filename;



foreach my $file (@files) {

 $file;

	$lineno = 0;

 <$fh>) {

 Dropped for now. Too much noise &check_config();

	if ($line =~ m/^\s*#\s*include\s+<((asm|linux).*)>/) {

 $1;

		$found = stat($dir . "/" . $inc);

		if (!$found) {

asm/;

			$found = stat($dir . "/" . $inc);

		}

		if (!$found) {

			printf STDERR "$filename:$lineno: included file '$inc' is not exported\n";

 1;

 soundcard.h is what it is

	if ($line =~ m/^void seqbuf_dump\(void\);/) {

		return;

	}

	# drm headers are being C++ friendly

~ m/^extern "C"/) {

	if ($line =~ m/^(\s*extern|unsigned|char|short|int|long|void)\b/) {

		printf STDERR "$filename:$lineno: " .

			      "userspace cannot reference function or " .

			      "variable defined in the kernel\n";

	}

}



sub check_config

{

~ m/[^a-zA-Z0-9_]+CONFIG_([a-zA-Z0-9_]+)[^a-zA-Z0-9_]/) {

	if ($filename =~ /types.h|int-l64.h|int-ll64.h/o) {

		return;

	}

	if ($lineno == 1) {

 0;

	} elsif ($linux_asm_types >= 1) {

		return;

	}

\s*include\s+<asm\/types.h>/) {

		$linux_asm_types = 1;

		printf STDERR "$filename:$lineno: " .

		"include of <linux/types.h> is preferred over <asm/types.h>\n"

		# Warn until headers are all fixed

$ret = 1;

my %import_stack = ();

sub check_include_typesh

{

 $_[0];

	my @file_paths = ($path, $dir . "/" .  $path, dirname($filename) . "/" . $path);

	for my $possible ( @file_paths ) {

	    if (not $import_stack{$possible} and open($fh, '<', $possible)) {

 $possible;

		$import_stack{$import_path} = 1;

		last;

	    }

	}

	if (eof $fh) {

	    return;

	}



	my $line;

 <$fh>) {

		if ($line =~ m/^\s*#\s*include\s+<linux\/types.h>/) {

 1;

\s*include\s+[<"](\S+)[>"]/)[0]) {
~ /^\s*#\s*include\s+[<"](\S+)[>"]/)[0]) {

	if ($filename =~ /types.h|int-l64.h|int-ll64.h/o) {

		return;

	}

	if ($lineno == 1) {

 0;

	} elsif ($linux_types >= 1) {

		return;

	}

\s*include\s+<linux\/types.h>/) {

		$linux_types = 1;

		return;

	}

	if (my $included = ($line =~ /^\s*#\s*include\s+[<"](\S+)[>"]/)[0]) {

		check_include_typesh($included);

	}

~ m/__[us](8|16|32|64)\b/) {

include <linux/types.h>\n";

		$linux_types = 2;

		# Warn until headers are all fixed

$ret = 1;

!/usr/bin/perl

 SPDX-License-Identifier: GPL-2.0

my $basename = abs_path($0);

~ s,/[^/]+$,/,;

my $prefix=$basename . "../Documentation/features";



# Used only at for full features output. The script will auto-adjust

# such values for the minimal possible values

 1;

my $description_size = 1;



GetOptions(

> \$debug,

s" 
	'help|?' => \$help,

	'arch=s' => \$arch,

	'feat=s' => \$feat,

	'feature=s' => \$feat,

> \$man

> 0, -verbose 
my ($cmd, $arg) = @ARGV;



pod2usage(2) if ($cmd ne "current" && $cmd ne "rest" && $cmd ne "validate"

		&& $cmd ne "ls" && $cmd ne "list");



require Data::Dumper if ($debug);



my %data;

my %archs;



#

# Displays an error message, printing file name and line

#

sub parse_error($$$$) {

 @_;

	$data =~ s/\s+$/\n/;



	print STDERR "Warning: file $file#$ln:\n\t$msg";



	if ($data ne "") {

		print STDERR ". Line\n\t\t$data";

	} else {

	    print STDERR "\n";

	}

}



#

# Parse a features file, storing its contents at %data

#



 "Feature";

my $h_kconfig = "Kconfig";

 "Description";

my $h_subsys = "Subsystem";

 "Status";

my $h_arch = "Architecture";



 length($h_name);

my $max_size_kconfig = length($h_kconfig);

 length($h_description);

my $max_size_subsys = length($h_subsys);

 length($h_status);

my $max_size_arch = 0;

my $max_size_arch_with_header;

 0;

	my $file = $File::Find::name;



 (stat($file))[2];

	return if ($file =~ m,($prefix)/arch-support.txt,);

~ m,arch-support.txt$,));

	my $subsys = "";

 $2 if ( m,.*($prefix)/([^/]+).*,);

		$max_size_subsys = length($subsys);

	}



	my $name;

	my $kconfig;

	my $description;

 "";

\s+Feature\s+name:\s*(.*\S)/) {

			$name = $1;

			if (length($name) > $max_size_name) {

 length($name);

\s+Kconfig:\s*(.*\S)/) {

			$kconfig = $1;

			if (length($kconfig) > $max_size_kconfig) {

 length($kconfig);

\s+description:\s*(.*\S)/) {

			$description = $1;

			if (length($description) > $max_size_description) {

 length($description);

					$max_description_word = length($word);

				}

			}



			next;

		}

		next if (m/^\\s*$/);

		next if (m/^\s*\-+\s*$/);

		next if (m/^\s*\|\s*arch\s*\|\s*status\s*\|\s*$/);



		if (m/^\#\s*(.*)/) {

 "$1\n";

			my $a = $1;

 $2;

				$max_size_status = length($status);

			}

			if (length($a) > $max_size_arch) {

 length($a);

 "---" if ($status 
			$archs{$a} = 1;

 $status;

Everything else is an error

	$data{$name}->{where} = $file;

 $subsys;

	$data{$name}->{kconfig} = $kconfig;

 $description;

	$data{$name}->{comments} = $comments;

 \%arch_table;

	$max_size_arch_with_header = $max_size_arch + length($h_arch);

}



#

# Output feature(s) for a given architecture

#

sub output_arch_table {

 "Feature status on $arch architecture";

	print "=" x length($title) . "\n";

	print "$title\n";

" x length($title) . "\n\n";

	print "=" x $max_size_subsys;

	print "  ";

" x $max_size_name;

	print "=" x $max_size_kconfig;

	print "  ";

" x $max_size_status;

	print "=" x $max_size_description;

	print "\n";

	printf "%-${max_size_subsys}s  ", $h_subsys;

	printf "%-${max_size_name}s  ", $h_name;

	printf "%-${max_size_kconfig}s  ", $h_kconfig;

	printf "%-${max_size_status}s  ", $h_status;

	printf "%-${max_size_description}s\n", $h_description;

" x $max_size_subsys;

	print "=" x $max_size_name;

	print "  ";

" x $max_size_kconfig;

	print "=" x $max_size_status;

	print "  ";

" x $max_size_description;

		my %arch_table = %{$data{$name}->{table}};

		printf "%-${max_size_subsys}s  ", $data{$name}->{subsys};

		printf "%-${max_size_name}s  ", $name;

		printf "%-${max_size_kconfig}s  ", $data{$name}->{kconfig};

		printf "%-${max_size_status}s  ", $arch_table{$arch};

		printf "%-s\n", $data{$name}->{description};

	}



" x $max_size_subsys;

	print "=" x $max_size_name;

	print "  ";

" x $max_size_kconfig;

	print "=" x $max_size_status;

	print "  ";

" x $max_size_description;



 list feature(s) for a given architecture



\n\n";

		my %arch_table = %{$data{$name}->{table}};



 $arch_table{$arch};

		$status = " " x ((4 - length($status)) / 2) . $status;



		printf " %${max_size_subsys}s/ ", $data{$name}->{subsys};

		printf "%-${max_size_name}s: ", $name;

		printf "%-5s|   ", $status;

		printf "%${max_size_kconfig}s # ", $data{$name}->{kconfig};

		printf " %s\n", $data{$name}->{description};

	}

}



#

# Output a feature on all architectures

#

sub output_feature {

 "Feature $feat";

	print "=" x length($title) . "\n";

	print "$title\n";

" x length($title) . "\n\n";

	my $desc = $data{$feat}->{description};

~ s/^([a-z])/\U$1/;

	$desc =~ s/\.?\s*//;

	print "\n$desc.\n\n";



 $data{$feat}->{comments};

	$com =~ s/^\s+//;

~ s/\s+$//;

	print "=" x $max_size_arch_with_header;

	print "  ";

" x $max_size_status;

	print "=" x $max_size_arch_with_header;

	print "  ";

" x $max_size_status;

	my %arch_table = %{$data{$feat}->{table}};

	foreach my $arch (sort keys %arch_table) {

		printf "%-${max_size_arch}s  ", $arch;

		printf "%-${max_size_status}s\n", $arch_table{$arch};

	}



" x $max_size_arch_with_header;

	print "=" x $max_size_status;

	print "\n";

}



#

# Output all features for all architectures

#



sub matrix_lines($$$) {

 shift;

	my $status_size = shift;

 shift;

 "
		$ln_marker = "-";

	}



 $ln_marker;

	my $title = "Feature status on all architectures";

 "Not compatible";

	print "=" x length($title) . "\n";

	print "$title\n";

" x length($title) . "\n\n";

	my $desc_title = "$h_kconfig / $h_description";



 $max_size_kconfig + 4;

		$desc_size = $max_size_description if ($max_size_description > $desc_size);

	} else {

 $description_size if ($description_size > $desc_size);

	$desc_size = $max_description_word if ($max_description_word > $desc_size);



 length($desc_title) if (length($desc_title) > $desc_size);

	$max_size_status = length($notcompat) if (length($notcompat) > $max_size_status);



	# Ensure that the status will fit

 $max_size_status + $max_size_arch + 6;

	$status_size = $min_status_size if ($status_size < $min_status_size);





 "";

			$cur_subsys = $data{$name}->{subsys};



 "Subsystem: $cur_subsys";

			print "=" x length($title) . "\n\n";





			matrix_lines($desc_size, $status_size, 0);



			printf "|%-${max_size_name}s", $h_name;

			printf "|%-${desc_size}s", $desc_title;



			printf "|%-${status_size}s|\n", "Status per architecture";

			matrix_lines($desc_size, $status_size, 1);

		}



 %{$data{$name}->{table}};

		my $cur_status = "";



		my (@lines, @descs);

 "";

			my $status = $arch_table{$arch};



			if ($status eq "---") {

 $notcompat;

					$line = "";

				}

 "- **" . $status . "**: " . $arch;

				$line .= ", " . $arch;

			} else {

				push @lines, $line;

 "  " . $arch;

			$cur_status = $status;

		}

		push @lines, $line if ($line ne "");



 $data{$name}->{description};

			my $d = substr $description, 0, $desc_size;



			# Ensure that it will end on a space

			# if it can't, it means that the size is too small

			# Instead of aborting it, let's print what we have

~ s/^(.*)\s+.*/$1/)) {

				$d = substr $d, 0, -1;

				push @descs, "$d\\";

~ s/^\Q$d\E//;

				$description =~ s/^\Q$d\E\s+//;

			}

		}

		push @descs, $description;



		# Ensure that the full description will be printed

		push @lines, "" while (scalar(@lines) < 2 + scalar(@descs));



 0;

			} elsif ($ln >= 2 && scalar(@descs)) {

				printf "|%-${max_size_name}s", "";

				printf "|%-${desc_size}s", shift @descs;

			} else {

				printf "|%-${max_size_name}s", "";

				printf "|%-${desc_size}s", "";

			}



			printf "|%-${status_size}s|\n", $line;



			$ln++;

		}

		matrix_lines($desc_size, $status_size, 0);

	}

}





#

# Parses all feature files located at $prefix dir

#

find({wanted =>\&parse_feat, no_chdir => 1}, $prefix);



print STDERR Data::Dumper->Dump([\%data], [qw(*data)]) if ($debug);



#

# Handles the command

#

if ($cmd eq "current") {

 qx(uname -m | sed 's/x86_64/x86/' | sed 's/i386/x86/');

	$arch =~s/\s+$//;

}



if ($cmd eq "ls" or $cmd eq "list") {

	if (!$arch) {

 qx(uname -m | sed 's/x86_64/x86/' | sed 's/i386/x86/');

		$arch =~s/\s+$//;

	}



	list_arch_features;



	exit;

}



if ($cmd ne "validate") {

	if ($arch) {

		output_arch_table;

	} elsif ($feat) {

		output_feature;

	} else {

		output_matrix;

	}

}



__END__



head1 NAME

=head1 SYNOPSIS



B<get_feat.pl> [--debug] [--man] [--help] [--dir=<dir>] [--arch=<arch>]

	       [--feature=<feature>|--feat=<feature>] <COMAND> [<ARGUMENT>]



Where <COMMAND> can be:



over 8

=back



head1 OPTIONS

=over 8



item B<--arch>

=item B<--feat> or B<--feature>



Output features for a single specific feature.



item B<--dir>

=item B<--debug>



Put the script in verbose mode, useful for debugging. Can be called multiple

times, to increase verbosity.



item B<--help>

=item B<--man>



Prints the manual page and exits.



back

=head1 DESCRIPTION



Parse the Linux feature files from Documentation/features (by default),

optionally producing results at ReST format.



It supports output data per architecture, per feature or a

feature x arch matrix.



When used with B<rest> command, it will use either one of the tree formats:



If neither B<--arch> or B<--feature> arguments are used, it will output a

matrix with features per architecture.



If B<--arch> argument is used, it will output the features availability for

a given architecture.



If B<--feat> argument is used, it will output the content of the feature

file using ReStructured Text markup.



head1 BUGS

=head1 COPYRIGHT



Copyright (c) 2019 by Mauro Carvalho Chehab <mchehab+samsung@kernel.org>.



License GPLv2: GNU GPL version 2 <http://gnu.org/licenses/gpl.html>.



This is free software: you are free to change and redistribute it.

There is NO WARRANTY, to the extent permitted by law.



cut

! /usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0



 checkversion finds uses of all macros in <linux/version.h>

 where the source files do not 
 of including <linux/version.h> where it is not needed.

 Copyright (C) 2003, Randy Dunlap <rdunlap@infradead.org>

$| = 1;



my $debugging;



foreach my $file (@ARGV) {

~ "include/generated/uapi/linux/version\.h";

    next if $file =~ "usr/include/linux/version\.h";

    # Open this file.

    open( my $f, '<', $file )

      or die "Can't open $file: $!\n";



    # Initialize variables.

    my ($fInComment, $fInString, $fUseVersion);

 0;

 Strip comments.

	$fInComment && (s+^.*?\*/+ +o ? ($fInComment = 0) : next);

 1)));

 Pick up definitions.

/o ) {

	    $iLinuxVersion      = $. if m/^\s*#\s*include\s*"linux\/version\.h"/o;

	}



	# Strip strings.

 0) : next);

	m+"+o && (s+".*?"+ +go, (s+".*$+ +o && ($fInString = 1)));



	# Pick up definitions.

	if ( m/^\s*#/o ) {

\s*include\s*<linux\/version\.h>/o;

 Look for uses: LINUX_VERSION_CODE, KERNEL_VERSION,

 LINUX_VERSION_MAJOR, LINUX_VERSION_PATCHLEVEL, LINUX_VERSION_SUBLEVEL

~ /LINUX_VERSION_CODE/) || ($_ 
~ /LINUX_VERSION_MAJOR/) || ($_ 
	    ($_ =~ /LINUX_VERSION_SUBLEVEL/)) {

 1;

 Report used version IDs without include?

 Report superfluous includes.

 debug: report OK results:

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0



 extract-mod-sig <part> <module-file>



 Reads the module file and writes out some or all of the signature

 section to stdout.  Part is the bit to be written and is one of:



  -0: The unsigned module, no signature data at all

  -a: All of the signature data, including magic number

  -d: Just the descriptor values as a sequence of numbers

  -n: Just the signer's name

  -k: Just the key ID

  -s: Just the crypto signature or PKCS


    if ($#ARGV != 1);



 $ARGV[0];

my $modfile = $ARGV[1];



 "~Module signature appended~\n";



 Read the module contents



my @st = stat(FD);

die "$modfile" unless (@st);

 "";

my $len = sysread(FD, $buf, $st[7]);

die "$modfile" unless (defined($len));

die "Short read on $modfile\n" unless ($len == $st[7]);

close(FD) || die $modfile;



print STDERR "Read ", $len, " bytes from module file\n";



die "The file is too short to have a sig magic number and descriptor\n"

    if ($len < 12 + length($magic_number));



#

# Check for the magic number and extract the information block

#

 $len - length($magic_number);

my $raw_magic = substr($buf, $p);



die "Magic number not found at $len\n"

    if ($raw_magic ne $magic_number);

print STDERR "Found magic number at $len\n";



 12;

my $raw_info = substr($buf, $p, 12);



 unpack("CCCCCxxxN", $raw_info);

my ($algo, $hash, $id_type, $name_len, $kid_len, $sig_len) = @info;



if ($id_type == 0) {

    print STDERR "Found PGP key identifier\n";

} elsif ($id_type == 1) {

    print STDERR "Found X.509 cert identifier\n";

} elsif ($id_type == 2) {

    print STDERR "Found PKCS#7/CMS encapsulation\n";

} else {

    print STDERR "Found unsupported identifier type $id_type\n";

}



#

# Extract the three pieces of info data

#

die "Insufficient name+kid+sig data in file\n"

 $name_len + $kid_len + $sig_len);

$p -= $sig_len;

 substr($buf, $p, $sig_len);

$p -= $kid_len;

 substr($buf, $p, $kid_len);

$p -= $name_len;

 substr($buf, $p, $name_len);

my $module_len = $p;



if ($sig_len > 0) {

    print STDERR "Found $sig_len bytes of signature [";

 $sig_len > 16 ? 16 : $sig_len;

    my $n = $kid_len > 16 ? 16 : $kid_len;

    foreach my $i (unpack("C" x $n, substr($raw_kid, 0, $n))) {

	printf STDERR "%02x", $i;

    }

    print STDERR "]\n";

}



if ($name_len > 0) {

    print STDERR "Found $name_len bytes of signer's name [$raw_name]\n";

}



#

# Produce the requested output

#

if ($part eq "-0") {

    # The unsigned module, no signature data at all

    binmode(STDOUT);

    print substr($buf, 0, $module_len);

} elsif ($part eq "-a") {

    # All of the signature data, including magic number

    binmode(STDOUT);

    print substr($buf, $module_len);

} elsif ($part eq "-d") {

    # Just the descriptor values as a sequence of numbers

    print join(" ", @info), "\n";

} elsif ($part eq "-n") {

    # Just the signer's name

    print STDERR "No signer's name for PKCS#7 message type sig\n"

	if ($id_type == 2);

    binmode(STDOUT);

    print $raw_name;

} elsif ($part eq "-k") {

    # Just the key identifier

    print STDERR "No key ID for PKCS#7 message type sig\n"

	if ($id_type == 2);

    binmode(STDOUT);

    print $raw_kid;

} elsif ($part eq "-s") {

    # Just the crypto signature or PKCS#7 message

    binmode(STDOUT);

    print $raw_sig;

}

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0



 (c) 2007, Joe Perches <joe@perches.com>

           created from checkpatch.pl



 Print selected MAINTAINERS information for

 the files modified in a patch or for a file



 usage: perl scripts/get_maintainer.pl [OPTIONS] <patch>

        perl scripts/get_maintainer.pl [OPTIONS] -f <file>

my $P = $0;

 '0.26';

my $cur_path = fastgetcwd() . '/';

 "./";

my $email = 1;

 1;

my $email_maintainer = 1;

 1;

my $email_fixes = 1;

 1;

my $email_moderated_list = 1;

 0;

my $email_git_penguin_chiefs = 0;

 0;

my $email_git_all_signature_types = 0;

 0;

my $email_git_blame_signatures = 1;

 1;

my $email_git_min_signatures = 1;

 5;

my $email_git_min_percent = 5;

 "1-year-ago";

my $email_hg_since = "-365";

 0;

my $email_remove_duplicates = 1;

 1;

my $output_multiline = 1;

 ", ";

my $output_roles = 0;

 1;

my $output_section_maxlen = 50;

 0;

my $tree = 1;

 0;

my $subsystem = 0;

 0;

my $letters = "";

 1;

my $sections = 0;

 0;

my $from_filename = 0;

 0;

my $self_test = undef;

 0;

my $help = 0;

 0;

my $vcs_used = 0;



 0;

my @files = ();

 If a patch description includes Fixes: lines

my @range = ();

 ();

my @file_emails = ();



my %commit_author_hash;

my %commit_signer_hash;



 ();

Andrew wants in on most everything - 2009/01/14

push(@penguin_chief, "Andrew Morton:akpm\@linux-foundation.org");

my @penguin_chief_names = ();

foreach my $chief (@penguin_chief) {

~ m/^(.*):(.*)/) {

	my $chief_name = $1;

 $2;

my $penguin_chiefs = "\(" . join("|", @penguin_chief_names) . "\)";



# Signature types of people who are either

# 	a) responsible for the code in question, or

# 	b) familiar enough with it to give relevant feedback

 ();

my $signature_pattern = "\(" . join("|", @signature_tags) . "\)";



# rfc822 email address - preloaded methods go here.

 "(?:(?:\\r\\n)?[ \\t])";

my $rfc822_char = '[\\000-\\377]';



# VCS command support: class-like functions and strings



my %VCS_cmds;



 (

    "execute_cmd" => \&git_execute_cmd,

> '(which("git") ne "") && (-e ".git")',

    "find_signers_cmd" =>

\$email_git_since " .

	    '--format="GitCommit: %H%n' .

		      'GitAuthor: %an <%ae>%n' .

		      'GitDate: %aD%n' .

		      'GitSubject: %s%n' .

		      '%b%n"' .

	    " -- \$file",

>

	    '--format="GitCommit: %H%n' .

		      'GitAuthor: %an <%ae>%n' .

		      'GitDate: %aD%n' .

		      'GitSubject: %s%n' .

		      '%b%n"' .

	    " -1 \$commit",

>

	    '--format="GitCommit: %H%n' .

		      'GitAuthor: %an <%ae>%n' .

		      'GitDate: %aD%n' .

		      'GitSubject: %s%n"' .

	    " -1 \$commit",

> "git blame -l -L \$diff_start,+\$diff_length \$file",

    "blame_file_cmd" => "git blame -l \$file",

> "^GitCommit: ([0-9a-f]{40,40})",

    "blame_commit_pattern" => "^([0-9a-f]+) ",

> "^GitAuthor: (.*)",

    "subject_pattern" => "^GitSubject: (.*)",

> "^(\\d+)\\t(\\d+)\\t\$file\$",

    "file_exists_cmd" => "git ls-files \$file",

> "git ls-files \$file",

my %VCS_cmds_hg = (

> \&hg_execute_cmd,

    "available" => '(which("hg") ne "") && (-d ".hg")',

>

	"hg log --date=\$email_hg_since " .

'HgCommit: {node}\\n" .

    "find_commit_signers_cmd" =>

	"hg log " .

'HgSubject: {desc}\\n'" .

    "find_commit_author_cmd" =>

	"hg log " .

'HgCommit: {node}\\n" .

    "blame_range_cmd" => "",		# not supported

> "hg blame -n \$file",

    "commit_pattern" => "^HgCommit: ([0-9a-f]{40,40})",

> "^([ 0-9a-f]+):",

    "author_pattern" => "^HgAuthor: (.*)",

> "^HgSubject: (.*)",

    "stat_pattern" => "^(\\d+)\t(\\d+)\t\$file\$",

> "hg files \$file",

    "list_files_cmd" => "hg manifest -R \$file",

);



 which_conf(".get_maintainer.conf");

	my $line = $_;



~ s/\s*\n?$//g;

	$line =~ s/^\s*//g;

~ s/\s+/ /g;

	next if ($line =~ m/^\s*#/);

~ m/^\s*$/);

	my @words = split(" ", $line);

	foreach my $word (@words) {

/);

my @ignore_emails = ();

 which_conf(".get_maintainer.ignore");

	my $line = $_;



~ s/\s*\n?$//;

	$line =~ s/^\s*//;

~ s/\s+$//;

	$line =~ s/#.*$//;



~ m/^\s*$/);

ARGV > 0) {

~ /^-{1,2}self-test(?:
		'email!' => \$email,

> \$email_git,

		'git-all-signature-types!' => \$email_git_all_signature_types,

> \$email_git_blame,

		'git-blame-signatures!' => \$email_git_blame_signatures,

> \$email_git_fallback,

		'git-chief-penguins!' => \$email_git_penguin_chiefs,

		'git-min-signatures=i' => \$email_git_min_signatures,

		'git-max-maintainers=i' => \$email_git_max_maintainers,

		'git-min-percent=i' => \$email_git_min_percent,

		'git-since=s' => \$email_git_since,

		'hg-since=s' => \$email_hg_since,

> \$interactive,

		'remove-duplicates!' => \$email_remove_duplicates,

> \$email_use_mailmap,

		'm!' => \$email_maintainer,

> \$email_reviewer,

		'n!' => \$email_usename,

> \$email_list,

		'fixes!' => \$email_fixes,

> \$email_moderated_list,

		's!' => \$email_subscriber_list,

> \$output_multiline,

		'roles!' => \$output_roles,

> \$output_rolestats,

s' 
		'subsystem!' => \$subsystem,

> \$status,

		'scm!' => \$scm,

> \$tree,

		'web!' => \$web,

		'letters=s' => \$letters,

		'pattern-depth=i' => \$pattern_depth,

> \$keywords,

		'sections!' => \$sections,

> \$email_file_emails,

		'f|file' => \$from_filename,

> \$find_maintainer_files,

s' 
		'self-test:s' => \$self_test,

> \$version,

		'h|help|usage' => \$help,

		)) {

    die "$P: invalid argument - use --help if necessary\n";

}



 0) {

if ($version != 0) {

    print("${P} ${V}\n");

    exit 0;

}



if (defined $self_test) {

    read_all_maintainer_files();

    self_test();

    exit 0;

}



if (-t STDIN && !@ARGV) {

    # We're talking to a terminal, but have no command line arguments.

    die "$P: missing patchfile or -f file - use --help if necessary\n";

}



 0 if ($output_separator ne ", ");

$output_rolestats = 1 if ($interactive);

 1 if ($output_rolestats);

    $sections = 1;

 0;

    $email_list = 0;

 0;

    $status = 0;

 0;

    $web = 0;

 0;

    $interactive = 0;

} else {

 $email + $scm + $status + $subsystem + $web;

my @typevalue = ();

my %keyword_hash;

 ();

my @self_test_info = ();



sub read_maintainer_file {

 @_;

    my $i = 1;

    while (<$maint>) {

 $_;

	if ($line =~ m/^([A-Z]):\s*(.*)/) {

 $1;

	    my $value = $2;



	    ##Filename pattern matching

	    if ($type eq "F" || $type eq "X") {

~ s@\.@\\\.@g;       ##Convert . to \.

		$value =~ s/\*/\.\*/g;       ##Convert * to .*

~ s/\?/\./g;         ##Convert ? to .

		    $value =~ s@([^/])$@$1/@;

		}

	    } elsif ($type eq "K") {

 $value;

/)) {

	    push(@self_test_info, {file=>$file, linenr=>$i, line=>$line});

	}

	$i++;

    }

    close($maint);

}



sub find_is_maintainer_file {

 $_;

    $file = $File::Find::name;

    return if (! -f $file);

    push(@mfiles, $file);

}



sub find_ignore_git {

    return grep { $_ !~ /^\.git$/; } @_;

}



read_all_maintainer_files();



sub read_all_maintainer_files {

 "${lk_path}MAINTAINERS";

	$path = $maintainer_path;

	# Perl Cookbook tilde expansion if necessary

~ s@^~([^/]*)@ $1 ? (getpwnam($1))[7] : ( $ENV{HOME} || $ENV{LOGDIR} || (getpwuid($<))[7])@ex;

	$path .= '/' if ($path !~ m@/$@);

	if ($find_maintainer_files) {

> \&find_is_maintainer_file,

		    preprocess => \&find_ignore_git,

> 1,

	    my @files = readdir(DIR);

	    closedir(DIR);

	    foreach my $file (@files) {

		push(@mfiles, "$path$file") if ($file !~ /^\./);

	    }

	}

    } elsif (-f "$path") {

	push(@mfiles, "$path");

    } else {

	die "$P: MAINTAINER file not found '$path'\n";

    }

    die "$P: No MAINTAINER files found in '$path'\n" if (scalar(@mfiles) == 0);

    foreach my $file (@mfiles) {

	read_maintainer_file("$file");

    }

}



sub maintainers_in_file {

 @_;

    return if ($file =~ m@\bMAINTAINERS$@);



~ /\.yaml$/)) {

	my $text = do { local($/) ; <$f> };

	close($f);



	my @poss_addr = $text =~ m$[A-Za-z-\"\' \,\.\+-]*\s*[\,]*\s*[\(\<\{]{0,1}[A-Za-z0-9_\.\+-]+\@[A-Za-z0-9\.-]+\.[A-Za-z0-9]+[\)\>\}]{0,1}$g;

	push(@file_emails, clean_file_emails(@poss_addr));

    }

}



#

# Read mail address map

#



my $mailmap;



read_mailmap();



sub read_mailmap {

 {

	names => {},

> {}

.*$//; 
trim

skip empty lines

entries have one of the following formats:

 name1 <mail1>

 <mail1> <mail2>

 name1 <mail1> <mail2>

 name1 <mail1> name2 <mail2>

 (see man git-shortlog)

	    my $real_name = $1;

 $2;

	    $real_name =~ s/\s+$//;

 parse_email("$real_name <$address>");

	    $mailmap->{names}->{$address} = $real_name;



	} elsif (/^<([^>]+)>\s*<([^>]+)>$/) {

 $1;

	    my $wrong_address = $2;



 $real_address;

	    my $real_name = $1;

 $2;

	    my $wrong_address = $3;



~ s/\s+$//;

	    ($real_name, $real_address) =

		parse_email("$real_name <$real_address>");

 $real_name;

	    $mailmap->{addresses}->{$wrong_address} = $real_address;



	} elsif (/^(.+)<([^>]+)>\s*(.+)\s*<([^>]+)>$/) {

 $1;

	    my $real_address = $2;

 $3;

	    my $wrong_address = $4;



~ s/\s+$//;

	    ($real_name, $real_address) =

		parse_email("$real_name <$real_address>");



~ s/\s+$//;

	    ($wrong_name, $wrong_address) =

		parse_email("$wrong_name <$wrong_address>");



 format_email($wrong_name, $wrong_address, 1);

	    $mailmap->{names}->{$wrong_email} = $real_name;

 $real_address;

	$file = canonpath($file);

	##if $file is a directory and it lacks a trailing slash, add one

	if ((-d $file)) {

~ s@([^/])$@$1/@;

	$file =~ s/^\Q${cur_path}\E//;	#strip any absolute path

or the path to the lk tree

	    my $text = do { local($/) ; <$f> };

	    close($f);

	    if ($keywords) {

		foreach my $line (keys %keyword_hash) {

~ m/$keyword_hash{$line}/x) {

	my $file_cnt = @files;

	my $lastfile;



	open(my $patch, "< $file")

	    or die "$P: Can't open $file: $!\n";



	# We can check arbitrary information before the patch

	# like the commit message, mail headers, etc...

	# This allows us to match arbitrary keywords against any part

	# of a git format-patch generated file (subject tags, etc...)



Parsing the intro

	    my $patch_line = $_;

> [0-7]+ (\S+)\s*$/) {

		my $filename = $1;

		push(@files, $filename);

	    } elsif (m/^rename (?:from|to) (\S+)\s*$/) {

 $1;

		my $filename1 = $1;

 $2;

		my $filename = $1;

~ s@^[^/]*/@@;

		$filename =~ s@\n@@;

 $filename;

		$patch_prefix = "^[+-].*";	#Now parsing the actual patch

	    } elsif (m/^\@\@ -(\d+),(\d+)/) {

		if ($email_git_blame) {

		    push(@range, "$lastfile:$1:$2");

		}

	    } elsif ($keywords) {

		foreach my $line (keys %keyword_hash) {

~ m/${patch_prefix}$keyword_hash{$line}/x) {

	@files = sort_and_uniq(@files);

    }

}



 uniq(@file_emails);

@fixes = uniq(@fixes);



my %email_hash_name;

my %email_hash_address;

 ();

my @list_to = ();

 ();

my @web = ();

 ();

my @status = ();

 ();

my %deduplicate_address_hash = ();



 get_maintainers();

    @maintainers = merge_email(@maintainers);

    output(@maintainers);

}



if ($scm) {

 uniq(@scm);

    @status = uniq(@status);

    output(@status);

}



if ($subsystem) {

 uniq(@subsystem);

    @web = uniq(@web);

    output(@web);

}



exit($exit);



sub self_test {

 ();

    my @good_links = ();

 ();

    my @section_headers = ();

 0;

    @lsfiles = vcs_list_files($lk_path);



    for my $x (@self_test_info) {

	$index++;



	## Section header duplication and missing section content

~ /\bsections\b/) &&

	    $x->{line} =~ /^\S[^:]/ &&

	    defined $self_test_info[$index] &&

~ /^([A-Z]):\s*\S/) {

	    my $has_S = 0;

 0;

	    my $has_ML = 0;

 "";

	    my $nextline = $index;

	    while (defined $self_test_info[$nextline] &&

~ /^([A-Z]):\s*(\S.*)/) {

		my $type = $1;

 $2;

		    $has_S = 1;

 $value;

		    $has_F = 1;

		} elsif ($type eq "M" || $type eq "R" || $type eq "L") {

 1;

	my $type = $1;

 $2;

	    ($self_test eq "" || $self_test =~ /\bpatterns\b/)) {

~ s@\.@\\\.@g;       ##Convert . to \.

	    $value =~ s/\*/\.\*/g;       ##Convert * to .*

~ s/\?/\./g;         ##Convert ? to .

		$value =~ s@([^/])$@$1/@;

	    }

	    if (!grep(m@^$value@, @lsfiles)) {

		print("$x->{file}:$x->{linenr}: warning: no file matches\t$x->{line}\n");

	    }



	## Link reachability

	} elsif (($type eq "W" || $type eq "Q" || $type eq "B") &&

~ /^https?:/ &&

		 ($self_test eq "" || $self_test =~ /\blinks\b/)) {

	    next if (grep(m@^\Q$value\E$@, @good_links));

 0;

	        $isbad = 1;

	    } else {

 `wget --spider -q --no-check-certificate --timeout 10 --tries 1 $value`;

		    $isbad = 1;

		}

	    }

	    if ($isbad) {

	        print("$x->{file}:$x->{linenr}: warning: possible bad link\t$x->{line}\n");

	    }



	## SCM reachability

	} elsif ($type eq "T" &&

~ /\bscm\b/)) {

	    my $isbad = 0;

	    if (grep(m@^\Q$value\E$@, @bad_links)) {

 1;

	    } elsif ($value =~ /^git\s+(\S+)(\s+([^\(]+\S+))?/) {

 $1;

		my $branch = "";

 $3 if $3;

		my $output = `git ls-remote --exit-code -h "$url" $branch > /dev/null 2>&1`;

		if ($? == 0) {

		    push(@good_links, $value);

		} else {

		    push(@bad_links, $value);

 1;

	    } elsif ($value =~ /^(?:quilt|hg)\s+(https?:\S+)/) {

 $1;

		my $output = `wget --spider -q --no-check-certificate --timeout 10 --tries 1 $url`;

		if ($? == 0) {

		    push(@good_links, $value);

		} else {

		    push(@bad_links, $value);

 1;

    my ($address) = @_;



    foreach my $ignore (@ignore_emails) {

	return 1 if ($ignore eq $address);

    }



    return 0;

}



sub range_is_maintained {

 @_;

    for (my $i = $start; $i < $end; $i++) {

 $typevalue[$i];

	if ($line =~ m/^([A-Z]):\s*(.*)/) {

 $1;

	    my $value = $2;

	    if ($type eq 'S') {

~ /(maintain|support)/i) {

    my ($start, $end) = @_;



 $start; $i < $end; $i++) {

	my $line = $typevalue[$i];

~ m/^([A-Z]):\s*(.*)/) {

	    my $type = $1;

 $2;

    %email_hash_name = ();

 ();

    %commit_author_hash = ();

 ();

    @email_to = ();

 ();

    @list_to = ();

 ();

    @web = ();

 ();

    @status = ();

 ();

    %deduplicate_address_hash = ();

    if ($email_git_all_signature_types) {

 "(.+?)[Bb][Yy]:";

	$signature_pattern = "\(" . join("|", @signature_tags) . "\)";

    }



    # Find responsible parties



 ();

	my $tvi = find_first_section();

	while ($tvi < @typevalue) {

 find_starting_index($tvi);

	    my $end = find_ending_index($tvi);

 0;

Do not match excluded file patterns

	    for ($i = $start; $i < $end; $i++) {

 $typevalue[$i];

		if ($line =~ m/^([A-Z]):\s*(.*)/) {

 $1;

		    my $value = $2;

		    if ($type eq 'X') {

			if (file_match_pattern($file, $value)) {

 1;

		for ($i = $start; $i < $end; $i++) {

 $typevalue[$i];

		    if ($line =~ m/^([A-Z]):\s*(.*)/) {

 $1;

			my $value = $2;

			if ($type eq 'F') {

			    if (file_match_pattern($file, $value)) {

				my $value_pd = ($value =~ tr@/@@);

				my $file_pd = ($file  =~ tr@/@@);

				$value_pd++ if (substr($value,-1,1) ne "/");

				$value_pd = -1 if ($value =~ /^\.\*/);

 $file_pd &&

				    $exact_pattern_match_hash{$file} = 1;

				}

				if ($pattern_depth == 0 ||

				    (($file_pd - $value_pd) < $pattern_depth)) {

 $value_pd;

			    if ($file =~ m/$value/x) {

 0;

	    $tvi = $end + 1;

	}



> $hash{$a}} keys %hash) {

		my $start = find_starting_index($line);

 find_ending_index($line);

		for ($i = $start; $i < $end; $i++) {

 $typevalue[$i];

		    if ($line =~ /^[FX]:/) {		##Restore file patterns

~ s/([^\\])\.([^\*])/$1\?$2/g;

			$line =~ s/([^\\])\.$/$1\?/g;	##Convert . back to ?

~ s/\\\./\./g;       	##Convert \. to .

			$line =~ s/\.\*/\*/g;       	##Convert .* to *

		    }

		    my $count = $line =~ s/^([A-Z]):/$1:\t/g;

~ /$1/i)) {

	@keyword_tvi = sort_and_uniq(@keyword_tvi);

	foreach my $line (@keyword_tvi) {

	    add_categories($line);

	}

    }



    foreach my $email (@email_to, @list_to) {

 deduplicate_email($email->[0]);

	    if ($chief =~ m/^(.*):(.*)/) {

		my $email_address;



 format_email($1, $2, $email_usename);

		    @email_to = grep($_->[0] !~ /${email_address}/, @email_to);

		}

	    }

	}



	foreach my $email (@file_emails) {

 parse_email($email);

	    my $tmp_email = format_email($name, $address, $email_usename);

	    push_email_address($tmp_email, '');

	    add_role($tmp_email, 'in file');

	}

    }



    foreach my $fix (@fixes) {

	vcs_add_commit_signers($fix, "blamed_fixes");

    }



 ();

	    @to = (@to, @email_to);

	}

	if ($email_list) {

 (@to, @list_to);

	@to = interactive_get_maintainers(\@to);

    }



    return @to;

}



sub file_match_pattern {

 @_;

	if ($file =~ m@^$pattern@) {

	    return 1;

	}

    } else {

~ m@^$pattern@) {

 ($file 
 ($pattern 
  --email => print email address(es) if any

> include recent git \*-by: signers

    --git-all-signature-types => include signers regardless of signature type

        or use only ${signature_pattern} signers (default: $email_git_all_signature_types)

> use git when no exact MAINTAINERS pattern (default: $email_git_fallback)

    --git-chief-penguins => include ${penguin_chiefs}

> number of signatures required (default: $email_git_min_signatures)

    --git-max-maintainers => maximum maintainers to add (default: $email_git_max_maintainers)

> minimum percentage of commits required (default: $email_git_min_percent)

    --git-blame => use git blame to find modified commits for patch or file

> when used with --git-blame, also include all commit signers

    --git-since => git history to use (default: $email_git_since)

> hg history to use (default: $email_hg_since)

    --interactive => display a menu (mostly useful if used with the --git option)

> include maintainer(s) if any

    --r => include reviewer(s) if any

> include name 'Full Name <addr\@domain.tld>'

    --l => include list(s) if any

> include moderated lists(s) if any (default: true)

    --s => include subscriber only list(s) if any (default: false)

> minimize duplicate email names/addresses

    --roles => show roles (status:subsystem, git-signer, list, etc...)

> show roles and statistics (commits/total_commits, %)

    --file-emails => add email addresses found in -f file (default: 0 (off))

> for patches, add signatures of commits with 'Fixes: <commit>' (default: 1 (on))

  --scm => print SCM tree(s) if any

> print status if any

  --subsystem => print subsystem name if any

> print website(s) if any

  --separator [, ] => separator for multiple entries on 1 line

    using --separator also sets --nomultiline if --separator is not [, ]

> print 1 entry per line

  --pattern-depth => Number of pattern directory traversals (default: 0 (all))

> scan patch for keywords (default: $keywords)

  --sections => print all of the subsystem sections with pattern matches

> print all matching 'letter' types from all matching sections

  --mailmap => use .mailmap file (default: $email_use_mailmap)

> run without a kernel tree

  --self-test => show potential issues with MAINTAINERS file content

> show version

  --help => show this help information



Default options:

  [--email --tree --nogit --git-fallback --m --r --n --l --multiline

0 --remove-duplicates --rolestats]

  Using "--rolestats" and "--git-blame" shows the #/total=% commits,

      not the percentage of the entire file authored.  # of commits is

      not a good measure of amount of code authored.  1 major commit may

      contain a thousand lines, 5 trivial commits may modify a single line.

  If git is not installed, but mercurial (hg) is installed and an .hg

      repository exists, the following options apply to mercurial:

          --git,

          --git-min-signatures, --git-max-maintainers, --git-min-percent, and

          --git-blame

      Use --hg-since not --git-since to control date selection

  File ".get_maintainer.conf", if it exists in the linux kernel source root

      directory, can change whatever get_maintainer defaults are desired.

      Entries in this file can be any command line argument.

      This file is prepended to any additional command line arguments.

      Multiple lines and # comments are allowed.

  Most options have both positive and negative forms.

      The negative forms for --<foo> are --no<foo> and --no-<foo>.



EOT

}



sub top_of_kernel_tree {

 @_;

	$lk_path .= "/";

    }

    if (   (-f "${lk_path}COPYING")

	&& (-f "${lk_path}CREDITS")

	&& (-f "${lk_path}Kbuild")

	&& (-e "${lk_path}MAINTAINERS")

	&& (-f "${lk_path}Makefile")

	&& (-f "${lk_path}README")

	&& (-d "${lk_path}Documentation")

	&& (-d "${lk_path}arch")

	&& (-d "${lk_path}include")

	&& (-d "${lk_path}drivers")

	&& (-d "${lk_path}fs")

	&& (-d "${lk_path}init")

	&& (-d "${lk_path}ipc")

	&& (-d "${lk_path}kernel")

	&& (-d "${lk_path}lib")

	&& (-d "${lk_path}scripts")) {

	return 1;

    }

    return 0;

}



sub parse_email {

 @_;

    my $name = "";

 "";

    if ($formatted_email =~ /^([^<]+)<(.+\@.*)>.*$/) {

 $1;

	$address = $2;

~ /^\s*<(.+\@\S*)>.*$/) {

	$address = $1;

~ /^(.+\@\S*).*$/) {

	$address = $1;

    }



~ s/^\s+|\s+$//g;

    $name =~ s/^\"|\"$//g;

~ s/^\s+|\s+$//g;

    if ($name =~ /[^\w \-]/i) {  	 ##has "must quote" chars

~ s/(?<!\\)"/\\"/g;       ##escape quotes

	$name = "\"$name\"";

    }



    return ($name, $address);

}



sub format_email {

 @_;

    $name =~ s/^\s+|\s+$//g;

~ s/^\"|\"$//g;

    $address =~ s/^\s+|\s+$//g;



~ /[^\w \-]/i) {          ##has "must quote" chars

	$name =~ s/(?<!\\)"/\\"/g;       ##escape quotes

 "\"$name\"";

	    $formatted_email = "$address";

	} else {

 "$name <$address>";

	$formatted_email = $address;

    }



    return $formatted_email;

}



sub find_first_section {

 0;

	my $tv = $typevalue[$index];

~ m/^([A-Z]):\s*(.*)/)) {

    my ($index) = @_;



    while ($index > 0) {

 $typevalue[$index];

	if (!($tv =~ m/^([A-Z]):\s*(.*)/)) {

	    last;

	}

	$index--;

    }



    return $index;

}



sub find_ending_index {

 @_;

	my $tv = $typevalue[$index];

~ m/^([A-Z]):\s*(.*)/)) {

    my ($index) = @_;



 find_starting_index($index);

    my $subsystem = $typevalue[$start];

    if ($output_section_maxlen && length($subsystem) > $output_section_maxlen) {

 substr($subsystem, 0, $output_section_maxlen - 3);

	$subsystem =~ s/\s*$//;

 $subsystem . "...";

    my ($index) = @_;



    my $i;

 find_starting_index($index);

    my $end = find_ending_index($index);



 "unknown";

    my $subsystem = get_subsystem_name($index);



 $start + 1; $i < $end; $i++) {

	my $tv = $typevalue[$i];

~ m/^([A-Z]):\s*(.*)/) {

	    my $ptype = $1;

 $2;

		$role = $pvalue;

	    }

	}

    }



 lc($role);

	$role = "supporter";

    } elsif ($role eq "maintained") {

 "maintainer";

	$role = "odd fixer";

    } elsif ($role eq "orphan") {

 "orphan minder";

	$role = "obsolete minder";

    } elsif ($role eq "buried alive in reporters") {

 "chief penguin";

    my ($index) = @_;



 get_subsystem_name($index);

	$subsystem = "";

    }



    return $subsystem;

}



sub add_categories {

 @_;

    my $start = find_starting_index($index);

 find_ending_index($index);

    for ($i = $start + 1; $i < $end; $i++) {

 $typevalue[$i];

	if ($tv =~ m/^([A-Z]):\s*(.*)/) {

 $1;

	    my $pvalue = $2;

	    if ($ptype eq "L") {

 $pvalue;

		my $list_additional = "";

 get_list_role($i);

		    $list_role = ":" . $list_role;

		}

~ m/([^\s]+)\s+(.*)$/) {

		    $list_address = $1;

 $2;

		if ($list_additional =~ m/subscribers-only/) {

		    if ($email_subscriber_list) {

			if (!$hash_list_to{lc($list_address)}) {

 1;

			    if ($list_additional =~ m/moderated/) {

				if ($email_moderated_list) {

 1;

				$hash_list_to{lc($list_address)} = 1;

				push(@list_to, [$list_address,

						"open list${list_role}"]);

			    }

			}

		    }

		}

	    } elsif ($ptype eq "M") {

		if ($email_maintainer) {

 get_maintainer_role($i);

		    my $subsystem = get_subsystem_name($i);

		    push_email_addresses($pvalue, "reviewer:$subsystem");

		}

	    } elsif ($ptype eq "T") {

		push(@scm, $pvalue);

	    } elsif ($ptype eq "W") {

		push(@web, $pvalue);

	    } elsif ($ptype eq "S") {

		push(@status, $pvalue);

	    }

	}

    }

}



sub email_inuse {

 @_;

    my ($line, $role) = @_;



 parse_email($line);

    my ($address, $role) = @_;



 ();

    } elsif (@address_list = rfc822_validlist($address)) {

 shift(@address_list);

	while (my $entry = shift(@address_list)) {

	    push_email_address($entry, $role);

	}

    } else {

	if (!push_email_address($address, $role)) {

	    warn("Invalid MAINTAINERS address: '" . $address . "'\n");

	}

    }

}



sub add_role {

 @_;

    my ($name, $address) = parse_email($line);

 format_email($name, $address, $email_usename);

	    my ($entry_name, $entry_address) = parse_email($entry->[0]);

	    if (($name eq $entry_name || $address eq $entry_address)

~ m/$role/))

		    $entry->[1] = "$role";

		} else {

 "$entry->[1],$role";

		&& ($role eq "" || !($entry->[1] =~ m/$role/))

	    ) {

		if ($entry->[1] eq "") {

 "$role";

		    $entry->[1] = "$entry->[1],$role";

		}

	    }

	}

    }

}



sub which {

 @_;

    my ($conf) = @_;



    foreach my $path (split(/:/, ".:$ENV{HOME}:.scripts")) {

	if (-e "$path/$conf") {

	    return "$path/$conf";

	}

    }



    return "";

}



sub mailmap_email {

 @_;

    my ($name, $address) = parse_email($line);

 format_email($name, $address, 1);

    my $real_name = $name;

 $address;

	    $real_name = $mailmap->{names}->{$email};

	}

	if (exists $mailmap->{addresses}->{$email}) {

 $mailmap->{addresses}->{$email};

	    $real_name = $mailmap->{names}->{$address};

	}

	if (exists $mailmap->{addresses}->{$address}) {

 $mailmap->{addresses}->{$address};

    my (@addresses) = @_;



 ();

    my (@emails) = @_;



    foreach my $email (@emails) {

 parse_email($email);

	    $address = $address_map{$name};

 format_email($name, $address, 1);

	    $address_map{$name} = $address;

	}

    }

}



sub git_execute_cmd {

 @_;

    my @lines = ();



 `$cmd`;

    $output =~ s/^\s*//gm;

 split("\n", $output);

    my ($cmd) = @_;

 ();

    my $output = `$cmd`;

 split("\n", $output);

    my (@signature_lines) = @_;



 @signature_lines;

 cut -f2- -d":"

	$signer = deduplicate_email($signer);

    }



    return (\@type, \@signature_lines);

}



sub vcs_find_signers {

 @_;

    my @lines = ();

 ();

    my @authors = ();

 ();

    @lines = &{$VCS_cmds{"execute_cmd"}}($cmd);



 $VCS_cmds{"commit_pattern"};

    my $author_pattern = $VCS_cmds{"author_pattern"};

 $VCS_cmds{"stat_pattern"};

    $stat_pattern =~ s/(\$\w+)/$1/eeg;		#interpolate $stat_pattern



 of commits

    @authors = grep(/$author_pattern/, @lines);

 grep(/^[ \t]*${signature_pattern}.*\@.*$/, @lines);

    @stats = grep(/$stat_pattern/, @lines);



#    print("stats: <@stats>\n");



    return (0, \@signatures, \@authors, \@stats) if !@signatures;



    save_commits_by_author(@lines) if ($interactive);

    save_commits_by_signer(@lines) if ($interactive);



    if (!$email_git_penguin_chiefs) {

 grep(!/${penguin_chiefs}/i, @signatures);

    my ($author_ref, $authors_ref) = extract_formatted_signatures(@authors);

 extract_formatted_signatures(@signatures);

    my ($cmd) = @_;

 ();

    @lines = &{$VCS_cmds{"execute_cmd"}}($cmd);



    if (!$email_git_penguin_chiefs) {

 grep(!/${penguin_chiefs}/i, @lines);

    my @authors = ();

    foreach my $line (@lines) {

~ m/$VCS_cmds{"author_pattern"}/) {

	    my $author = $1;

 parse_email($author);

	    $author = format_email($name, $address, 1);

	    push(@authors, $author);

	}

    }



    save_commits_by_author(@lines) if ($interactive);

    save_commits_by_signer(@lines) if ($interactive);



    return @authors;

}



sub vcs_save_commits {

 @_;

    my @lines = ();

 ();

    @lines = &{$VCS_cmds{"execute_cmd"}}($cmd);



    foreach my $line (@lines) {

~ m/$VCS_cmds{"blame_commit_pattern"}/) {

    my ($file) = @_;

    my $cmd;

 ();

	my @all_commits = ();



 $VCS_cmds{"blame_file_cmd"};

	$cmd =~ s/(\$\w+)/$1/eeg;		#interpolate $cmd

 vcs_save_commits($cmd);

	    next if (!($file_range_diff =~ m/(.+):(.+):(.+)/));

 $1;

	    my $diff_start = $2;

 $3;

	    for (my $i = $diff_start; $i < $diff_start + $diff_length; $i++) {

		push(@commits, $all_commits[$i]);

	    }

	}

    } elsif (@range) {

	foreach my $file_range_diff (@range) {

~ m/(.+):(.+):(.+)/));

	    my $diff_file = $1;

 $2;

	    my $diff_length = $3;

	    next if ("$file" ne "$diff_file");

 $VCS_cmds{"blame_range_cmd"};

	    $cmd =~ s/(\$\w+)/$1/eeg;		#interpolate $cmd

	    push(@commits, vcs_save_commits($cmd));

	}

    } else {

 $VCS_cmds{"blame_file_cmd"};

	$cmd =~ s/(\$\w+)/$1/eeg;		#interpolate $cmd

 vcs_save_commits($cmd);

	$commit =~ s/^\^//g;

    }



    return @commits;

}



 0;

    %VCS_cmds = %VCS_cmds_git;

    return 1 if eval $VCS_cmds{"available"};

 %VCS_cmds_hg;

    %VCS_cmds = ();

    if (!$printed_novcs) {

	warn("$P: No supported VCS found.  Add --nogit to options?\n");

	warn("Using a git repository produces better results.\n");

	warn("Try Linus Torvalds' latest git repository using:\n");

	warn("git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n");

 1;

    my ($commit, $desc) = @_;

 0;

    my @commit_authors = ();

 ();

    $cmd = $VCS_cmds{"find_commit_signers_cmd"};

substitute variables in $cmd

    ($commit_count, $commit_signers_ref, $commit_authors_ref, $stats_ref) = vcs_find_signers($cmd, "");

 @{$commit_authors_ref} if defined $commit_authors_ref;

    @commit_signers = @{$commit_signers_ref} if defined $commit_signers_ref;



    foreach my $signer (@commit_signers) {

 deduplicate_email($signer);

    my ($list_ref) = @_;

 @$list_ref;

    my $count = 0;

 0;

 1 if ($entry->[1] 
	$selected{$count} = 1;

 0;

	$signed{$count} = 0;

	$count++;

    }



    #menu loop

 0;

    my $print_options = 0;

 1;

	$count = 0;

	if ($redraw) {

	    printf STDERR "\n%1s %2s %-65s",

			  "*", "#", "email/list and role:stats";

	    if ($email_git ||

		($email_git_fallback && !$maintained) ||

		$email_git_blame) {

		print STDERR "auth sign";

	    }

	    print STDERR "\n";

	    foreach my $entry (@list) {

 $entry->[0];

		my $role = $entry->[1];

 "";

		$sel = "*" if ($selected{$count});

 $commit_author_hash{$email};

		my $commit_signer = $commit_signer_hash{$email};

 0;

		my $signed = 0;

		$authored++ for (@{$commit_author});

		$signed++ for (@{$commit_signer});

		printf STDERR "%1s %2d %-65s", $sel, $count + 1, $email;

		printf STDERR "%4d %4d", $authored, $signed

		    if ($authored > 0 || $signed > 0);

		printf STDERR "\n     %s\n", $role;

		if ($authored{$count}) {

 $commit_author_hash{$email};

		    my $commit_signer = $commit_signer_hash{$email};

		    foreach my $ref (@{$commit_signer}) {

			print STDERR "     @{$ref}[2]: @{$ref}[1]\n";

		    }

		}



		$count++;

	    }

	}

 \$email_git_since;

	$date_ref = \$email_hg_since if (vcs_is_hg());

	if ($print_options) {

 0;

 minimum commits      [$email_git_min_signatures]

 min percent          [$email_git_min_percent]

 history to use       [$$date_ref]

 max maintainers      [$email_git_max_maintainers]

 pattern match depth  [$pattern_depth]

(toggle), A(signed) *(all), ^(none), O(options), Y(approve): ";

	my $input = <STDIN>;

	chomp($input);



 1;

	my $rerun = 0;

 split(/[, ]+/, $input);

	    $nr = lc($nr);

 substr($nr, 0, 1);

	    my $str = substr($nr, 1);

 0;

 $1 if $str 
		$interactive = 0;

 1;

		$output_rolestats = 0;

 0;

~ /^\d+$/ && $nr > 0 && $nr <
		$selected{$nr - 1} = !$selected{$nr - 1};

	    } elsif ($sel eq "*" || $sel eq '^') {

 0;

		$toggle = 1 if ($sel eq '*');

 0; $i < $count; $i++) {

		    $selected{$i} = $toggle;

		}

	    } elsif ($sel eq "0") {

 0; $i < $count; $i++) {

		    $selected{$i} = !$selected{$i};

		}

	    } elsif ($sel eq "t") {

		if (lc($str) eq "m") {

 0; $i < $count; $i++) {

			$selected{$i} = !$selected{$i}

~ /^(maintainer|supporter)/i);

		    for (my $i = 0; $i < $count; $i++) {

 !$selected{$i}

			    if ($list[$i]->[1] =~ /^(author|commit|signer)/i);

		    }

		} elsif (lc($str) eq "l") {

 0; $i < $count; $i++) {

			$selected{$i} = !$selected{$i}

~ /^(open list)/i);

		    for (my $i = 0; $i < $count; $i++) {

 !$selected{$i}

			    if ($list[$i]->[1] =~ /^(subscriber list)/i);

		    }

		}

	    } elsif ($sel eq "a") {

 $count) {

		    $authored{$val - 1} = !$authored{$val - 1};

		} elsif ($str eq '*' || $str eq '^') {

 0;

		    $toggle = 1 if ($str eq '*');

 0; $i < $count; $i++) {

			$authored{$i} = $toggle;

		    }

		}

	    } elsif ($sel eq "s") {

 $count) {

		    $signed{$val - 1} = !$signed{$val - 1};

		} elsif ($str eq '*' || $str eq '^') {

 0;

		    $toggle = 1 if ($str eq '*');

 0; $i < $count; $i++) {

			$signed{$i} = $toggle;

		    }

		}

	    } elsif ($sel eq "o") {

 1;

		$redraw = 1;

	    } elsif ($sel eq "g") {

		if ($str eq "f") {

		    bool_invert(\$email_git_fallback);

		} else {

		    bool_invert(\$email_git);

		}

 1;

		$rerun = 1;

	    } elsif ($sel eq "c") {

		if ($val > 0) {

 $val;

		    $rerun = 1;

		}

	    } elsif ($sel eq "x") {

		if ($val > 0) {

 $val;

		    $rerun = 1;

		}

	    } elsif ($sel eq "%") {

 0) {

		    $email_git_min_percent = $val;

 1;

		    $email_git_since = $str;

		} elsif (vcs_is_hg()) {

 $str;

		$rerun = 1;

	    } elsif ($sel eq "t") {

		bool_invert(\$email_git_all_signature_types);

 1;

		$rerun = 1;

	    } elsif ($sel eq "r") {

		bool_invert(\$email_remove_duplicates);

 1;

		$rerun = 1;

	    } elsif ($sel eq "k") {

		bool_invert(\$keywords);

 1;

		if ($str ne "" && $val >= 0) {

 $val;

		    $rerun = 1;

		}

	    } elsif ($sel eq "h" || $sel eq "?") {

		print STDERR <<EOT



Interactive mode allows you to select the various maintainers, submitters,

commit signers and mailing lists that could be CC'd on a patch.



Any *'d entry is selected.



If you have git or hg installed, you can choose to summarize the commit

history of files in the patch.  Also, each line of the current file can

be matched to its commit author and that commits signers with blame.



Various knobs exist to control the length of time for active commit

tracking, the maximum number of commit authors and signers to add,

and such.



Enter selections at the prompt until you are satisfied that the selected

maintainers are appropriate.  You may enter multiple selections separated

by either commas or spaces.



EOT

	    } else {

		print STDERR "invalid option: '$nr'\n";

 0;

drop not selected entries

    $count = 0;

 ();

    my ($bool_ref) = @_;



    if ($$bool_ref) {

 0;

	$$bool_ref = 1;

    }

}



sub deduplicate_email {

 @_;

    my $matched = 0;

 parse_email($email);

    $email = format_email($name, $address, 1);

 mailmap_email($email);

    ($name, $address) = parse_email($email);



    if ($name ne "" && $deduplicate_name_hash{lc($name)}) {

 $deduplicate_name_hash{lc($name)}->[0];

	$address = $deduplicate_name_hash{lc($name)}->[1];

 1;

	$name = $deduplicate_address_hash{lc($address)}->[0];

 $deduplicate_address_hash{lc($address)}->[1];

	$matched = 1;

    }

    if (!$matched) {

 [ $name, $address ];

	$deduplicate_address_hash{lc($address)} = [ $name, $address ];

    }

 format_email($name, $address, 1);

    $email = mailmap_email($email);

    return $email;

}



sub save_commits_by_author {

 @_;

    my @authors = ();

 ();

    my @subjects = ();



    foreach my $line (@lines) {

~ m/$VCS_cmds{"author_pattern"}/) {

	    my $author = $1;

 deduplicate_email($author);

	push(@commits, $1) if ($line =~ m/$VCS_cmds{"commit_pattern"}/);

~ m/$VCS_cmds{"subject_pattern"}/);

    for (my $i = 0; $i < @authors; $i++) {

 0;

		$exists = 1;

		last;

	    }

	}

	if (!$exists) {

	    push(@{$commit_author_hash{$authors[$i]}},

		 [ ($commits[$i], $subjects[$i]) ]);

	}

    }

}



sub save_commits_by_signer {

 @_;

    my $commit = "";

 "";

 $1 if ($line 
 $1 if ($line 
	if ($line =~ /^[ \t]*${signature_pattern}.*\@.*$/) {

 ($line);

	    my ($types_ref, $signers_ref) = extract_formatted_signatures(@signatures);

 @$types_ref;

	    my @signers = @$signers_ref;



 $types[0];

	    my $signer = $signers[0];



 deduplicate_email($signer);

	    my $exists = 0;

	    foreach my $ref(@{$commit_signer_hash{$signer}}) {

		if (@{$ref}[0] eq $commit &&

		    @{$ref}[1] eq $subject &&

		    @{$ref}[2] eq $type) {

 1;

    my ($role, $divisor, @lines) = @_;



    my %hash;

 0;

    return if (@lines <= 0);



 0) {

	$divisor = 1;

    }



 mailmap(@lines);

    return if (@lines <= 0);



 sort(@lines);

 uniq -c

 sort -rn

    foreach my $line (sort {$hash{$b} <=> $hash{$a}} keys %hash) {

 $hash{$line};

	my $percent = $sign_offs * 100 / $divisor;



 100 if ($percent > 100);

	    my $fmt_percent = sprintf("%.0f", $percent);

$fmt_percent%");

    my ($file) = @_;



    my $authors_ref;

    my $signers_ref;

    my $stats_ref;

 ();

    my @signers = ();

 ();

    $vcs_used = vcs_exists();

    return if (!$vcs_used);



 $VCS_cmds{"find_signers_cmd"};

    $cmd =~ s/(\$\w+)/$1/eeg;		# interpolate $cmd



 vcs_find_signers($cmd, $file);

    @signers = @{$signers_ref} if defined $signers_ref;

 @{$authors_ref} if defined $authors_ref;

    @stats = @{$stats_ref} if defined $stats_ref;



#    print("commits: <$commits>\nsigners:<@signers>\nauthors: <@authors>\nstats: <@stats>\n");



    foreach my $signer (@signers) {

 deduplicate_email($signer);

authors == $
	my $stat_pattern = $VCS_cmds{"stat_pattern"};

interpolate $stat_pattern

	my $added = 0;

 0;

stats; $i++) {
 $#stats; $i++) {

	    if ($stats[$i] =~ /$stat_pattern/) {

 $1;

		$deleted += $2;

	    }

	}

 uniq(@authors);

	    $author = deduplicate_email($author);

	}

 uniq(@tmp_authors);

	my @list_added = ();

 ();

	    my $auth_added = 0;

 0;

stats; $i++) {
 $#stats; $i++) {

		    $stats[$i] =~ /$stat_pattern/) {

 $1;

		    $auth_deleted += $2;

		}

	    }

 0; $i < $auth_added; $i++) {

	    for (my $i = 0; $i < $auth_deleted; $i++) {

		push(@list_deleted, $author);

	    }

	}

	vcs_assign("added_lines", $added, @list_added);

	vcs_assign("removed_lines", $deleted, @list_deleted);

    }

}



sub vcs_file_blame {

 @_;

    my @signers = ();

 ();

    my @commits = ();

    my $total_commits;

    my $total_lines;



 vcs_exists();

    @all_commits = vcs_blame($file);

 uniq(@all_commits);

    $total_commits = @commits;

 @all_commits;

	    my @commit_authors = ();

 ();

	    my $commit = join(" -r ", @commits);

	    my $cmd;



 $VCS_cmds{"find_commit_signers_cmd"};

	    $cmd =~ s/(\$\w+)/$1/eeg;	#substitute variables in $cmd



 vcs_find_signers($cmd, $file);

	    @commit_authors = @{$commit_authors_ref} if defined $commit_authors_ref;

 @{$commit_signers_ref} if defined $commit_signers_ref;

		my @commit_authors = ();

 ();

		$cmd = $VCS_cmds{"find_commit_signers_cmd"};

substitute variables in $cmd

		($commit_count, $commit_signers_ref, $commit_authors_ref, $stats_ref) = vcs_find_signers($cmd, $file);

 @{$commit_authors_ref} if defined $commit_authors_ref;

		@commit_signers = @{$commit_signers_ref} if defined $commit_signers_ref;



		push(@signers, @commit_signers);

	    }

	}

    }



    if ($from_filename) {

	if ($output_rolestats) {

	    my @blame_signers;

	    if (vcs_is_hg()) {{		# Double brace for last exit

		my $commit_count;

 ();

		@commits = uniq(@commits);

 sort(@commits);

		my $commit = join(" -r ", @commits);

		my $cmd;



 $VCS_cmds{"find_commit_author_cmd"};

		$cmd =~ s/(\$\w+)/$1/eeg;	#substitute variables in $cmd



 ();

		@lines = &{$VCS_cmds{"execute_cmd"}}($cmd);



		if (!$email_git_penguin_chiefs) {

 grep(!/${penguin_chiefs}/i, @lines);

		my @authors = ();

		foreach my $line (@lines) {

~ m/$VCS_cmds{"author_pattern"}/) {

			my $author = $1;

 deduplicate_email($author);

		    my $cmd = $VCS_cmds{"find_commit_author_cmd"};

interpolate $cmd

		    my @author = vcs_find_author($cmd);

		    next if !@author;



 deduplicate_email($author[0]);

		    my $count = grep(/$commit/, @all_commits);

 0; $i < $count ; $i++) {

	    $signer = deduplicate_email($signer);

	}

	vcs_assign("commits", $total_commits, @signers);

    } else {

	foreach my $signer (@signers) {

 deduplicate_email($signer);

    my ($file) = @_;



    my $exists;



 vcs_exists();

    my $cmd = $VCS_cmds{"file_exists_cmd"};

 interpolate $cmd

    $cmd .= " 2>&1";

 &{$VCS_cmds{"execute_cmd"}}($cmd);

    return 0 if ($? != 0);



    return $exists;

}



sub vcs_list_files {

 @_;

    my @lsfiles = ();



 vcs_exists();

    my $cmd = $VCS_cmds{"list_files_cmd"};

 interpolate $cmd

    @lsfiles = &{$VCS_cmds{"execute_cmd"}}($cmd);



 0);

    my (@parms) = @_;



    my %saw;

 grep(!$saw{$_}++, @parms);

    my (@parms) = @_;



    my %saw;

 sort @parms;

    @parms = grep(!$saw{$_}++, @parms);

    return @parms;

}



sub clean_file_emails {

 @_;

    my @fmt_emails = ();



    foreach my $email (@file_emails) {

~ s/[\(\<\{]{0,1}([A-Za-z0-9_\.\+-]+\@[A-Za-z0-9\.-]+)[\)\>\}]{0,1}/\<$1\>/g;

	my ($name, $address) = parse_email($email);

	if ($name eq '"[,\.]"') {

 "";

	my @nw = split(/[^A-Za-z-\'\,\.\+-]/, $name);

	if (@nw > 2) {

 $nw[@nw - 3];

	    my $middle = $nw[@nw - 2];

 $nw[@nw - 1];

	    if (((length($first) == 1 && $first =~ m/[A-Za-z]/) ||

		 (length($first) == 2 && substr($first, -1) eq ".")) ||

		(length($middle) == 1 ||

		 (length($middle) == 2 && substr($middle, -1) eq "."))) {

 "$first $middle $last";

		$name = "$middle $last";

	    }

	}



~ /[,\.]/) {

	    $name = substr($name, 0, length($name) - 1);

~ /[,\.]"/) {

	    $name = substr($name, 0, length($name) - 2) . '"';

	}



~ /[,\.]/) {

	    $name = substr($name, 1, length($name) - 1);

~ /"[,\.]/) {

	    $name = '"' . substr($name, 2, length($name) - 2);

	}



 format_email($name, $address, $email_usename);

	my ($address, $role) = @$_;

	if (!$saw{$address}) {

	    if ($output_roles) {

		push(@lines, "$address ($role)");

	    } else {

		push(@lines, $address);

	    }

 1;

    my (@parms) = @_;



    if ($output_multiline) {

	foreach my $line (@parms) {

	    print("${line}\n");

	}

    } else {

	print(join($output_separator, @parms));

	print("\n");

    }

}



my $rfc822re;



sub make_rfc822re {

#   Basic lexical tokens are specials, domain_literal, quoted_string, atom, and

#   comment.  We must allow for rfc822_lwsp (or comments) after each of these.

#   This regexp will only work on addresses which have had comments stripped

#   and replaced with rfc822_lwsp.



 '()<>@,;:\\\\".\\[\\]';

    my $controls = '\\000-\\037\\177';



 "[^\\[\\]\\r\\\\]";

    my $domain_literal = "\\[(?:$dtext|\\\\.)*\\]$rfc822_lwsp*";



 "\"(?:[^\\\"\\r\\\\]|\\\\.|$rfc822_lwsp)*\"$rfc822_lwsp*";

   Use zero-width assertion to spot the limit of an atom.  A simple

   $rfc822_lwsp* causes the regexp engine to hang occasionally.

 "[^$specials $controls]+(?:$rfc822_lwsp+|\\Z|(?
    my $word = "(?:$atom|$quoted_string)";

 "$word(?:\\.$rfc822_lwsp*$word)*";

    my $sub_domain = "(?:$atom|$domain_literal)";

 "$sub_domain(?:\\.$rfc822_lwsp*$sub_domain)*";

    my $addr_spec = "$localpart\@$rfc822_lwsp*$domain";



 "$word*";

    my $route = "(?:\@$domain(?:,\@$rfc822_lwsp*$domain)*:$rfc822_lwsp*)";

 "\\<$rfc822_lwsp*$route?$addr_spec\\>$rfc822_lwsp*";

    my $mailbox = "(?:$addr_spec|$phrase$route_addr)";



 "$phrase:$rfc822_lwsp*(?:$mailbox(?:,\\s*$mailbox)*)?;\\s*";

    my $address = "(?:$mailbox|$group)";



    return "$rfc822_lwsp*$address";

}



sub rfc822_strip_comments {

 shift;

   Recursively remove comments, and replace with a single space.  The simpler

   regexps in the Email Addressing FAQ are imperfect - they will miss escaped

   chars in atoms, for example.

    while ($s =~ s/^((?:[^"\\]|\\.)*

                    (?:"(?:[^"\\]|\\.)*"(?:[^"\\]|\\.)*)*)

                    \((?:[^()\\]|\\.)*\)/$1 /osx) {}

    return $s;

}



#   valid: returns true if the parameter is an RFC822 valid address

#

sub rfc822_valid {

 rfc822_strip_comments(shift);

        $rfc822re = make_rfc822re();

    }



    return $s =~ m/^$rfc822re$/so && $s =~ m/^$rfc822_char*$/;

}



#   validlist: In scalar context, returns true if the parameter is an RFC822

#              valid list of addresses.

#

#              In list context, returns an empty list on failure (an invalid

#              address was found); otherwise a list whose first element is the

#              number of addresses found and whose remaining elements are the

#              addresses.  This is needed to disambiguate failure (invalid)

#              from success with no addresses found, because an empty string is

#              a valid list.



sub rfc822_validlist {

 rfc822_strip_comments(shift);

        $rfc822re = make_rfc822re();

    }

    # * null list items are valid according to the RFC

    # * the '1' business is to aid in distinguishing failure from no results



    my @r;

~ m/^(?:$rfc822re)?(?:,(?:$rfc822re)?)*$/so &&

	$s =~ m/^$rfc822_char*$/) {

~ m/(?:^|,$rfc822_lwsp*)($rfc822re)/gos) {

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0



 (c) 2001, Dave Jones. (the file handling bit)

 (c) 2005, Joel Schopp <jschopp@austin.ibm.com> (the ugly bit)

 (c) 2007,2008, Andy Whitcroft <apw@uk.ibm.com> (new conditions, test suite)

 (c) 2008-2010 Andy Whitcroft <apw@canonical.com>

 (c) 2010-2018 Joe Perches <joe@perches.com>

my $P = $0;

 dirname(abs_path($P));

my $V = '0.32';



use Getopt::Long qw(:config no_auto_abbrev);



 0;

my $verbose = 0;

 ();

my %verbose_emitted = ();

 1;

my $chk_signoff = 1;

 1;

my $emacs = 0;

 0;

my $showfile = 0;

 0;

my $git = 0;

 ();

my $check = 0;

 0;

my $summary = 1;

 0;

my $summary_file = 0;

 0;

my $list_types = 0;

 0;

my $fix_inplace = 0;

my $root;

 $ENV{'GIT_DIR'};

$gitroot = ".git" if !defined($gitroot);

my %debug;

 ();

my %use_type = ();

 ();

my %ignore_type = ();

 ();

my $help = 0;

 ".checkpatch.conf";

my $max_line_length = 100;

 0;

my $minimum_perl_version = 5.10.0;

 4;

my $spelling_file = "$D/spelling.txt";

 0;

my $codespellfile = "/usr/share/codespell/dictionary.txt";

 "";

my $conststructsfile = "$D/const_structs.checkpatch";

 "$D/../Documentation/dev-tools/checkpatch.rst";

my $color = "auto";

 Can be overridden by --ignore C99_COMMENT_TOLERANCE

 git output parsing needs US English output, so first set backtick child process LANGUAGE

'export LANGUAGE
my $tabsize = 8;

 "CONFIG_";

	my ($exitcode) = @_;



	print << "EOM";

Usage: $P [OPTION]... [FILE]...

Version: $V



Options:

  -q, --quiet                quiet

  -v, --verbose              verbose mode

  --no-tree                  run without a kernel tree

  --no-signoff               do not check for 'Signed-off-by' line

  --patch                    treat FILE as patchfile (default)

  --emacs                    emacs compile window format

  --terse                    one line per report

  --showfile                 emit diffed file position, not input file position

  -g, --git                  treat FILE as a single commit or git revision range

                             single git commit with:

                               <rev>

                               <rev>^

                               <rev>~n

                             multiple git commits with:

                               <rev1>..<rev2>

                               <rev1>...<rev2>

                               <rev>-<count>

                             git merges are ignored

  -f, --file                 treat FILE as regular source file

  --subjective, --strict     enable more subjective tests

  --list-types               list the possible message types

  --types TYPE(,TYPE2...)    show only these comma separated message types

  --ignore TYPE(,TYPE2...)   ignore various comma separated message types

  --show-types               show the specific message type in the output

n        set the maximum line length, (default $max_line_length)

  --min-conf-desc-length=n   set the min description length, if shorter, warn

n               set the number of spaces for tab (default $tabsize)

  --root=PATH                PATH to the kernel tree root

  --no-summary               suppress the per-file summary

  --mailback                 only produce a report in case of warnings/errors

  --summary-file             include the filename in summary

[0|1]          turn on/off debugging of KEY, where KEY is one of

  --test-only=WORD           report only warnings/errors containing WORD

                             literally

  --fix                      EXPERIMENTAL - may create horrible results

                             If correctable single-line errors exist, create

                             "<inputfile>.EXPERIMENTAL-checkpatch-fixes"

                             with potential errors corrected to the preferred

                             checkpatch style

  --fix-inplace              EXPERIMENTAL - may create horrible results

                             Is the same as --fix, but overwrites the input

                             file.  It's your fault if there's no backup or git

  --ignore-perl-version      override checking of perl version.  expect

                             runtime errors.

  --codespell                Use the codespell dictionary for spelling/typos

                             (default:$codespellfile)

  --codespellfile            Use this codespell dictionary

  --typedefsfile             Read additional types from this file

WHEN]             Use colors 'always', 'never', or only when output

  --kconfig-prefix=WORD      use WORD as a prefix for Kconfig symbols (default

                             ${CONFIG_})

  -h, --help, --version      display this help and exit



When FILE is - read standard input.

EOM



	exit($exitcode);

}



sub uniq {

	my %seen;

	return grep { !$seen{$_}++ } @_;

}



sub list_types {

 @_;

	my $count = 0;



 undef;

	my $text = <$script>;

	close($script);



 ();

 Also catch when type or level is passed through a variable

~ /(?:(\bCHK|\bWARN|\bERROR|&\{\$msg_level})\s*\(|\$msg_type\s*
				$types{$2} .= ",$1" if ($types{$2} ne $1);

			} else {

 $1;

			$types{$2} = "UNDETERMINED";

		}

	}



	print("#\tMessage type\n\n");

	if ($color) {

		print(" ( Color coding: ");

		print(RED . "ERROR" . RESET);

		print(" | ");

		print(YELLOW . "WARNING" . RESET);

		print(" | ");

		print(GREEN . "CHECK" . RESET);

		print(" | ");

		print("Multiple levels / Undetermined");

		print(" )\n\n");

	}



	foreach my $type (sort keys %types) {

 $type;

			my $level = $types{$type};

			if ($level eq "ERROR") {

 RED . $type . RESET;

				$type = YELLOW . $type . RESET;

			} elsif ($level eq "CHK") {

 GREEN . $type . RESET;

			my $message = $verbose_messages{$orig_type};

~ s/\n/\n\t/g;

my $conf = which_conf($configuration_file);

if (-f $conf) {

	my @conf_args;

	open(my $conffile, '<', "$conf")

	    or warn "$P: Can't find a readable $configuration_file file $!\n";



	while (<$conffile>) {

 $_;

		$line =~ s/\s*\n?$//g;

~ s/^\s*//g;

		$line =~ s/\s+/ /g;



/);

		next if ($line =~ m/^\s*$/);



 split(" ", $line);

			last if ($word =~ m/^#/);

			push (@conf_args, $word);

		}

	}

	close($conffile);

	unshift(@ARGV, @conf_args) if @conf_args;

}



sub load_docs {

	open(my $docs, '<', "$docsfile")

	    or warn "$P: Can't read the documentation file $docsfile $!\n";



 '';

	my $desc = '';

 0;

		my $line = $_;

~ s/\s+$//;

		if ($line =~ /^\s*\*\*(.+)\*\*$/) {

			if ($desc ne '') {

 trim($desc);

			$type = $1;

 '';

			$in_desc = 1;

		} elsif ($in_desc) {

~ /^(?:\s{4,}|$)/) {

				$line =~ s/^\s{4}//;

 $line;

				$desc .= "\n";

			} else {

 trim($desc);

				$type = '';

 '';

				$in_desc = 0;

			}

		}

	}



	if ($desc ne '') {

 trim($desc);

 Perl's Getopt::Long allows options to take optional arguments after a space.

 Prevent --color by itself from consuming other arguments

 "--color
	'q|quiet+'	=> \$quiet,

> \$verbose,

	'tree!'		=> \$tree,

> \$chk_signoff,

	'patch!'	=> \$chk_patch,

> \$emacs,

	'terse!'	=> \$terse,

> \$showfile,

	'f|file!'	=> \$file,

> \$git,

	'subjective!'	=> \$check,

> \$check,

s'	
s'	
	'show-types!'	=> \$show_types,

> \$list_types,

i' 
i' 
i'	
s'	
	'summary!'	=> \$summary,

> \$mailback,

	'summary-file!'	=> \$summary_file,

> \$fix,

	'fix-inplace!'	=> \$fix_inplace,

> \$ignore_perl_version,

s'	
s'	
	'codespell!'	=> \$codespell,

	'codespellfile=s'	=> \$user_codespellfile,

	'typedefsfile=s'	=> \$typedefsfile,

	'color=s'	=> \$color,

keep old behaviors of -nocolor

	'nocolor'	=> \$color,	#keep old behaviors of -nocolor

	'kconfig-prefix=s'	=> \${CONFIG_},

> \$help,

	'version'	=> \$help

 2;

 Use the user provided codespell file unconditionally

	$codespellfile = $user_codespellfile;

} elsif (!(-f $codespellfile)) {

	# If /usr/share/codespell/dictionary.txt is not present, try to find it

	# under codespell's install directory: <codespell_root>/data/dictionary.txt

	if (($codespell || $help) && which("codespell") ne "" && which("python") ne "") {

 << "EOF";

codespell_dir = op.dirname(codespell_lib.__file__)

 op.join(codespell_dir, 'data', 'dictionary.txt')

print(codespell_file, end='')

EOF



 `python -c "$python_codespell_dict" 2> /dev/null`;

		$codespellfile = $codespell_dict if (-f $codespell_dict);

	}

}



# $help is 1 if either -h, --help or --version is passed as option - exitcode: 0

# $help is 2 if invalid option is passed - exitcode: 1

help($help - 1) if ($help);



die "$P: --git cannot be used with --file or --fix\n" if ($git && ($file || $fix));

die "$P: --verbose cannot be used with --terse\n" if ($verbose && $terse);



~ /^[01]$/) {

	$color = !$color;

~ /^always$/i) {

	$color = 1;

~ /^never$/i) {

	$color = 0;

~ /^auto$/i) {

	$color = (-t STDOUT);

} else {

	die "$P: Invalid color mode: $color\n";

}



load_docs() if ($verbose);

list_types(0) if ($list_types);



 1 if ($fix_inplace);

$check_orig = $check;



 0;

my $perl_version_ok = 1;

if ($^V && $^V lt $minimum_perl_version) {

 0;

if no filenames are given, push '-' to read patch from stdin

ARGV < 0) {

 skip TAB size 1 to avoid additional checks on $tabsize - 1

	my ($hashRef, $arrayRef) = @_;



 split(/,/, join(',', @$arrayRef));

		$word =~ s/\s*\n?$//g;

~ s/^\s*//g;

		$word =~ s/\s+/ /g;

~ tr/[a-z]/[A-Z]/;

		next if ($word =~ m/^\s*#/);

~ m/^\s*$/);

	my ($hashRef, $prefix) = @_;



	if (keys %$hashRef) {

		print "\nNOTE: $prefix message types:";

		foreach my $word (sort keys %$hashRef) {

			print " $word";

		}

		print "\n";

	}

}



hash_save_array_words(\%ignore_type, \@ignore);

hash_save_array_words(\%use_type, \@use);



 0;

my $dbg_possible = 0;

 0;

my $dbg_attr = 0;

for my $key (keys %debug) {

	## no critic

 '$debug{$key}';";

my $rpt_cleaners = 0;



if ($terse) {

 1;

			$root = '.';

~ m@(.*)/scripts/[^/]*$@ &&

			$root = $1;

		}

	}



	if (!defined $root) {

		print "Must be run from the top-level dir. of a kernel tree\n";

		exit(2);

	}

}



 0;

our $Ident	= qr{

			[A-Za-z_][A-Za-z\d_]*

			(?:\s*\#\#\s*[A-Za-z_][A-Za-z\d_]*)*

		}x;

 qr{extern|static|asmlinkage};

our $Sparse	= qr{

			__user|

			__kernel|

			__force|

			__iomem|

			__must_check|

			__kprobes|

			__ref|

			__refconst|

			__refdata|

			__rcu|

			__private

		}x;

 qr{__(?:mem|cpu|dev|net_|)};

our $InitAttributeData = qr{$InitAttributePrefix(?:initdata\b)};

 qr{$InitAttributePrefix(?:initconst\b)};

our $InitAttributeInit = qr{$InitAttributePrefix(?:init\b)};

 qr{$InitAttributeData|$InitAttributeConst|$InitAttributeInit};

 Notes to $Attribute:

 We need \b after 'init' otherwise 'initconst' will cause a false positive in a check

our $Attribute	= qr{

			const|

			volatile|

			__percpu|

			__nocast|

			__safe|

			__bitwise|

			__packed__|

			__packed2__|

			__naked|

			__maybe_unused|

			__always_unused|

			__noreturn|

			__used|

			__cold|

			__pure|

			__noclone|

			__deprecated|

			__read_mostly|

			__ro_after_init|

			__kprobes|

			$InitAttribute|

			____cacheline_aligned|

			____cacheline_aligned_in_smp|

			____cacheline_internodealigned_in_smp|

			__weak|

			__alloc_size\s*\(\s*\d+\s*(?:,\s*\d+\s*)?\)

		  }x;

our $Modifier;

 qr{inline|__always_inline|noinline|__inline|__inline__};

our $Member	= qr{->$Ident|\.$Ident|\[[^]]*\]};

 qr{$Ident(?:$Member)*};

our $Int_type	= qr{(?i)llu|ull|ll|lu|ul|l|u};

 qr{(?i)0b[01]+$Int_type?};

our $Hex	= qr{(?i)0x[0-9a-f]+$Int_type?};

 qr{[0-9]+$Int_type?};

our $Octal	= qr{0[0-7]+$Int_type?};

 qr{(?:\b[Lu])?"[X\t]*"};

our $Float_hex	= qr{(?i)0x[0-9a-f]+p-?[0-9]+[fl]?};

 qr{(?i)(?:[0-9]+\.[0-9]*|[0-9]*\.[0-9]+)(?:e-?[0-9]+)?[fl]?};

our $Float_int	= qr{(?i)[0-9]+e-?[0-9]+[fl]?};

 qr{$Float_hex|$Float_dec|$Float_int};

our $Constant	= qr{$Float|$Binary|$Octal|$Hex|$Int};

our $Assignment	= qr{\*\=|/=|%=|\+=|-=|<<=|>>=|&=|\^=|\|=|=};

our $Compare    = qr{<=|>=|==|!=|<|(?<!-)>};

 qr{\+|-|\*|\/|%};

our $Operators	= qr{

|>|

			=>|->|<<|>>|<|>|!|~|

			&&|\|\||,|\^|\+\+|--|&|\||$Arithmetic

		  }x;



 qr{do|for|while|if|else|return|goto|continue|switch|default|case|break}x;

our $NON_ASCII_UTF8	= qr{

	[\xC2-\xDF][\x80-\xBF]               # non-overlong 2-byte

	|  \xE0[\xA0-\xBF][\x80-\xBF]        # excluding overlongs

	| [\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}  # straight 3-byte

	|  \xED[\x80-\x9F][\x80-\xBF]        # excluding surrogates

	|  \xF0[\x90-\xBF][\x80-\xBF]{2}     # planes 1-3

	| [\xF1-\xF3][\x80-\xBF]{3}          # planes 4-15

	|  \xF4[\x80-\x8F][\x80-\xBF]{2}     # plane 16

}x;



 qr{

 ASCII

our $typeC99Typedefs = qr{(?:__)?(?:[us]_?)?int_?(?:8|16|32|64)_t};

 qr{(?x:

 bsd

 sysv

our $typeKernelTypedefs = qr{(?x:

	(?:__)?(?:u|s|be|le)(?:8|16|32|64)|

	atomic_t

)};

 qr{(?x:

our $zero_initializer = qr{(?:(?:0[xX])?0+$Int_type?|NULL|false)\b};



 qr{(?x:

our $allocFunctions = qr{(?x:

	(?:(?:devm_)?

		(?:kv|k|v)[czm]alloc(?:_array)?(?:_node)? |

		kstrdup(?:_const)? |

		kmemdup(?:_nul)?) |

	(?:\w+)?alloc_skb(?:_ip_align)? |

				# dev_alloc_skb/netdev_alloc_skb, et al

	dma_alloc_coherent

)};



 qr{(?xi:

our $tracing_logging_tags = qr{(?xi:

-]*> |

	<[=-]* |

	\[ |

	\] |

	start |

	called |

	entered |

	entry |

	enter |

	in |

	inside |

	here |

	begin |

	exit |

	end |

	done |

	leave |

	completed |

	out |

	return |

	[\.\!:\s]*

)};



sub edit_distance_min {

 @_;

	my $len = scalar @arr;

	if ((scalar @arr) < 1) {

		# if underflow, return

		return;

	}

 $arr[0];

			$min = $arr[$i];

		}

	}

	return $min;

}



sub get_edit_distance {

 @_;

	$str1 = lc($str1);

 lc($str2);

	$str1 =~ s/-//g;

~ s/-//g;

	my $len1 = length($str1);

 length($str2);

 two dimensional array storing minimum edit distance

				$distance[$i][$j] = $j;

			} elsif ($j == 0) {

 $i;

				$distance[$i][$j] = $distance[$i - 1][$j - 1];

			} else {

insert distance

				my $dist2 = $distance[$i - 1][$j]; # remove

replace

				$distance[$i][$j] = 1 + edit_distance_min($dist1, $dist2, $dist3);

			}

		}

	}

	return $distance[$len1][$len2];

}



sub find_standard_signature {

 @_;

	my @standard_signature_tags = (

		'Signed-off-by:', 'Co-developed-by:', 'Acked-by:', 'Tested-by:',

		'Reviewed-by:', 'Reported-by:', 'Suggested-by:'

	);

	foreach my $signature (@standard_signature_tags) {

 2);

our @typeListMisordered = (

	qr{char\s+(?:un)?signed},

	qr{int\s+(?:(?:un)?signed\s+)?short\s},

	qr{int\s+short(?:\s+(?:un)?signed)},

	qr{short\s+int(?:\s+(?:un)?signed)},

	qr{(?:un)?signed\s+int\s+short},

	qr{short\s+(?:un)?signed},

	qr{long\s+int\s+(?:un)?signed},

	qr{int\s+long\s+(?:un)?signed},

	qr{long\s+(?:un)?signed\s+int},

	qr{int\s+(?:un)?signed\s+long},

	qr{int\s+(?:un)?signed},

	qr{int\s+long\s+long\s+(?:un)?signed},

	qr{long\s+long\s+int\s+(?:un)?signed},

	qr{long\s+long\s+(?:un)?signed\s+int},

	qr{long\s+long\s+(?:un)?signed},

	qr{long\s+(?:un)?signed},

);



 (

our $C90_int_types = qr{(?x:

	long\s+long\s+int\s+(?:un)?signed|

	long\s+long\s+(?:un)?signed\s+int|

	long\s+long\s+(?:un)?signed|

	(?:(?:un)?signed\s+)?long\s+long\s+int|

	(?:(?:un)?signed\s+)?long\s+long|

	int\s+long\s+long\s+(?:un)?signed|

	int\s+(?:(?:un)?signed\s+)?long\s+long|



	long\s+int\s+(?:un)?signed|

	long\s+(?:un)?signed\s+int|

	long\s+(?:un)?signed|

	(?:(?:un)?signed\s+)?long\s+int|

	(?:(?:un)?signed\s+)?long|

	int\s+long\s+(?:un)?signed|

	int\s+(?:(?:un)?signed\s+)?long|



	int\s+(?:un)?signed|

	(?:(?:un)?signed\s+)?int

)};



 ();

our @typeListWithAttr = (

	@typeList,

	qr{struct\s+$InitAttribute\s+$Ident},

	qr{union\s+$InitAttribute\s+$Ident},

);



 (

our @modifierListFile = ();



 (

my $word_pattern = '\b[A-Z]?[a-z]{2,}\b';



#Create a search pattern for all these functions to speed up a loop below

 "";

	$mode_perms_search .= '|' if ($mode_perms_search ne "");

 $entry->[0];

$mode_perms_search = "(?:${mode_perms_search})";



 (

	"synchronize_rcu_bh"			=> "synchronize_rcu",

> "synchronize_rcu_expedited",

	"call_rcu_bh"				=> "call_rcu",

> "rcu_barrier",

	"synchronize_sched"			=> "synchronize_rcu",

> "synchronize_rcu_expedited",

	"call_rcu_sched"			=> "call_rcu",

> "rcu_barrier",

	"get_state_synchronize_sched"		=> "get_state_synchronize_rcu",

> "cond_synchronize_rcu",

Create a search pattern for all these strings to speed up a loop below

our $deprecated_apis_search = "";

foreach my $entry (keys %deprecated_apis) {

 '|' if ($deprecated_apis_search ne "");

	$deprecated_apis_search .= $entry;

}

 "(?:${deprecated_apis_search})";

our $mode_perms_world_writable = qr{

	S_IWUGO		|

	S_IWOTH		|

	S_IRWXUGO	|

	S_IALLUGO	|

	0[0-7][0-7][2367]

}x;



 (

	"S_IRWXU" => 0700,

> 0400,

	"S_IWUSR" => 0200,

> 0100,

	"S_IRWXG" => 0070,

> 0040,

	"S_IWGRP" => 0020,

> 0010,

	"S_IRWXO" => 0007,

> 0004,

	"S_IWOTH" => 0002,

> 0001,

	"S_IRWXUGO" => 0777,

> 0444,

	"S_IWUGO" => 0222,

> 0111,

Create a search pattern for all these strings to speed up a loop below

our $mode_perms_string_search = "";

foreach my $entry (keys %mode_permission_string_types) {

 '|' if ($mode_perms_string_search ne "");

	$mode_perms_string_search .= $entry;

}

 "(?:${mode_perms_string_search})";

our $multi_mode_perms_string_search = qr{

	${single_mode_perms_string_search}

	(?:\s*\|\s*${single_mode_perms_string_search})*

}x;



sub perms_to_octal {

 @_;

	return trim($string) if ($string =~ /^\s*0[0-7]{3,3}\s*$/);



 "";

	my $oval = "";

 0;

	my $curpos = 0;

 0;

	while ($string =~ /\b(($single_mode_perms_string_search)\b(?:\s*\|\s*)?\s*)/g) {

 pos($string);

		my $match = $2;

 $1;

		last if ($lastpos > 0 && ($curpos - length($omatch) != $lastpos));

 $curpos;

		$to |= $mode_permission_string_types{$match};

 '\s*\|\s*' if ($val ne "");

		$val .= $match;

 $omatch;

	$oval =~ s/^\s*\|\s*//;

~ s/\s*\|\s*$//;

our $allowed_asm_includes = qr{(?x:

	irq|

	memory|

	time|

	reboot

)};

# memory.h: ARM has a custom one



# Load common spelling mistakes and build regular expression list.

my $misspellings;

my %spelling_fix;



if (open(my $spelling, '<', $spelling_file)) {

	while (<$spelling>) {

 $_;

		$line =~ s/\s*\n?$//g;

~ s/^\s*//g;

		next if ($line =~ m/^\s*#/);

~ m/^\s*$/);

		my ($suspect, $fix) = split(/\|\|/, $line);



 $fix;

			my $line = $_;



~ s/\s*\n?$//g;

			$line =~ s/^\s*//g;



/);

			next if ($line =~ m/^\s*$/);

~ m/, disabled/i);

			$line =~ s/,.*$//;



 split(/->/, $line);

			$spelling_fix{$suspect} = $fix;

		}

		close($spelling);

	} else {

		warn "No codespell typos will be found - file '$codespellfile': $!\n";

	}

}



 join("|", sort keys %spelling_fix) if keys %spelling_fix;

	my ($wordsRef, $file) = @_;



	if (open(my $words, '<', $file)) {

		while (<$words>) {

 $_;

			$line =~ s/\s*\n?$//g;

~ s/^\s*//g;

			next if ($line =~ m/^\s*#/);

~ m/^\s*$/);

			if ($line =~ /\s/) {

				print("$file: '$line' invalid - ignored\n");

				next;

			}



 '|' if (defined $$wordsRef);

			$$wordsRef .= $line;

		}

		close($file);

		return 1;

	}



	return 0;

}



my $const_structs;

if (show_type("CONST_STRUCT")) {

	read_words(\$const_structs, $conststructsfile)

	    or warn "No structs that should be const will be found - file '$conststructsfile': $!\n";

}



if (defined($typedefsfile)) {

	my $typeOtherTypedefs;

	read_words(\$typeOtherTypedefs, $typedefsfile)

	    or warn "No additional types will be considered - file '$typedefsfile': $!\n";

 '|' . $typeOtherTypedefs if (defined $typeOtherTypedefs);

	my $mods = "(?x:  \n" . join("|\n  ", (@modifierList, @modifierListFile)) . "\n)";

 "(?x:  \n" . join("|\n  ", (@typeList, @typeListFile)) . "\n)";

	my $Misordered = "(?x:  \n" . join("|\n  ", @typeListMisordered) . "\n)";

 "(?x:  \n" . join("|\n  ", @typeListWithAttr) . "\n)";

	$Modifier	= qr{(?:$Attribute|$Sparse|$mods)};

 qr{

	$NonptrType	= qr{

			(?:$Modifier\s+|const\s+)*

			(?:

				(?:typeof|__typeof__)\s*\([^\)]*\)|

				(?:$typeTypedefs\b)|

				(?:${all}\b)

			)

			(?:\s+$Modifier|\s+const)*

		  }x;

 qr{

	$NonptrTypeWithAttr	= qr{

			(?:$Modifier\s+|const\s+)*

			(?:

				(?:typeof|__typeof__)\s*\([^\)]*\)|

				(?:$typeTypedefs\b)|

				(?:${allWithAttr}\b)

			)

			(?:\s+$Modifier|\s+const)*

		  }x;

 qr{

	$TypeMisordered	= qr{

			$NonptrTypeMisordered

			(?:(?:\s|\*|\[\])+\s*const|(?:\s|\*\s*(?:const\s*)?|\[\])+|(?:\s*\[\s*\])+){0,4}

			(?:\s+$Inline|\s+$Modifier)*

		  }x;

 qr{(?:$Storage\s+(?:$Inline\s+)?)?$Type};

	$DeclareMisordered	= qr{(?:$Storage\s+(?:$Inline\s+)?)?$TypeMisordered};

}

build_types();



 qr{\s*(\(\s*$NonptrType\s*\)){0,1}\s*};

 Using $balanced_parens, $LvalOrFunc, or $FuncArg

 requires at least perl version v5.10.0

 Any use must be runtime checked with $^V

our $balanced_parens = qr/(\((?:[^\(\)]++|(?-1))*\))/;

 qr{((?:[\&\*]\s*)?$Lval)\s*($balanced_parens{0,1})\s*};

our $FuncArg = qr{$Typecast{0,1}($LvalOrFunc|$Constant|$String)};



 qr{(?x:

our %allow_repeated_words = (

> '',

	added => '',

> '',

	be => '',

);



sub deparenthesize {

 @_;

	while ($string =~ /^\s*\(.*\)\s*$/) {

~ s@^\s*\(\s*@@;

		$string =~ s@\s*\)\s*$@@;

	}



~ s@\s+@ @g;

	my ($file) = @_;



	return if (!(-f $file));



	local $/;



	open(my $include_file, '<', "$file")

	    or warn "$P: Can't read '$file' $!\n";

 <$include_file>;

	my @lines = split('\n', $text);



	foreach my $line (@lines) {

		next if ($line !~ /(?:[A-Z][a-z]|[a-z][A-Z])/);

[ \t]*define|typedef\s+$Type)\s+(\w*(?:[A-Z][a-z]|[a-z][A-Z])\w*)/) {

			$camelcase{$1} = 1;

~ /^\s*$Declare\s+(\w*(?:[A-Z][a-z]|[a-z][A-Z])\w*)\s*[\(\[,;]/) {

			$camelcase{$1} = 1;

~ /^\s*(?:union|struct|enum)\s+(\w*(?:[A-Z][a-z]|[a-z][A-Z])\w*)\s*[;\{]/) {

			$camelcase{$1} = 1;

		}

	}

}



 ();

	my ($filename) = @_;



	return 0 if (!$tree || !(-e "$root/scripts/get_maintainer.pl"));



	if (!exists($maintained_status{$filename})) {

 `perl $root/scripts/get_maintainer.pl --status --nom --nol --nogit --nogit-fallback -f $filename 2>&1`;

	return $maintained_status{$filename} =~ /obsolete/i;

}



sub is_SPDX_License_valid {

 @_;

	my $root_path = abs_path($root);

 `cd "$root_path"; echo "$license" | scripts/spdxcheck.py -`;

my $camelcase_seeded = 0;

sub seed_camelcase_includes {

	return if ($camelcase_seeded);



	my $files;

 "";

	my @include_files = ();



 1;

 `${git_command} log --no-merges --pretty
		$camelcase_cache = ".checkpatch-camelcase.git.$git_last_include_commit";

	} else {

 0;

		$files = `find $root/include -name "*.h"`;

 split('\n', $files);

			my $date = POSIX::strftime("%Y%m%d%H%M",

						   localtime((stat $file)[9]));

 $date if ($last_mod_date < $date);

		$camelcase_cache = ".checkpatch-camelcase.date.$last_mod_date";

	}



	if ($camelcase_cache ne "" && -f $camelcase_cache) {

		open(my $camelcase_file, '<', "$camelcase_cache")

		    or warn "$P: Can't read '$camelcase_cache' $!\n";

		while (<$camelcase_file>) {

			chomp;

 1;

		$files = `${git_command} ls-files "include/*.h"`;

 split('\n', $files);

	my ($filename) = @_;



	return 0 if ((which("git") eq "") || !(-e "$gitroot"));



 `${git_command} ls-files -- $filename 2>/dev/null`;

 $output 
	return $count eq 1 && $output =~ m{^${filename}$};

}



sub git_commit_info {

 @_;

 `${git_command} log --no-color --format
	$output =~ s/^\s*//gm;

 split("\n", $output);

lines < 0);

	if ($lines[0] =~ /^error: short SHA1 $commit is ambiguous/) {

# Maybe one day convert this block of bash into something that returns

# all matching commit ids, but it's very slow...

#

#		echo "checking commits $1..."

#		git rev-list --remotes | grep -i "^$1" |

#		while read line ; do

		    git log --format='%H %s' -1 $line |

		    echo "commit $(cut -c 1-12,41-)"

		done

	} elsif ($lines[0] =~ /^fatal: ambiguous argument '$commit': unknown revision or path not in the working tree\./ ||

~ /^fatal: bad object $commit/) {

		$id = undef;

	} else {

 substr($lines[0], 0, 12);

		$desc = substr($lines[0], 41);

	}



	return ($id, $desc);

}



 0 if ($file);

my @rawlines = ();

 ();

my @fixed = ();

 ();

my @fixed_deleted = ();

 -1;

 If input is git commits, extract all commits from the commit expressions.

 For example, HEAD-3 means we need check 'HEAD, HEAD~1, HEAD~2'.

	my @commits = ();

	foreach my $commit_expr (@ARGV) {

		my $git_range;

~ m/^(.*)-(\d+)$/) {

			$git_range = "-$2 $1";

~ m/\.\./) {

			$git_range = "$commit_expr";

		} else {

 "-1 $commit_expr";

 `${git_command} log --no-color --no-merges --pretty
			$line =~ /^([0-9a-fA-F]{40,40}) (.*)$/;

			next if (!defined($1) || !defined($2));

 $1;

			my $subject = $2;

			unshift(@commits, $sha1);

 $subject;

	@ARGV = @commits;

}



my $vname;

 !defined $ignore_type{"C99_COMMENT_TOLERANCE"};

	my $is_git_file = git_is_single_file($filename);

 $file;

	$file = 1 if ($is_git_file);

	if ($git) {

		open($FILE, '-|', "git format-patch -M --stdout -1 $filename") ||

			die "$P: $filename: git format-patch failed - $!\n";

	} elsif ($file) {

		open($FILE, '-|', "diff -u /dev/null $filename") ||

			die "$P: $filename: diff failed - $!\n";

	} elsif ($filename eq '-') {

		open($FILE, '<&STDIN');

	} else {

		open($FILE, '<', "$filename") ||

			die "$P: $filename: open failed - $!\n";

	}

	if ($filename eq '-') {

 'Your patch';

		$vname = "Commit " . substr($filename, 0, 12) . ' ("' . $git_commits{$filename} . '")';

	} else {

 $filename;

 qq("$1") if ($filename eq '-' && $_ 
ARGV > 0 && $quiet == 0) {
 0) {

		$exit = 1;

	}

 ();

	@lines = ();

 ();

	@fixed_inserted = ();

 ();

	$fixlinenr = -1;

 ();

	@typeListFile = ();

	build_types();

 $oldfile if ($is_git_file);

	my ($root) = @_;



 (

	my ($formatted_email) = @_;



 "";

	my $quoted = "";

 "";

	my $address = "";

 "";

	if ($formatted_email =~ /^(.*)<(\S+\@\S+)>(.*)$/) {

 $1;

		$address = $2;

 $3 if defined $3;

	} elsif ($formatted_email =~ /^\s*<(\S+\@\S+)>(.*)$/) {

 $1;

		$comment = $2 if defined $2;

~ /(\S+\@\S+)(.*)$/) {

		$address = $1;

 $2 if defined $2;

		$formatted_email =~ s/\Q$address\E.*$//;

 $formatted_email;

		$name = trim($name);

~ s/^\"|\"$//g;

 If there's a name left after stripping spaces and

 leading quotes, and the address doesn't have both

 leading and trailing angle brackets, the address

 is invalid. ie:

   "joe smith joe@smith.com" bad

   "joe smith <joe@smith.com" bad

			$name = "";

 "";

			$comment = "";

		}

	}



	# Extract comments from names excluding quoted parts

	# "John D. (Doe)" - Do not extract

~ s/\"(.+)\"//) {

		$quoted = $1;

	}

~ s/\s*($balanced_parens)\s*/ /) {

		$name_comment .= trim($1);

	}

~ s/^[ \"]+|[ \"]+$//g;

	$name = trim("$quoted $name");



 trim($address);

	$address =~ s/^\<|\>$//g;

 trim($comment);

	if ($name =~ /[^\w \-]/i) { ##has "must quote" chars

~ s/(?<!\\)"/\\"/g; ##escape quotes

		$name = "\"$name\"";

	}



	return ($name, $name_comment, $address, $comment);

}



sub format_email {

 @_;

	$name =~ s/^[ \"]+|[ \"]+$//g;

 trim($address);

	$address =~ s/(?:\.|\,|\")+$//; ##trailing commas, dots or quotes



~ /[^\w \-]/i) { ##has "must quote" chars

		$name =~ s/(?<!\\)"/\\"/g; ##escape quotes

 "\"$name\"";

	$name_comment = trim($name_comment);

 " $name_comment" if ($name_comment ne "");

	$comment = trim($comment);

 " $comment" if ($comment ne "");

		$formatted_email = "$address";

	} else {

 "$name$name_comment <$address>";

	$formatted_email .= "$comment";

	return $formatted_email;

}



sub reformat_email {

 @_;

	my ($email_name, $name_comment, $email_address, $comment) = parse_email($email);

	return format_email($email_name, $name_comment, $email_address, $comment);

}



sub same_email_addresses {

 @_;

	my ($email1_name, $name1_comment, $email1_address, $comment1) = parse_email($email1);

 parse_email($email2);

	my ($bin) = @_;



	foreach my $path (split(/:/, $ENV{PATH})) {

		if (-e "$path/$bin") {

			return "$path/$bin";

		}

	}



	return "";

}



sub which_conf {

 @_;

	my ($str) = @_;



 '';

	my $n = 0;

	for my $c (split(//, $str)) {

		if ($c eq "\t") {

 ' ';

			for (; ($n % $tabsize) != 0; $n++) {

 ' ';

		$res .= $c;

		$n++;

	}



	return $res;

}

sub copy_spacing {

	(my $res = shift) =~ tr/\t/ /c;

	return $res;

}



sub line_stats {

 @_;

 Drop the diff line leader and expand tabs

	$line =~ s/^.//;

 expand_tabs($line);

 Pick the indent from the front of the line.

 ($line 
my $sanitise_quote = '';



sub sanitise_line_reset {

 @_;

		$sanitise_quote = '*/';

	} else {

 '';

	my ($line) = @_;



 '';

	my $l = '';



 0;

	my $off = 0;

	my $c;



	# Always copy over the diff marker.

 substr($line, 0, 1);

	for ($off = 1; $off < length($line); $off++) {

 substr($line, $off, 1);

 Comments we are whacking completely including the begin

 and end, all to $;.

			$sanitise_quote = '*/';



			substr($res, $off, 2, "$;$;");

			$off++;

			next;

		}

		if ($sanitise_quote eq '*/' && substr($line, $off, 2) eq '*/') {

 '';

			$sanitise_quote = '//';



			substr($res, $off, 2, $sanitise_quote);

			$off++;

			next;

		}



		# A \ in a string means ignore the next character.

		if (($sanitise_quote eq "'" || $sanitise_quote eq '"') &&

		    $c eq "\\") {

			substr($res, $off, 2, 'XX');

			$off++;

			next;

		}

		# Regular quotes.

		if ($c eq "'" || $c eq '"') {

			if ($sanitise_quote eq '') {

 $c;

				$sanitise_quote = '';

			}

		}



		#print "c<$c> SQ<$sanitise_quote>\n";

 0 && $sanitise_quote eq '*/' && $c ne "\t") {

		} elsif ($off != 0 && $sanitise_quote eq '//' && $c ne "\t") {

			substr($res, $off, 1, $;);

 0 && $sanitise_quote && $c ne "\t") {

		$sanitise_quote = '';

	}



	# The pathname on a #include may be surrounded by '<' and '>'.

\s*include\s+\<(.*)\>/) {

		my $clean = 'X' x length($1);

~ s@\<.*\>@<$clean>@;

 The whole of a 
	} elsif ($res =~ /^.\s*\#\s*(?:error|warning)\s+(.*)\b/) {

 'X' x length($1);

		$res =~ s@(\#\s*(?:error|warning)\s+).*@$1$clean@;

	}



~ m@(//.*$)@) {

		my $match = $1;

~ s/\Q$match\E/"$;" x length($match)/e;

	my ($line, $rawline) = @_;



	return "" if (!defined($line) || !defined($rawline));

	return "" if ($line !~ m/($String)/g);

	return substr($rawline, $-[0], $+[0] - $-[0]);

}



sub ctx_statement_block {

 @_;

	my $line = $linenr - 1;

 '';

	my $soff = $off;

 $off - 1;

	my $coff_set = 0;



 0;

	my $type = '';

 0;

	my @stack = ();

	my $p;

	my $c;

 0;

		@stack = (['', 0]) if ($#stack == -1);



		#warn "CSB: blk<$blk> remain<$remain>\n";

		# If we are about to drop off the end, pull in more

		# context.

 $len) {

				next if ($lines[$line] =~ /^-/);

				$remain--;

 $len;

				$blk .= $lines[$line] . "\n";

 length($blk);

 Bail if there is no further context.

warn "CSB: blk<$blk> off<$off> len<$len>\n";

			if ($off >= $len) {

				last;

			}

\s*define/) {
 0 && substr($blk, $off) 
				$type = '#';

			}

		}

 $c;

		$c = substr($blk, $off, 1);

 substr($blk, $off);

warn "CSB: c<$c> type<$type> level<$level> remainder<$remainder> coff_set<$coff_set>\n";

 Handle nested else.

		if ($remainder =~ /^#\s*(?:ifndef|ifdef|if)\s/) {

			push(@stack, [ $type, $level ]);

\s*(?:else|elif)\b/) {

			($type, $level) = @{$stack[$#stack - 1]};

\s*endif\b/) {

			($type, $level) = @{pop(@stack)};

		}



		# Statement ends at the ';' or a close '}' at the

		# outermost level.

		if ($level == 0 && $c eq ';') {

			last;

		}



		# An else is really a conditional as long as its not else if

		if ($level == 0 && $coff_set == 0 &&

~ /(?:\s|\}|\+)/) &&

				$remainder =~ /^(else)(?:\s|{)/ &&

				$remainder !~ /^else\s+if\b/) {

 $off + length($1) - 1;

			$coff_set = 1;

			#warn "CSB: mark coff<$coff> soff<$soff> 1<$1>\n";

			#warn "[" . substr($blk, $soff, $coff - $soff + 1) . "]\n";

		}



		if (($type eq '' || $type eq '(') && $c eq '(') {

			$level++;

 '(';

 ($level !
				$coff = $off;

 1;

warn "CSB: mark coff<$coff>\n";

			$type = '{';

		}

		if ($type eq '{' && $c eq '}') {

			$level--;

			$type = ($level != 0)? '{' : '';



			if ($level == 0) {

				if (substr($blk, $off + 1, 1) eq ';') {

					$off++;

				}

				last;

			}

		}

		# Preprocessor commands end at the newline unless escaped.

		if ($type eq '#' && $c eq "\n" && $p ne "\\") {

			$level--;

 '';

 We are truly at the end, so shuffle to the next line.

		$loff = $len + 1;

		$line++;

		$remain--;

	}



 substr($blk, $soff, $off - $soff + 1);

	my $condition = substr($blk, $soff, $coff - $soff + 1);



	#warn "STATEMENT<$statement>\n";

	#warn "CONDITION<$condition>\n";



	#print "coff<$coff> soff<$off> loff<$loff>\n";



	return ($statement, $condition,

			$line, $remain + 1, $off - $loff + 1, $level);

}



sub statement_lines {

 @_;

 Strip the diff line prefixes and rip blank lines at start and end.

	$stmt =~ s/(^|\n)./$1/g;

~ s/^\s*//;

	$stmt =~ s/\s*$//;



	my @stmt_lines = ($stmt =~ /\n/g);



	return $#stmt_lines + 2;

}



sub statement_rawlines {

 @_;

 ($stmt 
stmt_lines + 2;

	my ($stmt) = @_;



~ s/(^|\n)./$1/g;

	$stmt =~ s/^\s*{//;

~ s/}\s*$//;

	$stmt =~ s/^\s*//;

~ s/\s*$//;

 ($stmt 
 ($stmt 
	my $stmt_lines = $#stmt_lines + 2;

stmt_statements + 1;

	my ($linenr, $remain, $off) = @_;

	my ($statement, $condition, $level);



	my (@chunks);



	# Grab the first conditional/block pair.



print "F: c<$condition> s<$statement> remain<$remain>\n";

	if (!($remain > 0 && $condition =~ /^\s*(?:\n[+-])?\s*(?:if|else|do)\b/s)) {

		return ($level, $linenr, @chunks);

	}



	# Pull in the following conditional/block pairs and see if they

	# could continue the statement.

	for (;;) {



print "C: c<$condition> s<$statement> remain<$remain>\n";

		last if (!($remain > 0 && $condition =~ /^(?:\s*\n[+-])*\s*(?:else|do)\b/s));

		#print "C: push\n";

		push(@chunks, [ $condition, $statement ]);

	}



	return ($level, $linenr, @chunks);

}



sub ctx_block_get {

 @_;

	my $start = $linenr - 1;

 '';

	my @res = ();



 0;

	my @stack = ($level);

 $start; $remain > 0; $line++) {

		next if ($rawlines[$line] =~ /^-/);

		$remain--;



 $rawlines[$line];

 Handle nested else.

		if ($lines[$line] =~ /^.\s*#\s*(?:ifndef|ifdef|if)\s/) {

			push(@stack, $level);

\s*(?:else|elif)\b/) {

			$level = $stack[$#stack - 1];

\s*endif\b/) {

			$level = pop(@stack);

		}



		foreach my $c (split(//, $lines[$line])) {

			##print "C<$c>L<$level><$open$close>O<$off>\n";

			if ($off > 0) {

				$off--;

				next;

			}



			if ($c eq $close && $level > 0) {

				$level--;

				last if ($level == 0);

			} elsif ($c eq $open) {

				$level++;

			}

		}



 1) {

	my ($linenr, $remain) = @_;



 ctx_block_get($linenr, $remain, 1, '{', '}', 0);

	my ($linenr, $remain) = @_;



 ctx_block_get($linenr, $remain, 0, '{', '}', 0);

	my ($linenr, $remain, $off) = @_;



 ctx_block_get($linenr, $remain, 0, '(', ')', $off);

	my ($linenr, $remain) = @_;



	return ctx_block_get($linenr, $remain, 0, '{', '}', 0);

}

sub ctx_statement_level {

 @_;

	my ($first_line, $end_line) = @_;



	# If c99 comment on the current line, or the line before or after

	my ($current_comment) = ($rawlines[$end_line - 1] =~ m@^\+.*(//.*$)@);

	return $current_comment if (defined $current_comment);

	($current_comment) = ($rawlines[$end_line - 2] =~ m@^[\+ ].*(//.*$)@);

	return $current_comment if (defined $current_comment);

	($current_comment) = ($rawlines[$end_line] =~ m@^[\+ ].*(//.*$)@);

	return $current_comment if (defined $current_comment);



	# Catch a comment on the end of the line itself.

	($current_comment) = ($rawlines[$end_line - 1] =~ m@.*(/\*.*\*/)\s*(?:\\\s*)?$@);

	return $current_comment if (defined $current_comment);



	# Look through the context and try and figure out if there is a

	# comment.

 0;

	$current_comment = '';

 $first_line; $linenr < $end_line; $linenr++) {

		my $line = $rawlines[$linenr - 1];

		#warn "           $line\n";

~ m@^.\s*\*@) {

			$in_comment = 1;

		}

~ m@/\*@) {

			$in_comment = 1;

		}

		if (!$in_comment && $current_comment ne '') {

 '';

		$current_comment .= $line . "\n" if ($in_comment);

~ m@\*/@) {

			$in_comment = 0;

		}

	}



	chomp($current_comment);

	return($current_comment);

}

sub ctx_has_comment {

 @_;

	my $cmt = ctx_locate_comment($first_line, $end_line);



	##print "LINE: $rawlines[$end_line - 1 ]\n";

	##print "CMMT: $cmt\n";



	return ($cmt ne '');

}



sub raw_line {

 @_;

	my $offset = $linenr - 1;

	$cnt++;



	my $line;

	while ($cnt) {

 $rawlines[$offset++];

		next if (defined($line) && $line =~ /^-/);

		$cnt--;

	}



	return $line;

}



sub get_stat_real {

 @_;

	my $stat_real = raw_line($linenr, 0);

	for (my $count = $linenr + 1; $count <= $lc; $count++) {

 $stat_real . "\n" . raw_line($count, 0);

	my ($linenr, $cnt, $here) = @_;



 $here . "\n";

	for (my $n = 0; $n < $cnt; $n++) {

 raw_line($linenr, $n) . "\n";

	my ($vet) = @_;

	my ($res, $coded);



 '';

	while ($vet =~ /([^[:cntrl:]]*)([[:cntrl:]]|$)/g) {

 $1;

			$coded = sprintf("^%c", unpack('C', $2) + 64);

 $coded;

	$res =~ s/$/\$/;



	return $res;

}



 0;

	$av_preprocessor = 0;

 '_';

	@av_paren_type = ('E');

 'O';

	my ($stream, $type) = @_;



	my $res;

 '_' x length($stream);

	my $cur = $stream;



	print "$stream\n" if ($dbg_values > 1);



	while (length($cur)) {

av_paren_type < 0);

		if ($cur =~ /^(\s+)/o) {

			print "WS($1)\n" if ($dbg_values > 1);

~ /\n/ && $av_preprocessor) {

				$type = pop(@av_paren_type);

 0;

		} elsif ($cur =~ /^(\(\s*$Type\s*)\)/ && $av_pending eq '_') {

			print "CAST($1)\n" if ($dbg_values > 1);

			push(@av_paren_type, $type);

 'c';

		} elsif ($cur =~ /^($Type)\s*(?:$Ident|,|\)|\(|\s*$)/) {

			print "DECLARE($1)\n" if ($dbg_values > 1);

 'T';

		} elsif ($cur =~ /^($Modifier)\s*/) {

			print "MODIFIER($1)\n" if ($dbg_values > 1);

 'T';

		} elsif ($cur =~ /^(\#\s*define\s*$Ident)(\(?)/o) {

			print "DEFINE($1,$2)\n" if ($dbg_values > 1);

 1;

				$av_pending = 'N';

			}

 'E';

		} elsif ($cur =~ /^(\#\s*(?:undef\s*$Ident|include\b))/o) {

			print "UNDEF($1)\n" if ($dbg_values > 1);

 1;

		} elsif ($cur =~ /^(\#\s*(?:ifdef|ifndef|if))/o) {

			print "PRE_START($1)\n" if ($dbg_values > 1);

 1;

			$type = 'E';



\s*(?:else|elif))/o) {

			$av_preprocessor = 1;



			push(@av_paren_type, $av_paren_type[$#av_paren_type]);



 'E';

		} elsif ($cur =~ /^(\#\s*(?:endif))/o) {

			print "PRE_END($1)\n" if ($dbg_values > 1);



 1;

 Assume all arms of the conditional end as this

 one does, and continue as if the 
			$type = 'E';



~ /^(\\\n)/o) {

		} elsif ($cur =~ /^(__attribute__)\s*\(?/o) {

			print "ATTR($1)\n" if ($dbg_values > 1);

 $type;

			$type = 'N';



~ /^(sizeof)\s*(\()?/o) {

				$av_pending = 'V';

			}

 'N';

		} elsif ($cur =~ /^(if|while|for)\b/o) {

			print "COND($1)\n" if ($dbg_values > 1);

 'E';

			$type = 'N';



~/^(case)/o) {

			$av_pend_colon = 'C';

 'N';

		} elsif ($cur =~/^(return|else|goto|typeof|__typeof__)\b/o) {

			print "KEYWORD($1)\n" if ($dbg_values > 1);

 'N';

		} elsif ($cur =~ /^(\()/o) {

			print "PAREN('$1')\n" if ($dbg_values > 1);

			push(@av_paren_type, $av_pending);

 '_';

			$type = 'N';



~ /^(\))/o) {

			my $new_type = pop(@av_paren_type);

			if ($new_type ne '_') {

 $new_type;

		} elsif ($cur =~ /^($Ident)\s*\(/o) {

			print "FUNC($1)\n" if ($dbg_values > 1);

 'V';

			$av_pending = 'V';



		} elsif ($cur =~ /^($Ident\s*):(?:\s*\d+\s*(,|=|;))?/) {

			if (defined $2 && $type eq 'C' || $type eq 'T') {

 'B';

				$av_pend_colon = 'L';

			}

			print "IDENT_COLON($1,$type>$av_pend_colon)\n" if ($dbg_values > 1);

 'V';

		} elsif ($cur =~ /^($Ident|$Constant)/o) {

			print "IDENT($1)\n" if ($dbg_values > 1);

 'V';

		} elsif ($cur =~ /^($Assignment)/o) {

			print "ASSIGN($1)\n" if ($dbg_values > 1);

 'N';

		} elsif ($cur =~/^(;|{|})/) {

			print "END($1)\n" if ($dbg_values > 1);

 'E';

			$av_pend_colon = 'O';



~/^(,)/) {

			$type = 'C';



~ /^(\?)/o) {

			$type = 'N';



~ /^(:)/o) {

				$type = 'E';

			} else {

 'N';

			$av_pend_colon = 'O';



~ /^(\[)/o) {

			$type = 'N';



~ /^(-(?![->])|\+(?!\+)|\*|\&\&|\&)/o) {

				$variant = 'B';

			} else {

 'U';

			$type = 'N';



~ /^($Operators)/o) {

				$type = 'N';

			}



~ /(^.)/o) {

			$cur = substr($cur, length($1));

 $type x length($1);

	my ($possible, $line) = @_;

 qr{(?:

|

\
 Check for modifiers.

		$possible =~ s/\s*$Storage\s*//g;

~ s/\s*$Sparse\s*//g;

		if ($possible =~ /^\s*$/) {



~ /\s/) {

			$possible =~ s/\s*$Type\s*//g;

			for my $modifier (split(' ', $possible)) {

				if ($modifier !~ $notPermitted) {

					warn "MODIFIER: $modifier ($possible) ($line)\n" if ($dbg_possible);

					push(@modifierListFile, $modifier);

				}

			}



		} else {

			warn "POSSIBLE: $possible ($line)\n" if ($dbg_possible);

			push(@typeListFile, $possible);

		}

		build_types();

	} else {

		warn "NOTPOSS: $possible ($line)\n" if ($dbg_possible > 1);

	}

}



 '';

	my ($type) = @_;



~ tr/[a-z]/[A-Z]/;

	my ($level, $type, $msg) = @_;



	if (!show_type($type) ||

	    (defined $tst_only && $msg !~ /\Q$tst_only\E/)) {

		return 0;

	}

 '';

			$output .= RED;

		} elsif ($level eq 'WARNING') {

 YELLOW;

			$output .= GREEN;

		}

	}

 $prefix . $level . ':';

		$output .= BLUE if ($color);

 "$type:";

	$output .= RESET if ($color);

 ' ' . $msg . "\n";

		my @lines = split("\n", $output, -1);

		splice(@lines, 1, 1);

 join("\n", @lines);

		$output = (split('\n', $output))[0] . "\n";

	}



	if ($verbose && exists($verbose_messages{$type}) &&

	    !exists($verbose_emitted{$type})) {

 $verbose_messages{$type} . "\n\n";

		$verbose_emitted{$type} = 1;

	}



	push(our @report, $output);



	return 1;

}



sub report_dump {

	our @report;

}



sub fixup_current_range {

 @_;

	if ($$lineRef =~ /^\@\@ -\d+,\d+ \+(\d+),(\d+) \@\@/) {

 $1;

		my $l = $2;

 $o + $offset;

		my $nl = $l + $length;

~ s/\+$o,$l \@\@/\+$no,$nl \@\@/;

	my ($linesRef, $insertedRef, $deletedRef) = @_;



 0;

	my $delta_offset = 0;



 0;

	my $new_linenr = 0;



 0;

	my $next_delete = 0;



 ();

	my $inserted = @{$insertedRef}[$next_insert++];

 @{$deletedRef}[$next_delete++];

		my $save_line = 1;

don't modify the array

		if ($line =~ /^(?:\+\+\+|\-\-\-)\s+\S+/) {	#new filename

 0;

		} elsif ($line =~ /^\@\@ -\d+,\d+ \+\d+,\d+ \@\@/) {	#new hunk

 $new_linenr;

			$deleted = @{$deletedRef}[$next_delete++];

 0;

			$inserted = @{$insertedRef}[$next_insert++];

			$new_linenr++;

			fixup_current_range(\$lines[$range_last_linenr], $delta_offset++, 1);

		}



		if ($save_line) {

			push(@lines, $line);

			$new_linenr++;

		}



		$old_linenr++;

	}



	return @lines;

}



sub fix_insert_line {

 @_;

	my $inserted = {

> $linenr,

		LINE => $line,

	};

	push(@fixed_inserted, $inserted);

}



sub fix_delete_line {

 @_;

	my $deleted = {

> $linenr,

		LINE => $line,

	};



	push(@fixed_deleted, $deleted);

}



sub ERROR {

 @_;

		our $clean = 0;

		our $cnt_error++;

		return 1;

	}

	return 0;

}

sub WARN {

 @_;

		our $clean = 0;

		our $cnt_warn++;

		return 1;

	}

	return 0;

}

sub CHK {

 @_;

		our $clean = 0;

		our $cnt_chk++;

		return 1;

	}

	return 0;

}



sub check_absolute_file {

 @_;

	my $file = $absolute;



	##print "absolute<$absolute>\n";



	# See if any suffix of this path is a path within the tree.

~ s@^[^/]*/@@) {

 It is, so see if the prefix is acceptable.

	my $prefix = $absolute;

 '';

	my ($string) = @_;



~ s/^\s+|\s+$//g;

	my ($string) = @_;



~ s/^\s+//;

	my ($string) = @_;



~ s/\s+$//;

	my ($string, $find, $replace) = @_;



~ s/$find/$replace/g;

	my ($leading) = @_;



 $tabsize;

	my $max_spaces_before_tab = $source_indent - 1;

 " " x $source_indent;

convert leading spaces to tabs

	1 while $leading =~ s@^([\t]*)$spaces_to_tab@$1\t@g;

	#Remove spaces before a tab

~ s@^([\t]*)( {1,$max_spaces_before_tab})\t@$1\t@g;

	my ($line) = @_;



 0;

 $line 
 $line 
	my $last_openparen = 0;



 $opens)) {

	my $len = length($line);



 0; $pos < $len; $pos++) {

		my $string = substr($line, $pos);

~ /^($FuncArg|$balanced_parens)/) {

			$pos += length($1) - 1;

		} elsif (substr($line, $pos, 1) eq '(') {

 $pos;

	my ($line, $rawline) = @_;

 '';

			$comment .= substr($rawline, $i, 1);

		}

	}



	return $comment;

}



sub exclude_global_initialisers {

 @_;

 Do not check for BPF programs (tools/testing/selftests/bpf/progs/*.c, samples/bpf/*_kern.c, *.bpf.c).

	return $realfile =~ m@^tools/testing/selftests/bpf/progs/.*\.c$@ ||

~ m@^samples/bpf/.*_kern\.c$@ ||

		$realfile =~ m@/bpf/.*\.bpf\.c$@;

}



sub process {

 shift;

	my $linenr=0;

"";

	my $prevrawline="";

"";

	my $stashrawline="";



	my $length;

	my $indent;

0;

	my $stashindent=0;



 1;

	my $signoff = 0;

 '';

	my $authorsignoff = 0;

 '';

	my $is_patch = 0;

 -1;

	my $in_header_lines = $file ? 0 : 1;

Scanning lines before patch

	my $has_patch_separator = 0;	#Found a --- line

Encountered lines before patch

	my $commit_log_lines = 0;	#Number of commit log lines

 0;

	my $commit_log_long_line = 0;

 0;

	my $reported_maintainer_file = 0;

 0;

	my $last_git_commit_id_linenr = -1;



 0;

	my $last_coalesced_string_linenr = -1;



 ();

	our $cnt_lines = 0;

 0;

	our $cnt_warn = 0;

 0;

 Trace the real file/line as we go.

	my $realfile = '';

 0;

	my $realcnt = 0;

 '';

undef'd unless there's a known function

	my $in_comment = 0;

 0;

	my $first_line = 0;

 '';

	my $prev_values = 'E';



	# suppression flags

	my %suppress_ifbraces;

	my %suppress_whiletrailers;

	my %suppress_export;

 0;

	my %signatures = ();



	# Pre-scan the patch sanitizing the lines.

	# Pre-scan the patch looking for any __setup documentation.

	#

 ();

	my $setup_docs = 0;



 0;

	my $checklicenseline = 1;



	sanitise_line_reset();

	my $line;

	foreach my $rawline (@rawlines) {

		$linenr++;

 $rawline;

		if ($rawline=~/^\+\+\+\s+(\S+)/) {

 0;

			if ($1 =~ m@Documentation/admin-guide/kernel-parameters.txt$@) {

 1;

next;

		if ($rawline =~ /^\@\@ -\d+(?:,\d+)? \+(\d+)(,(\d+))? \@\@/) {

$1-1;

				$realcnt=$3+1;

			} else {

1+1;

			$in_comment = 0;



			# Guestimate if this is a continuing comment.  Run

			# the context looking for a comment "edge".  If this

			# edge is a close comment then we must be in a comment

			# at context start.

			my $edge;

 $realcnt;

			for (my $ln = $linenr + 1; $cnt > 0; $ln++) {

				next if (defined $rawlines[$ln - 1] &&

~ /^-/);

print "RAW<$rawlines[$ln - 1]>\n";

				if ($rawlines[$ln - 1] =~ m@(/\*|\*/)@ &&

				    $rawlines[$ln - 1] !~ m@"[^"]*(?:/\*|\*/)[^"]*"@) {

 $1;

				$in_comment = 1;

			}



			# Guestimate if this is a continuing comment.  If this

			# is the start of a diff block and this line starts

			# ' *' then it is very likely a comment.

			if (!defined $edge &&

~ m@^.\s*(?:\*\*+| \*)(?:\s|$)@)

				$in_comment = 1;

			}



			##print "COMMENT:$in_comment edge<$edge> $rawline\n";

			sanitise_line_reset($in_comment);



~ /^(?:\+| |$)/) {

 Standardise the strings and chars within the input to

 simplify matching -- only bother with positive lines.

			$line = sanitise_line($rawline);

		}

		push(@lines, $line);



		if ($realcnt > 1) {

~ /^(?:\+| |$)/);

			$realcnt = 0;

		}



		#print "==>$rawline\n";

		#print "-->$line\n";



~ /^\+/) {

	$prefix = '';



 0;

	$linenr = 0;

 -1;

		my $sline = $line;	#copy of $line

with comments as spaces

		my $rawline = $rawlines[$linenr - 1];

 get_raw_comment($line, $rawline);

 check if it's a mode change, rename or start of a patch

~ /^ mode change [0-7]+ 
		    ($line =~ /^rename (?:from|to) \S+\s*$/ ||

~ /^diff --git a\/[\w\/\.\_\-]+ b\/\S+\s*$/))) {

			$is_patch = 1;

		}



#extract the line range in the file after the patch is applied

		if (!$in_commit_log &&

~ /^\@\@ -\d+(?:,\d+)? \+(\d+)(,(\d+))? \@\@(.*)/) {

			my $context = $4;

 1;

			$first_line = $linenr + 1;

$1-1;

				$realcnt=$3+1;

			} else {

1+1;

			$prev_values = 'E';



 ();

			%suppress_whiletrailers = ();

 ();

			$suppress_statement = 0;

~ /\b(\w+)\s*\(/) {

				$context_function = $1;

			} else {

				undef $context_function;

			}

			next;



# track the line number as we move through the hunk, note that

# new versions of GNU diff omit the leading space on completely

# blank context lines so we need to count that too.

~ /^( |\+|$)/) {

			$realcnt-- if ($realcnt != 0);



			# Measure the line length and indent.

 line_stats($rawline);

 Track the previous line.

			($prevline, $stashline) = ($stashline, $line);

 ($stashindent, $indent);

			($prevrawline, $stashrawline) = ($stashrawline, $rawline);



			#warn "line<$line>\n";



		} elsif ($realcnt == 1) {

			$realcnt--;

		}



		my $hunk_line = ($realcnt != 0);



$linenr: " if (!$file);

		$here = "#$realline: " if ($file);



 0;

 extract the filename as it passes

		if ($line =~ /^diff --git.*?(\S+)$/) {

 $1;

			$realfile =~ s@^([^/]*)/@@ if (!$file);

 0;

			$found_file = 1;

~ /^\+\+\+\s+(\S+)/) {

			$realfile = $1;

~ s@^([^/]*)/@@ if (!$file);

			$in_commit_log = 0;



 $1;

			if ($realfile =~ m@^include/asm/@) {

				ERROR("MODIFIED_INCLUDE_ASM",

				      "do not modify files in include/asm, change architecture specific files in include/asm-<architecture>\n" . "$here$rawline\n");

			}

 1;

make up the handle for any error we report on this line

			$prefix = "$realfile:$realline: "

		} elsif ($emacs) {

			if ($file) {

 "$filename:$realline: ";

				$prefix = "$filename:$linenr: ";

			}

		}



		if ($found_file) {

			if (is_maintained_obsolete($realfile)) {

				WARN("OBSOLETE",

				     "$realfile is marked as 'obsolete' in the MAINTAINERS hierarchy.  No unnecessary modifications please.\n");

			}

~ m@^(?:drivers/net/|net/|drivers/staging/)@) {

				$check = 1;

			} else {

 $check_orig;

			$checklicenseline = 1;



			if ($realfile !~ /^MAINTAINERS/) {

 $is_binding_patch;

				$is_binding_patch = () = $realfile =~ m@^(?:Documentation/devicetree/|include/dt-bindings/)@;



 -1) &&

 "FILE: $realfile:$realline:" if ($realcnt !
		my $hereline = "$here\n$rawline\n";

 "$here\n$rawline\n";

		my $hereprev = "$here\n$prevrawline\n$rawline\n";



 0);

 Verify the existence of a commit log if appropriate

 2 is used because a $signature is counted in $commit_log_lines

could be a $signature

			$commit_log_lines = 2;	#warn only once

		}



# Check if the commit log has what seems like a diff which can confuse patch

		if ($in_commit_log && !$commit_log_has_diff &&

~ m@^\s+diff\b.*a/([\w/]+)@ &&

		      $line =~ m@^\s+diff\b.*a/[\w/]+\s+b/$1\b@) ||

~ m@^\s*(?:\-\-\-\s+a/|\+\+\+\s+b/)@ ||

		     $line =~ m/^\s*\@\@ \-\d+,\d+ \+\d+,\d+ \@\@/)) {

			ERROR("DIFF_IN_COMMIT_MSG",

			      "Avoid using diff content in the commit message - patch(1) might not work\n" . $herecurr);

 1;

 Check for incorrect file permissions

		if ($line =~ /^new (file )?mode.*[7531]\d{0,2}$/) {

 $here . "FILE: $realfile\n";

 Check the patch for a From:

		if (decode("MIME-Header", $line) =~ /^From:\s*(.*)/) {

 $1;

			my $curline = $linenr;

~ /^[ \t]\s*(.*)/)) {

				$author .= $1;

			}

 encode("utf8", $author) if ($line \?utf-8\?/i);

			$author =~ s/"//g;

 reformat_email($author);

 Check the patch for a signoff:

		if ($line =~ /^\s*signed-off-by:\s*(.*)/i) {

			$signoff++;

 0;

			if ($author ne ''  && $authorsignoff != 1) {

				if (same_email_addresses($1, $author)) {

 1;

					my $ctx = $1;

 parse_email($ctx);

					my ($author_name, $author_comment, $author_address, $comment2) = parse_email($author);



					if (lc $email_address eq lc $author_address && $email_name eq $author_name) {

 $ctx;

						$authorsignoff = 2;

					} elsif (lc $email_address eq lc $author_address) {

 $ctx;

						$authorsignoff = 3;

					} elsif ($email_name eq $author_name) {

 $ctx;

						$authorsignoff = 4;



 $email_address;

						my $address2 = $author_address;



~ /(\S+)\+\S+(\@.*)/) {

							$address1 = "$1$2";

						}

~ /(\S+)\+\S+(\@.*)/) {

							$address2 = "$1$2";

						}

						if ($address1 eq $address2) {

 5;

 Check for patch separator

		if ($line =~ /^---$/) {

 1;

			$in_commit_log = 0;

		}



# Check if MAINTAINERS is being updated.  If so, there's probably no need to

# emit the "does MAINTAINERS need updating?" message on file add/move/delete

~ /^\s*MAINTAINERS\s*\|/) {

			$reported_maintainer_file = 1;

		}



# Check signature styles

		if (!$in_header_lines &&

~ /^(\s*)([a-z0-9_-]+by:|$signature_tags)(\s*)(.*)/i) {

			my $space_before = $1;

 $2;

			my $space_after = $3;

 $4;

			my $ucfirst_sign_off = ucfirst(lc($sign_off));



			if ($sign_off !~ /$signature_tags/) {

 find_standard_signature($sign_off);

						$fixed[$fixlinenr] =~ s/$sign_off/$suggested_signature/;

					}

				}

			}

			if (defined $space_before && $space_before ne "") {

				if (WARN("BAD_SIGN_OFF",

					 "Do not use whitespace before $ucfirst_sign_off\n" . $herecurr) &&

				    $fix) {



			if ($sign_off =~ /-by:$/i && $sign_off ne $ucfirst_sign_off) {

				if (WARN("BAD_SIGN_OFF",

					 "'$ucfirst_sign_off' is the preferred signature form\n" . $herecurr) &&

				    $fix) {



					$fixed[$fixlinenr] =

					    "$ucfirst_sign_off $email";

				}

			}



 parse_email($email);

			my $suggested_email = format_email(($email_name, $name_comment, $email_address, $comment));

			if ($suggested_email eq "") {

				ERROR("BAD_SIGN_OFF",

				      "Unrecognized email address: '$email'\n" . $herecurr);

			} else {

 $suggested_email;

				$dequoted =~ s/^"//;

~ s/" </ </;

 Don't force email to have quotes

 Allow just an angle bracketed address

						$fixed[$fixlinenr] =~ s/\Q$email\E/$suggested_email/;

					}

				}



				# Address part shouldn't have comments

 $email_address;

				$stripped_address =~ s/\([^\(\)]*\)//g;

				if ($email_address ne $stripped_address) {

					if (WARN("BAD_SIGN_OFF",

						 "address part of email should not have comments: '$email_address'\n" . $herecurr) &&

					    $fix) {

~ s/\Q$email_address\E/$stripped_address/;

 Only one name comment should be allowed

				my $comment_count = () = $name_comment =~ /\([^\)]+\)/g;

				if ($comment_count > 1) {

					WARN("BAD_SIGN_OFF",

					     "Use a single name comment in email: '$email'\n" . $herecurr);

				}





				# stable@vger.kernel.org or stable@kernel.org shouldn't

				# have an email name. In addition comments should strictly

				# begin with a #

~ /^.*stable\@(?:vger\.)?kernel\.org/i) {

.+/) ||

						my $cur_name = $email_name;

 $comment;

						$cur_name =~ s/[a-zA-Z\s\-\"]+//g;



						# Remove brackets enclosing comment text

						# and # from start of comments to get comment text

~ s/^\((.*)\)$/$1/;

						$new_comment =~ s/^\[(.*)\]$/$1/;

]+|\s+$//g;

						$new_comment = trim("$new_comment $cur_name") if ($cur_name ne $new_comment);

 $new_comment" if ($new_comment ne "");

						my $new_email = "$email_address$new_comment";



						if (WARN("BAD_STABLE_ADDRESS_STYLE",

							 "Invalid email format for stable: '$email', prefer '$new_email'\n" . $herecurr) &&

						    $fix) {

~ s/\Q$email\E/$new_email/;

.+|\(.+\))$/) {

					my $new_comment = $comment;



					# Extract comment text from within brackets or

					# c89 style /*...*/ comments

~ s/^\[(.*)\]$/$1/;

					$new_comment =~ s/^\/\*(.*)\*\/$/$1/;



 trim($new_comment);

					$new_comment =~ s/^[^\w]$//; # Single lettered comment with non word character is usually a typo

 "($new_comment)" if ($new_comment ne "");

					my $new_email = format_email($email_name, $name_comment, $email_address, $new_comment);



					if (WARN("BAD_SIGN_OFF",

						 "Unexpected content after email: '$email', should be: '$new_email'\n" . $herecurr) &&

					    $fix) {

~ s/\Q$email\E/$new_email/;

 Check for duplicate signatures

			my $sig_nospace = $line;

~ s/\s//g;

			$sig_nospace = lc($sig_nospace);

			if (defined $signatures{$sig_nospace}) {

				WARN("BAD_SIGN_OFF",

				     "Duplicate signature\n" . $herecurr);

			} else {

 1;

 Check Co-developed-by: immediately followed by Signed-off-by: with same name and email

			if ($sign_off =~ /^co-developed-by:$/i) {

				if ($email eq $author) {

					WARN("BAD_SIGN_OFF",

					      "Co-developed-by: should not be used to attribute nominal patch author '$author'\n" . "$here\n" . $rawline);

				}

				if (!defined $lines[$linenr]) {

					WARN("BAD_SIGN_OFF",

					     "Co-developed-by: must be immediately followed by Signed-off-by:\n" . "$here\n" . $rawline);

				} elsif ($rawlines[$linenr] !~ /^\s*signed-off-by:\s*(.*)/i) {

					WARN("BAD_SIGN_OFF",

					     "Co-developed-by: must be immediately followed by Signed-off-by:\n" . "$here\n" . $rawline . "\n" .$rawlines[$linenr]);

				} elsif ($1 ne $email) {

					WARN("BAD_SIGN_OFF",

					     "Co-developed-by and Signed-off-by: name/email do not match \n" . "$here\n" . $rawline . "\n" .$rawlines[$linenr]);

				}

			}

		}



# Check email subject for common tools that don't need to be mentioned

		if ($in_header_lines &&

~ /^Subject:.*\b(?:checkpatch|sparse|smatch)\b[^:]/i) {

 Check for Gerrit Change-Ids not in any patch context

		if ($realfile eq '' && !$has_patch_separator && $line =~ /^\s*change-id:/i) {

			if (ERROR("GERRIT_CHANGE_ID",

			          "Remove Gerrit Change-Id's before submitting upstream\n" . $herecurr) &&

			    $fix) {

				fix_delete_line($fixlinenr, $rawline);

			}

		}



# Check if the commit log is in a possible stack dump

		if ($in_commit_log && !$commit_log_possible_stack_dump &&

~ /^\s*(?:WARNING:|BUG:)/ ||

		     $line =~ /^\s*\[\s*\d+\.\d{6,6}\s*\]/ ||

					# timestamp

~ /^\s*\[\<[0-9a-fA-F]{8,}\>\]/) ||

		     $line =~ /^(?:\s+\w+:\s+[0-9a-fA-F]+){3,3}/ ||

\d+\s*\[[0-9a-fA-F]+\]\s*\w+ at [0-9a-fA-F]+/) {

 stack dump address styles

			$commit_log_possible_stack_dump = 1;

		}



# Check for line lengths > 75 in commit log, warn once

		if ($in_commit_log && !$commit_log_long_line &&

		    length($line) > 75 &&

~ /^\s*[a-zA-Z0-9_\/\.]+\s+\|\s+\d+/ ||

 file delta changes

		      $line =~ /^\s*(?:[\w\.\-]+\/)++[\w\.\-]+:/ ||

					# filename then :

~ /^\s*(?:Fixes:|Link:|$signature_tags)/i ||

 A Fixes: or Link: line or signature tag line

			$commit_log_long_line = 1;

		}



# Reset possible stack dump if a blank line is found

		if ($in_commit_log && $commit_log_possible_stack_dump &&

~ /^\s*$/) {

			$commit_log_possible_stack_dump = 0;

		}



# Check for lines starting with a #

/) {

' are dropped by git as comments\n" . $herecurr) &&

				$fixed[$fixlinenr] =~ s/^/ /;

			}

		}



# Check for git id commit length and improperly formed commit descriptions

# A correctly formed commit description is:

#    commit <SHA-1 hash length 12+ chars> ("Complete commit subject")

# with the commit subject '("' prefix and '")' suffix

# This is a fairly compilicated block as it tests for what appears to be

# bare SHA-1 hash with  minimum length of 5.  It also avoids several types of

# possible SHA-1 matches.

# A commit match can span multiple lines so this block attempts to find a

# complete typical commit on a maximum of 3 lines

		if ($perl_version_ok &&

		    $in_commit_log && !$commit_log_possible_stack_dump &&

		    $line !~ /^\s*(?:Link|Patchwork|http|https|BugLink|base-commit):/i &&

		    $line !~ /^This reverts commit [0-9a-f]{7,40}/ &&

~ /\bcommit\s+[0-9a-f]{5,}\b/i ||

~ /\bcommit\s*$/i && defined($rawlines[$linenr]) && $rawlines[$linenr] 
		     ($line =~ /(?:\s|^)[0-9a-f]{12,40}(?:[\s"'\(\[]|$)/i &&

		      $line !~ /[\<\[][0-9a-f]{12,40}[\>\]]/i &&

		      $line !~ /\bfixes:\s*[0-9a-f]{12,40}/i))) {

 "c";

			my $orig_commit = "";

 1;

			my $long = 0;

 1;

			my $space = 1;

 '0123456789ab';

			my $orig_desc = "commit description";

 "";

			my $herectx = $herecurr;

 0;

			my $has_quotes = 0;



 $line;

			if ($line =~ /(?:\bcommit\s+[0-9a-f]{5,}|\bcommit\s*$)/i) {

 0; $n < 2; $n++) {

					if ($input =~ /\bcommit\s+[0-9a-f]{5,}\s*($balanced_parens)/i) {

 $1;

						$has_parens = 1;

						# Always strip leading/trailing parens then double quotes if existing

 substr($orig_desc, 1, -1);

						if ($orig_desc =~ /^".*"$/) {

 substr($orig_desc, 1, -1);

							$has_quotes = 1;

						}

						last;

					}

					last if ($#lines < $linenr + $n);

 " " . trim($rawlines[$linenr + $n]);

					$herectx .= "$rawlines[$linenr + $n]\n";

				}

 $herecurr if (!$has_parens);

			if ($input =~ /\b(c)ommit\s+([0-9a-f]{5,})\b/i) {

 $1;

				$orig_commit = lc($2);

				$short = 0 if ($input =~ /\bcommit\s+[0-9a-f]{12,40}/i);

				$long = 1 if ($input =~ /\bcommit\s+[0-9a-f]{41,}/i);

				$space = 0 if ($input =~ /\bcommit [0-9a-f]/i);

				$case = 0 if ($input =~ /\b[Cc]ommit\s+[0-9a-f]{5,40}[^A-F]/);

~ /\b([0-9a-f]{12,40})\b/i) {

				$orig_commit = lc($1);

			}



 git_commit_info($orig_commit,

			    $last_git_commit_id_linenr != $linenr - 1) {

				ERROR("GIT_COMMIT_ID",

				      "Please use git commit description style 'commit <12+ chars of sha1> (\"<title line>\")' - ie: '${init_char}ommit $id (\"$description\")'\n" . $herectx);

			}

			#don't report the next line if this line ends in commit and the sha1 hash is the next line

			$last_git_commit_id_linenr = $linenr if ($line =~ /\bcommit\s*$/i);

		}



# Check for added, moved or deleted files

		if (!$reported_maintainer_file && !$in_commit_log &&

~ /^(?:new|deleted) file mode\s*\d+\s*$/ ||

		     $line =~ /^rename (?:from|to) [\w\/\.\-]+\s*$/ ||

		     ($line =~ /\{\s*([\w\/\.\-]*)\s*\=\>\s*([\w\/\.\-]*)\s*\}/ &&

		      (defined($1) || defined($2))))) {

 1;

			$reported_maintainer_file = 1;

			WARN("FILE_PATH_CHANGES",

			     "added, moved or deleted file(s), does MAINTAINERS need updating?\n" . $herecurr);

		}



# Check for adding new DT bindings not in schema format

		if (!$in_commit_log &&

~ /^new file mode\s*\d+\s*$/) &&

		    ($realfile =~ m@^Documentation/devicetree/bindings/.*\.txt$@)) {

			WARN("DT_SCHEMA_BINDING_PATCH",

			     "DT bindings should be in DT schema format. See: Documentation/devicetree/bindings/writing-schema.rst\n");

		}



# Check for wrappage within a valid hunk of the file

 0 && $line !~ m{^(?:\+|-| |\\ No newline|$)}) {

 UTF-8 regex found at http://www.w3.org/International/questions/qa-forms-utf-8.en.php

~ /^$/ || $line 
 ($rawline 
			my $blank = copy_spacing($rawline);

 substr($blank, 0, length($utf8_prefix)) . "^";

			my $hereptr = "$hereline$ptr\n";



			CHK("INVALID_UTF8",

			    "Invalid UTF-8, patch and commit message should be encoded in UTF-8\n" . $hereptr);

		}



# Check if it's the start of a commit log

# (not a header line and we haven't seen the patch filename)

~ /^$/ &&

		    !($rawline =~ /^\s+(?:\S|$)/ ||

~ /^(?:commit\b|from\b|[\w-]+:)/i)) {

			$in_header_lines = 0;

 1;

			$has_commit_log = 1;

		}



# Check if there is UTF-8 in a commit log when a mail header has explicitly

# declined it, i.e defined some charset where it is missing.

		if ($in_header_lines &&

		    $rawline =~ /^Content-Type:.+charset="(.+)".*$/ &&

		    $1 !~ /utf-8/i) {

 1;

		if ($in_commit_log && $non_utf8_charset && $realfile =~ /^$/ &&

~ /$NON_ASCII_UTF8/) {

 Check for absolute kernel paths in commit message

			while ($line =~ m{(?:^|\s)(/\S*)}g) {

 $1;

				if ($file =~ m{^(.*?)(?::\d+)+:?$} &&

				    check_absolute_file($1, $herecurr)) {

					#

				} else {

					check_absolute_file($file, $herecurr);

				}

			}

		}



# Check for various typo / spelling mistakes

		if (defined($misspellings) &&

~ /^(?:\+|Subject:)/i)) {

			while ($rawline =~ /(?:^|[^\w\-'`])($misspellings)(?:[^\w\-'`]|$)/gi) {

 $1;

				my $blank = copy_spacing($rawline);

 substr($blank, 0, $-[1]) . "^" x length($typo);

				my $hereptr = "$hereline$ptr\n";

 $spelling_fix{lc($typo)};

 ucfirst($typo_fix) if ($typo 
 uc($typo_fix) if ($typo 
				my $msg_level = \&WARN;

 \&CHK if ($file);

					$fixed[$fixlinenr] =~ s/(^|[^A-Za-z@])($typo)($|[^A-Za-z@])/$1$typo_fix$3/;

				}

			}

		}



# check for invalid commit id

~ /(^fixes:|\bcommit)\s+([0-9a-f]{6,40})\b/i) {

			($id, $description) = git_commit_info($2, undef, undef);

			if (!defined($id)) {

				WARN("UNKNOWN_COMMIT_ID",

				     "Unknown commit id '$2', maybe rebased or not pulled?\n" . $herecurr);

			}

		}



# check for repeated words separated by a single space

# avoid false positive from list command eg, '-rw-r--r-- 1 root root'

~ /^\+/ || $in_commit_log) &&

			pos($rawline) = 1 if (!$in_commit_log);

			while ($rawline =~ /\b($word_pattern) (?=($word_pattern))/g) {



 $1;

				my $second = $2;

 $-[1];

				my $end_pos = $+[2];

~ /(?:struct|union|enum)/) {

					pos($rawline) += length($first) + length($second) + 1;

					next;

				}



				next if (lc($first) ne lc($second));

				next if ($first eq 'long');



				# check for character before and after the word matches

 '';

				my $end_char = '';

 substr($rawline, $start_pos - 1, 1) if ($start_pos > ($in_commit_log ? 0 : 1));

				$end_char = substr($rawline, $end_pos, 1) if ($end_pos < length($rawline));



~ /^\S$/);

 avoid repeating hex occurrences like 'ff ff fe 09 ...'

				if ($first =~ /\b[0-9a-f]{2,}\b/i) {

					next if (!exists($allow_repeated_words{lc($first)}));

				}



				if (WARN("REPEATED_WORD",

					 "Possible repeated word: '$first'\n" . $herecurr) &&

				    $fix) {

~ s/\b$first $second\b/$first/;

 if it's a repeated word on consecutive lines in a comment block

			if ($prevline =~ /$;+\s*$/ &&

~ /($word_pattern)\s*$/) {

				my $last_word = $1;

~ /^\+\s*\*\s*$last_word /) {

						$fixed[$fixlinenr] =~ s/(\+\s*\*\s*)$last_word /$1/;

					}

				}

			}

		}



# ignore non-hunk lines and lines being removed

~ /^-/);

trailing whitespace

		if ($line =~ /^\+.*\015/) {

 "$here\n" . cat_vet($rawline) . "\n";

				$fixed[$fixlinenr] =~ s/[\s\015]+$//;

			}

		} elsif ($rawline =~ /^\+.*\S\s+$/ || $rawline =~ /^\+\s+$/) {

 "$here\n" . cat_vet($rawline) . "\n";

				$fixed[$fixlinenr] =~ s/\s+$//;

			}



 1;

 Check for FSF mailing addresses.

		if ($rawline =~ /\bwrite to the Free/i ||

~ /\b675\s+Mass\s+Ave/i ||

		    $rawline =~ /\b59\s+Temple\s+Pl/i ||

~ /\b51\s+Franklin\s+St/i) {

			my $herevet = "$here\n" . cat_vet($rawline) . "\n";

 \&ERROR;

			$msg_level = \&CHK if ($file);

			&{$msg_level}("FSF_MAILING_ADDRESS",

				      "Do not include the paragraph about writing to the Free Software Foundation's mailing address from the sample GPL notice. The FSF has changed addresses in the past, and may do so again. Linux already includes a copy of the GPL.\n" . $herevet)

		}



# check for Kconfig help text having a real description

# Only applies when adding the entry originally, after that we do not have

# sufficient context to determine whether it is indeed long enough.

~ /Kconfig/ &&

 'choice' is usually the last thing on the line (though

 Kconfig supports named choices), so use a word boundary

 (\b) rather than a whitespace character (\s)

		    $line =~ /^\+\s*(?:config|menuconfig|choice)\b/) {

 0;

			my $cnt = $realcnt;

 $linenr + 1;

			my $is_start = 0;

 0;

				$f = $lines[$ln - 1];

				$cnt-- if ($lines[$ln - 1] !~ /^-/);

				$is_end = $lines[$ln - 1] =~ /^\+/;



~ /^-/);

				last if (!$file && $f =~ /^\@\@/);



~ /^\+\s*(?:bool|tristate|prompt)\s*["']/) {

					$is_start = 1;

~ /^\+\s*(?:---)?help(?:---)?$/) {

					$length = -1;

				}



~ s/^.//;

				$f =~ s/#.*//;

~ s/^\s+//;

				next if ($f =~ /^$/);



				# This only checks context lines in the patch

				# and so hopefully shouldn't trigger false

				# positives, even though some of these are

				# common words in help texts

~ /^\s*(?:config|menuconfig|choice|endchoice|

					$is_end = 1;

					last;

				}

				$length++;

			}

			if ($is_start && $is_end && $length < $min_conf_desc_length) {

				WARN("CONFIG_DESCRIPTION",

				     "please write a paragraph that describes the config symbol fully\n" . $herecurr);

			}

			#print "is_start<$is_start> is_end<$is_end> length<$length>\n";

		}



# check MAINTAINERS entries

~ /^MAINTAINERS$/) {

 check MAINTAINERS entries for the right form

			if ($rawline =~ /^\+[A-Z]:/ &&

			    $rawline !~ /^\+[A-Z]:\t\S/) {

				if (WARN("MAINTAINERS_STYLE",

					 "MAINTAINERS entries use one tab after TYPE:\n" . $herecurr) &&

				    $fix) {

~ s/^(\+[A-Z]):\s*/$1:\t/;

 check MAINTAINERS entries for the right ordering too

			my $preferred_order = 'MRLSWQBCPTFXNK';

~ /^\+[A-Z]:/ &&

			    $prevrawline =~ /^[\+ ][A-Z]:/) {

~ /^\+([A-Z]):\s*(.*)/;

				my $cur = $1;

 $2;

				$prevrawline =~ /^[\+ ]([A-Z]):\s*(.*)/;

 $1;

				my $prevval = $2;

 index($preferred_order, $cur);

				my $previndex = index($preferred_order, $prev);

				if ($curindex < 0) {

					WARN("MAINTAINERS_STYLE",

					     "Unknown MAINTAINERS entry type: '$cur'\n" . $herecurr);

				} else {

 0 && $curindex < $previndex) {

~ /Makefile.*/ || $realfile 
		    ($line =~ /\+(EXTRA_[A-Z]+FLAGS).*/)) {

 $1;

			my $replacement = {

>   'asflags-y',

				'EXTRA_CFLAGS' =>   'ccflags-y',

> 'cppflags-y',

				'EXTRA_LDFLAGS' =>  'ldflags-y',

			};



			WARN("DEPRECATED_VARIABLE",

			     "Use of $flag is deprecated, please use \`$replacement->{$flag} instead.\n" . $herecurr) if ($replacement->{$flag});

		}



# check for DT compatible documentation

		if (defined $root &&

~ /\.dtsi?$/ && $line \s*\"/) ||

			 ($realfile =~ /\.[ch]$/ && $line =~ /^\+.*\.compatible\s*=\s*\"/))) {



			my @compats = $rawline =~ /\"([a-zA-Z0-9\-\,\.\+_]+)\"/g;



 $root . "/Documentation/devicetree/bindings/";

			my $vp_file = $dt_path . "vendor-prefixes.yaml";



			foreach my $compat (@compats) {

 $compat;

				$compat2 =~ s/\,[a-zA-Z0-9]*\-/\,<\.\*>\-/;

 $compat;

				$compat3 =~ s/\,([a-z]*)[0-9]*\-/\,$1<\.\*>\-/;

				`grep -Erq "$compat|$compat2|$compat3" $dt_path`;

				if ( $? >> 8 ) {

					WARN("UNDOCUMENTED_DT_STRING",

					     "DT compatible string \"$compat\" appears un-documented -- check $dt_path\n" . $herecurr);

				}



				next if $compat !~ /^([a-zA-Z0-9\-]+)\,/;

 $1;

 check for using SPDX license tag at beginning of files

			if ($rawline =~ /^[ \+]\s*\#\!\s*\//) {

 2;

			} elsif ($rawline =~ /^\+/) {

 "";

				if ($realfile =~ /\.(h|s|S)$/) {

 '/*';

				} elsif ($realfile =~ /\.(c|dts|dtsi)$/) {

 '//';

				} elsif (($checklicenseline == 2) || $realfile =~ /\.(sh|pl|py|awk|tc|yaml)$/) {

';

				} elsif ($realfile =~ /\.rst$/) {

 '..';

 check SPDX comment style for .[chsS] files

				if ($realfile =~ /\.[chsS]$/ &&

~ /SPDX-License-Identifier:/ &&

				} elsif ($rawline =~ /(SPDX-License-Identifier: .*)/) {

 $1;

					if ($realfile =~ m@^Documentation/devicetree/bindings/@ &&

~ /GPL-2\.0.*BSD-2-Clause/) {

						my $msg_level = \&WARN;

 \&CHK if ($file);

							$fixed[$fixlinenr] =~ s/SPDX-License-Identifier: .*/SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)/;

						}

					}

				}

			}

		}



# check for embedded filenames

~ /^\+.*\Q$realfile\E/) {

 check we are in a valid source file if not then ignore this hunk

 check for using SPDX-License-Identifier on the wrong line number

		if ($realline != $checklicenseline &&

~ /\bSPDX-License-Identifier:/ &&

 line length limit (with some exclusions)



 There are a few types of lines that may extend beyond $max_line_length:

	logging functions like pr_info that end in a string

	lines with a single string

	
	lines with an RFC3986 like URL



 There are 3 different line length message types:

 LONG_LINE_COMMENT	a comment starts before but extends beyond $max_line_length

 LONG_LINE_STRING	a string starts before but extends beyond $max_line_length

 LONG_LINE		all other lines longer than $max_line_length



 if LONG_LINE is ignored, the other 2 types are also ignored



		if ($line =~ /^\+/ && $length > $max_line_length) {

 "LONG_LINE";

 Check the allowed long line types first

 logging functions that end in a string that starts

 before $max_line_length

			if ($line =~ /^\+\s*$logFunctions\s*\(\s*(?:(?:KERN_\S+\s*|[^"]*))?($String\s*(?:|,|\)\s*;)\s*)$/ &&

 $max_line_length) {

				$msg_type = "";



			# lines with only strings (w/ possible termination)

			# #defines with only strings

~ /^\+\s*$String\s*(?:\s*|,|\)\s*;)\s*$/ ||

				 $line =~ /^\+\s*#\s*define\s+\w+\s+$String$/) {

 "";

 More special cases

			} elsif ($line =~ /^\+.*\bEFI_GUID\s*\(/ ||

~ /^\+\s*(?:\w+)?\s*DEFINE_PER_CPU/) {

				$msg_type = "";



			# URL ($rawline is used in case the URL is in a comment)

~ /^\+.*\b[a-z][\w\.\+\-]*:\/\/\S+/i) {

				$msg_type = "";



			# Otherwise set the alternate message types



			# a comment starts before $max_line_length

~ /($;[\s$;]*)$/ &&

				 length(expand_tabs(substr($line, 1, length($line) - length($1) - 1))) <= $max_line_length) {

 "LONG_LINE_COMMENT"

 a quoted string starts before $max_line_length

			} elsif ($sline =~ /\s*($String(?:\s*(?:\\|,\s*|\)\s*;\s*))?)$/ &&

 $max_line_length) {

				$msg_type = "LONG_LINE_STRING"

			}



			if ($msg_type ne "" &&

			    (show_type("LONG_LINE") || show_type($msg_type))) {

 \&WARN;

				$msg_level = \&CHK if ($file);

				&{$msg_level}($msg_type,

					      "line length of $length exceeds $max_line_length columns\n" . $herecurr);

			}

		}



# check for adding lines without a newline.

		if ($line =~ /^\+/ && defined $lines[$linenr] && $lines[$linenr] =~ /^\\ No newline at end of file/) {

			if (WARN("MISSING_EOF_NEWLINE",

			         "adding a line without newline at end of file\n" . $herecurr) &&

			    $fix) {

				fix_delete_line($fixlinenr+1, "No newline at end of file");

			}

		}



# check for .L prefix local symbols in .S files

~ /\.S$/ &&

		    $line =~ /^\+\s*(?:[A-Z]+_)?SYM_[A-Z]+_(?:START|END)(?:_[A-Z_]+)?\s*\(\s*\.L/) {

			WARN("AVOID_L_PREFIX",

			     "Avoid using '.L' prefixed local symbol names for denoting a range of code via 'SYM_*_START/END' annotations; see Documentation/asm-annotations.rst\n" . $herecurr);

		}



# check we are in a valid source file C or perl if not then ignore this hunk

		next if ($realfile !~ /\.(h|c|pl|dtsi|dts)$/);



# at the beginning of a line any tabs must come first and anything

# more than $tabsize must use tabs.

~ /^\+\s* \t\s*\S/ ||

		    $rawline =~ /^\+\s*        \s*/) {

 "$here\n" . cat_vet($rawline) . "\n";

			$rpt_cleaners = 1;

			if (ERROR("CODE_INDENT",

				  "code indent should use tabs where possible\n" . $herevet) &&

			    $fix) {

~ s/^\+([ \t]+)/"\+" . tabify($1)/e;

 check for space before tabs.

~ /^\+/ && $rawline 
			my $herevet = "$here\n" . cat_vet($rawline) . "\n";

			if (WARN("SPACE_BEFORE_TAB",

				"please, no space before tabs\n" . $herevet) &&

			    $fix) {

~

				while ($fixed[$fixlinenr] =~

					   s/(^\+.*) +\t/$1\t/) {}

			}

		}



# check for assignments on the start of a line

		if ($sline =~ /^\+\s+($Assignment)[^=]/) {

 $1;

			    $fix && $prevrawline =~ /^\+/) {

				# add assignment operator to the previous line, remove from current line

 " $operator";

				$fixed[$fixlinenr] =~ s/\Q$operator\E\s*//;

			}

		}



# check for && or || at the start of a line

~ /^\+\s*(&&|\|\|)/) {

			my $operator = $1;

			if (CHK("LOGICAL_CONTINUATIONS",

				"Logical continuations should be on the previous line\n" . $hereprev) &&

~ /^\+/) {

 insert logical operator at last non-comment, non-whitepsace char on previous line

				$prevline =~ /[\s$;]*$/;

 substr($prevrawline, $-[0]);

				$fixed[$fixlinenr - 1] =~ s/\Q$line_end\E$/ $operator$line_end/;

~ s/\Q$operator\E\s*//;

 check indentation starts on a tab stop

~ /^\+\t+( +)(?:$c90_Keywords\b|\{\s*$|\}\s*(?:else\b|while\b|\s*$)|$Declare\s*$Ident\s*[;
			my $indent = length($1);

			if ($indent % $tabsize) {

				if (WARN("TABSTOP",

					 "Statements should start on a tabstop\n" . $herecurr) &&

				    $fix) {

~ s@(^\+\t+) +@$1 . "\t" x ($indent/$tabsize)@e;

 check multi-line statement indentation matches previous line

~ /^\+([ \t]*)((?:$c90_Keywords(?:\s+if)\s*)|(?:$Declare\s*)?(?:$Ident|\(\s*\*\s*$Ident\s*\))\s*|(?:\*\s*)*$Lval\s*
			$prevline =~ /^\+(\t*)(.*)$/;

 $1;

			my $rest = $2;



 pos_last_openparen($rest);

			if ($pos >= 0) {

~ /^(\+| )([ \t]*)/;

				my $newindent = $2;



 $oldindent .

				my $goodspaceindent = $oldindent . " "  x $pos;



				if ($newindent ne $goodtabindent &&

				    $newindent ne $goodspaceindent) {



					if (CHK("PARENTHESIS_ALIGNMENT",

						"Alignment should match open parenthesis\n" . $hereprev) &&

~ /^\+/) {

						$fixed[$fixlinenr] =~

						    s/^\+[ \t]*/\+$goodtabindent/;

					}

				}

			}

		}



# check for space after cast like "(int) foo" or "(struct foo) bar"

# avoid checking a few false positives:

#   "sizeof(<type>)" or "__alignof__(<type>)"

   function pointer declarations like "(*foo)(int) = bar;"

   structure definitions like "(struct foo) { 0 };"

   multiline macros that define functions

   known attributes or the __attribute__ keyword

~ /^\+(.*)\(\s*$Type\s*\)([ \t]++)((?![
				$fixed[$fixlinenr] =~

				    s/(\(\s*$Type\s*\))[ \t]+/$1/;

			}

		}



# Block comment styles

# Networking with an initial /*

~ m@^(drivers/net/|net/)@ &&

		    $prevrawline =~ /^\+[ \t]*\/\*[ \t]*$/ &&

~ /^\+[ \t]*\*/ &&

 Do not warn about the initial copyright comment block after SPDX-License-Identifier

 Block comments use * on subsequent lines

		if ($prevline =~ /$;[ \t]*$/ &&			#ends in comment

starting /*

no trailing */

		    $rawline =~ /^\+/ &&			#line is new

		    $rawline !~ /^\+[ \t]*\*/) {		#no leading *

			WARN("BLOCK_COMMENT_STYLE",

			     "Block comments use * on subsequent lines\n" . $hereprev);

		}



# Block comments use */ on trailing lines

		if ($rawline !~ m@^\+[ \t]*\*/[ \t]*$@ &&	#trailing */

		    $rawline !~ m@^\+.*/\*.*\*/[ \t]*$@ &&	#inline /*...*/

		    $rawline !~ m@^\+.*\*{2,}/[ \t]*$@ &&	#trailing **/

non blank */

 Block comment * alignment

		if ($prevline =~ /$;[ \t]*$/ &&			#ends in comment

leading comment

		    $rawline =~ /^\+[ \t]*\*/ &&		#leading *

leading /*

no trailing */

		     $prevrawline =~ /^\+[ \t]*\*/)) {		#leading *

			my $oldindent;

~ m@^\+([ \t]*/?)\*@;

				$oldindent = expand_tabs($1);

			} else {

~ m@^\+(.*/?)\*@;

				$oldindent = expand_tabs($1);

			}

~ m@^\+([ \t]*)\*@;

			my $newindent = $1;

 expand_tabs($newindent);

 check for missing blank lines after struct/union declarations

 with exceptions for various attributes and macros

		if ($prevline =~ /^[\+ ]};?\s*$/ &&

~ /^\+/ &&

		    !($line =~ /^\+\s*$/ ||

~ /^\+\s*EXPORT_SYMBOL/ ||

		      $line =~ /^\+\s*MODULE_/i ||

\s*(?:end|elif|else)/ ||

		      $line =~ /^\+[a-z_]*init/ ||

~ /^\+\s*(?:static\s+)?[A-Z_]*ATTR/ ||

		      $line =~ /^\+\s*DECLARE/ ||

~ /^\+\s*builtin_[\w_]*driver/ ||

		      $line =~ /^\+\s*__setup/)) {

			if (CHK("LINE_SPACING",

				"Please use a blank line after function/struct/union/enum declarations\n" . $hereprev) &&

			    $fix) {

				fix_insert_line($fixlinenr, "\+");

			}

		}



# check for multiple consecutive blank lines

~ /^[\+ ]\s*$/ &&

		    $line =~ /^\+\s*$/ &&

 ($linenr - 1)) {

			$last_blank_line = $linenr;

		}



# check for missing blank lines after declarations

# (declarations must have the same indentation and not be at the start of line)

		if (($prevline =~ /\+(\s+)\S/) && $sline =~ /^\+$1\S/) {

			# use temporaries

 $sline;

			my $pl = $prevline;

			# remove $Attribute/$Sparse uses to simplify comparisons

~ s/\b(?:$Attribute|$Sparse)\b//g;

			$pl =~ s/\b(?:$Attribute|$Sparse)\b//g;

			if (($pl =~ /^\+\s+$Declare\s*$Ident\s*[=,;:\[]/ ||

			# function pointer declarations

			     $pl =~ /^\+\s+$Declare\s*\(\s*\*\s*$Ident\s*\)\s*[=,;:\[\(]/ ||

			# foo bar; where foo is some local typedef or #define

			     $pl =~ /^\+\s+$Ident(?:\s+|\s*\*\s*)$Ident\s*[=,;\[]/ ||

			# known declaration macros

~ /^\+\s+$declaration_macros/) &&

 for "else if" which can look like "$Ident $Ident"

			    !($pl =~ /^\+\s+$c90_Keywords\b/ ||

			# other possible extensions of declaration lines

~ /(?:$Compare|$Assignment|$Operators)\s*$/ ||

 not starting a section or a macro "\" extended line

			      $pl =~ /(?:\{\s*|\\)$/) &&

			# looks like a declaration

			    !($sl =~ /^\+\s+$Declare\s*$Ident\s*[=,;:\[]/ ||

			# function pointer declarations

			      $sl =~ /^\+\s+$Declare\s*\(\s*\*\s*$Ident\s*\)\s*[=,;:\[\(]/ ||

			# foo bar; where foo is some local typedef or #define

			      $sl =~ /^\+\s+$Ident(?:\s+|\s*\*\s*)$Ident\s*[=,;\[]/ ||

			# known declaration macros

~ /^\+\s+$declaration_macros/ ||

 start of struct or union or enum

			      $sl =~ /^\+\s+(?:static\s+)?(?:const\s+)?(?:union|struct|enum|typedef)\b/ ||

			# start or end of block or continuation of declaration

\"\?\:\(\[])/ ||

 bitfield continuation

			      $sl =~ /^\+\s+$Ident\s*:\s*\d+\s*[,;]/ ||

			# other possible extensions of declaration lines

~ /^\+\s+\(?\s*(?:$Compare|$Assignment|$Operators)/)) {

 check for spaces at the beginning of a line.

 Exceptions:

  1) within comments

  2) indented preprocessor commands

  3) hanging labels

		if ($rawline =~ /^\+ / && $line !~ /^\+ *(?:$;|#|$Ident:)/)  {

 "$here\n" . cat_vet($rawline) . "\n";

				$fixed[$fixlinenr] =~ s/^\+([ \t]+)/"\+" . tabify($1)/e;

			}

		}



# check we are in a valid C source file if not then ignore this hunk

		next if ($realfile !~ /\.(h|c)$/);



# check for unusual line ending [ or (

~ /^\+.*([\[\(])\s*$/) {

 check if this appears to be the start function declaration, save the name

		if ($sline =~ /^\+\{\s*$/ &&

~ /^\+(?:(?:(?:$Storage|$Inline)\s*)*\s*$Type\s*)?($Ident)\(/) {

			$context_function = $1;

		}



# check if this appears to be the end of function declaration

~ /^\+\}\s*$/) {

 check indentation of any line with a bare else

 (but not if it is a multiple line "if (foo) return bar; else return baz;")

 if the previous line is a break or return and is indented 1 tab more...

		if ($sline =~ /^\+([\t]+)(?:}[ \t]*)?else(?:[ \t]*{)?\s*$/) {

 length($1) + 1;

			if ($prevline =~ /^\+\t{$tabs,$tabs}break\b/ ||

~ /^\+\t{$tabs,$tabs}return\b/ &&

 check indentation of a line with a break;

 if the previous line is a goto, return or break

 and is indented the same 
		if ($sline =~ /^\+([\t]+)break\s*;\s*$/) {

 $1;

			if ($prevline =~ /^\+$tabs(goto|return|break)\b/) {

				if (WARN("UNNECESSARY_BREAK",

					 "break is not useful after a $1\n" . $hereprev) &&

				    $fix) {

					fix_delete_line($fixlinenr, $rawline);

				}

			}

		}



# check for RCS/CVS revision markers

~ /^\+.*\$(Revision|Log|Id)(?:\$|)/) {

 check for old HOTPLUG __dev<foo> section markings

		if ($line =~ /\b(__dev(init|exit)(data|const|))\b/) {

			WARN("HOTPLUG_SECTION",

			     "Using $1 is unnecessary\n" . $herecurr);

		}



# Check for potential 'bare' types

		my ($stat, $cond, $line_nr_next, $remain_next, $off_next,

		    $realline_next);

#print "LINE<$line>\n";

		if ($linenr > $suppress_statement &&

~ /.\s*\S/) {

			($stat, $cond, $line_nr_next, $remain_next, $off_next) =

				ctx_statement_block($linenr, $realcnt, 0);

~ s/\n./\n /g;

			$cond =~ s/\n./\n /g;



#print "linenr<$linenr> <$stat>\n";

			# If this statement has no statement boundaries within

			# it there is no point in retrying a statement scan

			# until we hit end of it.

			my $frag = $stat; $frag =~ s/;+\s*$//;

			if ($frag !~ /(?:{|;)/) {

#print "skip<$line_nr_next>\n";

 $line_nr_next;

 Find the real next line.

			$realline_next = $line_nr_next;

			if (defined $realline_next &&

			    (!defined $lines[$realline_next - 1] ||

~ /^\s*$/)) {

			my $s = $stat;

~ s/{.*$//s;

 Ignore goto labels.

			if ($s =~ /$Ident:\*$/s) {



			# Ignore functions being called

~ /^.\s*$Ident\s*\(/s) {

			} elsif ($s =~ /^.\s*else\b/s) {



			# declarations always start with types

			} elsif ($prev_values eq 'E' && $s =~ /^.\s*(?:$Storage\s+)?(?:$Inline\s+)?(?:const\s+)?((?:\s*$Ident)+?)\b(?:\s+$Sparse)?\s*\**\s*(?:$Ident|\(\*[^\)]*\))(?:\s*$Modifier)?\s*(?:;|=|,|\()/s) {

 $1;

				$type =~ s/\s+/ /g;

				possible($type, "A:" . $s);



			# definitions in global scope can only start with types

~ /^.(?:$Storage\s+)?(?:$Inline\s+)?(?:const\s+)?($Ident)\b\s*(?!:)/s) {

 any (foo ... *) is a pointer cast, and foo is a type

			while ($s =~ /\(($Ident)(?:\s+$Sparse)*[\s\*]+\s*\)/sg) {

				possible($1, "C:" . $s);

			}



			# Check for any sort of function declaration.

			# int foo(something bar, other baz);

			# void (*store_gdt)(x86_descr_ptr *);

~ /^(.(?:typedef\s*)?(?:(?:$Storage|$Inline)\s*)*\s*$Type\s*(?:\b$Ident|\(\*\s*$Ident\))\s*)\(/s) {

				my ($name_len) = length($1);



 $s;

				$ctx =~ s/\)[^\)]*$//;



				for my $arg (split(/\s*,\s*/, $ctx)) {

					if ($arg =~ /^(?:const\s+)?($Ident)(?:\s+$Sparse)*\s*\**\s*(:?\b$Ident)?$/s || $arg =~ /^($Ident)$/s) {



						possible($1, "D:" . $s);

					}

				}

			}



		}



#

# Checks which may be anchored in the context.

#



# Check for switch () and associated case and default

# statements should be at the same indent.

~/\bswitch\s*\(.*\)/) {

			my $err = '';

 '';

			my @ctx = ctx_block_outer($linenr, $realcnt);

			shift(@ctx);

			for my $ctx (@ctx) {

 line_stats($ctx);

				if ($ctx =~ /^\+\s*(case\s+|default:)/ &&

 $cindent) {

					$err .= "$sep$ctx\n";

 '';

					$sep = "[...]\n";

				}

			}

			if ($err ne '') {

				ERROR("SWITCH_CASE_INDENT_LEVEL",

				      "switch and case should be at the same indent\n$hereline$err");

			}

		}



# if/while/etc brace do not go on next line, unless defining a do while loop,

# or if that brace on the next line is for something else

/) {

			my $pre_ctx = "$1$2";



 ctx_statement_level($linenr, $realcnt, 0);

			if ($line =~ /^\+\t{6,}/) {

				WARN("DEEP_INDENTATION",

				     "Too many leading tabs - consider code refactoring\n" . $herecurr);

			}



ctx - 1;

			my $ctx = join("\n", @ctx);



 $linenr;

			my $ctx_skip = $realcnt;



			while ($ctx_skip > $ctx_cnt || ($ctx_skip == $ctx_cnt &&

					defined $lines[$ctx_ln - 1] &&

~ /^-/)) {

print "realcnt<$realcnt> ctx_cnt<$ctx_cnt>\n";

print "pre<$pre_ctx>\nline<$line>\nctx<$ctx>\nnext<$lines[$ctx_ln - 1]>\n";

			if ($ctx !~ /{\s*/ && defined($lines[$ctx_ln - 1]) && $lines[$ctx_ln - 1] =~ /^\+\s*{/) {

				ERROR("OPEN_BRACE",

				      "that open brace { should be on the previous line\n" .

					"$here\n$ctx\n$rawlines[$ctx_ln - 1]\n");

			}

			if ($level == 0 && $pre_ctx !~ /}\s*while\s*\($/ &&

~ /\)\s*\;\s*$/ &&

				my ($nlength, $nindent) = line_stats($lines[$ctx_ln - 1]);

				if ($nindent > $indent) {

					WARN("TRAILING_SEMICOLON",

					     "trailing semicolon indicates no statements, indent implies otherwise\n" .

						"$here\n$ctx\n$rawlines[$ctx_ln - 1]\n");

				}

			}

		}



# Check relative indent for conditionals and blocks.

/ && $line !~ /\}\s*while\s*/) {

			($stat, $cond, $line_nr_next, $remain_next, $off_next) =

				ctx_statement_block($linenr, $realcnt, 0)

					if (!defined $stat);

 ($stat, $cond);

 remove inline comments

			$s =~ s/$;/ /g;

~ s/$;/ /g;

 Find out how long the conditional actually is.

 ($c 
			my $cond_lines = 1 + $#newlines;



			# Make sure we remove the line prefixes as we have

			# none on the first line, and are going to readd them

			# where necessary.

~ s/\n./\n/gs;

			while ($s =~ /\n\s+\\\n/) {

				$cond_lines += $s =~ s/\n\s+\\\n/\n/g;

			}



			# We want to check the first line inside the block

			# starting at the end of the conditional, so remove:

			#  1) any blank line termination

			#  2) any opening brace { on end of the line

			#  3) any do (...) {

 0;

			my $check = 0;

~ s/^.*\bdo\b//;

			$s =~ s/^\s*{//;

~ s/^\s*\\//) {

				$continuation = 1;

			}

~ s/^\s*?\n//) {

				$check = 1;

				$cond_lines++;

			}



			# Also ignore a loop construct at the end of a

			# preprocessor statement.

\s*define\s/ ||

			    $prevline =~ /\\\s*$/) && $continuation == 0) {

 0;

			my $cond_ptr = -1;

 0;

			while ($cond_ptr != $cond_lines) {

 $cond_lines;

 If we see an elif then the code

 is not linear.

				if ($s =~ /^\s*\#\s*(?:else|elif)/) {

 0;

 Ignore:

  1) blank lines, they should be at 0,

  2) preprocessor lines, and

  3) labels.

				    $s =~ /^\s*?\n/ ||

\s*?/ ||

				    $s =~ /^\s*$Ident\s*:/) {

					$continuation = ($s =~ /^.*?\\\n/) ? 1 : 0;

~ s/^.*?\n//) {

			my (undef, $sindent) = line_stats("+" . $s);

 raw_line($linenr, $cond_lines);

 Check if either of these lines are modified, else

 this is not this patch's fault.

				$check = 0;

			}

			if (defined($stat_real) && $cond_lines > 1) {

 "[...]\n$stat_real";

print "line<$line> prevline<$prevline> indent<$indent> sindent<$sindent> check<$check> continuation<$continuation> s<$s> cond_lines<$cond_lines> stat_real<$stat_real> stat<$stat>\n";

			    (($sindent % $tabsize) != 0 ||

			     ($sindent < $indent) ||

			     ($sindent == $indent &&

			      ($s !~ /^\s*(?:\}|\{|else\b)/)) ||

			     ($sindent > $indent + $tabsize))) {

				WARN("SUSPECT_CODE_INDENT",

				     "suspect code indent for conditional statements ($indent, $sindent)\n" . $herecurr . "$stat_real\n");

			}

		}



		# Track the 'values' across context and added lines.

		my $opline = $line; $opline =~ s/^./ /;



		$curr_values = $prev_values . $curr_values;

		if ($dbg_values) {

			my $outline = $opline; $outline =~ s/\t/ /g;

			print "$linenr > .$outline\n";

			print "$linenr > $curr_values\n";

			print "$linenr >  $curr_vars\n";

		}

 substr($curr_values, -1);

ignore lines not being added

		next if ($line =~ /^[^\+]/);



# check for self assignments used to avoid compiler warnings

# e.g.:	int foo = foo, *bar = NULL;

	struct foo bar = *(&(bar));

~ /^\+\s*(?:$Declare)?([A-Za-z_][A-Za-z\d_]*)\s*
			my $var = $1;

			if ($line =~ /^\+\s*(?:$Declare)?$var\s*=\s*(?:$var|\*\s*\(?\s*&\s*\(?\s*$var\s*\)?\s*\)?)\s*[;,]/) {

				WARN("SELF_ASSIGNMENT",

				     "Do not use self-assignments to avoid compiler warnings\n" . $herecurr);

			}

		}



# check for dereferences that span multiple lines

~ /^\+.*$Lval\s*(?:\.|->)\s*$/ &&

		    $line =~ /^\+\s*(?!\#\s*(?!define\s+|if))\s*$Lval/) {

~ /($Lval\s*(?:\.|->))\s*$/;

			my $ref = $1;

~ /^.\s*($Lval)/;

			$ref .= $1;

~ s/\s//g;

 check for declarations of signed or unsigned without int

~ m{\b($Declare)\s*(?!char\b|short\b|int\b|long\b)\s*($Ident)?\s*[
			my $type = $1;

 $2;

			$var = "" if (!defined $var);

~ /^(?:(?:$Storage|$Inline|$Attribute)\s+)*((?:un)?signed)((?:\s*\*)*)\s*$/) {

				my $sign = $1;

 $2;

				$pointer = "" if (!defined $pointer);



				if (WARN("UNSPECIFIED_INT",

					 "Prefer '" . trim($sign) . " int" . rtrim($pointer) . "' to bare use of '$sign" . rtrim($pointer) . "'\n" . $herecurr) &&

				    $fix) {

 trim($sign) . " int ";

					my $comp_pointer = $pointer;

~ s/\s//g;

					$decl .= $comp_pointer;

 rtrim($decl) if ($var eq "");

					$fixed[$fixlinenr] =~ s@\b$sign\s*\Q$pointer\E\s*$var\b@$decl$var@;

				}

			}

		}



# TEST: allow direct testing of the type matcher.

		if ($dbg_type) {

~ /^.\s*$Declare\s*$/) {

			} elsif ($dbg_type > 1 && $line =~ /^.+($Declare)/) {

				ERROR("TEST_NOT_TYPE",

				      "TEST: is not type ($1 is)\n". $herecurr);

			}

			next;

		}

# TEST: allow direct testing of the attribute matcher.

		if ($dbg_attr) {

~ /^.\s*$Modifier\s*$/) {

			} elsif ($dbg_attr > 1 && $line =~ /^.+($Modifier)/) {

				ERROR("TEST_NOT_ATTR",

				      "TEST: is not attr ($1 is)\n". $herecurr);

			}

			next;

		}



# check for initialisation to aggregates open brace on the next line

~ /^.\s*{/ &&

		    $prevline =~ /(?:^|[^=])=\s*$/) {

			if (ERROR("OPEN_BRACE",

				  "that open brace { should be on the previous line\n" . $hereprev) &&

			    $fix && $prevline =~ /^\+/ && $line =~ /^\+/) {

				fix_delete_line($fixlinenr - 1, $prevrawline);

				fix_delete_line($fixlinenr, $rawline);

 $prevrawline;

				$fixedline =~ s/\s*=\s*$/ = {/;

				fix_insert_line($fixlinenr, $fixedline);

 $line;

				$fixedline =~ s/^(.\s*)\{\s*/$1/;

				fix_insert_line($fixlinenr, $fixedline);

			}

		}



#

# Checks which are anchored on the added line.

#



# check for malformed paths in #include statements (uses RAW line)

\s*include\s+[<"](.*)[">]}) {

			my $path = $1;

~ m{//}) {

include filename\n" . $herecurr);

~ "^uapi/" && $realfile 
include in ...include/uapi/... should use a uapi/ path prefix\n" . $herecurr);

 no C99 // comments

		if ($line =~ m{//}) {

			if (ERROR("C99_COMMENTS",

				  "do not use C99 // comments\n" . $herecurr) &&

			    $fix) {

 $fixed[$fixlinenr];

				if ($line =~ /\/\/(.*)$/) {

 trim($1);

					$fixed[$fixlinenr] =~ s@\/\/(.*)$@/\* $comment \*/@;

				}

			}

		}

		# Remove C99 comments.

~ s@//.*@@;

		$opline =~ s@//.*@@;



# EXPORT_SYMBOL should immediately follow the thing it is exporting, consider

# the whole statement.

#print "APW <$lines[$realline_next - 1]>\n";

		if (defined $realline_next &&

		    exists $lines[$realline_next - 1] &&

		    !defined $suppress_export{$realline_next} &&

~ /EXPORT_SYMBOL.*\((.*)\)/)) {

 Handle definitions which produce identifiers with

 a prefix:

   XXX(foo);

   EXPORT_SYMBOL(something_foo);

			my $name = $1;

~ s/^\s*($Ident).*/$1/;

			if ($stat =~ /^(?:.\s*}\s*\n)?.([A-Z_]+)\s*\(\s*($Ident)/ &&

~ /^${Ident}_$2/) {

print "FOO C name<$name>\n";

				$suppress_export{$realline_next} = 1;



			} elsif ($stat !~ /(?:

				\n.}\s*$|

				^.DEFINE_$Ident\(\Q$name\E\)|

				^.DECLARE_$Ident\(\Q$name\E\)|

				^.LIST_HEAD\(\Q$name\E\)|

				^.(?:$Storage\s+)?$Type\s*\(\s*\*\s*\Q$name\E\s*\)\s*\(|

|\[|\()

print "FOO A<$lines[$realline_next - 1]> stat<$stat> name<$name>\n";

				$suppress_export{$realline_next} = 2;

			} else {

 1;

		    $prevline =~ /^.\s*$/ &&

~ /EXPORT_SYMBOL.*\((.*)\)/)) {

print "FOO B <$lines[$linenr - 1]>\n";

			$suppress_export{$linenr} = 2;

		}

		if (defined $suppress_export{$linenr} &&

		    $suppress_export{$linenr} == 2) {

			WARN("EXPORT_SYMBOL",

			     "EXPORT_SYMBOL(foo); should immediately follow its function/variable\n" . $herecurr);

		}



# check for global initialisers.

		if ($line =~ /^\+$Type\s*$Ident(?:\s+$Modifier)*\s*=\s*($zero_initializer)\s*;/ &&

		    !exclude_global_initialisers($realfile)) {

			if (ERROR("GLOBAL_INITIALISERS",

				  "do not initialise globals to $1\n" . $herecurr) &&

			    $fix) {

				$fixed[$fixlinenr] =~ s/(^.$Type\s*$Ident(?:\s+$Modifier)*)\s*=\s*$zero_initializer\s*;/$1;/;

			}

		}

# check for static initialisers.

		if ($line =~ /^\+.*\bstatic\s.*=\s*($zero_initializer)\s*;/) {

			if (ERROR("INITIALISED_STATIC",

				  "do not initialise statics to $1\n" .

				      $herecurr) &&

			    $fix) {

				$fixed[$fixlinenr] =~ s/(\bstatic\s.*?)\s*=\s*$zero_initializer\s*;/$1;/;

			}

		}



# check for misordered declarations of char/short/int/long with signed/unsigned

~ m{(\b$TypeMisordered\b)}g) {

			my $tmp = trim($1);

			WARN("MISORDERED_TYPE",

			     "type '$tmp' should be specified in [[un]signed] [short|int|long|long long] order\n" . $herecurr);

		}



# check for unnecessary <signed> int declarations of short/long/long long

~ m{\b($TypeMisordered(\s*\*)*|$C90_int_types)\b}g) {

			my $type = trim($1);

			next if ($type !~ /\bint\b/);

			next if ($type !~ /\b(?:short|long\s+long|long)\b/);

 $type;

			$new_type =~ s/\b\s*int\s*\b/ /;

~ s/\b\s*(?:un)?signed\b\s*/ /;

			$new_type =~ s/^const\s+//;

			$new_type = "unsigned $new_type" if ($type =~ /\bunsigned\b/);

			$new_type = "const $new_type" if ($type =~ /^const\b/);

~ s/\s+/ /g;

			$new_type = trim($new_type);

			if (WARN("UNNECESSARY_INT",

				 "Prefer '$new_type' over '$type' as the int is unnecessary\n" . $herecurr) &&

			    $fix) {

~ s/\b\Q$type\E\b/$new_type/;

 check for static const char * arrays.

~ /\bstatic\s+const\s+char\s*\*\s*(\w+)\s*\[\s*\]\s*
 check for initialized const char arrays that should be static const

~ /^\+\s*const\s+(char|unsigned\s+char|_*u8|(?:[us]_)?int8_t)\s+\w+\s*\[\s*(?:\w+\s*)?\]\s*
				$fixed[$fixlinenr] =~ s/(^.\s*)const\b/${1}static const/;

			}

		}



 check for static char foo[] = "bar" declarations.

~ /\bstatic\s+char\s+(\w+)\s*\[\s*\]\s*
 check for const <foo> const where <foo> is not a pointer or array type

		if ($sline =~ /\bconst\s+($BasicType)\s+const\b/) {

 $1;

			if ($sline =~ /\bconst\s+\Q$found\E\s+const\b\s*\*/) {

				WARN("CONST_CONST",

				     "'const $found const *' should probably be 'const $found * const'\n" . $herecurr);

			} elsif ($sline !~ /\bconst\s+\Q$found\E\s+const\s+\w+\s*\[/) {

				WARN("CONST_CONST",

				     "'const $found const' should probably be 'const $found'\n" . $herecurr);

			}

		}



# check for const static or static <non ptr type> const declarations

# prefer 'static const <foo>' over 'const static <foo>' and 'static <foo> const'

~ /^\+\s*const\s+static\s+($Type)\b/ ||

		    $sline =~ /^\+\s*static\s+($BasicType)\s+const\b/) {

			if (WARN("STATIC_CONST",

				 "Move const after static - use 'static const $1'\n" . $herecurr) &&

			    $fix) {

~ s/\bconst\s+static\b/static const/;

				$fixed[$fixlinenr] =~ s/\bstatic\s+($BasicType)\s+const\b/static const $1/;

			}

		}



 check for non-global char *foo[] = {"bar", ...} declarations.

~ /^.\s+(?:static\s+|const\s+)?char\s+\*\s*\w+\s*\[\s*\]\s*
 check for sizeof(foo)/sizeof(foo[0]) that could be ARRAY_SIZE(foo)

		if ($line =~ m@\bsizeof\s*\(\s*($Lval)\s*\)@) {

 $1;

			if ($line =~ m@\b(sizeof\s*\(\s*\Q$array\E\s*\)\s*/\s*sizeof\s*\(\s*\Q$array\E\s*\[\s*0\s*\]\s*\))@) {

 $1;

					$fixed[$fixlinenr] =~ s/\Q$array_div\E/ARRAY_SIZE($array)/;

				}

			}

		}



# check for function declarations without arguments like "int foo()"

~ /(\b$Type\s*$Ident)\s*\(\s*\)/) {

				$fixed[$fixlinenr] =~ s/(\b($Type)\s+($Ident))\s*\(\s*\)/$2 $3(void)/;

			}

		}



# check for new typedefs, only function parameters and sparse annotations

# make sense.

~ /\btypedef\s/ &&

 * goes on variable not on type

 (char*[ const])

		while ($line =~ m{(\($NonptrType(\s*(?:$Modifier\b\s*|\*\s*)+)\))}g) {

			#print "AA<$1>\n";

 ($1, $2, $2);

 Should start with a space.

			$to =~ s/^(\S)/ $1/;

			# Should not end with a space.

~ s/\s+$//;

 '*'s should not have spaces between.

			while ($to =~ s/\*\s+\*/\*\*/) {

			}



##			print "1: from<$from> to<$to> ident<$ident>\n";

			if ($from ne $to) {

				if (ERROR("POINTER_LOCATION",

					  "\"(foo$from)\" should be \"(foo$to)\"\n" .  $herecurr) &&

				    $fix) {

 $ident;

					my $sub_to = $ident;

~ s/\Q$from\E/$to/;

					$fixed[$fixlinenr] =~

					    s@\Q$sub_from\E@$sub_to@;

				}

			}

		}

~ m{(\b$NonptrType(\s*(?:$Modifier\b\s*|\*\s*)+)($Ident))}g) {

print "BB<$1>\n";

			my ($match, $from, $to, $ident) = ($1, $2, $2, $3);



			# Should start with a space.

~ s/^(\S)/ $1/;

 Should not end with a space.

			$to =~ s/\s+$//;

			# '*'s should not have spaces between.

~ s/\*\s+\*/\*\*/) {

 Modifiers should have spaces.

			$to =~ s/(\b$Modifier$)/$1 /;



##			print "2: from<$from> to<$to> ident<$ident>\n";

			if ($from ne $to && $ident !~ /^$Modifier$/) {

				if (ERROR("POINTER_LOCATION",

					  "\"foo${from}bar\" should be \"foo${to}bar\"\n" .  $herecurr) &&

				    $fix) {



 $match;

					my $sub_to = $match;

~ s/\Q$from\E/$to/;

					$fixed[$fixlinenr] =~

					    s@\Q$sub_from\E@$sub_to@;

				}

			}

		}



# avoid BUG() or BUG_ON()

~ /\b(?:BUG|BUG_ON)\b/) {

			my $msg_level = \&WARN;

 \&CHK if ($file);

 avoid LINUX_VERSION_CODE

		if ($line =~ /\bLINUX_VERSION_CODE\b/) {

			WARN("LINUX_VERSION_CODE",

			     "LINUX_VERSION_CODE should be avoided, code should be for the version to which it is merged\n" . $herecurr);

		}



# check for uses of printk_ratelimit

~ /\bprintk_ratelimit\s*\(/) {

 printk should use KERN_* levels

		if ($line =~ /\bprintk\s*\(\s*(?!KERN_[A-Z]+\b)/) {

			WARN("PRINTK_WITHOUT_KERN_LEVEL",

			     "printk() should include KERN_<LEVEL> facility level\n" . $herecurr);

		}



# prefer variants of (subsystem|netdev|dev|pr)_<level> to printk(KERN_<LEVEL>

~ /\b(printk(_once|_ratelimited)?)\s*\(\s*KERN_([A-Z]+)/) {

			my $printk = $1;

 $2;

			my $orig = $3;

 "" if (!defined($modifier));

			my $level = lc($orig);

 "warn" if ($level eq "warning");

			my $level2 = $level;

 "dbg" if ($level eq "debug");

			$level .= $modifier;

 $modifier;

 prefer dev_<level> to dev_printk(KERN_<LEVEL>

		if ($line =~ /\bdev_printk\s*\(\s*KERN_([A-Z]+)/) {

 $1;

			my $level = lc($orig);

 "warn" if ($level eq "warning");

			$level = "dbg" if ($level eq "debug");

			WARN("PREFER_DEV_LEVEL",

			     "Prefer dev_$level(... to dev_printk(KERN_$orig, ...\n" . $herecurr);

		}



# trace_printk should not be used in production code.

~ /\b(trace_printk|trace_puts|ftrace_vprintk)\s*\(/) {

 ENOSYS means "bad syscall nr" and nothing else.  This will have a small

 number of false positives, but assembly files are not checked, so at

 least the arch entry code will not trigger this warning.

		if ($line =~ /\bENOSYS\b/) {

			WARN("ENOSYS",

			     "ENOSYS means 'invalid syscall nr' and nothing else\n" . $herecurr);

		}



# ENOTSUPP is not a standard error code and should be avoided in new patches.

# Folks usually mean EOPNOTSUPP (also called ENOTSUP), when they type ENOTSUPP.

# Similarly to ENOSYS warning a small number of false positives is expected.

~ /\bENOTSUPP\b/) {

				$fixed[$fixlinenr] =~ s/\bENOTSUPP\b/EOPNOTSUPP/;

			}

		}



# function brace can't be on same line, except for #defines of do while,

# or if closed on same line

		if ($perl_version_ok &&

~ /$Type\s*$Ident\s*$balanced_parens\s*\{/ &&

\s*define\b.*do\s*\{/ &&

				my $fixed_line = $rawline;

~ /(^..*$Type\s*$Ident\(.*\)\s*)\{(.*)$/;

				my $line1 = $1;

 $2;

 open braces for enum, union and struct go on the same line.

		if ($line =~ /^.\s*{/ &&

~ /^.\s*(?:typedef\s+)?(enum|union|struct)(?:\s+$Ident)?\s*$/) {

~ /^\+/ && $line 
				my $fixedline = rtrim($prevrawline) . " {";

				fix_insert_line($fixlinenr, $fixedline);

 $rawline;

				$fixedline =~ s/^(.\s*)\{\s*/$1\t/;

				if ($fixedline !~ /^\+\s*$/) {

					fix_insert_line($fixlinenr, $fixedline);

				}

			}

		}



# missing space after union, struct or enum definition

		if ($line =~ /^.\s*(?:typedef\s+)?(enum|union|struct)(?:\s+$Ident){1,2}[=\{]/) {

			if (WARN("SPACING",

				 "missing space after $1 definition\n" . $herecurr) &&

			    $fix) {

~

				    s/^(.\s*(?:typedef\s+)?(?:enum|union|struct)(?:\s+$Ident){1,2})([=\{])/$1 $2/;

			}

		}



# Function pointer declarations

# check spacing between type, funcptr, and args

# canonical declaration is "type (*funcptr)(args...)"

~ /^.\s*($Declare)\((\s*)\*(\s*)($Ident)(\s*)\)(\s*)\(/) {

			my $declare = $1;

 $2;

			my $post_pointer_space = $3;

 $4;

			my $post_funcname_space = $5;

 $6;

 the $Declare variable will capture all spaces after the type

 so check it for a missing trailing missing space but pointer return types

 don't need a space so don't warn for those.

			my $post_declare_space = "";

~ /(\s+)$/) {

				$post_declare_space = $1;

 rtrim($declare);

			if ($declare !~ /\*$/ && $post_declare_space =~ /^$/) {

				WARN("SPACING",

				     "missing space after return type\n" . $herecurr);

 " ";

 unnecessary space "type  (*funcptr)(args...)"

 This test is not currently implemented because these declarations are

 equivalent to

	int  foo(int bar, ...)

 and this is form shouldn't/doesn't generate a checkpatch warning.



#			elsif ($declare =~ /\s{2,}$/) {

#				WARN("SPACING",

#				     "Multiple spaces after return type\n" . $herecurr);

#			}



# unnecessary space "type ( *funcptr)(args...)"

			if (defined $pre_pointer_space &&

~ /^\s/) {

 unnecessary space "type (* funcptr)(args...)"

			    $post_pointer_space =~ /^\s/) {

				WARN("SPACING",

				     "Unnecessary space before function pointer name\n" . $herecurr);

			}



# unnecessary space "type (*funcptr )(args...)"

			if (defined $post_funcname_space &&

~ /^\s/) {

 unnecessary space "type (*funcptr) (args...)"

			    $pre_args_space =~ /^\s/) {

				WARN("SPACING",

				     "Unnecessary space before function pointer arguments\n" . $herecurr);

			}



			if (show_type("SPACING") && $fix) {

~

 check for spacing round square brackets; allowed:

  1. with a type on the left -- int [] a;

#  2. at the beginning of a line for slice initialisers -- [0...10] = 5,

#  3. inside a curly brace -- = { [0...10] = 5 }

~ /(.*?\s)\[/g) {

			my ($where, $prefix) = ($-[1], $1);

			if ($prefix !~ /$Type\s+$/ &&

 0 || $prefix !~ /^.\s+$/) &&

				    $fixed[$fixlinenr] =~

					s/^(\+.*?)\s+\[/$1\[/;

				}

			}

		}



# check for spaces between functions and their parentheses.

~ /($Ident)\s+\(/g) {

			my $name = $1;

 substr($line, 0, $-[1]);

			my $ctx = "$ctx_before$name";



			# Ignore those directives where spaces _are_ permitted.

~ /^(?:

 cpp 
 if there is a space between the name and the open

 parenthesis it is simply not a parameter group.

			} elsif ($ctx_before =~ /^.\s*\#\s*define\s*$/) {



			# cpp #elif statement condition may start with a (

\s*elif\s*$/) {

 If this whole things ends with a type its most

 likely a typedef for a function.

			} elsif ($ctx =~ /$Type$/) {



			} else {

				if (WARN("SPACING",

					 "space prohibited between function name and open parenthesis '('\n" . $herecurr) &&

					     $fix) {

~

 Check operator spacing.

		if (!($line=~/\#\s*include/)) {

 "";

			my $line_fixed = 0;



 qr{

				<<=|>>=|<=|>=|==|!=|

				\+=|-=|\*=|\/=|%=|\^=|\|=|&=|

				=>|->|<<|>>|<|>|=|!|~|

				&&|\|\||,|\^|\+\+|--|&|\||\+|-|\*|\/|%|

				\?:|\?|:

			}x;

 split(/($ops|;)/, $opline);

elements . ">\n");

			my @fix_elements = ();

 0;

				$off += length($el);

			}



 0;

			my $blank = copy_spacing($opline);

 -1;

elements; $n += 2) {
 2) {

				my $good = $fix_elements[$n] . $fix_elements[$n + 1];



##				print("n: <$n> good: <$good>\n");



 length($elements[$n]);

 Pick up the preceding and succeeding characters.

				my $ca = substr($opline, 0, $off);

 '';

				if (length($opline) >= ($off + length($elements[$n + 1]))) {

 substr($opline, $off + length($elements[$n + 1]));

				my $cb = "$ca$;$cc";



 '';

				$a = 'V' if ($elements[$n] ne '');

				$a = 'W' if ($elements[$n] =~ /\s$/);

				$a = 'C' if ($elements[$n] =~ /$;$/);

				$a = 'B' if ($elements[$n] =~ /(\[|\()$/);

 'O' if ($elements[$n] eq '');

 'E' if ($ca 
				my $op = $elements[$n + 1];



 '';

					$c = 'V' if ($elements[$n + 2] ne '');

					$c = 'W' if ($elements[$n + 2] =~ /^\s/);

					$c = 'C' if ($elements[$n + 2] =~ /^$;/);

					$c = 'B' if ($elements[$n + 2] =~ /^(\)|\]|;)/);

 'O' if ($elements[$n + 2] eq '');

 'E' if ($elements[$n + 2] 
					$c = 'E';

				}



 "${a}x${c}";

				my $at = "(ctx:$ctx)";



 substr($blank, 0, $off) . "^";

				my $hereptr = "$hereline$ptr\n";



				# Pull out the value of this operator.

 substr($curr_values, $off + 1, 1);

 Get the full operator variant.

				my $opv = $op . substr($curr_vars, $off, 1);



				# Ignore operators passed as parameters.

				if ($op_type ne 'V' &&

				    $ca =~ /\s$/ && $cc =~ /^\s*[,\)]/) {



#				# Ignore comments

				} elsif ($op =~ /^$;+$/) {

 ; should have either the end of line or a space or \ after it

							$good = $fix_elements[$n] . trim($fix_elements[$n + 1]) . " ";

 1;

 // is a comment

   :   when part of a bitfield

 skip the bitfield test for now

 No spaces for:

   ->

					if ($ctx =~ /Wx.|.xW/) {

						if (ERROR("SPACING",

							  "spaces prohibited around that '$op' $at\n" . $hereptr)) {

 rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);

								$fix_elements[$n + 2] =~ s/^\s+//;

							}

 1;

 , must not have a space before and must have a space on the right.

					my $rtrim_before = 0;

 0;

					if ($ctx =~ /Wx./) {

						if (ERROR("SPACING",

							  "space prohibited before that '$op' $at\n" . $hereptr)) {

 1;

							$rtrim_before = 1;

						}

					}

					if ($ctx !~ /.x[WEC]/ && $cc !~ /^}/) {

						if (ERROR("SPACING",

							  "space required after that '$op' $at\n" . $hereptr)) {

 1;

							$last_after = $n;

 1;

							$good = rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);

						} else {

 $fix_elements[$n] . trim($fix_elements[$n + 1]);

							$good .= " ";

						}

					}



				# '*' as part of a type definition -- reported already.

				} elsif ($opv eq '*_') {

					#warn "'*' is part of type\n";



				# unary operators should have a space before and

				# none after.  May be left adjacent to another

				# unary operator, or a cast

				} elsif ($op eq '!' || $op eq '~' ||

					 $opv eq '*U' || $opv eq '-U' ||

					 $opv eq '&U' || $opv eq '&&U') {

					if ($ctx !~ /[WEBC]x./ && $ca !~ /(?:\)|!|~|\*|-|\&|\||\+\+|\-\-|\{)$/) {

						if (ERROR("SPACING",

							  "space required before that '$op' $at\n" . $hereptr)) {

 $last_after + 2) {

								$good = $fix_elements[$n] . " " . ltrim($fix_elements[$n + 1]);

 1;

					if ($op eq '*' && $cc =~/\s*$Modifier\b/) {

						# A unary '*' may be const



~ /.xW/) {

							$good = $fix_elements[$n] . rtrim($fix_elements[$n + 1]);

							if (defined $fix_elements[$n + 2]) {

~ s/^\s+//;

							$line_fixed = 1;

						}

					}



				# unary ++ and unary -- are allowed no space on one side.

				} elsif ($op eq '++' or $op eq '--') {

					if ($ctx !~ /[WEOBC]x[^W]/ && $ctx !~ /[^W]x[WOBEC]/) {

						if (ERROR("SPACING",

							  "space required one side of that '$op' $at\n" . $hereptr)) {

 $fix_elements[$n] . trim($fix_elements[$n + 1]) . " ";

							$line_fixed = 1;

						}

					}

~ /Wx[BE]/ ||

~ /Wx./ && $cc 
							$good = rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);

 1;

					if ($ctx =~ /ExW/) {

						if (ERROR("SPACING",

							  "space prohibited after that '$op' $at\n" . $hereptr)) {

 $fix_elements[$n] . trim($fix_elements[$n + 1]);

								$fix_elements[$n + 2] =~ s/^\s+//;

							}

 1;

 << and >> may either have or not have spaces both sides

								$good = rtrim($fix_elements[$n]) . " " . trim($fix_elements[$n + 1]) . " ";

~ s/^\s+//;

								$line_fixed = 1;

							}

						} elsif (!defined $fix_elements[$n + 2] && $ctx !~ /Wx[OE]/) {

							if (CHK("SPACING",

								"space preferred before that '$op' $at\n" . $hereptr)) {

 rtrim($fix_elements[$n]) . " " . trim($fix_elements[$n + 1]);

								$line_fixed = 1;

							}

						}

~ /Wx[^WCE]|[^WCE]xW/) {

							$good = rtrim($fix_elements[$n]) . " " . trim($fix_elements[$n + 1]) . " ";

							if (defined $fix_elements[$n + 2]) {

~ s/^\s+//;

							$line_fixed = 1;

						}

					}



				# A colon needs no spaces before when it is

				# terminating a case value or a label.

				} elsif ($opv eq ':C' || $opv eq ':L') {

~ /Wx./ and $realfile !~ m@.*\.lds\.h$@) {

							$good = rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);

 1;

 All the others need spaces both sides.

					my $ok = 0;



					# Ignore email addresses <foo@bar>

					if (($op eq '<' &&

~ /^\S+\@\S+>/) ||

					     $ca =~ /<\S+\@\S+$/))

					{

 1;

 for asm volatile statements

 ignore a colon with another

 colon immediately before or after

~ /:$/ || $cc 
						$ok = 1;

					}



					# messages are ERROR, but ?: are CHK

					if ($ok == 0) {

 \&ERROR;

 \&CHK if (($op eq '?:' || $op eq '?' || $op eq ':') && $ctx 
							$good = rtrim($fix_elements[$n]) . " " . trim($fix_elements[$n + 1]) . " ";

							if (defined $fix_elements[$n + 2]) {

~ s/^\s+//;

							$line_fixed = 1;

						}

					}

				}

 length($elements[$n + 1]);

				$fixed_line = $fixed_line . $good;

			}



			if (($#elements % 2) == 0) {

elements];

				$fixed[$fixlinenr] = $fixed_line;

			}





		}



# check for whitespace before a non-naked semicolon

~ /^\+.*\S\s+;\s*$/) {

				1 while $fixed[$fixlinenr] =~

				    s/^(\+.*\S)\s+;/$1;/;

			}

		}



# check for multiple assignments

		if ($line =~ /^.\s*$Lval\s*=\s*$Lval\s*=(?!=)/) {

			CHK("MULTIPLE_ASSIGNMENTS",

			    "multiple assignments should be avoided\n" . $herecurr);

		}



## # check for multiple declarations, allowing for a function declaration

## # continuation.

## 		if ($line =~ /^.\s*$Type\s+$Ident(?:\s*=[^,{]*)?\s*,\s*$Ident.*/ &&

[^,{]*)?\s*,\s*$Type\s*$Ident.*/) {

 Remove any bracketed sections to ensure we do not

 falsely report the parameters of functions.

## 			my $ln = $line;

~ s/\([^\(\)]*\)//g) {

## 			if ($ln =~ /,/) {

## 				WARN("MULTIPLE_DECLARATION",

##				     "declaring multiple variables together should be avoided\n" . $herecurr);

## 			}

## 		}



#need space before brace following if, while, etc

~ /\(.*\)\{/ && $line !~ /\($Type\)\{/) ||

		    $line =~ /\b(?:else|do)\{/) {

			if (ERROR("SPACING",

				  "space required before the open brace '{'\n" . $herecurr) &&

			    $fix) {

~ s/^(\+.*(?:do|else|\)))\{/$1 {/;

 check for blank lines before declarations

~ /^.\t+$Type\s+$Ident(?:\s*
##		    $prevrawline =~ /^.\s*$/) {

##			WARN("SPACING",

##			     "No blank lines before declarations\n" . $hereprev);

##		}

##



# closing brace should have a space following it when it has anything

# on the line

~ /}(?!(?:,|;|\)|\}))\S/) {

				$fixed[$fixlinenr] =~

				    s/}((?!(?:,|;|\)))\S)/} $1/;

			}

		}



# check spacing on square brackets

~ /\[\s/ && $line !~ /\[\s*$/) {

				$fixed[$fixlinenr] =~

				    s/\[\s+/\[/;

			}

		}

~ /\s\]/) {

				$fixed[$fixlinenr] =~

				    s/\s+\]/\]/;

			}

		}



# check spacing on parentheses

~ /\(\s/ && $line !~ /\(\s*(?:\\)?$/ &&

				$fixed[$fixlinenr] =~

				    s/\(\s+/\(/;

			}

		}

~ /(\s+)\)/ && $line !~ /^.\s*\)/ &&

				$fixed[$fixlinenr] =~

				    s/\s+\)/\)/;

			}

		}



# check unnecessary parentheses around addressof/dereference single $Lvals

# ie: &(foo->bar) should be &foo->bar and *(foo->bar) should be *foo->bar



~ /(?:[^&]&\s*|\*)\(\s*($Ident\s*(?:$Member\s*)+)\s*\)/g) {

			my $var = $1;

			if (CHK("UNNECESSARY_PARENTHESES",

				"Unnecessary parentheses around $var\n" . $herecurr) &&

			    $fix) {

~ s/\(\s*\Q$var\E\s*\)/$var/;

 check for unnecessary parentheses around function pointer uses

 ie: (foo->bar)(); should be foo->bar();

 but not "if (foo->bar) (" to avoid some false positives

		if ($line =~ /(\bif\s*|)(\(\s*$Ident\s*(?:$Member\s*)+\))[ \t]*\(/ && $1 !~ /^if/) {

 $2;

				my $var2 = deparenthesize($var);

~ s/\s//g;

				$fixed[$fixlinenr] =~ s/\Q$var\E/$var2/;

			}

		}



# check for unnecessary parentheses around comparisons in if uses

# when !drivers/staging or command-line uses --strict

		if (($realfile !~ m@^(?:drivers/staging/)@ || $check_orig) &&

		    $perl_version_ok && defined($stat) &&

~ /(^.\s*if\s*($balanced_parens))/) {

			my $if_stat = $1;

 substr($2, 1, -1);

			while ($test =~ /(?:^|[^\w\&\!\~])+\s*\(\s*([\&\!\~]?\s*$Lval\s*(?:$Compare\s*$FuncArg)?)\s*\)/g) {

 $1;

 avoid parentheses around potential macro args

				next if ($match =~ /^\s*\w+\s*$/);

				if (!defined($herectx)) {

 $here . "\n";

					my $cnt = statement_rawlines($if_stat);

 0; $n < $cnt; $n++) {

						my $rl = raw_line($linenr, $n);

  $rl . "\n";

						last if $rl =~ /^[ \+].*\{/;

					}

				}

				CHK("UNNECESSARY_PARENTHESES",

				    "Unnecessary parentheses around '$match'\n" . $herectx);

			}

		}



# check that goto labels aren't indented (allow a single space indentation)

# and ignore bitfield definitions like foo:1

# Strictly, labels can have whitespace after the identifier and before the :

# but this is not allowed here as many ?: uses would appear to be labels

~ /^.\s+[A-Za-z_][A-Za-z\d_]*:(?!\s*\d+)/ &&

				$fixed[$fixlinenr] =~

				    s/^(.)\s+/$1/;

			}

		}



# check if a statement with a comma should be two statements like:

	foo = bar(),	/* comma should be semicolon */

#	bar = baz();

		if (defined($stat) &&

~ /^\+\s*(?:$Lval\s*$Assignment\s*)?$FuncArg\s*,\s*(?:$Lval\s*$Assignment\s*)?$FuncArg\s*;\s*$/) {

			my $cnt = statement_rawlines($stat);

 get_stat_here($linenr, $cnt, $here);

 return is not a function

		if (defined($stat) && $stat =~ /^.\s*return(\s*)\(/s) {

 $1;

			    $stat =~ /^.\s*return\s*($balanced_parens)\s*;\s*$/) {

 $1;

				$value = deparenthesize($value);

~ m/^\s*$FuncArg\s*(?:\?|$)/) {

 unnecessary return in a void function

 at end-of-function, with the previous line a single leading tab, then return;

 and the line before that not a goto label target like "out:"

		if ($sline =~ /^[ \+]}\s*$/ &&

~ /^\+\treturn\s*;\s*$/ &&

		    $linenr >= 3 &&

~ /^[ +]/ &&

 if statements using unnecessary parentheses - ie: if ((foo == bar))
 bar))

		    $line =~ /\bif\s*((?:\(\s*){2,})/) {

 $1;

 $openparens 
			my $msg = "";

~ /\bif\s*(?:\(\s*){$count,$count}$LvalOrFunc\s*($Compare)\s*$LvalOrFunc(?:\s*\)){$count,$count}/) {

				my $comp = $4;	#Not $1 because of $LvalOrFunc

				$msg = " - maybe == should be = ?" if ($comp eq "==");

				WARN("UNNECESSARY_PARENTHESES",

				     "Unnecessary parentheses$msg\n" . $herecurr);

			}

		}



# comparisons with a constant or upper case identifier on the left

#	avoid cases like "foo + BAR < baz"

#	only fix matches surrounded by parentheses to avoid incorrect

#	conversions like "FOO < baz() + 5" being "misfixed" to "baz() > FOO + 5"

		if ($perl_version_ok &&

~ /^\+(.*)\b($Constant|[A-Z_][A-Z0-9_]*)\s*($Compare)\s*($LvalOrFunc)/) {

			my $lead = $1;

 $2;

			my $comp = $3;

 $4;

			my $newcomp = $comp;

			if ($lead !~ /(?:$Operators|\.)\s*$/ &&

			    $to !~ /^(?:Constant|[A-Z_][A-Z0-9_]*)$/ &&

			    WARN("CONSTANT_COMPARISON",

				 "Comparisons should place the constant on the right side of the test\n" . $herecurr) &&

			    $fix) {

				if ($comp eq "<") {

 ">";

				} elsif ($comp eq "<=") {

					$newcomp = ">=";

				} elsif ($comp eq ">") {

 "<";

				} elsif ($comp eq ">=") {

					$newcomp = "<=";

				}

~ s/\(\s*\Q$const\E\s*$Compare\s*\Q$to\E\s*\)/($to $newcomp $const)/;

 Return of what appears to be an errno should normally be negative

		if ($sline =~ /\breturn(?:\s*\(+\s*|\s+)(E[A-Z]+)(?:\s*\)+\s*|\s*)[;:,]/) {

 $1;

 Need a space before open parenthesis after if, while etc

		if ($line =~ /\b(if|while|for|switch)\(/) {

			if (ERROR("SPACING",

				  "space required before the open parenthesis '('\n" . $herecurr) &&

			    $fix) {

~

 Check for illegal assignment in if conditional -- and check for trailing

 statements after the conditional.

		if ($line =~ /do\s*(?!{)/) {



			my ($stat_next) = ctx_statement_block($line_nr_next,

						$remain_next, $off_next);

~ s/\n./\n /g;

			if ($stat_next =~ /^\s*while\b/) {

				# If the statement carries leading newlines,

				# then count those as offsets.



					($stat_next =~ /^((?:\s*\n[+-])*\s*)/s);



								$offset} = 1;

			}

		}

		if (!defined $suppress_whiletrailers{$linenr} &&

		    defined($stat) && defined($cond) &&

/) {

			my ($s, $c) = ($stat, $cond);



			if ($c =~ /\bif\s*\(.*[^<>!=]=[^=].*/s) {

				if (ERROR("ASSIGN_IN_IF",

					  "do not use assignment in if condition\n" . $herecurr) &&

				    $fix && $perl_version_ok) {

					if ($rawline =~ /^\+(\s+)if\s*\(\s*(\!)?\s*\(\s*(($Lval)\s*=\s*$LvalOrFunc)\s*\)\s*(?:($Compare)\s*($FuncArg))?\s*\)\s*(\{)?\s*$/) {

 $1;

						my $not = $2;

 $3;

						my $assigned = $4;

 $8;

						my $against = $9;

 $15;

						my $newline = "${space}if (";

 '!' if defined($not);

						$newline .= '(' if (defined $not && defined($test) && defined($against));

 "$assigned";

						$newline .= " $test $against" if (defined($test) && defined($against));

 ')' if (defined $not && defined($test) && defined($against));

						$newline .= ')';

 " {" if (defined($brace));

 Find out what is on the end of the line after the

 conditional.

			$s =~ s/\n.*//g;

 Remove any comments

 Find out how long the conditional actually is.

 ($c 
				my $cond_lines = 1 + $#newlines;

 '';

				$stat_real = raw_line($linenr, $cond_lines)

							. "\n" if ($cond_lines);

				if (defined($stat_real) && $cond_lines > 1) {

 "[...]\n$stat_real";

 Check for bitwise tests written as boolean

		if ($line =~ /

			(?:

				(?:\[|\(|\&\&|\|\|)

				\s*0[xX][0-9]+\s*

				(?:\&\&|\|\|)

			|

				(?:\&\&|\|\|)

				\s*0[xX][0-9]+\s*

				(?:\&\&|\|\||\)|\])

			)/x)

		{

			WARN("HEXADECIMAL_BOOLEAN_TEST",

			     "boolean test with hexadecimal, perhaps just 1 \& or \|?\n" . $herecurr);

		}



# if and else should not have general statements after it

~ /^.\s*(?:}\s*)?else\b(.*)/) {

			my $s = $1;

 Remove any comments

 if should not continue a brace

		if ($line =~ /}\s*if\b/) {

			ERROR("TRAILING_STATEMENTS",

			      "trailing statements should be on next line (or did you mean 'else if'?)\n" .

				$herecurr);

		}

# case and default should not have general statements after them

~ /^.\s*(?:case\s*.*|default\s*):/g &&

 Check for }<nl>else {, these must be at the same

 indent level to be relevant to each other.

~/}\s*$/ and $line
~ /^\+/ && $line 
				my $fixedline = $prevrawline;

~ s/}\s*$//;

				$fixedline = $rawline;

~ s/^(.\s*)else/$1} else/;

~/}\s*$/ and $line
			my ($s, $c) = ctx_statement_block($linenr, $realcnt, 0);



			# Find out what is on the end of the line after the

			# conditional.

			substr($s, 0, length($c), '');

~ s/\n.*//g;

			if ($s =~ /^\s*;/) {

				if (ERROR("WHILE_AFTER_BRACE",

					  "while should follow close brace '}'\n" . $hereprev) &&

				    $fix && $prevline =~ /^\+/ && $line =~ /^\+/) {

					fix_delete_line($fixlinenr - 1, $prevrawline);

					fix_delete_line($fixlinenr, $rawline);

 $prevrawline;

					my $trailing = $rawline;

~ s/^\+//;

					$trailing = trim($trailing);

~ s/}\s*$/} $trailing/;

Specific variable tests

		while ($line =~ m{($Constant|$Lval)}g) {

 $1;

CamelCase

			    $var =~ /[A-Z][a-z]|[a-z][A-Z]/ &&

#Ignore some autogenerated defines and enum values

			    $var !~ /^(?:[A-Z]+_){1,5}[A-Z]{1,3}[a-z]/ &&

#Ignore Page<foo> variants

			    $var !~ /^(?:Clear|Set|TestClear|TestSet|)Page[A-Z]/ &&

#Ignore SI style variants like nS, mV and dB

#(ie: max_uV, regulator_min_uA_show, RANGE_mA_VALUE)

			    $var !~ /^(?:[a-z0-9_]*|[A-Z0-9_]*)?_?[a-z][A-Z](?:_[a-z0-9_]+|_[A-Z0-9_]+)?$/ &&

#Ignore some three character SI units explicitly, like MiB and KHz

			    $var !~ /^(?:[a-z_]*?)_?(?:[KMGT]iB|[KMGT]?Hz)(?:_[a-z_]+)?$/) {

~ m{($Ident)}g) {

					my $word = $1;

					next if ($word !~ /[A-Z][a-z]|[a-z][A-Z]/);

					if ($check) {

						seed_camelcase_includes();

						if (!$file && !$camelcase_file_seeded) {

							seed_camelcase_file($realfile);

 1;

						$camelcase{$word} = 1;

						CHK("CAMELCASE",

						    "Avoid CamelCase: <$word>\n" . $herecurr);

					}

				}

			}

		}



#no spaces allowed after \ in define

\s*define.*\\\s+$/) {

				$fixed[$fixlinenr] =~ s/\s+$//;

			}

		}



# warn if <asm/foo.h> is #included and <linux/foo.h> is available and includes

# itself <asm/foo.h> (uses RAW line)

\s*include\s*\<asm\/(.*)\.h\>}) {

			my $file = "$1.h";

 "include/linux/$file";

				my $asminclude = `grep -Ec "#include\\s+<asm/$file>" $root/$checkfile`;

				if ($asminclude > 0) {

~ m{^arch/}) {

include <linux/$file> instead of <asm/$file>\n" . $herecurr);

include <linux/$file> instead of <asm/$file>\n" . $herecurr);

 multi-statement macros should be enclosed in a do while loop, grab the

 first statement and ensure its the whole macro if its not enclosed

 in a known good container

		    $line =~ /^.\s*\#\s*define\s*$Ident(\()?/) {

 $linenr;

			my $cnt = $realcnt;

			my ($off, $dstat, $dcond, $rest);

 '';

			my $has_flow_statement = 0;

 0;

			($dstat, $dcond, $ln, $cnt, $off) =

				ctx_statement_block($linenr, $realcnt, 0);

 $dstat;

print "dstat<$dstat> dcond<$dcond> cnt<$cnt> off<$off>\n";

print "LINE<$lines[$ln-1]> len<" . length($lines[$ln-1]) . "\n";

 1 if ($ctx 
\\ 1 if ($ctx 
			$dstat =~ s/^.\s*\#\s*define\s+$Ident(\([^\)]*\))?\s*//;

 $1;

			my $define_stmt = $dstat;

 ();

				$define_args = substr($define_args, 1, length($define_args) - 2);

~ s/\s*//g;

				$define_args =~ s/\\\+?//g;

 split(",", $define_args);

			$dstat =~ s/$;//g;

~ s/\\\n.//g;

			$dstat =~ s/^\s*//s;

~ s/\s*$//s;

 Flatten any parentheses and braces

			while ($dstat =~ s/\([^\(\)]*\)/1u/ ||

~ s/\{[^\{\}]*\}/1u/ ||

			       $dstat =~ s/.\[[^\[\]]*\]/1u/)

			{

			}



			# Flatten any obvious string concatenation.

~ s/($String)\s*$Ident/$1/ ||

			       $dstat =~ s/$Ident\s*($String)/$1/)

			{

			}



			# Make asm volatile uses seem like a generic function

~ s/\b_*asm_*\s+_*volatile_*\b/asm_volatile/g;

			my $exceptions = qr{

				$Declare|

				module_param_named|

				MODULE_PARM_DESC|

				DECLARE_PER_CPU|

				DEFINE_PER_CPU|

				__typeof__\(|

				union|

				struct|

\s*|

print "REST<$rest> dstat<$dstat> ctx<$ctx>\n";

			$ctx =~ s/\n*$//;

 statement_rawlines($ctx);

			my $herectx = get_stat_here($linenr, $stmt_cnt, $here);



			if ($dstat ne '' &&

			    $dstat !~ /^(?:$Ident|-?$Constant),$/ &&			# 10, // foo(),

			    $dstat !~ /^(?:$Ident|-?$Constant);$/ &&			# foo();

			    $dstat !~ /^[!~-]?(?:$Lval|$Constant)$/ &&		# 10 // foo() // !foo // ~foo // -foo // foo->bar // foo.bar->baz

			    $dstat !~ /^'X'$/ && $dstat !~ /^'XX'$/ &&			# character constants

			    $dstat !~ /$exceptions/ &&

			    $dstat !~ /^\.$Ident\s*=/ &&				# .foo =

			    $dstat !~ /^(?:\#\s*$Ident|\#\s*$Constant)\s*$/ &&		# stringification #foo

			    $dstat !~ /^do\s*$Constant\s*while\s*$Constant;?$/ &&	# do {...} while (...); // do {...} while (...)

			    $dstat !~ /^while\s*$Constant\s*$Constant\s*$/ &&		# while (...) {...}

			    $dstat !~ /^for\s*$Constant$/ &&				# for (...)

			    $dstat !~ /^for\s*$Constant\s+(?:$Ident|-?$Constant)$/ &&	# for (...) bar()

			    $dstat !~ /^do\s*{/ &&					# do {...

			    $dstat !~ /^\(\{/ &&						# ({...

			    $ctx !~ /^.\s*#\s*define\s+TRACE_(?:SYSTEM|INCLUDE_FILE|INCLUDE_PATH)\b/)

			{

~ /^\s*if\b/) {

				} elsif ($dstat =~ /;/) {

					ERROR("MULTISTATEMENT_MACRO_USE_DO_WHILE",

					      "Macros with multiple statements should be enclosed in a do - while loop\n" . "$herectx");

				} else {

					ERROR("COMPLEX_MACRO",

					      "Macros with complex values should be enclosed in parentheses\n" . "$herectx");

				}



			}



			# Make $define_stmt single line, comment-free, etc

 split('\n', $define_stmt);

			my $first = 1;

 "";

				$l =~ s/\\$//;

				if ($first) {

 $l;

					$first = 0;

~ /^[\+ ]/) {

					$define_stmt .= substr($l, 1);

				}

			}

~ s/$;//g;

			$define_stmt =~ s/\s+/ /g;

 trim($define_stmt);

 check if any macro arguments are reused (ignore '...' and 'type')

			        next if ($arg =~ /\.\.\./);

~ /^type$/i);

				my $tmp_stmt = $define_stmt;

+)\s*\(*\s*$arg\s*\)*\b//g;

				$tmp_stmt =~ s/\#+\s*$arg\b//g;

\~ s/\b$arg\s*\#\#//g;

				my $use_cnt = () = $tmp_stmt =~ /\b$arg\b/g;

				if ($use_cnt > 1) {

					CHK("MACRO_ARG_REUSE",

					    "Macro argument reuse '$arg' - possible side-effects?\n" . "$herectx");

				    }

# check if any macro arguments may have other precedence issues

~ m/($Operators)?\s*\b$arg\b\s*($Operators)?/m &&

 check for macros with flow control, but without  concatenation

  concatenation is commonly a macro that defines a function so ignore those

				my $cnt = statement_rawlines($ctx);

 get_stat_here($linenr, $cnt, $here);

 check for line continuations outside of , and asm

.*\\$/ &&		
 asm

			    $line =~ /^\+.*\\$/) {

				WARN("LINE_CONTINUATIONS",

				     "Avoid unnecessary line continuations\n" . $herecurr);

			}

		}



# do {} while (0) macro tests:

# single-statement macros do not need to be enclosed in do while (0) loop,

# macro should not end with a semicolon

		if ($perl_version_ok &&

		    $realfile !~ m@/vmlinux.lds.h$@ &&

\s*define\s+$Ident(\()?/) {

			my $ln = $linenr;

 $realcnt;

			my $ctx = '';



			$ctx = $dstat;



~ s/\\\n.//g;

			$dstat =~ s/$;/ /g;



\s*define\s+$Ident\s*${balanced_parens}\s*do\s*{(.*)\s*}\s*while\s*\(\s*0\s*\)\s*([;\s]*)\s*$/) {

				my $stmts = $2;

 $3;

				$ctx =~ s/\n*$//;

 statement_rawlines($ctx);

				my $herectx = get_stat_here($linenr, $cnt, $here);



~ tr/;/;/)  1 &&

			} elsif ($dstat =~ /^\+\s*#\s*define\s+$Ident.*;\s*$/) {

~ s/\n*$//;

				my $cnt = statement_rawlines($ctx);

 get_stat_here($linenr, $cnt, $here);

 check for redundant bracing round if etc

		if ($line =~ /(^.*)\bif\b/ && $1 !~ /else\s*$/) {



print "chunks<$
print "APW: <<$chunks[1][0]>><<$chunks[1][1]>>\n";

chunks > 0 && $level == 0) {
 0) {

				my @allowed = ();

 0;

				my $seen = 0;

 $here . "\n";

				my $ln = $linenr - 1;

				for my $chunk (@chunks) {

 @{$chunk};

 If the condition carries leading newlines, then count those as offsets.

 ($cond 
					my $offset = statement_rawlines($whitespace) - 1;



 0;

print "COND<$cond> whitespace<$whitespace> offset<$offset>\n";

 We have looked at and allowed this specific line.

					$suppress_ifbraces{$ln + $offset} = 1;



 "$rawlines[$ln + $offset]\n[...]\n";

					$ln += statement_rawlines($block) - 1;



					substr($block, 0, length($cond), '');



~ /^\s*{/);

print "cond<$cond> block<$block> allowed<$allowed[$allow]>\n";

print "APW: ALLOWED: cond<$cond>\n";

						$allowed[$allow] = 1;

					}

~/\b(?:if|for|while)\b/) {

print "APW: ALLOWED: block<$block>\n";

						$allowed[$allow] = 1;

					}

					if (statement_block_size($block) > 1) {

						#print "APW: ALLOWED: lines block<$block>\n";

 1;

					my $sum_allowed = 0;

					foreach (@allowed) {

 $_;

					} elsif ($sum_allowed != $allow &&

 $allow) {

					$line =~ /\b(if|while|for|else)\b/) {

 0;

 Check the pre-context.

			if (substr($line, 0, $-[0]) =~ /(\}\s*)$/) {

				#print "APW: ALLOWED: pre<$1>\n";

 1;

			my ($level, $endln, @chunks) =

				ctx_statement_full($linenr, $realcnt, $-[0]);



			# Check the condition.

 @{$chunks[0]};

print "CHECKING<$linenr> cond<$cond> block<$block>\n";

print "APW: ALLOWED: cond<$cond>\n";

				$allowed = 1;

			}

~/\b(?:if|for|while)\b/) {

print "APW: ALLOWED: block<$block>\n";

				$allowed = 1;

			}

			if (statement_block_size($block) > 1) {

				#print "APW: ALLOWED: lines block<$block>\n";

 1;

 Check the post-context.

				my ($cond, $block) = @{$chunks[1]};

				if (defined $cond) {

					substr($block, 0, length($cond), '');

				}

~ /^\s*\{/) {

print "APW: ALLOWED: chunk-1 block<$block>\n";

					$allowed = 1;

				}

			}

~ /^\s*\{/ && !$allowed) {

				my $cnt = statement_rawlines($block);

 get_stat_here($linenr, $cnt, $here);

 check for single line unbalanced braces

		if ($sline =~ /^.\s*\}\s*else\s*$/ ||

~ /^.\s*else\s*\{\s*$/) {

 check for unnecessary blank lines around braces

~ /^.\s*}\s*$/ && $prevrawline 
			    $fix && $prevrawline =~ /^\+/) {

				fix_delete_line($fixlinenr - 1, $prevrawline);

			}

		}

		if (($rawline =~ /^.\s*$/ && $prevline =~ /^..*{\s*$/)) {

			if (CHK("BRACES",

				"Blank lines aren't necessary after an open brace '{'\n" . $hereprev) &&

			    $fix) {

				fix_delete_line($fixlinenr, $rawline);

			}

		}



# no volatiles please

 qr{\b(__asm__|asm)\s+(__volatile__|volatile)\b};

		if ($line =~ /\bvolatile\b/ && $line !~ /$asm_volatile/) {

			WARN("VOLATILE",

			     "Use of volatile is usually wrong: see Documentation/process/volatile-considered-harmful.rst\n" . $herecurr);

		}



# Check for user-visible strings broken across lines, which breaks the ability

# to grep for the string.  Make exceptions when the previous string ends in a

# newline (multiple lines in one string constant) or '\t', '\r', ';', or '{'

# (common in inline assembly) or is a octal \123 or hexadecimal \xaf value

~ /^\+\s*$String/ &&

		    $prevline =~ /"\s*$/ &&

		    $prevrawline !~ /(?:\\(?:[ntr]|[0-7]{1,3}|x[0-9a-fA-F]{1,2})|;\s*|\{\s*)"\s*$/) {

			if (WARN("SPLIT_STRING",

				 "quoted string split across lines\n" . $hereprev) &&

				     $fix &&

~ /^\+.*"\s*$/ &&

				     $last_coalesced_string_linenr != $linenr - 1) {

 get_quoted_string($line, $rawline);

				my $comma_close = "";

~ /\Q$extracted_string\E(\s*\)\s*;\s*$|\s*,\s*)/) {

					$comma_close = $1;

				}



				fix_delete_line($fixlinenr - 1, $prevrawline);

				fix_delete_line($fixlinenr, $rawline);

 $prevrawline;

				$fixedline =~ s/"\s*$//;

 substr($extracted_string, 1) . trim($comma_close);

				$fixedline = $rawline;

~ s/\Q$extracted_string\E\Q$comma_close\E//;

				$last_coalesced_string_linenr = $linenr;

			}

		}



# check for missing a space in a string concatenation

		if ($prevrawline =~ /[^\\]\w"$/ && $rawline =~ /^\+[\t ]+"\w/) {

			WARN('MISSING_SPACE',

			     "break quoted strings at a space character\n" . $hereprev);

		}



# check for an embedded function name in a string when the function is known

# This does not work very well for -f --file checking as it depends on patch

# context providing the function name or a single line form for in-file

# function declarations

~ /^\+.*$String/ &&

		    get_quoted_string($line, $rawline) =~ /\b$context_function\b/ &&

 (length($context_function) + 2)) {

 check for unnecessary function tracing like uses

 This does not use $logFunctions because there are many instances like

 'dprintk(FOO, "%s()\n", __func__);' which do not match $logFunctions

		if ($rawline =~ /^\+.*\([^"]*"$tracing_logging_tags{0,3}%s(?:\s*\(\s*\)\s*)?$tracing_logging_tags{0,3}(?:\\n)?"\s*,\s*__func__\s*\)\s*;/) {

			if (WARN("TRACING_LOGGING",

				 "Unnecessary ftrace-like logging - prefer using ftrace\n" . $herecurr) &&

			    $fix) {

                                fix_delete_line($fixlinenr, $rawline);

			}

		}



# check for spaces before a quoted newline

~ /^.*\".*\s\\n/) {

				$fixed[$fixlinenr] =~ s/^(\+.*\".*)\s+\\n/$1\\n/;

			}



		}



# concatenated string without spaces between elements

~ /$String[A-Z_]/ ||

		    ($line =~ /([A-Za-z0-9_]+)$String/ && $1 !~ /^[Lu]$/)) {

			if (CHK("CONCATENATED_STRING",

				"Concatenated strings should use spaces between elements\n" . $herecurr) &&

			    $fix) {

~ /($String)/g) {

					my $extracted_string = substr($rawline, $-[0], $+[0] - $-[0]);

~ s/\Q$extracted_string\E([A-Za-z0-9_])/$extracted_string $1/;

					$fixed[$fixlinenr] =~ s/([A-Za-z0-9_])\Q$extracted_string\E/$1 $extracted_string/;

				}

			}

		}



# uncoalesced string fragments

~ /$String\s*[Lu]?"/) {

~ /($String)(?
					my $extracted_string = substr($rawline, $-[0], $+[0] - $-[0]);

~ s/\Q$extracted_string\E\s*"/substr($extracted_string, 0, -1)/e;

 check for non-standard and hex prefixed decimal printf formats

		my $show_L = 1;	#don't show the same defect twice

 1;

		while ($line =~ /(?:^|")([X\t]*)(?:"|$)/g) {

 substr($rawline, $-[1], $+[1] - $-[1]);

			$string =~ s/%%/__/g;

			# check for %L

~ /%[\*\d\.\$]*L([diouxX])/) {

				$show_L = 0;

			}

			# check for %Z

~ /%[\*\d\.\$]*Z([diouxX])/) {

				$show_Z = 0;

			}

			# check for 0x<decimal>

~ /0x%[\*\d\.\$\Llzth]*[diou]/) {

 check for line continuations in quoted strings with odd counts of "

~ /\\$/ && $sline 
 warn about 
		if ($line =~ /^.\s*\#\s*if\s+0\b/) {

			WARN("IF_0",

			     "Consider removing the code enclosed by this #if 0 and its #endif\n" . $herecurr);

		}



# warn about #if 1

\s*if\s+1\b/) {

if 1 and its 
 check for needless "if (<foo>) fn(<foo>)" uses

		if ($prevline =~ /\bif\s*\(\s*($Lval)\s*\)/) {

 quotemeta($1);

			my $expr = '\s*\(\s*' . $tested . '\s*\)\s*;';

~ /\b(kfree|usb_free_urb|debugfs_remove(?:_recursive)?|(?:kmem_cache|mempool|dma_pool)_destroy)$expr/) {

				my $func = $1;

				if (WARN('NEEDLESS_IF',

					 "$func(NULL) is safe and this check is probably not required\n" . $hereprev) &&

				    $fix) {

 1;

					my $leading_tabs = "";

 "";

					if ($lines[$linenr - 2] =~ /^\+(\t*)if\s*\(\s*$tested\s*\)\s*$/) {

 $1;

						$do_fix = 0;

					}

~ /^\+(\t+)$func\s*\(\s*$tested\s*\)\s*;\s*$/) {

						$new_leading_tabs = $1;

						if (length($leading_tabs) + 1 ne length($new_leading_tabs)) {

 0;

						$do_fix = 0;

					}

					if ($do_fix) {

						fix_delete_line($fixlinenr - 1, $prevrawline);

~ s/^\+$new_leading_tabs/\+$leading_tabs/;

 check for unnecessary "Out of Memory" messages

		if ($line =~ /^\+.*\b$logFunctions\s*\(/ &&

~ /^[ \+]\s*if\s*\(\s*(\!\s*|NULL\s*\s*)?($Lval)(\s*\s*NULL\s*)?\s*\)/ &&

			my $testval = $2;

 $lines[$linenr - 3];

			my ($s, $c) = ctx_statement_block($linenr - 3, $realcnt, 0);

#			print("line: <$line>\nprevline: <$prevline>\ns: <$s>\nc: <$c>\n\n\n");



			if ($s =~ /(?:^|\n)[ \+]\s*(?:$Type\s*)?\Q$testval\E\s*=\s*(?:\([^\)]*\)\s*)?\s*$allocFunctions\s*\(/ &&

			    $s !~ /\b__GFP_NOWARN\b/ ) {

				WARN("OOM_MESSAGE",

				     "Possible unnecessary 'out of memory' message\n" . $hereprev);

			}

		}



# check for logging functions with KERN_<LEVEL>

		if ($line !~ /printk(?:_ratelimited|_once)?\s*\(/ &&

~ /\b$logFunctions\s*\(.*\b(KERN_[A-Z]+)\b/) {

			my $level = $1;

			if (WARN("UNNECESSARY_KERN_LEVEL",

				 "Possible unnecessary $level\n" . $herecurr) &&

			    $fix) {

~ s/\s*$level\s*//;

 check for logging continuations

		if ($line =~ /\bprintk\s*\(\s*KERN_CONT\b|\bpr_cont\s*\(/) {

			WARN("LOGGING_CONTINUATION",

			     "Avoid logging continuation uses where feasible\n" . $herecurr);

		}



# check for unnecessary use of %h[xudi] and %hh[xudi] in logging functions

		if (defined $stat &&

~ /\b$logFunctions\s*\(/ &&

		    index($stat, '"') >= 0) {

			my $lc = $stat =~ tr@\n@@;

 $lc + $linenr;

			my $stat_real = get_stat_real($linenr, $lc);

 index($stat_real, '"');

			while ($stat_real =~ /[^\"%]*(%[\#\d\.\*\-]*(h+)[idux])/g) {

 $1;

				my $h = $2;

				my $lineoff = substr($stat_real, 0, $-[1]) =~ tr@\n@@;

				if (WARN("UNNECESSARY_MODIFIER",

					 "Integer promotion: Using '$h' in '$pspec' is unnecessary\n" . "$here\n$stat_real\n") &&

~ /^\+/) {

					my $nspec = $pspec;

~ s/h//g;

					$fixed[$fixlinenr + $lineoff] =~ s/\Q$pspec\E/$nspec/;

				}

			}

		}



# check for mask then right shift without a parentheses

		if ($perl_version_ok &&

~ /$LvalOrFunc\s*\&\s*($LvalOrFunc)\s*>>/ &&

 $LvalOrFunc may be &foo, ignore if so

 check for pointer comparisons to NULL

~ /\b$LvalOrFunc\s*(|\!
				my $val = $1;

 "!";

 "" if ($4 eq "!
~ s/\b\Q$val\E\s*(?:|\!
 check for bad placement of section $InitAttribute (e.g.: __initdata)

		if ($line =~ /(\b$InitAttribute\b)/) {

 $1;

~ /^\+\s*static\s+(?:const\s+)?(?:$attr\s+)?($NonptrTypeWithAttr)\s+(?:$attr\s+)?($Ident(?:\[[^]]*\])?)\s*[
				my $ptr = $1;

 $2;

				if ((($ptr =~ /\b(union|struct)\s+$attr\b/ &&

				      ERROR("MISPLACED_INIT",

					    "$attr should be placed after $var\n" . $herecurr)) ||

				     ($ptr !~ /\b(union|struct)\s+$attr\b/ &&

				      WARN("MISPLACED_INIT",

					   "$attr should be placed after $var\n" . $herecurr))) &&

				    $fix) {

~ s/(\bstatic\s+(?:const\s+)?)(?:$attr\s+)?($NonptrTypeWithAttr)\s+(?:$attr\s+)?($Ident(?:\[[^]]*\])?)\s*([ ")/e;

 check for $InitAttributeData (ie: __initdata) with const

~ /\bconst\b/ && $line 
			my $attr = $1;

~ /($InitAttributePrefix)(.*)/;

			my $attr_prefix = $1;

 $2;

				$fixed[$fixlinenr] =~

				    s/$InitAttributeData/${attr_prefix}initconst/;

			}

		}



# check for $InitAttributeConst (ie: __initconst) without const

~ /($InitAttributeConst)/) {

			my $attr = $1;

			if (ERROR("INIT_ATTRIBUTE",

				  "Use of $attr requires a separate use of const\n" . $herecurr) &&

			    $fix) {

				my $lead = $fixed[$fixlinenr] =~

				    /(^\+\s*(?:static\s+))/;

 rtrim($1);

				$lead = "$lead " if ($lead !~ /^\+$/);

 "${lead}const ";

				$fixed[$fixlinenr] =~ s/(^\+\s*(?:static\s+))/$lead/;

			}

		}



# check for __read_mostly with const non-pointer (should just be const)

~ /\b__read_mostly\b/ &&

~ /($Type)\s*$Ident/ && $1 !~ /\*\s*$/ && $1 
				$fixed[$fixlinenr] =~ s/\s+__read_mostly\b//;

			}

		}



# don't use __constant_<foo> functions outside of include/uapi/

		if ($realfile !~ m@^include/uapi/@ &&

~ /(__constant_(?:htons|ntohs|[bl]e(?:16|32|64)_to_cpu|cpu_to_[bl]e(?:16|32|64)))\s*\(/) {

			my $constant_func = $1;

 $constant_func;

			$func =~ s/^__constant_//;

			if (WARN("CONSTANT_CONVERSION",

				 "$constant_func should be $func\n" . $herecurr) &&

			    $fix) {

~ s/\b$constant_func\b/$func/g;

 prefer usleep_range over udelay

		if ($line =~ /\budelay\s*\(\s*(\d+)\s*\)/) {

 $1;

 ignore udelay's < 10, however

 warn about unexpectedly long msleep's

		if ($line =~ /\bmsleep\s*\((\d+)\);/) {

			if ($1 < 20) {

				WARN("MSLEEP",

				     "msleep < 20ms can sleep for up to 20ms; see Documentation/timers/timers-howto.rst\n" . $herecurr);

			}

		}



# check for comparisons of jiffies

~ /\bjiffies\s*$Compare|$Compare\s*jiffies\b/) {

 check for comparisons of get_jiffies_64()

		if ($line =~ /\bget_jiffies_64\s*\(\s*\)\s*$Compare|$Compare\s*get_jiffies_64\s*\(\s*\)/) {

			WARN("JIFFIES_COMPARISON",

			     "Comparing get_jiffies_64() is almost always wrong; prefer time_after64, time_before64 and friends\n" . $herecurr);

		}



# warn about #ifdefs in C files

#		if ($line =~ /^.\s*\#\s*if(|n)def/ && ($realfile =~ /\.c$/)) {

#			print "#ifdef in C files should be avoided\n";

#			print "$herecurr";

			$clean = 0;

		}

 warn about spacing in 
		if ($line =~ /^.\s*\#\s*(ifdef|ifndef|elif)\s\s+/) {

			if (ERROR("SPACING",

				  "exactly one space required after that #$1\n" . $herecurr) &&

			    $fix) {

~

\s*(ifdef|ifndef|elif))\s{2,}/$1 /;

 check for spinlock_t definitions without a comment.

		if ($line =~ /^.\s*(struct\s+mutex|spinlock_t)\s+\S+;/ ||

~ /^.\s*(DEFINE_MUTEX)\s*\(/) {

			my $which = $1;

			if (!ctx_has_comment($first_line, $linenr)) {

				CHK("UNCOMMENTED_DEFINITION",

				    "$1 definition without comment\n" . $herecurr);

			}

		}

# check for memory barriers without a comment.



 qr{

		my $barrier_stems = qr{

			mb__before_atomic|

			mb__after_atomic|

			store_release|

			load_acquire|

			store_mb|

			(?:$barriers)

		}x;

 qr{

		if ($line =~ /\b(?:$all_barriers)\s*\(/) {

			if (!ctx_has_comment($first_line, $linenr)) {

				WARN("MEMORY_BARRIER",

				     "memory barrier without comment\n" . $herecurr);

			}

		}



 qr{__smp_(?:$barrier_stems)}x;

		    $line =~ m/\b(?:$underscore_smp_barriers)\s*\(/ &&

		    $line !~ m/^.\s*\#\s*define\s+(?:$underscore_smp_barriers)\s*\(/) {

			WARN("MEMORY_BARRIER",

			     "__smp memory barriers shouldn't be used outside barrier.h and asm-generic\n" . $herecurr);

		}



# check for waitqueue_active without a comment.

~ /\bwaitqueue_active\s*\(/) {

 check for data_race without a comment.

		if ($line =~ /\bdata_race\s*\(/) {

			if (!ctx_has_comment($first_line, $linenr)) {

				WARN("DATA_RACE",

				     "data_race without comment\n" . $herecurr);

			}

		}



# check of hardware specific defines

\s*if.*\b(__i386__|__powerpc64__|__sun__|__s390x__)\b@ && $realfile !~ m@include/asm-@) {

 check that the storage class is not after a type

		if ($line =~ /\b($Type)\s+($Storage)\b/) {

			WARN("STORAGE_CLASS",

			     "storage class '$2' should be located before type '$1'\n" . $herecurr);

		}

# Check that the storage class is at the beginning of a declaration

~ /\b$Storage\b/ &&

		    $line =~ /^.\s*(.+?)\$Storage\s/ &&

		    $1 !~ /[\,\)]\s*$/) {

			WARN("STORAGE_CLASS",

			     "storage class should be at the beginning of the declaration\n" . $herecurr);

		}



# check the location of the inline attribute, that it is between

# storage class and type.

~ /\b$Type\s+$Inline\b/ ||

		    $line =~ /\b$Inline\s+$Storage\b/) {

			ERROR("INLINE_LOCATION",

			      "inline keyword should sit between storage class and type\n" . $herecurr);

		}



# Check for __inline__ and __inline, prefer inline

		if ($realfile !~ m@\binclude/uapi/@ &&

~ /\b(__inline__|__inline)\b/) {

				$fixed[$fixlinenr] =~ s/\b(__inline__|__inline)\b/inline/;



			}

		}



# Check for compiler attributes

		if ($realfile !~ m@\binclude/uapi/@ &&

~ /\b__attribute__\s*\(\s*($balanced_parens)\s*\)/) {

			my $attr = $1;

~ s/\s*\(\s*(.*)\)\s*/$1/;

			my %attr_list = (

> "__alias",

				"aligned"			=> "__aligned",

> "__always_inline",

				"assume_aligned"		=> "__assume_aligned",

> "__cold",

				"const"				=> "__attribute_const__",

> "__copy",

				"designated_init"		=> "__designated_init",

> "__visible",

				"format"			=> "printf|scanf",

> "__gnu_inline",

				"malloc"			=> "__malloc",

> "__mode",

				"no_caller_saved_registers"	=> "__no_caller_saved_registers",

> "__noclone",

				"noinline"			=> "noinline",

> "__nonstring",

				"noreturn"			=> "__noreturn",

> "__packed",

				"pure"				=> "__pure",

> "__section",

				"used"				=> "__used",

> "__weak"

			while ($attr =~ /\s*(\w+)\s*(${balanced_parens})?/g) {

 $1;

				my $params = '';

 $2 if defined($2);

				my $curr_attr = $orig_attr;

~ s/^[\s_]+|[\s_]+$//g;

					my $new = $attr_list{$curr_attr};

					if ($curr_attr eq "format" && $params) {

~ /^\s*\(\s*(\w+)\s*,\s*(.*)/;

						$new = "__$1\($2";

					} else {

 "$new$params";

						my $remove = "\Q$orig_attr\E" . '\s*' . "\Q$params\E" . '(?:\s*,\s*)?';

~ s/$remove//;

						$fixed[$fixlinenr] =~ s/\b__attribute__/$new __attribute__/;

~ s/\}\Q$new\E/} $new/;

						$fixed[$fixlinenr] =~ s/ __attribute__\s*\(\s*\(\s*\)\s*\)//;

					}

				}

			}



			# Check for __attribute__ unused, prefer __always_unused or __maybe_unused

~ /^_*unused/) {

 Check for __attribute__ weak, or __weak declarations (may have link issues)

		    $line =~ /(?:$Declare|$DeclareMisordered)\s*$Ident\s*$balanced_parens\s*(?:$Attribute)?\s*;/ &&

~ /\b__attribute__\s*\(\s*\(.*\bweak\b/ ||

		     $line =~ /\b__weak\b/)) {

			ERROR("WEAK_DECLARATION",

			      "Using weak declarations can have unintended link defects\n" . $herecurr);

		}



# check for c99 types like uint8_t used outside of uapi/ and tools/

		if ($realfile !~ m@\binclude/uapi/@ &&

		    $realfile !~ m@\btools/@ &&

		    $line =~ /\b($Declare)\s*$Ident\s*[=;,\[]/) {

 $1;

			if ($type =~ /\b($typeC99Typedefs)\b/) {

 $1;

				my $kernel_type = 'u';

				$kernel_type = 's' if ($type =~ /^_*[si]/);

~ /(\d+)/;

				$kernel_type .= $1;

				if (CHK("PREFER_KERNEL_TYPES",

					"Prefer kernel type '$kernel_type' over '$type'\n" . $herecurr) &&

				    $fix) {

~ s/\b$type\b/$kernel_type/;

 check for cast of C90 native int or longer types constants

		if ($line =~ /(\(\s*$C90_int_types\s*\)\s*)($Constant)\b/) {

 $1;

			my $const = $2;

 "";

			my $newconst = $const;

~ s/${Int_type}$//;

 'U' if ($cast 
			if ($cast =~ /\blong\s+long\b/) {

 'LL';

			} elsif ($cast =~ /\blong\b/) {

 'L';

				$fixed[$fixlinenr] =~ s/\Q$cast\E$const\b/$newconst$suffix/;

			}

		}



# check for sizeof(&)

~ /\bsizeof\s*\(\s*\&/) {

 check for sizeof without parenthesis

		if ($line =~ /\bsizeof\s+((?:\*\s*|)$Lval|$Type(?:\s+$Lval|))/) {

			if (WARN("SIZEOF_PARENTHESIS",

				 "sizeof $1 should be sizeof($1)\n" . $herecurr) &&

			    $fix) {

~ s/\bsizeof\s+((?:\*\s*|)$Lval|$Type(?:\s+$Lval|))/"sizeof(" . trim($1) . ")"/ex;

 check for struct spinlock declarations

		if ($line =~ /^.\s*\bstruct\s+spinlock\s+\w+\s*;/) {

			WARN("USE_SPINLOCK_T",

			     "struct spinlock should be spinlock_t\n" . $herecurr);

		}



# check for seq_printf uses that could be seq_puts

~ /\bseq_printf\s*\(.*"\s*\)\s*;\s*$/) {

			my $fmt = get_quoted_string($line, $rawline);

~ s/%%//g;

					$fixed[$fixlinenr] =~ s/\bseq_printf\b/seq_puts/;

				}

			}

		}



# check for vsprintf extension %p<foo> misuses

		if ($perl_version_ok &&

		    defined $stat &&

~ /^\+(?![^\{]*\{\s*).*\b(\w+)\s*\(.*$String\s*,/s &&

 $stat 
			$lc = $lc + $linenr;

		        for (my $count = $linenr; $count <= $lc; $count++) {

				my $specifier;

				my $extension;

				my $qualifier;

 "";

				my $fmt = get_quoted_string($lines[$count - 1], raw_line($count, 0));

~ s/%%//g;

				while ($fmt =~ /(\%[\*\d\.]*p(\w)(\w*))/g) {

 $1;

					$extension = $2;

 $3;

						$bad_specifier = $specifier;

						last;

					}

					if ($extension eq "x" && !defined($stat_real)) {

						if (!defined($stat_real)) {

 get_stat_real($linenr, $lc);

					my $stat_real = get_stat_real($linenr, $lc);

 "Invalid";

					my $use = "";

~ /p[Ff]/) {

						$use = " - use %pS instead";

						$use =~ s/pS/ps/ if ($bad_specifier =~ /pf/);

					}



					WARN("VSPRINTF_POINTER_EXTENSION",

					     "$ext_type vsprintf pointer extension '$bad_specifier'$use\n" . "$here\n$stat_real\n");

				}

			}

		}



# Check for misused memsets

		if ($perl_version_ok &&

		    defined $stat &&

~ /^\+(?:.*?)\bmemset\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*$FuncArg\s*\)/) {

			my $ms_addr = $2;

 $7;

			my $ms_size = $12;



~ /^(0x|)0$/i) {

			} elsif ($ms_size =~ /^(0x|)1$/i) {

				WARN("MEMSET",

				     "single byte memset is suspicious. Swapped 2nd/3rd argument?\n" . "$here\n$stat\n");

			}

		}



# Check for memcpy(foo, bar, ETH_ALEN) that could be ether_addr_copy(foo, bar)

#		if ($perl_version_ok &&

#		    defined $stat &&

		    $stat =~ /^\+(?:.*?)\bmemcpy\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/) {

			if (WARN("PREFER_ETHER_ADDR_COPY",

				 "Prefer ether_addr_copy() over memcpy() if the Ethernet addresses are __aligned(2)\n" . "$here\n$stat\n") &&

			    $fix) {

#				$fixed[$fixlinenr] =~ s/\bmemcpy\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/ether_addr_copy($2, $7)/;

#			}

#		}



# Check for memcmp(foo, bar, ETH_ALEN) that could be ether_addr_equal*(foo, bar)

#		if ($perl_version_ok &&

#		    defined $stat &&

		    $stat =~ /^\+(?:.*?)\bmemcmp\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/) {

			WARN("PREFER_ETHER_ADDR_EQUAL",

			     "Prefer ether_addr_equal() or ether_addr_equal_unaligned() over memcmp()\n" . "$here\n$stat\n")

		}

 check for memset(foo, 0x0, ETH_ALEN) that could be eth_zero_addr

 check for memset(foo, 0xFF, ETH_ALEN) that could be eth_broadcast_addr

		if ($perl_version_ok &&

		    defined $stat &&

#		    $stat =~ /^\+(?:.*?)\bmemset\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\,\s*ETH_ALEN\s*\)/) {

#

			my $ms_val = $7;



#			if ($ms_val =~ /^(?:0x|)0+$/i) {

#				if (WARN("PREFER_ETH_ZERO_ADDR",

#					 "Prefer eth_zero_addr over memset()\n" . "$here\n$stat\n") &&

#				    $fix) {

					$fixed[$fixlinenr] =~ s/\bmemset\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*,\s*ETH_ALEN\s*\)/eth_zero_addr($2)/;

				}

#			} elsif ($ms_val =~ /^(?:0xff|255)$/i) {

#				if (WARN("PREFER_ETH_BROADCAST_ADDR",

#					 "Prefer eth_broadcast_addr() over memset()\n" . "$here\n$stat\n") &&

#				    $fix) {

					$fixed[$fixlinenr] =~ s/\bmemset\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*,\s*ETH_ALEN\s*\)/eth_broadcast_addr($2)/;

				}

			}

		}

 strlcpy uses that should likely be strscpy

		if ($line =~ /\bstrlcpy\s*\(/) {

			WARN("STRLCPY",

			     "Prefer strscpy over strlcpy - see: https://lore.kernel.org/r/CAHk-=wgfRnXz0W3D37d01q3JFkr_i_uTL=V6A6G1oUZcprmknw\@mail.gmail.com/\n" . $herecurr);

		}



# typecasts on min/max could be min_t/max_t

		if ($perl_version_ok &&

		    defined $stat &&

~ /^\+(?:.*?)\b(min|max)\s*\(\s*$FuncArg\s*,\s*$FuncArg\s*\)/) {

				my $call = $1;

 deparenthesize($2);

				my $arg1 = $3;

 deparenthesize($7);

				my $arg2 = $8;

				my $cast;



				if ($cast1 ne "" && $cast2 ne "" && $cast1 ne $cast2) {

 "$cast1 or $cast2";

					$cast = $cast1;

				} else {

 $cast2;

 check usleep_range arguments

		    $stat =~ /^\+(?:.*?)\busleep_range\s*\(\s*($FuncArg)\s*,\s*($FuncArg)\s*\)/) {

 $1;

			my $max = $7;

			if ($min eq $max) {

				WARN("USLEEP_RANGE",

				     "usleep_range should not use min == max args; see Documentation/timers/timers-howto.rst\n" . "$here\n$stat\n");

			} elsif ($min =~ /^\d+$/ && $max =~ /^\d+$/ &&

				 $min > $max) {

				WARN("USLEEP_RANGE",

				     "usleep_range args reversed, use min then max; see Documentation/timers/timers-howto.rst\n" . "$here\n$stat\n");

			}

		}



# check for naked sscanf

		if ($perl_version_ok &&

		    defined $stat &&

~ /\bsscanf\b/ &&

		    ($stat !~ /$Ident\s*=\s*sscanf\s*$balanced_parens/ &&

		     $stat !~ /\bsscanf\s*$balanced_parens\s*(?:$Compare)/ &&

		     $stat !~ /(?:$Compare)\s*\bsscanf\s*$balanced_parens/)) {

			my $lc = $stat =~ tr@\n@@;

 $lc + $linenr;

			my $stat_real = get_stat_real($linenr, $lc);

			WARN("NAKED_SSCANF",

			     "unchecked sscanf return value\n" . "$here\n$stat_real\n");

		}



# check for simple sscanf that should be kstrto<foo>

		if ($perl_version_ok &&

		    defined $stat &&

~ /\bsscanf\b/) {

 $stat 
			$lc = $lc + $linenr;

 get_stat_real($linenr, $lc);

			if ($stat_real =~ /\bsscanf\b\s*\(\s*$FuncArg\s*,\s*("[^"]+")/) {

 $6;

 $format 
				    $format =~ /^"\%(?i:ll[udxi]|[udxi]ll|ll|[hl]h?[udxi]|[udxi][hl]h?|[hl]h?|[udxi])"$/) {

					WARN("SSCANF_TO_KSTRTO",

					     "Prefer kstrto<type> to single variable sscanf\n" . "$here\n$stat_real\n");

				}

			}

		}



# check for new externs in .h files.

~ /\.h$/ &&

		    $line =~ /^\+\s*(extern\s+)$Type\s*$Ident\s*\(/s) {

			if (CHK("AVOID_EXTERNS",

				"extern prototypes should be avoided in .h files\n" . $herecurr) &&

			    $fix) {

~ s/(.*)\bextern\b\s*(.*)/$1$2/;

 check for new externs in .c files.

		if ($realfile =~ /\.c$/ && defined $stat &&

~ /^.\s*(?:extern\s+)?$Type\s+($Ident)(\s*)\(/s)

			my $function_name = $1;

 $2;

			my $s = $stat;

			if (defined $cond) {

				substr($s, 0, length($cond), '');

			}

~ /^\s*;/)

			if ($paren_space =~ /\n/) {

				WARN("FUNCTION_ARGUMENTS",

				     "arguments for function declarations should follow identifier\n" . $herecurr);

			}



~ /\.c$/ && defined $stat &&

		    $stat =~ /^.\s*extern\s+/)

		{

			WARN("AVOID_EXTERNS",

			     "externs should be avoided in .c files\n" .  $herecurr);

		}



# check for function declarations that have arguments without identifier names

		if (defined $stat &&

~ /^.\s*(?:extern\s+)?$Type\s*(?:$Ident|\(\s*\*\s*$Ident\s*\))\s*\(\s*([^{]+)\s*\)\s*;/s &&

			my $args = trim($1);

~ m/\s*($Type\s*(?:$Ident|\(\s*\*\s*$Ident?\s*\)\s*$balanced_parens)?)/g) {

				my $arg = trim($1);

~ /^$Type$/ && $arg !~ /enum\s+$Ident$/) {

 check for function definitions

		    $stat =~ /^.\s*(?:$Storage\s+)?$Type\s*($Ident)\s*$balanced_parens\s*{/s) {

 $1;

 check for multiline function definition with misplaced open brace

			my $ok = 0;

 statement_rawlines($stat);

			my $herectx = $here . "\n";

 0; $n < $cnt; $n++) {

				my $rl = raw_line($linenr, $n);

  $rl . "\n";

 1 if ($rl 
 1 if ($rl 
				last if $rl =~ /^[ \+].*\{/;

			}

			if (!$ok) {

				ERROR("OPEN_BRACE",

				      "open brace '{' following function definitions go on the next line\n" . $herectx);

			}

		}



# checks for new __setup's

~ /\b__setup\("([^"]*)"/) {

			my $name = $1;



			if (!grep(/$name/, @setup_docs)) {

				CHK("UNDOCUMENTED_SETUP",

				    "__setup appears un-documented -- check Documentation/admin-guide/kernel-parameters.txt\n" . $herecurr);

			}

		}



# check for pointless casting of alloc functions

~ /\*\s*\)\s*$allocFunctions\b/) {

 alloc style

 p = alloc(sizeof(struct foo), ...) should be p = alloc(sizeof(*p), ...)
 alloc(sizeof(*p), ...)

~ /\b($Lval)\s*\
 check for k[mz]alloc with multiplies that could be kmalloc_array/kcalloc

~ /^\+\s*($Lval)\s*\
			my $oldfunc = $3;

 $4;

			my $a2 = $10;

 "kmalloc_array";

			$newfunc = "kcalloc" if ($oldfunc eq "kzalloc");

 $a1;

			my $r2 = $a2;

~ /^sizeof\s*\S/) {

				$r1 = $a2;

 $a1;

			if ($r1 !~ /^sizeof\b/ && $r2 =~ /^sizeof\s*\S/ &&

			    !($r1 =~ /^$Constant$/ || $r1 =~ /^[A-Z_][A-Z0-9_]*$/)) {

 statement_rawlines($stat);

				my $herectx = get_stat_here($linenr, $cnt, $here);



				if (WARN("ALLOC_WITH_MULTIPLY",

					 "Prefer $newfunc over $oldfunc with multiply\n" . $herectx) &&

				    $cnt == 1 &&

				    $fix) {

~ s/\b($Lval)\s*\ ' . "$newfunc(" . trim($r1) . ', ' . trim($r2)/e;

 check for krealloc arg reuse

~ /\b($Lval)\s*\
 check for alloc argument mismatch

		if ($line =~ /\b((?:devm_)?(?:kcalloc|kmalloc_array))\s*\(\s*sizeof\b/) {

			WARN("ALLOC_ARRAY_ARGS",

			     "$1 uses number as first arg, sizeof is generally wrong\n" . $herecurr);

		}



# check for multiple semicolons

~ /;\s*;\s*$/) {

				$fixed[$fixlinenr] =~ s/(\s*;\s*){2,}$/;/g;

			}

		}



# check for #defines like: 1 << <digit> that could be BIT(digit), it is not exported to uapi

		if ($realfile !~ m@^include/uapi/@ &&

\s*define\s+\w+\s+\(?\s*1\s*([ulUL]*)\s*\<\<\s*(?:\d+|$Ident)\s*\)?/) {

			my $ull = "";

			$ull = "_ULL" if (defined($1) && $1 =~ /ll/i);

			if (CHK("BIT_MACRO",

				"Prefer using the BIT$ull macro\n" . $herecurr) &&

			    $fix) {

~ s/\(?\s*1\s*[ulUL]*\s*<<\s*(\d+|$Ident)\s*\)?/BIT${ull}($1)/;

 check for IS_ENABLED() without CONFIG_<FOO> ($rawline for comments too)

		if ($rawline =~ /\bIS_ENABLED\s*\(\s*(\w+)\s*\)/ && $1 !~ /^${CONFIG_}/) {

			WARN("IS_ENABLED_CONFIG",

			     "IS_ENABLED($1) is normally used as IS_ENABLED(${CONFIG_}$1)\n" . $herecurr);

		}



# check for #if defined CONFIG_<FOO> || defined CONFIG_<FOO>_MODULE

\s*if\s+defined(?:\s*\(?\s*|\s+)(${CONFIG_}[A-Z_]+)\s*\)?\s*\|\|\s*defined(?:\s*\(?\s*|\s+)\1_MODULE\s*\)?\s*$/) {

			my $config = $1;

			if (WARN("PREFER_IS_ENABLED",

				 "Prefer IS_ENABLED(<FOO>) to ${CONFIG_}<FOO> || ${CONFIG_}<FOO>_MODULE\n" . $herecurr) &&

			    $fix) {

if IS_ENABLED($config)";

 check for /* fallthrough */ like comment, prefer fallthrough;

		my @fallthroughs = (

			'fallthrough',

			'@fallthrough@',

			'lint -fallthrough[ \t]*',

			'intentional(?:ly)?[ \t]*fall(?:(?:s | |-)[Tt]|t)hr(?:ough|u|ew)',

			'(?:else,?\s*)?FALL(?:S | |-)?THR(?:OUGH|U|EW)[ \t.!]*(?:-[^\n\r]*)?',

			'Fall(?:(?:s | |-)[Tt]|t)hr(?:ough|u|ew)[ \t.!]*(?:-[^\n\r]*)?',

			'fall(?:s | |-)?thr(?:ough|u|ew)[ \t.!]*(?:-[^\n\r]*)?',

		    );

		if ($raw_comment ne '') {

			foreach my $ft (@fallthroughs) {

~ /$ft/) {

					my $msg_level = \&WARN;

 \&CHK if ($file);

 check for switch/default statements without a break;

		    $stat =~ /^\+[$;\s]*(?:case[$;\s]+\w+[$;\s]*:[$;\s]*|)*[$;\s]*\bdefault[$;\s]*:[$;\s]*;/g) {

 statement_rawlines($stat);

			my $herectx = get_stat_here($linenr, $cnt, $here);



			WARN("DEFAULT_NO_BREAK",

			     "switch default: should use break\n" . $herectx);

		}



# check for gcc specific __FUNCTION__

~ /\b__FUNCTION__\b/) {

				$fixed[$fixlinenr] =~ s/\b__FUNCTION__\b/__func__/g;

			}

		}



# check for uses of __DATE__, __TIME__, __TIMESTAMP__

~ /\b(__(?:DATE|TIME|TIMESTAMP)__)\b/g) {

 check for use of yield()

		if ($line =~ /\byield\s*\(\s*\)/) {

			WARN("YIELD",

			     "Using yield() is generally wrong. See yield() kernel-doc (sched/core.c)\n"  . $herecurr);

		}



# check for comparisons against true and false

		if ($line =~ /\+\s*(.*?)\b(true|false|$Lval)\s*(==|\!=)\s*(true|false|$Lval)\b(.*)$/i) {

 $1;

			my $arg = $2;

 $3;

			my $otype = $4;

 $5;

			my $op = "!";



			($arg, $otype) = ($otype, $arg) if ($arg =~ /^(?:true|false)$/i);



 lc($otype);

			if ($type =~ /^(?:true|false)$/) {

				if (("$test" eq "==" && "$type" eq "true") ||

" && "$type" eq "false")) {

					$op = "";

				}



				CHK("BOOL_COMPARISON",

				    "Using comparison to $otype is error prone\n" . $herecurr);



## maybe suggesting a correct construct would better

##				    "Using comparison to $otype is error prone.  Perhaps use '${lead}${op}${arg}${trail}'\n" . $herecurr);



			}

		}



# check for semaphores initialized locked

~ /^.\s*sema_init.+,\W?0\W?\)/) {

 recommend kstrto* over simple_strto* and strict_strto*

		if ($line =~ /\b((simple|strict)_(strto(l|ll|ul|ull)))\s*\(/) {

			WARN("CONSIDER_KSTRTO",

			     "$1 is obsolete, use k$3 instead\n" . $herecurr);

		}



# check for __initcall(), use device_initcall() explicitly or more appropriate function please

~ /^.\s*__initcall\s*\(/) {

 check for spin_is_locked(), suggest lockdep instead

		if ($line =~ /\bspin_is_locked\(/) {

			WARN("USE_LOCKDEP",

			     "Where possible, use lockdep_assert_held instead of assertions based on spin_is_locked\n" . $herecurr);

		}



# check for deprecated apis

~ /\b($deprecated_apis_search)\b\s*\(/) {

			my $deprecated_api = $1;

 $deprecated_apis{$deprecated_api};

 check for various structs that are normally const (ops, kgdb, device_tree)

 and avoid what seem like struct definitions 'struct foo {'

		    $line =~ /\bstruct\s+($const_structs)\b(?!\s*\{)/) {

			WARN("CONST_STRUCT",

			     "struct $1 should normally be const\n" . $herecurr);

		}



# use of NR_CPUS is usually wrong

# ignore definitions of NR_CPUS and usage to define arrays as likely right

# ignore designated initializers using NR_CPUS

~ /\bNR_CPUS\b/ &&

\s*if\b.*\bNR_CPUS\b/ &&

\s*define\b.*\bNR_CPUS\b/ &&

		    $line !~ /^.\s*\.\w+\s*=\s*.*\bNR_CPUS\b/)

		{

			WARN("NR_CPUS",

			     "usage of NR_CPUS is often wrong - consider using cpu_possible(), num_possible_cpus(), for_each_possible_cpu(), etc\n" . $herecurr);

		}



# Use of __ARCH_HAS_<FOO> or ARCH_HAVE_<BAR> is wrong.

\s*define\s+((?:__)?ARCH_(?:HAS|HAVE)\w*)\b/) {

define of '$1' is wrong - use Kconfig variables or standard guards instead\n" . $herecurr);

 likely/unlikely comparisons similar to "(likely(foo) > 0)"

		    $line =~ /\b((?:un)?likely)\s*\(\s*$FuncArg\s*\)\s*$Compare/) {

			WARN("LIKELY_MISUSE",

			     "Using $1 should generally have parentheses around the comparison\n" . $herecurr);

		}



# return sysfs_emit(foo, fmt, ...) fmt without newline

~ /\breturn\s+sysfs_emit\s*\(\s*$FuncArg\s*,\s*($String)/ &&

			my $offset = $+[6] - 1;

			if (WARN("SYSFS_EMIT",

				 "return sysfs_emit(...) formats should include a terminating newline\n" . $herecurr) &&

			    $fix) {

 '\\n';

 nested likely/unlikely calls

		if ($line =~ /\b(?:(?:un)?likely)\s*\(\s*!?\s*(IS_ERR(?:_OR_NULL|_VALUE)?|WARN)/) {

			WARN("LIKELY_MISUSE",

			     "nested (un)?likely() calls, $1 already uses unlikely() internally\n" . $herecurr);

		}



# whine mightly about in_atomic

~ /\bin_atomic\s*\(/) {

			if ($realfile =~ m@^drivers/@) {

				ERROR("IN_ATOMIC",

				      "do not use in_atomic in drivers\n" . $herecurr);

			} elsif ($realfile !~ m@^kernel/@) {

				WARN("IN_ATOMIC",

				     "use of in_atomic() is incorrect outside core kernel code\n" . $herecurr);

			}

		}



# check for lockdep_set_novalidate_class

~ /^.\s*lockdep_set_novalidate_class\s*\(/ ||

		    $line =~ /__lockdep_no_validate__\s*\)/ ) {

			if ($realfile !~ m@^kernel/lockdep@ &&

			    $realfile !~ m@^include/linux/lockdep@ &&

			    $realfile !~ m@^drivers/base/core@) {

				ERROR("LOCKDEP",

				      "lockdep_no_validate class is reserved for device->mutex.\n" . $herecurr);

			}

		}



~ /debugfs_create_\w+.*\b$mode_perms_world_writable\b/ ||

		    $line =~ /DEVICE_ATTR.*\b$mode_perms_world_writable\b/) {

			WARN("EXPORTED_WORLD_WRITABLE",

			     "Exporting world writable files is usually an error. Consider more restrictive permissions.\n" . $herecurr);

		}



# check for DEVICE_ATTR uses that could be DEVICE_ATTR_<FOO>

# and whether or not function naming is typical and if

# DEVICE_ATTR permissions uses are unusual too

		if ($perl_version_ok &&

		    defined $stat &&

~ /\bDEVICE_ATTR\s*\(\s*(\w+)\s*,\s*\(?\s*(\s*(?:${multi_mode_perms_string_search}|0[0-7]{3,3})\s*)\s*\)?\s*,\s*(\w+)\s*,\s*(\w+)\s*\)/) {

			my $var = $1;

 $2;

			my $show = $3;

 $4;

			my $octal_perms = perms_to_octal($perms);

~ /^${var}_show$/ &&

			    $store =~ /^${var}_store$/ &&

			    $octal_perms eq "0644") {

				if (WARN("DEVICE_ATTR_RW",

					 "Use DEVICE_ATTR_RW\n" . $herecurr) &&

				    $fix) {

~ s/\bDEVICE_ATTR\s*\(\s*$var\s*,\s*\Q$perms\E\s*,\s*$show\s*,\s*$store\s*\)/DEVICE_ATTR_RW(${var})/;

			} elsif ($show =~ /^${var}_show$/ &&

~ /^NULL$/ &&

					$fixed[$fixlinenr] =~ s/\bDEVICE_ATTR\s*\(\s*$var\s*,\s*\Q$perms\E\s*,\s*$show\s*,\s*NULL\s*\)/DEVICE_ATTR_RO(${var})/;

				}

~ /^NULL$/ &&

				 $store =~ /^${var}_store$/ &&

				 $octal_perms eq "0200") {

				if (WARN("DEVICE_ATTR_WO",

					 "Use DEVICE_ATTR_WO\n" . $herecurr) &&

				    $fix) {

~ s/\bDEVICE_ATTR\s*\(\s*$var\s*,\s*\Q$perms\E\s*,\s*NULL\s*,\s*$store\s*\)/DEVICE_ATTR_WO(${var})/;

				my $newshow = "$show";

 "${var}_show" if ($show ne "NULL" && $show ne "${var}_show");

				my $newstore = $store;

 "${var}_store" if ($store ne "NULL" && $store ne "${var}_store");

				my $rename = "";

				if ($show ne $newshow) {

 " '$show' to '$newshow'";

					$rename .= " '$store' to '$newstore'";

				}

				WARN("DEVICE_ATTR_FUNCTIONS",

				     "Consider renaming function(s)$rename\n" . $herecurr);

			} else {

				WARN("DEVICE_ATTR_PERMS",

				     "DEVICE_ATTR unusual permissions '$perms' used\n" . $herecurr);

			}

		}



# Mode permission misuses where it seems decimal should be octal

# This uses a shortcut match to avoid unnecessary uses of a slow foreach loop

# o Ignore module_param*(...) uses with a decimal 0 permission as that has a

#   specific definition of not visible in sysfs.

# o Ignore proc_create*(...) uses with a decimal 0 permission as that means

#   use the default permissions

		if ($perl_version_ok &&

		    defined $stat &&

~ /$mode_perms_search/) {

				my $func = $entry->[0];

 $entry->[1];

 $stat 
				$lc = $lc + $linenr;

 get_stat_real($linenr, $lc);

				my $skip_args = "";

				if ($arg_pos > 1) {

					$arg_pos--;

 "(?:\\s*$FuncArg\\s*,\\s*){$arg_pos,$arg_pos}";

				my $test = "\\b$func\\s*\\(${skip_args}($FuncArg(?:\\|\\s*$FuncArg)*)\\s*[,\\)]";

~ /$test/) {

					my $val = $1;

 $6 if ($skip_args ne "");

					if (!($func =~ /^(?:module_param|proc_create)/ && $val eq "0") &&

~ /^$Int$/ && $val !~ /^$Octal$/) ||

					     ($val =~ /^$Octal$/ && length($val) ne 4))) {

						ERROR("NON_OCTAL_PERMISSIONS",

						      "Use 4 digit octal (0777) not decimal permissions\n" . "$here\n" . $stat_real);

					}

~ /^$Octal$/ && (oct($val) & 02)) {

 check for uses of S_<PERMS> that could be octal for readability

		while ($line =~ m{\b($multi_mode_perms_string_search)\b}g) {

 $1;

			my $octal = perms_to_octal($oval);

			if (WARN("SYMBOLIC_PERMS",

				 "Symbolic permissions '$oval' are not preferred. Consider using octal permissions '$octal'.\n" . $herecurr) &&

			    $fix) {

~ s/\Q$oval\E/$octal/;

 validate content of MODULE_LICENSE against list from include/linux/module.h

		if ($line =~ /\bMODULE_LICENSE\s*\(\s*($String)\s*\)/) {

 get_quoted_string($line, $rawline);

			my $valid_licenses = qr{

						GPL|

						GPL\ v2|

						GPL\ and\ additional\ rights|

						Dual\ BSD/GPL|

						Dual\ MIT/GPL|

						Dual\ MPL/GPL|

						Proprietary

					}x;

			if ($extracted_string !~ /^"(?:$valid_licenses)"$/x) {

				WARN("MODULE_LICENSE",

				     "unknown module license " . $extracted_string . "\n" . $herecurr);

			}

		}



# check for sysctl duplicate constants

		if ($line =~ /\.extra[12]\s*=\s*&(zero|one|int_max)\b/) {

			WARN("DUPLICATED_SYSCTL_CONST",

				"duplicated sysctl range checking value '$1', consider using the shared one in include/linux/sysctl.h\n" . $herecurr);

		}

	}



	# If we have no input at all, then there is nothing to report on

	# so just keep quiet.

	if ($#rawlines == -1) {

		exit(0);

	}



	# In mailback mode only produce a report in the negative, for

	# things that appear to be patches.

	if ($mailback && ($clean == 1 || !$is_patch)) {

		exit(0);

	}



	# This is not a patch, and we are in 'no-patch' mode so

	# just keep quiet.

	if (!$chk_patch && !$is_patch) {

		exit(0);

	}



	if (!$is_patch && $filename !~ /cover-letter\.patch$/) {

		ERROR("NOT_UNIFIED_DIFF",

		      "Does not appear to be a unified-diff format patch\n");

	}

	if ($is_patch && $has_commit_log && $chk_signoff) {

		if ($signoff == 0) {

			ERROR("MISSING_SIGN_OFF",

			      "Missing Signed-off-by: line(s)\n");

 1) {

 authorsignoff values:

 0 -> missing sign off

 1 -> sign off identical

 2 -> names and addresses match, comments mismatch

 3 -> addresses match, names different

 4 -> names match, addresses different

 5 -> names match, addresses excluding subaddress details (refer RFC 5233) match

 "'From: $author' !
 If there were any defects found and not already fixing them

 If there were whitespace errors which cleanpatch can fix

 then suggest that.

			$rpt_cleaners = 0;

			print << "EOM"



NOTE: Whitespace errors detected.

      You may wish to use scripts/cleanpatch or scripts/cleanfile

EOM

		}

	}



	if ($clean == 0 && $fix &&

	    ("@rawlines" ne "@fixed" ||

	     $#fixed_inserted >= 0 || $#fixed_deleted >= 0)) {

 $filename;

		$newfile .= ".EXPERIMENTAL-checkpatch-fixes" if (!$fix_inplace);

 0;

		@fixed = fix_inserted_deleted_lines(\@fixed, \@fixed_inserted, \@fixed_deleted);



		open($f, '>', $newfile)

		    or die "$P: Can't open $newfile for write\n";

		foreach my $fixed_line (@fixed) {

			$linecount++;

			if ($file) {

				if ($linecount > 3) {

~ s/^\+//;

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0



 Takes a (sorted) output of readprofile and turns it into a list suitable for

 linker scripts



 usage:

	 readprofile | sort -rn | perl profile2linkerlist.pl > functionlist



  my $line = $_;



~ /\W*[0-9]+\W*([a-zA-Z\_0-9]+)\W*[0-9]+/;

~ /unknown/) || ($line 
!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0-only

 Copyright 2008, Intel Corporation



 This file is part of the Linux kernel



 Authors:

 	Arjan van de Ven <arjan@linux.intel.com>

my $cross_compile = "";

 "";

my $modulefile = "";



# Get options

Getopt::Long::GetOptions(

	'cross-compile|c=s'	=> \$cross_compile,

	'module|m=s'		=> \$modulefile,

> \&usage,

my $vmlinux_name = $ARGV[0];

if (!defined($vmlinux_name)) {

 `uname -r`;

	$vmlinux_name = "/lib/modules/$kerver/build/vmlinux";

	print "No vmlinux specified, assuming $vmlinux_name\n";

}

 $vmlinux_name;

 Parse the oops to find the EIP value

my $target = "0";

my $function;

 "";

my $func_offset = 0;

 0;

	my ($line) = @_;

~ /EAX: ([0-9a-f]+) EBX: ([0-9a-f]+) ECX: ([0-9a-f]+) EDX: ([0-9a-f]+)/) {

		$regs{"%eax"} = $1;

 $2;

		$regs{"%ecx"} = $3;

 $4;

	if ($line =~ /ESI: ([0-9a-f]+) EDI: ([0-9a-f]+) EBP: ([0-9a-f]+) ESP: ([0-9a-f]+)/) {

 $1;

		$regs{"%edi"} = $2;

 $4;

	if ($line =~ /RAX: ([0-9a-f]+) RBX: ([0-9a-f]+) RCX: ([0-9a-f]+)/) {

 $1;

		$regs{"%ebx"} = $2;

 $3;

	if ($line =~ /RDX: ([0-9a-f]+) RSI: ([0-9a-f]+) RDI: ([0-9a-f]+)/) {

 $1;

		$regs{"%esi"} = $2;

 $3;

	if ($line =~ /RBP: ([0-9a-f]+) R08: ([0-9a-f]+) R09: ([0-9a-f]+)/) {

 $2;

		$regs{"%r09"} = $3;

	}

~ /R10: ([0-9a-f]+) R11: ([0-9a-f]+) R12: ([0-9a-f]+)/) {

		$regs{"%r10"} = $1;

 $2;

		$regs{"%r12"} = $3;

	}

~ /R13: ([0-9a-f]+) R14: ([0-9a-f]+) R15: ([0-9a-f]+)/) {

		$regs{"%r13"} = $1;

 $2;

		$regs{"%r15"} = $3;

	}

}



sub reg_name

{

 @_;

	$reg =~ s/r(.)x/e\1x/;

~ s/r(.)i/e\1i/;

	$reg =~ s/r(.)p/e\1p/;

	return $reg;

}



sub process_x86_regs

{

 @_;

	my $str = "";

	if (length($line) < 40) {

		return ""; # not an asm istruction

	}



	# find the arguments to the instruction

~ /([0-9a-zA-Z\,\%\(\)\-\+]+)$/) {

		$lastword = $1;

	} else {

		return "";

	}



	# we need to find the registers that get clobbered,

	# since their value is no longer relevant for previous

	# instructions in the stream.



 $lastword;

 first, remove all memory operands, they're read only

	$clobber =~ s/\([a-z0-9\%\,]+\)//g;

	# then, remove everything before the comma, thats the read part

~ s/.*\,//g;

 if this is the instruction that faulted, we haven't actually done

 the write yet... nothing is clobbered.

		$clobber = "";

	}



	foreach $reg (keys(%regs)) {

 reg_name($clobber);

		my $lastwordprime = reg_name($lastword);

 $regs{$reg};

		if ($val =~ /^[0]+$/) {

 "0";

			$val =~ s/^0*//;

		}



		# first check if we're clobbering this register; if we do

 we print it with a =>, and then delete its value

~ /$reg/ || $clobberprime 
 $str . " $reg 
			$regs{$reg} = "";

 "";

 now check if we're reading this register

~ /$reg/ || $lastwordprime 
 $str . " $reg 
 parse the oops

	my $line = $_;

~ /EIP: 0060:\[\<([a-z0-9]+)\>\]/) {

		$target = $1;

	}

~ /RIP: 0010:\[\<([a-z0-9]+)\>\]/) {

		$target = $1;

	}

~ /EIP is at ([a-zA-Z0-9\_]+)\+0x([0-9a-f]+)\/0x[a-f0-9]/) {

		$function = $1;

 $2;

	if ($line =~ /RIP: 0010:\[\<[0-9a-f]+\>\]  \[\<[0-9a-f]+\>\] ([a-zA-Z0-9\_]+)\+0x([0-9a-f]+)\/0x[a-f0-9]/) {

 $1;

		$func_offset = $2;

	}



	# check if it's a module

~ /EIP is at ([a-zA-Z0-9\_]+)\+(0x[0-9a-f]+)\/0x[a-f0-9]+\W\[([a-zA-Z0-9\_\-]+)\]/) {

		$module = $3;

	}

~ /RIP: 0010:\[\<[0-9a-f]+\>\]  \[\<[0-9a-f]+\>\] ([a-zA-Z0-9\_]+)\+(0x[0-9a-f]+)\/0x[a-f0-9]+\W\[([a-zA-Z0-9\_\-]+)\]/) {

		$module = $3;

	}

	parse_x86_regs($line);

}



 Math::BigInt->from_hex("0x$target") - Math::BigInt->from_hex("0x$func_offset");

my $decodestop = Math::BigInt->from_hex("0x$target") + 8192;

if ($target eq "0") {

	print "No oops found!\n";

	usage();

}



# if it's a module, we need to find the .ko file and calculate a load offset

if ($module ne "") {

	if ($modulefile eq "") {

 `modinfo -F filename $module`;

	$filename = $modulefile;

	if ($filename eq "") {

		print "Module .ko file for $module not found. Aborting\n";

		exit;

	}

	# ok so we found the module, now we need to calculate the vma offset

	open(FILE, $cross_compile."objdump -dS $filename |") || die "Cannot start objdump";

	while (<FILE>) {

~ /^([0-9a-f]+) \<$function\>\:/) {

			my $fu = $1;

 Math::BigInt->from_hex("0x$target") - Math::BigInt->from_hex("0x$fu") - Math::BigInt->from_hex("0x$func_offset");

my $counter = 0;

 0;

my $center  = -1;

my @lines;

my @reglines;



sub InRange {

 @_;

	my $ad = "0x".$address;

 "0x".$target;

	my $delta = Math::BigInt->from_hex($ad) - Math::BigInt->from_hex($ta);



	if (($delta > -4096) && ($delta < 4096)) {

		return 1;

	}

	return 0;

}







# first, parse the input into the lines array, but to keep size down,

# we only do this for 4Kb around the sweet spot



$vmaoffset --start-address$decodestop $filename |") || die "Cannot start objdump";

	my $line = $_;

	chomp($line);

	if ($state == 0) {

~ /^([a-f0-9]+)\:/) {

				$state = 1;

			}

		}

	}

	if ($state == 1) {

~ /^([a-f0-9][a-f0-9][a-f0-9][a-f0-9][a-f0-9][a-f0-9]+)\:/) {

			my $val = $1;

			if (!InRange($val, $target)) {

				last;

			}

			if ($val eq $target) {

 $counter;

		$lines[$counter] = $line;



 $counter + 1;

my $codelines = 0;

 0;

 now we go up and down in the array to find how much we want to print

$start = $center;



while ($start > 1) {

 $start - 1;

	my $line = $lines[$start];

~ /^([a-f0-9]+)\:/) {

		$binarylines = $binarylines + 1;

	} else {

 $codelines + 1;

$finish = $center;

 0;

$binarylines = 0;

while ($finish < $counter) {

 $finish + 1;

	my $line = $lines[$finish];

~ /^([a-f0-9]+)\:/) {

		$binarylines = $binarylines + 1;

	} else {

 $codelines + 1;

 start annotating the registers in the asm.

 this goes from the oopsing point back, so that the annotator

 can track (opportunistically) which registers got written and

 whos value no longer is relevant.

$i = $center;

 $start) {

	$reglines[$i] = process_x86_regs($lines[$i], $center - $i);

 $i - 1;

$i = $start;

while ($i < $finish) {

	my $line;

	if ($i == $center) {

  "*$lines[$i] ";

		$line =  " $lines[$i] ";

	}

	print $line;

	if (defined($reglines[$i]) && length($reglines[$i]) > 0) {

 60 - length($line);

		while ($c > 0) { print " "; $c = $c - 1; };

		print "| $reglines[$i]";

	}

	if ($i == $center) {

		print "<--- faulting instruction";

	}

	print "\n";

 $i +1;

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (c) Mauro Carvalho Chehab <mchehab@kernel.org>



 In order to use, you need to:

	1) Download the windows driver with something like:

	Version 2.4

		wget http://www.twinhan.com/files/AW/BDA T/20080303_V1.0.6.7.zip

		or wget http://www.stefanringel.de/pub/20080303_V1.0.6.7.zip

	Version 2.7

		wget http://www.steventoth.net/linux/xc5000/HVR-12x0-14x0-17x0_1_25_25271_WHQL.zip

	2) Extract the files from the zip into the current dir:

		unzip -j 20080303_V1.0.6.7.zip 20080303_v1.0.6.7/UDXTTM6000.sys

		unzip -j HVR-12x0-14x0-17x0_1_25_25271_WHQL.zip Driver85/hcw85bda.sys

	3) run the script:

		./extract_xc3028.pl

	4) copy the generated files:

		cp xc3028-v24.fw /lib/firmware

		cp xc3028-v27.fw /lib/firmware

use strict;

my $debug=0;



sub verify ($$)

{

 @_;

	$testhash = <CMD>;

~ /([a-zA-Z0-9]*)/;

	$testhash = $1;

	close CMD;

		die "Hash of extracted file does not match (found $testhash, expected $hash!\n" if ($testhash ne $hash);

}



sub get_hunk ($$)

{

 @_;

 Calc chunk size

		$chunklength = 2048;

 $length if ($chunklength > $length);

		$rcount = sysread(INFILE, $buf, $chunklength);

 $chunklength);

		$out .= $buf;

 $rcount;

	my $val = shift;

 ($val >> 8) &0xff;

	my $lsb = $val & 0xff;



	syswrite(OUTFILE, chr($lsb).chr($msb));

}



sub write_le32($)

{

 shift;

	my $l3 = ($val >> 24) & 0xff;

 ($val >> 16) & 0xff;

	my $l1 = ($val >> 8)  & 0xff;

 $val         & 0xff;

	my $msb_val = shift;

 shift;

	my $l7 = ($msb_val >> 24) & 0xff;

 ($msb_val >> 16) & 0xff;

	my $l5 = ($msb_val >> 8)  & 0xff;

 $msb_val         & 0xff;

	my $l3 = ($lsb_val >> 24) & 0xff;

 ($lsb_val >> 16) & 0xff;

	my $l1 = ($lsb_val >> 8)  & 0xff;

 $lsb_val         & 0xff;

	my ($offset, $length) = @_;

 get_hunk($offset, $length);

	for (my $i=0;$i<$length;$i++) {

		printf "%02x ",ord(substr($out,$i,1)) if ($debug);

	}

	printf "\n" if ($debug);



	syswrite(OUTFILE, $out);

}



sub write_hunk_fix_endian($$)

{

 @_;

	my $out = get_hunk($offset, $length);



	printf "(len_fix %d) ",$length if ($debug);



0;$i<$length;$i++) {

	my $i=0;

	while ($i<$length) {

 ord(substr($out,$i,1))*256+ord(substr($out,$i+1,1));

		$i+=2;

		if ($size>0 && $size <0x8000) {

0;$j<$size;$j++) {

			$i+=$size;

		}

	}

}



sub main_firmware_24($$$$)

{

	my $out;

0;

	my $outfile = shift;

 shift;

	my $version = shift;

 shift;

	for ($j = length($name); $j <32; $j++) {

 $name.chr(0);



 Firmware 0, type: BASE FW   F8MHZ (0x00000003), id: (0000000000000000), size: 6635



 Type

 ID

 Size



 Firmware 1, type: BASE FW   F8MHZ MTS (0x00000007), id: (0000000000000000), size: 6635



 Type

 ID

 Size



 Firmware 2, type: BASE FW   FM (0x00000401), id: (0000000000000000), size: 6525



 Type

 ID

 Size



 Firmware 3, type: BASE FW   FM INPUT1 (0x00000c01), id: (0000000000000000), size: 6539



 Type

 ID

 Size



 Firmware 4, type: BASE FW   (0x00000001), id: (0000000000000000), size: 6633



 Type

 ID

 Size



 Firmware 5, type: BASE FW   MTS (0x00000005), id: (0000000000000000), size: 6617



 Type

 ID

 Size



 Firmware 6, type: STD FW    (0x00000000), id: PAL/BG A2/A (0000000100000007), size: 161



 Type

 ID

 Size



 Firmware 7, type: STD FW    MTS (0x00000004), id: PAL/BG A2/A (0000000100000007), size: 169



 Type

 ID

 Size



 Firmware 8, type: STD FW    (0x00000000), id: PAL/BG A2/B (0000000200000007), size: 161



 Type

 ID

 Size



 Firmware 9, type: STD FW    MTS (0x00000004), id: PAL/BG A2/B (0000000200000007), size: 169



 Type

 ID

 Size



 Firmware 10, type: STD FW    (0x00000000), id: PAL/BG NICAM/A (0000000400000007), size: 161



 Type

 ID

 Size



 Firmware 11, type: STD FW    MTS (0x00000004), id: PAL/BG NICAM/A (0000000400000007), size: 169



 Type

 ID

 Size



 Firmware 12, type: STD FW    (0x00000000), id: PAL/BG NICAM/B (0000000800000007), size: 161



 Type

 ID

 Size



 Firmware 13, type: STD FW    MTS (0x00000004), id: PAL/BG NICAM/B (0000000800000007), size: 169



 Type

 ID

 Size



 Firmware 14, type: STD FW    (0x00000000), id: PAL/DK A2 (00000003000000e0), size: 161



 Type

 ID

 Size



 Firmware 15, type: STD FW    MTS (0x00000004), id: PAL/DK A2 (00000003000000e0), size: 169



 Type

 ID

 Size



 Firmware 16, type: STD FW    (0x00000000), id: PAL/DK NICAM (0000000c000000e0), size: 161



 Type

 ID

 Size



 Firmware 17, type: STD FW    MTS (0x00000004), id: PAL/DK NICAM (0000000c000000e0), size: 169



 Type

 ID

 Size



 Firmware 18, type: STD FW    (0x00000000), id: SECAM/K1 (0000000000200000), size: 161



 Type

 ID

 Size



 Firmware 19, type: STD FW    MTS (0x00000004), id: SECAM/K1 (0000000000200000), size: 169



 Type

 ID

 Size



 Firmware 20, type: STD FW    (0x00000000), id: SECAM/K3 (0000000004000000), size: 161



 Type

 ID

 Size



 Firmware 21, type: STD FW    MTS (0x00000004), id: SECAM/K3 (0000000004000000), size: 169



 Type

 ID

 Size



 Firmware 22, type: STD FW    D2633 DTV6 ATSC (0x00010030), id: (0000000000000000), size: 149



 Type

 ID

 Size



 Firmware 23, type: STD FW    D2620 DTV6 QAM (0x00000068), id: (0000000000000000), size: 149



 Type

 ID

 Size



 Firmware 24, type: STD FW    D2633 DTV6 QAM (0x00000070), id: (0000000000000000), size: 149



 Type

 ID

 Size



 Firmware 25, type: STD FW    D2620 DTV7 (0x00000088), id: (0000000000000000), size: 149



 Type

 ID

 Size



 Firmware 26, type: STD FW    D2633 DTV7 (0x00000090), id: (0000000000000000), size: 149



 Type

 ID

 Size



 Firmware 27, type: STD FW    D2620 DTV78 (0x00000108), id: (0000000000000000), size: 149



 Type

 ID

 Size



 Firmware 28, type: STD FW    D2633 DTV78 (0x00000110), id: (0000000000000000), size: 149



 Type

 ID

 Size



 Firmware 29, type: STD FW    D2620 DTV8 (0x00000208), id: (0000000000000000), size: 149



 Type

 ID

 Size



 Firmware 30, type: STD FW    D2633 DTV8 (0x00000210), id: (0000000000000000), size: 149



 Type

 ID

 Size



 Firmware 31, type: STD FW    FM (0x00000400), id: (0000000000000000), size: 135



 Type

 ID

 Size



 Firmware 32, type: STD FW    (0x00000000), id: PAL/I (0000000000000010), size: 161



 Type

 ID

 Size



 Firmware 33, type: STD FW    MTS (0x00000004), id: PAL/I (0000000000000010), size: 169



 Type

 ID

 Size



 Firmware 34, type: STD FW    (0x00000000), id: SECAM/L AM (0000001000400000), size: 169





 Firmware 35, type: STD FW    (0x00000000), id: SECAM/L NICAM (0000000c00400000), size: 161



 Type

 ID

 Size



 Firmware 36, type: STD FW    (0x00000000), id: SECAM/Lc (0000000000800000), size: 161



 Type

 ID

 Size



 Firmware 37, type: STD FW    (0x00000000), id: NTSC/M Kr (0000000000008000), size: 161



 Type

 ID

 Size



 Firmware 38, type: STD FW    LCD (0x00001000), id: NTSC/M Kr (0000000000008000), size: 161



 Type

 ID

 Size



 Firmware 39, type: STD FW    LCD NOGD (0x00003000), id: NTSC/M Kr (0000000000008000), size: 161



 Type

 ID

 Size



 Firmware 40, type: STD FW    MTS (0x00000004), id: NTSC/M Kr (0000000000008000), size: 169



 Type

 ID

 Size



 Firmware 41, type: STD FW    (0x00000000), id: NTSC PAL/M PAL/N (000000000000b700), size: 161



 Type

 ID

 Size



 Firmware 42, type: STD FW    LCD (0x00001000), id: NTSC PAL/M PAL/N (000000000000b700), size: 161



 Type

 ID

 Size



 Firmware 43, type: STD FW    LCD NOGD (0x00003000), id: NTSC PAL/M PAL/N (000000000000b700), size: 161



 Type

 ID

 Size



 Firmware 44, type: STD FW    (0x00000000), id: NTSC/M Jp (0000000000002000), size: 161



 Type

 ID

 Size



 Firmware 45, type: STD FW    MTS (0x00000004), id: NTSC PAL/M PAL/N (000000000000b700), size: 169



 Type

 ID

 Size



 Firmware 46, type: STD FW    MTS LCD (0x00001004), id: NTSC PAL/M PAL/N (000000000000b700), size: 169



 Type

 ID

 Size



 Firmware 47, type: STD FW    MTS LCD NOGD (0x00003004), id: NTSC PAL/M PAL/N (000000000000b700), size: 169



 Type

 ID

 Size



	# Firmware 48, type: SCODE FW  HAS IF (0x60000000), IF = 3.28 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(3280);			# IF

	write_le32(192);			# Size

	write_hunk(309048, 192);



	#

 Firmware 49, type: SCODE FW  HAS IF (0x60000000), IF = 3.30 MHz id: (0000000000000000), size: 192



	write_le32(0x60000000);			
	write_le64(0x00000000, 0x00000000);	
	write_le16(3300);			
	write_le32(192);			
	write_hunk(304440, 192);



	# Firmware 50, type: SCODE FW  HAS IF (0x60000000), IF = 3.44 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(3440);			# IF

	write_le32(192);			# Size

	write_hunk(309432, 192);



	#

 Firmware 51, type: SCODE FW  HAS IF (0x60000000), IF = 3.46 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 52, type: SCODE FW  DTV6 ATSC OREN36 HAS IF (0x60210020), IF = 3.80 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60210020);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(3800);			# IF

	write_le32(192);			# Size

	write_hunk(306936, 192);



	#

 Firmware 53, type: SCODE FW  HAS IF (0x60000000), IF = 4.00 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 54, type: SCODE FW  DTV6 ATSC TOYOTA388 HAS IF (0x60410020), IF = 4.08 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60410020);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(4080);			# IF

	write_le32(192);			# Size

	write_hunk(307128, 192);



	#

 Firmware 55, type: SCODE FW  HAS IF (0x60000000), IF = 4.20 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 56, type: SCODE FW  MONO HAS IF (0x60008000), IF = 4.32 MHz id: NTSC/M Kr (0000000000008000), size: 192

	#



	write_le32(0x60008000);			# Type

	write_le64(0x00000000, 0x00008000);	# ID

	write_le16(4320);			# IF

	write_le32(192);			# Size

	write_hunk(305208, 192);



	#

 Firmware 57, type: SCODE FW  HAS IF (0x60000000), IF = 4.45 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 58, type: SCODE FW  MTS LCD NOGD MONO IF HAS IF (0x6002b004), IF = 4.50 MHz id: NTSC PAL/M PAL/N (000000000000b700), size: 192

	#



	write_le32(0x6002b004);			# Type

	write_le64(0x00000000, 0x0000b700);	# ID

	write_le16(4500);			# IF

	write_le32(192);			# Size

	write_hunk(304824, 192);



	#

 Firmware 59, type: SCODE FW  LCD NOGD IF HAS IF (0x60023000), IF = 4.60 MHz id: NTSC/M Kr (0000000000008000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 60, type: SCODE FW  DTV6 QAM DTV7 DTV78 DTV8 ZARLINK456 HAS IF (0x620003e0), IF = 4.76 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x620003e0);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(4760);			# IF

	write_le32(192);			# Size

	write_hunk(304440, 192);



	#

 Firmware 61, type: SCODE FW  HAS IF (0x60000000), IF = 4.94 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 62, type: SCODE FW  HAS IF (0x60000000), IF = 5.26 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(5260);			# IF

	write_le32(192);			# Size

	write_hunk(307704, 192);



	#

 Firmware 63, type: SCODE FW  MONO HAS IF (0x60008000), IF = 5.32 MHz id: PAL/BG A2 NICAM (0000000f00000007), size: 192



 Type

 ID

 IF

 Size



	# Firmware 64, type: SCODE FW  DTV7 DTV78 DTV8 DIBCOM52 CHINA HAS IF (0x65000380), IF = 5.40 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x65000380);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(5400);			# IF

	write_le32(192);			# Size

	write_hunk(304248, 192);



	#

 Firmware 65, type: SCODE FW  DTV6 ATSC OREN538 HAS IF (0x60110020), IF = 5.58 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 66, type: SCODE FW  HAS IF (0x60000000), IF = 5.64 MHz id: PAL/BG A2 (0000000300000007), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x00000003, 0x00000007);	# ID

	write_le16(5640);			# IF

	write_le32(192);			# Size

	write_hunk(305592, 192);



	#

 Firmware 67, type: SCODE FW  HAS IF (0x60000000), IF = 5.74 MHz id: PAL/BG NICAM (0000000c00000007), size: 192



 Type

 ID

 IF

 Size



	# Firmware 68, type: SCODE FW  HAS IF (0x60000000), IF = 5.90 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(5900);			# IF

	write_le32(192);			# Size

	write_hunk(307512, 192);



	#

 Firmware 69, type: SCODE FW  MONO HAS IF (0x60008000), IF = 6.00 MHz id: PAL/DK PAL/I SECAM/K3 SECAM/L SECAM/Lc NICAM (0000000c04c000f0), size: 192



 Type

 ID

 IF

 Size



	# Firmware 70, type: SCODE FW  DTV6 QAM ATSC LG60 F6MHZ HAS IF (0x68050060), IF = 6.20 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x68050060);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(6200);			# IF

	write_le32(192);			# Size

	write_hunk(306552, 192);



	#

 Firmware 71, type: SCODE FW  HAS IF (0x60000000), IF = 6.24 MHz id: PAL/I (0000000000000010), size: 192



 Type

 ID

 IF

 Size



	# Firmware 72, type: SCODE FW  MONO HAS IF (0x60008000), IF = 6.32 MHz id: SECAM/K1 (0000000000200000), size: 192

	#



	write_le32(0x60008000);			# Type

	write_le64(0x00000000, 0x00200000);	# ID

	write_le16(6320);			# IF

	write_le32(192);			# Size

	write_hunk(308472, 192);



	#

 Firmware 73, type: SCODE FW  HAS IF (0x60000000), IF = 6.34 MHz id: SECAM/K1 (0000000000200000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 74, type: SCODE FW  MONO HAS IF (0x60008000), IF = 6.50 MHz id: PAL/DK SECAM/K3 SECAM/L NICAM (0000000c044000e0), size: 192

	#



	write_le32(0x60008000);			# Type

	write_le64(0x0000000c, 0x044000e0);	# ID

	write_le16(6500);			# IF

	write_le32(192);			# Size

	write_hunk(308280, 192);



	#

 Firmware 75, type: SCODE FW  DTV6 ATSC ATI638 HAS IF (0x60090020), IF = 6.58 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 76, type: SCODE FW  HAS IF (0x60000000), IF = 6.60 MHz id: PAL/DK A2 (00000003000000e0), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x00000003, 0x000000e0);	# ID

	write_le16(6600);			# IF

	write_le32(192);			# Size

	write_hunk(306168, 192);



	#

 Firmware 77, type: SCODE FW  MONO HAS IF (0x60008000), IF = 6.68 MHz id: PAL/DK A2 (00000003000000e0), size: 192



 Type

 ID

 IF

 Size



	# Firmware 78, type: SCODE FW  DTV6 ATSC TOYOTA794 HAS IF (0x60810020), IF = 8.14 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60810020);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(8140);			# IF

	write_le32(192);			# Size

	write_hunk(307320, 192);



	#

 Firmware 79, type: SCODE FW  HAS IF (0x60000000), IF = 8.20 MHz id: (0000000000000000), size: 192



	write_le32(0x60000000);			
	write_le64(0x00000000, 0x00000000);	
	write_le16(8200);			
	write_le32(192);			
	write_hunk(308088, 192);

	my $j=0;

 shift;

	my $name    = shift;

 shift;

	my $nr_desc = shift;



 length($name); $j <32; $j++) {

		$name = $name.chr(0);

	}



	open OUTFILE, ">$outfile";

	syswrite(OUTFILE, $name);

	write_le16($version);

	write_le16($nr_desc);



	#

	# Firmware 0, type: BASE FW   F8MHZ (0x00000003), id: (0000000000000000), size: 8718

	#



	write_le32(0x00000003);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(8718);			# Size

	write_hunk_fix_endian(813432, 8718);



	#

	# Firmware 1, type: BASE FW   F8MHZ MTS (0x00000007), id: (0000000000000000), size: 8712

	#



	write_le32(0x00000007);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(8712);			# Size

	write_hunk_fix_endian(822152, 8712);



	#

	# Firmware 2, type: BASE FW   FM (0x00000401), id: (0000000000000000), size: 8562

	#



	write_le32(0x00000401);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(8562);			# Size

	write_hunk_fix_endian(830872, 8562);



	#

	# Firmware 3, type: BASE FW   FM INPUT1 (0x00000c01), id: (0000000000000000), size: 8576

	#



	write_le32(0x00000c01);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(8576);			# Size

	write_hunk_fix_endian(839440, 8576);



	#

	# Firmware 4, type: BASE FW   (0x00000001), id: (0000000000000000), size: 8706

	#



	write_le32(0x00000001);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(8706);			# Size

	write_hunk_fix_endian(848024, 8706);



	#

	# Firmware 5, type: BASE FW   MTS (0x00000005), id: (0000000000000000), size: 8682

	#



	write_le32(0x00000005);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(8682);			# Size

	write_hunk_fix_endian(856736, 8682);



	#

	# Firmware 6, type: STD FW    (0x00000000), id: PAL/BG A2/A (0000000100000007), size: 161

	#



	write_le32(0x00000000);			# Type

	write_le64(0x00000001, 0x00000007);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(865424, 161);



	#

	# Firmware 7, type: STD FW    MTS (0x00000004), id: PAL/BG A2/A (0000000100000007), size: 169

	#



	write_le32(0x00000004);			# Type

	write_le64(0x00000001, 0x00000007);	# ID

	write_le32(169);			# Size

	write_hunk_fix_endian(865592, 169);



	#

	# Firmware 8, type: STD FW    (0x00000000), id: PAL/BG A2/B (0000000200000007), size: 161

	#



	write_le32(0x00000000);			# Type

	write_le64(0x00000002, 0x00000007);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(865424, 161);



	#

	# Firmware 9, type: STD FW    MTS (0x00000004), id: PAL/BG A2/B (0000000200000007), size: 169

	#



	write_le32(0x00000004);			# Type

	write_le64(0x00000002, 0x00000007);	# ID

	write_le32(169);			# Size

	write_hunk_fix_endian(865592, 169);



	#

	# Firmware 10, type: STD FW    (0x00000000), id: PAL/BG NICAM/A (0000000400000007), size: 161

	#



	write_le32(0x00000000);			# Type

	write_le64(0x00000004, 0x00000007);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(866112, 161);



	#

	# Firmware 11, type: STD FW    MTS (0x00000004), id: PAL/BG NICAM/A (0000000400000007), size: 169

	#



	write_le32(0x00000004);			# Type

	write_le64(0x00000004, 0x00000007);	# ID

	write_le32(169);			# Size

	write_hunk_fix_endian(866280, 169);



	#

	# Firmware 12, type: STD FW    (0x00000000), id: PAL/BG NICAM/B (0000000800000007), size: 161

	#



	write_le32(0x00000000);			# Type

	write_le64(0x00000008, 0x00000007);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(866112, 161);



	#

	# Firmware 13, type: STD FW    MTS (0x00000004), id: PAL/BG NICAM/B (0000000800000007), size: 169

	#



	write_le32(0x00000004);			# Type

	write_le64(0x00000008, 0x00000007);	# ID

	write_le32(169);			# Size

	write_hunk_fix_endian(866280, 169);



	#

	# Firmware 14, type: STD FW    (0x00000000), id: PAL/DK A2 (00000003000000e0), size: 161

	#



	write_le32(0x00000000);			# Type

	write_le64(0x00000003, 0x000000e0);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(866800, 161);



	#

	# Firmware 15, type: STD FW    MTS (0x00000004), id: PAL/DK A2 (00000003000000e0), size: 169

	#



	write_le32(0x00000004);			# Type

	write_le64(0x00000003, 0x000000e0);	# ID

	write_le32(169);			# Size

	write_hunk_fix_endian(866968, 169);



	#

	# Firmware 16, type: STD FW    (0x00000000), id: PAL/DK NICAM (0000000c000000e0), size: 161

	#



	write_le32(0x00000000);			# Type

	write_le64(0x0000000c, 0x000000e0);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(867144, 161);



	#

	# Firmware 17, type: STD FW    MTS (0x00000004), id: PAL/DK NICAM (0000000c000000e0), size: 169

	#



	write_le32(0x00000004);			# Type

	write_le64(0x0000000c, 0x000000e0);	# ID

	write_le32(169);			# Size

	write_hunk_fix_endian(867312, 169);



	#

	# Firmware 18, type: STD FW    (0x00000000), id: SECAM/K1 (0000000000200000), size: 161

	#



	write_le32(0x00000000);			# Type

	write_le64(0x00000000, 0x00200000);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(867488, 161);



	#

	# Firmware 19, type: STD FW    MTS (0x00000004), id: SECAM/K1 (0000000000200000), size: 169

	#



	write_le32(0x00000004);			# Type

	write_le64(0x00000000, 0x00200000);	# ID

	write_le32(169);			# Size

	write_hunk_fix_endian(867656, 169);



	#

	# Firmware 20, type: STD FW    (0x00000000), id: SECAM/K3 (0000000004000000), size: 161

	#



	write_le32(0x00000000);			# Type

	write_le64(0x00000000, 0x04000000);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(867832, 161);



	#

	# Firmware 21, type: STD FW    MTS (0x00000004), id: SECAM/K3 (0000000004000000), size: 169

	#



	write_le32(0x00000004);			# Type

	write_le64(0x00000000, 0x04000000);	# ID

	write_le32(169);			# Size

	write_hunk_fix_endian(868000, 169);



	#

	# Firmware 22, type: STD FW    D2633 DTV6 ATSC (0x00010030), id: (0000000000000000), size: 149

	#



	write_le32(0x00010030);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(149);			# Size

	write_hunk_fix_endian(868176, 149);



	#

	# Firmware 23, type: STD FW    D2620 DTV6 QAM (0x00000068), id: (0000000000000000), size: 149

	#



	write_le32(0x00000068);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(149);			# Size

	write_hunk_fix_endian(868336, 149);



	#

	# Firmware 24, type: STD FW    D2633 DTV6 QAM (0x00000070), id: (0000000000000000), size: 149

	#



	write_le32(0x00000070);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(149);			# Size

	write_hunk_fix_endian(868488, 149);



	#

	# Firmware 25, type: STD FW    D2620 DTV7 (0x00000088), id: (0000000000000000), size: 149

	#



	write_le32(0x00000088);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(149);			# Size

	write_hunk_fix_endian(868648, 149);



	#

	# Firmware 26, type: STD FW    D2633 DTV7 (0x00000090), id: (0000000000000000), size: 149

	#



	write_le32(0x00000090);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(149);			# Size

	write_hunk_fix_endian(868800, 149);



	#

	# Firmware 27, type: STD FW    D2620 DTV78 (0x00000108), id: (0000000000000000), size: 149

	#



	write_le32(0x00000108);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(149);			# Size

	write_hunk_fix_endian(868960, 149);



	#

	# Firmware 28, type: STD FW    D2633 DTV78 (0x00000110), id: (0000000000000000), size: 149

	#



	write_le32(0x00000110);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(149);			# Size

	write_hunk_fix_endian(869112, 149);



	#

	# Firmware 29, type: STD FW    D2620 DTV8 (0x00000208), id: (0000000000000000), size: 149

	#



	write_le32(0x00000208);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(149);			# Size

	write_hunk_fix_endian(868648, 149);



	#

	# Firmware 30, type: STD FW    D2633 DTV8 (0x00000210), id: (0000000000000000), size: 149

	#



	write_le32(0x00000210);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(149);			# Size

	write_hunk_fix_endian(868800, 149);



	#

	# Firmware 31, type: STD FW    FM (0x00000400), id: (0000000000000000), size: 135

	#



	write_le32(0x00000400);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le32(135);			# Size

	write_hunk_fix_endian(869584, 135);



	#

	# Firmware 32, type: STD FW    (0x00000000), id: PAL/I (0000000000000010), size: 161

	#



	write_le32(0x00000000);			# Type

	write_le64(0x00000000, 0x00000010);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(869728, 161);



	#

	# Firmware 33, type: STD FW    MTS (0x00000004), id: PAL/I (0000000000000010), size: 169

	#



	write_le32(0x00000004);			# Type

	write_le64(0x00000000, 0x00000010);	# ID

	write_le32(169);			# Size

	write_hunk_fix_endian(869896, 169);



	#

	# Firmware 34, type: STD FW    (0x00000000), id: SECAM/L AM (0000001000400000), size: 169

	#



	write_le32(0x00000000);			# Type

	write_le64(0x00000010, 0x00400000);	# ID

	write_le32(169);			# Size

	write_hunk_fix_endian(870072, 169);



	#

	# Firmware 35, type: STD FW    (0x00000000), id: SECAM/L NICAM (0000000c00400000), size: 161

	#



	write_le32(0x00000000);			# Type

	write_le64(0x0000000c, 0x00400000);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(870248, 161);



	#

	# Firmware 36, type: STD FW    (0x00000000), id: SECAM/Lc (0000000000800000), size: 161

	#



	write_le32(0x00000000);			# Type

	write_le64(0x00000000, 0x00800000);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(870416, 161);



	#

	# Firmware 37, type: STD FW    (0x00000000), id: NTSC/M Kr (0000000000008000), size: 161

	#



	write_le32(0x00000000);			# Type

	write_le64(0x00000000, 0x00008000);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(870584, 161);



	#

	# Firmware 38, type: STD FW    LCD (0x00001000), id: NTSC/M Kr (0000000000008000), size: 161

	#



	write_le32(0x00001000);			# Type

	write_le64(0x00000000, 0x00008000);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(870752, 161);



	#

	# Firmware 39, type: STD FW    LCD NOGD (0x00003000), id: NTSC/M Kr (0000000000008000), size: 161

	#



	write_le32(0x00003000);			# Type

	write_le64(0x00000000, 0x00008000);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(870920, 161);



	#

	# Firmware 40, type: STD FW    MTS (0x00000004), id: NTSC/M Kr (0000000000008000), size: 169

	#



	write_le32(0x00000004);			# Type

	write_le64(0x00000000, 0x00008000);	# ID

	write_le32(169);			# Size

	write_hunk_fix_endian(871088, 169);



	#

	# Firmware 41, type: STD FW    (0x00000000), id: NTSC PAL/M PAL/N (000000000000b700), size: 161

	#



	write_le32(0x00000000);			# Type

	write_le64(0x00000000, 0x0000b700);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(871264, 161);



	#

	# Firmware 42, type: STD FW    LCD (0x00001000), id: NTSC PAL/M PAL/N (000000000000b700), size: 161

	#



	write_le32(0x00001000);			# Type

	write_le64(0x00000000, 0x0000b700);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(871432, 161);



	#

	# Firmware 43, type: STD FW    LCD NOGD (0x00003000), id: NTSC PAL/M PAL/N (000000000000b700), size: 161

	#



	write_le32(0x00003000);			# Type

	write_le64(0x00000000, 0x0000b700);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(871600, 161);



	#

	# Firmware 44, type: STD FW    (0x00000000), id: NTSC/M Jp (0000000000002000), size: 161

	#



	write_le32(0x00000000);			# Type

	write_le64(0x00000000, 0x00002000);	# ID

	write_le32(161);			# Size

	write_hunk_fix_endian(871264, 161);



	#

	# Firmware 45, type: STD FW    MTS (0x00000004), id: NTSC PAL/M PAL/N (000000000000b700), size: 169

	#



	write_le32(0x00000004);			# Type

	write_le64(0x00000000, 0x0000b700);	# ID

	write_le32(169);			# Size

	write_hunk_fix_endian(871936, 169);



	#

	# Firmware 46, type: STD FW    MTS LCD (0x00001004), id: NTSC PAL/M PAL/N (000000000000b700), size: 169

	#



	write_le32(0x00001004);			# Type

	write_le64(0x00000000, 0x0000b700);	# ID

	write_le32(169);			# Size

	write_hunk_fix_endian(872112, 169);



	#

	# Firmware 47, type: STD FW    MTS LCD NOGD (0x00003004), id: NTSC PAL/M PAL/N (000000000000b700), size: 169

	#



	write_le32(0x00003004);			# Type

	write_le64(0x00000000, 0x0000b700);	# ID

	write_le32(169);			# Size

	write_hunk_fix_endian(872288, 169);



	#

 Firmware 48, type: SCODE FW  HAS IF (0x60000000), IF = 3.28 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 49, type: SCODE FW  HAS IF (0x60000000), IF = 3.30 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(3300);			# IF

	write_le32(192);			# Size

	write_hunk(813048, 192);



	#

 Firmware 50, type: SCODE FW  HAS IF (0x60000000), IF = 3.44 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 51, type: SCODE FW  HAS IF (0x60000000), IF = 3.46 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(3460);			# IF

	write_le32(192);			# Size

	write_hunk(812472, 192);



	#

 Firmware 52, type: SCODE FW  DTV6 ATSC OREN36 HAS IF (0x60210020), IF = 3.80 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 53, type: SCODE FW  HAS IF (0x60000000), IF = 4.00 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(4000);			# IF

	write_le32(192);			# Size

	write_hunk(812088, 192);



	#

 Firmware 54, type: SCODE FW  DTV6 ATSC TOYOTA388 HAS IF (0x60410020), IF = 4.08 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 55, type: SCODE FW  HAS IF (0x60000000), IF = 4.20 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(4200);			# IF

	write_le32(192);			# Size

	write_hunk(811704, 192);



	#

 Firmware 56, type: SCODE FW  MONO HAS IF (0x60008000), IF = 4.32 MHz id: NTSC/M Kr (0000000000008000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 57, type: SCODE FW  HAS IF (0x60000000), IF = 4.45 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(4450);			# IF

	write_le32(192);			# Size

	write_hunk(812664, 192);



	#

 Firmware 58, type: SCODE FW  MTS LCD NOGD MONO IF HAS IF (0x6002b004), IF = 4.50 MHz id: NTSC PAL/M PAL/N (000000000000b700), size: 192



 Type

 ID

 IF

 Size



	# Firmware 59, type: SCODE FW  LCD NOGD IF HAS IF (0x60023000), IF = 4.60 MHz id: NTSC/M Kr (0000000000008000), size: 192

	#



	write_le32(0x60023000);			# Type

	write_le64(0x00000000, 0x00008000);	# ID

	write_le16(4600);			# IF

	write_le32(192);			# Size

	write_hunk(807864, 192);



	#

 Firmware 60, type: SCODE FW  DTV6 QAM DTV7 DTV78 DTV8 ZARLINK456 HAS IF (0x620003e0), IF = 4.76 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 61, type: SCODE FW  HAS IF (0x60000000), IF = 4.94 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(4940);			# IF

	write_le32(192);			# Size

	write_hunk(811512, 192);



	#

 Firmware 62, type: SCODE FW  HAS IF (0x60000000), IF = 5.26 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 63, type: SCODE FW  MONO HAS IF (0x60008000), IF = 5.32 MHz id: PAL/BG A2 NICAM (0000000f00000007), size: 192

	#



	write_le32(0x60008000);			# Type

	write_le64(0x0000000f, 0x00000007);	# ID

	write_le16(5320);			# IF

	write_le32(192);			# Size

	write_hunk(810744, 192);



	#

 Firmware 64, type: SCODE FW  DTV7 DTV78 DTV8 DIBCOM52 CHINA HAS IF (0x65000380), IF = 5.40 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 65, type: SCODE FW  DTV6 ATSC OREN538 HAS IF (0x60110020), IF = 5.58 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60110020);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(5580);			# IF

	write_le32(192);			# Size

	write_hunk(809592, 192);



	#

 Firmware 66, type: SCODE FW  HAS IF (0x60000000), IF = 5.64 MHz id: PAL/BG A2 (0000000300000007), size: 192



 Type

 ID

 IF

 Size



	# Firmware 67, type: SCODE FW  HAS IF (0x60000000), IF = 5.74 MHz id: PAL/BG NICAM (0000000c00000007), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x0000000c, 0x00000007);	# ID

	write_le16(5740);			# IF

	write_le32(192);			# Size

	write_hunk(808632, 192);



	#

 Firmware 68, type: SCODE FW  HAS IF (0x60000000), IF = 5.90 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 69, type: SCODE FW  MONO HAS IF (0x60008000), IF = 6.00 MHz id: PAL/DK PAL/I SECAM/K3 SECAM/L SECAM/Lc NICAM (0000000c04c000f0), size: 192

	#



	write_le32(0x60008000);			# Type

	write_le64(0x0000000c, 0x04c000f0);	# ID

	write_le16(6000);			# IF

	write_le32(192);			# Size

	write_hunk(808824, 192);



	#

 Firmware 70, type: SCODE FW  DTV6 QAM ATSC LG60 F6MHZ HAS IF (0x68050060), IF = 6.20 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 71, type: SCODE FW  HAS IF (0x60000000), IF = 6.24 MHz id: PAL/I (0000000000000010), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x00000000, 0x00000010);	# ID

	write_le16(6240);			# IF

	write_le32(192);			# Size

	write_hunk(808248, 192);



	#

 Firmware 72, type: SCODE FW  MONO HAS IF (0x60008000), IF = 6.32 MHz id: SECAM/K1 (0000000000200000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 73, type: SCODE FW  HAS IF (0x60000000), IF = 6.34 MHz id: SECAM/K1 (0000000000200000), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x00000000, 0x00200000);	# ID

	write_le16(6340);			# IF

	write_le32(192);			# Size

	write_hunk(809208, 192);



	#

 Firmware 74, type: SCODE FW  MONO HAS IF (0x60008000), IF = 6.50 MHz id: PAL/DK SECAM/K3 SECAM/L NICAM (0000000c044000e0), size: 192



 Type

 ID

 IF

 Size



	# Firmware 75, type: SCODE FW  DTV6 ATSC ATI638 HAS IF (0x60090020), IF = 6.58 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60090020);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(6580);			# IF

	write_le32(192);			# Size

	write_hunk(807480, 192);



	#

 Firmware 76, type: SCODE FW  HAS IF (0x60000000), IF = 6.60 MHz id: PAL/DK A2 (00000003000000e0), size: 192



 Type

 ID

 IF

 Size



	# Firmware 77, type: SCODE FW  MONO HAS IF (0x60008000), IF = 6.68 MHz id: PAL/DK A2 (00000003000000e0), size: 192

	#



	write_le32(0x60008000);			# Type

	write_le64(0x00000003, 0x000000e0);	# ID

	write_le16(6680);			# IF

	write_le32(192);			# Size

	write_hunk(810936, 192);



	#

 Firmware 78, type: SCODE FW  DTV6 ATSC TOYOTA794 HAS IF (0x60810020), IF = 8.14 MHz id: (0000000000000000), size: 192



 Type

 ID

 IF

 Size



	# Firmware 79, type: SCODE FW  HAS IF (0x60000000), IF = 8.20 MHz id: (0000000000000000), size: 192

	#



	write_le32(0x60000000);			# Type

	write_le64(0x00000000, 0x00000000);	# ID

	write_le16(8200);			# IF

	write_le32(192);			# Size

	write_hunk(812856, 192);

}





sub extract_firmware {

 "UDXTTM6000.sys";

	my $hash_24 = "cb9deb5508a5e150af2880f5b0066d78";

 "xc3028-v24.fw";

	my $name_24 = "xc2028 firmware";

 516;

	my $nr_desc_24 = 77;

	my $out;



 "hcw85bda.sys";

	my $hash_27 = "0e44dbf63bb0169d57446aec21881ff2";

 "xc3028-v27.fw";

	my $name_27 = "xc2028 firmware";

 519;

	my $nr_desc_27 = 80;

	my $out;



	if (-e $sourcefile_24) {

		verify($sourcefile_24, $hash_24);



		open INFILE, "<$sourcefile_24";

		main_firmware_24($outfile_24, $name_24, $version_24, $nr_desc_24);

		close INFILE;

	}



	if (-e $sourcefile_27) {

		verify($sourcefile_27, $hash_27);



		open INFILE, "<$sourcefile_27";

		main_firmware_27($outfile_27, $name_27, $version_27, $nr_desc_27);

		close INFILE;

	}

}



extract_firmware;

printf "Firmwares generated.\n";

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0



 checkdeclares: find struct declared more than once



 Copyright 2021 Wan Jiabing<wanjiabing@vivo.com>

 Inspired by checkincludes.pl



 This script checks for duplicate struct declares.

 Note that this will not take into consideration macros so

 you should run this only if you know you do have real dups

 and do not have them under 
 You could also just review the results.

ARGV < 0) {

my $dup_counter = 0;



foreach my $file (@ARGV) {

	open(my $f, '<', $file)

	    or die "Cannot open $file: $!.\n";



 ();

! /usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0



 Detect cycles in the header file dependency graph

 Vegard Nossum <vegardno@ifi.uio.no>



	help	=> \&help,

> \&version,

	all	=> \$opt_all,

	"I=s"	=> \@opt_include,

> \$opt_graph,

my %deps = ();

 ();

my @headers = grep { strip($_) } @ARGV;



parse_all(@headers);



if($opt_graph) {

	graph();

} else {

	detect_cycles(@headers);

}





sub help {

	print "Usage: $0 [options] file...\n";

	print "\n";

	print "Options:\n";

	print "  --all\n";

	print "  --graph\n";

	print "\n";

	print "  -I includedir\n";

	print "\n";

	print "To make nice graphs, try:\n";

	print "  $0 --graph include/linux/kernel.h | dot -Tpng -o graph.png\n";

	exit;

}



sub version {

	print "headerdep version 2\n";

	exit;

}



# Get a file name that is relative to our include paths

sub strip {

 shift;

		my $stripped = $filename;

~ s/^$i\///;

 Search for the file name in the list of include paths

	my $filename = shift;

	return $filename if -f $filename;



	for my $i (@opt_include) {

 "$i/$filename";

 Parse all the headers.

	my @queue = @_;

	while(@queue) {

 pop @queue;

		$deps{$header} = [] unless exists $deps{$header};



 search($header);

		chomp(my @lines = <$file>);

		close($file);



		for my $i (0 .. $#lines) {

 $lines[$i];

\s*include\s*<(.*?)>/)) {
~ m/^#\s*include\s*<(.*?)>/)) {

 $cycle[n] includes $cycle[n + 1];

 $cycle[-1] will be the culprit

	my $cycle = shift;



	# Adjust the line numbers

	for my $i (0 .. $#$cycle - 1) {

 $cycle->[$i + 1]->[0];

	$cycle->[-1]->[0] = 0;



 shift @$cycle;

	my $last = pop @$cycle;



 "In file included";

 Find and print the smallest cycle starting in the specified node.

	my @queue = map { [[0, $_]] } @_;

	while(@queue) {

 pop @queue;

		my $name = $top->[-1]->[1];



		for my $dep (@{$deps{$name}}) {

 [@$top, [$dep->[0], $dep->[1]]];

 If the dep already exists in the chain, we have a

 cycle...

	$_ = shift;

	s/\//__/g;

	s/\./_/g;

	s/-/_/g;

	$_;

}



# Output dependency graph in GraphViz language.

sub graph {

	print "digraph {\n";



	print "\t/* vertices */\n";

	for my $header (keys %deps) {

\"%s\"];\n",

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0

	Check the stack usage of functions



	Copyright Joern Engel <joern@lazybastard.org>

	Inspired by Linus Torvalds

	Original idea maybe from Keith Owens

	s390 port and big speedup by Arnd Bergmann <arnd@bergmann-dalldorf.de>

	Mips port by Juan Quintela <quintela@mandrakesoft.com>

	IA64 port via Andreas Dilger

	Arm port by Holger Schurig

	sh64 port by Paul Mundt

	Random bits by Matt Mackall <mpm@selenic.com>

	M68k port by Geert Uytterhoeven and Andreas Schwab

	AArch64, PARISC ports by Kyle McMartin

	sparc port by Martin Habets <errandir_news@mph.eclipse.co.uk>

	ppc64le port by Breno Leitao <leitao@debian.org>



	Usage:

	objdump -d vmlinux | scripts/checkstack.pl [arch]



	TODO :	Port to all architectures (one regex per arch)

 check for arch



 $re is used for two matches:

 $& (whole re) matches the complete objdump line with the stack growth

 $1 (first bracket) matches the size of the stack growth



 $dre is similar, but for dynamic stack redutions:

 $& (whole re) matches the complete objdump line with the stack growth

 $1 (first bracket) matches the dynamic amount of the stack growth



 $sub: subroutine for special handling to check stack usage.



 use anything else and feel the pain ;)

	my $arch = shift;

	if ($arch eq "") {

 `uname -m`;

	$min_stack = shift;

	if ($min_stack eq "" || $min_stack !~ /^\d+$/) {

 100;

	$x	= "[0-9a-f]";	# hex character

 hex character or space

	$funcre = qr/^$x* <(.*)>:$/;

~ '^(aarch|arm)64$') {

ffffffc0006325cc:       a9bb7bfd        stp     x29, x30, [sp, 
a110:       d11643ff        sub     sp, sp, 
		$re = qr/^.*stp.*sp, \#-([0-9]{1,8})\]\!/o;

(0x$x{1,8})/o;

c0008ffc:	e24dd064	sub	sp, sp, 
		$re = qr/.*sub.*sp, sp, #([0-9]{1,4})/o;

 \&arm_push_handling;

~ /^x86(_64)?$/ || $arch 
c0105234:       81 ec ac 05 00 00       sub    $0x5ac,%esp

 or

    2f60:    48 81 ec e8 05 00 00       sub    $0x5e8,%rsp

		$re = qr/^.*[as][du][db]    \$(0x$x{1,8}),\%(e|r)sp$/o;

 qr/^.*[as][du][db]    (%.*),\%(e|r)sp$/o;

		#e0000000044011fc:       01 0f fc 8c     adds r12=-384,r12

		$re = qr/.*adds.*r12=-(([0-9]{2}|[3-9])[0-9]{2}),r12/o;

	} elsif ($arch eq 'm68k') {

		#    2b6c:       4e56 fb70       linkw %fp,#-1168

		#  1df770:       defc ffe4       addaw #-28,%sp

-([0-9]{1,4})(?:,%sp)?$/o;

8800402c:       67bdfff0        daddiu  sp,sp,-16

		$re = qr/.*daddiu.*sp,sp,-(([0-9]{2}|[3-9])[0-9]{2})/o;

	} elsif ($arch eq 'mips') {

		#88003254:       27bdffe0        addiu   sp,sp,-32

 qr/.*addiu.*sp,sp,-(([0-9]{2}|[3-9])[0-9]{2})/o;

25a8:	defffb04 	addi	sp,sp,-20

		$re = qr/.*addi.*sp,sp,-(([0-9]{2}|[3-9])[0-9]{2})/o;

	} elsif ($arch eq 'openrisc') {

		# c000043c:       9c 21 fe f0     l.addi r1,r1,-272

 qr/.*l\.addi.*r1,r1,-(([0-9]{2}|[3-9])[0-9]{2})/o;

		$re = qr/.*ldo ($x{1,8})\(sp\),sp/o;

~ /^ppc(64)?(le)?$/ ) {

 powerpc    : 94 21 ff 30     stwu    r1,-208(r1)

 ppc64(le)  : 81 ff 21 f8     stdu    r1,-128(r1)

		$re = qr/.*st[dw]u.*r1,-($x{1,8})\(r1\)/o;

~ /^s390x?$/) {

   11160:       a7 fb ff 60             aghi   %r15,-160

 or

  100092:	 e3 f0 ff c8 ff 71	 lay	 %r15,-56(%r15)

		$re = qr/.*(?:lay|ag?hi).*\%r15,-(([0-9]{2}|[3-9])[0-9]{2})

		      (?:\(\%r15\))?$/ox;

~ /^sh64$/) {

XXX: we only check for the immediate case presently,

     though we will want to check for the movi/sub

     pair for larger users. -- PFM.

a00048e0:       d4fc40f0        addi.l  r15,-240,r15

		$re = qr/.*addi\.l.*r15,-(([0-9]{2}|[3-9])[0-9]{2}),r15/o;

	} elsif ($arch eq 'sparc' || $arch eq 'sparc64') {

		# f0019d10:       9d e3 bf 90     save  %sp, -112, %sp

 qr/.*save.*%sp, -(([0-9]{2}|[3-9])[0-9]{2}), %sp/o;



 To count stack usage of push {*, fp, ip, lr, pc} instruction in ARM,

 if FRAME POINTER is enabled.

 e.g. c01f0d48: e92ddff0 push {r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}



	my $regex = qr/.*push.*fp, ip, lr, pc}/o;

 0;

	my $line_arg = shift;



~ m/$regex/) {

 $line_arg 
		$size = ($size + 1) * 4;

	}



	return $size;

}



#

# main()

#

my ($func, $file, $lastslash, $total_size, $addr, $intro);



 0;

while (my $line = <STDIN>) {

~ m/$funcre/) {

		$func = $1;

		next if $line !~ m/^($xs*)/;

		if ($total_size > $min_stack) {

			push @stack, "$intro$total_size\n";

		}



 $1;

		$addr =~ s/ /0/g;

 "0x$addr";

		$intro = "$addr $func [$file]:";

 56 - length($intro);

			$intro .= '	';

 8;

		$total_size = 0;

	}

~ m/(.*):\s*file format/) {

		$file = $1;

~ s/\.ko//;

		$lastslash = rindex($file, "/");

 -1) {

			$file = substr($file, $lastslash + 1);

		}

	}

~ m/$re/) {

		my $size = $1;

		$size = hex($size) if ($size =~ /^0x/);



		if ($size > 0xf0000000) {

 - $size;

			$size += 0x80000000;

 0x80000000;

		$total_size += $size;

	}

~ m/$dre/) {

		my $size = $1;



		$size = hex($size) if ($size =~ /^0x/);

 $size;

		my $size = &$sub($line);



 $size;

 Sort output by size (last field)

print sort { ($b =~ /:\t*(\d+)$/)[0] <=> ($a =~ /:\t*(\d+)$/)[0] } @stack;

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0

BEGIN { $Pod::Usage::Formatter = 'Pod::Text::Termcap'; }



use strict;

use warnings;

use utf8;

use Pod::Usage qw(pod2usage);

use Getopt::Long;

use File::Find;

use IO::Handle;

use Fcntl ':mode';

use Cwd 'abs_path';

use Data::Dumper;



 0;

my $hint = 0;

 0;

my $debug = 0;

 0;

my $show_warnings = 1;

"Documentation/ABI";

my $sysfs_prefix="/sys";

my $search_string;



# Debug options

 1;

my $dbg_what_open = 2;

 4;

my $dbg_undefined = 8;



 1;

$Data::Dumper::Terse = 1;



#

# If true, assumes that the description is formatted with ReST

#

 1;

i" 
	"enable-lineno" => \$enable_lineno,

> \$description_is_rst,

s" 
	'help|?' => \$help,

> \$hint,

s" 
	man => \$man

) or pod2usage(2);



pod2usage(1) if $help;

pod2usage(-exitstatus => 0, -noperldoc, -verbose => 2) if $man;



pod2usage(2) if (scalar @ARGV < 1 || @ARGV > 2);



 @ARGV;



 Displays an error message, printing file name and line



	my ($file, $ln, $msg, $data) = @_;



	return if (!$show_warnings);



~ s/\s+$/\n/;

$ln:\n\t$msg";



 Parse an ABI file, storing its contents at %data



	my $file = $File::Find::name;



 (stat($file))[2];

	return if ($file =~ m,/README,);



 $file;

	$name =~ s,.*/,,;



 $file;

	$fn =~ s,Documentation/ABI/,,;



 "File $fn";

	$data{$nametag}->{what} = "File $name";

 "File";

	$data{$nametag}->{file} = $name;

 $file;

	$data{$nametag}->{is_file} = 1;

 1;

	my $type = $file;

~ s,.*/(.*)/.*,$1,;

	my $tag = "";

	my $ln;

	my $xrefs;

	my $space;

	my @labels;

 "";

			my $new_tag = lc($1);

 $2;

			my $content = $3;



~ m/(what|where|date|kernelversion|contact|description|users)/)) {

 New "tag" is actually part of

 description. Don't consider it a tag

					$new_tag = "";

				} elsif ($tag ne "") {

					parse_error($file, $ln, "tag '$tag' is invalid", $_);

				}

			}



			# Invalid, but it is a common mistake

			if ($new_tag eq "where") {

				parse_error($file, $ln, "tag 'Where' is invalid. Should be 'What:' instead", "");

 "what";

			if ($new_tag =~ m/what/) {

 "";

				$content =~ s/[,.;]$//;



				push @{$symbols{$content}->{file}}, " $file:" . ($ln - 1);



~ m/what/) {

					$what .= "\xac" . $content;

				} else {

					if ($what) {

						parse_error($file, $ln, "What '$what' doesn't have a description", "") if (!$data{$what}->{description});



						foreach my $w(split /\xac/, $what) {

 $what;

					$what = $content;

 $content;

					$new_what = 1;

				}

				push @labels, [($content, $label)];

 $new_tag;

				$tag = $new_tag;



				if ($new_what) {

 @labels if ($data{$nametag}->{what});

					@labels = ();

 "";

					$new_what = 0;



 $type;

						$data{$what}->{file} = $name;

 $file;

						$data{$what}->{description} .= "\n\n" if (defined($data{$what}->{description}));

						if ($name ne $data{$what}->{file}) {

 " " . $name;

							$data{$what}->{filepath} .= " " . $file;

						}

					}

					print STDERR "\twhat: $what\n" if ($debug & $dbg_what_parsing);

 $ln;

					$data{$what}->{line_no} = $ln if (!defined($data{$what}->{line_no}));

				}



				if (!$what) {

					parse_error($file, $ln, "'What:' should come first:", $_);

					next;

				}

				if ($new_tag eq "description") {

~ s,:, ,;

					$content = ' ' x length($new_tag) . $sep . $content;

~ s/\t+/' ' x (length($&) * 8 - length($`) % 8)/e) {}

					if ($content =~ m/^(\s*)(\S.*)$/) {

						# Preserve initial spaces for the first line

 $1;

						$content = "$2\n";

 $content;

					$data{$what}->{$tag} = $content;

				}

				next;

			}

		}



		# Store any contents before tags at the database

		if (!$tag && $data{$nametag}->{what}) {

 $_;

			my $content = $_;

~ s/\t+/' ' x (length($&) * 8 - length($`) % 8)/e) {}

				$data{$what}->{$tag} .= "\n";

				next;

			}



			if (!defined($space)) {

				# Preserve initial spaces for the first line

~ m/^(\s*)(\S.*)$/) {

					$space = $1;

 "$2\n";

 "" if (!($content 
			$data{$what}->{$tag} .= $content;



			next;

		}

		if (m/^\s*(.*)/) {

 "\n$1";

			$data{$what}->{$tag} =~ s/\n+$//;

			next;

		}



		# Everything else is error

		parse_error($file, $ln, "Unexpected content", $_);

	}

~ s/^\n+// if ($data{$nametag}->{description});

			$symbols{$w}->{xref} = $what;

		};

	}

	close IN;

}



sub create_labels {

	my %labels;



	foreach my $what (keys %data) {

		next if ($data{$what}->{file} eq "File");



		foreach my $p (@{$data{$what}->{label_list}}) {

 @{$p};

			$label = "abi_" . $label . " ";

~ tr/A-Z/a-z/;

 Convert special chars to "_"

			$label =~s/([\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xff])/_/g;

~ s,_+,_,g;

			$label =~ s,_$,,;



			# Avoid duplicated labels

			while (defined($labels{$label})) {

 ("A".."Z", "a".."z");

			    $label .= $chars[rand @chars];

			}

 1;

			$data{$what}->{label} = $label;



			# only one label is enough

			last;

		}

	}

}



#

# Outputs the book on ReST format

#



# \b doesn't work well with paths. So, we need to define something else:

# Boundaries are punct characters, spaces and end-of-line

 qr {(^|\s|\() }x;

my $bondary = qr { ([,.:;\)\s]|\z) }x;

 qr { $start(\/(sys|config|proc|dev|kvd)\/[^,.:;\)\s]+)$bondary }x;

my $symbols = qr { ([\x01-\x08\x0e-\x1f\x21-\x2f\x3a-\x40\x7b-\xff]) }x;



sub output_rest {

	create_labels();



 "";

		my $type = $data{$what}->{type};



 split / /, $data{$what}->{file};

		my @filepath = split / /, $data{$what}->{filepath};



		if ($enable_lineno) {

			printf "#define LINENO %s%s#%s\n\n",

			       $prefix, $file[0],

			       $data{$what}->{line_no};

		}



 $what;

			my $cur_part = $what;

~ '/') {

				if ($what =~ m#^(\/?(?:[\w\-]+\/?){1,2})#) {

 "Symbols under $1";

					$cur_part =~ s,/$,,;

				}

			}



			if ($cur_part ne "" && $part ne $cur_part) {

 $cur_part;

			    my $bar = $part;

~ s/./-/g;

			my @names = split /\xac/,$w;

 0;

				$name =~ s/$symbols/\\$1/g;

 "**$name**";

				$len = length($name) if (length($name) > $len);

			}



			print "+-" . "-" x $len . "-+\n";

			foreach my $name (@names) {

				printf "| %s", $name . " " x ($len - length($name)) . " |\n";

				print "+-" . "-" x $len . "-+\n";

			}



			print "\n";

		}



 0; $i < scalar(@filepath); $i++) {

			my $path = $filepath[$i];

 $file[$i];

			$path =~ s,.*/(.*/.*),$1,;;

~ s,[/\-],_,g;;

			my $fileref = "abi_file_".$path;



			if ($type eq "File") {

				print ".. _$fileref:\n\n";

			} else {

				print "Defined on file :ref:`$f <$fileref>`\n\n";

			}

		}



		if ($type eq "File") {

 $w;

			$bar =~ s/./-/g;

			print "$w\n$bar\n\n";

		}



 "";

		$desc = $data{$what}->{description} if (defined($data{$what}->{description}));

~ s/\s+$/\n/;

		if (!($desc =~ /^\s*$/)) {

			if ($description_is_rst) {

				# Remove title markups from the description

				# Having titles inside ABI files will only work if extra

				# care would be taken in order to strictly follow the same

				# level order for each markup.

				$desc =~ s/\n[\-\*\=\^\~]+\n/\n\n/g;



				# Enrich text by creating cross-references



 "";

				my $init_indent = -1;

 -1;

				while (my $d = <$fh>) {

					my $indent = $d =~ m/^(\s+)/;

 length($indent);

					$init_indent = $indent if ($init_indent < 0);

 0) {

							$new_desc .= $d;

							next;

						} else {

 -1;

~ /()::$/ && !($d 
							$literal_indent = $spaces;

						}

					}



~ s,Documentation/(?!devicetree)(\S+)\.rst,:doc:`/$1`,g;

 $d 
						my $xref = $f;

 $f;

						$path =~ s,.*/(.*/.*),$1,;;

~ s,[/\-],_,g;;

						$xref .= " <abi_file_" . $path . ">";

~ s,\bDocumentation/ABI/$f\b,:ref:`$xref`,g;

 Seek for cross reference symbols like /sys/...

 $d 
						next if (!($s =~ m,/,));

						if (defined($data{$s}) && defined($data{$s}->{label})) {

 $s;

							$xref =~ s/$symbols/\\$1/g;

 ":ref:`$xref <" . $data{$s}->{label} . ">`";

							$d =~ s,$start$s$bondary,$1$xref$2,g;

						}

					}

 $d;

				$desc =~ s/^\s+//;



				# Remove title markups from the description, as they won't work

				$desc =~ s/\n[\-\*\=\^\~]+\n/\n\n/g;



~ m/\:\n/ || $desc ~ m/[\x00-\x08\x0b-\x1f\x7b-\xff]/) {

 put everything inside a code block

					$desc =~ s/\n/\n /g;



					print "::\n\n";

					print " $desc\n\n";

				} else {

					# Escape any special chars from description

~s/([\x00-\x08\x0b-\x1f\x21-\x2a\x2d\x2f\x3c-\x40\x5c\x5e-\x60\x7b-\xff])/\\$1/g;

				my $label = $data{$symbols{$content}->{xref}}->{label};



				# Escape special chars from content

~s/([\x00-\x1f\x21-\x2f\x3a-\x40\x7b-\xff])/\\$1/g;

			my $users = $data{$what}->{users};



~ s/\n/\n\t/g;



 Searches for ABI symbols



		next if (!($what =~ m/($arg)/));



 $data{$what}->{type};

		my $file = $data{$what}->{filepath};



~ s/\xac/, /g;

		my $bar = $what;

~ s/./-/g;

		my $kernelversion = $data{$what}->{kernelversion} if (defined($data{$what}->{kernelversion}));

 $data{$what}->{contact} if (defined($data{$what}->{contact}));

		my $users = $data{$what}->{users} if (defined($data{$what}->{users}));

 $data{$what}->{date} if (defined($data{$what}->{date}));

		my $desc = $data{$what}->{description} if (defined($data{$what}->{description}));



~ s/^\s+// if ($kernelversion);

		$contact =~ s/^\s+// if ($contact);

		if ($users) {

~ s/^\s+//;

			$users =~ s/\n//g;

		}

~ s/^\s+// if ($date);

		$desc =~ s/^\s+// if ($desc);



		printf "Kernel version:\t\t%s\n", $kernelversion if ($kernelversion);

		printf "Date:\t\t\t%s\n", $date if ($date);

		printf "Contact:\t\t%s\n", $contact if ($contact);

		printf "Users:\t\t\t%s\n", $users if ($users);

		print "Defined on file(s):\t$file\n\n";

		print "Description:\n\n$desc";

	}

}



# Exclude /sys/kernel/debug and /sys/kernel/tracing from the search path

sub dont_parse_special_attributes {

~ m,^/sys/kernel,)) {

	if (($File::Find::dir =~ m,^/sys/fs,)) {

		return grep {!/(pstore|bpf|fuse)/ } @_;

	}



	return @_

}



my %leaf;

my %aliases;

my @files;

my %root;



sub graph_add_file {

 shift;

	my $type = shift;



 $file;

	$dir =~ s,^(.*/).*,$1,;

~ s,.*/,,;

	my $file_ref = \%root;

	foreach my $edge(split "/", $dir) {

 "$edge/";

			${$file_ref}{$edge} = { };

		}

 \%{$$file_ref{$edge}};

		${$file_ref}{"__name"} = [ $name ];

	}

 "$file";

	${$file_ref}{$file} = {

> [ $name ]

	my $file = shift;

 shift;

 Traverse graph to find the reference

	my $file_ref = \%root;

	foreach my $edge(split "/", $file) {

 \%{$$file_ref{$edge}} || die "Missing node!";

 do a BFS

		my $v = shift @queue;

 keys(%{$v});

 Add new name

			my $name = @{$$v{$c}{"__name"}}[0];

^$file/) {

 Add child to the queue and mark as seen

my $escape_symbols = qr { ([\x01-\x08\x0e-\x1f\x21-\x29\x2b-\x2d\x3a-\x40\x7b-\xfe]) }x;

sub parse_existing_sysfs {

 $File::Find::name;

	my $mode = (lstat($file))[2];

 abs_path($file);

 Ignore cgroup, as this is big and has zero docs under ABI

		return if ($f =~ m#^/sys/fs/cgroup/#);



		# Ignore firmware as it is documented elsewhere

		# Either ACPI or under Documentation/devicetree/bindings/

^/sys/firmware/~ m#^/sys/firmware/#);

 Ignore some sysfs nodes that aren't actually part of ABI

		return if ($f =~ m#/sections|notes/#);



		# Would need to check at

		# Documentation/admin-guide/kernel-parameters.txt, but this

		# is not easily parseable.

/parameters/~ m#/parameters/#);

		$aliases{$file} = $abs_file;

		return;

	}



	return if (S_ISDIR($mode));



	# Trivial: file is defined exactly the same way at ABI What:

	return if (defined($data{$file}));

	return if (defined($data{$abs_file}));



	push @files, graph_add_file($abs_file, "file");

}



sub get_leave($)

{

 shift;

	my $l = $what;

 1;

	$leave = $l;

~ s,/$,,;

	$leave =~ s,.*/,,;

~ s/[\(\)]//g;

 $leave is used to improve search performance at

 check_undefined_symbols, as the algorithm there can seek

 for a small number of "what". It also allows giving a

 hint about a leave with the same name somewhere else.

 However, there are a few occurences where the leave is

 either a wildcard or a number. Just group such cases

 altogether.

~ m/\.\*/ || $leave eq "" || $leave 
		$leave = "others";

	}



	return $leave;

}



my @not_found;



sub check_file($$)

{

 shift;

	my $names_ref = shift;

 @{$names_ref};

	my $file = $names[0];



	my $found_string;



 get_leave($file);

		$leave = "others";

	}

 @{$leaf{$leave}->{expr}};

	my $path = $file;

~ s,(.*/).*,$1,;

		return if (!($file =~ m#$search_string#));

 1;

	for (my $i = 0; $i < @names; $i++) {

		if ($found_string && $hint) {

			if (!$i) {

				print STDERR "--> $names[$i]\n";

			} else {

				print STDERR "    $names[$i]\n";

			}

		}

		foreach my $re (@expr) {

~ /^$re\$/\n" if ($debug && $dbg_undefined);

			if ($names[$i] =~ $re) {

				return;

			}

		}

	}



	if ($leave ne "others") {

 @{$leaf{"others"}->{expr}};

		for (my $i = 0; $i < @names; $i++) {

			foreach my $re (@expr) {

~ /^$re\$/\n" if ($debug && $dbg_undefined);

				if ($names[$i] =~ $re) {

					return;

				}

			}

		}

	}



	push @not_found, $file if (!$search_string || $found_string);



	if ($hint && (!$search_string || $found_string)) {

 $leaf{$leave}->{what};

		$what =~ s/\xac/\n\t/g;

		if ($leave ne "others") {

			print STDERR "\r    more likely regexes:\n\t$what\n";

		} else {

			print STDERR "\r    tested regexes:\n\t$what\n";

		}

	}

}



sub check_undefined_symbols {

 scalar @files;

	my $next_i = 0;

 times;

	@files = sort @files;



 $start_time;

 When either debug or hint is enabled, there's no sense showing

 progress, as the progress will be overriden.

		$next_i = $num_files;

	}



	my $is_console;

 1 if (-t STDERR);

	for (my $i = 0; $i < $num_files; $i++) {

 $files[$i];

		my @names = @{$$file_ref{"__name"}};



		check_file($file_ref, \@names);



 times;

			my $percent = $i * 100 / $num_files;



 $cur_time - $start_time;

			my $time = sprintf "%d:%02d", int($tm), 60 * ($tm - int($tm));



			printf STDERR "\33[2K\r", if ($is_console);

			printf STDERR "%s: processing sysfs files... %i%%: $names[0]", $time, $percent;

			printf STDERR "\n", if (!$is_console);

			STDERR->flush();



 int (($percent + 1) * $num_files / 100);

			$last_time = $cur_time;

		}

	}



 times;

	my $tm = $cur_time - $start_time;

 sprintf "%d:%02d", int($tm), 60 * ($tm - int($tm));

		wanted =>\&parse_existing_sysfs,

>\&dont_parse_special_attributes,

		no_chdir => 1

	     }, $sysfs_prefix);

	print STDERR "done.\n";



 "";

			next if (!($what =~ m/^$sysfs_prefix/));



			# Convert what into regular expressions



			# Escape dot characters

~ s/\./\xf6/g;

 Temporarily change [0-9]+ type of patterns

			$what =~ s/\[0\-9\]\+/\xff/g;



			# Temporarily change [\d+-\d+] type of patterns

~ s/\[0\-\d+\]/\xff/g;

			$what =~ s/\[(\d+)\]/\xf4$1\xf5/g;



			# Temporarily change [0-9] type of patterns

~ s/\[(\d)\-(\d)\]/\xf4$1-$2\xf5/g;

 Handle multiple option patterns

			$what =~ s/[\{\<\[]([\w_]+)(?:[,|]+([\w_]+)){1,}[\}\>\]]/($1|$2)/g;



			# Handle wildcards

~ s,\*,.*,g;

			$what =~ s,/\xf6..,/.*,g;

~ s/\<[^\>]+\>/.*/g;

			$what =~ s/\{[^\}]+\}/.*/g;

~ s/\[[^\]]+\]/.*/g;

			$what =~ s/[XYZ]/.*/g;



			# Recover [0-9] type of patterns

~ s/\xf4/[/g;

			$what =~ s/\xf5/]/g;



			# Remove duplicated spaces

~ s/\s+/ /g;

 Special case: this ABI has a parenthesis on it

			$what =~ s/sqrt\(x^2\+y^2\+z^2\)/sqrt\(x^2\+y^2\+z^2\)/;



			# Special case: drop comparition as in:

	What: foo = <something>

 (this happens on a few IIO definitions)

~ s,\s*\
 Escape all other symbols

			$what =~ s/$escape_symbols/\\$1/g;

~ s/\\\\/\\/g;

			$what =~ s/\\([\[\]\(\)\|])/$1/g;

~ s/(\d+)\\(-\d+)/$1$2/g;

			$what =~ s/\xff/\\d+/g;



			# Special case: IIO ABI which a parenthesis.

~ s/sqrt(.*)/sqrt\(.*\)/;

 Simplify regexes with multiple .*

			$what =~ s#(?:\.\*){2,}##g;

			$what =~ s.*~ s#\.\*/\.\*#.*#g;

 Recover dot characters

			$what =~ s/\xf6/\./g;



 get_leave($what);

			my $added = 0;

			foreach my $l (split /\|/, $leave) {

				if (defined($leaf{$l})) {

~ m/\b$what\b/);

					$leaf{$l}->{what} .= "\xac" . $what;

 1;

					$leaf{$l}->{what} = $what;

 1;

				print STDERR "What: $what\n" if ($what =~ m#$search_string#);

			}



		}

	}

	# Compile regexes

	foreach my $l (sort keys %leaf) {

		my @expr;

		foreach my $w(sort split /\xac/, $leaf{$l}->{what}) {

			push @expr, qr /^$w$/;

		}

 \@expr;

 Take links into account

		my $abs_file = $aliases{$link};

		graph_add_link($abs_file, $link);

	}

	print STDERR "done.\n";



	check_undefined_symbols;

}



# Ensure that the prefix will always end with a slash

# While this is not needed for find, it makes the patch nicer

# with --enable-lineno

~ s,/?$,/,;

	$show_warnings = 0;

}

#

# Parses all ABI files located at $prefix dir

#

find({wanted =>\&parse_abi, no_chdir => 1}, $prefix);



print STDERR Data::Dumper->Dump([\%data], [qw(*data)]) if ($debug & $dbg_dump_abi_structs);



#

# Handles the command

#

if ($cmd eq "undefined") {

	undefined_symbols;

} elsif ($cmd eq "search") {

	search_symbols;

} else {

	if ($cmd eq "rest") {

		output_rest;

	}



	# Warn about duplicated ABI entries

	foreach my $what(sort keys %symbols) {

 @{$symbols{$what}->{file}};

=head1 NAME



abi_book.pl - parse the Linux ABI files and produce a ReST book.



head1 SYNOPSIS

	       [--(no-)rst-source] [--dir=<dir>] [--show-hints]

	       [--search-string <regex>]

	       <COMAND> [<ARGUMENT>]



Where B<COMMAND> can be:



over 8

=back



head1 OPTIONS

=over 8



item B<--dir>

=item B<--rst-source> and B<--no-rst-source>



The input file may be using ReST syntax or not. Those two options allow

selecting between a rst-compliant source ABI (B<--rst-source>), or a

plain text that may be violating ReST spec, so it requres some escaping

logic (B<--no-rst-source>).



item B<--enable-lineno>

define LINENO lines.

=item B<--debug> I<debug level>



Print debug information according with the level, which is given by the

following bitmask:



    -  1: Debug parsing What entries from ABI files;

    -  2: Shows what files are opened from ABI files;

    -  4: Dump the structs used to store the contents of the ABI files.



item B<--show-hints>

=item B<--search-string> I<regex string>



Show only occurences that match a search string.

Used only when B<undefined>.



item B<--help>

=item B<--man>



Prints the manual page and exits.



back

=head1 DESCRIPTION



Parse the Linux ABI files from ABI DIR (usually located at Documentation/ABI),

allowing to search for ABI symbols or to produce a ReST book containing

the Linux ABI documentation.



head1 EXAMPLES

=over 8



$ scripts/get_abi.pl search usb --dir Documentation/ABI/stable



back

=over 8



$ scripts/get_abi.pl search usb.*cap



back

=over 8



$ scripts/get_abi.pl rest --dir Documentation/ABI/obsolete



back

=head1 BUGS



Report bugs to Mauro Carvalho Chehab <mchehab+huawei@kernel.org>



head1 COPYRIGHT

=cut

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0-only



 (C) Copyright IBM Corporation 2006.

	Author : Ram Pai (linuxram@us.ibm.com)



 Usage: export_report.pl -k Module.symvers [-o report_file ] -f *.mod.c



	my $no1 = (split /\s+/, $a)[1];

 (split /\s+/, $b)[1];

	return $no1 <=> $no2;

}



sub alphabetically {

 @{$a};

	my ($module2, $value2) = @{$b};

> $value2 || $module2 cmp $module1;

	my ($href) = @_;

	print "\n";

	for my $mod (sort keys %$href) {

 $href->{$mod};

			my ($symbol, $no) = split /\s+/, $sym;

			printf("\t\t%-25s\n", $symbol);

		}

		print "\n";

	}

	print "\n";

	print "~"x80 , "\n";

}



sub usage {

        print "Usage: @_ -h -k Module.symvers  [ -o outputfile ] \n",

	      "\t-f: treat all the non-option argument as .mod.c files. ",

	      "Recommend using this as the last option\n",

	      "\t-h: print detailed help\n",

	      "\t-k: the path to Module.symvers file. By default uses ",

	      "the file from the current directory\n",

	      "\t-o outputfile: output the report to outputfile\n";

	exit 0;

}



sub collectcfiles {

    my @file;

    open my $fh, '< modules.order' or die "cannot open modules.order: $!\n";

    while (<$fh>) {

	s/\.ko$/.mod.c/;

	push (@file, $_)

    }

    close($fh);

    chomp @file;

    return @file;

}



my (%SYMBOL, %MODULE, %opt, @allcfiles);



if (not getopts('hk:o:f',\%opt) or defined $opt{'h'}) {

        usage($0);

}



if (defined $opt{'f'}) {

 @ARGV;

	@allcfiles = collectcfiles();

}



if (not defined $opt{'k'}) {

 "Module.symvers";



 collect all the symbols and their attributes from the

 Module.symvers file



	my (undef, $symbol, $module, $gpl, $namespace) = split('\t');

  [ $module , "0" , $symbol, $gpl];



 collect the usage count of each symbol.



my $modversion_warnings = 0;



foreach my $thismod (@allcfiles) {

	my $module;



	unless (open ($module, '<', $thismod)) {

		warn "Sorry, cannot open $thismod: $!\n";

		next;

	}



0;

 1 if ($_ 
 2 if ($_ 
			my $sym = (split /([,"])/,)[4];

 @{$SYMBOL{$sym}};

			$SYMBOL{ $sym } =  [ $module, $value+1, $symbol, $gpl];

			push(@{$MODULE{$thismod}} , $sym);

		}

	}

 2) {



 print the list of unused exported symbols



	my ($module, $value, $symbol, $gpl) = @{$list};

	printf("%-25s\t%-25s\t%-10s\t", $symbol, $module, $value);

	if (defined $gpl) {

		printf("%-25s\n",$gpl);

	} else {

		printf("\n");

	}

}

printf("%s\n\n\n","x"x80);



printf("SECTION 2:\n\tThis section reports export-symbol-usage of in-kernel

modules. Each module lists the modules, and the symbols from that module that

it uses.  Each listed symbol reports the number of modules using it\n");



print "\nNOTE: Got $modversion_warnings CONFIG_MODVERSIONS warnings\n\n"

    if $modversion_warnings;



print "~"x80 , "\n";

for my $thismod (sort keys %MODULE) {

 $MODULE{$thismod};

	$thismod =~ s/\.mod\.c/.ko/;

	print "\t\t\t$thismod\n";

	foreach my $symbol (@{$list}) {

 @{$SYMBOL{$symbol}};

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0-only

 Copyright 2008, Intel Corporation



 This file is part of the Linux kernel



 Authors:

 	Arjan van de Ven <arjan@linux.intel.com>



 This script turns a dmesg output into a SVG graphic that shows which

 functions take how much time. You can view SVG graphics with various

 programs, including Inkscape, The Gimp and Firefox.





 For this script to work, the kernel needs to be compiled with the

 CONFIG_PRINTK_TIME configuration option enabled, and with

 "initcall_debug" passed on the kernel command line.



 usage:

 	dmesg | perl scripts/bootgraph.pl > output.svg



my $header = 0;



sub help {

 << "EOM";

	my $std=shift;

	if ($std == 1) {

		print STDERR $text;

	} else {

		print $text;

	}

	exit;

}



GetOptions(

>\&help,

	'header'	=>\$header

);



my %start;

my %end;

my %type;

 0;

my $maxtime = 0;

 99999;

my $count = 0;

my %pids;

my %pidctr;



 20;

my $xheader = 15;

 25;

my $cyheader = 0;



while (<>) {

 $_;

	if ($line =~ /([0-9\.]+)\] calling  ([a-zA-Z0-9\_\.]+)\+/) {

 $2;

			$start{$func} = $1;

 0;

				$firsttime = $1;

			}

		}

~ /\@ ([0-9]+)/) {

			$pids{$func} = $1;

		}

 $count + 1;

	if ($line =~ /([0-9\.]+)\] async_waiting @ ([0-9]+)/) {

 $2;

			$func = "wait_" . $pid . "_1";

 1;

			$pidctr{$pid} = $pidctr{$pid} + 1;

 "wait_" . $pid . "_" . $pidctr{$pid};

			$start{$func} = $1;

 1;

				$firsttime = $1;

			}

		}

 $pid;

		$count = $count + 1;

	}



~ /([0-9\.]+)\] initcall ([a-zA-Z0-9\_\.]+)\+.*returned/) {

			$end{$2} = $1;

 $1;

	if ($line =~ /([0-9\.]+)\] async_continuing @ ([0-9]+)/) {

 $2;

		my $func =  "wait_" . $pid . "_" . $pidctr{$pid};

 $1;

		$maxtime = $1;

	}

~ /Write protecting the/) {

		$done = 1;

	}

~ /Freeing unused kernel memory/) {

		$done = 1;

	}

}



if ($count == 0) {

    print STDERR <<END;

1' and

\"1.0\" standalone
\"2000\" height\"1.1\" xmlns
	my $version = `uname -a`;

 `date`;

	print "<text transform=\"translate($xheader,$yheader)\">Kernel version: $version</text>\n";

 $yheader+$headerstep;

	print "<text transform=\"translate($xheader,$cyheader)\">Date: $date</text>\n";

}



my @styles;



 "fill:rgb(0,0,255);fill-opacity:0.5;stroke-width:1;stroke:rgb(0,0,0)";

$styles[1] = "fill:rgb(0,255,0);fill-opacity:0.5;stroke-width:1;stroke:rgb(0,0,0)";

 "fill:rgb(255,0,20);fill-opacity:0.5;stroke-width:1;stroke:rgb(0,0,0)";

$styles[3] = "fill:rgb(255,255,20);fill-opacity:0.5;stroke-width:1;stroke:rgb(0,0,0)";

 "fill:rgb(255,0,255);fill-opacity:0.5;stroke-width:1;stroke:rgb(0,0,0)";

$styles[5] = "fill:rgb(0,255,255);fill-opacity:0.5;stroke-width:1;stroke:rgb(0,0,0)";

 "fill:rgb(0,128,255);fill-opacity:0.5;stroke-width:1;stroke:rgb(0,0,0)";

$styles[7] = "fill:rgb(0,255,128);fill-opacity:0.5;stroke-width:1;stroke:rgb(0,0,0)";

 "fill:rgb(255,0,128);fill-opacity:0.5;stroke-width:1;stroke:rgb(0,0,0)";

$styles[9] = "fill:rgb(255,255,128);fill-opacity:0.5;stroke-width:1;stroke:rgb(0,0,0)";

 "fill:rgb(255,128,255);fill-opacity:0.5;stroke-width:1;stroke:rgb(0,0,0)";

$styles[11] = "fill:rgb(128,255,255);fill-opacity:0.5;stroke-width:1;stroke:rgb(0,0,0)";



 "fill:rgb(128,128,128);fill-opacity:0.5;stroke-width:0;stroke:rgb(0,0,0)";

my $mult = 1950.0 / ($maxtime - $firsttime);

 ($maxtime - $firsttime) / 120.0;

my $threshold = $threshold2/10;

 0;

my $rowscount = 1;

my @initcalls = sort { $start{$a} <=> $start{$b} } keys(%start);



foreach my $key (@initcalls) {

 $end{$key} - $start{$key};

	if ($duration >= $threshold) {

		my ($s, $s2, $s3, $e, $w, $y, $y2, $style);

 $pids{$key};

			$rows{$pid} = $rowscount;

 $rowscount + 1;

		$s = ($start{$key} - $firsttime) * $mult;

 $s + 6;

		$s3 = $s + 1;

 ($end{$key} - $firsttime) * $mult;

		$w = $e - $s;



 $rows{$pid} * 150;

		$y2 = $y + 4;



 $styles[$stylecounter];

		$stylecounter = $stylecounter + 1;

		if ($stylecounter > 11) {

 0;

			$y = $y + 15;

\"$s\" width\"$y\" height\"$style_wait\"/>\n";

			print "<rect x=\"$s\" width=\"$w\" y=\"$y\" height=\"145\" style=\"$style\"/>\n";

 $threshold2) {

				print "<text transform=\"translate($s2,$y2) rotate(90)\">$key</text>\n";

			} else {

				print "<text transform=\"translate($s3,$y2) rotate(90)\" font-size=\"3pt\">$key</text>\n";

			}

		}

	}

}





# print the time line on top

 $firsttime;

my $step = ($maxtime - $firsttime) / 15;

while ($time < $maxtime) {

 ($time - $firsttime) * $mult;

	my $tm = int($time * 100) / 100.0;

\"translate($s3,89) rotate(90)\">$tm</text>\n";

	$time = $time + $step;

}



print "</svg>\n";

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0



ARGV != 1 && $ 1 && $#ARGV !
ARGV == 3 && $ARGV[0] ne "-s");
 3 && $ARGV[0] ne "-s");

my $sysmap = "";

if ($#ARGV == 3) {

    shift;

 $ARGV[0];

my $vmlinux = $ARGV[0];

 $ARGV[1];



 Parse the vmlinux section table



my @lines = <FD>;

close(FD) || die $vmlinux;



 ();

    if ($line =~ /\s*([0-9]+)\s+(\S+)\s+([0-9a-f]+)\s+([0-9a-f]+)\s+([0-9a-f]+)\s+([0-9a-f]+)\s+2[*][*]([0-9]+)/

	) {

 $1;

	my $name = $2;

 Math::BigInt->new("0x" . $3);

	my $vma  = Math::BigInt->new("0x" . $4);

 Math::BigInt->new("0x" . $5);

	my $foff = Math::BigInt->new("0x" . $6);

 2 ** $7;

	push @sections, { name => $name,

> $vma,

			  len => $len,

> $foff };

sections sections\n";



 Try and parse the vmlinux symbol table.  If the vmlinux file has been created

 from a vmlinuz file with extract-vmlinux then the symbol table will be empty.



@lines = <FD>;

close(FD) || die $vmlinux;



 ();

my $nr_symbols = 0;



sub parse_symbols(@) {

    foreach my $line (@_) {

	chomp($line);

~ /([0-9a-f]+)\s([a-zA-Z])\s(\S+)/

	    my $addr = "0x" . $1;

 $2;

	    my $name = $3;



 $addr;

    @lines = <FD>;

    close(FD) || die $sysmap;

    parse_symbols(@lines);

}



die "No symbols available\n"

    if ($nr_symbols == 0);



print "Have $nr_symbols symbols\n";



die "Can't find system certificate list"

    unless (exists($symbols{"__cert_list_start"}) &&

	    exists($symbols{"system_certificate_list_size"}));



 Math::BigInt->new($symbols{"__cert_list_start"});

my $size_sym = Math::BigInt->new($symbols{"system_certificate_list_size"});



open FD, "<$vmlinux" || die $vmlinux;

binmode(FD);



 undef;

    my $s_name = $sec->{name};

 $sec->{vma};

    my $s_len = $sec->{len};

 $sec->{foff};

    my $s_vend = $s_vma + $s_len;



 $s_vma);

    next if ($start >= $s_vend);



    die "Certificate list size was not found on the same section\n"

	if ($size_sym < $s_vma || $size_sym > $s_vend);



    die "Cert object in multiple sections: ", $s_name, " and ", $s->{name}, "\n"

	if ($s);



 $size_sym -$s_vma + $s_foff;

    $size = unpack 'L!', $packed;

 $start + $size;

    $s = $sec;

}



die "Cert object not inside a section\n"

    unless ($s);



print "Certificate list in section ", $s->{name}, "\n";



 $start - $s->{vma} + $s->{foff};

my $buf = "";

 sysread(FD, $buf, $size);

die "Short read on $vmlinux\n" if ($len != $size);

close(FD) || die $vmlinux;



open FD, ">$keyring" || die $keyring;

binmode(FD);

 syswrite(FD, $buf, $size);

die "Short write on $keyring\n" if ($len != $size);

close(FD) || die $keyring;

include <limits.h>

include <stdlib.h>

include <string.h>

include <ctype.h>

include "genksyms.h"

include "parse.tab.h"

define YY_DECL		static int yylex1(void)

|<>/-]
[ \t]+{INT}[ \t]+\"[^\"\n]+\".*\n	return FILENAME;

.*\n					cur_line++;

include "keywords.c"

define _APP(T,L)	do {						   \

			  cur_node = next_node;				   \

 xmalloc(sizeof(*next_node));	   \

			  next_node->next = cur_node;			   \

 memcpy(xmalloc(L+1), T, L+1); \

			  cur_node->tag =				   \

			    find_symbol(cur_node->string, SYM_ENUM_CONST, 1)?\

			    SYM_ENUM_CONST : SYM_NORMAL ;		   \

 in_source_file;       \

define APP		_APP(yytext, yyleng)

  } lexstate = ST_NOTSTARTED;



  static int suppress_type_lookup, dont_want_brace_phrase;

  static struct string_list *next_node;

  static char *source_file;



 0;

      next_node = xmalloc(sizeof(*next_node));

 NULL;

      lexstate = ST_NORMAL;

    }



repeat:

 yylex1();

      file = strchr(yytext, '\"')+1;

 strchr(file, '\"');

      *e = '\0';

 memcpy(xmalloc(e-file+1), file, e-file+1);

      cur_line = atoi(yytext+2);



      if (!source_file) {

 xstrdup(cur_filename);

        in_source_file = 1;

      } else {

 (strcmp(cur_filename, source_file)  0);

	    int r = is_reserved_word(yytext, yyleng);

 0)

		switch (token = r)

		  {

		  case ATTRIBUTE_KEYW:

 ST_ATTRIBUTE;

		    count = 0;

		    goto repeat;

		  case ASM_KEYW:

 ST_ASM;

		    count = 0;

		    goto repeat;

		  case TYPEOF_KEYW:

 ST_TYPEOF;

		    count = 0;

		    goto repeat;



		  case STRUCT_KEYW:

		  case UNION_KEYW:

		  case ENUM_KEYW:

 3;

		    suppress_type_lookup = 2;

		    goto fini;



		  case EXPORT_SYMBOL_KEYW:

		      goto fini;



		  case STATIC_ASSERT_KEYW:

 ST_STATIC_ASSERT;

		    count = 0;

		    goto repeat;

		  }

	      }

	    if (!suppress_type_lookup)

	      {

		if (find_symbol(yytext, SYM_TYPEDEF, 1))

 TYPE;

	  lexstate = ST_BRACKET;

 1;

	  lexstate = ST_BRACE;

 1;

	case '=': case ':':

	  APP;

 ST_EXPRESSION;

	      lexstate = ST_NORMAL;

 ATTRIBUTE_PHRASE;

	      lexstate = ST_NORMAL;

 ASM_PHRASE;

	  if (is_reserved_word(yytext, yyleng) >= 0

	      || find_symbol(yytext, SYM_TYPEDEF, 1))

	    {

	      yyless(0);

	      unput('(');

 ST_NORMAL;

	      token = TYPEOF_KEYW;

	      break;

	    }

	  _APP("(", 1);

	}

 ST_TYPEOF;

	    lexstate = ST_TYPEOF_1;

	  else

	    APP;

	  goto repeat;

	case ')':

	  APP;

	  if (--count == 0)

	    {

 ST_NORMAL;

	      token = TYPEOF_PHRASE;

	      break;

	    }

	  goto repeat;

	default:

	  APP;

	  goto repeat;

	}

      break;



    case ST_BRACKET:

      APP;

      switch (token)

	{

	case '[':

	  ++count;

	  goto repeat;

	case ']':

	  if (--count == 0)

	    {

 ST_NORMAL;

	      token = BRACKET_PHRASE;

	      break;

	    }

	  goto repeat;

	default:

	  goto repeat;

	}

      break;



    case ST_BRACE:

      APP;

      switch (token)

	{

	case '{':

	  ++count;

	  goto repeat;

	case '}':

	  if (--count == 0)

	    {

 ST_NORMAL;

	      token = BRACE_PHRASE;

	      break;

	    }

	  goto repeat;

	default:

	  goto repeat;

	}

      break;



    case ST_EXPRESSION:

      switch (token)

	{

	case '(': case '[': case '{':

	  ++count;

	  APP;

	  goto repeat;

	case '}':

	  /* is this the last line of an enum declaration? */

	  if (count == 0)

	    {

	      /* Put back the token we just read so's we can find it again

		 after registering the expression.  */

	      unput(token);



 ST_NORMAL;

	      token = EXPRESSION_PHRASE;

	      break;

	    }

	  /* FALLTHRU */

	case ')': case ']':

	  --count;

	  APP;

	  goto repeat;

	case ',': case ';':

	  if (count == 0)

	    {

	      /* Put back the token we just read so's we can find it again

		 after registering the expression.  */

	      unput(token);



 ST_NORMAL;

	      token = EXPRESSION_PHRASE;

	      break;

	    }

	  APP;

	  goto repeat;

	default:

	  APP;

	  goto repeat;

	}

      break;



    case ST_STATIC_ASSERT:

      APP;

      switch (token)

	{

	case '(':

	  ++count;

	  goto repeat;

	case ')':

	  if (--count == 0)

	    {

 ST_NORMAL;

	      token = STATIC_ASSERT_PHRASE;

	      break;

	    }

	  goto repeat;

	default:

	  goto repeat;

	}

      break;



    default:

      exit(1);

    }

fini:



  if (suppress_type_lookup > 0)

    --suppress_type_lookup;

  if (dont_want_brace_phrase > 0)

    --dont_want_brace_phrase;



 &next_node->next;

?@-]

include "dtc.h"

include "srcpos.h"

include "dtc-parser.tab.h"

define	YY_USER_ACTION \

define LEXDEBUG	1*/

ifdef LEXDEBUG

define DPRINT(fmt, ...)	fprintf(stderr, fmt, __VA_ARGS__)

else

define DPRINT(fmt, ...)	do { } while (0)

endif

static int dts_version = 1;



#define BEGIN_DEFAULT()		DPRINT("<V1>\n"); \

				BEGIN(V1); \



static void push_input_file(const char *filename);

static bool pop_input_file(void);

static void PRINTF(1, 2) lexical_error(const char *fmt, ...);



%}



%%

<*>"/include/"{WS}*{STRING} {

 strchr(yytext, '\"') + 1;

			yytext[yyleng-1] = '\0';

			push_input_file(name);

		}



<*>^"#"(line)?[ \t]+[0-9]+[ \t]+{STRING}([ \t]+[0-9]+)* {

			char *line, *fnstart, *fnend;

			struct data fn;

			/* skip text before line # */

 yytext;

			fnstart = memchr(yytext, '"', yyleng);

 yytext + yyleng - 1;

			     *fnend != '"'; fnend--)

				;

			assert(fnstart && fnend && (fnend > fnstart));



 data_copy_escape_string(fnstart + 1,

line is the number of the next line */

			yylval.data = data_copy_escape_string(yytext+1,

					yyleng-2);

			return DT_STRING;

		}



<*>"/dts-v1/"	{

			DPRINT("Keyword: /dts-v1/\n");

 1;

			yylval.labelref = xstrdup(yytext);

 '\0';

			errno = 0;

 strtoull(yytext, &e, 0);

			d = data_copy_escape_string(yytext+1, yyleng-2);

			if (d.len == 1) {

				lexical_error("Empty character literal");

 0;

				yylval.integer = (unsigned char)d.val[0];



				if (d.len > 2)

					lexical_error("Character literal has %d"

						      " characters instead of 1",

						      d.len - 1);

			}



			data_free(d);

			return DT_CHAR_LITERAL;

		}



<*>\&{LABEL}	{	/* label reference */

			DPRINT("Ref: %s\n", yytext+1);

 xstrdup(yytext+1);

			yytext[yyleng-1] = '\0';

			DPRINT("Ref: %s\n", yytext+2);

 xstrdup(yytext+2);

			yylval.byte = strtol(yytext, NULL, 16);

			DPRINT("Byte: %02x\n", (int)yylval.byte);

			return DT_BYTE;

		}



<BYTESTRING>"]"	{

			DPRINT("/BYTESTRING\n");

			BEGIN_DEFAULT();

			return ']';

		}



<PROPNODENAME>\\?{PROPNODECHAR}+ {

			DPRINT("PropNodeName: %s\n", yytext);

 xstrdup((yytext[0]  '\\') ?

<*>"<="		{ return DT_LE; };

"		{ return DT_GE; };

<*>"!="		{ return DT_NE; };

<*>"&&"		{ return DT_AND; };

<*>"||"		{ return DT_OR; };



<*>.		{

			DPRINT("Char: %c (\\x%02x)\n", yytext[0],

				(unsigned)yytext[0]);

			if (yytext[0] == '[') {

				DPRINT("<BYTESTRING>\n");

				BEGIN(BYTESTRING);

			}

			if ((yytext[0] == '{')

			    || (yytext[0] == ';')) {

				DPRINT("<PROPNODENAME>\n");

				BEGIN(PROPNODENAME);

			}

			return yytext[0];

		}



%%



static void push_input_file(const char *filename)

{

	assert(filename);



	srcfile_push(filename);



 current_srcfile->f;

	yyin = current_srcfile->f;



	return true;

}



static void lexical_error(const char *fmt, ...)

{

	va_list ap;



	va_start(ap, fmt);

	srcpos_verror(&yylloc, "Lexical error", fmt, ap);

	va_end(ap);



 true;

include <assert.h>

include <limits.h>

include <stdio.h>

include <stdlib.h>

include <string.h>

include "lkc.h"

include "parser.tab.h"

define YY_DECL		static int yylex1(void)

define START_STRSIZE	16

static int prev_prev_token = T_EOL;

 T_EOL;

	text = xmalloc(START_STRSIZE);

 START_STRSIZE;

	text_size = 0;

 0;

	int new_size = text_size + size + 1;

	if (new_size > text_asize) {

 START_STRSIZE - 1;

		new_size &= -START_STRSIZE;

 xrealloc(text, new_size);

		text_asize = new_size;

	}

	memcpy(text + text_size, str, size);

 size;

	text[text_size] = 0;

}



static void alloc_string(const char *str, int size)

{

 xmalloc(size + 1);

	text[size] = 0;

}



static void warn_ignored_character(char chr)

{

	fprintf(stderr,

	        "%s:%d:warning: ignoring unsupported character '%c'\n",

	        current_file->name, yylineno, chr);

}

%}



n	[A-Za-z0-9_-]



%%

 0;

.*			/* ignore comment */

"="			return T_EQUAL;

"			return T_UNEQUAL;

"<="			return T_LESS_EQUAL;

">"			return T_GREATER;

"			return T_GREATER_EQUAL;

":="			return T_COLON_EQUAL;

"			return T_PLUS_EQUAL;

				open_quote = yytext[0];

				new_string();

				BEGIN(STRING);

			}

{n}+			{

				alloc_string(yytext, yyleng);

 text;

				yylval.string = expand_token(yytext, yyleng);

				if (strlen(yylval.string))

					return T_WORD;

				free(yylval.string);

			}

.			warn_ignored_character(*yytext);



<ASSIGN_VAL>{

	[^[:blank:]\n]+.*	{

		alloc_string(yytext, yyleng);

 text;

			yylval.string = text;

			return T_WORD_QUOTE;

		} else

			append_string(yytext, 1);

	}

	\n	{

		fprintf(stderr,

			"%s:%d:warning: multi-line strings not supported\n",

			zconf_curname(), zconf_lineno());

		unput('\n');

		BEGIN(INITIAL);

 text;

		yylval.string = text;

		return T_WORD_QUOTE;

	}

}



<HELP>{

	[ \t]+	{

		int ts, i;



 0;

		for (i = 0; i < yyleng; i++) {

			if (yytext[i] == '\t')

 (ts & ~7) + 8;

		last_ts = ts;

		if (first_ts) {

			if (ts < first_ts) {

				zconf_endhelp();

				return T_HELPTEXT;

			}

 first_ts;

				ts -= 8;

			}

			append_string("        ", ts);

		}

	}

	[ \t]*\n/[^ \t\n] {

		zconf_endhelp();

		return T_HELPTEXT;

	}

	[ \t]*\n	{

		append_string("\n", 1);

	}

	[^ \t\n].* {

		while (yyleng) {

			if ((yytext[yyleng-1] != ' ') && (yytext[yyleng-1] != '\t'))

				break;

			yyleng--;

		}

		append_string(yytext, yyleng);

		if (!first_ts)

 last_ts;

 T_EOL && prev_token !
	token = yylex1();



	if (prev_token == T_EOL || prev_token == T_HELPTEXT) {

		if (token == T_EOL) {

			/* Do not pass unneeded T_EOL to the parser. */

			goto repeat;

		} else {

			/*

			 * For the parser, update file/lineno at the first token

			 * of each statement. Generally, \n is a statement

			 * terminator in Kconfig, but it is not always true

			 * because \n could be escaped by a backslash.

			 */

 current_file;

			current_pos.lineno = yylineno;

		}

	}



	if (prev_prev_token == T_EOL && prev_token == T_WORD &&

	    (token == T_EQUAL || token == T_COLON_EQUAL || token == T_PLUS_EQUAL))

		BEGIN(ASSIGN_VAL);



 prev_token;

	prev_token = token;



	return token;

}



static char *expand_token(const char *in, size_t n)

{

	char *out;

	int c;

	char c2;

	const char *rest, *end;



	new_string();

	append_string(in, n);



	/* get the whole line because we do not know the end of token. */

	while ((c = input()) != EOF) {

		if (c == '\n') {

			unput(c);

			break;

		}

 c;

	rest = text;

 expand_one_token(&rest);

	end = rest + strlen(rest);

	while (end > rest)

		unput(*--end);



	free(text);



	return out;

}



static void append_expanded_string(const char *str)

{

	const char *end;

	char *res;



	str++;



 expand_dollar(&str);

	end = str + strlen(str);

	while (end > str)

		unput(*--end);



	append_string(res, strlen(res));



	free(res);

}



void zconf_starthelp(void)

{

	new_string();

	last_ts = first_ts = 0;

	BEGIN(HELP);

}



static void zconf_endhelp(void)

{

 text;

	f = fopen(name, "r");

	if (!f && name != NULL && name[0] != '/') {

 getenv(SRCTREE);

			f = fopen(fullname, "r");

		}

	}

	return f;

}



void zconf_initscan(const char *name)

{

 zconf_fopen(name);

	current_buf = xmalloc(sizeof(*current_buf));

	memset(current_buf, 0, sizeof(*current_buf));



 file_lookup(name);

	yylineno = 1;

}



void zconf_nextfile(const char *name)

{

	struct file *iter;

 file_lookup(name);

	struct buffer *buf = xmalloc(sizeof(*buf));

	memset(buf, 0, sizeof(*buf));



 YY_CURRENT_BUFFER;

	yyin = zconf_fopen(file->name);

	if (!yyin) {

		fprintf(stderr, "%s:%d: can't open file \"%s\"\n",

			zconf_curname(), zconf_lineno(), file->name);

		exit(1);

	}

	yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));

 current_buf;

	current_buf = buf;



 yylineno;

	file->parent = current_file;



	for (iter = current_file; iter; iter = iter->parent) {

		if (!strcmp(iter->name, file->name)) {

			fprintf(stderr,

				"Recursive inclusion detected.\n"

				"Inclusion path:\n"

				"  current file : %s\n", file->name);

 file;

				iter = iter->parent;

				fprintf(stderr, "  included from: %s:%d\n",

					iter->name, iter->lineno - 1);

			} while (strcmp(iter->name, file->name));

			exit(1);

		}

	}



 1;

	current_file = file;

}



static void zconf_endfile(void)

{

	struct buffer *parent;



 current_file->parent;

		yylineno = current_file->lineno;



 current_buf->parent;

	current_buf = parent;

}



int zconf_lineno(void)

{

	return current_pos.lineno;

}



const char *zconf_curname(void)

{

	return current_pos.file ? current_pos.file->name : "<none>";

}

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0



 Copyright 2005-2009 - Steven Rostedt



  It's simple enough to figure out how this works.

  If not, then you can ask me at stripconfig@goodmis.org



 What it does?



   If you have installed a Linux kernel from a distribution

   that turns on way too many modules than you need, and

   you only want the modules you use, then this program

   is perfect for you.



   It gives you the ability to turn off all the modules that are

   not loaded on your system.



 Howto:



  1. Boot up the kernel that you want to stream line the config on.

  2. Change directory to the directory holding the source of the

       kernel that you just booted.

  3. Copy the configuration file to this directory as .config

  4. Have all your devices that you need modules for connected and

      operational (make sure that their corresponding modules are loaded)

  5. Run this script redirecting the output to some other file

       like config_strip.

  6. Back up your old config (if you want too).

  7. copy the config_strip file to .config

  8. Run "make oldconfig"



  Now your kernel is ready to be built with only the modules that

  are loaded.



 Here's what I did with my Debian distribution.



    cd /usr/src/linux-2.6.10

    cp /boot/config-2.6.10-1-686-smp .config

    ~/bin/streamline_config > config_strip

    mv .config config_sav

    mv config_strip .config

    make oldconfig



 set the environment variable LOCALMODCONFIG_DEBUG to get

 debug output.

my $debugprint = 0;

 1 if (defined($ENV{LOCALMODCONFIG_DEBUG}));

my $uname = `uname -r`;

chomp $uname;



 (

	    "file" => ".config",

> "cat",

	    "file" => "/proc/config.gz",

> "zcat",

	    "file" => "/boot/config-$uname",

> "cat",

	    "file" => "/boot/vmlinuz-$uname",

> "scripts/extract-ikconfig",

	    "test" => "scripts/extract-ikconfig",

	},

	{

> "vmlinux",

	    "exec" => "scripts/extract-ikconfig",

> "scripts/extract-ikconfig",

	    "file" => "/lib/modules/$uname/kernel/kernel/configs.ko",

> "scripts/extract-ikconfig",

	    "test" => "scripts/extract-ikconfig",

	},

	{

> "kernel/configs.ko",

	    "exec" => "scripts/extract-ikconfig",

> "scripts/extract-ikconfig",

	    "file" => "kernel/configs.o",

> "scripts/extract-ikconfig",

	    "test" => "scripts/extract-ikconfig",

	},

);



sub read_config {

    foreach my $conf (@searchconfigs) {

 $conf->{"file"};

	my $exec = $conf->{"exec"};



	print STDERR "using config: '$file'\n";



	open(my $infile, '-|', "$exec $file") || die "Failed to run $exec $file";

 <$infile>;

my @config_file = read_config;



# Parse options

 0;

my $localyesconfig = 0;



> \$localmodconfig,

	   "localyesconfig" => \$localyesconfig);



# Get the build source and top level Kconfig file (passed in)

 ($ARGV[0] ? $ARGV[0] : '.');

my $kconfig = $ARGV[1];

 $ENV{'LSMOD'};

my @makefiles = `find $ksource -name Makefile -or -name Kbuild 2>/dev/null`;

chomp @makefiles;



my %depends;

my %selects;

my %prompts;

my %objects;

my %config2kfile;

my $var;

 0;

 prevent recursion

    my ($kconfig) = @_;



 "NONE";

    my $cont = 0;

    my $line;



 "$ksource/$kconfig";

    my $last_source = "";



    # Check for any environment variables used

~ /\$\((\w+)\)/ && $last_source ne $source) {

	my $env = $1;

 $source;

	$source =~ s/\$\($env\)/$ENV{$env}/;

    }



    open(my $kinfile, '<', $source) || die "Can't open $kconfig";

    while (<$kinfile>) {

	chomp;



	# Make sure that lines ending with \ continue

	if ($cont) {

 $line . " " . $_;

	    $cont = 1;

 $_;

	$cont = 0;



	# collect any Kconfig sources

	if (/^source\s+"?([^"]+)/) {

 $1;

 prevent reading twice.

		$read_kconfigs{$kconfig} = 1;

		read_kconfig($kconfig);

	    }

	    next;

	}



	# configs found

	if (/^\s*(menu)?config\s+(\S+)\s*$/) {

 "NEW";

	    $config = $2;

 $kconfig;

 Add depends for 'if' nesting

	    for (my $i = 0; $i < $iflevel; $i++) {

		if ($i) {

 " " . $ifdeps[$i];

		    $depends{$config} = $ifdeps[$i];

		}

 "DEP";

 collect the depends for the config

	    $state = "DEP";

 $1;

	    $depends{$config} .= " " . $1;

	} elsif ($state eq "DEP" && /^\s*def(_(bool|tristate)|ault)\s+(\S.*)$/) {

 $3;

		$dep =~ s/.*\sif\s+//;

 " " . $dep;

 Get the configs that select this config

	    my $conf = $1;

	    if (defined($selects{$conf})) {

 " " . $config;

		$selects{$conf} = $config;

	    }



	# configs without prompts must be selected

	} elsif ($state ne "NONE" && /^\s*(tristate\s+\S|prompt\b)/) {

	    # note if the config has a prompt

 1;

 Check for if statements

	    my $deps = $1;

	    # remove beginning and ending non text

~ s/^[^a-zA-Z0-9_]*//;

	    $deps =~ s/[^a-zA-Z0-9_]*$//;



 split /[^a-zA-Z0-9_]+/, $deps;

	    $ifdeps[$iflevel++] = join ':', @deps;



	} elsif (/^endif/) {



	    $iflevel-- if ($iflevel);



	# stop on "help" and keywords that end a menu entry

	} elsif (/^\s*(---)?help(---)?\s*$/ || /^(comment|choice|menu)\b/) {

 "NONE";

 Makefiles can use variables to define their dependencies

    my ($line, %vars) = @_;



 "";

    while ($line =~ s/^(.*?)(\$\((.*?)\))//) {

 $1;

	my $variable = $2;

 $3;

	    $process .= $start . $vars{$var};

	} else {

 $start . $variable;

    $process .= $line;



    return $process;

}



# Read all Makefiles to map the configs to the objects

foreach my $makefile (@makefiles) {



 "";

 if this line ends with a backslash, continue

	    $line .= $1;

	    next;

	}



 $_;

	$_ = $line;

 "";

 Convert variables in a line (could define configs)

	$_ = convert_vars($_, %make_vars);



	# collect objects after obj-$(CONFIG_FOO_BAR)

\s*(.*)/) {

	    $var = $1;

 $2;

 check if variables are set

	} elsif (/^\s*(\S+)\s*[:]?=\s*(.*\S)/) {

 $2;

		$obj =~ s/-/_/g;

~ /(.*)\.o$/) {

 Objects may be enabled by more than one config.

 Store configs in an array.

			@arr = @{$objects{$1}};

		    }



arr+1] = $var;

 The objects have a hash mapping to a reference

 of an array of configs.

		    $objects{$1} = \@arr;

		}

	    }

	}

    }

    close($infile);

}



my %modules;

my $linfile;



if (defined($lsmod_file)) {

    if ( ! -f $lsmod_file) {

	if ( -f $ENV{'objtree'}."/".$lsmod_file) {

 $ENV{'objtree'}."/".$lsmod_file;

    my $otype = ( -x $lsmod_file) ? '-|' : '<';

    open($linfile, $otype, $lsmod_file);



} else {



    # see what modules are loaded on this system

    my $lsmod;



    foreach my $dir ( ("/sbin", "/bin", "/usr/sbin", "/usr/bin") ) {

	if ( -x "$dir/lsmod" ) {

 "$dir/lsmod";

 try just the path

	$lsmod = "lsmod";

    }



    open($linfile, '-|', $lsmod) || die "Can not call lsmod with $lsmod";

}



while (<$linfile>) {

	next if (/^Module/);  # Skip the first line.

	if (/^(\S+)/) {

 1;

 add to the configs hash all configs that are needed to enable

# a loaded module. This is a direct obj-${CONFIG_FOO} += bar.o

# where we know we need bar.o so we add FOO to the list.

my %configs;

foreach my $module (keys(%modules)) {

    if (defined($objects{$module})) {

 @{$objects{$module}};

	    $configs{$conf} = $module;

	    dprint "$conf added by direct ($module)\n";

	    if ($debugprint) {

$conf;

		$c =~ s/^CONFIG_//;

		if (defined($depends{$c})) {

 $depends{$c}\n";

 Most likely, someone has a custom (binary?) module loaded.

 Read the current config, and see what is enabled. We want to

 ignore configs that we would not enable anyway.

my $valid = "A-Za-z_0-9";



foreach my $line (@config_file) {

 $line;

    if (/(CONFIG_[$valid]*)=(m|y)/) {

 $2;

my $repeat = 1;



my $depconfig;



#

# Note, we do not care about operands (like: &&, ||, !) we want to add any

# config that is in the depend list of another config. This script does

# not enable configs that are not already enabled. If we come across a

# config A that depends on !B, we can still add B to the list of depends

# to keep on. If A was on in the original config, B would not have been

# and B would not be turned on by this script.

#

sub parse_config_depends

{

 @_;

    while ($p =~ /[$valid]/) {



~ /^[^$valid]*([$valid]+)/) {

	    my $conf = "CONFIG_" . $1;



~ s/^[^$valid]*[$valid]+//;

 We only need to process if the depend config is a module

 We must make sure that this config has its

 dependencies met.

		$repeat = 1; # do again

		dprint "$conf selected by depend $depconfig\n";

 1;

 Select is treated a bit differently than depends. We call this

 when a config has no prompt and requires another config to be

 selected. We use to just select all configs that selected this

 config, but found that that can balloon into enabling hundreds

 of configs that we do not care about.



 The idea is we look at all the configs that select it. If one

 is already in our list of configs to enable, then there's nothing

 else to do. If there isn't, we pick the first config that was

 enabled in the original config and use that.

    my ($config, $p) = @_;



    my $next_config;



~ /[$valid]/) {

	if ($p =~ /^[^$valid]*([$valid]+)/) {

 "CONFIG_" . $1;

	    $p =~ s/^[^$valid]*[$valid]+//;



	    # Make sure that this config exists in the current .config file

	    if (!defined($orig_configs{$conf})) {

		dprint "$conf not set for $config select\n";

		next;

	    }



	    # Check if something other than a module selects this config

	    if (defined($orig_configs{$conf}) && $orig_configs{$conf} ne "m") {

		dprint "$conf (non module) selects config, we are good\n";

		# we are good with this

		return;

	    }

	    if (defined($configs{$conf})) {

		dprint "$conf selects $config so we are good\n";

		# A set config selects this config, we are good

		return;

	    }

	    # Set this config to be selected

	    if (!defined($next_config)) {

 $conf;

 If no possible config selected this, then something happened.

 If we are here, then we found no config that is set and

 selects this config. Repeat.

    $repeat = 1;

    # Make this config need to be selected

 1;

 loop through all configs, select their dependencies.

    $repeat = 1;



    while ($repeat) {

 0;

 If this config is not a module, we do not need to process it

	    $config =~ s/^CONFIG_//;

 $config;

 This config has dependencies. Make sure they are also included

 If the config has no prompt, then we need to check if a config

 that is enabled selected it. Or if we need to enable one.

		$process_selects{$config} = 1;

	    }

	}

    }

}



sub loop_select {



    foreach my $config (keys %process_selects) {

~ s/^CONFIG_//;

 config has no prompt and must be selected.

 Get the first set of configs and their dependencies.

    $repeat = 0;



    # Now we need to see if we have to check selects;

    loop_select;

}



my %setconfigs;

my @preserved_kconfigs;

if (defined($ENV{'LMC_KEEP'})) {

 split(/:/,$ENV{LMC_KEEP});

    my $kconfig = $config2kfile{$_[0]};

    if (!defined($kconfig)) {

	return 0;

    }

    foreach my $excl (@preserved_kconfigs) {

~ /^$excl/) {

 Finally, read the .config file and turn off any module enabled that

 we could not find a reason to keep enabled.

    $_ = $line;



    if (/CONFIG_IKCONFIG/) {

	if (/# CONFIG_IKCONFIG is not set/) {

	    # enable IKCONFIG at least as a module

m\n";

 don't ask about PROC

 CONFIG_IKCONFIG_PROC is not set\n";

    if (/CONFIG_MODULE_SIG_KEY="(.+)"/) {

 $1;

	my $default_cert = "certs/signing_key.pem";



	# Check that the logic in this script still matches the one in Kconfig

	if (!defined($depends{"MODULE_SIG_KEY"}) ||

	    $depends{"MODULE_SIG_KEY"} !~ /"\Q$default_cert\E"/) {

	    print STDERR "WARNING: MODULE_SIG_KEY assertion failure, ",

		"update needed to ", __FILE__, " line ", __LINE__, "\n";

	    print;

	} elsif ($orig_cert ne $default_cert && ! -f $orig_cert) {

	    print STDERR "Module signature verification enabled but ",

		"module signing key \"$orig_cert\" not found. Resetting ",

		"signing key to default value.\n";

\"$default_cert\"\n";

    if (/CONFIG_SYSTEM_TRUSTED_KEYS="(.+)"/) {

 $1;

	    print "CONFIG_SYSTEM_TRUSTED_KEYS=\"\"\n";

	} else {

	    print;

	}

	next;

    }



(m|y)/) {

		$setconfigs{$1} = 'y';

y\n";

		$setconfigs{$1} = $2;

	    }

	} elsif ($2 eq "m") {

	    print "# $1 is not set\n";

	    next;

	}

    }

    print;

}



# Integrity check, make sure all modules that we want enabled do

# indeed have their configs set.

loop:

foreach my $module (keys(%modules)) {

    if (defined($objects{$module})) {

 @{$objects{$module}};

# vim: softtabstop=4

!/usr/bin/env perl

	"debug" => \$debug,

> \$help,

	'help' => \$man

) or pod2usage(2);



pod2usage(1) if $help;

pod2usage(-exitstatus => 0, -verbose => 2) if $man;

pod2usage(2) if (scalar @ARGV < 2 || scalar @ARGV > 3);



 @ARGV;



 read the file and get identifiers



my $is_enum = 0;

 0;

	$data .= $_;



 $_;

		$ln =~ s,/\*.*(\*/),,g;



		$is_comment = 1 if ($ln =~ s,/\*.*,,);

	} else {

~ s,^(.*\*/),,) {

			$is_comment = 0;

		} else {

			next;

		}

	}



	if ($is_enum && $ln =~ m/^\s*([_\w][\w\d_]+)\s*[\,=]?/) {

 $1;

		my $n = $1;

~ tr/A-Z/a-z/;

		$n =~ tr/_/-/;



  "\\ :ref:`$s <$n>`\\ ";

		$is_enum = 0 if ($is_enum && m/\}/);

		next;

	}

 0 if ($is_enum && m/\}/);

	if ($ln =~ m/^\s*#\s*define\s+([_\w][\w\d_]+)\s+_IO/) {

 $1;

		my $n = $1;

~ tr/A-Z/a-z/;

		$ioctls{$s} = "\\ :ref:`$s <$n>`\\ ";

		next;

	}



\s*define\s+([_\w][\w\d_]+)\s+/) {

		my $s = $1;

 $1;

		$n =~ tr/A-Z/a-z/;

~ tr/_/-/;

		$defines{$s} = "\\ :ref:`$s <$n>`\\ ";

		next;

	}



~ m/^\s*typedef\s+([_\w][\w\d_]+)\s+(.*)\s+([_\w][\w\d_]+);/) {

		my $s = $2;

 $3;

		$typedefs{$n} = "\\ :c:type:`$n <$s>`\\ ";

		next;

	}

~ m/^\s*enum\s+([_\w][\w\d_]+)\s+\{/

	    || $ln =~ m/^\s*enum\s+([_\w][\w\d_]+)$/

~ m/^\s*typedef\s*enum\s+([_\w][\w\d_]+)\s+\{/

	    || $ln =~ m/^\s*typedef\s*enum\s+([_\w][\w\d_]+)$/) {

 $1;

		$enums{$s} =  "enum :c:type:`$s`\\ ";



 $1;

	if ($ln =~ m/^\s*struct\s+([_\w][\w\d_]+)\s+\{/

~ m/^\s*struct\s+([[_\w][\w\d_]+)$/

	    || $ln =~ m/^\s*typedef\s*struct\s+([_\w][\w\d_]+)\s+\{/

~ m/^\s*typedef\s*struct\s+([[_\w][\w\d_]+)$/

		my $s = $1;



 "struct $s\\ ";



 Handle multi-line typedefs



 ($data 
	       $data =~ m/typedef\s+enum\s+\S+?\s*\{[^\}]+\}\s*(\S+)\s*\;/g,);

foreach my $m (@matches) {

 $m;

	$typedefs{$s} = "\\ :c:type:`$s`\\ ";

	next;

}



#

# Handle exceptions, if any

#



 (

	"ioctl"   => ":ref",

> ":ref",

	"symbol"  => ":ref",

> ":c:type",

	"enum"    => ":c:type",

> ":c:type",

/);

 Parsers to ignore a symbol

 Parsers to replace a symbol

			$type = $1;

 $2;

			$new = $3;

		} else {

			die "Can't parse $file_exceptions: $_";

		}



~ m/^\:c\:(data|func|macro|type)\:\`(.+)\`/) {

			$reftype = ":c:$1";

 $2;

		} elsif ($new =~ m/\:ref\:\`(.+)\`/) {

 ":ref";

			$new = $1;

		} else {

 $def_reftype{$type};

		$new = "$reftype:`$old <$new>`";



		if ($type eq "ioctl") {

 $new if (exists($ioctls{$old}));

			$defines{$old} = $new if (exists($defines{$old}));

			next;

		}

		if ($type eq "symbol") {

 $new if (exists($enum_symbols{$old}));

			$typedefs{$old} = $new if (exists($typedefs{$old}));

			next;

		}

		if ($type eq "enum") {

 $new if (exists($enums{$old}));

			$structs{$old} = $new if (exists($structs{$old}));

			next;

		}



		die "Can't parse $file_exceptions: $_";

	}

}



if ($debug) {

	print Data::Dumper->Dump([\%ioctls], [qw(*ioctls)]) if (%ioctls);

	print Data::Dumper->Dump([\%typedefs], [qw(*typedefs)]) if (%typedefs);

	print Data::Dumper->Dump([\%enums], [qw(*enums)]) if (%enums);

	print Data::Dumper->Dump([\%structs], [qw(*structs)]) if (%structs);

	print Data::Dumper->Dump([\%defines], [qw(*defines)]) if (%defines);

	print Data::Dumper->Dump([\%enum_symbols], [qw(*enum_symbols)]) if (%enum_symbols);

}



#

# Align block

#

 expand($data);

$data = "    " . $data;

~ s/\n/\n    /g;

$data =~ s/\n\s+$/\n/g;

~ s/\n\s+\n/\n\n/g;



 Add escape codes for special characters



$data =~ s,([\_\`\*\<\>\&\\\\:\/\|\%\$\#\{\}\~\^]),\\$1,g;



~ s,DEPRECATED,**DEPRECATED**,g;



 Add references



 "[ \n\t\(\
 "(\\s|,|\\\\
	my $s = $ioctls{$r};



~ s,([\_\`\*\<\>\&\\\\:\/]),\\\\$1,g;

	$data =~ s/($start_delim)($r)$end_delim/$1$s$3/g;

}



foreach my $r (keys %defines) {

 $defines{$r};

	$r =~ s,([\_\`\*\<\>\&\\\\:\/]),\\\\$1,g;



	print "$r -> $s\n" if ($debug);



~ s/($start_delim)($r)$end_delim/$1$s$3/g;

	my $s = $enum_symbols{$r};



~ s,([\_\`\*\<\>\&\\\\:\/]),\\\\$1,g;

	$data =~ s/($start_delim)($r)$end_delim/$1$s$3/g;

}



foreach my $r (keys %enums) {

 $enums{$r};

	$r =~ s,([\_\`\*\<\>\&\\\\:\/]),\\\\$1,g;



	print "$r -> $s\n" if ($debug);



~ s/enum\s+($r)$end_delim/$s$2/g;

	my $s = $structs{$r};



~ s,([\_\`\*\<\>\&\\\\:\/]),\\\\$1,g;

	$data =~ s/struct\s+($r)$end_delim/$s$2/g;

}



foreach my $r (keys %typedefs) {

 $typedefs{$r};

	$r =~ s,([\_\`\*\<\>\&\\\\:\/]),\\\\$1,g;



	print "$r -> $s\n" if ($debug);

~ s/($start_delim)($r)$end_delim/$1$s$3/g;

$data =~ s/\\ ([\n\s])/\1/g;



#

# Generate output file

#



 $file_in;

$title =~ s,.*/,,;



open OUT, "> $file_out" or die "Can't open $file_out";

print OUT ".. -*- coding: utf-8; mode: rst -*-\n\n";

print OUT "$title\n";

" x length($title);

=head1 NAME



parse_headers.pl - parse a C file, in order to identify functions, structs,

enums and defines and create cross-references to a Sphinx book.



head1 SYNOPSIS

=head1 OPTIONS



over 8

=item B<--debug>



Put the script in verbose mode, useful for debugging.



item B<--usage>

=item B<--help>



Prints a more detailed help message and exits.



back

=head1 DESCRIPTION



Convert a C header or source file (C_FILE), into a ReStructured Text

included via ..parsed-literal block with cross-references for the

documentation files that describe the API. It accepts an optional

EXCEPTIONS_FILE with describes what elements will be either ignored or

be pointed to a non-default reference.



The output is written at the (OUT_FILE).



It is capable of identifying defines, functions, structs, typedefs,

enums and enum symbols and create cross-references for all of them.

It is also capable of distinguish #define used for specifying a Linux

ioctl.



The EXCEPTIONS_FILE contain two rules to allow ignoring a symbol or

to replace the default references by a custom one.



Please read Documentation/doc-guide/parse-headers.rst at the Kernel's

tree for more details.



head1 BUGS

=head1 COPYRIGHT



Copyright (c) 2016 by Mauro Carvalho Chehab <mchehab+samsung@kernel.org>.



License GPLv2: GNU GPL version 2 <https://gnu.org/licenses/gpl.html>.



This is free software: you are free to change and redistribute it.

There is NO WARRANTY, to the extent permitted by law.



cut

!/usr/bin/env perl

 This is a POC for reading the text representation of trace output related to

 page reclaim. It makes an attempt to extract some high-level information on

 what is going on. The accuracy of the parser may vary



 Example usage: trace-vmscan-postprocess.pl < /sys/kernel/debug/tracing/trace_pipe

 other options

   --read-procstat	If the trace lacks process info, get it from /proc

   --ignore-pid	Aggregate processes of the same name together



 Copyright (c) IBM Corporation 2009

 Author: Mel Gorman <mel@csn.ul.ie>

 Tracepoint events

use constant MM_VMSCAN_DIRECT_RECLAIM_BEGIN	=> 1;

> 2;

use constant MM_VMSCAN_KSWAPD_WAKE		=> 3;

> 4;

use constant MM_VMSCAN_LRU_SHRINK_ACTIVE	=> 5;

> 6;

use constant MM_VMSCAN_LRU_ISOLATE		=> 7;

> 8;

use constant MM_VMSCAN_WRITEPAGE_ANON_SYNC	=> 9;

> 10;

use constant MM_VMSCAN_WRITEPAGE_ANON_ASYNC	=> 11;

> 12;

use constant EVENT_UNKNOWN			=> 13;



# Per-order events

> 11;

use constant MM_VMSCAN_WAKEUP_KSWAPD_PERORDER 	=> 12;

> 13;

use constant HIGH_KSWAPD_REWAKEUP_PERORDER	=> 14;



# Constants used to track state

> 15;

use constant STATE_DIRECT_ORDER 		=> 16;

> 17;

use constant STATE_KSWAPD_ORDER			=> 18;



# High-level events extrapolated from tracepoints

> 19;

use constant HIGH_KSWAPD_LATENCY		=> 20;

> 21;

use constant HIGH_NR_SCANNED			=> 22;

> 23;

use constant HIGH_NR_RECLAIMED			=> 24;

> 25;

use constant HIGH_NR_ANON_SCANNED		=> 26;

> 27;

use constant HIGH_NR_ANON_RECLAIMED		=> 28;



my %perprocesspid;

my %perprocess;

my %last_procmap;

my $opt_ignorepid;

my $opt_read_procstat;



my $total_wakeup_kswapd;

my ($total_direct_reclaim, $total_direct_nr_scanned);

my ($total_direct_nr_file_scanned, $total_direct_nr_anon_scanned);

my ($total_direct_latency, $total_kswapd_latency);

my ($total_direct_nr_reclaimed);

my ($total_direct_nr_file_reclaimed, $total_direct_nr_anon_reclaimed);

my ($total_direct_writepage_file_sync, $total_direct_writepage_file_async);

my ($total_direct_writepage_anon_sync, $total_direct_writepage_anon_async);

my ($total_kswapd_nr_scanned, $total_kswapd_wake);

my ($total_kswapd_nr_file_scanned, $total_kswapd_nr_anon_scanned);

my ($total_kswapd_writepage_file_sync, $total_kswapd_writepage_file_async);

my ($total_kswapd_writepage_anon_sync, $total_kswapd_writepage_anon_async);

my ($total_kswapd_nr_reclaimed);

my ($total_kswapd_nr_file_reclaimed, $total_kswapd_nr_anon_reclaimed);



# Catch sigint and exit on request

 0;

my $sigint_exit = 0;

 0;

my $sigint_received = 0;

sub sigint_handler {

 time;

		$sigint_report = 1;

	} else {

		if (!$sigint_exit) {

			print "Second SIGINT received quickly, exiting\n";

		}

		$sigint_exit++;

	}



	if ($sigint_exit > 3) {

		print "Many SIGINTs received, exiting now without report\n";

		exit;

	}



 $current_time;

	$sigint_pending = 1;

}

 "sigint_handler";

 Parse command line options

	'ignore-pid'	 =>	\$opt_ignorepid,

>	\$opt_read_procstat,

 Defaults for dynamically discovered regex's

 'order([0-9]*) gfp_flags
 'nr_reclaimed
my $regex_kswapd_wake_default = 'nid=([0-9]*) order=([0-9]*)';

my $regex_kswapd_sleep_default = 'nid=([0-9]*)';

 'nid([0-9]*) order([A-Z_|]*)';

my $regex_lru_isolate_default = 'isolate_mode=([0-9]*) classzone_idx=([0-9]*) order=([0-9]*) nr_requested=([0-9]*) nr_scanned=([0-9]*) nr_skipped=([0-9]*) nr_taken=([0-9]*) lru=([a-z_]*)';

my $regex_lru_shrink_inactive_default = 'nid=([0-9]*) nr_scanned=([0-9]*) nr_reclaimed=([0-9]*) nr_dirty=([0-9]*) nr_writeback=([0-9]*) nr_congested=([0-9]*) nr_immediate=([0-9]*) nr_activate_anon=([0-9]*) nr_activate_file=([0-9]*) nr_ref_keep=([0-9]*) nr_unmap_fail=([0-9]*) priority=([0-9]*) flags=([A-Z_|]*)';

 'lru([0-9]*) nr_rotated([0-9]*)';

 'page([0-9]*) flags
 Dyanically discovered regex

 Static regex used. Specified like this for readability and for use with /o

                      (process_pid)     (cpus      )   ( time  )   (tpoint    ) (details)

my $regex_traceevent = '\s*([a-zA-Z0-9-]*)\s*(\[[0-9]*\])(\s*[dX.][Nnp.][Hhs.][0-9a-fA-F.]*|)\s*([0-9.]*):\s*([a-zA-Z_]*):\s*(.*)';

 '[-0-9]*\s\((.*)\).*';

my $regex_statppid = '[-0-9]*\s\(.*\)\s[A-Za-z]\s([0-9]*).*';



sub generate_traceevent_regex {

 shift;

	my $default = shift;

	my $regex;



	# Read the event format or use the default

	if (!open (FORMAT, "/sys/kernel/debug/tracing/events/$event/format")) {

		print("WARNING: Event $event format string not found\n");

		return $default;

	} else {

		my $line;

		while (!eof(FORMAT)) {

 <FORMAT>;

			$line =~ s/, REC->.*//;

~ /^print fmt:\s"(.*)".*/) {

				$regex = $1;

~ s/%s/\([0-9a-zA-Z|_]*\)/g;

				$regex =~ s/%p/\([0-9a-f]*\)/g;

~ s/%d/\([-0-9]*\)/g;

				$regex =~ s/%ld/\([-0-9]*\)/g;

~ s/%lu/\([0-9]*\)/g;

 Can't handle the print_flags stuff but in the context of this

 script, it really doesn't matter

	$regex =~ s/\(REC.*\) \? __print_flags.*//;



	# Verify fields are in the right order

	my $tuple;

	foreach $tuple (split /\s/, $regex) {

		my ($key, $value) = split(/=/, $tuple);

 shift;

			print("WARNING: Format not as expected for event $event '$key' != '$expected'\n");

~ s/$key$1/;

$regex_direct_begin = generate_traceevent_regex(

			"vmscan/mm_vmscan_direct_reclaim_begin",

			$regex_direct_begin_default,

			"order", "may_writepage",

			"gfp_flags");

 generate_traceevent_regex(

$regex_kswapd_wake = generate_traceevent_regex(

			"vmscan/mm_vmscan_kswapd_wake",

			$regex_kswapd_wake_default,

			"nid", "order");

 generate_traceevent_regex(

$regex_wakeup_kswapd = generate_traceevent_regex(

			"vmscan/mm_vmscan_wakeup_kswapd",

			$regex_wakeup_kswapd_default,

			"nid", "zid", "order", "gfp_flags");

 generate_traceevent_regex(

$regex_lru_shrink_inactive = generate_traceevent_regex(

			"vmscan/mm_vmscan_lru_shrink_inactive",

			$regex_lru_shrink_inactive_default,

			"nid", "nr_scanned", "nr_reclaimed", "nr_dirty", "nr_writeback",

			"nr_congested", "nr_immediate", "nr_activate_anon",

			"nr_activate_file", "nr_ref_keep",

			"nr_unmap_fail", "priority", "flags");

 generate_traceevent_regex(

$regex_writepage = generate_traceevent_regex(

			"vmscan/mm_vmscan_writepage",

			$regex_writepage_default,

			"page", "pfn", "flags");



sub read_statline($) {

 $_[0];

		$statline = <STAT>;

		close(STAT);

	}



	if ($statline eq '') {

 "-1 (UNKNOWN_PROCESS_NAME) R 0";

	my $pid = $_[0];

 $_[1];

 Convert sec.usec timestamp format

	my $timestamp = $_[0];



 split (/\./, $timestamp);

 Read each line of the event log

	while ($traceevent = <STDIN>) {

~ /$regex_traceevent/o) {

			$process_pid = $1;

 $4;

			$tracepoint = $5;



~ /(.*)-([0-9]*)$/;

			my $process = $1;

 $2;

				$process = $last_procmap{$pid};

 "$process-$pid";

			$last_procmap{$pid} = $process;



			if ($opt_read_procstat) {

 read_statline($pid);

					$process_pid = guess_process_pid($pid, $statline);

				}

			}

		} else {

			next;

		}



		# Perl Switch() sucks majorly

		if ($tracepoint eq "mm_vmscan_direct_reclaim_begin") {

 timestamp_to_ms($timestamp);

			$perprocesspid{$process_pid}->{STATE_DIRECT_BEGIN} = $timestamp;



 $6;

			my $order = $1;

			$perprocesspid{$process_pid}->{MM_VMSCAN_DIRECT_RECLAIM_BEGIN_PERORDER}[$order]++;

 $order;

 Count the event itself

			my $index = $perprocesspid{$process_pid}->{MM_VMSCAN_DIRECT_RECLAIM_END};

			$perprocesspid{$process_pid}->{MM_VMSCAN_DIRECT_RECLAIM_END}++;



			# Record how long direct reclaim took this time

			if (defined $perprocesspid{$process_pid}->{STATE_DIRECT_BEGIN}) {

 timestamp_to_ms($timestamp);

				my $order = $perprocesspid{$process_pid}->{STATE_DIRECT_ORDER};

 ($timestamp - $perprocesspid{$process_pid}->{STATE_DIRECT_BEGIN});

				$perprocesspid{$process_pid}->{HIGH_DIRECT_RECLAIM_LATENCY}[$index] = "$order-$latency";

			}

		} elsif ($tracepoint eq "mm_vmscan_kswapd_wake") {

 $6;

			my $order = $2;

 $order;

				$timestamp = timestamp_to_ms($timestamp);

				$perprocesspid{$process_pid}->{MM_VMSCAN_KSWAPD_WAKE}++;

 $timestamp;

 Count the event itself

			my $index = $perprocesspid{$process_pid}->{MM_VMSCAN_KSWAPD_SLEEP};

			$perprocesspid{$process_pid}->{MM_VMSCAN_KSWAPD_SLEEP}++;



			# Record how long kswapd was awake

 timestamp_to_ms($timestamp);

			my $order = $perprocesspid{$process_pid}->{STATE_KSWAPD_ORDER};

 ($timestamp - $perprocesspid{$process_pid}->{STATE_KSWAPD_BEGIN});

			$perprocesspid{$process_pid}->{HIGH_KSWAPD_LATENCY}[$index] = "$order-$latency";

 0;

			$details = $6;

			if ($details !~ /$regex_wakeup_kswapd/o) {

				print "WARNING: Failed to parse mm_vmscan_wakeup_kswapd as expected\n";

				print "         $details\n";

				print "         $regex_wakeup_kswapd\n";

				next;

			}

 $3;

			$details = $6;

			if ($details !~ /$regex_lru_isolate/o) {

				print "WARNING: Failed to parse mm_vmscan_lru_isolate as expected\n";

				print "         $details\n";

				print "         $regex_lru_isolate/o\n";

				next;

			}

 $1;

			my $nr_scanned = $5;

 $8;

 To closer match vmstat scanning statistics, only count isolate_both

 and isolate_inactive as scanning. isolate_active is rotation

 isolate_inactive == 1
 1

 isolate_active   == 2
 2

 isolate_both     == 3
 3

			if ($isolate_mode != 2) {

 $nr_scanned;

				if ($file =~ /_file/) {

 $nr_scanned;

					$perprocesspid{$process_pid}->{HIGH_NR_ANON_SCANNED} += $nr_scanned;

				}

			}

		} elsif ($tracepoint eq "mm_vmscan_lru_shrink_inactive") {

 $6;

			my $nr_reclaimed = $3;

 $13;

			my $file = 0;

~ /RECLAIM_WB_FILE/) {

				$file = 1;

			}

 $nr_reclaimed;

				$perprocesspid{$process_pid}->{HIGH_NR_FILE_RECLAIMED} += $nr_reclaimed;

			} else {

 $nr_reclaimed;

			$details = $6;

			if ($details !~ /$regex_writepage/o) {

				print "WARNING: Failed to parse mm_vmscan_writepage as expected\n";

				print "         $details\n";

				print "         $regex_writepage\n";

				next;

			}



 $3;

			my $file = 0;

 0;

			if ($flags =~ /RECLAIM_WB_FILE/) {

 1;

			if ($flags =~ /RECLAIM_WB_SYNC/) {

 1;

	my $hashref = shift;

 %$hashref;

 Dump per-process stats

	my $max_strlen = 0;



	# Get the maximum process name

	foreach $process_pid (keys %perprocesspid) {

 length($process_pid);

			$max_strlen = $len;

		}

	}

 2;

 Work out latencies

		my $index = 0;

		while (defined $stats{$process_pid}->{HIGH_DIRECT_RECLAIM_LATENCY}[$index] ||

			defined $stats{$process_pid}->{HIGH_KSWAPD_LATENCY}[$index]) {



			if ($stats{$process_pid}->{HIGH_DIRECT_RECLAIM_LATENCY}[$index]) {

				printf("%s ", $stats{$process_pid}->{HIGH_DIRECT_RECLAIM_LATENCY}[$index]) if !$opt_ignorepid;

 split(/-/, $stats{$process_pid}->{HIGH_DIRECT_RECLAIM_LATENCY}[$index]);

				$total_direct_latency += $latency;

			} else {

				printf("%s ", $stats{$process_pid}->{HIGH_KSWAPD_LATENCY}[$index]) if !$opt_ignorepid;

 split(/-/, $stats{$process_pid}->{HIGH_KSWAPD_LATENCY}[$index]);

				$total_kswapd_latency += $latency;

			}

			$index++;

		}

		print "\n" if !$opt_ignorepid;

	}



	# Print out process activity

	printf("\n");

	printf("%-" . $max_strlen . "s %8s %10s   %8s %8s  %8s %8s %8s %8s\n", "Process", "Direct",  "Wokeup", "Pages",   "Pages",   "Pages",   "Pages",     "Time");

	printf("%-" . $max_strlen . "s %8s %10s   %8s %8s  %8s %8s %8s %8s\n", "details", "Rclms",   "Kswapd", "Scanned", "Rclmed",  "Sync-IO", "ASync-IO",  "Stalled");

	foreach $process_pid (keys %stats) {



		if (!$stats{$process_pid}->{MM_VMSCAN_DIRECT_RECLAIM_BEGIN}) {

			next;

		}



 $stats{$process_pid}->{MM_VMSCAN_DIRECT_RECLAIM_BEGIN};

		$total_wakeup_kswapd += $stats{$process_pid}->{MM_VMSCAN_WAKEUP_KSWAPD};

 $stats{$process_pid}->{HIGH_NR_SCANNED};

		$total_direct_nr_file_scanned += $stats{$process_pid}->{HIGH_NR_FILE_SCANNED};

 $stats{$process_pid}->{HIGH_NR_ANON_SCANNED};

		$total_direct_nr_reclaimed += $stats{$process_pid}->{HIGH_NR_RECLAIMED};

 $stats{$process_pid}->{HIGH_NR_FILE_RECLAIMED};

		$total_direct_nr_anon_reclaimed += $stats{$process_pid}->{HIGH_NR_ANON_RECLAIMED};

 $stats{$process_pid}->{MM_VMSCAN_WRITEPAGE_FILE_SYNC};

		$total_direct_writepage_anon_sync += $stats{$process_pid}->{MM_VMSCAN_WRITEPAGE_ANON_SYNC};

 $stats{$process_pid}->{MM_VMSCAN_WRITEPAGE_FILE_ASYNC};

		$total_direct_writepage_anon_async += $stats{$process_pid}->{MM_VMSCAN_WRITEPAGE_ANON_ASYNC};



 0;

		my $this_reclaim_delay = 0;

		while (defined $stats{$process_pid}->{HIGH_DIRECT_RECLAIM_LATENCY}[$index]) {

 split(/-/, $stats{$process_pid}->{HIGH_DIRECT_RECLAIM_LATENCY}[$index]);

			$this_reclaim_delay += $latency;

			$index++;

		}



		printf("%-" . $max_strlen . "s %8d %10d   %8u %8u  %8u %8u %8.3f",

			$process_pid,

			$stats{$process_pid}->{MM_VMSCAN_DIRECT_RECLAIM_BEGIN},

			$stats{$process_pid}->{MM_VMSCAN_WAKEUP_KSWAPD},

			$stats{$process_pid}->{HIGH_NR_SCANNED},

			$stats{$process_pid}->{HIGH_NR_FILE_SCANNED},

			$stats{$process_pid}->{HIGH_NR_ANON_SCANNED},

			$stats{$process_pid}->{HIGH_NR_RECLAIMED},

			$stats{$process_pid}->{HIGH_NR_FILE_RECLAIMED},

			$stats{$process_pid}->{HIGH_NR_ANON_RECLAIMED},

			$stats{$process_pid}->{MM_VMSCAN_WRITEPAGE_FILE_SYNC} + $stats{$process_pid}->{MM_VMSCAN_WRITEPAGE_ANON_SYNC},

			$stats{$process_pid}->{MM_VMSCAN_WRITEPAGE_FILE_ASYNC} + $stats{$process_pid}->{MM_VMSCAN_WRITEPAGE_ANON_ASYNC},

			$this_reclaim_delay / 1000);



		if ($stats{$process_pid}->{MM_VMSCAN_DIRECT_RECLAIM_BEGIN}) {

			print "      ";

 0; $order < 20; $order++) {

				my $count = $stats{$process_pid}->{MM_VMSCAN_DIRECT_RECLAIM_BEGIN_PERORDER}[$order];

 0) {

					print "direct-$order=$count ";

				}

			}

		}

		if ($stats{$process_pid}->{MM_VMSCAN_WAKEUP_KSWAPD}) {

			print "      ";

 0; $order < 20; $order++) {

				my $count = $stats{$process_pid}->{MM_VMSCAN_WAKEUP_KSWAPD_PERORDER}[$order];

 0) {

					print "wakeup-$order=$count ";

				}

			}

		}



		print "\n";

	}



	# Print out kswapd activity

	printf("\n");

	printf("%-" . $max_strlen . "s %8s %10s   %8s   %8s %8s %8s\n", "Kswapd",   "Kswapd",  "Order",     "Pages",   "Pages",   "Pages",  "Pages");

	printf("%-" . $max_strlen . "s %8s %10s   %8s   %8s %8s %8s\n", "Instance", "Wakeups", "Re-wakeup", "Scanned", "Rclmed",  "Sync-IO", "ASync-IO");

	foreach $process_pid (keys %stats) {



		if (!$stats{$process_pid}->{MM_VMSCAN_KSWAPD_WAKE}) {

			next;

		}



 $stats{$process_pid}->{MM_VMSCAN_KSWAPD_WAKE};

		$total_kswapd_nr_scanned += $stats{$process_pid}->{HIGH_NR_SCANNED};

 $stats{$process_pid}->{HIGH_NR_FILE_SCANNED};

		$total_kswapd_nr_anon_scanned += $stats{$process_pid}->{HIGH_NR_ANON_SCANNED};

 $stats{$process_pid}->{HIGH_NR_RECLAIMED};

		$total_kswapd_nr_file_reclaimed += $stats{$process_pid}->{HIGH_NR_FILE_RECLAIMED};

 $stats{$process_pid}->{HIGH_NR_ANON_RECLAIMED};

		$total_kswapd_writepage_file_sync += $stats{$process_pid}->{MM_VMSCAN_WRITEPAGE_FILE_SYNC};

 $stats{$process_pid}->{MM_VMSCAN_WRITEPAGE_ANON_SYNC};

		$total_kswapd_writepage_file_async += $stats{$process_pid}->{MM_VMSCAN_WRITEPAGE_FILE_ASYNC};

 $stats{$process_pid}->{MM_VMSCAN_WRITEPAGE_ANON_ASYNC};

			for (my $order = 0; $order < 20; $order++) {

 $stats{$process_pid}->{MM_VMSCAN_KSWAPD_WAKE_PERORDER}[$order];

				if ($count != 0) {

$count ";

			for (my $order = 0; $order < 20; $order++) {

 $stats{$process_pid}->{HIGH_KSWAPD_REWAKEUP_PERORDER}[$order];

				if ($count != 0) {

$count ";

 Print out summaries

	$total_direct_latency /= 1000;

 1000;

		$process = $process_pid;

~ s/-([0-9])*$//;

			$process = "NO_PROCESS_NAME";

		}



 $perprocesspid{$process_pid}->{MM_VMSCAN_DIRECT_RECLAIM_BEGIN};

		$perprocess{$process}->{MM_VMSCAN_KSWAPD_WAKE} += $perprocesspid{$process_pid}->{MM_VMSCAN_KSWAPD_WAKE};

 $perprocesspid{$process_pid}->{MM_VMSCAN_WAKEUP_KSWAPD};

		$perprocess{$process}->{HIGH_KSWAPD_REWAKEUP} += $perprocesspid{$process_pid}->{HIGH_KSWAPD_REWAKEUP};

 $perprocesspid{$process_pid}->{HIGH_NR_SCANNED};

		$perprocess{$process}->{HIGH_NR_FILE_SCANNED} += $perprocesspid{$process_pid}->{HIGH_NR_FILE_SCANNED};

 $perprocesspid{$process_pid}->{HIGH_NR_ANON_SCANNED};

		$perprocess{$process}->{HIGH_NR_RECLAIMED} += $perprocesspid{$process_pid}->{HIGH_NR_RECLAIMED};

 $perprocesspid{$process_pid}->{HIGH_NR_FILE_RECLAIMED};

		$perprocess{$process}->{HIGH_NR_ANON_RECLAIMED} += $perprocesspid{$process_pid}->{HIGH_NR_ANON_RECLAIMED};

 $perprocesspid{$process_pid}->{MM_VMSCAN_WRITEPAGE_FILE_SYNC};

		$perprocess{$process}->{MM_VMSCAN_WRITEPAGE_ANON_SYNC} += $perprocesspid{$process_pid}->{MM_VMSCAN_WRITEPAGE_ANON_SYNC};

 $perprocesspid{$process_pid}->{MM_VMSCAN_WRITEPAGE_FILE_ASYNC};

		$perprocess{$process}->{MM_VMSCAN_WRITEPAGE_ANON_ASYNC} += $perprocesspid{$process_pid}->{MM_VMSCAN_WRITEPAGE_ANON_ASYNC};



 0; $order < 20; $order++) {

			$perprocess{$process}->{MM_VMSCAN_DIRECT_RECLAIM_BEGIN_PERORDER}[$order] += $perprocesspid{$process_pid}->{MM_VMSCAN_DIRECT_RECLAIM_BEGIN_PERORDER}[$order];

 $perprocesspid{$process_pid}->{MM_VMSCAN_WAKEUP_KSWAPD_PERORDER}[$order];

			$perprocess{$process}->{MM_VMSCAN_KSWAPD_WAKE_PERORDER}[$order] += $perprocesspid{$process_pid}->{MM_VMSCAN_KSWAPD_WAKE_PERORDER}[$order];



		}



		# Aggregate direct reclaim latencies

 $perprocess{$process}->{MM_VMSCAN_DIRECT_RECLAIM_END};

		my $rd_index = 0;

		while (defined $perprocesspid{$process_pid}->{HIGH_DIRECT_RECLAIM_LATENCY}[$rd_index]) {

 $perprocesspid{$process_pid}->{HIGH_DIRECT_RECLAIM_LATENCY}[$rd_index];

		$perprocess{$process}->{MM_VMSCAN_DIRECT_RECLAIM_END} = $wr_index;



		# Aggregate kswapd latencies

 $perprocess{$process}->{MM_VMSCAN_KSWAPD_SLEEP};

		my $rd_index = 0;

		while (defined $perprocesspid{$process_pid}->{HIGH_KSWAPD_LATENCY}[$rd_index]) {

 $perprocesspid{$process_pid}->{HIGH_KSWAPD_LATENCY}[$rd_index];

		$perprocess{$process}->{MM_VMSCAN_DIRECT_RECLAIM_END} = $wr_index;

	}

}



sub report() {

	if (!$opt_ignorepid) {

		dump_stats(\%perprocesspid);

	} else {

		aggregate_perprocesspid();

		dump_stats(\%perprocess);

	}

}



# Process events or signals until neither is available

sub signal_loop() {

	my $sigint_processed;

	do {

 0;

 Handle pending signals if any

			my $current_time = time;



			if ($sigint_exit) {

				print "Received exit signal\n";

 0;

				if ($current_time >= $sigint_received + 2) {

					report();

 0;

					$sigint_pending = 0;

 1;

!/usr/bin/env perl

 This is a POC (proof of concept or piece of crap, take your pick) for reading the

 text representation of trace output related to page allocation. It makes an attempt

 to extract some high-level information on what is going on. The accuracy of the parser

 may vary considerably



 Example usage: trace-pagealloc-postprocess.pl < /sys/kernel/debug/tracing/trace_pipe

 other options

   --prepend-parent	Report on the parent proc and PID

   --read-procstat	If the trace lacks process info, get it from /proc

   --ignore-pid	Aggregate processes of the same name together



 Copyright (c) IBM Corporation 2009

 Author: Mel Gorman <mel@csn.ul.ie>

 Tracepoint events

use constant MM_PAGE_ALLOC		=> 1;

> 2;

use constant MM_PAGE_FREE_BATCHED	=> 3;

> 4;

use constant MM_PAGE_ALLOC_ZONE_LOCKED	=> 5;

> 6;

use constant EVENT_UNKNOWN		=> 7;



# Constants used to track state

> 8;

use constant STATE_PCPU_PAGES_REFILLED	=> 9;



# High-level events extrapolated from tracepoints

> 10;

use constant HIGH_PCPU_REFILLS		=> 11;

> 12;

use constant HIGH_EXT_FRAGMENT_SEVERE	=> 13;

> 14;

use constant HIGH_EXT_FRAGMENT_CHANGED	=> 15;



my %perprocesspid;

my %perprocess;

my $opt_ignorepid;

my $opt_read_procstat;

my $opt_prepend_parent;



# Catch sigint and exit on request

 0;

my $sigint_exit = 0;

 0;

my $sigint_received = 0;

sub sigint_handler {

 time;

		$sigint_report = 1;

	} else {

		if (!$sigint_exit) {

			print "Second SIGINT received quickly, exiting\n";

		}

		$sigint_exit++;

	}



	if ($sigint_exit > 3) {

		print "Many SIGINTs received, exiting now without report\n";

		exit;

	}



 $current_time;

	$sigint_pending = 1;

}

 "sigint_handler";

 Parse command line options

	'ignore-pid'	 =>	\$opt_ignorepid,

>	\$opt_read_procstat,

	'prepend-parent' =>	\$opt_prepend_parent,

);



# Defaults for dynamically discovered regex's

my $regex_fragdetails_default = 'page=([0-9a-f]*) pfn=([0-9]*) alloc_order=([-0-9]*) fallback_order=([-0-9]*) pageblock_order=([-0-9]*) alloc_migratetype=([-0-9]*) fallback_migratetype=([-0-9]*) fragmenting=([-0-9]) change_ownership=([-0-9])';



# Dyanically discovered regex

my $regex_fragdetails;



# Static regex used. Specified like this for readability and for use with /o

#                      (process_pid)     (cpus      )   ( time  )   (tpoint    ) (details)

 '\s*([a-zA-Z0-9-]*)\s*(\[[0-9]*\])\s*([0-9.]*):\s*([a-zA-Z_]*):\s*(.*)';

my $regex_statname = '[-0-9]*\s\((.*)\).*';

 '[-0-9]*\s\(.*\)\s[A-Za-z]\s([0-9]*).*';

	my $event = shift;

 shift;

 Read the event format or use the default

		$regex = $default;

	} else {

		my $line;

		while (!eof(FORMAT)) {

 <FORMAT>;

			if ($line =~ /^print fmt:\s"(.*)",.*/) {

 $1;

				$regex =~ s/%p/\([0-9a-f]*\)/g;

~ s/%d/\([-0-9]*\)/g;

				$regex =~ s/%lu/\([0-9]*\)/g;

			}

		}

	}



	# Verify fields are in the right order

	my $tuple;

	foreach $tuple (split /\s/, $regex) {

		my ($key, $value) = split(/=/, $tuple);

 shift;

			print("WARNING: Format not as expected '$key' != '$expected'");

~ s/$key$1/;

$regex_fragdetails = generate_traceevent_regex("kmem/mm_page_alloc_extfrag",

			$regex_fragdetails_default,

			"page", "pfn",

			"alloc_order", "fallback_order", "pageblock_order",

			"alloc_migratetype", "fallback_migratetype",

			"fragmenting", "change_ownership");



sub read_statline($) {

 $_[0];

		$statline = <STAT>;

		close(STAT);

	}



	if ($statline eq '') {

 "-1 (UNKNOWN_PROCESS_NAME) R 0";

	my $pid = $_[0];

 $_[1];

	my $pid = $_[0];

 $_[1];

 Read the ppid stat line

	$ppid = $1;

	return guess_process_pid($ppid, read_statline($ppid));

}



sub process_events {

	my $traceevent;

	my $process_pid;

	my $cpus;

	my $timestamp;

	my $tracepoint;

	my $details;

	my $statline;



	# Read each line of the event log

EVENT_PROCESS:

 <STDIN>) {

		if ($traceevent =~ /$regex_traceevent/o) {

 $1;

			$tracepoint = $4;



			if ($opt_read_procstat || $opt_prepend_parent) {

~ /(.*)-([0-9]*)$/;

				my $process = $1;

 $2;

				$statline = read_statline($pid);



				if ($opt_read_procstat && $process eq '') {

 guess_process_pid($pid, $statline);

					$process_pid = parent_info($pid, $statline) . " :: $process_pid";

				}

			}



			# Unnecessary in this script. Uncomment if required

 $cpus = $2;

			# $timestamp = $3;

		} else {

			next;

		}



		# Perl Switch() sucks majorly

		if ($tracepoint eq "mm_page_alloc") {

			$perprocesspid{$process_pid}->{MM_PAGE_ALLOC}++;

		} elsif ($tracepoint eq "mm_page_free") {

			$perprocesspid{$process_pid}->{MM_PAGE_FREE}++

		} elsif ($tracepoint eq "mm_page_free_batched") {

			$perprocesspid{$process_pid}->{MM_PAGE_FREE_BATCHED}++;

		} elsif ($tracepoint eq "mm_page_pcpu_drain") {

			$perprocesspid{$process_pid}->{MM_PAGE_PCPU_DRAIN}++;

			$perprocesspid{$process_pid}->{STATE_PCPU_PAGES_DRAINED}++;

		} elsif ($tracepoint eq "mm_page_alloc_zone_locked") {

			$perprocesspid{$process_pid}->{MM_PAGE_ALLOC_ZONE_LOCKED}++;

			$perprocesspid{$process_pid}->{STATE_PCPU_PAGES_REFILLED}++;

		} elsif ($tracepoint eq "mm_page_alloc_extfrag") {



			# Extract the details of the event now

 $5;

			$page = $1;

 $2;

			$alloc_order = $3;

 $4;

			$pageblock_order = $5;

 $6;

			$fallback_migratetype = $7;

 $8;

			$change_ownership = $9;



			if ($fragmenting) {

				$perprocesspid{$process_pid}->{HIGH_EXT_FRAG}++;

 3) {

 Catch a full pcpu drain event

			$perprocesspid{$process_pid}->{STATE_PCPU_PAGES_DRAINED} = 0;

		}



		# Catch a full pcpu refill event

		if ($perprocesspid{$process_pid}->{STATE_PCPU_PAGES_REFILLED} &&

				$tracepoint ne "mm_page_alloc_zone_locked") {

			$perprocesspid{$process_pid}->{HIGH_PCPU_REFILLS}++;

 0;

	my $hashref = shift;

 %$hashref;

 Dump per-process stats

	my $max_strlen = 0;



	# Get the maximum process name

	foreach $process_pid (keys %perprocesspid) {

 length($process_pid);

			$max_strlen = $len;

		}

	}

 2;

 Dump final aggregates

			$stats{$process_pid}->{STATE_PCPU_PAGES_DRAINED} = 0;

		}

		if ($stats{$process_pid}->{STATE_PCPU_PAGES_REFILLED}) {

			$stats{$process_pid}->{HIGH_PCPU_REFILLS}++;

 0;

		$process = $process_pid;

~ s/-([0-9])*$//;

			$process = "NO_PROCESS_NAME";

		}



 $perprocesspid{$process_pid}->{MM_PAGE_ALLOC};

		$perprocess{$process}->{MM_PAGE_ALLOC_ZONE_LOCKED} += $perprocesspid{$process_pid}->{MM_PAGE_ALLOC_ZONE_LOCKED};

 $perprocesspid{$process_pid}->{MM_PAGE_FREE};

		$perprocess{$process}->{MM_PAGE_FREE_BATCHED} += $perprocesspid{$process_pid}->{MM_PAGE_FREE_BATCHED};

 $perprocesspid{$process_pid}->{MM_PAGE_PCPU_DRAIN};

		$perprocess{$process}->{HIGH_PCPU_DRAINS} += $perprocesspid{$process_pid}->{HIGH_PCPU_DRAINS};

 $perprocesspid{$process_pid}->{HIGH_PCPU_REFILLS};

		$perprocess{$process}->{MM_PAGE_ALLOC_EXTFRAG} += $perprocesspid{$process_pid}->{MM_PAGE_ALLOC_EXTFRAG};

 $perprocesspid{$process_pid}->{HIGH_EXT_FRAG};

		$perprocess{$process}->{HIGH_EXT_FRAGMENT_CHANGED} += $perprocesspid{$process_pid}->{HIGH_EXT_FRAGMENT_CHANGED};

 $perprocesspid{$process_pid}->{HIGH_EXT_FRAGMENT_SEVERE};

		$perprocess{$process}->{HIGH_EXT_FRAGMENT_MODERATE} += $perprocesspid{$process_pid}->{HIGH_EXT_FRAGMENT_MODERATE};

 $perprocesspid{$process_pid}->{EVENT_UNKNOWN};

 Process events or signals until neither is available

		$sigint_processed = 0;

		process_events();



		# Handle pending signals if any

		if ($sigint_pending) {

 time;

				$sigint_pending = 0;

			}

			if ($sigint_report) {

 $sigint_received + 2) {

					$sigint_report = 0;

 0;

					$sigint_processed = 1;

				}

			}

		}

	} while ($sigint_pending || $sigint_processed);

}



signal_loop();

report();

!/usr/bin/perl -w



 winucase_convert.pl -- convert "Windows 8 Upper Case Mapping Table.txt" to

                        a two-level set of C arrays.



   Copyright 2013: Jeff Layton <jlayton@redhat.com>



   This program is free software: you can redistribute it and/or modify

   it under the terms of the GNU General Public License as published by

   the Free Software Foundation, either version 3 of the License, or

   (at your option) any later version.



   This program is distributed in the hope that it will be useful,

   but WITHOUT ANY WARRANTY; without even the implied warranty of

   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

   GNU General Public License for more details.



   You should have received a copy of the GNU General Public License

   along with this program.  If not, see <https://www.gnu.org/licenses/>.



	$firstchar = hex($1);

 hex($2);

	$uppercase = hex($3);



 $uppercase;

for ($i = 0; $i < 256; $i++) {

	next if (!$top[$i]);



 {", $i);

	for ($j = 0; $j < 256; $j++) {

		if (($j % 8) == 0) {

			print "\n\t";

		} else {

			print " ";

		}

		printf("0x%4.4x,", $top[$i][$j] ? $top[$i][$j] : 0);

	}

	print "\n};\n\n";

}



 {", $i);

for ($i = 0; $i < 256; $i++) {

	if (($i % 8) == 0) {

		print "\n\t";

	} elsif ($top[$i]) {

		print " ";

	} else {

		print "  ";

	}



	if ($top[$i]) {

		printf("t2_%2.2x,", $i);

	} else {

		print "NULL,";

	}

}

print "\n};\n\n";

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-1.0+ OR BSD-3-Clause



 ====================================================================


 Written by Andy Polyakov, @dot-asm, originally for the OpenSSL

 project.

 ====================================================================


 Poly1305 hash for MIPS.



 May 2016



 Numbers are cycles per processed byte with poly1305_blocks alone.



		IALU/gcc

 R1x000	~5.5/+130%	(big-endian)

 Octeon II	2.50/+70%	(little-endian)



 March 2019



 Add 32-bit code path.



 October 2019



 Modulo-scheduling reduction allows to omit dependency chain at the

 end of inner loop and improve performance. Also optimize MIPS32R2

 code path for MIPS 1004K core. Per Ren von Dorst's suggestions.



		IALU/gcc

 R1x000	~9.8/?		(big-endian)

 Octeon II	3.65/+140%	(little-endian)

 MT7621/1004K	4.75/?		(little-endian)



 There is a number of MIPS ABI in use, O32 and N32/64 are most

 widely used. Then there is a new contender: NUBI. It appears that if

 one picks the latter, it's possible to arrange code in ABI neutral

 manner. Therefore let's stick to NUBI register layout:



($zero,$at,$t0,$t1,$t2)=map("\$$_",(0..2,24,25));

map("\$$_",(4..11));

($s0,$s1,$s2,$s3,$s4,$s5,$s6,$s7,$s8,$s9,$s10,$s11)=map("\$$_",(12..23));

map("\$$_",(3,28..31));



 The return value is placed in $a0. Following coding rules facilitate

 interoperability:



 - never ever touch $tp, "thread pointer", former $gp [o32 can be

   excluded from the rule, because it's specified volatile];

 - copy return value to $t0, former $v0 [or to $a0 if you're adapting

   old code];

 - on O32 populate $a4-$a7 with 'lw $aN,4*N($sp)' if necessary;



 For reference here is register layout for N32/64 MIPS ABIs:



# ($zero,$at,$v0,$v1)=map("\$$_",(0..3));

 ($a0,$a1,$a2,$a3,$a4,$a5,$a6,$a7)=map("\$$_",(4..11));

# ($t0,$t1,$t2,$t3,$t8,$t9)=map("\$$_",(12..15,24,25));

 ($s0,$s1,$s2,$s3,$s4,$s5,$s6,$s7)=map("\$$_",(16..23));

# ($gp,$sp,$fp,$ra)=map("\$$_",(28..31));

#

# <appro@openssl.org>

#

######################################################################



 supported flavours are o32,n32,64,nubi32,nubi64

 ($flavour 
if ($flavour =~ /64|n32/i) {{{

######################################################################

# 64-bit code path

#



 ($a0,$a1,$a2,$a3);

my ($in0,$in1,$tmp0,$tmp1,$tmp2,$tmp3,$tmp4) = ($a4,$a5,$a6,$a7,$at,$t0,$t1);



<<___;

if (defined(_MIPS_ARCH_MIPS64R3) || defined(_MIPS_ARCH_MIPS64R5) || \\

 define _MIPS_ARCH_MIPS64R2

endif

if defined(_MIPS_ARCH_MIPS64R6)

 define dmultu(rs,rt)

 define mflo(rd,rs,rt)	dmulu	rd,rs,rt

 define mfhi(rd,rs,rt)	dmuhu	rd,rs,rt

else

 define dmultu(rs,rt)		dmultu	rs,rt

 define mflo(rd,rs,rt)	mflo	rd

 define mfhi(rd,rs,rt)	mfhi	rd

endif

ifdef	__KERNEL__

 define poly1305_init   poly1305_init_mips

 define poly1305_blocks poly1305_blocks_mips

 define poly1305_emit   poly1305_emit_mips

endif

if defined(__MIPSEB__) && !defined(MIPSEB)

 define MIPSEB

endif

ifdef MIPSEB

 define MSB 0

 define LSB 7

else

 define MSB 7

 define LSB 0

endif

if defined(_MIPS_ARCH_MIPS64R6)

 $inp % 8

 align $inp

 byte to bit offset

 ifdef	MIPSEB

 else

 endif

else

endif

ifdef	MIPSEB

 if defined(_MIPS_ARCH_MIPS64R2)

 byte swap

 else

 0x000000FF000000FF

 byte swap

 0x0000FF000000FF00

 endif

endif

 0x0000000100000000

 0x00000000ffffffc1

 0x0ffffffc10000000

 0x0ffffffc0fffffff

 0x0ffffffc0ffffffc

	daddu	$tmp0,$in1		# s1 = r1 + (r1 >> 2)

	sd	$tmp0,40($ctx)



.Lno_key:

	li	$v0,0			# return 0

	jr	$ra

.end	poly1305_init

___

{

my $SAVED_REGS_MASK = ($flavour =~ /nubi/i) ? "0x0003f000" : "0x00030000";





my ($shr,$shl) = ($s6,$s7);		# used on R6



<<___;

 number of complete blocks

if defined(_MIPS_ARCH_MIPS64R6)

else

endif

 optimize non-nubi prologue
~ /nubi/i);	# optimize non-nubi prologue

$code.=<<___;

	.set	reorder



#if defined(_MIPS_ARCH_MIPS64R6)

	andi	$shr,$inp,7

	dsubu	$inp,$inp,$shr		# align $inp

	sll	$shr,$shr,3		# byte to bit offset

	subu	$shl,$zero,$shr

#endif



	ld	$h0,0($ctx)		# load hash value

	ld	$h1,8($ctx)

	ld	$h2,16($ctx)



	ld	$r0,24($ctx)		# load key

	ld	$r1,32($ctx)

	ld	$rs1,40($ctx)



	dsll	$len,4

	daddu	$len,$inp		# end of buffer

	b	.Loop



.align	4

.Loop:

#if defined(_MIPS_ARCH_MIPS64R6)

	ld	$in0,0($inp)		# load input

	ld	$in1,8($inp)

	beqz	$shr,.Laligned_inp



	ld	$tmp2,16($inp)

# ifdef	MIPSEB

	dsllv	$in0,$in0,$shr

	dsrlv	$tmp3,$in1,$shl

	dsllv	$in1,$in1,$shr

	dsrlv	$tmp2,$tmp2,$shl

# else

	dsrlv	$in0,$in0,$shr

	dsllv	$tmp3,$in1,$shl

	dsrlv	$in1,$in1,$shr

	dsllv	$tmp2,$tmp2,$shl

# endif

	or	$in0,$in0,$tmp3

	or	$in1,$in1,$tmp2

.Laligned_inp:

#else

	ldl	$in0,0+MSB($inp)	# load input

	ldl	$in1,8+MSB($inp)

	ldr	$in0,0+LSB($inp)

	ldr	$in1,8+LSB($inp)

#endif

	daddiu	$inp,16

#ifdef	MIPSEB

# if defined(_MIPS_ARCH_MIPS64R2)

	dsbh	$in0,$in0		# byte swap

	 dsbh	$in1,$in1

	dshd	$in0,$in0

	 dshd	$in1,$in1

# else

	ori	$tmp0,$zero,0xFF

	dsll	$tmp2,$tmp0,32

	or	$tmp0,$tmp2		# 0x000000FF000000FF



	and	$tmp1,$in0,$tmp0	# byte swap

	 and	$tmp3,$in1,$tmp0

	dsrl	$tmp2,$in0,24

	 dsrl	$tmp4,$in1,24

	dsll	$tmp1,24

	 dsll	$tmp3,24

	and	$tmp2,$tmp0

	 and	$tmp4,$tmp0

	dsll	$tmp0,8			# 0x0000FF000000FF00

	or	$tmp1,$tmp2

	 or	$tmp3,$tmp4

	and	$tmp2,$in0,$tmp0

	 and	$tmp4,$in1,$tmp0

	dsrl	$in0,8

	 dsrl	$in1,8

	dsll	$tmp2,8

	 dsll	$tmp4,8

	and	$in0,$tmp0

	 and	$in1,$tmp0

	or	$tmp1,$tmp2

	 or	$tmp3,$tmp4

	or	$in0,$tmp1

	 or	$in1,$tmp3

	dsrl	$tmp1,$in0,32

	 dsrl	$tmp3,$in1,32

	dsll	$in0,32

	 dsll	$in1,32

	or	$in0,$tmp1

	 or	$in1,$tmp3

# endif

#endif

	dsrl	$tmp1,$h2,2		# modulo-scheduled reduction

	andi	$h2,$h2,3

	dsll	$tmp0,$tmp1,2



	daddu	$d0,$h0,$in0		# accumulate input

	 daddu	$tmp1,$tmp0

	sltu	$tmp0,$d0,$h0

	daddu	$d0,$d0,$tmp1		# ... and residue

	sltu	$tmp1,$d0,$tmp1

	daddu	$d1,$h1,$in1

	daddu	$tmp0,$tmp1

	sltu	$tmp1,$d1,$h1

	daddu	$d1,$tmp0



	dmultu	($r0,$d0)		# h0*r0

	 daddu	$d2,$h2,$padbit

	 sltu	$tmp0,$d1,$tmp0

	mflo	($h0,$r0,$d0)

	mfhi	($h1,$r0,$d0)



	dmultu	($rs1,$d1)		# h1*5*r1

	 daddu	$d2,$tmp1

	 daddu	$d2,$tmp0

	mflo	($tmp0,$rs1,$d1)

	mfhi	($tmp1,$rs1,$d1)



	dmultu	($r1,$d0)		# h0*r1

	mflo	($tmp2,$r1,$d0)

	mfhi	($h2,$r1,$d0)

	 daddu	$h0,$tmp0

	 daddu	$h1,$tmp1

	 sltu	$tmp0,$h0,$tmp0



	dmultu	($r0,$d1)		# h1*r0

	 daddu	$h1,$tmp0

	 daddu	$h1,$tmp2

	mflo	($tmp0,$r0,$d1)

	mfhi	($tmp1,$r0,$d1)



	dmultu	($rs1,$d2)		# h2*5*r1

	 sltu	$tmp2,$h1,$tmp2

	 daddu	$h2,$tmp2

	mflo	($tmp2,$rs1,$d2)



	dmultu	($r0,$d2)		# h2*r0

	 daddu	$h1,$tmp0

	 daddu	$h2,$tmp1

	mflo	($tmp3,$r0,$d2)

	 sltu	$tmp0,$h1,$tmp0

	 daddu	$h2,$tmp0



	daddu	$h1,$tmp2

	sltu	$tmp2,$h1,$tmp2

	daddu	$h2,$tmp2

	daddu	$h2,$tmp3



	bne	$inp,$len,.Loop



	sd	$h0,0($ctx)		# store hash value

	sd	$h1,8($ctx)

	sd	$h2,16($ctx)



	.set	noreorder

#if defined(_MIPS_ARCH_MIPS64R6)

	ld	$s7,56($sp)

	ld	$s6,48($sp)

#endif

	ld	$s5,40($sp)		# epilogue

	ld	$s4,32($sp)

___

$code.=<<___ if ($flavour =~ /nubi/i);	# optimize non-nubi epilogue

	ld	$s3,24($sp)

	ld	$s2,16($sp)

	ld	$s1,8($sp)

	ld	$s0,0($sp)

___

<<___;

if defined(_MIPS_ARCH_MIPS64R6)

else

endif

my ($ctx,$mac,$nonce) = ($a0,$a1,$a2);



<<___;

 final reduction

 compare to modulus

 see if it carried/borrowed

 load nonce

 accumulate nonce

 write mac value

 32-bit code path



my ($ctx,$inp,$len,$padbit) = ($a0,$a1,$a2,$a3);



$code.=<<___;

#if (defined(_MIPS_ARCH_MIPS32R3) || defined(_MIPS_ARCH_MIPS32R5) || \\

     defined(_MIPS_ARCH_MIPS32R6)) \\

     && !defined(_MIPS_ARCH_MIPS32R2)

# define _MIPS_ARCH_MIPS32R2

#endif



#if defined(_MIPS_ARCH_MIPS32R6)

# define multu(rs,rt)

# define mflo(rd,rs,rt)	mulu	rd,rs,rt

# define mfhi(rd,rs,rt)	muhu	rd,rs,rt

#else

# define multu(rs,rt)	multu	rs,rt

# define mflo(rd,rs,rt)	mflo	rd

# define mfhi(rd,rs,rt)	mfhi	rd

#endif



#ifdef	__KERNEL__

# define poly1305_init   poly1305_init_mips

# define poly1305_blocks poly1305_blocks_mips

# define poly1305_emit   poly1305_emit_mips

#endif



#if defined(__MIPSEB__) && !defined(MIPSEB)

# define MIPSEB

#endif



#ifdef MIPSEB

# define MSB 0

# define LSB 3

#else

# define MSB 3

# define LSB 0

#endif



.text

.set	noat

.set	noreorder



.align	5

.globl	poly1305_init

.ent	poly1305_init

poly1305_init:

	.frame	$sp,0,$ra

	.set	reorder



	sw	$zero,0($ctx)

	sw	$zero,4($ctx)

	sw	$zero,8($ctx)

	sw	$zero,12($ctx)

	sw	$zero,16($ctx)



	beqz	$inp,.Lno_key



#if defined(_MIPS_ARCH_MIPS32R6)

	andi	$tmp0,$inp,3		# $inp % 4

	subu	$inp,$inp,$tmp0		# align $inp

	sll	$tmp0,$tmp0,3		# byte to bit offset

	lw	$in0,0($inp)

	lw	$in1,4($inp)

	lw	$in2,8($inp)

	lw	$in3,12($inp)

	beqz	$tmp0,.Laligned_key



	lw	$tmp2,16($inp)

	subu	$tmp1,$zero,$tmp0

# ifdef	MIPSEB

	sllv	$in0,$in0,$tmp0

	srlv	$tmp3,$in1,$tmp1

	sllv	$in1,$in1,$tmp0

	or	$in0,$in0,$tmp3

	srlv	$tmp3,$in2,$tmp1

	sllv	$in2,$in2,$tmp0

	or	$in1,$in1,$tmp3

	srlv	$tmp3,$in3,$tmp1

	sllv	$in3,$in3,$tmp0

	or	$in2,$in2,$tmp3

	srlv	$tmp2,$tmp2,$tmp1

	or	$in3,$in3,$tmp2

# else

	srlv	$in0,$in0,$tmp0

	sllv	$tmp3,$in1,$tmp1

	srlv	$in1,$in1,$tmp0

	or	$in0,$in0,$tmp3

	sllv	$tmp3,$in2,$tmp1

	srlv	$in2,$in2,$tmp0

	or	$in1,$in1,$tmp3

	sllv	$tmp3,$in3,$tmp1

	srlv	$in3,$in3,$tmp0

	or	$in2,$in2,$tmp3

	sllv	$tmp2,$tmp2,$tmp1

	or	$in3,$in3,$tmp2

# endif

.Laligned_key:

#else

	lwl	$in0,0+MSB($inp)

	lwl	$in1,4+MSB($inp)

	lwl	$in2,8+MSB($inp)

	lwl	$in3,12+MSB($inp)

	lwr	$in0,0+LSB($inp)

	lwr	$in1,4+LSB($inp)

	lwr	$in2,8+LSB($inp)

	lwr	$in3,12+LSB($inp)

#endif

#ifdef	MIPSEB

# if defined(_MIPS_ARCH_MIPS32R2)

	wsbh	$in0,$in0		# byte swap

	wsbh	$in1,$in1

	wsbh	$in2,$in2

	wsbh	$in3,$in3

	rotr	$in0,$in0,16

	rotr	$in1,$in1,16

	rotr	$in2,$in2,16

	rotr	$in3,$in3,16

# else

	srl	$tmp0,$in0,24		# byte swap

	srl	$tmp1,$in0,8

	andi	$tmp2,$in0,0xFF00

	sll	$in0,$in0,24

	andi	$tmp1,0xFF00

	sll	$tmp2,$tmp2,8

	or	$in0,$tmp0

	 srl	$tmp0,$in1,24

	or	$tmp1,$tmp2

	 srl	$tmp2,$in1,8

	or	$in0,$tmp1

	 andi	$tmp1,$in1,0xFF00

	 sll	$in1,$in1,24

	 andi	$tmp2,0xFF00

	 sll	$tmp1,$tmp1,8

	 or	$in1,$tmp0

	srl	$tmp0,$in2,24

	 or	$tmp2,$tmp1

	srl	$tmp1,$in2,8

	 or	$in1,$tmp2

	andi	$tmp2,$in2,0xFF00

	sll	$in2,$in2,24

	andi	$tmp1,0xFF00

	sll	$tmp2,$tmp2,8

	or	$in2,$tmp0

	 srl	$tmp0,$in3,24

	or	$tmp1,$tmp2

	 srl	$tmp2,$in3,8

	or	$in2,$tmp1

	 andi	$tmp1,$in3,0xFF00

	 sll	$in3,$in3,24

	 andi	$tmp2,0xFF00

	 sll	$tmp1,$tmp1,8

	 or	$in3,$tmp0

	 or	$tmp2,$tmp1

	 or	$in3,$tmp2

# endif

#endif

	lui	$tmp0,0x0fff

	ori	$tmp0,0xffff		# 0x0fffffff

	and	$in0,$in0,$tmp0

	subu	$tmp0,3			# 0x0ffffffc

	and	$in1,$in1,$tmp0

	and	$in2,$in2,$tmp0

	and	$in3,$in3,$tmp0



	sw	$in0,20($ctx)

	sw	$in1,24($ctx)

	sw	$in2,28($ctx)

	sw	$in3,32($ctx)



	srl	$tmp1,$in1,2

	srl	$tmp2,$in2,2

	srl	$tmp3,$in3,2

 s1 = r1 + (r1 >> 2)

 ($flavour 
my ($h0,$h1,$h2,$h3,$h4, $r0,$r1,$r2,$r3, $rs1,$rs2,$rs3) =

   ($s0,$s1,$s2,$s3,$s4, $s5,$s6,$s7,$s8, $s9,$s10,$s11);



my $shr = $t2;		# used on R6

 used on R2

$code.=<<___;

.globl	poly1305_blocks

.align	5

.ent	poly1305_blocks

poly1305_blocks:

	.frame	$sp,16*4,$ra

	.mask	$SAVED_REGS_MASK,-4

	.set	noreorder

	subu	$sp, $sp,4*12

	sw	$s11,4*11($sp)

	sw	$s10,4*10($sp)

	sw	$s9, 4*9($sp)

	sw	$s8, 4*8($sp)

	sw	$s7, 4*7($sp)

	sw	$s6, 4*6($sp)

	sw	$s5, 4*5($sp)

	sw	$s4, 4*4($sp)

___

$code.=<<___ if ($flavour =~ /nubi/i);	# optimize non-nubi prologue

	sw	$s3, 4*3($sp)

	sw	$s2, 4*2($sp)

	sw	$s1, 4*1($sp)

	sw	$s0, 4*0($sp)

___

<<___;

 number of complete blocks

if defined(_MIPS_ARCH_MIPS32R6)

 align $inp

 byte to bit offset

endif

 load hash value

 load key

 end of buffer

if defined(_MIPS_ARCH_MIPS32R6)

 load input

 ifdef	MIPSEB

 else

 endif

else

 load input

endif

ifdef	MIPSEB

 if defined(_MIPS_ARCH_MIPS32R2)

 byte swap

 else

 byte swap

 endif

endif

 modulo-scheduled reduction

 accumulate input

 ... and residue

 carry

 carry

 carry

if defined(_MIPS_ARCH_MIPS32R2) && !defined(_MIPS_ARCH_MIPS32R6)

 d0*r0

 d1*s3

 carry

 d2*s2

 d3*s1

 d0*r1

 d1*r0

 d2*s3

 d3*s2

 h4*s1

 hi*1

 d0*r2

 d1*r1

 d2*r0

 d3*s3

 h4*s2

 hi*1

 h4*r0

 d0*r3

 d1*r2

 d2*r1

 d3*r0

 h4*s3

 hi*1

else

 d0*r0

 carry

 d1*s3

 d2*s2

 d3*s1

 d0*r1

 d1*r0

 d2*s3

 d3*s2

 h4*s1

 d0*r2

 d1*r1

 d2*r0

 d3*s3

 h4*s2

 d0*r3

 d1*r2

 d3*r0

 d2*r1

 h4*s3

 h4*r0

 if we loop, padbit is 1

endif

 store hash value

 optimize non-nubi prologue
~ /nubi/i);	# optimize non-nubi prologue

$code.=<<___;

	jr	$ra

	addu	$sp,$sp,4*12

.end	poly1305_blocks

___

}

{

 ($a0,$a1,$a2,$a3);

$code.=<<___;

.align	5

.globl	poly1305_emit

.ent	poly1305_emit

poly1305_emit:

	.frame	$sp,0,$ra

	.set	reorder



	lw	$tmp4,16($ctx)

	lw	$tmp0,0($ctx)

	lw	$tmp1,4($ctx)

	lw	$tmp2,8($ctx)

	lw	$tmp3,12($ctx)



	li	$in0,-4			# final reduction

	srl	$ctx,$tmp4,2

	and	$in0,$in0,$tmp4

	andi	$tmp4,$tmp4,3

	addu	$ctx,$ctx,$in0



	addu	$tmp0,$tmp0,$ctx

	sltu	$ctx,$tmp0,$ctx

	 addiu	$in0,$tmp0,5		# compare to modulus

	addu	$tmp1,$tmp1,$ctx

	 sltiu	$in1,$in0,5

	sltu	$ctx,$tmp1,$ctx

	 addu	$in1,$in1,$tmp1

	addu	$tmp2,$tmp2,$ctx

	 sltu	$in2,$in1,$tmp1

	sltu	$ctx,$tmp2,$ctx

	 addu	$in2,$in2,$tmp2

	addu	$tmp3,$tmp3,$ctx

	 sltu	$in3,$in2,$tmp2

	sltu	$ctx,$tmp3,$ctx

	 addu	$in3,$in3,$tmp3

	addu	$tmp4,$tmp4,$ctx

	 sltu	$ctx,$in3,$tmp3

	 addu	$ctx,$tmp4



	srl	$ctx,2			# see if it carried/borrowed

	subu	$ctx,$zero,$ctx



	xor	$in0,$tmp0

	xor	$in1,$tmp1

	xor	$in2,$tmp2

	xor	$in3,$tmp3

	and	$in0,$ctx

	and	$in1,$ctx

	and	$in2,$ctx

	and	$in3,$ctx

	xor	$in0,$tmp0

	xor	$in1,$tmp1

	xor	$in2,$tmp2

	xor	$in3,$tmp3



	lw	$tmp0,0($nonce)		# load nonce

	lw	$tmp1,4($nonce)

	lw	$tmp2,8($nonce)

	lw	$tmp3,12($nonce)



	addu	$in0,$tmp0		# accumulate nonce

	sltu	$ctx,$in0,$tmp0



	addu	$in1,$tmp1

	sltu	$tmp1,$in1,$tmp1

	addu	$in1,$ctx

	sltu	$ctx,$in1,$ctx

	addu	$ctx,$tmp1



	addu	$in2,$tmp2

	sltu	$tmp2,$in2,$tmp2

	addu	$in2,$ctx

	sltu	$ctx,$in2,$ctx

	addu	$ctx,$tmp2



	addu	$in3,$tmp3

	addu	$in3,$ctx



	srl	$tmp0,$in0,8		# write mac value

	srl	$tmp1,$in0,16

	srl	$tmp2,$in0,24

	sb	$in0, 0($mac)

	sb	$tmp0,1($mac)

	srl	$tmp0,$in1,8

	sb	$tmp1,2($mac)

	srl	$tmp1,$in1,16

	sb	$tmp2,3($mac)

	srl	$tmp2,$in1,24

	sb	$in1, 4($mac)

	sb	$tmp0,5($mac)

	srl	$tmp0,$in2,8

	sb	$tmp1,6($mac)

	srl	$tmp1,$in2,16

	sb	$tmp2,7($mac)

	srl	$tmp2,$in2,24

	sb	$in2, 8($mac)

	sb	$tmp0,9($mac)

	srl	$tmp0,$in3,8

	sb	$tmp1,10($mac)

	srl	$tmp1,$in3,16

	sb	$tmp2,11($mac)

	srl	$tmp2,$in3,24

	sb	$in3, 12($mac)

	sb	$tmp0,13($mac)

	sb	$tmp1,14($mac)

	sb	$tmp2,15($mac)



	jr	$ra

.end	poly1305_emit

.rdata

.asciiz	"Poly1305 for MIPS32, CRYPTOGAMS by \@dot-asm"

.align	2

___

}

}}}



pop and open STDOUT,">$output";

! /usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0

 This code is taken from the OpenSSL project but the author (Andy Polyakov)

 has relicensed it under the GPLv2. Therefore this program is free software;

 you can redistribute it and/or modify it under the terms of the GNU General

 Public License version 2 as published by the Free Software Foundation.



 The original headers, including the original license headers, are

 included below for completeness.

 Copyright 2014-2016 The OpenSSL Project Authors. All Rights Reserved.



 Licensed under the OpenSSL license (the "License").  You may not use

 this file except in compliance with the License.  You can obtain a copy

 in the file LICENSE in the source distribution or at

 https://www.openssl.org/source/license.html

 ====================================================================


 Written by Andy Polyakov <appro@openssl.org> for the OpenSSL

 project. The module is, however, dual licensed under OpenSSL and

 CRYPTOGAMS licenses depending on where you obtain it. For further

 details see http://www.openssl.org/~appro/cryptogams/.

 ====================================================================




 SHA256/512 for ARMv8.



 Performance in cycles per processed byte and improvement coefficient

 over code generated with "default" compiler:



		SHA256-hw	SHA256(*)	SHA512

 Apple A7	1.97		10.5 (+33%)	6.73 (-1%(**))

 Cortex-A53	2.38		15.5 (+115%)	10.0 (+150%(***))

 Cortex-A57	2.31		11.6 (+86%)	7.51 (+260%(***))

 Denver	2.01		10.5 (+26%)	6.70 (+8%)

 X-Gene			20.0 (+100%)	12.8 (+300%(***))

 Mongoose	2.36		13.0 (+50%)	8.36 (+33%)



 (*)	Software SHA256 results are of lesser relevance, presented

	mostly for informational purposes.

 (**)	The result is a trade-off: it's possible to improve it by

	10% (or by 1 cycle per round), but at the cost of 20% loss

	on Cortex-A53 (or by 4 cycles per round).

 (***)	Super-impressive coefficients over gcc-generated code are

	indication of some compiler "pathology", most notably code

	generated with -mgeneral-regs-only is significanty faster

	and the gap is only 40-90%.



 October 2016.



 Originally it was reckoned that it makes no sense to implement NEON

 version of SHA256 for 64-bit processors. This is because performance

 improvement on most wide-spread Cortex-A5x processors was observed

 to be marginal, same on Cortex-A53 and ~10% on A57. But then it was

 observed that 32-bit NEON SHA256 performs significantly better than

 64-bit scalar version on *some* of the more recent processors. As

 result 64-bit NEON version of SHA256 was added to provide best

 all-round performance. For example it executes ~30% faster on X-Gene

 and Mongoose. [For reference, NEON version of SHA512 is bound to

 deliver much less improvement, likely *negative* on Cortex-A5x.

 Which is why NEON support is limited to SHA256.]

$output=pop;

pop;

~ m/(.*[\/\\])[^\/\\]+$/; $dir
    ( $xlate="${dir}arm-xlate.pl" and -f $xlate ) or

"${dir}../../perlasm/arm-xlate.pl" and -f $xlate) or

    *STDOUT=*OUT;

} else {

    open STDOUT,">$output";

}



~ /512/) {

	$BITS=512;

8;

	@Sigma0=(28,34,39);

(14,18,41);

	@sigma0=(1,  8, 7);

(19,61, 6);

	$rounds=80;

"x";

	$BITS=256;

4;

	@Sigma0=( 2,13,22);

( 6,11,25);

	@sigma0=( 7,18, 3);

(17,19,10);

	$rounds=64;

"w";

$func="sha${BITS}_block_data_order";



map("x$_",(0..2,30));

@X=map("$reg_t$_",(3..15,0..2));

@V=($A,$B,$C,$D,$E,$F,$G,$H)=map("$reg_t$_",(20..27));

map("$reg_t$_",(16,17,19,28));

my ($i,$a,$b,$c,$d,$e,$f,$g,$h)=@_;

($i+1)&15;

my ($T0,$T1,$T2)=(@X[($i-8)&15],@X[($i-9)&15],@X[($i-10)&15]);

@X[$i+3] if ($i<11);

$code.=<<___	if ($i<16);

#ifndef	__AARCH64EB__

	rev	@X[$i],@X[$i]			// $i

#endif

___

<<___	if ($i<13 && ($i&1));

2*$SZ

$code.=<<___	if ($i==13);

	ldp	@X[14],@X[15],[$inp]

___

$code.=<<___	if ($i>=14);

	ldr	@X[($i-11)&15],[sp,#`$SZ*(($i-11)%4)`]

___

<<___	if ($i>0 && $i<16);

	add	$a,$a,$t1			// h+=Sigma0(a)

___

$code.=<<___	if ($i>=11);

	str	@X[($i-8)&15],[sp,#`$SZ*(($i-8)%4)`]

___

# While ARMv8 specifies merged rotate-n-logical operation such as

# 'eor x,y,z,ror#n', it was found to negatively affect performance

# on Apple A7. The reason seems to be that it requires even 'y' to

# be available earlier. This means that such merged instruction is

# not necessarily best choice on critical path... On the other hand

# Cortex-A5x handles merged instructions much better than disjoint

# rotate and logical... See (**) footnote above.

<<___	if ($i<15);

$Sigma1[0]

	add	$h,$h,$t2			// h+=K[i]

	eor	$T0,$e,$e,ror#`$Sigma1[2]-$Sigma1[1]`

	and	$t1,$f,$e

	bic	$t2,$g,$e

X[i]

$Sigma1[1]	// Sigma1(e)

$Sigma0[0]

	add	$h,$h,$t1			// h+=Ch(e,f,g)

	eor	$t1,$a,$a,ror#`$Sigma0[2]-$Sigma0[1]`

Sigma1(e)

	and	$t3,$t3,$t2			// (b^c)&=(a^b)

h

$Sigma0[1]	// Sigma0(a)

	add	$h,$h,$t3			// h+=Maj(a,b,c)

	ldr	$t3,[$Ktbl],#$SZ		// *K++, $t2 in next round

Sigma0(a)

<<___	if ($i>
$Sigma1[0]

	add	$h,$h,$t2			// h+=K[i]

	ror	$T1,@X[($j+1)&15],#$sigma0[0]

	and	$t1,$f,$e

	ror	$T2,@X[($j+14)&15],#$sigma1[0]

	bic	$t2,$g,$e

	ror	$T0,$a,#$Sigma0[0]

X[i]

$Sigma1[1]

$sigma0[1]

$Sigma1[2]	// Sigma1(e)

$Sigma0[1]

	add	$h,$h,$t1			// h+=Ch(e,f,g)

(a^b)

$sigma1[1]

$sigma0[2]	// sigma0(X[i+1])

	add	$h,$h,$t0			// h+=Sigma1(e)

	eor	$t3,$t3,$b			// Maj(a,b,c)

	eor	$t1,$T0,$a,ror#$Sigma0[2]	// Sigma0(a)

	eor	$T2,$T2,@X[($j+14)&15],lsr#$sigma1[2]	// sigma1(X[i+14])

	add	@X[$j],@X[$j],@X[($j+9)&15]

h

	add	$h,$h,$t3			// h+=Maj(a,b,c)

	ldr	$t3,[$Ktbl],#$SZ		// *K++, $t2 in next round

	add	@X[$j],@X[$j],$T1

Sigma0(a)

	($t2,$t3)=($t3,$t2);

}



<<___;

ifndef	__KERNEL__

 include "arm_arch.h"

endif

$code.=<<___	if ($SZ==4);

#ifndef	__KERNEL__

# ifdef	__ILP32__

	ldrsw	x16,.LOPENSSL_armcap_P

# else

	ldr	x16,.LOPENSSL_armcap_P

# endif

	adr	x17,.LOPENSSL_armcap_P

	add	x16,x16,x17

	ldr	w16,[x16]

	tst	w16,#ARMV8_SHA256

	b.ne	.Lv8_entry

	tst	w16,#ARMV7_NEON

	b.ne	.Lneon_entry

#endif

___

<<___;

-128]!

0

16]

32]

48]

64]

80]

4*$SZ

2*$SZ]

4*$SZ]

`log(16*$SZ)/log(2)`	// end of input

6*$SZ]

96]

2*$SZ

$SZ			// *K++

112]

for ($i=0;$i<16;$i++)	{ &BODY_00_xx($i,@V); unshift(@V,pop(@V)); }

".Loop_16_xx:\n";

$code.=<<___;

	cbnz	$t2,.Loop_16_xx



	ldp	$ctx,$num,[x29,#96]

	ldr	$inp,[x29,#112]

	sub	$Ktbl,$Ktbl,#`$SZ*($rounds+1)`		// rewind



	ldp	@X[0],@X[1],[$ctx]

	ldp	@X[2],@X[3],[$ctx,#2*$SZ]

	add	$inp,$inp,#14*$SZ			// advance input pointer

	ldp	@X[4],@X[5],[$ctx,#4*$SZ]

	add	$A,$A,@X[0]

	ldp	@X[6],@X[7],[$ctx,#6*$SZ]

	add	$B,$B,@X[1]

	add	$C,$C,@X[2]

	add	$D,$D,@X[3]

	stp	$A,$B,[$ctx]

	add	$E,$E,@X[4]

	add	$F,$F,@X[5]

	stp	$C,$D,[$ctx,#2*$SZ]

	add	$G,$G,@X[6]

	add	$H,$H,@X[7]

	cmp	$inp,$num

	stp	$E,$F,[$ctx,#4*$SZ]

	stp	$G,$H,[$ctx,#6*$SZ]

	b.ne	.Loop



	ldp	x19,x20,[x29,#16]

	add	sp,sp,#4*$SZ

	ldp	x21,x22,[x29,#32]

	ldp	x23,x24,[x29,#48]

	ldp	x25,x26,[x29,#64]

	ldp	x27,x28,[x29,#80]

	ldp	x29,x30,[sp],#128

	ret

.size	$func,.-$func



.align	6

.type	.LK$BITS,%object

.LK$BITS:

___

<<___ if ($SZ8);

$code.=<<___ if ($SZ==4);

	.long	0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5

	.long	0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5

	.long	0xd807aa98,0x12835b01,0x243185be,0x550c7dc3

	.long	0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174

	.long	0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc

	.long	0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da

	.long	0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7

	.long	0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967

	.long	0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13

	.long	0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85

	.long	0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3

	.long	0xd192e819,0xd6990624,0xf40e3585,0x106aa070

	.long	0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5

	.long	0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3

	.long	0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208

	.long	0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2

	.long	0	//terminator

___

<<___;

ifndef	__KERNEL__

 ifdef	__ILP32__

 else

 endif

endif

my $Ktbl="x3";



map("v$_.16b",(0..2));

my @MSG=map("v$_.16b",(4..7));

("v16.4s","v17.4s");

my ($ABCD_SAVE,$EFGH_SAVE)=("v18.16b","v19.16b");



<<___;

ifndef	__KERNEL__

-16]!

0

64

1

16

for($i=0;$i<12;$i++) {

<<___;

16

	($W0,$W1)=($W1,$W0);	push(@MSG,shift(@MSG));

}

<<___;

16

16

$rounds*$SZ-16	// rewind

16

endif

 NEON stuff 
 You'll surely note a lot of similarities with sha256-armv4 module,

 and of course it's not a coincidence. sha256-armv4 was used as

 initial template, but was adapted for ARMv8 instruction set and

 extensively re-tuned for all-round performance.

 ($A,$B,$C,$D,$E,$F,$G,$H) 
my ($t0,$t1,$t2,$t3,$t4) = map("w$_",(11..15));

"x16";

my $Xfer="x17";

 map("q$_",(0..3));

my ($T0,$T1,$T2,$T3,$T4,$T5,$T6,$T7) = map("q$_",(4..7,16..19));

0;

 thunk [simplified] x86-style perlasm

{ my $opcode = $AUTOLOAD; $opcode =~ s/.*:://; $opcode =~ s/_/\./;

 pop;

    $arg = "#$arg" if ($arg*1 eq $arg);

 "\t$opcode\t".join(',',@_,$arg)."\n";

sub Dscalar { shift =~ m|[qv]([0-9]+)|?"d$1":""; }

~ m|[qv]([0-9]+)|?"v$1.d[0]":""; }

sub Dhi     { shift =~ m|[qv]([0-9]+)|?"v$1.d[1]":""; }



sub Xupdate()

{ use integer;

 shift;

  my @insns = (&$body,&$body,&$body,&$body);

  my ($a,$b,$c,$d,$e,$f,$g,$h);



	&ext_8		($T0,@X[0],@X[1],4);	# X[1..4]

	 eval(shift(@insns));

	 eval(shift(@insns));

	 eval(shift(@insns));

	&ext_8		($T3,@X[2],@X[3],4);	# X[9..12]

	 eval(shift(@insns));

	 eval(shift(@insns));

	&mov		(&Dscalar($T7),&Dhi(@X[3]));	# X[14..15]

	 eval(shift(@insns));

	 eval(shift(@insns));

	&ushr_32	($T2,$T0,$sigma0[0]);

	 eval(shift(@insns));

	&ushr_32	($T1,$T0,$sigma0[2]);

	 eval(shift(@insns));

 X[0..3] += X[9..12]

 sigma0(X[1..4])

	&add_32		(@X[0],@X[0],$T1);	# X[0..3] += sigma0(X[1..4])

	 eval(shift(@insns));

	 eval(shift(@insns));

	  &sli_u32	($T3,$T7,32-$sigma1[1]);

	 eval(shift(@insns));

	 eval(shift(@insns));

	  &eor_8	($T5,$T5,$T4);

	 eval(shift(@insns));

	 eval(shift(@insns));

	 eval(shift(@insns));

	  &eor_8	($T5,$T5,$T3);		# sigma1(X[14..15])

	 eval(shift(@insns));

	 eval(shift(@insns));

	 eval(shift(@insns));

 X[0..1] += sigma1(X[14..15])

16");

 sigma1(X[16..17])

	&add_32		(@X[0],@X[0],$T5);	# X[2..3] += sigma1(X[16..17])

	 eval(shift(@insns));

	 eval(shift(@insns));

	 eval(shift(@insns));

	&add_32		($T0,$T0,@X[0]);

insns>=1) { eval(shift(@insns)); }

16");

 "rotate" X[]

  my $body = shift;

 (&$body,&$body,&$body,&$body);

16");

16");

 remaining instructions

16");

 "rotate" X[]

	'($a,$b,$c,$d,$e,$f,$g,$h)=@V;'.

 h+=X[i]+K[i]

	'&add	($a,$a,$t4);'.			# h+=Sigma0(a) from the past

	'&and	($t1,$f,$e)',

	'&bic	($t4,$g,$e)',

	'&eor	($t0,$e,$e,"ror#".($Sigma1[1]-$Sigma1[0]))',

 h+=Maj(a,b,c) from the past

 Ch(e,f,g)

".($Sigma1[2]-$Sigma1[0]))',	
".($Sigma0[1]-$Sigma0[0]))',

	'&add	($h,$h,$t1)',			# h+=Ch(e,f,g)

	'&ror	($t0,$t0,"#$Sigma1[0]")',

	'&eor	($t2,$a,$b)',			# a^b, b^c in next round

	'&eor	($t4,$t4,$a,"ror#".($Sigma0[2]-$Sigma0[0]))',	# Sigma0(a)

 h+=Sigma1(e)

	'&ldr	($t1,sprintf "[sp,#%d]",4*(($j+1)&15))	if (($j&15)!=15);'.

	'&ldr	($t1,"[$Ktbl]")				if ($j==15);'.

 (b^c)&=(a^b)

$Sigma0[0]")',

	'&add	($d,$d,$h)',			# d+=h

	'&eor	($t3,$t3,$b)',			# Maj(a,b,c)

($t3,$t2);'

$code.=<<___;

#ifdef	__KERNEL__

.globl	sha256_block_neon

#endif

.type	sha256_block_neon,%function

.align	4

sha256_block_neon:

.Lneon_entry:

	stp	x29, x30, [sp, #-16]!

	mov	x29, sp

	sub	sp,sp,#16*4



	adr	$Ktbl,.LK256

	add	$num,$inp,$num,lsl#6	// len to point at the end of inp



	ld1.8	{@X[0]},[$inp], #16

	ld1.8	{@X[1]},[$inp], #16

	ld1.8	{@X[2]},[$inp], #16

	ld1.8	{@X[3]},[$inp], #16

	ld1.32	{$T0},[$Ktbl], #16

	ld1.32	{$T1},[$Ktbl], #16

	ld1.32	{$T2},[$Ktbl], #16

	ld1.32	{$T3},[$Ktbl], #16

	rev32	@X[0],@X[0]		// yes, even on

	rev32	@X[1],@X[1]		// big-endian

	rev32	@X[2],@X[2]

	rev32	@X[3],@X[3]

	mov	$Xfer,sp

	add.32	$T0,$T0,@X[0]

	add.32	$T1,$T1,@X[1]

	add.32	$T2,$T2,@X[2]

	st1.32	{$T0-$T1},[$Xfer], #32

	add.32	$T3,$T3,@X[3]

	st1.32	{$T2-$T3},[$Xfer]

	sub	$Xfer,$Xfer,#32



	ldp	$A,$B,[$ctx]

	ldp	$C,$D,[$ctx,#8]

	ldp	$E,$F,[$ctx,#16]

	ldp	$G,$H,[$ctx,#24]

	ldr	$t1,[sp,#0]

	mov	$t2,wzr

	eor	$t3,$B,$C

	mov	$t4,wzr

	b	.L_00_48



.align	4

.L_00_48:

___

	&Xupdate(\&body_00_15);

	&Xupdate(\&body_00_15);

	&Xupdate(\&body_00_15);

	&Xupdate(\&body_00_15);

<<___;

0				// check for K256 terminator

0]

64

256		// rewind $Ktbl

64

$code.=<<___;

Sigma0(a) from the past

0]

	add	$A,$A,$t2			// h+=Maj(a,b,c) from the past

	ldp	$t2,$t3,[$ctx,#8]

	add	$A,$A,$t0			// accumulate

	add	$B,$B,$t1

	ldp	$t0,$t1,[$ctx,#16]

	add	$C,$C,$t2

	add	$D,$D,$t3

	ldp	$t2,$t3,[$ctx,#24]

	add	$E,$E,$t0

	add	$F,$F,$t1

	 ldr	$t1,[sp,#0]

	stp	$A,$B,[$ctx,#0]

	add	$G,$G,$t2

	 mov	$t2,wzr

	stp	$C,$D,[$ctx,#8]

	add	$H,$H,$t3

	stp	$E,$F,[$ctx,#16]

	 eor	$t3,$B,$C

	stp	$G,$H,[$ctx,#24]

	 mov	$t4,wzr

	 mov	$Xfer,sp

	b.ne	.L_00_48



	ldr	x29,[x29]

	add	sp,sp,#16*4+16

	ret

.size	sha256_block_neon,.-sha256_block_neon

___

}



<<___;

ifndef	__KERNEL__

endif

{   my  %opcode = (

	"sha256h"	=> 0x5e004000,	"sha256h2"	=> 0x5e005000,

	"sha256su0"	=> 0x5e282800,	"sha256su1"	=> 0x5e006000	);



    sub unsha256 {

@_;

	$arg =~ m/[qv]([0-9]+)[^,]*,\s*[qv]([0-9]+)[^,]*(?:,\s*[qv]([0-9]+))?/o

	&&

	sprintf ".inst\t0x%08x\t//%s %s",

			$opcode{$mnemonic}|$1|($2<<5)|($3<<16),

			$mnemonic,$arg;

    }

}



open SELF,$0;

while(<SELF>) {

        next if (/^#!/);

        last if (!s/^#/\/\// and !/^$/);

        print;

}

close SELF;



foreach(split("\n",$code)) {



	s/\`([^\`]*)\`/eval($1)/ge;



	s/\b(sha256\w+)\s+([qv].*)/unsha256($1,$2)/ge;



	s/\bq([0-9]+)\b/v$1.16b/g;		# old->new registers



	s/\.[ui]?8(\s)/$1/;

	s/\.\w?32\b//		and s/\.16b/\.4s/g;

	m/(ld|st)1[^\[]+\[0\]/	and s/\.4s/\.s/g;



	print $_,"\n";

}



close STDOUT;

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-1.0+ OR BSD-3-Clause



 ====================================================================


 Written by Andy Polyakov, @dot-asm, initially for the OpenSSL

 project.

 ====================================================================




 This module implements Poly1305 hash for ARMv8.



 June 2015



 Numbers are cycles per processed byte with poly1305_blocks alone.



		IALU/gcc-4.9	NEON



 Apple A7	1.86/+5%	0.72

 Cortex-A53	2.69/+58%	1.47

 Cortex-A57	2.70/+7%	1.14

 Denver	1.64/+50%	1.18(*)

 X-Gene	2.13/+68%	2.27

 Mongoose	1.77/+75%	1.12

 Kryo		2.70/+55%	1.13

 ThunderX2	1.17/+95%	1.36



 (*)	estimate based on resources availability is less than 1.0,

	i.e. measured result is worse than expected, presumably binary

	translator is not almighty;

$flavour=shift;

shift;

~ m/(.*[\/\\])[^\/\\]+$/; $dir
    ( $xlate="${dir}arm-xlate.pl" and -f $xlate ) or

"${dir}../../perlasm/arm-xlate.pl" and -f $xlate) or

my ($ctx,$inp,$len,$padbit) = map("x$_",(0..3));

($inp,$len);

my ($h0,$h1,$h2,$r0,$r1,$s1,$t0,$t1,$d0,$d1,$d2) = map("x$_",(4..14));



<<___;

ifndef __KERNEL__

 include "arm_arch.h"

endif

16]	// [along with is_base2_26]

ifndef	__KERNEL__

:lo12:OPENSSL_armcap_P]

endif

0xfffffffc0fffffff

0x0fff,lsl
ifdef	__AARCH64EB__

endif

	and	$r0,$r0,$s1		// &=0ffffffc0fffffff

	and	$s1,$s1,#-4

0ffffffc0ffffffc

$s1,
32]	// save key value

$s1,[$ctx,
ifndef	__KERNEL__

ARMV7_NEON

 ifdef	__ILP32__

$d0,w
 else

 endif

endif

1

-16

16]	// [along with is_base2_26]

32]	// load key value

ifdef	__AARCH64EB__

32

$d1,w
32

$h1

32

else

$d0,w
32

$d2,w
32

$h2

endif

26	// base 2^26 -> base 2^64

12

52

14

24

40

0			// is_base2_26?

	add	$s1,$r1,$r1,lsr#2	// s1 = r1 + (r1 >> 2)

	csel	$h0,$h0,$d0,eq		// choose between radixes

	csel	$h1,$h1,$d1,eq

	csel	$h2,$h2,$d2,eq



.Loop:

	ldp	$t0,$t1,[$inp],#16	// load input

	sub	$len,$len,#16

#ifdef	__AARCH64EB__

	rev	$t0,$t0

	rev	$t1,$t1

#endif

	adds	$h0,$h0,$t0		// accumulate input

	adcs	$h1,$h1,$t1



	mul	$d0,$h0,$r0		// h0*r0

	adc	$h2,$h2,$padbit

	umulh	$d1,$h0,$r0



	mul	$t0,$h1,$s1		// h1*5*r1

	umulh	$t1,$h1,$s1



	adds	$d0,$d0,$t0

	mul	$t0,$h0,$r1		// h0*r1

	adc	$d1,$d1,$t1

	umulh	$d2,$h0,$r1



	adds	$d1,$d1,$t0

	mul	$t0,$h1,$r0		// h1*r0

	adc	$d2,$d2,xzr

	umulh	$t1,$h1,$r0



	adds	$d1,$d1,$t0

	mul	$t0,$h2,$s1		// h2*5*r1

	adc	$d2,$d2,$t1

	mul	$t1,$h2,$r0		// h2*r0



	adds	$d1,$d1,$t0

	adc	$d2,$d2,$t1



	and	$t0,$d2,#-4		// final reduction

	and	$h2,$d2,#3

	add	$t0,$t0,$d2,lsr#2

	adds	$h0,$d0,$t0

	adcs	$h1,$d1,xzr

	adc	$h2,$h2,xzr



	cbnz	$len,.Loop



	stp	$h0,$h1,[$ctx]		// store hash value

	stp	$h2,xzr,[$ctx,#16]	// [and clear is_base2_26]



.Lno_data:

	ret

.size	poly1305_blocks,.-poly1305_blocks



.type	poly1305_emit,%function

.align	5

poly1305_emit:

.Lpoly1305_emit:

	ldp	$h0,$h1,[$ctx]		// load hash base 2^64

	ldp	$h2,$r0,[$ctx,#16]	// [along with is_base2_26]

	ldp	$t0,$t1,[$nonce]	// load nonce



#ifdef	__AARCH64EB__

	lsr	$d0,$h0,#32

	mov	w#$d1,w#$h0

	lsr	$d2,$h1,#32

	mov	w15,w#$h1

	lsr	x16,$h2,#32

#else

	mov	w#$d0,w#$h0

	lsr	$d1,$h0,#32

	mov	w#$d2,w#$h1

	lsr	x15,$h1,#32

	mov	w16,w#$h2

#endif



	add	$d0,$d0,$d1,lsl#26	// base 2^26 -> base 2^64

	lsr	$d1,$d2,#12

	adds	$d0,$d0,$d2,lsl#52

	add	$d1,$d1,x15,lsl#14

	adc	$d1,$d1,xzr

	lsr	$d2,x16,#24

	adds	$d1,$d1,x16,lsl#40

	adc	$d2,$d2,xzr



	cmp	$r0,#0			// is_base2_26?

	csel	$h0,$h0,$d0,eq		// choose between radixes

	csel	$h1,$h1,$d1,eq

	csel	$h2,$h2,$d2,eq



	adds	$d0,$h0,#5		// compare to modulus

	adcs	$d1,$h1,xzr

	adc	$d2,$h2,xzr



	tst	$d2,#-4			// see if it's carried/borrowed



	csel	$h0,$h0,$d0,eq

	csel	$h1,$h1,$d1,eq



#ifdef	__AARCH64EB__

	ror	$t0,$t0,#32		// flip nonce words

	ror	$t1,$t1,#32

#endif

	adds	$h0,$h0,$t0		// accumulate nonce

	adc	$h1,$h1,$t1

#ifdef	__AARCH64EB__

	rev	$h0,$h0			// flip output bytes

	rev	$h1,$h1

#endif

	stp	$h0,$h1,[$mac]		// write result



	ret

.size	poly1305_emit,.-poly1305_emit

___

 map("v$_.4s",(0..8));

my ($IN01_0,$IN01_1,$IN01_2,$IN01_3,$IN01_4) = map("v$_.2s",(9..13));

 map("v$_.2s",(14..18));

my ($ACC0,$ACC1,$ACC2,$ACC3,$ACC4) = map("v$_.2d",(19..23));

 map("v$_.2s",(24..28));

my ($T0,$T1,$MASK) = map("v$_",(29..31));



("x16","x17");

my $is_base2_26 = $zeros;		# borrow



<<___;

-4		// final reduction

3

2

0x03ffffff	// base 2^64 -> base 2^26

26,
52

0x03ffffff

14,
40

16*0]	// r0

2	// r1*5

16*1]	// r1

2	// r2*5

16*2]	// s1

16*3]	// r2

2	// r3*5

16*4]	// s2

16*5]	// r3

2	// r4*5

16*6]	// s3

16*7]	// r4

16*8]	// s4

ifdef	__KERNEL__

endif

24]

128

-80]!

0

16]		// meet ABI requirements

32]

48]

64]

8]

16]

31

32]	// load key value

26	// base 2^26 -> base 2^64

12

52

14

24

40

16	// load input

16

	add	$s1,$r1,$r1,lsr#2	// s1 = r1 + (r1 >> 2)



#ifdef	__AARCH64EB__

	rev	$d0,$d0

	rev	$d1,$d1

#endif

	adds	$h0,$h0,$d0		// accumulate input

	adcs	$h1,$h1,$d1

	adc	$h2,$h2,$padbit



	bl	poly1305_mult



	and	x10,$h0,#0x03ffffff	// base 2^64 -> base 2^26

	ubfx	x11,$h0,#26,#26

	extr	x12,$h1,$h0,#52

	and	x12,x12,#0x03ffffff

	ubfx	x13,$h1,#14,#26

	extr	x14,$h2,$h1,#40



	b	.Leven_neon



.align	4

.Lbase2_64_neon:

	ldp	$r0,$r1,[$ctx,#32]	// load key value



	ldp	$h0,$h1,[$ctx]		// load hash value base 2^64

	ldr	$h2,[$ctx,#16]



	tst	$len,#31

	b.eq	.Linit_neon



	ldp	$d0,$d1,[$inp],#16	// load input

	sub	$len,$len,#16

2	// s1 = r1 + (r1 >> 2)

ifdef	__AARCH64EB__

endif

48]		// first table element

0x03ffffff	// base 2^64 -> base 2^26

26,
52

0x03ffffff

14,
40

-1			// is value impossible?

	add	$s1,$r1,$r1,lsr#2	// s1 = r1 + (r1 >> 2)

	mov	$h1,$r1

	mov	$h2,xzr

	add	$ctx,$ctx,#48+12

	bl	poly1305_splat



	bl	poly1305_mult		// r^2

	sub	$ctx,$ctx,#4

	bl	poly1305_splat



	bl	poly1305_mult		// r^3

	sub	$ctx,$ctx,#4

	bl	poly1305_splat



	bl	poly1305_mult		// r^4

	sub	$ctx,$ctx,#4

	bl	poly1305_splat

	sub	$ctx,$ctx,#48		// restore original $ctx

	b	.Ldo_neon



.align	4

.Leven_neon:

	fmov	${H0},x10

	fmov	${H1},x11

	fmov	${H2},x12

	fmov	${H3},x13

	fmov	${H4},x14



.Ldo_neon:

	ldp	x8,x12,[$inp,#32]	// inp[2:3]

	subs	$len,$len,#64

	ldp	x9,x13,[$inp,#48]

	add	$in2,$inp,#96

	adr	$zeros,.Lzeros



	lsl	$padbit,$padbit,#24

	add	x15,$ctx,#48



#ifdef	__AARCH64EB__

	rev	x8,x8

	rev	x12,x12

	rev	x9,x9

	rev	x13,x13

#endif

	and	x4,x8,#0x03ffffff	// base 2^64 -> base 2^26

	and	x5,x9,#0x03ffffff

	ubfx	x6,x8,#26,#26

	ubfx	x7,x9,#26,#26

	add	x4,x4,x5,lsl#32		// bfi	x4,x5,#32,#32

	extr	x8,x12,x8,#52

	extr	x9,x13,x9,#52

	add	x6,x6,x7,lsl#32		// bfi	x6,x7,#32,#32

	fmov	$IN23_0,x4

	and	x8,x8,#0x03ffffff

	and	x9,x9,#0x03ffffff

	ubfx	x10,x12,#14,#26

	ubfx	x11,x13,#14,#26

	add	x12,$padbit,x12,lsr#40

	add	x13,$padbit,x13,lsr#40

	add	x8,x8,x9,lsl#32		// bfi	x8,x9,#32,#32

	fmov	$IN23_1,x6

	add	x10,x10,x11,lsl#32	// bfi	x10,x11,#32,#32

	add	x12,x12,x13,lsl#32	// bfi	x12,x13,#32,#32

	fmov	$IN23_2,x8

	fmov	$IN23_3,x10

	fmov	$IN23_4,x12



	ldp	x8,x12,[$inp],#16	// inp[0:1]

	ldp	x9,x13,[$inp],#48



	ld1	{$R0,$R1,$S1,$R2},[x15],#64

	ld1	{$S2,$R3,$S3,$R4},[x15],#64

	ld1	{$S4},[x15]



#ifdef	__AARCH64EB__

	rev	x8,x8

	rev	x12,x12

	rev	x9,x9

	rev	x13,x13

#endif

	and	x4,x8,#0x03ffffff	// base 2^64 -> base 2^26

	and	x5,x9,#0x03ffffff

	ubfx	x6,x8,#26,#26

	ubfx	x7,x9,#26,#26

	add	x4,x4,x5,lsl#32		// bfi	x4,x5,#32,#32

	extr	x8,x12,x8,#52

	extr	x9,x13,x9,#52

	add	x6,x6,x7,lsl#32		// bfi	x6,x7,#32,#32

	fmov	$IN01_0,x4

	and	x8,x8,#0x03ffffff

	and	x9,x9,#0x03ffffff

	ubfx	x10,x12,#14,#26

	ubfx	x11,x13,#14,#26

	add	x12,$padbit,x12,lsr#40

	add	x13,$padbit,x13,lsr#40

	add	x8,x8,x9,lsl#32		// bfi	x8,x9,#32,#32

	fmov	$IN01_1,x6

	add	x10,x10,x11,lsl#32	// bfi	x10,x11,#32,#32

	add	x12,x12,x13,lsl#32	// bfi	x12,x13,#32,#32

	movi	$MASK.2d,#-1

	fmov	$IN01_2,x8

	fmov	$IN01_3,x10

	fmov	$IN01_4,x12

	ushr	$MASK.2d,$MASK.2d,#38



	b.ls	.Lskip_loop



.align	4

.Loop_neon:

	////////////////////////////////////////////////////////////////

	// ((inp[0]*r^4+inp[2]*r^2+inp[4])*r^4+inp[6]*r^2

	// ((inp[1]*r^4+inp[3]*r^2+inp[5])*r^3+inp[7]*r

	//   \___________________/

	// ((inp[0]*r^4+inp[2]*r^2+inp[4])*r^4+inp[6]*r^2+inp[8])*r^2

	// ((inp[1]*r^4+inp[3]*r^2+inp[5])*r^4+inp[7]*r^2+inp[9])*r

	//   \___________________/ \____________________/

	//

	// Note that we start with inp[2:3]*r^2. This is because it

	// doesn't depend on reduction in previous iteration.

	////////////////////////////////////////////////////////////////

 h0*r4 + h1*r3   + h2*r2   + h3*r1   + h4*r0

	// d3 = h0*r3 + h1*r2   + h2*r1   + h3*r0   + h4*5*r4

 h0*r2 + h1*r1   + h2*r0   + h3*5*r4 + h4*5*r3

	// d1 = h0*r1 + h1*r0   + h2*5*r4 + h3*5*r3 + h4*5*r2

 h0*r0 + h1*5*r4 + h2*5*r3 + h3*5*r2 + h4*5*r1

64

16	// inp[2:3] (or zero)

48

ifdef	__AARCH64EB__

endif

0x03ffffff	// base 2^64 -> base 2^26

0x03ffffff

26,
26,
32		// bfi	x4,x5,32

52

52

32		// bfi	x6,x7,32

0x03ffffff

0x03ffffff

14,
14,
32		// bfi	x8,x9,32

40

40

32	// bfi	x10,x11,32

32	// bfi	x12,x13,32

16	// inp[0:1]

48

ifdef	__AARCH64EB__

endif

0x03ffffff	// base 2^64 -> base 2^26

0x03ffffff

26,
26,
32		// bfi	x4,x5,32

52

52

32		// bfi	x6,x7,32

0x03ffffff

0x03ffffff

14,
14,
32		// bfi	x8,x9,32

40

40

32	// bfi	x10,x11,32

32	// bfi	x12,x13,32

26

26

	bic	$H3,#0xfc,lsl#24	// &=0x03ffffff

	 add	$ACC1,$ACC1,$T1.2d	// h0 -> h1



	ushr	$T0.2d,$ACC4,#26

	xtn	$H4,$ACC4

	 ushr	$T1.2d,$ACC1,#26

	 xtn	$H1,$ACC1

	bic	$H4,#0xfc,lsl#24

	 add	$ACC2,$ACC2,$T1.2d	// h1 -> h2



	add	$ACC0,$ACC0,$T0.2d

	shl	$T0.2d,$T0.2d,#2

	 shrn	$T1.2s,$ACC2,#26

	 xtn	$H2,$ACC2

	add	$ACC0,$ACC0,$T0.2d	// h4 -> h0

	 bic	$H1,#0xfc,lsl#24

	 add	$H3,$H3,$T1.2s		// h2 -> h3

	 bic	$H2,#0xfc,lsl#24



	shrn	$T0.2s,$ACC0,#26

	xtn	$H0,$ACC0

	 ushr	$T1.2s,$H3,#26

	 bic	$H3,#0xfc,lsl#24

	 bic	$H0,#0xfc,lsl#24

	add	$H1,$H1,$T0.2s		// h0 -> h1

	 add	$H4,$H4,$T1.2s		// h3 -> h4



	b.hi	.Loop_neon



.Lskip_loop:

	dup	$IN23_2,${IN23_2}[0]

	add	$IN01_2,$IN01_2,$H2



	////////////////////////////////////////////////////////////////

	// multiply (inp[0:1]+hash) or inp[2:3] by r^2:r^1



	adds	$len,$len,#32

	b.ne	.Long_tail



	dup	$IN23_2,${IN01_2}[0]

	add	$IN23_0,$IN01_0,$H0

	add	$IN23_3,$IN01_3,$H3

	add	$IN23_1,$IN01_1,$H1

	add	$IN23_4,$IN01_4,$H4



.Long_tail:

	dup	$IN23_0,${IN23_0}[0]

	umull2	$ACC0,$IN23_2,${S3}

	umull2	$ACC3,$IN23_2,${R1}

	umull2	$ACC4,$IN23_2,${R2}

	umull2	$ACC2,$IN23_2,${R0}

	umull2	$ACC1,$IN23_2,${S4}



	dup	$IN23_1,${IN23_1}[0]

	umlal2	$ACC0,$IN23_0,${R0}

	umlal2	$ACC2,$IN23_0,${R2}

	umlal2	$ACC3,$IN23_0,${R3}

	umlal2	$ACC4,$IN23_0,${R4}

	umlal2	$ACC1,$IN23_0,${R1}



	dup	$IN23_3,${IN23_3}[0]

	umlal2	$ACC0,$IN23_1,${S4}

	umlal2	$ACC3,$IN23_1,${R2}

	umlal2	$ACC2,$IN23_1,${R1}

	umlal2	$ACC4,$IN23_1,${R3}

	umlal2	$ACC1,$IN23_1,${R0}



	dup	$IN23_4,${IN23_4}[0]

	umlal2	$ACC3,$IN23_3,${R0}

	umlal2	$ACC4,$IN23_3,${R1}

	umlal2	$ACC0,$IN23_3,${S2}

	umlal2	$ACC1,$IN23_3,${S3}

	umlal2	$ACC2,$IN23_3,${S4}



	umlal2	$ACC3,$IN23_4,${S4}

	umlal2	$ACC0,$IN23_4,${S1}

	umlal2	$ACC4,$IN23_4,${R0}

	umlal2	$ACC1,$IN23_4,${S2}

	umlal2	$ACC2,$IN23_4,${S3}



	b.eq	.Lshort_tail



	////////////////////////////////////////////////////////////////

	// (hash+inp[0:1])*r^4:r^3 and accumulate



	add	$IN01_0,$IN01_0,$H0

	umlal	$ACC3,$IN01_2,${R1}

	umlal	$ACC0,$IN01_2,${S3}

	umlal	$ACC4,$IN01_2,${R2}

	umlal	$ACC1,$IN01_2,${S4}

	umlal	$ACC2,$IN01_2,${R0}



	add	$IN01_1,$IN01_1,$H1

	umlal	$ACC3,$IN01_0,${R3}

	umlal	$ACC0,$IN01_0,${R0}

	umlal	$ACC4,$IN01_0,${R4}

	umlal	$ACC1,$IN01_0,${R1}

	umlal	$ACC2,$IN01_0,${R2}



	add	$IN01_3,$IN01_3,$H3

	umlal	$ACC3,$IN01_1,${R2}

	umlal	$ACC0,$IN01_1,${S4}

	umlal	$ACC4,$IN01_1,${R3}

	umlal	$ACC1,$IN01_1,${R0}

	umlal	$ACC2,$IN01_1,${R1}



	add	$IN01_4,$IN01_4,$H4

	umlal	$ACC3,$IN01_3,${R0}

	umlal	$ACC0,$IN01_3,${S2}

	umlal	$ACC4,$IN01_3,${R1}

	umlal	$ACC1,$IN01_3,${S3}

	umlal	$ACC2,$IN01_3,${S4}



	umlal	$ACC3,$IN01_4,${S4}

	umlal	$ACC0,$IN01_4,${S1}

	umlal	$ACC4,$IN01_4,${R0}

	umlal	$ACC1,$IN01_4,${S2}

	umlal	$ACC2,$IN01_4,${S3}



.Lshort_tail:

	////////////////////////////////////////////////////////////////

	// horizontal add



	addp	$ACC3,$ACC3,$ACC3

	 ldp	d8,d9,[sp,#16]		// meet ABI requirements

	addp	$ACC0,$ACC0,$ACC0

	 ldp	d10,d11,[sp,#32]

	addp	$ACC4,$ACC4,$ACC4

	 ldp	d12,d13,[sp,#48]

	addp	$ACC1,$ACC1,$ACC1

	 ldp	d14,d15,[sp,#64]

	addp	$ACC2,$ACC2,$ACC2

	 ldr	x30,[sp,#8]



	////////////////////////////////////////////////////////////////

	// lazy reduction, but without narrowing



	ushr	$T0.2d,$ACC3,#26

	and	$ACC3,$ACC3,$MASK.2d

	 ushr	$T1.2d,$ACC0,#26

	 and	$ACC0,$ACC0,$MASK.2d



	add	$ACC4,$ACC4,$T0.2d	// h3 -> h4

	 add	$ACC1,$ACC1,$T1.2d	// h0 -> h1



	ushr	$T0.2d,$ACC4,#26

	and	$ACC4,$ACC4,$MASK.2d

	 ushr	$T1.2d,$ACC1,#26

	 and	$ACC1,$ACC1,$MASK.2d

	 add	$ACC2,$ACC2,$T1.2d	// h1 -> h2



	add	$ACC0,$ACC0,$T0.2d

	shl	$T0.2d,$T0.2d,#2

	 ushr	$T1.2d,$ACC2,#26

	 and	$ACC2,$ACC2,$MASK.2d

	add	$ACC0,$ACC0,$T0.2d	// h4 -> h0

	 add	$ACC3,$ACC3,$T1.2d	// h2 -> h3



	ushr	$T0.2d,$ACC0,#26

	and	$ACC0,$ACC0,$MASK.2d

	 ushr	$T1.2d,$ACC3,#26

	 and	$ACC3,$ACC3,$MASK.2d

	add	$ACC1,$ACC1,$T0.2d	// h0 -> h1

	 add	$ACC4,$ACC4,$T1.2d	// h3 -> h4



	////////////////////////////////////////////////////////////////

	// write the result, can be partially reduced



	st4	{$ACC0,$ACC1,$ACC2,$ACC3}[0],[$ctx],#16

	mov	x4,#1

	st1	{$ACC4}[0],[$ctx]

	str	x4,[$ctx,#8]		// set is_base2_26



	ldr	x29,[sp],#80

	 .inst	0xd50323bf		// autiasp

	ret

.size	poly1305_blocks_neon,.-poly1305_blocks_neon



.align	5

.Lzeros:

.long	0,0,0,0,0,0,0,0

.asciz	"Poly1305 for ARMv8, CRYPTOGAMS by \@dot-asm"

.align	2

#if !defined(__KERNEL__) && !defined(_WIN64)

.comm	OPENSSL_armcap_P,4,4

.hidden	OPENSSL_armcap_P

#endif

___



foreach (split("\n",$code)) {

	s/\b(shrn\s+v[0-9]+)\.[24]d/$1.2s/			or

	s/\b(fmov\s+)v([0-9]+)[^,]*,\s*x([0-9]+)/$1d$2,x$3/	or

	(m/\bdup\b/ and (s/\.[24]s/.2d/g or 1))			or

	(m/\b(eor|and)/ and (s/\.[248][sdh]/.16b/g or 1))	or

	(m/\bum(ul|la)l\b/ and (s/\.4s/.2s/g or 1))		or

	(m/\bum(ul|la)l2\b/ and (s/\.2s/.4s/g or 1))		or

	(m/\bst[1-4]\s+{[^}]+}\[/ and (s/\.[24]d/.s/g or 1));



	s/\.[124]([sd])\[/.$1\[/;

	s/w#x([0-9]+)/w$1/g;



	print $_,"\n";

}

close STDOUT;

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause



 Copyright (C) 2017-2018 Samuel Neves <sneves@dei.uc.pt>. All Rights Reserved.

 Copyright (C) 2017-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

 Copyright (C) 2006-2017 CRYPTOGAMS by <appro@openssl.org>. All Rights Reserved.



 This code is taken from the OpenSSL project but the author, Andy Polyakov,

 has relicensed it under the licenses specified in the SPDX header above.

 The original headers, including the original license headers, are

 included below for completeness.



 ====================================================================


 Written by Andy Polyakov <appro@openssl.org> for the OpenSSL

 project. The module is, however, dual licensed under OpenSSL and

 CRYPTOGAMS licenses depending on where you obtain it. For further

 details see http://www.openssl.org/~appro/cryptogams/.

 ====================================================================




 This module implements Poly1305 hash for x86_64.



 March 2015



 Initial release.



 December 2016



 Add AVX512F+VL+BW code path.



 November 2017



 Convert AVX512F+VL+BW code path to pure AVX512F, so that it can be

 executed even on Knights Landing. Trigger for modification was

 observation that AVX512 code paths can negatively affect overall

 Skylake-X system performance. Since we are likely to suppress

 AVX512F capability flag [at least on Skylake-X], conversion serves

 as kind of "investment protection". Note that next *lake processor,

 Cannonlake, has AVX512IFMA code path to execute...



 Numbers are cycles per processed byte with poly1305_blocks alone,

 measured with rdtsc at fixed clock frequency.



		IALU/gcc-4.8(*)	AVX(**)		AVX2	AVX-512

 P4		4.46/+120%	-

 Core 2	2.41/+90%	-

 Westmere	1.88/+120%	-

 Sandy Bridge	1.39/+140%	1.10

 Haswell	1.14/+175%	1.11		0.65

 Skylake[-X]	1.13/+120%	0.96		0.51	[0.35]

 Silvermont	2.83/+95%	-

 Knights L	3.60/?		1.65		1.10	0.41(***)

 Goldmont	1.70/+180%	-

 VIA Nano	1.82/+150%	-

 Sledgehammer	1.38/+160%	-

 Bulldozer	2.30/+130%	0.97

 Ryzen		1.15/+200%	1.08		1.18



 (*)	improvement coefficients relative to clang are more modest and

	are ~50% on most processors, in both cases we are comparing to

	__int128 code;

 (**)	SSE2 implementation was attempted, but among non-AVX processors

	it was faster than integer-only code only on older Intel P4 and

	Core processors, 50-30%, less newer processor is, but slower on

	contemporary ones, for example almost 2x slower on Atom, and as

	former are naturally disappearing, SSE2 is deemed unnecessary;

 (***)	strangely enough performance seems to vary from core to core,

	listed result is best case;

$flavour = shift;

 shift;

~ /\./) { $output 
0; $win64~ /[nm]asm|mingw64/ || $output 
0; $kernel
~ m/(.*[\/\\])[^\/\\]+$/; $dir
	( $xlate="${dir}x86_64-xlate.pl" and -f $xlate ) or

"${dir}../../perlasm/x86_64-xlate.pl" and -f $xlate) or

	*STDOUT=*OUT;



	if (`$ENV{CC} -Wa,-v -c -o /dev/null -x assembler /dev/null 2>&1`

~ /GNU assembler version ([2-9]\.[0-9]+)/) {

 ($1>2.22) + ($1>
~ /nasm/ || $ENV{ASM} 
	    `nasm -v 2>&1` =~ /NASM version ([2-9]\.[0-9]+)(?:\.([0-9]+))?/) {

		$avx = ($1>=2.09) + ($1>=2.10) + ($1>=2.12);

		$avx += 1 if ($1==2.11 && $2>=8);

	}



	if (!$avx && $win64 && ($flavour =~ /masm/ || $ENV{ASM} =~ /ml64/) &&

~ /Version ([0-9]+)\./) {

		$avx = ($1>=10) + ($1>=11);

	}



~ /((?:^clang|LLVM) version|.*based on LLVM) ([3-9]\.[0-9]+)/) {

 ($2>
	$avx = 4; # The kernel uses ifdefs for this.

}



sub declare_function() {

 @_;

		$code .= ".align $align\n";

 "SYM_FUNC_START($name)\n";

		$code .= ".L$name:\n";

	} else {

 ".globl	$name\n";

		$code .= ".type	$name,\@function,$nargs\n";

 ".align	$align\n";

		$code .= "$name:\n";

	}

}



sub end_function() {

 @_;

		$code .= "SYM_FUNC_END($name)\n";

	} else {

 ".size   $name,.-$name\n";

$code.=<<___ if $kernel;

#include <linux/linkage.h>

___



if ($avx) {

<<___ if $kernel;

$code.=<<___;

.align	64

.Lconst:

.Lmask24:

.long	0x0ffffff,0,0x0ffffff,0,0x0ffffff,0,0x0ffffff,0

.L129:

.long	`1<<24`,0,`1<<24`,0,`1<<24`,0,`1<<24`,0

.Lmask26:

.long	0x3ffffff,0,0x3ffffff,0,0x3ffffff,0,0x3ffffff,0

.Lpermd_avx2:

.long	2,2,2,3,2,0,2,1

.Lpermd_avx512:

.long	0,0,0,1, 0,2,0,3, 0,4,0,5, 0,6,0,7



.L2_44_inp_permd:

.long	0,1,1,2,2,3,7,7

.L2_44_inp_shift:

.quad	0,12,24,64

.L2_44_mask:

.quad	0xfffffffffff,0xfffffffffff,0x3ffffffffff,0xffffffffffffffff

.L2_44_shift_rgt:

.quad	44,44,42,64

.L2_44_shift_lft:

.quad	8,8,10,64



.align	64

.Lx_mask44:

.quad	0xfffffffffff,0xfffffffffff,0xfffffffffff,0xfffffffffff

.quad	0xfffffffffff,0xfffffffffff,0xfffffffffff,0xfffffffffff

.Lx_mask42:

.quad	0x3ffffffffff,0x3ffffffffff,0x3ffffffffff,0x3ffffffffff

.quad	0x3ffffffffff,0x3ffffffffff,0x3ffffffffff,0x3ffffffffff

___

}

<<___ if (!$kernel);

my ($ctx,$inp,$len,$padbit)=("%rdi","%rsi","%rdx","%rcx");

 *_emit arguments

my ($d1,$d2,$d3, $r0,$r1,$s1)=("%r8","%r9","%rdi","%r11","%r12","%r13");

("%r14","%rbx","%r10");

 input:	copy of $r1 in %rax, $h0-$h2, $r0-$r1

# output:	$h0-$h2 *= $r0-$r1

<<___;

 h0*r1

 h0*r0

 future $h0

 h1*r0

 h1*s1

 borrow $h1

 h2*s1

 h2*r0

 mask value

 last reduction step

 Layout of opaque area is following.



	unsigned __int64 h[3];		
	unsigned __int64 r[2];		
$code.=<<___;

.text

___

<<___ if (!$kernel);

$code.=<<___;

	xor	%eax,%eax

	mov	%rax,0($ctx)		# initialize hash value

	mov	%rax,8($ctx)

	mov	%rax,16($ctx)



	test	$inp,$inp

	je	.Lno_key

___

<<___ if (!$kernel);

$code.=<<___	if (!$kernel && $avx);

	mov	OPENSSL_ia32cap_P+4(%rip),%r9

	lea	poly1305_blocks_avx(%rip),%rax

	lea	poly1305_emit_avx(%rip),%rcx

	bt	\$`60-32`,%r9		# AVX?

	cmovc	%rax,%r10

	cmovc	%rcx,%r11

___

<<___	if (!$kernel && $avx>1);

 AVX2?

$code.=<<___	if (!$kernel && $avx>3);

	mov	\$`(1<<31|1<<21|1<<16)`,%rax

	shr	\$32,%r9

	and	%rax,%r9

	cmp	%rax,%r9

	je	.Linit_base2_44

___

<<___;

$code.=<<___	if (!$kernel && $flavour !~ /elf32/);

	mov	%r10,0(%rdx)

	mov	%r11,8(%rdx)

___

$code.=<<___	if (!$kernel && $flavour =~ /elf32/);

	mov	%r10d,0(%rdx)

	mov	%r11d,4(%rdx)

___

<<___;

$code.=<<___;

.cfi_startproc

.Lblocks:

	shr	\$4,$len

	jz	.Lno_data		# too short



	push	%rbx

.cfi_push	%rbx

	push	%r12

.cfi_push	%r12

	push	%r13

.cfi_push	%r13

	push	%r14

.cfi_push	%r14

	push	%r15

.cfi_push	%r15

	push	$ctx

.cfi_push	$ctx

.Lblocks_body:



	mov	$len,%r15		# reassign $len



	mov	24($ctx),$r0		# load r

	mov	32($ctx),$s1



	mov	0($ctx),$h0		# load hash value

	mov	8($ctx),$h1

	mov	16($ctx),$h2



	mov	$s1,$r1

	shr	\$2,$s1

	mov	$r1,%rax

 s1 = r1 + (r1 >> 2)

 accumulate input

$code.=<<___;

	mov	$r1,%rax

 len-=16

 store hash value

$code.=<<___;

.Lemit:

	mov	0($ctx),%r8	# load hash value

	mov	8($ctx),%r9

	mov	16($ctx),%r10



	mov	%r8,%rax

	add	\$5,%r8		# compare to modulus

	mov	%r9,%rcx

	adc	\$0,%r9

	adc	\$0,%r10

	shr	\$2,%r10	# did 130-bit value overflow?

	cmovnz	%r8,%rax

	cmovnz	%r9,%rcx



	add	0($nonce),%rax	# accumulate nonce

	adc	8($nonce),%rcx

	mov	%rax,0($mac)	# write result

	mov	%rcx,8($mac)



	ret

___

&end_function("poly1305_emit_x86_64");

if ($avx) {



########################################################################

# Layout of opaque area is following.

#

#	unsigned __int32 h[5];		# current hash value base 2^26

#	unsigned __int32 is_base2_26;

#	unsigned __int64 r[2];		# key value base 2^64

#	unsigned __int64 pad;

#	struct { unsigned __int32 r^2, r^1, r^4, r^3; } r[9];

#

# where r^n are base 2^26 digits of degrees of multiplier key. There are

# 5 digits, but last four are interleaved with multiples of 5, totalling

# in 9 elements: r0, r1, 5*r1, r2, 5*r2, r3, 5*r3, r4, 5*r4.





$code.=<<___;

.type	__poly1305_block,\@abi-omnipotent

.align	32

__poly1305_block:

	push $ctx

___

	&poly1305_iteration();

<<___;

 size optimization

 r^2

 save interleaved r^2 and r base 2^26

d,%eax

d,%edx

d,%eax

d,%edx

 *5

 *5

 *5

 *5

d,%eax

d,%edx

 *5

 *5

d,`16*7+0-64`($ctx)

 *5

d,`16*7+4-64`($ctx)

 *5

d,`16*8+0-64`($ctx)

d,`16*8+4-64`($ctx)

 r^3

 save r^3 base 2^26

d,%eax

d,%edx

 *5

 *5

d,%edx

 *5

d,`16*7+12-64`($ctx)

 *5

d,`16*8+12-64`($ctx)

 r^4

 save r^4 base 2^26

d,%eax

d,%edx

 *5

 *5

d,%edx

 *5

d,`16*7+8-64`($ctx)

 *5

d,`16*8+8-64`($ctx)

 size [de-]optimization

$code.=<<___;

.cfi_startproc

	mov	20($ctx),%r8d		# is_base2_26

	cmp	\$128,$len

	jae	.Lblocks_avx

	test	%r8d,%r8d

	jz	.Lblocks



.Lblocks_avx:

	and	\$-16,$len

	jz	.Lno_data_avx



	vzeroupper



	test	%r8d,%r8d

	jz	.Lbase2_64_avx



	test	\$31,$len

	jz	.Leven_avx



	push	%rbp

.cfi_push	%rbp

	mov 	%rsp,%rbp

	push	%rbx

.cfi_push	%rbx

	push	%r12

.cfi_push	%r12

	push	%r13

.cfi_push	%r13

	push	%r14

.cfi_push	%r14

	push	%r15

.cfi_push	%r15

.Lblocks_avx_body:



	mov	$len,%r15		# reassign $len



	mov	0($ctx),$d1		# load hash value

	mov	8($ctx),$d2

	mov	16($ctx),$h2#d



	mov	24($ctx),$r0		# load r

	mov	32($ctx),$s1



	################################# base 2^26 -> base 2^64

	mov	$d1#d,$h0#d

	and	\$`-1*(1<<31)`,$d1

	mov	$d2,$r1			# borrow $r1

	mov	$d2#d,$h1#d

	and	\$`-1*(1<<31)`,$d2



	shr	\$6,$d1

	shl	\$52,$r1

	add	$d1,$h0

	shr	\$12,$h1

	shr	\$18,$d2

	add	$r1,$h0

	adc	$d2,$h1



	mov	$h2,$d1

	shl	\$40,$d1

	shr	\$24,$h2

	add	$d1,$h1

	adc	\$0,$h2			# can be partially reduced...



	mov	\$-4,$d2		# ... so reduce

	mov	$h2,$d1

	and	$h2,$d2

	shr	\$2,$d1

	and	\$3,$h2

 =*5

	add	$r1,$s1			# s1 = r1 + (r1 >> 2)



	add	0($inp),$h0		# accumulate input

	adc	8($inp),$h1

	lea	16($inp),$inp

	adc	$padbit,$h2



	call	__poly1305_block



	test	$padbit,$padbit		# if $padbit is zero,

	jz	.Lstore_base2_64_avx	# store hash in base 2^64 format



	################################# base 2^64 -> base 2^26

	mov	$h0,%rax

	mov	$h0,%rdx

	shr	\$52,$h0

	mov	$h1,$r0

	mov	$h1,$r1

	shr	\$26,%rdx

	and	\$0x3ffffff,%rax	# h[0]

	shl	\$12,$r0

	and	\$0x3ffffff,%rdx	# h[1]

	shr	\$14,$h1

	or	$r0,$h0

	shl	\$24,$h2

	and	\$0x3ffffff,$h0		# h[2]

	shr	\$40,$r1

	and	\$0x3ffffff,$h1		# h[3]

	or	$r1,$h2			# h[4]



	sub	\$16,%r15

	jz	.Lstore_base2_26_avx



	vmovd	%rax#d,$H0

	vmovd	%rdx#d,$H1

	vmovd	$h0#d,$H2

	vmovd	$h1#d,$H3

	vmovd	$h2#d,$H4

	jmp	.Lproceed_avx



.align	32

.Lstore_base2_64_avx:

	mov	$h0,0($ctx)

	mov	$h1,8($ctx)

	mov	$h2,16($ctx)		# note that is_base2_26 is zeroed

	jmp	.Ldone_avx



.align	16

.Lstore_base2_26_avx:

	mov	%rax#d,0($ctx)		# store hash value base 2^26

	mov	%rdx#d,4($ctx)

	mov	$h0#d,8($ctx)

	mov	$h1#d,12($ctx)

	mov	$h2#d,16($ctx)

.align	16

.Ldone_avx:

	pop 		%r15

.cfi_restore	%r15

	pop 		%r14

.cfi_restore	%r14

	pop 		%r13

.cfi_restore	%r13

	pop 		%r12

.cfi_restore	%r12

	pop 		%rbx

.cfi_restore	%rbx

	pop 		%rbp

.cfi_restore	%rbp

.Lno_data_avx:

.Lblocks_avx_epilogue:

	ret

.cfi_endproc



.align	32

.Lbase2_64_avx:

.cfi_startproc

	push	%rbp

.cfi_push	%rbp

	mov 	%rsp,%rbp

	push	%rbx

.cfi_push	%rbx

	push	%r12

.cfi_push	%r12

	push	%r13

.cfi_push	%r13

	push	%r14

.cfi_push	%r14

	push	%r15

.cfi_push	%r15

.Lbase2_64_avx_body:



	mov	$len,%r15		# reassign $len



	mov	24($ctx),$r0		# load r

	mov	32($ctx),$s1



	mov	0($ctx),$h0		# load hash value

	mov	8($ctx),$h1

	mov	16($ctx),$h2#d



	mov	$s1,$r1

	mov	$s1,%rax

	shr	\$2,$s1

 s1 = r1 + (r1 >> 2)

 accumulate input

 base 2^64 -> base 2^26

 h[0]

 h[1]

 h[2]

 h[3]

 h[4]

d,$H0

d,$H1

d,$H2

d,$H3

d,$H4

 set is_base2_26

 load hash value

$code.=<<___	if (!$win64);

	lea		8(%rsp),%r10

.cfi_def_cfa_register	%r10

	and		\$-32,%rsp

	sub		\$-8,%rsp

	lea		-0x58(%rsp),%r11

	sub		\$0x178,%rsp

___

<<___	if ($win64);

$code.=<<___;

	sub		\$64,$len

	lea		-32($inp),%rax

	cmovc		%rax,$inp



	vmovdqu		`16*3`($ctx),$D4	# preload r0^2

	lea		`16*3+64`($ctx),$ctx	# size optimization

	lea		.Lconst(%rip),%rcx



	################################################################

	# load input

	vmovdqu		16*2($inp),$T0

	vmovdqu		16*3($inp),$T1

	vmovdqa		64(%rcx),$MASK		# .Lmask26



	vpsrldq		\$6,$T0,$T2		# splat input

	vpsrldq		\$6,$T1,$T3

	vpunpckhqdq	$T1,$T0,$T4		# 4

	vpunpcklqdq	$T1,$T0,$T0		# 0:1

	vpunpcklqdq	$T3,$T2,$T3		# 2:3



	vpsrlq		\$40,$T4,$T4		# 4

	vpsrlq		\$26,$T0,$T1

	vpand		$MASK,$T0,$T0		# 0

	vpsrlq		\$4,$T3,$T2

	vpand		$MASK,$T1,$T1		# 1

	vpsrlq		\$30,$T3,$T3

	vpand		$MASK,$T2,$T2		# 2

	vpand		$MASK,$T3,$T3		# 3

	vpor		32(%rcx),$T4,$T4	# padbit, yes, always



	jbe		.Lskip_loop_avx



	# expand and copy pre-calculated table to stack

	vmovdqu		`16*1-64`($ctx),$D1

	vmovdqu		`16*2-64`($ctx),$D2

	vpshufd		\$0xEE,$D4,$D3		# 34xx -> 3434

	vpshufd		\$0x44,$D4,$D0		# xx12 -> 1212

	vmovdqa		$D3,-0x90(%r11)

	vmovdqa		$D0,0x00(%rsp)

	vpshufd		\$0xEE,$D1,$D4

	vmovdqu		`16*3-64`($ctx),$D0

	vpshufd		\$0x44,$D1,$D1

	vmovdqa		$D4,-0x80(%r11)

	vmovdqa		$D1,0x10(%rsp)

	vpshufd		\$0xEE,$D2,$D3

	vmovdqu		`16*4-64`($ctx),$D1

	vpshufd		\$0x44,$D2,$D2

	vmovdqa		$D3,-0x70(%r11)

	vmovdqa		$D2,0x20(%rsp)

	vpshufd		\$0xEE,$D0,$D4

	vmovdqu		`16*5-64`($ctx),$D2

	vpshufd		\$0x44,$D0,$D0

	vmovdqa		$D4,-0x60(%r11)

	vmovdqa		$D0,0x30(%rsp)

	vpshufd		\$0xEE,$D1,$D3

	vmovdqu		`16*6-64`($ctx),$D0

	vpshufd		\$0x44,$D1,$D1

	vmovdqa		$D3,-0x50(%r11)

	vmovdqa		$D1,0x40(%rsp)

	vpshufd		\$0xEE,$D2,$D4

	vmovdqu		`16*7-64`($ctx),$D1

	vpshufd		\$0x44,$D2,$D2

	vmovdqa		$D4,-0x40(%r11)

	vmovdqa		$D2,0x50(%rsp)

	vpshufd		\$0xEE,$D0,$D3

	vmovdqu		`16*8-64`($ctx),$D2

	vpshufd		\$0x44,$D0,$D0

	vmovdqa		$D3,-0x30(%r11)

	vmovdqa		$D0,0x60(%rsp)

	vpshufd		\$0xEE,$D1,$D4

	vpshufd		\$0x44,$D1,$D1

	vmovdqa		$D4,-0x20(%r11)

	vmovdqa		$D1,0x70(%rsp)

	vpshufd		\$0xEE,$D2,$D3

	 vmovdqa	0x00(%rsp),$D4		# preload r0^2

	vpshufd		\$0x44,$D2,$D2

	vmovdqa		$D3,-0x10(%r11)

	vmovdqa		$D2,0x80(%rsp)



	jmp		.Loop_avx



.align	32

.Loop_avx:

	################################################################

	# ((inp[0]*r^4+inp[2]*r^2+inp[4])*r^4+inp[6]*r^2

	# ((inp[1]*r^4+inp[3]*r^2+inp[5])*r^3+inp[7]*r

	#   \___________________/

	# ((inp[0]*r^4+inp[2]*r^2+inp[4])*r^4+inp[6]*r^2+inp[8])*r^2

	# ((inp[1]*r^4+inp[3]*r^2+inp[5])*r^4+inp[7]*r^2+inp[9])*r

	#   \___________________/ \____________________/

	#

	# Note that we start with inp[2:3]*r^2. This is because it

	# doesn't depend on reduction in previous iteration.

	################################################################

 d4 = h4*r0 + h3*r1   + h2*r2   + h1*r3   + h0*r4

	# d3 = h3*r0 + h2*r1   + h1*r2   + h0*r3   + h4*5*r4

 d2 = h2*r0 + h1*r1   + h0*r2   + h4*5*r3 + h3*5*r4

	# d1 = h1*r0 + h0*r1   + h4*5*r2 + h3*5*r3 + h2*5*r4

 d0 = h0*r0 + h4*5*r1 + h3*5*r2 + h2*5*r3 + h1*5*r4



 though note that $Tx and $Hx are "reversed" in this section,

 and $D4 is preloaded with r0^2...

	vpmuludq	$T0,$D4,$D0		# d0 = h0*r0

 d1 = h1*r0

 offload hash

	vpmuludq	$T2,$D4,$D2		# d3 = h2*r0

	 vmovdqa	0x10(%rsp),$H2		# r1^2

 d3 = h3*r0

	vpmuludq	$T4,$D4,$D4		# d4 = h4*r0



	  vmovdqa	$H0,0x00(%r11)				#

	vpmuludq	0x20(%rsp),$T4,$H0	# h4*s1

	  vmovdqa	$H1,0x10(%r11)				#

	vpmuludq	$T3,$H2,$H1		# h3*r1

 d0 += h4*s1

	vpaddq		$H1,$D4,$D4		# d4 += h3*r1

	  vmovdqa	$H3,0x30(%r11)				#

	vpmuludq	$T2,$H2,$H0		# h2*r1

	vpmuludq	$T1,$H2,$H1		# h1*r1

 d3 += h2*r1

 r2^2

	vpaddq		$H1,$D2,$D2		# d2 += h1*r1

	  vmovdqa	$H4,0x40(%r11)				#

	vpmuludq	$T0,$H2,$H2		# h0*r1

	 vpmuludq	$T2,$H3,$H0		# h2*r2

 d1 += h0*r1

 s2^2

	vpaddq		$H0,$D4,$D4		# d4 += h2*r2

	vpmuludq	$T1,$H3,$H1		# h1*r2

	vpmuludq	$T0,$H3,$H3		# h0*r2

 d3 += h1*r2

 r3^2

	vpaddq		$H3,$D2,$D2		# d2 += h0*r2

	vpmuludq	$T4,$H4,$H0		# h4*s2

	vpmuludq	$T3,$H4,$H4		# h3*s2

 d1 += h4*s2

 s3^2

	vpaddq		$H4,$D0,$D0		# d0 += h3*s2



	 vmovdqa	0x80(%rsp),$H4		# s4^2

	vpmuludq	$T1,$H2,$H1		# h1*r3

	vpmuludq	$T0,$H2,$H2		# h0*r3

 d4 += h1*r3

	vpaddq		$H2,$D3,$D3		# d3 += h0*r3

	vpmuludq	$T4,$H3,$H0		# h4*s3

	vpmuludq	$T3,$H3,$H1		# h3*s3

 d2 += h4*s3

 load input

	vpaddq		$H1,$D1,$D1		# d1 += h3*s3

	vpmuludq	$T2,$H3,$H3		# h2*s3

	 vpmuludq	$T2,$H4,$T2		# h2*s4

 d0 += h2*s3



	vpaddq		$T2,$D1,$D1		# d1 += h2*s4

	vpmuludq	$T3,$H4,$T3		# h3*s4

	vpmuludq	$T4,$H4,$T4		# h4*s4

	 vpsrldq	\$6,$H0,$H2				# splat input

 d2 += h3*s4

	vpaddq		$T4,$D3,$D3		# d3 += h4*s4

	 vpsrldq	\$6,$H1,$H3				#

	vpmuludq	0x70(%rsp),$T0,$T4	# h0*r4

	vpmuludq	$T1,$H4,$T0		# h1*s4

	 vpunpckhqdq	$H1,$H0,$H4		# 4

 d4 += h0*r4

 r0^4

	vpaddq		$T0,$D0,$D0		# d0 += h1*s4



	vpunpcklqdq	$H1,$H0,$H0		# 0:1

	vpunpcklqdq	$H3,$H2,$H3		# 2:3



	#vpsrlq		\$40,$H4,$H4		# 4

	vpsrldq		\$`40/8`,$H4,$H4	# 4

	vpsrlq		\$26,$H0,$H1

	vpand		$MASK,$H0,$H0		# 0

	vpsrlq		\$4,$H3,$H2

	vpand		$MASK,$H1,$H1		# 1

	vpand		0(%rcx),$H4,$H4		# .Lmask24

	vpsrlq		\$30,$H3,$H3

	vpand		$MASK,$H2,$H2		# 2

	vpand		$MASK,$H3,$H3		# 3

	vpor		32(%rcx),$H4,$H4	# padbit, yes, always



	vpaddq		0x00(%r11),$H0,$H0	# add hash value

	vpaddq		0x10(%r11),$H1,$H1

	vpaddq		0x20(%r11),$H2,$H2

	vpaddq		0x30(%r11),$H3,$H3

	vpaddq		0x40(%r11),$H4,$H4



	lea		16*2($inp),%rax

	lea		16*4($inp),$inp

	sub		\$64,$len

	cmovc		%rax,$inp



	################################################################

	# Now we accumulate (inp[0:1]+hash)*r^4

	################################################################

 d4 = h4*r0 + h3*r1   + h2*r2   + h1*r3   + h0*r4

	# d3 = h3*r0 + h2*r1   + h1*r2   + h0*r3   + h4*5*r4

 d2 = h2*r0 + h1*r1   + h0*r2   + h4*5*r3 + h3*5*r4

	# d1 = h1*r0 + h0*r1   + h4*5*r2 + h3*5*r3 + h2*5*r4

 d0 = h0*r0 + h4*5*r1 + h3*5*r2 + h2*5*r3 + h1*5*r4

 h0*r0

 h1*r0

 r1^4

 h2*r0

 h3*r0

 h4*r0

 h4*s1

	vpaddq		$T0,$D0,$D0		# d0 += h4*s1

	vpmuludq	$H2,$T2,$T1		# h2*r1

	vpmuludq	$H3,$T2,$T0		# h3*r1

 d3 += h2*r1

 r2^4

	vpaddq		$T0,$D4,$D4		# d4 += h3*r1

	vpmuludq	$H1,$T2,$T1		# h1*r1

	vpmuludq	$H0,$T2,$T2		# h0*r1

 d2 += h1*r1

	vpaddq		$T2,$D1,$D1		# d1 += h0*r1



	 vmovdqa	-0x50(%r11),$T4		# s2^4

	vpmuludq	$H2,$T3,$T0		# h2*r2

	vpmuludq	$H1,$T3,$T1		# h1*r2

 d4 += h2*r2

	vpaddq		$T1,$D3,$D3		# d3 += h1*r2

	 vmovdqa	-0x40(%r11),$T2		# r3^4

	vpmuludq	$H0,$T3,$T3		# h0*r2

	vpmuludq	$H4,$T4,$T0		# h4*s2

 d2 += h0*r2

	vpaddq		$T0,$D1,$D1		# d1 += h4*s2

	 vmovdqa	-0x30(%r11),$T3		# s3^4

	vpmuludq	$H3,$T4,$T4		# h3*s2

	 vpmuludq	$H1,$T2,$T1		# h1*r3

 d0 += h3*s2

 s4^4

	vpaddq		$T1,$D4,$D4		# d4 += h1*r3

	vpmuludq	$H0,$T2,$T2		# h0*r3

	vpmuludq	$H4,$T3,$T0		# h4*s3

 d3 += h0*r3

	vpaddq		$T0,$D2,$D2		# d2 += h4*s3

	 vmovdqu	16*2($inp),$T0				# load input

	vpmuludq	$H3,$T3,$T2		# h3*s3

	vpmuludq	$H2,$T3,$T3		# h2*s3

 d1 += h3*s3



	vpaddq		$T3,$D0,$D0		# d0 += h2*s3



	vpmuludq	$H2,$T4,$H2		# h2*s4

	vpmuludq	$H3,$T4,$H3		# h3*s4

	 vpsrldq	\$6,$T0,$T2				# splat input

 d1 += h2*s4

 h4*s4



	vpaddq		$H3,$D2,$H2		# h2 = d2 + h3*s4

 h3 = d3 + h4*s4

 h0*r4

 4

	vpaddq		$H4,$D4,$H4		# h4 = d4 + h0*r4

 h0 = d0 + h1*s4

 0:1

 2:3

vpsrlq		\$40,$T4,$T4		
 4

 preload r0^2

 0

 1

 .Lmask24

 2

 3

 padbit, yes, always

 lazy reduction as discussed in "NEON crypto" by D.J. Bernstein

 and P. Schwabe

 h3 -> h4

 h0 -> h1

 h1 -> h2

 h4 -> h0

 h2 -> h3

 h0 -> h1

 h3 -> h4

 multiply (inp[0:1]+hash) or inp[2:3] by r^2:r^1

 r0^n, xx12 -> x1x2

	# d4 = h4*r0 + h3*r1   + h2*r2   + h1*r3   + h0*r4

 d3 = h3*r0 + h2*r1   + h1*r2   + h0*r3   + h4*5*r4

	# d2 = h2*r0 + h1*r1   + h0*r2   + h4*5*r3 + h3*5*r4

 d1 = h1*r0 + h0*r1   + h4*5*r2 + h3*5*r3 + h2*5*r4

	# d0 = h0*r0 + h4*5*r1 + h3*5*r2 + h2*5*r3 + h1*5*r4



 d2 = h2*r0

	vpmuludq	$T0,$D4,$D0		# d0 = h0*r0

	 vpshufd	\$0x10,`16*1-64`($ctx),$H2		# r1^n

 d1 = h1*r0

	vpmuludq	$T3,$D4,$D3		# d3 = h3*r0

 d4 = h4*r0

 h3*r1

	vpaddq		$H0,$D4,$D4		# d4 += h3*r1

	 vpshufd	\$0x10,`16*2-64`($ctx),$H3		# s1^n

	vpmuludq	$T2,$H2,$H1		# h2*r1

 d3 += h2*r1

 r2^n

 h1*r1

	vpaddq		$H0,$D2,$D2		# d2 += h1*r1

	vpmuludq	$T0,$H2,$H2		# h0*r1

 d1 += h0*r1

 h4*s1

	vpaddq		$H3,$D0,$D0		# d0 += h4*s1



	 vpshufd	\$0x10,`16*4-64`($ctx),$H2		# s2^n

	vpmuludq	$T2,$H4,$H1		# h2*r2

 d4 += h2*r2

 h1*r2

	vpaddq		$H0,$D3,$D3		# d3 += h1*r2

	 vpshufd	\$0x10,`16*5-64`($ctx),$H3		# r3^n

	vpmuludq	$T0,$H4,$H4		# h0*r2

 d2 += h0*r2

 h4*s2

	vpaddq		$H1,$D1,$D1		# d1 += h4*s2

	 vpshufd	\$0x10,`16*6-64`($ctx),$H4		# s3^n

	vpmuludq	$T3,$H2,$H2		# h3*s2

 d0 += h3*s2

 h1*r3

	vpaddq		$H0,$D4,$D4		# d4 += h1*r3

	vpmuludq	$T0,$H3,$H3		# h0*r3

 d3 += h0*r3

 r4^n

 h4*s3

	vpaddq		$H1,$D2,$D2		# d2 += h4*s3

	 vpshufd	\$0x10,`16*8-64`($ctx),$H3		# s4^n

	vpmuludq	$T3,$H4,$H0		# h3*s3

 d1 += h3*s3

 h2*s3

	vpaddq		$H4,$D0,$D0		# d0 += h2*s3



	vpmuludq	$T0,$H2,$H2		# h0*r4

 h4 = d4 + h0*r4

 h4*s4

	vpaddq		$H1,$D3,$D3		# h3 = d3 + h4*s4

	vpmuludq	$T3,$H3,$H0		# h3*s4

 h2 = d2 + h3*s4

 h2*s4

	vpaddq		$H1,$D1,$D1		# h1 = d1 + h2*s4

	vpmuludq	$T1,$H3,$H3		# h1*s4

 h0 = d0 + h1*s4

 load input

 splat input

 4

 0:1

 2:3

 4

 0

 1

 2

 3

 padbit, yes, always

 r0^n, 34xx -> x3x4

 multiply (inp[0:1]+hash) by r^4:r^3 and accumulate

 h0*r0

	vpaddq		$T0,$D0,$D0		# d0 += h0*r0

	vpmuludq	$H1,$T4,$T1		# h1*r0

 d1 += h1*r0

 h2*r0

	vpaddq		$T0,$D2,$D2		# d2 += h2*r0

	 vpshufd	\$0x32,`16*1-64`($ctx),$T2		# r1^n

	vpmuludq	$H3,$T4,$T1		# h3*r0

 d3 += h3*r0

 h4*r0

	vpaddq		$T4,$D4,$D4		# d4 += h4*r0



	vpmuludq	$H3,$T2,$T0		# h3*r1

 d4 += h3*r1

 s1

 h2*r1

	vpaddq		$T1,$D3,$D3		# d3 += h2*r1

	 vpshufd	\$0x32,`16*3-64`($ctx),$T4		# r2

	vpmuludq	$H1,$T2,$T0		# h1*r1

 d2 += h1*r1

 h0*r1

	vpaddq		$T2,$D1,$D1		# d1 += h0*r1

	vpmuludq	$H4,$T3,$T3		# h4*s1

 d0 += h4*s1

 s2

 h2*r2

	vpaddq		$T1,$D4,$D4		# d4 += h2*r2

	vpmuludq	$H1,$T4,$T0		# h1*r2

 d3 += h1*r2

 r3

 h0*r2

	vpaddq		$T4,$D2,$D2		# d2 += h0*r2

	vpmuludq	$H4,$T2,$T1		# h4*s2

 d1 += h4*s2

 s3

 h3*s2

	vpaddq		$T2,$D0,$D0		# d0 += h3*s2



	vpmuludq	$H1,$T3,$T0		# h1*r3

 d4 += h1*r3

 h0*r3

	vpaddq		$T3,$D3,$D3		# d3 += h0*r3

	 vpshufd	\$0x32,`16*7-64`($ctx),$T2		# r4

	vpmuludq	$H4,$T4,$T1		# h4*s3

 d2 += h4*s3

 s4

 h3*s3

	vpaddq		$T0,$D1,$D1		# d1 += h3*s3

	vpmuludq	$H2,$T4,$T4		# h2*s3

 d0 += h2*s3

 h0*r4

	vpaddq		$T2,$D4,$D4		# d4 += h0*r4

	vpmuludq	$H4,$T3,$T1		# h4*s4

 d3 += h4*s4

 h3*s4

	vpaddq		$T0,$D2,$D2		# d2 += h3*s4

	vpmuludq	$H2,$T3,$T1		# h2*s4

 d1 += h2*s4

 h1*s4

	vpaddq		$T3,$D0,$D0		# d0 += h1*s4



.Lshort_tail_avx:

	################################################################

	# horizontal addition



	vpsrldq		\$8,$D4,$T4

	vpsrldq		\$8,$D3,$T3

	vpsrldq		\$8,$D1,$T1

	vpsrldq		\$8,$D0,$T0

	vpsrldq		\$8,$D2,$T2

	vpaddq		$T3,$D3,$D3

	vpaddq		$T4,$D4,$D4

	vpaddq		$T0,$D0,$D0

	vpaddq		$T1,$D1,$D1

	vpaddq		$T2,$D2,$D2



	################################################################

	# lazy reduction



	vpsrlq		\$26,$D3,$H3

	vpand		$MASK,$D3,$D3

	vpaddq		$H3,$D4,$D4		# h3 -> h4



	vpsrlq		\$26,$D0,$H0

	vpand		$MASK,$D0,$D0

	vpaddq		$H0,$D1,$D1		# h0 -> h1



	vpsrlq		\$26,$D4,$H4

	vpand		$MASK,$D4,$D4



	vpsrlq		\$26,$D1,$H1

	vpand		$MASK,$D1,$D1

	vpaddq		$H1,$D2,$D2		# h1 -> h2



	vpaddq		$H4,$D0,$D0

	vpsllq		\$2,$H4,$H4

	vpaddq		$H4,$D0,$D0		# h4 -> h0



	vpsrlq		\$26,$D2,$H2

	vpand		$MASK,$D2,$D2

	vpaddq		$H2,$D3,$D3		# h2 -> h3



	vpsrlq		\$26,$D0,$H0

	vpand		$MASK,$D0,$D0

	vpaddq		$H0,$D1,$D1		# h0 -> h1



	vpsrlq		\$26,$D3,$H3

	vpand		$MASK,$D3,$D3

	vpaddq		$H3,$D4,$D4		# h3 -> h4



	vmovd		$D0,`4*0-48-64`($ctx)	# save partially reduced

	vmovd		$D1,`4*1-48-64`($ctx)

	vmovd		$D2,`4*2-48-64`($ctx)

	vmovd		$D3,`4*3-48-64`($ctx)

	vmovd		$D4,`4*4-48-64`($ctx)

___

<<___	if ($win64);

$code.=<<___	if (!$win64);

	lea		-8(%r10),%rsp

.cfi_def_cfa_register	%rsp

___

<<___;

$code.=<<___;

	cmpl	\$0,20($ctx)	# is_base2_26?

	je	.Lemit



	mov	0($ctx),%eax	# load hash value base 2^26

	mov	4($ctx),%ecx

	mov	8($ctx),%r8d

	mov	12($ctx),%r11d

	mov	16($ctx),%r10d



	shl	\$26,%rcx	# base 2^26 -> base 2^64

	mov	%r8,%r9

	shl	\$52,%r8

	add	%rcx,%rax

	shr	\$12,%r9

	add	%rax,%r8	# h0

	adc	\$0,%r9



	shl	\$14,%r11

	mov	%r10,%rax

	shr	\$24,%r10

	add	%r11,%r9

	shl	\$40,%rax

	add	%rax,%r9	# h1

	adc	\$0,%r10	# h2



	mov	%r10,%rax	# could be partially reduced, so reduce

	mov	%r10,%rcx

	and	\$3,%r10

	shr	\$2,%rax

	and	\$-4,%rcx

	add	%rcx,%rax

	add	%rax,%r8

	adc	\$0,%r9

	adc	\$0,%r10



	mov	%r8,%rax

	add	\$5,%r8		# compare to modulus

	mov	%r9,%rcx

	adc	\$0,%r9

	adc	\$0,%r10

	shr	\$2,%r10	# did 130-bit value overflow?

	cmovnz	%r8,%rax

	cmovnz	%r9,%rcx



	add	0($nonce),%rax	# accumulate nonce

	adc	8($nonce),%rcx

	mov	%rax,0($mac)	# write result

	mov	%rcx,8($mac)



	ret

___

&end_function("poly1305_emit_avx");



if ($avx>1) {





my $S4=$MASK;



sub poly1305_blocks_avxN {

 @_;

	my $suffix = $avx512 ? "_avx512" : "";

<<___;

 is_base2_26

 reassign $len

 load hash value

d

 load r

 base 2^26 -> base 2^64

d,$h0
 borrow $r1

d,$h1
 can be partially reduced...

 ... so reduce

	add	$d2,$d1			# =*5

	add	$d1,$h0

	adc	\$0,$h1

	adc	\$0,$h2



	mov	$s1,$r1

	mov	$s1,%rax

	shr	\$2,$s1

 s1 = r1 + (r1 >> 2)

 accumulate input

 if $padbit is zero,

 store hash in base 2^64 format

 base 2^64 -> base 2^26

 h[0]

 h[1]

 h[2]

 h[3]

 h[4]

d,%x
d,%x
d,%x
d,%x
d,%x
 note that is_base2_26 is zeroed

d,0($ctx)		
d,4($ctx)

d,8($ctx)

d,12($ctx)

d,16($ctx)

 reassign $len

 load r

 load hash value

d

	add	$r1,$s1			# s1 = r1 + (r1 >> 2)



	test	\$63,$len

	jz	.Linit_avx2$suffix



.Lbase2_64_pre_avx2$suffix:

	add	0($inp),$h0		# accumulate input

	adc	8($inp),$h1

	lea	16($inp),$inp

	adc	$padbit,$h2

	sub	\$16,%r15



	call	__poly1305_block

	mov	$r1,%rax



	test	\$63,%r15

	jnz	.Lbase2_64_pre_avx2$suffix



.Linit_avx2$suffix:

	################################# base 2^64 -> base 2^26

	mov	$h0,%rax

	mov	$h0,%rdx

	shr	\$52,$h0

	mov	$h1,$d1

	mov	$h1,$d2

	shr	\$26,%rdx

	and	\$0x3ffffff,%rax	# h[0]

	shl	\$12,$d1

	and	\$0x3ffffff,%rdx	# h[1]

	shr	\$14,$h1

	or	$d1,$h0

	shl	\$24,$h2

	and	\$0x3ffffff,$h0		# h[2]

	shr	\$40,$d2

	and	\$0x3ffffff,$h1		# h[3]

	or	$d2,$h2			# h[4]



	vmovd	%rax#d,%x#$H0

	vmovd	%rdx#d,%x#$H1

	vmovd	$h0#d,%x#$H2

	vmovd	$h1#d,%x#$H3

	vmovd	$h2#d,%x#$H4

	movl	\$1,20($ctx)		# set is_base2_26



	call	__poly1305_init_avx



.Lproceed_avx2$suffix:

	mov	%r15,$len			# restore $len

___

<<___ if (!$kernel);

$code.=<<___;

	pop 		%r15

.cfi_restore	%r15

	pop 		%r14

.cfi_restore	%r14

	pop 		%r13

.cfi_restore	%r13

	pop 		%r12

.cfi_restore	%r12

	pop 		%rbx

.cfi_restore	%rbx

	pop 		%rbp

.cfi_restore 	%rbp

.Lbase2_64_avx2_epilogue$suffix:

	jmp	.Ldo_avx2$suffix

.cfi_endproc



.align	32

.Leven_avx2$suffix:

.cfi_startproc

___

<<___ if (!$kernel);

$code.=<<___;

	vmovd		4*0($ctx),%x#$H0	# load hash value base 2^26

	vmovd		4*1($ctx),%x#$H1

	vmovd		4*2($ctx),%x#$H2

	vmovd		4*3($ctx),%x#$H3

	vmovd		4*4($ctx),%x#$H4



.Ldo_avx2$suffix:

___

<<___		if (!$kernel && $avx>2);

 check for AVX512F

$code.=<<___ if ($avx > 2 && $avx512 && $kernel);

	cmp		\$512,$len

	jae		.Lblocks_avx512

___

<<___	if (!$win64);

$code.=<<___	if ($win64);

	lea		8(%rsp),%r10

	sub		\$0x1c8,%rsp

	vmovdqa		%xmm6,-0xb0(%r10)

	vmovdqa		%xmm7,-0xa0(%r10)

	vmovdqa		%xmm8,-0x90(%r10)

	vmovdqa		%xmm9,-0x80(%r10)

	vmovdqa		%xmm10,-0x70(%r10)

	vmovdqa		%xmm11,-0x60(%r10)

	vmovdqa		%xmm12,-0x50(%r10)

	vmovdqa		%xmm13,-0x40(%r10)

	vmovdqa		%xmm14,-0x30(%r10)

	vmovdqa		%xmm15,-0x20(%r10)

.Ldo_avx2_body$suffix:

___

<<___;

 size optimization

 .Lpermd_avx2

 expand and copy pre-calculated table to stack

$T2

$T3

$T4

$D0

$D1

$D2

 size optimization

$D3

 00003412 -> 14243444

$D4

$MASK

 .Lmask26

 load input

$T0

$T1

 splat input

 4

 2:3

 0:1

 4

 2

 0

 1

 3

 padbit, yes, always

 accumulate input

 ((inp[0]*r^4+inp[4])*r^4+inp[ 8])*r^4

 ((inp[1]*r^4+inp[5])*r^4+inp[ 9])*r^3

 ((inp[2]*r^4+inp[6])*r^4+inp[10])*r^2

 ((inp[3]*r^4+inp[7])*r^4+inp[11])*r^1

   \________/\__________/

vpaddq		$H2,$T2,$H2		
 r0^4

 r1^4

 r2^4

 s3^4

 s4^4

	# d4 = h4*r0 + h3*r1   + h2*r2   + h1*r3   + h0*r4

 d3 = h3*r0 + h2*r1   + h1*r2   + h0*r3   + h4*5*r4

	# d2 = h2*r0 + h1*r1   + h0*r2   + h4*5*r3 + h3*5*r4

 d1 = h1*r0 + h0*r1   + h4*5*r2 + h3*5*r3 + h2*5*r4

	# d0 = h0*r0 + h4*5*r1 + h3*5*r2 + h2*5*r3 + h1*5*r4

	#

	# however, as h2 is "chronologically" first one available pull

	# corresponding operations up, so it's

	#

 d4 = h2*r2   + h4*r0 + h3*r1             + h1*r3   + h0*r4

	# d3 = h2*r1   + h3*r0           + h1*r2   + h0*r3   + h4*5*r4

 d2 = h2*r0           + h1*r1   + h0*r2   + h4*5*r3 + h3*5*r4

	# d1 = h2*5*r4 + h1*r0 + h0*r1   + h4*5*r2 + h3*5*r3

 d0 = h2*5*r3 + h0*r0 + h4*5*r1 + h3*5*r2           + h1*5*r4

	vpmuludq	$H2,$T0,$D2		# d2 = h2*r0

 d3 = h2*r1

	vpmuludq	$H2,$T2,$D4		# d4 = h2*r2

 d0 = h2*s3

	vpmuludq	$H2,$S4,$D1		# d1 = h2*s4



	vpmuludq	$H0,$T1,$T4		# h0*r1

	vpmuludq	$H1,$T1,$H2		# h1*r1, borrow $H2 as temp

 d1 += h0*r1

	vpaddq		$H2,$D2,$D2		# d2 += h1*r1

	vpmuludq	$H3,$T1,$T4		# h3*r1

	vpmuludq	`32*2`(%rsp),$H4,$H2	# h4*s1

 d4 += h3*r1

	vpaddq		$H2,$D0,$D0		# d0 += h4*s1

	 vmovdqa	`32*4-0x90`(%rax),$T1	# s2



	vpmuludq	$H0,$T0,$T4		# h0*r0

	vpmuludq	$H1,$T0,$H2		# h1*r0

 d0 += h0*r0

	vpaddq		$H2,$D1,$D1		# d1 += h1*r0

	vpmuludq	$H3,$T0,$T4		# h3*r0

	vpmuludq	$H4,$T0,$H2		# h4*r0

	 vmovdqu	16*0($inp),%x#$T0	# load input

 d3 += h3*r0

	vpaddq		$H2,$D4,$D4		# d4 += h4*r0

	 vinserti128	\$1,16*2($inp),$T0,$T0



	vpmuludq	$H3,$T1,$T4		# h3*s2

	vpmuludq	$H4,$T1,$H2		# h4*s2

	 vmovdqu	16*1($inp),%x#$T1

 d0 += h3*s2

	vpaddq		$H2,$D1,$D1		# d1 += h4*s2

	 vmovdqa	`32*5-0x90`(%rax),$H2	# r3

	vpmuludq	$H1,$T2,$T4		# h1*r2

	vpmuludq	$H0,$T2,$T2		# h0*r2

 d3 += h1*r2

	vpaddq		$T2,$D2,$D2		# d2 += h0*r2

	 vinserti128	\$1,16*3($inp),$T1,$T1

	 lea		16*4($inp),$inp



	vpmuludq	$H1,$H2,$T4		# h1*r3

	vpmuludq	$H0,$H2,$H2		# h0*r3

	 vpsrldq	\$6,$T0,$T2		# splat input

 d4 += h1*r3

	vpaddq		$H2,$D3,$D3		# d3 += h0*r3

	vpmuludq	$H3,$T3,$T4		# h3*s3

	vpmuludq	$H4,$T3,$H2		# h4*s3

	 vpsrldq	\$6,$T1,$T3

 d1 += h3*s3

	vpaddq		$H2,$D2,$D2		# d2 += h4*s3

	 vpunpckhqdq	$T1,$T0,$T4		# 4



	vpmuludq	$H3,$S4,$H3		# h3*s4

	vpmuludq	$H4,$S4,$H4		# h4*s4

	 vpunpcklqdq	$T1,$T0,$T0		# 0:1

 h2 = d2 + h3*r4

	vpaddq		$H4,$D3,$H3		# h3 = d3 + h4*r4

	 vpunpcklqdq	$T3,$T2,$T3		# 2:3

	vpmuludq	`32*7-0x90`(%rax),$H0,$H4	# h0*r4

	vpmuludq	$H1,$S4,$H0		# h1*s4

	vmovdqa		64(%rcx),$MASK		# .Lmask26

 h4 = d4 + h0*r4

	vpaddq		$H0,$D0,$H0		# h0 = d0 + h1*s4



	################################################################

	# lazy reduction (interleaved with tail of input splat)



	vpsrlq		\$26,$H3,$D3

	vpand		$MASK,$H3,$H3

	vpaddq		$D3,$H4,$H4		# h3 -> h4



	vpsrlq		\$26,$H0,$D0

	vpand		$MASK,$H0,$H0

	vpaddq		$D0,$D1,$H1		# h0 -> h1



	vpsrlq		\$26,$H4,$D4

	vpand		$MASK,$H4,$H4



	 vpsrlq		\$4,$T3,$T2



	vpsrlq		\$26,$H1,$D1

	vpand		$MASK,$H1,$H1

	vpaddq		$D1,$H2,$H2		# h1 -> h2



	vpaddq		$D4,$H0,$H0

	vpsllq		\$2,$D4,$D4

	vpaddq		$D4,$H0,$H0		# h4 -> h0



	 vpand		$MASK,$T2,$T2		# 2

	 vpsrlq		\$26,$T0,$T1



	vpsrlq		\$26,$H2,$D2

	vpand		$MASK,$H2,$H2

	vpaddq		$D2,$H3,$H3		# h2 -> h3



	 vpaddq		$T2,$H2,$H2		# modulo-scheduled

	 vpsrlq		\$30,$T3,$T3



	vpsrlq		\$26,$H0,$D0

	vpand		$MASK,$H0,$H0

	vpaddq		$D0,$H1,$H1		# h0 -> h1



	 vpsrlq		\$40,$T4,$T4		# 4



	vpsrlq		\$26,$H3,$D3

	vpand		$MASK,$H3,$H3

	vpaddq		$D3,$H4,$H4		# h3 -> h4



	 vpand		$MASK,$T0,$T0		# 0

	 vpand		$MASK,$T1,$T1		# 1

	 vpand		$MASK,$T3,$T3		# 3

	 vpor		32(%rcx),$T4,$T4	# padbit, yes, always



	sub		\$64,$len

	jnz		.Loop_avx2$suffix



	.byte		0x66,0x90

.Ltail_avx2$suffix:

	################################################################

	# while above multiplications were by r^4 in all lanes, in last

	# iteration we multiply least significant lane by r^4 and most

	# significant one by r, so copy of above except that references

	# to the precomputed table are displaced by 4...



	#vpaddq		$H2,$T2,$H2		# accumulate input

	vpaddq		$H0,$T0,$H0

	vmovdqu		`32*0+4`(%rsp),$T0	# r0^4

	vpaddq		$H1,$T1,$H1

	vmovdqu		`32*1+4`(%rsp),$T1	# r1^4

	vpaddq		$H3,$T3,$H3

	vmovdqu		`32*3+4`(%rsp),$T2	# r2^4

	vpaddq		$H4,$T4,$H4

	vmovdqu		`32*6+4-0x90`(%rax),$T3	# s3^4

	vmovdqu		`32*8+4-0x90`(%rax),$S4	# s4^4



 d2 = h2*r0

	vpmuludq	$H2,$T1,$D3		# d3 = h2*r1

 d4 = h2*r2

	vpmuludq	$H2,$T3,$D0		# d0 = h2*s3

 d1 = h2*s4

 h0*r1

 h1*r1

	vpaddq		$T4,$D1,$D1		# d1 += h0*r1

 d2 += h1*r1

 h3*r1

 h4*s1

	vpaddq		$T4,$D4,$D4		# d4 += h3*r1

 d0 += h4*s1

 h0*r0

 h1*r0

	vpaddq		$T4,$D0,$D0		# d0 += h0*r0

	 vmovdqu	`32*4+4-0x90`(%rax),$T1	# s2

 d1 += h1*r0

 h3*r0

 h4*r0

	vpaddq		$T4,$D3,$D3		# d3 += h3*r0

 d4 += h4*r0

 h3*s2

 h4*s2

	vpaddq		$T4,$D0,$D0		# d0 += h3*s2

 d1 += h4*s2

 r3

 h1*r2

 h0*r2

	vpaddq		$T4,$D3,$D3		# d3 += h1*r2

 d2 += h0*r2

 h1*r3

 h0*r3

	vpaddq		$T4,$D4,$D4		# d4 += h1*r3

 d3 += h0*r3

 h3*s3

 h4*s3

	vpaddq		$T4,$D1,$D1		# d1 += h3*s3

 d2 += h4*s3

 h3*s4

 h4*s4

	vpaddq		$H3,$D2,$H2		# h2 = d2 + h3*r4

 h3 = d3 + h4*r4

 h0*r4

 h1*s4

 .Lmask26

	vpaddq		$H4,$D4,$H4		# h4 = d4 + h0*r4

 h0 = d0 + h1*s4

 horizontal addition

 lazy reduction

 h3 -> h4

 h0 -> h1

 h1 -> h2

 h4 -> h0

 h2 -> h3

 h0 -> h1

 h3 -> h4

$H0,`4*0-48-64`($ctx)
$H1,`4*1-48-64`($ctx)

$H2,`4*2-48-64`($ctx)

$H3,`4*3-48-64`($ctx)

$H4,`4*4-48-64`($ctx)

$code.=<<___	if ($win64);

	vmovdqa		-0xb0(%r10),%xmm6

	vmovdqa		-0xa0(%r10),%xmm7

	vmovdqa		-0x90(%r10),%xmm8

	vmovdqa		-0x80(%r10),%xmm9

	vmovdqa		-0x70(%r10),%xmm10

	vmovdqa		-0x60(%r10),%xmm11

	vmovdqa		-0x50(%r10),%xmm12

	vmovdqa		-0x40(%r10),%xmm13

	vmovdqa		-0x30(%r10),%xmm14

	vmovdqa		-0x20(%r10),%xmm15

	lea		-8(%r10),%rsp

.Ldo_avx2_epilogue$suffix:

___

<<___	if (!$win64);

$code.=<<___;

	vzeroupper

	ret

.cfi_endproc

___

if($avx > 2 && $avx512) {

 map("%zmm$_",(16..24));

my ($M0,$M1,$M2,$M3,$M4) = map("%zmm$_",(25..29));

"%zmm30";

 switch to %zmm domain

$code.=<<___;

.cfi_startproc

.Lblocks_avx512:

	mov		\$15,%eax

	kmovw		%eax,%k2

___

<<___	if (!$win64);

$code.=<<___	if ($win64);

	lea		8(%rsp),%r10

	sub		\$0x1c8,%rsp

	vmovdqa		%xmm6,-0xb0(%r10)

	vmovdqa		%xmm7,-0xa0(%r10)

	vmovdqa		%xmm8,-0x90(%r10)

	vmovdqa		%xmm9,-0x80(%r10)

	vmovdqa		%xmm10,-0x70(%r10)

	vmovdqa		%xmm11,-0x60(%r10)

	vmovdqa		%xmm12,-0x50(%r10)

	vmovdqa		%xmm13,-0x40(%r10)

	vmovdqa		%xmm14,-0x30(%r10)

	vmovdqa		%xmm15,-0x20(%r10)

.Ldo_avx512_body:

___

<<___;

 size optimization

$T2		
 expand pre-calculated table

$D0	
$D1	
$T0	
$D2	
$T1	
$D3	
$T3	
$D4	
$T4	
 00003412 -> 14243444

 .Lmask26

	vmovdqa64	$R0,0x00(%rsp){%k2}	# save in case $len%128 != 0

	 vpsrlq		\$32,$R0,$T0		# 14243444 -> 01020304

	vpermd		$T1,$T2,$S2

	vmovdqu64	$R1,0x00(%rsp,%rax){%k2}

	 vpsrlq		\$32,$R1,$T1

	vpermd		$D3,$T2,$R3

	vmovdqa64	$S1,0x40(%rsp){%k2}

	vpermd		$T3,$T2,$S3

	vpermd		$D4,$T2,$R4

	vmovdqu64	$R2,0x40(%rsp,%rax){%k2}

	vpermd		$T4,$T2,$S4

	vmovdqa64	$S2,0x80(%rsp){%k2}

	vmovdqu64	$R3,0x80(%rsp,%rax){%k2}

	vmovdqa64	$S3,0xc0(%rsp){%k2}

	vmovdqu64	$R4,0xc0(%rsp,%rax){%k2}

	vmovdqa64	$S4,0x100(%rsp){%k2}



	################################################################

	# calculate 5th through 8th powers of the key

	#

 d0 = r0'*r0 + r1'*5*r4 + r2'*5*r3 + r3'*5*r2 + r4'*5*r1

	# d1 = r0'*r1 + r1'*r0   + r2'*5*r4 + r3'*5*r3 + r4'*5*r2

 d2 = r0'*r2 + r1'*r1   + r2'*r0   + r3'*5*r4 + r4'*5*r3

	# d3 = r0'*r3 + r1'*r2   + r2'*r1   + r3'*r0   + r4'*5*r4

 d4 = r0'*r4 + r1'*r3   + r2'*r2   + r3'*r1   + r4'*r0

	vpmuludq	$T0,$R0,$D0		# d0 = r0'*r0

 d1 = r0'*r1

	vpmuludq	$T0,$R2,$D2		# d2 = r0'*r2

 d3 = r0'*r3

	vpmuludq	$T0,$R4,$D4		# d4 = r0'*r4

	 vpsrlq		\$32,$R2,$T2



	vpmuludq	$T1,$S4,$M0

	vpmuludq	$T1,$R0,$M1

	vpmuludq	$T1,$R1,$M2

	vpmuludq	$T1,$R2,$M3

	vpmuludq	$T1,$R3,$M4

	 vpsrlq		\$32,$R3,$T3

 d0 += r1'*5*r4

	vpaddq		$M1,$D1,$D1		# d1 += r1'*r0

 d2 += r1'*r1

	vpaddq		$M3,$D3,$D3		# d3 += r1'*r2

 d4 += r1'*r3

	vpaddq		$M0,$D0,$D0		# d0 += r2'*5*r3

 d1 += r2'*5*r4

	vpaddq		$M3,$D3,$D3		# d3 += r2'*r1

 d4 += r2'*r2

	vpaddq		$M2,$D2,$D2		# d2 += r2'*r0



	vpmuludq	$T3,$S2,$M0

	vpmuludq	$T3,$R0,$M3

	vpmuludq	$T3,$R1,$M4

	vpmuludq	$T3,$S3,$M1

	vpmuludq	$T3,$S4,$M2

 d0 += r3'*5*r2

	vpaddq		$M3,$D3,$D3		# d3 += r3'*r0

 d4 += r3'*r1

	vpaddq		$M1,$D1,$D1		# d1 += r3'*5*r3

 d2 += r3'*5*r4

	vpaddq		$M3,$D3,$D3		# d3 += r2'*5*r4

 d4 += r2'*r0

	vpaddq		$M0,$D0,$D0		# d0 += r2'*5*r1

 d1 += r2'*5*r2

	vpaddq		$M2,$D2,$D2		# d2 += r2'*5*r3



	################################################################

	# load input

	vmovdqu64	16*0($inp),%z#$T3

	vmovdqu64	16*4($inp),%z#$T4

	lea		16*8($inp),$inp



	################################################################

	# lazy reduction



	vpsrlq		\$26,$D3,$M3

	vpandq		$MASK,$D3,$D3

	vpaddq		$M3,$D4,$D4		# d3 -> d4



	vpsrlq		\$26,$D0,$M0

	vpandq		$MASK,$D0,$D0

	vpaddq		$M0,$D1,$D1		# d0 -> d1



	vpsrlq		\$26,$D4,$M4

	vpandq		$MASK,$D4,$D4



	vpsrlq		\$26,$D1,$M1

	vpandq		$MASK,$D1,$D1

	vpaddq		$M1,$D2,$D2		# d1 -> d2



	vpaddq		$M4,$D0,$D0

	vpsllq		\$2,$M4,$M4

	vpaddq		$M4,$D0,$D0		# d4 -> d0



	vpsrlq		\$26,$D2,$M2

	vpandq		$MASK,$D2,$D2

	vpaddq		$M2,$D3,$D3		# d2 -> d3



	vpsrlq		\$26,$D0,$M0

	vpandq		$MASK,$D0,$D0

	vpaddq		$M0,$D1,$D1		# d0 -> d1



	vpsrlq		\$26,$D3,$M3

	vpandq		$MASK,$D3,$D3

	vpaddq		$M3,$D4,$D4		# d3 -> d4



	################################################################

	# at this point we have 14243444 in $R0-$S4 and 05060708 in

	# $D0-$D4, ...



	vpunpcklqdq	$T4,$T3,$T0	# transpose input

	vpunpckhqdq	$T4,$T3,$T4



	# ... since input 64-bit lanes are ordered as 73625140, we could

	# "vperm" it to 76543210 (here and in each loop iteration), *or*

	# we could just flow along, hence the goal for $R0-$S4 is

	# 1858286838784888 ...



	vmovdqa32	128(%rcx),$M0		# .Lpermd_avx512:

	mov		\$0x7777,%eax

	kmovw		%eax,%k1



	vpermd		$R0,$M0,$R0		# 14243444 -> 1---2---3---4---

	vpermd		$R1,$M0,$R1

	vpermd		$R2,$M0,$R2

	vpermd		$R3,$M0,$R3

	vpermd		$R4,$M0,$R4



	vpermd		$D0,$M0,${R0}{%k1}	# 05060708 -> 1858286838784888

	vpermd		$D1,$M0,${R1}{%k1}

	vpermd		$D2,$M0,${R2}{%k1}

	vpermd		$D3,$M0,${R3}{%k1}

	vpermd		$D4,$M0,${R4}{%k1}



	vpslld		\$2,$R1,$S1		# *5

	vpslld		\$2,$R2,$S2

	vpslld		\$2,$R3,$S3

	vpslld		\$2,$R4,$S4

	vpaddd		$R1,$S1,$S1

	vpaddd		$R2,$S2,$S2

	vpaddd		$R3,$S3,$S3

	vpaddd		$R4,$S4,$S4



	vpbroadcastq	32(%rcx),$PADBIT	# .L129



	vpsrlq		\$52,$T0,$T2		# splat input

	vpsllq		\$12,$T4,$T3

	vporq		$T3,$T2,$T2

	vpsrlq		\$26,$T0,$T1

	vpsrlq		\$14,$T4,$T3

	vpsrlq		\$40,$T4,$T4		# 4

	vpandq		$MASK,$T2,$T2		# 2

	vpandq		$MASK,$T0,$T0		# 0

	#vpandq		$MASK,$T1,$T1		# 1

	#vpandq		$MASK,$T3,$T3		# 3

	#vporq		$PADBIT,$T4,$T4		# padbit, yes, always



	vpaddq		$H2,$T2,$H2		# accumulate input

	sub		\$192,$len

	jbe		.Ltail_avx512

	jmp		.Loop_avx512



.align	32

.Loop_avx512:

	################################################################

	# ((inp[0]*r^8+inp[ 8])*r^8+inp[16])*r^8

	# ((inp[1]*r^8+inp[ 9])*r^8+inp[17])*r^7

	# ((inp[2]*r^8+inp[10])*r^8+inp[18])*r^6

	# ((inp[3]*r^8+inp[11])*r^8+inp[19])*r^5

	# ((inp[4]*r^8+inp[12])*r^8+inp[20])*r^4

	# ((inp[5]*r^8+inp[13])*r^8+inp[21])*r^3

	# ((inp[6]*r^8+inp[14])*r^8+inp[22])*r^2

	# ((inp[7]*r^8+inp[15])*r^8+inp[23])*r^1

	#   \________/\___________/

	################################################################

	#vpaddq		$H2,$T2,$H2		# accumulate input



 d4 = h4*r0 + h3*r1   + h2*r2   + h1*r3   + h0*r4

	# d3 = h3*r0 + h2*r1   + h1*r2   + h0*r3   + h4*5*r4

 d2 = h2*r0 + h1*r1   + h0*r2   + h4*5*r3 + h3*5*r4

	# d1 = h1*r0 + h0*r1   + h4*5*r2 + h3*5*r3 + h2*5*r4

 d0 = h0*r0 + h4*5*r1 + h3*5*r2 + h2*5*r3 + h1*5*r4



 however, as h2 is "chronologically" first one available pull

 corresponding operations up, so it's



	# d3 = h2*r1   + h0*r3 + h1*r2   + h3*r0 + h4*5*r4

 d4 = h2*r2   + h0*r4 + h1*r3   + h3*r1 + h4*r0

	# d0 = h2*5*r3 + h0*r0 + h1*5*r4         + h3*5*r2 + h4*5*r1

 d1 = h2*5*r4 + h0*r1           + h1*r0 + h3*5*r3 + h4*5*r2

	# d2 = h2*r0           + h0*r2   + h1*r1 + h3*5*r4 + h4*5*r3



 d3 = h2*r1

	vpmuludq	$H2,$R2,$D4		# d4 = h2*r2

	 vpandq		$MASK,$T1,$T1		# 1

 d0 = h2*s3

 3

	vpmuludq	$H2,$S4,$D1		# d1 = h2*s4

	 vporq		$PADBIT,$T4,$T4		# padbit, yes, always

 d2 = h2*r0

 accumulate input

 load input

	vpaddq		$M3,$D3,$D3		# d3 += h0*r3

 d4 += h0*r4

	vpaddq		$M0,$D0,$D0		# d0 += h0*r0

 d1 += h0*r1

	vpaddq		$M3,$D3,$D3		# d3 += h1*r2

 d4 += h1*r3

	vpaddq		$M0,$D0,$D0		# d0 += h1*s4

 d2 += h0*r2

 transpose input

	vpaddq		$M3,$D3,$D3		# d3 += h3*r0

 d4 += h3*r1

	vpaddq		$M1,$D1,$D1		# d1 += h1*r0

 d2 += h1*r1

	vpaddq		$M3,$D3,$D3		# d3 += h4*s4

	vpmuludq	$H3,$S4,$M2

 d4 += h4*r0

	vpaddq		$M0,$D0,$D0		# d0 += h3*s2

 d1 += h3*s3

	vpaddq		$M2,$D2,$D2		# d2 += h3*s4



	vpmuludq	$H4,$S1,$M0

	vpmuludq	$H4,$S2,$M1

	vpmuludq	$H4,$S3,$M2

 h0 = d0 + h4*s1

	vpaddq		$M1,$D1,$H1		# h1 = d2 + h4*s2

 h2 = d3 + h4*s3

 lazy reduction (interleaved with input splat)

 splat input

 h3 -> h4

 h0 -> h1

 2

 h1 -> h2

 h4 -> h0

 modulo-scheduled

 h2 -> h3

 h0 -> h1

 4

 h3 -> h4

 0

vpandq	$MASK,$T1,$T1		
vpandq	$MASK,$T3,$T3		
vporq		$PADBIT,$T4,$T4		
 while above multiplications were by r^8 in all lanes, in last

 iteration we multiply least significant lane by r^8 and most

 significant one by r, that's why table gets shifted...

 0105020603070408

 load either next or last 64 byte of input

vpaddq		$H2,$T2,$H2		
	vpmuludq	$H2,$R1,$D3		# d3 = h2*r1

 d4 = h2*r2

	vpmuludq	$H2,$S3,$D0		# d0 = h2*s3

	 vpandq		$MASK,$T1,$T1		# 1

 d1 = h2*s4

 3

	vpmuludq	$H2,$R0,$D2		# d2 = h2*r0

	 vporq		$PADBIT,$T4,$T4		# padbit, yes, always

	 vpaddq		$H1,$T1,$H1		# accumulate input

	 vpaddq		$H3,$T3,$H3

	 vpaddq		$H4,$T4,$H4



	  vmovdqu	16*0($inp),%x#$T0

	vpmuludq	$H0,$R3,$M3

	vpmuludq	$H0,$R4,$M4

	vpmuludq	$H0,$R0,$M0

	vpmuludq	$H0,$R1,$M1

 d3 += h0*r3

	vpaddq		$M4,$D4,$D4		# d4 += h0*r4

 d0 += h0*r0

	vpaddq		$M1,$D1,$D1		# d1 += h0*r1



	  vmovdqu	16*1($inp),%x#$T1

	vpmuludq	$H1,$R2,$M3

	vpmuludq	$H1,$R3,$M4

	vpmuludq	$H1,$S4,$M0

	vpmuludq	$H0,$R2,$M2

 d3 += h1*r2

	vpaddq		$M4,$D4,$D4		# d4 += h1*r3

 d0 += h1*s4

	vpaddq		$M2,$D2,$D2		# d2 += h0*r2



	  vinserti128	\$1,16*2($inp),%y#$T0,%y#$T0

	vpmuludq	$H3,$R0,$M3

	vpmuludq	$H3,$R1,$M4

	vpmuludq	$H1,$R0,$M1

	vpmuludq	$H1,$R1,$M2

 d3 += h3*r0

	vpaddq		$M4,$D4,$D4		# d4 += h3*r1

 d1 += h1*r0

	vpaddq		$M2,$D2,$D2		# d2 += h1*r1



	  vinserti128	\$1,16*3($inp),%y#$T1,%y#$T1

	vpmuludq	$H4,$S4,$M3

	vpmuludq	$H4,$R0,$M4

	vpmuludq	$H3,$S2,$M0

	vpmuludq	$H3,$S3,$M1

	vpmuludq	$H3,$S4,$M2

 h3 = d3 + h4*s4

	vpaddq		$M4,$D4,$D4		# d4 += h4*r0

 d0 += h3*s2

	vpaddq		$M1,$D1,$D1		# d1 += h3*s3

 d2 += h3*s4

	vpaddq		$M0,$D0,$H0		# h0 = d0 + h4*s1

 h1 = d2 + h4*s2

	vpaddq		$M2,$D2,$H2		# h2 = d3 + h4*s3



	################################################################

	# horizontal addition



	mov		\$1,%eax

	vpermq		\$0xb1,$H3,$D3

	vpermq		\$0xb1,$D4,$H4

	vpermq		\$0xb1,$H0,$D0

	vpermq		\$0xb1,$H1,$D1

	vpermq		\$0xb1,$H2,$D2

	vpaddq		$D3,$H3,$H3

	vpaddq		$D4,$H4,$H4

	vpaddq		$D0,$H0,$H0

	vpaddq		$D1,$H1,$H1

	vpaddq		$D2,$H2,$H2



	kmovw		%eax,%k3

	vpermq		\$0x2,$H3,$D3

	vpermq		\$0x2,$H4,$D4

	vpermq		\$0x2,$H0,$D0

	vpermq		\$0x2,$H1,$D1

	vpermq		\$0x2,$H2,$D2

	vpaddq		$D3,$H3,$H3

	vpaddq		$D4,$H4,$H4

	vpaddq		$D0,$H0,$H0

	vpaddq		$D1,$H1,$H1

	vpaddq		$D2,$H2,$H2



	vextracti64x4	\$0x1,$H3,%y#$D3

	vextracti64x4	\$0x1,$H4,%y#$D4

	vextracti64x4	\$0x1,$H0,%y#$D0

	vextracti64x4	\$0x1,$H1,%y#$D1

	vextracti64x4	\$0x1,$H2,%y#$D2

	vpaddq		$D3,$H3,${H3}{%k3}{z}	# keep single qword in case

	vpaddq		$D4,$H4,${H4}{%k3}{z}	# it's passed to .Ltail_avx2

	vpaddq		$D0,$H0,${H0}{%k3}{z}

	vpaddq		$D1,$H1,${H1}{%k3}{z}

	vpaddq		$D2,$H2,${H2}{%k3}{z}

___

map(s/%z/%y/,($T0,$T1,$T2,$T3,$T4, $PADBIT));

map(s/%z/%y/,($H0,$H1,$H2,$H3,$H4, $D0,$D1,$D2,$D3,$D4, $MASK));

<<___;

 lazy reduction (interleaved with input splat)

 splat input

 4

 h3 -> h4

 2:3

 0:1

 h0 -> h1

 h1 -> h2

 4

 h4 -> h0

 2

 0

 h2 -> h3

 accumulate input for .Ltail_avx2

 1

 h0 -> h1

 3

 padbit, yes, always

 h3 -> h4

 size optimization for .Ltail_avx2

 undo input accumulation

$H0,`4*0-48-64`($ctx)
$H1,`4*1-48-64`($ctx)

$H2,`4*2-48-64`($ctx)

$H3,`4*3-48-64`($ctx)

$H4,`4*4-48-64`($ctx)

$code.=<<___	if ($win64);

	movdqa		-0xb0(%r10),%xmm6

	movdqa		-0xa0(%r10),%xmm7

	movdqa		-0x90(%r10),%xmm8

	movdqa		-0x80(%r10),%xmm9

	movdqa		-0x70(%r10),%xmm10

	movdqa		-0x60(%r10),%xmm11

	movdqa		-0x50(%r10),%xmm12

	movdqa		-0x40(%r10),%xmm13

	movdqa		-0x30(%r10),%xmm14

	movdqa		-0x20(%r10),%xmm15

	lea		-8(%r10),%rsp

.Ldo_avx512_epilogue:

___

<<___	if (!$win64);

$code.=<<___;

	ret

.cfi_endproc

___



}



}



&declare_function("poly1305_blocks_avx2", 32, 4);

poly1305_blocks_avxN(0);

&end_function("poly1305_blocks_avx2");



#######################################################################

if ($avx>2) {

# On entry we have input length divisible by 64. But since inner loop

# processes 128 bytes per iteration, cases when length is not divisible

# by 128 are handled by passing tail 64 bytes to .Ltail_avx2. For this

# reason stack layout is kept identical to poly1305_blocks_avx2. If not

# for this tail, we wouldn't have to even allocate stack frame...



if($kernel) {

ifdef CONFIG_AS_AVX512\n";

	$code .= "#endif\n";

}



if (!$kernel && $avx>3) {

########################################################################

# VPMADD52 version using 2^44 radix.

#

# One can argue that base 2^52 would be more natural. Well, even though

# some operations would be more natural, one has to recognize couple of

# things. Base 2^52 doesn't provide advantage over base 2^44 if you look

# at amount of multiply-n-accumulate operations. Secondly, it makes it

# impossible to pre-compute multiples of 5 [referred to as s[]/sN in

# reference implementations], which means that more such operations

# would have to be performed in inner loop, which in turn makes critical

# path longer. In other words, even though base 2^44 reduction might

# look less elegant, overall critical path is actually shorter...



########################################################################

# Layout of opaque area is following.

#

#	unsigned __int64 h[3];		# current hash value base 2^44

#	unsigned __int64 s[2];		# key value*20 base 2^44

#	unsigned __int64 r[3];		# key value base 2^44

#	struct { unsigned __int64 r^1, r^3, r^2, r^4; } R[4];

#					# r^n positions reflect

#					# placement in register, not

#					# memory, R[3] is R[1]*20



<<___;

 initialize hash value

 r0

 r1

 *5

 r2

 magic <<2

 *5

 magic <<2

 s1

 s2

 write impossible value

$code.=<<___	if ($flavour !~ /elf32/);

	mov	%r10,0(%rdx)

	mov	%r11,8(%rdx)

___

$code.=<<___	if ($flavour =~ /elf32/);

	mov	%r10d,0(%rdx)

	mov	%r11d,4(%rdx)

___

<<___;

my ($H0,$H1,$H2,$r2r1r0,$r1r0s2,$r0s2s1,$Dlo,$Dhi) = map("%ymm$_",(0..5,16,17));

 map("%ymm$_",(18..21));

my ($reduc_mask,$reduc_rght,$reduc_left) = map("%ymm$_",(22..25));



<<___;

 too short

 peek on power of the key

 if powers of the key are not calculated yet, process up to 3

 blocks with this single-block subroutine, otherwise ensure that

 length is divisible by 2 blocks and pass the rest down to next

 subroutine...

 is input long

 is power value impossible?

 is input of favourable length?

$PAD

 .L2_44_inp_permd

 .L2_44_inp_shift

 .L2_44_mask

 load hash value

 load keys

 .L2_44_shift_rgt

 .L2_44_shift_lft

$T0		
 ----3210 -> --322110

 accumulate input

 smash hash value

 0 in topmost qword

 0 in topmost qword

 0 in lowest qword

 note topmost qword :-)

 0 in topmost word

	dec		%rax			# len-=16

	jnz		.Loop_vpmadd52



	vmovdqu64	$Dlo,0($ctx){%k7}	# store hash value



	test		$len,$len

	jnz		.Lblocks_vpmadd52_4x



.Lno_data_vpmadd52:

	ret

.size	poly1305_blocks_vpmadd52,.-poly1305_blocks_vpmadd52

___

}

{

########################################################################

# As implied by its name 4x subroutine processes 4 blocks in parallel

# (but handles even 4*n+2 blocks lengths). It takes up to 4th key power

# and is handled in 256-bit %ymm registers.



 map("%ymm$_",(0..5,16,17));

my ($D0lo,$D0hi,$D1lo,$D1hi,$D2lo,$D2hi) = map("%ymm$_",(18..23));

 map("%ymm$_",(24..31));

$code.=<<___;

.type	poly1305_blocks_vpmadd52_4x,\@function,4

.align	32

poly1305_blocks_vpmadd52_4x:

	shr	\$4,$len

	jz	.Lno_data_vpmadd52_4x		# too short



	shl	\$40,$padbit

	mov	64($ctx),%r8			# peek on power of the key



.Lblocks_vpmadd52_4x:

	vpbroadcastq	$padbit,$PAD



	vmovdqa64	.Lx_mask44(%rip),$mask44

	mov		\$5,%eax

	vmovdqa64	.Lx_mask42(%rip),$mask42

	kmovw		%eax,%k1		# used in 2x path



	test		%r8,%r8			# is power value impossible?

	js		.Linit_vpmadd52		# if it is, then init R[4]



	vmovq		0($ctx),%x#$H0		# load current hash value

	vmovq		8($ctx),%x#$H1

	vmovq		16($ctx),%x#$H2



	test		\$3,$len		# is length 4*n+2?

	jnz		.Lblocks_vpmadd52_2x_do



.Lblocks_vpmadd52_4x_do:

	vpbroadcastq	64($ctx),$R0		# load 4th power of the key

	vpbroadcastq	96($ctx),$R1

	vpbroadcastq	128($ctx),$R2

	vpbroadcastq	160($ctx),$S1



.Lblocks_vpmadd52_4x_key_loaded:

 S2 = R2*5*4

 is len 8*n?

 load data

 transpose data

 at this point 64-bit lanes are ordered as 3-1-2-0

 splat the data

 accumulate input

$S1		
$H2

$S2

$R0

$R1

 partial reduction

 additional step

 1,2

$H1,%x 2,2

$H2,%x
$H0,%x
	vpsllq		\$2,$R1,$S1		# S1 = R1*5*4

 S2 = R2*5*4

$R1,$H1,$R1	
$R2,$H2,$R2

$R0,$H0,$R0

 1,3,2,4

	vpsllq		\$2,$R1,$S1		# S1 = R1*5*4

	vpaddq		$R1,$S1,$S1

	vpsllq		\$2,$S1,$S1



	vmovq		0($ctx),%x#$H0		# load current hash value

	vmovq		8($ctx),%x#$H1

	vmovq		16($ctx),%x#$H2



	test		\$3,$len		# is length 4*n+2?

	jnz		.Ldone_init_vpmadd52_2x



	vmovdqu64	$R0,64($ctx)		# save key powers

	vpbroadcastq	%x#$R0,$R0		# broadcast 4th power

	vmovdqu64	$R1,96($ctx)

	vpbroadcastq	%x#$R1,$R1

	vmovdqu64	$R2,128($ctx)

	vpbroadcastq	%x#$R2,$R2

	vmovdqu64	$S1,160($ctx)

	vpbroadcastq	%x#$S1,$S1



	jmp		.Lblocks_vpmadd52_4x_key_loaded

	ud2



.align	32

.Ldone_init_vpmadd52_2x:

	vmovdqu64	$R0,64($ctx)		# save key powers

	vpsrldq		\$8,$R0,$R0		# 0-1-0-2

	vmovdqu64	$R1,96($ctx)

	vpsrldq		\$8,$R1,$R1

	vmovdqu64	$R2,128($ctx)

	vpsrldq		\$8,$R2,$R2

	vmovdqu64	$S1,160($ctx)

	vpsrldq		\$8,$S1,$S1

	jmp		.Lblocks_vpmadd52_2x_key_loaded

	ud2



.align	32

.Lblocks_vpmadd52_2x_do:

	vmovdqu64	128+8($ctx),${R2}{%k1}{z}# load 2nd and 1st key powers

	vmovdqu64	160+8($ctx),${S1}{%k1}{z}

	vmovdqu64	64+8($ctx),${R0}{%k1}{z}

	vmovdqu64	96+8($ctx),${R1}{%k1}{z}



.Lblocks_vpmadd52_2x_key_loaded:

	vmovdqu64	16*0($inp),$T2		# load data

	vpxorq		$T3,$T3,$T3

	lea		16*2($inp),$inp



	vpunpcklqdq	$T3,$T2,$T1		# transpose data

	vpunpckhqdq	$T3,$T2,$T3



	# at this point 64-bit lanes are ordered as x-1-x-0



	vpsrlq		\$24,$T3,$T2		# splat the data

	vporq		$PAD,$T2,$T2

	 vpaddq		$T2,$H2,$H2		# accumulate input

	vpandq		$mask44,$T1,$T0

	vpsrlq		\$44,$T1,$T1

	vpsllq		\$20,$T3,$T3

	vporq		$T3,$T1,$T1

	vpandq		$mask44,$T1,$T1



	jmp		.Ltail_vpmadd52_2x

	ud2



.align	32

.Loop_vpmadd52_4x:

	#vpaddq		$T2,$H2,$H2		# accumulate input

	vpaddq		$T0,$H0,$H0

	vpaddq		$T1,$H1,$H1



	vpxorq		$D0lo,$D0lo,$D0lo

	vpmadd52luq	$H2,$S1,$D0lo

	vpxorq		$D0hi,$D0hi,$D0hi

	vpmadd52huq	$H2,$S1,$D0hi

	vpxorq		$D1lo,$D1lo,$D1lo

	vpmadd52luq	$H2,$S2,$D1lo

	vpxorq		$D1hi,$D1hi,$D1hi

	vpmadd52huq	$H2,$S2,$D1hi

	vpxorq		$D2lo,$D2lo,$D2lo

	vpmadd52luq	$H2,$R0,$D2lo

	vpxorq		$D2hi,$D2hi,$D2hi

	vpmadd52huq	$H2,$R0,$D2hi



	 vmovdqu64	16*0($inp),$T2		# load data

	 vmovdqu64	16*2($inp),$T3

	 lea		16*4($inp),$inp

	vpmadd52luq	$H0,$R0,$D0lo

	vpmadd52huq	$H0,$R0,$D0hi

	vpmadd52luq	$H0,$R1,$D1lo

	vpmadd52huq	$H0,$R1,$D1hi

	vpmadd52luq	$H0,$R2,$D2lo

	vpmadd52huq	$H0,$R2,$D2hi



	 vpunpcklqdq	$T3,$T2,$T1		# transpose data

	 vpunpckhqdq	$T3,$T2,$T3

	vpmadd52luq	$H1,$S2,$D0lo

	vpmadd52huq	$H1,$S2,$D0hi

	vpmadd52luq	$H1,$R0,$D1lo

	vpmadd52huq	$H1,$R0,$D1hi

	vpmadd52luq	$H1,$R1,$D2lo

	vpmadd52huq	$H1,$R1,$D2hi



	################################################################

	# partial reduction (interleaved with data splat)

	vpsrlq		\$44,$D0lo,$tmp

	vpsllq		\$8,$D0hi,$D0hi

	vpandq		$mask44,$D0lo,$H0

	vpaddq		$tmp,$D0hi,$D0hi



	 vpsrlq		\$24,$T3,$T2

	 vporq		$PAD,$T2,$T2

	vpaddq		$D0hi,$D1lo,$D1lo



	vpsrlq		\$44,$D1lo,$tmp

	vpsllq		\$8,$D1hi,$D1hi

	vpandq		$mask44,$D1lo,$H1

	vpaddq		$tmp,$D1hi,$D1hi



	 vpandq		$mask44,$T1,$T0

	 vpsrlq		\$44,$T1,$T1

	 vpsllq		\$20,$T3,$T3

	vpaddq		$D1hi,$D2lo,$D2lo



	vpsrlq		\$42,$D2lo,$tmp

	vpsllq		\$10,$D2hi,$D2hi

	vpandq		$mask42,$D2lo,$H2

	vpaddq		$tmp,$D2hi,$D2hi



	  vpaddq	$T2,$H2,$H2		# accumulate input

	vpaddq		$D2hi,$H0,$H0

	vpsllq		\$2,$D2hi,$D2hi



	vpaddq		$D2hi,$H0,$H0

	 vporq		$T3,$T1,$T1

	 vpandq		$mask44,$T1,$T1



	vpsrlq		\$44,$H0,$tmp		# additional step

	vpandq		$mask44,$H0,$H0



	vpaddq		$tmp,$H1,$H1



 len-=64

 load all key powers

	vpsllq		\$2,$R2,$S2		# S2 = R2*5*4

	vpaddq		$R2,$S2,$S2

	vpsllq		\$2,$S2,$S2



	#vpaddq		$T2,$H2,$H2		# accumulate input

	vpaddq		$T0,$H0,$H0

	vpaddq		$T1,$H1,$H1



	vpxorq		$D0lo,$D0lo,$D0lo

	vpmadd52luq	$H2,$S1,$D0lo

	vpxorq		$D0hi,$D0hi,$D0hi

	vpmadd52huq	$H2,$S1,$D0hi

	vpxorq		$D1lo,$D1lo,$D1lo

	vpmadd52luq	$H2,$S2,$D1lo

	vpxorq		$D1hi,$D1hi,$D1hi

	vpmadd52huq	$H2,$S2,$D1hi

	vpxorq		$D2lo,$D2lo,$D2lo

	vpmadd52luq	$H2,$R0,$D2lo

	vpxorq		$D2hi,$D2hi,$D2hi

	vpmadd52huq	$H2,$R0,$D2hi



	vpmadd52luq	$H0,$R0,$D0lo

	vpmadd52huq	$H0,$R0,$D0hi

	vpmadd52luq	$H0,$R1,$D1lo

	vpmadd52huq	$H0,$R1,$D1hi

	vpmadd52luq	$H0,$R2,$D2lo

	vpmadd52huq	$H0,$R2,$D2hi



	vpmadd52luq	$H1,$S2,$D0lo

	vpmadd52huq	$H1,$S2,$D0hi

	vpmadd52luq	$H1,$R0,$D1lo

	vpmadd52huq	$H1,$R0,$D1hi

	vpmadd52luq	$H1,$R1,$D2lo

	vpmadd52huq	$H1,$R1,$D2hi



	################################################################

	# horizontal addition



	mov		\$1,%eax

	kmovw		%eax,%k1

	vpsrldq		\$8,$D0lo,$T0

	vpsrldq		\$8,$D0hi,$H0

	vpsrldq		\$8,$D1lo,$T1

	vpsrldq		\$8,$D1hi,$H1

	vpaddq		$T0,$D0lo,$D0lo

	vpaddq		$H0,$D0hi,$D0hi

	vpsrldq		\$8,$D2lo,$T2

	vpsrldq		\$8,$D2hi,$H2

	vpaddq		$T1,$D1lo,$D1lo

	vpaddq		$H1,$D1hi,$D1hi

	 vpermq		\$0x2,$D0lo,$T0

	 vpermq		\$0x2,$D0hi,$H0

	vpaddq		$T2,$D2lo,$D2lo

	vpaddq		$H2,$D2hi,$D2hi



	vpermq		\$0x2,$D1lo,$T1

	vpermq		\$0x2,$D1hi,$H1

	vpaddq		$T0,$D0lo,${D0lo}{%k1}{z}

	vpaddq		$H0,$D0hi,${D0hi}{%k1}{z}

	vpermq		\$0x2,$D2lo,$T2

	vpermq		\$0x2,$D2hi,$H2

	vpaddq		$T1,$D1lo,${D1lo}{%k1}{z}

	vpaddq		$H1,$D1hi,${D1hi}{%k1}{z}

	vpaddq		$T2,$D2lo,${D2lo}{%k1}{z}

	vpaddq		$H2,$D2hi,${D2hi}{%k1}{z}



	################################################################

	# partial reduction

	vpsrlq		\$44,$D0lo,$tmp

	vpsllq		\$8,$D0hi,$D0hi

	vpandq		$mask44,$D0lo,$H0

	vpaddq		$tmp,$D0hi,$D0hi



	vpaddq		$D0hi,$D1lo,$D1lo



	vpsrlq		\$44,$D1lo,$tmp

	vpsllq		\$8,$D1hi,$D1hi

	vpandq		$mask44,$D1lo,$H1

	vpaddq		$tmp,$D1hi,$D1hi



	vpaddq		$D1hi,$D2lo,$D2lo



	vpsrlq		\$42,$D2lo,$tmp

	vpsllq		\$10,$D2hi,$D2hi

	vpandq		$mask42,$D2lo,$H2

	vpaddq		$tmp,$D2hi,$D2hi



	vpaddq		$D2hi,$H0,$H0

	vpsllq		\$2,$D2hi,$D2hi



	vpaddq		$D2hi,$H0,$H0



	vpsrlq		\$44,$H0,$tmp		# additional step

	vpandq		$mask44,$H0,$H0



	vpaddq		$tmp,$H1,$H1

						# at this point $len is

						# either 4*n+2 or 0...

 len-=32

$H0,0($ctx)

$H1,8($ctx)

$H2,16($ctx)

 As implied by its name 8x subroutine processes 8 blocks in parallel...

 This is intermediate version, as it's used only in cases when input

 length is either 8*n, 8*n+1 or 8*n+2...

my ($H0,$H1,$H2,$R0,$R1,$R2,$S1,$S2) = map("%ymm$_",(0..5,16,17));

 map("%ymm$_",(18..23));

my ($T0,$T1,$T2,$T3,$mask44,$mask42,$tmp,$PAD) = map("%ymm$_",(24..31));

 map("%ymm$_",(6..10));

$code.=<<___;

.type	poly1305_blocks_vpmadd52_8x,\@function,4

.align	32

poly1305_blocks_vpmadd52_8x:

	shr	\$4,$len

	jz	.Lno_data_vpmadd52_8x		# too short



	shl	\$40,$padbit

	mov	64($ctx),%r8			# peek on power of the key



	vmovdqa64	.Lx_mask44(%rip),$mask44

	vmovdqa64	.Lx_mask42(%rip),$mask42



	test	%r8,%r8				# is power value impossible?

	js	.Linit_vpmadd52			# if it is, then init R[4]



	vmovq	0($ctx),%x#$H0			# load current hash value

	vmovq	8($ctx),%x#$H1

	vmovq	16($ctx),%x#$H2



.Lblocks_vpmadd52_8x:

	################################################################

	# fist we calculate more key powers



	vmovdqu64	128($ctx),$R2		# load 1-3-2-4 powers

	vmovdqu64	160($ctx),$S1

	vmovdqu64	64($ctx),$R0

	vmovdqu64	96($ctx),$R1



 S2 = R2*5*4

$R2,$RR2		
$R0,$RR0

$R1,$RR1

 partial reduction

 additional step

 At this point Rx holds 1324 powers, RRx - 5768, and the goal

 is 15263748, which reflects how data is loaded...

 3748

 1526

$code.=<<___;

	vshufi64x2	\$0x44,$R2,$T2,$RR2	# 15263748

	vshufi64x2	\$0x44,$R0,$T0,$RR0

	vshufi64x2	\$0x44,$R1,$T1,$RR1



	vmovdqu64	16*0($inp),$T2		# load data

	vmovdqu64	16*4($inp),$T3

	lea		16*8($inp),$inp



 S2 = R2*5*4

	vpsllq		\$2,$RR1,$SS1		# S1 = R1*5*4

	vpaddq		$RR2,$SS2,$SS2

	vpaddq		$RR1,$SS1,$SS1

	vpsllq		\$2,$SS2,$SS2

	vpsllq		\$2,$SS1,$SS1



	vpbroadcastq	$padbit,$PAD

	vpbroadcastq	%x#$mask44,$mask44

	vpbroadcastq	%x#$mask42,$mask42



	vpbroadcastq	%x#$SS1,$S1		# broadcast 8th power

	vpbroadcastq	%x#$SS2,$S2

	vpbroadcastq	%x#$RR0,$R0

	vpbroadcastq	%x#$RR1,$R1

	vpbroadcastq	%x#$RR2,$R2



	vpunpcklqdq	$T3,$T2,$T1		# transpose data

	vpunpckhqdq	$T3,$T2,$T3



	# at this point 64-bit lanes are ordered as 73625140



	vpsrlq		\$24,$T3,$T2		# splat the data

	vporq		$PAD,$T2,$T2

	 vpaddq		$T2,$H2,$H2		# accumulate input

	vpandq		$mask44,$T1,$T0

	vpsrlq		\$44,$T1,$T1

	vpsllq		\$20,$T3,$T3

	vporq		$T3,$T1,$T1

	vpandq		$mask44,$T1,$T1



	sub		\$8,$len

	jz		.Ltail_vpmadd52_8x

	jmp		.Loop_vpmadd52_8x



.align	32

.Loop_vpmadd52_8x:

	#vpaddq		$T2,$H2,$H2		# accumulate input

	vpaddq		$T0,$H0,$H0

	vpaddq		$T1,$H1,$H1



	vpxorq		$D0lo,$D0lo,$D0lo

	vpmadd52luq	$H2,$S1,$D0lo

	vpxorq		$D0hi,$D0hi,$D0hi

	vpmadd52huq	$H2,$S1,$D0hi

	vpxorq		$D1lo,$D1lo,$D1lo

	vpmadd52luq	$H2,$S2,$D1lo

	vpxorq		$D1hi,$D1hi,$D1hi

	vpmadd52huq	$H2,$S2,$D1hi

	vpxorq		$D2lo,$D2lo,$D2lo

	vpmadd52luq	$H2,$R0,$D2lo

	vpxorq		$D2hi,$D2hi,$D2hi

	vpmadd52huq	$H2,$R0,$D2hi



	 vmovdqu64	16*0($inp),$T2		# load data

	 vmovdqu64	16*4($inp),$T3

	 lea		16*8($inp),$inp

	vpmadd52luq	$H0,$R0,$D0lo

	vpmadd52huq	$H0,$R0,$D0hi

	vpmadd52luq	$H0,$R1,$D1lo

	vpmadd52huq	$H0,$R1,$D1hi

	vpmadd52luq	$H0,$R2,$D2lo

	vpmadd52huq	$H0,$R2,$D2hi



	 vpunpcklqdq	$T3,$T2,$T1		# transpose data

	 vpunpckhqdq	$T3,$T2,$T3

	vpmadd52luq	$H1,$S2,$D0lo

	vpmadd52huq	$H1,$S2,$D0hi

	vpmadd52luq	$H1,$R0,$D1lo

	vpmadd52huq	$H1,$R0,$D1hi

	vpmadd52luq	$H1,$R1,$D2lo

	vpmadd52huq	$H1,$R1,$D2hi



	################################################################

	# partial reduction (interleaved with data splat)

	vpsrlq		\$44,$D0lo,$tmp

	vpsllq		\$8,$D0hi,$D0hi

	vpandq		$mask44,$D0lo,$H0

	vpaddq		$tmp,$D0hi,$D0hi



	 vpsrlq		\$24,$T3,$T2

	 vporq		$PAD,$T2,$T2

	vpaddq		$D0hi,$D1lo,$D1lo



	vpsrlq		\$44,$D1lo,$tmp

	vpsllq		\$8,$D1hi,$D1hi

	vpandq		$mask44,$D1lo,$H1

	vpaddq		$tmp,$D1hi,$D1hi



	 vpandq		$mask44,$T1,$T0

	 vpsrlq		\$44,$T1,$T1

	 vpsllq		\$20,$T3,$T3

	vpaddq		$D1hi,$D2lo,$D2lo



	vpsrlq		\$42,$D2lo,$tmp

	vpsllq		\$10,$D2hi,$D2hi

	vpandq		$mask42,$D2lo,$H2

	vpaddq		$tmp,$D2hi,$D2hi



	  vpaddq	$T2,$H2,$H2		# accumulate input

	vpaddq		$D2hi,$H0,$H0

	vpsllq		\$2,$D2hi,$D2hi



	vpaddq		$D2hi,$H0,$H0

	 vporq		$T3,$T1,$T1

	 vpandq		$mask44,$T1,$T1



	vpsrlq		\$44,$H0,$tmp		# additional step

	vpandq		$mask44,$H0,$H0



	vpaddq		$tmp,$H1,$H1



 len-=128

vpaddq		$T2,$H2,$H2		
 horizontal addition

$T0

$H0

$T1

$H1

$T2

$H2

$code.=<<___;

	vpaddq		$T0,$D0lo,${D0lo}{%k1}{z}

	vpaddq		$H0,$D0hi,${D0hi}{%k1}{z}

	vpaddq		$T1,$D1lo,${D1lo}{%k1}{z}

	vpaddq		$H1,$D1hi,${D1hi}{%k1}{z}

	vpaddq		$T2,$D2lo,${D2lo}{%k1}{z}

	vpaddq		$H2,$D2hi,${D2hi}{%k1}{z}



	################################################################

	# partial reduction

	vpsrlq		\$44,$D0lo,$tmp

	vpsllq		\$8,$D0hi,$D0hi

	vpandq		$mask44,$D0lo,$H0

	vpaddq		$tmp,$D0hi,$D0hi



	vpaddq		$D0hi,$D1lo,$D1lo



	vpsrlq		\$44,$D1lo,$tmp

	vpsllq		\$8,$D1hi,$D1hi

	vpandq		$mask44,$D1lo,$H1

	vpaddq		$tmp,$D1hi,$D1hi



	vpaddq		$D1hi,$D2lo,$D2lo



	vpsrlq		\$42,$D2lo,$tmp

	vpsllq		\$10,$D2hi,$D2hi

	vpandq		$mask42,$D2lo,$H2

	vpaddq		$tmp,$D2hi,$D2hi



	vpaddq		$D2hi,$H0,$H0

	vpsllq		\$2,$D2hi,$D2hi



	vpaddq		$D2hi,$H0,$H0



	vpsrlq		\$44,$H0,$tmp		# additional step

	vpandq		$mask44,$H0,$H0



	vpaddq		$tmp,$H1,$H1



	################################################################



	vmovq		%x#$H0,0($ctx)

	vmovq		%x#$H1,8($ctx)

	vmovq		%x#$H2,16($ctx)

	vzeroall



.Lno_data_vpmadd52_8x:

	ret

.size	poly1305_blocks_vpmadd52_8x,.-poly1305_blocks_vpmadd52_8x

___

}

<<___;

 load hash value

 compare to modulus

 did 130-bit value overflow?

 accumulate nonce

 write result

 chacha20-poly1305 helpers

my ($out,$inp,$otp,$len)=$win64 ? ("%rcx","%rdx","%r8", "%r9") :  # Win64 order

                                  ("%rdi","%rsi","%rdx","%rcx");  # Unix order

<<___;

 put len aside

 len / 16

 len % 16

 put len aside

 len / 16

 len % 16

 EXCEPTION_DISPOSITION handler (EXCEPTION_RECORD *rec,ULONG64 frame,

		CONTEXT *context,DISPATCHER_CONTEXT *disp)

$rec="%rcx";

"%rdx";

$context="%r8";

"%r9";

$code.=<<___;

.extern	__imp_RtlVirtualUnwind

.type	se_handler,\@abi-omnipotent

.align	16

se_handler:

	push	%rsi

	push	%rdi

	push	%rbx

	push	%rbp

	push	%r12

	push	%r13

	push	%r14

	push	%r15

	pushfq

	sub	\$64,%rsp



	mov	120($context),%rax	# pull context->Rax

	mov	248($context),%rbx	# pull context->Rip



	mov	8($disp),%rsi		# disp->ImageBase

	mov	56($disp),%r11		# disp->HandlerData



	mov	0(%r11),%r10d		# HandlerData[0]

	lea	(%rsi,%r10),%r10	# prologue label

	cmp	%r10,%rbx		# context->Rip<.Lprologue

	jb	.Lcommon_seh_tail



	mov	152($context),%rax	# pull context->Rsp



	mov	4(%r11),%r10d		# HandlerData[1]

	lea	(%rsi,%r10),%r10	# epilogue label

 context->Rip>=.Lepilogue

 restore context->Rbx

 restore context->Rbp

 restore context->R12

 restore context->R13

 restore context->R14

 restore context->R14

 pull context->Rax

 pull context->Rip

 disp->ImageBase

 disp->HandlerData

 HandlerData[0]

 prologue label

 context->Rip<prologue label

 pull context->Rsp

 HandlerData[1]

 epilogue label

	cmp	%r10,%rbx		# context->Rip>=epilogue label

	jae	.Lcommon_seh_tail



	mov	208($context),%rax	# pull context->R11



	lea	0x50(%rax),%rsi

	lea	0xf8(%rax),%rax

	lea	512($context),%rdi	# &context.Xmm6

	mov	\$20,%ecx

	.long	0xa548f3fc		# cld; rep movsq



.Lcommon_seh_tail:

	mov	8(%rax),%rdi

	mov	16(%rax),%rsi

	mov	%rax,152($context)	# restore context->Rsp

	mov	%rsi,168($context)	# restore context->Rsi

	mov	%rdi,176($context)	# restore context->Rdi



	mov	40($disp),%rdi		# disp->ContextRecord

	mov	$context,%rsi		# context

	mov	\$154,%ecx		# sizeof(CONTEXT)

	.long	0xa548f3fc		# cld; rep movsq



	mov	$disp,%rsi

	xor	%ecx,%ecx		# arg1, UNW_FLAG_NHANDLER

	mov	8(%rsi),%rdx		# arg2, disp->ImageBase

	mov	0(%rsi),%r8		# arg3, disp->ControlPc

	mov	16(%rsi),%r9		# arg4, disp->FunctionEntry

	mov	40(%rsi),%r10		# disp->ContextRecord

	lea	56(%rsi),%r11		# &disp->HandlerData

	lea	24(%rsi),%r12		# &disp->EstablisherFrame

	mov	%r10,32(%rsp)		# arg5

	mov	%r11,40(%rsp)		# arg6

	mov	%r12,48(%rsp)		# arg7

	mov	%rcx,56(%rsp)		# arg8, (NULL)

	call	*__imp_RtlVirtualUnwind(%rip)



	mov	\$1,%eax		# ExceptionContinueSearch

	add	\$64,%rsp

	popfq

	pop	%r15

	pop	%r14

	pop	%r13

	pop	%r12

	pop	%rbp

	pop	%rbx

	pop	%rdi

	pop	%rsi

	ret

.size	avx_handler,.-avx_handler



.section	.pdata

.align	4

	.rva	.LSEH_begin_poly1305_init_x86_64

	.rva	.LSEH_end_poly1305_init_x86_64

	.rva	.LSEH_info_poly1305_init_x86_64



	.rva	.LSEH_begin_poly1305_blocks_x86_64

	.rva	.LSEH_end_poly1305_blocks_x86_64

	.rva	.LSEH_info_poly1305_blocks_x86_64



	.rva	.LSEH_begin_poly1305_emit_x86_64

	.rva	.LSEH_end_poly1305_emit_x86_64

	.rva	.LSEH_info_poly1305_emit_x86_64

___

<<___ if ($avx);

$code.=<<___ if ($avx>1);

	.rva	.LSEH_begin_poly1305_blocks_avx2

	.rva	.Lbase2_64_avx2

	.rva	.LSEH_info_poly1305_blocks_avx2_1



	.rva	.Lbase2_64_avx2

	.rva	.Leven_avx2

	.rva	.LSEH_info_poly1305_blocks_avx2_2



	.rva	.Leven_avx2

	.rva	.LSEH_end_poly1305_blocks_avx2

	.rva	.LSEH_info_poly1305_blocks_avx2_3

___

<<___ if ($avx>2);

$code.=<<___;

.section	.xdata

.align	8

.LSEH_info_poly1305_init_x86_64:

	.byte	9,0,0,0

	.rva	se_handler

	.rva	.LSEH_begin_poly1305_init_x86_64,.LSEH_begin_poly1305_init_x86_64



.LSEH_info_poly1305_blocks_x86_64:

	.byte	9,0,0,0

	.rva	se_handler

	.rva	.Lblocks_body,.Lblocks_epilogue



.LSEH_info_poly1305_emit_x86_64:

	.byte	9,0,0,0

	.rva	se_handler

	.rva	.LSEH_begin_poly1305_emit_x86_64,.LSEH_begin_poly1305_emit_x86_64

___

<<___ if ($avx);

 HandlerData[]

 HandlerData[]

 HandlerData[]

$code.=<<___ if ($avx>1);

.LSEH_info_poly1305_blocks_avx2_1:

	.byte	9,0,0,0

	.rva	se_handler

	.rva	.Lblocks_avx2_body,.Lblocks_avx2_epilogue	# HandlerData[]



.LSEH_info_poly1305_blocks_avx2_2:

	.byte	9,0,0,0

	.rva	se_handler

	.rva	.Lbase2_64_avx2_body,.Lbase2_64_avx2_epilogue	# HandlerData[]



.LSEH_info_poly1305_blocks_avx2_3:

	.byte	9,0,0,0

	.rva	avx_handler

	.rva	.Ldo_avx2_body,.Ldo_avx2_epilogue		# HandlerData[]

___

<<___ if ($avx>2);

 HandlerData[]

!/);

/\/\// and !/^$/);

d/%e$1/g;

d/%r$1d/g;

%[yz]/%x/g or s/%y%[yz]/%z/g;

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0

 This code is taken from the OpenSSL project but the author (Andy Polyakov)

 has relicensed it under the GPLv2. Therefore this program is free software;

 you can redistribute it and/or modify it under the terms of the GNU General

 Public License version 2 as published by the Free Software Foundation.



 The original headers, including the original license headers, are

 included below for completeness.

 ====================================================================


 Written by Andy Polyakov <appro@openssl.org> for the OpenSSL

 project. The module is, however, dual licensed under OpenSSL and

 CRYPTOGAMS licenses depending on where you obtain it. For further

 details see https://www.openssl.org/~appro/cryptogams/.

 ====================================================================


 SHA512 block procedure for ARMv4. September 2007.

 This code is ~4.5 (four and a half) times faster than code generated

 by gcc 3.4 and it spends ~72 clock cycles per byte [on single-issue

 Xscale PXA250 core].



 July 2010.



 Rescheduling for dual-issue pipeline resulted in 6% improvement on

 Cortex A8 core and ~40 cycles per processed byte.

 February 2011.



 Profiler-assisted and platform-specific optimization resulted in 7%

 improvement on Coxtex A8 core and ~38 cycles per byte.

 March 2011.



 Add NEON implementation. On Cortex A8 it was measured to process

 one byte in 23.3 cycles or ~60% faster than integer-only code.

 August 2012.



 Improve NEON performance by 12% on Snapdragon S4. In absolute

 terms it's 22.6 cycles per byte, which is disappointing result.

 Technical writers asserted that 3-way S4 pipeline can sustain

 multiple NEON instructions per cycle, but dual NEON issue could

 not be observed, see https://www.openssl.org/~appro/Snapdragon-S4.html

 for further details. On side note Cortex-A15 processes one byte in

 16 cycles.

# Byte order [in]dependence. =========================================

#

# Originally caller was expected to maintain specific *dword* order in

# h[0-7], namely with most significant dword at *lower* address, which

# was reflected in below two parameters as 0 and 4. Now caller is

# expected to maintain native byte order for whole 64-bit values.

"HI";

$lo="LO";

# ====================================================================



shift) && ($output!~/^\w[\w\-]*\.\w+$/)) {}

$ctx="r0";	# parameter block

"r1";

$len="r2";



"r3";

$Thi="r4";

"r5";

$Ahi="r6";

"r7";

$Ehi="r8";

"r9";

$t1="r10";

"r11";

$t3="r12";

############	r13 is stack pointer

"r14";

$Aoff=8*0;

8*1;

$Coff=8*2;

8*3;

$Eoff=8*4;

8*5;

$Goff=8*6;

8*7;

$Xoff=8*8;



sub BODY_00_15() {

 shift;

$code.=<<___;

	@ Sigma1(x)	(ROTR((x),14) ^ ROTR((x),18)  ^ ROTR((x),41))

	@ LO		lo>>14^hi<<18 ^ lo>>18^hi<<14 ^ hi>>9^lo<<23

	@ HI		hi>>14^lo<<18 ^ hi>>18^lo<<14 ^ lo>>9^hi<<23

	mov	$t0,$Elo,lsr#14

	str	$Tlo,[sp,#$Xoff+0]

	mov	$t1,$Ehi,lsr#14

	str	$Thi,[sp,#$Xoff+4]

	eor	$t0,$t0,$Ehi,lsl#18

	ldr	$t2,[sp,#$Hoff+0]	@ h.lo

	eor	$t1,$t1,$Elo,lsl#18

	ldr	$t3,[sp,#$Hoff+4]	@ h.hi

	eor	$t0,$t0,$Elo,lsr#18

	eor	$t1,$t1,$Ehi,lsr#18

	eor	$t0,$t0,$Ehi,lsl#14

	eor	$t1,$t1,$Elo,lsl#14

	eor	$t0,$t0,$Ehi,lsr#9

	eor	$t1,$t1,$Elo,lsr#9

	eor	$t0,$t0,$Elo,lsl#23

	eor	$t1,$t1,$Ehi,lsl#23	@ Sigma1(e)

	adds	$Tlo,$Tlo,$t0

	ldr	$t0,[sp,#$Foff+0]	@ f.lo

 Sigma1(e)

$Foff+4]	@ f.hi

$Goff+0]	@ g.lo

	adc	$Thi,$Thi,$t3		@ T += h

	ldr	$t3,[sp,#$Goff+4]	@ g.hi



	eor	$t0,$t0,$t2

	str	$Elo,[sp,#$Eoff+0]

	eor	$t1,$t1,$t3

	str	$Ehi,[sp,#$Eoff+4]

	and	$t0,$t0,$Elo

	str	$Alo,[sp,#$Aoff+0]

	and	$t1,$t1,$Ehi

	str	$Ahi,[sp,#$Aoff+4]

	eor	$t0,$t0,$t2

	ldr	$t2,[$Ktbl,#$lo]	@ K[i].lo

	eor	$t1,$t1,$t3		@ Ch(e,f,g)

	ldr	$t3,[$Ktbl,#$hi]	@ K[i].hi



	adds	$Tlo,$Tlo,$t0

	ldr	$Elo,[sp,#$Doff+0]	@ d.lo

 Ch(e,f,g)

$Doff+4]	@ d.hi

0xff

	adc	$Thi,$Thi,$t3		@ T += K[i]

	adds	$Elo,$Elo,$Tlo

	ldr	$t2,[sp,#$Boff+0]	@ b.lo

 T

$magic

$Coff+0]	@ c.lo

#if __ARM_ARCH__>=7

	it	eq			@ Thumb2 thing, sanity check in ARM

#endif

	orreq	$Ktbl,$Ktbl,#1

	@ Sigma0(x)	(ROTR((x),28) ^ ROTR((x),34) ^ ROTR((x),39))

	@ LO		lo>>28^hi<<4  ^ hi>>2^lo<<30 ^ hi>>7^lo<<25

	@ HI		hi>>28^lo<<4  ^ lo>>2^hi<<30 ^ lo>>7^hi<<25

	mov	$t0,$Alo,lsr#28

	mov	$t1,$Ahi,lsr#28

	eor	$t0,$t0,$Ahi,lsl#4

	eor	$t1,$t1,$Alo,lsl#4

	eor	$t0,$t0,$Ahi,lsr#2

	eor	$t1,$t1,$Alo,lsr#2

	eor	$t0,$t0,$Alo,lsl#30

	eor	$t1,$t1,$Ahi,lsl#30

	eor	$t0,$t0,$Ahi,lsr#7

	eor	$t1,$t1,$Alo,lsr#7

	eor	$t0,$t0,$Alo,lsl#25

	eor	$t1,$t1,$Ahi,lsl#25	@ Sigma0(a)

	adds	$Tlo,$Tlo,$t0

	and	$t0,$Alo,$t2

 Sigma0(a)

$Boff+4]	@ b.hi

$Coff+4]	@ c.hi

8

	adc	$Ahi,$Ahi,$Thi		@ h += T

	tst	$Ktbl,#1

	add	$Ktbl,$Ktbl,#8

___

}

<<___;

ifndef __KERNEL__

 include "arm_arch.h"

 define VFP_ABI_PUSH	vstmdb	sp!,{d8-d15}

 define VFP_ABI_POP	vldmia	sp!,{d8-d15}

else

 define __ARM_ARCH__ __LINUX_ARM_ARCH__

 define __ARM_MAX_ARCH__ 7

 define VFP_ABI_PUSH

 define VFP_ABI_POP

endif

ifdef __ARMEL__

 define LO 0

 define HI 4

 define WORD64(hi0,lo0,hi1,lo1)	.word	lo0,hi0, lo1,hi1

else

 define HI 0

 define LO 4

 define WORD64(hi0,lo0,hi1,lo1)	.word	hi0,lo0, hi1,lo1

endif

if __ARM_ARCH__<7

else

 ifdef __thumb2__

 else

 endif

endif

#if __ARM_MAX_ARCH__>=7 && !defined(__KERNEL__)

.LOPENSSL_armcap:

.word	OPENSSL_armcap_P-sha512_block_data_order

.skip	32-4

#else

.skip	32

#endif



.global	sha512_block_data_order

.type	sha512_block_data_order,%function

sha512_block_data_order:

.Lsha512_block_data_order:

#if __ARM_ARCH__<7

	sub	r3,pc,#8		@ sha512_block_data_order

#else

	adr	r3,.Lsha512_block_data_order

#endif

if __ARM_MAX_ARCH__>=7 && !defined(__KERNEL__)

1

endif

7	@ len to point at the end of inp

672		@ K512

9*8

$Eoff+$lo]

$Eoff+$hi]

$Goff+$lo]

$Goff+$hi]

$Hoff+$lo]

$Hoff+$hi]

$Goff+0]

$Goff+4]

$Hoff+0]

$Hoff+4]

$Aoff+$lo]

$Aoff+$hi]

$Boff+$lo]

$Boff+$hi]

$Coff+$lo]

$Coff+$hi]

$Doff+$lo]

$Doff+$hi]

$Boff+0]

$Boff+4]

$Coff+0]

$Coff+4]

$Doff+0]

$Doff+4]

$Foff+$lo]

$Foff+$hi]

$Foff+0]

$Foff+4]

if __ARM_ARCH__<7

7]

6]

5]

4]

3]

2]

8

1]

16

8

24

8

16

24

else

4]

8

ifdef __ARMEL__

endif

endif

$code.=<<___;

	tst	$Ktbl,#1

	beq	.L00_15

	ldr	$t0,[sp,#`$Xoff+8*(16-1)`+0]

	ldr	$t1,[sp,#`$Xoff+8*(16-1)`+4]

	bic	$Ktbl,$Ktbl,#1

.L16_79:

	@ sigma0(x)	(ROTR((x),1)  ^ ROTR((x),8)  ^ ((x)>>7))

	@ LO		lo>>1^hi<<31  ^ lo>>8^hi<<24 ^ lo>>7^hi<<25

	@ HI		hi>>1^lo<<31  ^ hi>>8^lo<<24 ^ hi>>7

	mov	$Tlo,$t0,lsr#1

	ldr	$t2,[sp,#`$Xoff+8*(16-14)`+0]

	mov	$Thi,$t1,lsr#1

	ldr	$t3,[sp,#`$Xoff+8*(16-14)`+4]

	eor	$Tlo,$Tlo,$t1,lsl#31

	eor	$Thi,$Thi,$t0,lsl#31

	eor	$Tlo,$Tlo,$t0,lsr#8

	eor	$Thi,$Thi,$t1,lsr#8

	eor	$Tlo,$Tlo,$t1,lsl#24

	eor	$Thi,$Thi,$t0,lsl#24

	eor	$Tlo,$Tlo,$t0,lsr#7

	eor	$Thi,$Thi,$t1,lsr#7

	eor	$Tlo,$Tlo,$t1,lsl#25



	@ sigma1(x)	(ROTR((x),19) ^ ROTR((x),61) ^ ((x)>>6))

	@ LO		lo>>19^hi<<13 ^ hi>>29^lo<<3 ^ lo>>6^hi<<26

	@ HI		hi>>19^lo<<13 ^ lo>>29^hi<<3 ^ hi>>6

	mov	$t0,$t2,lsr#19

	mov	$t1,$t3,lsr#19

	eor	$t0,$t0,$t3,lsl#13

	eor	$t1,$t1,$t2,lsl#13

	eor	$t0,$t0,$t3,lsr#29

	eor	$t1,$t1,$t2,lsr#29

	eor	$t0,$t0,$t2,lsl#3

	eor	$t1,$t1,$t3,lsl#3

	eor	$t0,$t0,$t2,lsr#6

	eor	$t1,$t1,$t3,lsr#6

	ldr	$t2,[sp,#`$Xoff+8*(16-9)`+0]

	eor	$t0,$t0,$t3,lsl#26



	ldr	$t3,[sp,#`$Xoff+8*(16-9)`+4]

	adds	$Tlo,$Tlo,$t0

	ldr	$t0,[sp,#`$Xoff+8*16`+0]

	adc	$Thi,$Thi,$t1



	ldr	$t1,[sp,#`$Xoff+8*16`+4]

	adds	$Tlo,$Tlo,$t2

	adc	$Thi,$Thi,$t3

	adds	$Tlo,$Tlo,$t0

	adc	$Thi,$Thi,$t1

___

	&BODY_00_15(0x17);

<<___;

#if __ARM_ARCH__>=7

	ittt	eq			@ Thumb2 thing, sanity check in ARM

#endif

	ldreq	$t0,[sp,#`$Xoff+8*(16-1)`+0]

	ldreq	$t1,[sp,#`$Xoff+8*(16-1)`+4]

	beq	.L16_79

	bic	$Ktbl,$Ktbl,#1



	ldr	$Tlo,[sp,#$Boff+0]

	ldr	$Thi,[sp,#$Boff+4]

	ldr	$t0, [$ctx,#$Aoff+$lo]

	ldr	$t1, [$ctx,#$Aoff+$hi]

	ldr	$t2, [$ctx,#$Boff+$lo]

	ldr	$t3, [$ctx,#$Boff+$hi]

	adds	$t0,$Alo,$t0

	str	$t0, [$ctx,#$Aoff+$lo]

	adc	$t1,$Ahi,$t1

	str	$t1, [$ctx,#$Aoff+$hi]

	adds	$t2,$Tlo,$t2

	str	$t2, [$ctx,#$Boff+$lo]

	adc	$t3,$Thi,$t3

	str	$t3, [$ctx,#$Boff+$hi]



	ldr	$Alo,[sp,#$Coff+0]

	ldr	$Ahi,[sp,#$Coff+4]

	ldr	$Tlo,[sp,#$Doff+0]

	ldr	$Thi,[sp,#$Doff+4]

	ldr	$t0, [$ctx,#$Coff+$lo]

	ldr	$t1, [$ctx,#$Coff+$hi]

	ldr	$t2, [$ctx,#$Doff+$lo]

	ldr	$t3, [$ctx,#$Doff+$hi]

	adds	$t0,$Alo,$t0

	str	$t0, [$ctx,#$Coff+$lo]

	adc	$t1,$Ahi,$t1

	str	$t1, [$ctx,#$Coff+$hi]

	adds	$t2,$Tlo,$t2

	str	$t2, [$ctx,#$Doff+$lo]

	adc	$t3,$Thi,$t3

	str	$t3, [$ctx,#$Doff+$hi]



	ldr	$Tlo,[sp,#$Foff+0]

	ldr	$Thi,[sp,#$Foff+4]

	ldr	$t0, [$ctx,#$Eoff+$lo]

	ldr	$t1, [$ctx,#$Eoff+$hi]

	ldr	$t2, [$ctx,#$Foff+$lo]

	ldr	$t3, [$ctx,#$Foff+$hi]

	adds	$Elo,$Elo,$t0

	str	$Elo,[$ctx,#$Eoff+$lo]

	adc	$Ehi,$Ehi,$t1

	str	$Ehi,[$ctx,#$Eoff+$hi]

	adds	$t2,$Tlo,$t2

	str	$t2, [$ctx,#$Foff+$lo]

	adc	$t3,$Thi,$t3

	str	$t3, [$ctx,#$Foff+$hi]



	ldr	$Alo,[sp,#$Goff+0]

	ldr	$Ahi,[sp,#$Goff+4]

	ldr	$Tlo,[sp,#$Hoff+0]

	ldr	$Thi,[sp,#$Hoff+4]

	ldr	$t0, [$ctx,#$Goff+$lo]

	ldr	$t1, [$ctx,#$Goff+$hi]

	ldr	$t2, [$ctx,#$Hoff+$lo]

	ldr	$t3, [$ctx,#$Hoff+$hi]

	adds	$t0,$Alo,$t0

	str	$t0, [$ctx,#$Goff+$lo]

	adc	$t1,$Ahi,$t1

	str	$t1, [$ctx,#$Goff+$hi]

	adds	$t2,$Tlo,$t2

	str	$t2, [$ctx,#$Hoff+$lo]

	adc	$t3,$Thi,$t3

	str	$t3, [$ctx,#$Hoff+$hi]



	add	sp,sp,#640

	sub	$Ktbl,$Ktbl,#640



	teq	$inp,$len

	bne	.Loop



	add	sp,sp,#8*9		@ destroy frame

if __ARM_ARCH__>=5

else

1

endif

my @Sigma0=(28,34,39);

(14,18,41);

my @sigma0=(1, 8, 7);

(19,61,6);

my $Ktbl="r3";

 volatile register known as ip, intra-procedure-call scratch

my @X=map("d$_",(0..15));

my @V=($A,$B,$C,$D,$E,$F,$G,$H)=map("d$_",(16..23));



sub NEON_00_15() {

shift;

my ($a,$b,$c,$d,$e,$f,$g,$h)=@_;

 temps

$code.=<<___ if ($i<16 || $i&1);

	vshr.u64	$t0,$e,#@Sigma1[0]	@ $i

#if $i<16

	vld1.64		{@X[$i%16]},[$inp]!	@ handles unaligned

#endif

	vshr.u64	$t1,$e,#@Sigma1[1]

#if $i>0

Maj from the past

endif

@Sigma1[2]

$code.=<<___;

	vld1.64		{$K},[$Ktbl,:64]!	@ K[i++]

	vsli.64		$t0,$e,#`64-@Sigma1[0]`

	vsli.64		$t1,$e,#`64-@Sigma1[1]`

	vmov		$Ch,$e

	vsli.64		$t2,$e,#`64-@Sigma1[2]`

#if $i<16 && defined(__ARMEL__)

	vrev64.8	@X[$i],@X[$i]

#endif

	veor		$t1,$t0

	vbsl		$Ch,$f,$g		@ Ch(e,f,g)

	vshr.u64	$t0,$a,#@Sigma0[0]

	veor		$t2,$t1			@ Sigma1(e)

	vadd.i64	$T1,$Ch,$h

	vshr.u64	$t1,$a,#@Sigma0[1]

	vsli.64		$t0,$a,#`64-@Sigma0[0]`

	vadd.i64	$T1,$t2

	vshr.u64	$t2,$a,#@Sigma0[2]

	vadd.i64	$K,@X[$i%16]

	vsli.64		$t1,$a,#`64-@Sigma0[1]`

	veor		$Maj,$a,$b

	vsli.64		$t2,$a,#`64-@Sigma0[2]`

	veor		$h,$t0,$t1

	vadd.i64	$T1,$K

	vbsl		$Maj,$c,$b		@ Maj(a,b,c)

	veor		$h,$t2			@ Sigma0(a)

	vadd.i64	$d,$T1

	vadd.i64	$Maj,$T1

	@ vadd.i64	$h,$Maj

___

}



sub NEON_16_79() {

shift;

 2x-vectorized, therefore runs every 2nd round

my @X=map("q$_",(0..7));			# view @X as 128-bit vector

 temps

my ($d0,$d1,$d2) = map("d$_",(24..26));		# temps from NEON_00_15

 $e from NEON_00_15

$i /= 2;

<<___;

@sigma1[0]

@sigma1[1]

	 vadd.i64	@_[0],d30			@ h+=Maj from the past

	vshr.u64	$s1,@X[($i+7)%8],#@sigma1[2]

	vsli.64		$t0,@X[($i+7)%8],#`64-@sigma1[0]`

	vext.8		$s0,@X[$i%8],@X[($i+1)%8],#8	@ X[i+1]

	vsli.64		$t1,@X[($i+7)%8],#`64-@sigma1[1]`

	veor		$s1,$t0

	vshr.u64	$t0,$s0,#@sigma0[0]

	veor		$s1,$t1				@ sigma1(X[i+14])

	vshr.u64	$t1,$s0,#@sigma0[1]

	vadd.i64	@X[$i%8],$s1

	vshr.u64	$s1,$s0,#@sigma0[2]

	vsli.64		$t0,$s0,#`64-@sigma0[0]`

	vsli.64		$t1,$s0,#`64-@sigma0[1]`

	vext.8		$s0,@X[($i+4)%8],@X[($i+5)%8],#8	@ X[i+9]

	veor		$s1,$t0

	vshr.u64	$d0,$e,#@Sigma1[0]		@ from NEON_00_15

	vadd.i64	@X[$i%8],$s0

	vshr.u64	$d1,$e,#@Sigma1[1]		@ from NEON_00_15

	veor		$s1,$t1				@ sigma0(X[i+1])

	vshr.u64	$d2,$e,#@Sigma1[2]		@ from NEON_00_15

	vadd.i64	@X[$i%8],$s1

___

	&NEON_00_15(2*$i,@_);

}



<<___;

#if __ARM_MAX_ARCH__>=7

.arch	armv7-a

.fpu	neon



.global	sha512_block_data_order_neon

.type	sha512_block_data_order_neon,%function

.align	4

sha512_block_data_order_neon:

.LNEON:

	dmb				@ errata #451034 on early Cortex A8

	add	$len,$inp,$len,lsl#7	@ len to point at the end of inp

	VFP_ABI_PUSH

	adr	$Ktbl,.Lsha512_block_data_order

	sub	$Ktbl,$Ktbl,.Lsha512_block_data_order-K512

	vldmia	$ctx,{$A-$H}		@ load context

.Loop_neon:

___

0;$i<16;$i++)	{ &NEON_00_15($i,@V); unshift(@V,pop(@V)); }

$code.=<<___;

	mov		$cnt,#4

.L16_79_neon:

	subs		$cnt,#1

___

for(;$i<32;$i++)	{ &NEON_16_79($i,@V); unshift(@V,pop(@V)); }

<<___;

	 vadd.i64	$A,d30		@ h+=Maj from the past

	vldmia		$ctx,{d24-d31}	@ load context to temp

	vadd.i64	q8,q12		@ vectorized accumulate

	vadd.i64	q9,q13

	vadd.i64	q10,q14

	vadd.i64	q11,q15

	vstmia		$ctx,{$A-$H}	@ save context

	teq		$inp,$len

	sub		$Ktbl,#640	@ rewind K512

	bne		.Loop_neon



	VFP_ABI_POP

	ret				@ bx lr

.size	sha512_block_data_order_neon,.-sha512_block_data_order_neon

#endif

___

}

<<___;

#if __ARM_MAX_ARCH__>=7 && !defined(__KERNEL__)

.comm	OPENSSL_armcap_P,4,4

#endif

___



~ s/\`([^\`]*)\`/eval $1/gem;

 make it possible to compile with -march=armv4
armv4

$code =~ s/\bret\b/bx	lr/gm;



open SELF,$0;

while(<SELF>) {

	next if (/^#!/);

	last if (!s/^#/@/ and !/^$/);

	print;

}

close SELF;



print $code;

close STDOUT; # enforce flush

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-1.0+ OR BSD-3-Clause



 ====================================================================


 Written by Andy Polyakov, @dot-asm, initially for the OpenSSL

 project.

 ====================================================================




			IALU(*)/gcc-4.4		NEON



 ARM11xx(ARMv6)	7.78/+100%		-

 Cortex-A5		6.35/+130%		3.00

 Cortex-A8		6.25/+115%		2.36

 Cortex-A9		5.10/+95%		2.55

 Cortex-A15		3.85/+85%		1.25(**)

 Snapdragon S4		5.70/+100%		1.48(**)



# (*)	this is for -march=armv6, i.e. with bunch of ldrb loading data;

# (**)	these are trade-off results, they can be improved by ~8% but at

#	the cost of 15/12% regression on Cortex-A5/A7, it's even possible

#	to improve Cortex-A9 result, but then A5/A7 loose more than 20%;



 shift;

~/\w[\w\-]*\.\w+$/) { $output
else { while (($output=shift) && ($output!~/\w[\w\-]*\.\w+$/)) {} }



if ($flavour && $flavour ne "void") {

    $0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;

"${dir}arm-xlate.pl" and -f $xlate ) or

    ( $xlate="${dir}../../perlasm/arm-xlate.pl" and -f $xlate) or

    die "can't locate arm-xlate.pl";



    open STDOUT,"| \"$^X\" $xlate $flavour $output";

} else {

    open STDOUT,">$output";

}



map("r$_",(0..3));

$code.=<<___;

#ifndef	__KERNEL__

# include "arm_arch.h"

#else

# define __ARM_ARCH__ __LINUX_ARM_ARCH__

# define __ARM_MAX_ARCH__ __LINUX_ARM_ARCH__

# define poly1305_init   poly1305_init_arm

# define poly1305_blocks poly1305_blocks_arm

# define poly1305_emit   poly1305_emit_arm

.globl	poly1305_blocks_neon

#endif



#if defined(__thumb2__)

.syntax	unified

.thumb

#else

.code	32

#endif



.text



.globl	poly1305_emit

.globl	poly1305_blocks

.globl	poly1305_init

.type	poly1305_init,%function

.align	5

poly1305_init:

.Lpoly1305_init:

	stmdb	sp!,{r4-r11}



	eor	r3,r3,r3

	cmp	$inp,#0

	str	r3,[$ctx,#0]		@ zero hash value

	str	r3,[$ctx,#4]

	str	r3,[$ctx,#8]

	str	r3,[$ctx,#12]

	str	r3,[$ctx,#16]

	str	r3,[$ctx,#36]		@ clear is_base2_26

	add	$ctx,$ctx,#20



#ifdef	__thumb2__

	it	eq

#endif

	moveq	r0,#0

	beq	.Lno_key



if	__ARM_MAX_ARCH__>=7

-1

28]		@ impossible key power value

 ifndef __KERNEL__

 endif

endif

0]

0x0fffffff

1]

-4		@ 0x0ffffffc

2]

3]

8

4]

16

5]

24

6]

#if	__ARM_MAX_ARCH__>=7 && !defined(__KERNEL__)

# if !defined(_WIN32)

	ldr	r12,[r11,r12]		@ OPENSSL_armcap_P

# endif

# if defined(__APPLE__) || defined(_WIN32)

	ldr	r12,[r12]

# endif

#endif

	ldrb	r8,[$inp,#7]

	orr	r5,r5,r6,lsl#8

	ldrb	r6,[$inp,#8]

	orr	r5,r5,r7,lsl#16

	ldrb	r7,[$inp,#9]

	orr	r5,r5,r8,lsl#24

	ldrb	r8,[$inp,#10]

	and	r5,r5,r3



if	__ARM_MAX_ARCH__>=7 && !defined(__KERNEL__)

ARMV7_NEON		@ check for NEON

 ifdef	__thumb2__

1		@ thumb-ify addresses

1

 else

(.Lpoly1305_emit-.Lpoly1305_init)

(.Lpoly1305_blocks-.Lpoly1305_init)

(.Lpoly1305_blocks_neon-.Lpoly1305_init)

 endif

endif

11]

8

12]

16

13]

24

14]

15]

8

0]

16

4]

24

8]

12]

#if	__ARM_MAX_ARCH__>=7 && !defined(__KERNEL__)

	stmia	r2,{r11,r12}		@ fill functions table

	mov	r0,#1

#else

	mov	r0,#0

#endif

.Lno_key:

	ldmia	sp!,{r4-r11}

if	__ARM_ARCH__>=5

else

1

endif

my ($h0,$h1,$h2,$h3,$h4,$r0,$r1,$r2,$r3)=map("r$_",(4..12));

($r1,$r2,$r3);

$code.=<<___;

.type	poly1305_blocks,%function

.align	5

poly1305_blocks:

.Lpoly1305_blocks:

	stmdb	sp!,{r3-r11,lr}



	ands	$len,$len,#-16

	beq	.Lno_data



	add	$len,$len,$inp		@ end pointer

	sub	sp,sp,#32



#if __ARM_ARCH__<7

	ldmia	$ctx,{$h0-$r3}		@ load context

	add	$ctx,$ctx,#20

	str	$len,[sp,#16]		@ offload stuff

	str	$ctx,[sp,#12]

#else

	ldr	lr,[$ctx,#36]		@ is_base2_26

	ldmia	$ctx!,{$h0-$h4}		@ load hash value

	str	$len,[sp,#16]		@ offload stuff

	str	$ctx,[sp,#12]



	adds	$r0,$h0,$h1,lsl#26	@ base 2^26 -> base 2^32

	mov	$r1,$h1,lsr#6

	adcs	$r1,$r1,$h2,lsl#20

	mov	$r2,$h2,lsr#12

	adcs	$r2,$r2,$h3,lsl#14

	mov	$r3,$h3,lsr#18

	adcs	$r3,$r3,$h4,lsl#8

	mov	$len,#0

	teq	lr,#0

	str	$len,[$ctx,#16]		@ clear is_base2_26

	adc	$len,$len,$h4,lsr#24



	itttt	ne

	movne	$h0,$r0			@ choose between radixes

	movne	$h1,$r1

	movne	$h2,$r2

	movne	$h3,$r3

	ldmia	$ctx,{$r0-$r3}		@ load key

	it	ne

	movne	$h4,$len

#endif



	mov	lr,$inp

	cmp	$padbit,#0

	str	$r1,[sp,#20]

	str	$r2,[sp,#24]

	str	$r3,[sp,#28]

	b	.Loop



.align	4

.Loop:

#if __ARM_ARCH__<7

	ldrb	r0,[lr],#16		@ load input

# ifdef	__thumb2__

	it	hi

# endif

	addhi	$h4,$h4,#1		@ 1<<128

	ldrb	r1,[lr,#-15]

	ldrb	r2,[lr,#-14]

	ldrb	r3,[lr,#-13]

	orr	r1,r0,r1,lsl#8

	ldrb	r0,[lr,#-12]

	orr	r2,r1,r2,lsl#16

	ldrb	r1,[lr,#-11]

	orr	r3,r2,r3,lsl#24

	ldrb	r2,[lr,#-10]

	adds	$h0,$h0,r3		@ accumulate input



	ldrb	r3,[lr,#-9]

	orr	r1,r0,r1,lsl#8

	ldrb	r0,[lr,#-8]

	orr	r2,r1,r2,lsl#16

	ldrb	r1,[lr,#-7]

	orr	r3,r2,r3,lsl#24

	ldrb	r2,[lr,#-6]

	adcs	$h1,$h1,r3



	ldrb	r3,[lr,#-5]

	orr	r1,r0,r1,lsl#8

	ldrb	r0,[lr,#-4]

	orr	r2,r1,r2,lsl#16

	ldrb	r1,[lr,#-3]

	orr	r3,r2,r3,lsl#24

	ldrb	r2,[lr,#-2]

	adcs	$h2,$h2,r3



	ldrb	r3,[lr,#-1]

	orr	r1,r0,r1,lsl#8

	str	lr,[sp,#8]		@ offload input pointer

	orr	r2,r1,r2,lsl#16

	add	$s1,$r1,$r1,lsr#2

	orr	r3,r2,r3,lsl#24

#else

	ldr	r0,[lr],#16		@ load input

	it	hi

	addhi	$h4,$h4,#1		@ padbit

	ldr	r1,[lr,#-12]

	ldr	r2,[lr,#-8]

	ldr	r3,[lr,#-4]

# ifdef	__ARMEB__

	rev	r0,r0

	rev	r1,r1

	rev	r2,r2

	rev	r3,r3

# endif

	adds	$h0,$h0,r0		@ accumulate input

	str	lr,[sp,#8]		@ offload input pointer

	adcs	$h1,$h1,r1

	add	$s1,$r1,$r1,lsr#2

	adcs	$h2,$h2,r2

#endif

	add	$s2,$r2,$r2,lsr#2

	adcs	$h3,$h3,r3

	add	$s3,$r3,$r3,lsr#2



	umull	r2,r3,$h1,$r0

	 adc	$h4,$h4,#0

	umull	r0,r1,$h0,$r0

	umlal	r2,r3,$h4,$s1

	umlal	r0,r1,$h3,$s1

	ldr	$r1,[sp,#20]		@ reload $r1

	umlal	r2,r3,$h2,$s3

	umlal	r0,r1,$h1,$s3

	umlal	r2,r3,$h3,$s2

	umlal	r0,r1,$h2,$s2

	umlal	r2,r3,$h0,$r1

	str	r0,[sp,#0]		@ future $h0

	 mul	r0,$s2,$h4

	ldr	$r2,[sp,#24]		@ reload $r2

d0>>32

0		@ future $h2

4]		@ future $h1

28]		@ reload $r3

0]

4]

	adds	$h2,lr,r0		@ d2+=d1>>32

	ldr	lr,[sp,#8]		@ reload input pointer

	adc	r1,r1,#0

d2>>32

16]		@ reload end pointer

0

	add	$h4,$h4,r3		@ h4+=d3>>32



	and	r1,$h4,#-4

	and	$h4,$h4,#3

2		@ *=5

0

0

0

0

12]

32

#if	__ARM_ARCH__>=5

	ldmia	sp!,{r3-r11,pc}

#else

	ldmia	sp!,{r3-r11,lr}

	tst	lr,#1

	moveq	pc,lr			@ be binary compatible with V4, yet

	bx	lr			@ interoperable with Thumb ISA:-)

#endif

.size	poly1305_blocks,.-poly1305_blocks

___

}

{

map("r$_",(0..2));

my ($h0,$h1,$h2,$h3,$h4,$g0,$g1,$g2,$g3)=map("r$_",(3..11));

$ctx;

$code.=<<___;

.type	poly1305_emit,%function

.align	5

poly1305_emit:

.Lpoly1305_emit:

	stmdb	sp!,{r4-r11}



	ldmia	$ctx,{$h0-$h4}



if __ARM_ARCH__>=7

36]		@ is_base2_26

26	@ base 2^26 -> base 2^32

6

20

12

14

18

8

0

24

endif

5		@ compare to modulus

0

0

0

0

4			@ did it carry/borrow?

ifdef	__thumb2__

endif

0]

ifdef	__thumb2__

endif

4]

ifdef	__thumb2__

endif

8]

ifdef	__thumb2__

endif

12]

#if __ARM_ARCH__>=7

# ifdef __ARMEB__

	rev	$h0,$h0

	rev	$h1,$h1

	rev	$h2,$h2

	rev	$h3,$h3

# endif

	str	$h0,[$mac,#0]

	str	$h1,[$mac,#4]

	str	$h2,[$mac,#8]

	str	$h3,[$mac,#12]

#else

	strb	$h0,[$mac,#0]

	mov	$h0,$h0,lsr#8

	strb	$h1,[$mac,#4]

	mov	$h1,$h1,lsr#8

	strb	$h2,[$mac,#8]

	mov	$h2,$h2,lsr#8

	strb	$h3,[$mac,#12]

	mov	$h3,$h3,lsr#8



	strb	$h0,[$mac,#1]

	mov	$h0,$h0,lsr#8

	strb	$h1,[$mac,#5]

	mov	$h1,$h1,lsr#8

	strb	$h2,[$mac,#9]

	mov	$h2,$h2,lsr#8

	strb	$h3,[$mac,#13]

	mov	$h3,$h3,lsr#8



	strb	$h0,[$mac,#2]

	mov	$h0,$h0,lsr#8

	strb	$h1,[$mac,#6]

	mov	$h1,$h1,lsr#8

	strb	$h2,[$mac,#10]

	mov	$h2,$h2,lsr#8

	strb	$h3,[$mac,#14]

	mov	$h3,$h3,lsr#8



	strb	$h0,[$mac,#3]

	strb	$h1,[$mac,#7]

	strb	$h2,[$mac,#11]

	strb	$h3,[$mac,#15]

#endif

	ldmia	sp!,{r4-r11}

if	__ARM_ARCH__>=5

else

1

endif

my ($R0,$R1,$S1,$R2,$S2,$R3,$S3,$R4,$S4) = map("d$_",(0..9));

 map("q$_",(5..14));

my ($T0,$T1,$MASK) = map("q$_",(15,4,0));



 map("r$_",(4..7));

$code.=<<___;

if	__ARM_MAX_ARCH__>=7

48]		@ first table element

-1			@ is value impossible?

20]		@ load key base 2^32

24]

28]

32]

0x03ffffff	@ base 2^32 -> base 2^26

26

20

6

14

12

8

18

0x03ffffff

0x03ffffff

0x03ffffff

2		@ *5

2

2

2

2		@ counter

	@ d0 = h0*r0 + h4*5*r1 + h3*5*r2 + h2*5*r3 + h1*5*r4

 h1*r0 + h0*r1   + h4*5*r2 + h3*5*r3 + h2*5*r4

	@ d2 = h2*r0 + h1*r1   + h0*r2   + h4*5*r3 + h3*5*r4

 h3*r0 + h2*r1   + h1*r2   + h0*r3   + h4*5*r4

	@ d4 = h4*r0 + h3*r1   + h2*r2   + h1*r3   + h0*r4



	vmull.u32	$D0,$R0,${R0}[1]

	vmull.u32	$D1,$R1,${R0}[1]

	vmull.u32	$D2,$R2,${R0}[1]

	vmull.u32	$D3,$R3,${R0}[1]

	vmull.u32	$D4,$R4,${R0}[1]



	vmlal.u32	$D0,$R4,${S1}[1]

	vmlal.u32	$D1,$R0,${R1}[1]

	vmlal.u32	$D2,$R1,${R1}[1]

	vmlal.u32	$D3,$R2,${R1}[1]

	vmlal.u32	$D4,$R3,${R1}[1]



	vmlal.u32	$D0,$R3,${S2}[1]

	vmlal.u32	$D1,$R4,${S2}[1]

	vmlal.u32	$D3,$R1,${R2}[1]

	vmlal.u32	$D2,$R0,${R2}[1]

	vmlal.u32	$D4,$R2,${R2}[1]



	vmlal.u32	$D0,$R2,${S3}[1]

	vmlal.u32	$D3,$R0,${R3}[1]

	vmlal.u32	$D1,$R3,${S3}[1]

	vmlal.u32	$D2,$R4,${S3}[1]

	vmlal.u32	$D4,$R1,${R3}[1]



	vmlal.u32	$D3,$R4,${S4}[1]

	vmlal.u32	$D0,$R1,${S4}[1]

	vmlal.u32	$D1,$R2,${S4}[1]

	vmlal.u32	$D2,$R3,${S4}[1]

	vmlal.u32	$D4,$R0,${R4}[1]



	@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

	@ lazy reduction as discussed in "NEON crypto" by D.J. Bernstein

	@ and P. Schwabe

	@

	@ H0>>+H1>>+H2>>+H3>>+H4

	@ H3>>+H4>>*5+H0>>+H1

	@

	@ Trivia.

	@

	@ Result of multiplication of n-bit number by m-bit number is

	@ n+m bits wide. However! Even though 2^n is a n+1-bit number,

	@ m-bit number multiplied by 2^n is still n+m bits wide.

	@

	@ Sum of two n-bit numbers is n+1 bits wide, sum of three - n+2,

	@ and so is sum of four. Sum of 2^m n-m-bit numbers and n-bit

	@ one is n+1 bits wide.

	@

	@ >>+ denotes Hnext += Hn>>26, Hn &= 0x3ffffff. This means that

	@ H0, H2, H3 are guaranteed to be 26 bits wide, while H1 and H4

	@ can be 27. However! In cases when their width exceeds 26 bits

	@ they are limited by 2^26+2^6. This in turn means that *sum*

	@ of the products with these values can still be viewed as sum

	@ of 52-bit numbers as long as the amount of addends is not a

	@ power of 2. For example,

	@

 H4*R0 + H3*R1 + H2*R2 + H1*R3 + H0 * R4,

26

lo,$D3

26

lo,$D0

	vbic.i32	$D3#lo,#0xfc000000	@ &=0x03ffffff

	 vadd.i64	$D1,$D1,$T1		@ h0 -> h1

	 vbic.i32	$D0#lo,#0xfc000000



	vshrn.u64	$T0#lo,$D4,#26

	vmovn.i64	$D4#lo,$D4

	 vshr.u64	$T1,$D1,#26

	 vmovn.i64	$D1#lo,$D1

	 vadd.i64	$D2,$D2,$T1		@ h1 -> h2

	vbic.i32	$D4#lo,#0xfc000000

	 vbic.i32	$D1#lo,#0xfc000000



	vadd.i32	$D0#lo,$D0#lo,$T0#lo

	vshl.u32	$T0#lo,$T0#lo,#2

	 vshrn.u64	$T1#lo,$D2,#26

	 vmovn.i64	$D2#lo,$D2

	vadd.i32	$D0#lo,$D0#lo,$T0#lo	@ h4 -> h0

	 vadd.i32	$D3#lo,$D3#lo,$T1#lo	@ h2 -> h3

	 vbic.i32	$D2#lo,#0xfc000000



	vshr.u32	$T0#lo,$D0#lo,#26

	vbic.i32	$D0#lo,#0xfc000000

	 vshr.u32	$T1#lo,$D3#lo,#26

	 vbic.i32	$D3#lo,#0xfc000000

	vadd.i32	$D1#lo,$D1#lo,$T0#lo	@ h0 -> h1

	 vadd.i32	$D4#lo,$D4#lo,$T1#lo	@ h3 -> h4



	subs		$zeros,$zeros,#1

	beq		.Lsquare_break_neon



	add		$tbl0,$ctx,#(48+0*9*4)

	add		$tbl1,$ctx,#(48+1*9*4)



	vtrn.32		$R0,$D0#lo		@ r^2:r^1

	vtrn.32		$R2,$D2#lo

	vtrn.32		$R3,$D3#lo

	vtrn.32		$R1,$D1#lo

	vtrn.32		$R4,$D4#lo



	vshl.u32	$S2,$R2,#2		@ *5

	vshl.u32	$S3,$R3,#2

	vshl.u32	$S1,$R1,#2

	vshl.u32	$S4,$R4,#2

	vadd.i32	$S2,$S2,$R2

	vadd.i32	$S1,$S1,$R1

	vadd.i32	$S3,$S3,$R3

	vadd.i32	$S4,$S4,$R4



	vst4.32		{${R0}[0],${R1}[0],${S1}[0],${R2}[0]},[$tbl0]!

	vst4.32		{${R0}[1],${R1}[1],${S1}[1],${R2}[1]},[$tbl1]!

	vst4.32		{${S2}[0],${R3}[0],${S3}[0],${R4}[0]},[$tbl0]!

	vst4.32		{${S2}[1],${R3}[1],${S3}[1],${R4}[1]},[$tbl1]!

	vst1.32		{${S4}[0]},[$tbl0,:32]

	vst1.32		{${S4}[1]},[$tbl1,:32]



	b		.Lsquare_neon



.align	4

.Lsquare_break_neon:

	add		$tbl0,$ctx,#(48+2*4*9)

	add		$tbl1,$ctx,#(48+3*4*9)



	vmov		$R0,$D0#lo		@ r^4:r^3

	vshl.u32	$S1,$D1#lo,#2		@ *5

	vmov		$R1,$D1#lo

	vshl.u32	$S2,$D2#lo,#2

	vmov		$R2,$D2#lo

	vshl.u32	$S3,$D3#lo,#2

	vmov		$R3,$D3#lo

	vshl.u32	$S4,$D4#lo,#2

	vmov		$R4,$D4#lo

	vadd.i32	$S1,$S1,$D1#lo

	vadd.i32	$S2,$S2,$D2#lo

	vadd.i32	$S3,$S3,$D3#lo

	vadd.i32	$S4,$S4,$D4#lo



	vst4.32		{${R0}[0],${R1}[0],${S1}[0],${R2}[0]},[$tbl0]!

	vst4.32		{${R0}[1],${R1}[1],${S1}[1],${R2}[1]},[$tbl1]!

	vst4.32		{${S2}[0],${R3}[0],${S3}[0],${R4}[0]},[$tbl0]!

	vst4.32		{${S2}[1],${R3}[1],${S3}[1],${R4}[1]},[$tbl1]!

	vst1.32		{${S4}[0]},[$tbl0]

	vst1.32		{${S4}[1]},[$tbl1]



.Lno_init_neon:

	ret				@ bx	lr

.size	poly1305_init_neon,.-poly1305_init_neon



.type	poly1305_blocks_neon,%function

.align	5

poly1305_blocks_neon:

.Lpoly1305_blocks_neon:

	ldr	ip,[$ctx,#36]		@ is_base2_26



	cmp	$len,#64

	blo	.Lpoly1305_blocks



	stmdb	sp!,{r4-r7}

	vstmdb	sp!,{d8-d15}		@ ABI specification says so



	tst	ip,ip			@ is_base2_26?

	bne	.Lbase2_26_neon



	stmdb	sp!,{r1-r3,lr}

	bl	.Lpoly1305_init_neon



	ldr	r4,[$ctx,#0]		@ load hash value base 2^32

	ldr	r5,[$ctx,#4]

	ldr	r6,[$ctx,#8]

	ldr	r7,[$ctx,#12]

	ldr	ip,[$ctx,#16]



	and	r2,r4,#0x03ffffff	@ base 2^32 -> base 2^26

	mov	r3,r4,lsr#26

	 veor	$D0#lo,$D0#lo,$D0#lo

	mov	r4,r5,lsr#20

	orr	r3,r3,r5,lsl#6

	 veor	$D1#lo,$D1#lo,$D1#lo

	mov	r5,r6,lsr#14

	orr	r4,r4,r6,lsl#12

	 veor	$D2#lo,$D2#lo,$D2#lo

	mov	r6,r7,lsr#8

	orr	r5,r5,r7,lsl#18

	 veor	$D3#lo,$D3#lo,$D3#lo

	and	r3,r3,#0x03ffffff

	orr	r6,r6,ip,lsl#24

	 veor	$D4#lo,$D4#lo,$D4#lo

	and	r4,r4,#0x03ffffff

	mov	r1,#1

	and	r5,r5,#0x03ffffff

	str	r1,[$ctx,#36]		@ set is_base2_26



	vmov.32	$D0#lo[0],r2

	vmov.32	$D1#lo[0],r3

	vmov.32	$D2#lo[0],r4

	vmov.32	$D3#lo[0],r5

	vmov.32	$D4#lo[0],r6

	adr	$zeros,.Lzeros



	ldmia	sp!,{r1-r3,lr}

	b	.Lhash_loaded



.align	4

.Lbase2_26_neon:

	@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

	@ load hash value



	veor		$D0#lo,$D0#lo,$D0#lo

	veor		$D1#lo,$D1#lo,$D1#lo

	veor		$D2#lo,$D2#lo,$D2#lo

	veor		$D3#lo,$D3#lo,$D3#lo

	veor		$D4#lo,$D4#lo,$D4#lo

	vld4.32		{$D0#lo[0],$D1#lo[0],$D2#lo[0],$D3#lo[0]},[$ctx]!

	adr		$zeros,.Lzeros

	vld1.32		{$D4#lo[0]},[$ctx]

	sub		$ctx,$ctx,#16		@ rewind



.Lhash_loaded:

	add		$in2,$inp,#32

	mov		$padbit,$padbit,lsl#24

	tst		$len,#31

	beq		.Leven



	vld4.32		{$H0#lo[0],$H1#lo[0],$H2#lo[0],$H3#lo[0]},[$inp]!

	vmov.32		$H4#lo[0],$padbit

	sub		$len,$len,#16

	add		$in2,$inp,#32



# ifdef	__ARMEB__

	vrev32.8	$H0,$H0

	vrev32.8	$H3,$H3

	vrev32.8	$H1,$H1

	vrev32.8	$H2,$H2

# endif

	vsri.u32	$H4#lo,$H3#lo,#8	@ base 2^32 -> base 2^26

	vshl.u32	$H3#lo,$H3#lo,#18



	vsri.u32	$H3#lo,$H2#lo,#14

	vshl.u32	$H2#lo,$H2#lo,#12

	vadd.i32	$H4#hi,$H4#lo,$D4#lo	@ add hash value and move to #hi



	vbic.i32	$H3#lo,#0xfc000000

	vsri.u32	$H2#lo,$H1#lo,#20

	vshl.u32	$H1#lo,$H1#lo,#6



	vbic.i32	$H2#lo,#0xfc000000

	vsri.u32	$H1#lo,$H0#lo,#26

	vadd.i32	$H3#hi,$H3#lo,$D3#lo



	vbic.i32	$H0#lo,#0xfc000000

	vbic.i32	$H1#lo,#0xfc000000

	vadd.i32	$H2#hi,$H2#lo,$D2#lo



	vadd.i32	$H0#hi,$H0#lo,$D0#lo

	vadd.i32	$H1#hi,$H1#lo,$D1#lo



	mov		$tbl1,$zeros

	add		$tbl0,$ctx,#48



	cmp		$len,$len

	b		.Long_tail



.align	4

.Leven:

	subs		$len,$len,#64

	it		lo

	movlo		$in2,$zeros



	vmov.i32	$H4,#1<<24		@ padbit, yes, always

	vld4.32		{$H0#lo,$H1#lo,$H2#lo,$H3#lo},[$inp]	@ inp[0:1]

	add		$inp,$inp,#64

	vld4.32		{$H0#hi,$H1#hi,$H2#hi,$H3#hi},[$in2]	@ inp[2:3] (or 0)

	add		$in2,$in2,#64

	itt		hi

	addhi		$tbl1,$ctx,#(48+1*9*4)

	addhi		$tbl0,$ctx,#(48+3*9*4)



# ifdef	__ARMEB__

	vrev32.8	$H0,$H0

	vrev32.8	$H3,$H3

	vrev32.8	$H1,$H1

	vrev32.8	$H2,$H2

# endif

	vsri.u32	$H4,$H3,#8		@ base 2^32 -> base 2^26

	vshl.u32	$H3,$H3,#18



	vsri.u32	$H3,$H2,#14

	vshl.u32	$H2,$H2,#12



	vbic.i32	$H3,#0xfc000000

	vsri.u32	$H2,$H1,#20

	vshl.u32	$H1,$H1,#6



	vbic.i32	$H2,#0xfc000000

	vsri.u32	$H1,$H0,#26



	vbic.i32	$H0,#0xfc000000

	vbic.i32	$H1,#0xfc000000



	bls		.Lskip_loop



	vld4.32		{${R0}[1],${R1}[1],${S1}[1],${R2}[1]},[$tbl1]!	@ load r^2

	vld4.32		{${R0}[0],${R1}[0],${S1}[0],${R2}[0]},[$tbl0]!	@ load r^4

	vld4.32		{${S2}[1],${R3}[1],${S3}[1],${R4}[1]},[$tbl1]!

	vld4.32		{${S2}[0],${R3}[0],${S3}[0],${R4}[0]},[$tbl0]!

	b		.Loop_neon



.align	5

.Loop_neon:

	@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

	@ ((inp[0]*r^4+inp[2]*r^2+inp[4])*r^4+inp[6]*r^2

	@ ((inp[1]*r^4+inp[3]*r^2+inp[5])*r^3+inp[7]*r

	@   \___________________/

	@ ((inp[0]*r^4+inp[2]*r^2+inp[4])*r^4+inp[6]*r^2+inp[8])*r^2

	@ ((inp[1]*r^4+inp[3]*r^2+inp[5])*r^4+inp[7]*r^2+inp[9])*r

	@   \___________________/ \____________________/

	@

	@ Note that we start with inp[2:3]*r^2. This is because it

	@ doesn't depend on reduction in previous iteration.

	@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

 h4*r0 + h3*r1   + h2*r2   + h1*r3   + h0*r4

	@ d3 = h3*r0 + h2*r1   + h1*r2   + h0*r3   + h4*5*r4

 h2*r0 + h1*r1   + h0*r2   + h4*5*r3 + h3*5*r4

	@ d1 = h1*r0 + h0*r1   + h4*5*r2 + h3*5*r3 + h2*5*r4

 h0*r0 + h4*5*r1 + h3*5*r2 + h2*5*r3 + h1*5*r4

lo,$H2lo	@ accumulate inp[0:1]

hi,${R0}[1]

lo,$H0lo

hi,${R0}[1]

lo,$H3lo

hi,${R0}[1]

hi,${R1}[1]

lo,$H1lo

hi,${R0}[1]

lo,$H4lo

hi,${R0}[1]

64

hi,${S1}[1]

hi,${R1}[1]

hi,${R1}[1]

hi,${R1}[1]

hi,${S2}[1]

hi,${R2}[1]

hi,${R2}[1]

hi,${S2}[1]

hi,${R2}[1]

hi,${R3}[1]

hi,${S3}[1]

hi,${R3}[1]

hi,${S3}[1]

hi,${S3}[1]

hi,${S4}[1]

hi,${S4}[1]

hi,${R4}[1]

hi,${S4}[1]

hi,${S4}[1]

hi,$H1hi,$H3
64

lo,${R0}[0]

lo,${R0}[0]

lo,${R0}[0]

lo,${R0}[0]

lo,${R0}[0]

lo,${R1}[0]

lo,${S1}[0]

lo,${R1}[0]

lo,${R1}[0]

lo,${R1}[0]

lo,${R2}[0]

lo,${S2}[0]

lo,${R2}[0]

lo,${S2}[0]

lo,${R2}[0]

lo,${R3}[0]

lo,${S3}[0]

lo,${R3}[0]

lo,${S3}[0]

lo,${S4}[0]

lo,${S3}[0]

lo,${S4}[0]

lo,${R4}[0]

1<<24		@ padbit, yes, always

lo,${S4}[0]

lo,${S4}[0]

lo,$H1lo,$H3
64

 ifdef	__ARMEB__

 endif

26

lo,$D3

26

lo,$D0

lo,
8		@ base 2^32 -> base 2^26

18

lo,
lo,$D4,
lo,$D4

26

lo,$D1

14

lo,
12

lo,
lo,$D0lo

lo,$T02

0xfc000000

lo,$D2,
lo,$D2

lo,$T0
20

lo,$D3lo	@ h2 -> h3

6

lo,
0xfc000000

lo,$D0,
lo,$D0

26

0xfc000000

lo,$D326

lo,
lo,
lo,$D1lo	@ h0 -> h1

lo,$D4lo	@ h3 -> h4

0xfc000000

(48+0*9*4)

(48+1*9*4)

32

0

hi,$H2lo	@ add hash value and move to 
hi,$H0lo

hi,$H3lo

hi,$H1lo

hi,$H4lo

lo,$H2lo	@ can be redundant

hi,$R0

lo,$H0lo

hi,$R0

lo,$H3lo

hi,$R0

lo,$H1lo

hi,$R0

lo,$H4lo

hi,$R0

hi,$S1

hi,$R1

hi,$R1

hi,$R1

hi,$R1

hi,$R2

hi,$S2

hi,$R2

hi,$S2

hi,$R2

hi,$R3

(48+2*9*4)

hi,$S3

(48+3*9*4)

hi,$R3

hi,$S3

hi,$S3

hi,$S4

hi,$S4

38

hi,$R4

hi,$S4

hi,$S4

lo,$R0

lo,$R0

lo,$R0

lo,$R0

lo,$R0

lo,$S1

lo,$R1

lo,$R1

lo,$R1

lo,$R1

lo,$R2

lo,$S2

lo,$R2

lo,$S2

lo,$R2

lo,$R3

lo,$S3

lo,$R3

lo,$S3

lo,$S3

lo,$S4

lo,$S4

38

lo,$R4

lo,$S4

lo,$S4

lo,$D3hi

lo,$D0hi

lo,$D4hi

lo,$D1hi

lo,$D2hi

26

26

26

26

2

26

26

26

0

lo[0],$D1lo[0],$D3
lo[0]},[$ctx]

ifndef	__KERNEL__

 ifdef	_WIN32

 else

 endif

endif

endif

$code.=<<___;

.asciz	"Poly1305 for ARMv4/NEON, CRYPTOGAMS by \@dot-asm"

.align	2

___



foreach (split("\n",$code)) {

	s/\`([^\`]*)\`/eval $1/geo;



	s/\bq([0-9]+)#(lo|hi)/sprintf "d%d",2*$1+($2 eq "hi")/geo	or

	s/\bret\b/bx	lr/go						or

 make it possible to compile with -march=armv4

 enforce flush

!/usr/bin/env perl

 SPDX-License-Identifier: GPL-2.0

 This code is taken from the OpenSSL project but the author (Andy Polyakov)

 has relicensed it under the GPLv2. Therefore this program is free software;

 you can redistribute it and/or modify it under the terms of the GNU General

 Public License version 2 as published by the Free Software Foundation.



 The original headers, including the original license headers, are

 included below for completeness.

 ====================================================================


 Written by Andy Polyakov <appro@openssl.org> for the OpenSSL

 project. The module is, however, dual licensed under OpenSSL and

 CRYPTOGAMS licenses depending on where you obtain it. For further

 details see https://www.openssl.org/~appro/cryptogams/.

 ====================================================================


 SHA256 block procedure for ARMv4. May 2007.

 Performance is ~2x better than gcc 3.4 generated code and in "abso-

 lute" terms is ~2250 cycles per 64-byte block or ~35 cycles per

 byte [on single-issue Xscale PXA250 core].

 July 2010.



 Rescheduling for dual-issue pipeline resulted in 22% improvement on

 Cortex A8 core and ~20 cycles per processed byte.

 February 2011.



 Profiler-assisted and platform-specific optimization resulted in 16%

 improvement on Cortex A8 core and ~15.4 cycles per processed byte.

 September 2013.



 Add NEON implementation. On Cortex A8 it was measured to process one

 byte in 12.5 cycles or 23% faster than integer-only code. Snapdragon

 S4 does it in 12.5 cycles too, but it's 50% faster than integer-only

 code (meaning that latter performs sub-optimally, nothing was done

 about it).

 May 2014.



 Add ARMv8 code path performing at 2.0 cpb on Apple A7.

while (($output=shift) && ($output!~/^\w[\w\-]*\.\w+$/)) {}

open STDOUT,">$output";



$ctx="r0";	$t0="r0";

$inp="r1";	$t4="r1";

$len="r2";	$t1="r2";

$T1="r3";	$t3="r3";

"r4";

$B="r5";

"r6";

$D="r7";

"r8";

$F="r9";

"r10";

$H="r11";

($A,$B,$C,$D,$E,$F,$G,$H);

$t2="r12";

"r14";

@Sigma0=( 2,13,22);

( 6,11,25);

@sigma0=( 7,18, 3);

(17,19,10);

my ($i,$a,$b,$c,$d,$e,$f,$g,$h) = @_;



<<___ if ($i<16);

#if __ARM_ARCH__>=7

	@ ldr	$t1,[$inp],#4			@ $i

# if $i==15

	str	$inp,[sp,#17*4]			@ make room for $t4

# endif

	eor	$t0,$e,$e,ror#`$Sigma1[1]-$Sigma1[0]`

Maj(a,b,c) from the past

`$Sigma1[2]-$Sigma1[0]`	@ Sigma1(e)

 ifndef __ARMEB__

 endif

else

3]			@ $i

	add	$a,$a,$t2			@ h+=Maj(a,b,c) from the past

	ldrb	$t2,[$inp,#2]

	ldrb	$t0,[$inp,#1]

	orr	$t1,$t1,$t2,lsl#8

	ldrb	$t2,[$inp],#4

	orr	$t1,$t1,$t0,lsl#16

# if $i==15

	str	$inp,[sp,#17*4]			@ make room for $t4

# endif

	eor	$t0,$e,$e,ror#`$Sigma1[1]-$Sigma1[0]`

	orr	$t1,$t1,$t2,lsl#24

	eor	$t0,$t0,$e,ror#`$Sigma1[2]-$Sigma1[0]`	@ Sigma1(e)

#endif

___

<<___;

4			@ *K256++

	add	$h,$h,$t1			@ h+=X[i]

	str	$t1,[sp,#`$i%16`*4]

	eor	$t1,$f,$g

$Sigma1[0]	@ h+=Sigma1(e)

	add	$h,$h,$t2			@ h+=K256[i]

	eor	$t1,$t1,$g			@ Ch(e,f,g)

	eor	$t0,$a,$a,ror#`$Sigma0[1]-$Sigma0[0]`

Ch(e,f,g)

if $i==31
31

0xff

0xf2			@ done?

endif

if $i<15

# if __ARM_ARCH__>=7

	ldr	$t1,[$inp],#4			@ prefetch

# else

	ldrb	$t1,[$inp,#3]

# endif

	eor	$t2,$a,$b			@ a^b, b^c in next round

#else

	ldr	$t1,[sp,#`($i+2)%16`*4]		@ from future BODY_16_xx

	eor	$t2,$a,$b			@ a^b, b^c in next round

	ldr	$t4,[sp,#`($i+15)%16`*4]	@ from future BODY_16_xx

#endif

	eor	$t0,$t0,$a,ror#`$Sigma0[2]-$Sigma0[0]`	@ Sigma0(a)

(a^b)

	add	$d,$d,$h			@ d+=h

	eor	$t3,$t3,$b			@ Maj(a,b,c)

$Sigma0[0]	@ h+=Sigma0(a)

	@ add	$h,$h,$t3			@ h+=Maj(a,b,c)

___

($t3,$t2);

my ($i,$a,$b,$c,$d,$e,$f,$g,$h) = @_;



<<___;

`($i+1)%16`*4]		@ $i

`($i+14)%16`*4]

$sigma0[0]

	add	$a,$a,$t2			@ h+=Maj(a,b,c) from the past

	mov	$t2,$t4,ror#$sigma1[0]

	eor	$t0,$t0,$t1,ror#$sigma0[1]

	eor	$t2,$t2,$t4,ror#$sigma1[1]

	eor	$t0,$t0,$t1,lsr#$sigma0[2]	@ sigma0(X[i+1])

	ldr	$t1,[sp,#`($i+0)%16`*4]

	eor	$t2,$t2,$t4,lsr#$sigma1[2]	@ sigma1(X[i+14])

	ldr	$t4,[sp,#`($i+9)%16`*4]



	add	$t2,$t2,$t0

	eor	$t0,$e,$e,ror#`$Sigma1[1]-$Sigma1[0]`	@ from BODY_00_15

	add	$t1,$t1,$t2

	eor	$t0,$t0,$e,ror#`$Sigma1[2]-$Sigma1[0]`	@ Sigma1(e)

	add	$t1,$t1,$t4			@ X[i]

___

	&BODY_00_15(@_);

}



<<___;

ifndef __KERNEL__

 include "arm_arch.h"

else

 define __ARM_ARCH__ __LINUX_ARM_ARCH__

 define __ARM_MAX_ARCH__ 7

endif

if __ARM_ARCH__<7

else

 ifdef __thumb2__

 else

 endif

endif

#if __ARM_MAX_ARCH__>=7 && !defined(__KERNEL__)

.LOPENSSL_armcap:

.word	OPENSSL_armcap_P-sha256_block_data_order

#endif

.align	5



.global	sha256_block_data_order

.type	sha256_block_data_order,%function

sha256_block_data_order:

.Lsha256_block_data_order:

#if __ARM_ARCH__<7

	sub	r3,pc,#8		@ sha256_block_data_order

#else

	adr	r3,.Lsha256_block_data_order

#endif

if __ARM_MAX_ARCH__>=7 && !defined(__KERNEL__)

ARMV8_SHA256

ARMV7_NEON

endif

6	@ len to point at the end of inp

256+32	@ K256

16*4		@ alloca(X[16])

# if __ARM_ARCH__>=7

	ldr	$t1,[$inp],#4

# else

	ldrb	$t1,[$inp,#3]

# endif

	eor	$t3,$B,$C		@ magic

	eor	$t2,$t2,$t2

___

0;$i<16;$i++)	{ &BODY_00_15($i,@V); unshift(@V,pop(@V)); }

$code.=".Lrounds_16_xx:\n";

for (;$i<32;$i++)	{ &BODY_16_XX($i,@V); unshift(@V,pop(@V)); }

<<___;

#if __ARM_ARCH__>=7

	ite	eq			@ Thumb2 thing, sanity check in ARM

#endif

	ldreq	$t3,[sp,#16*4]		@ pull ctx

	bne	.Lrounds_16_xx



Maj(a,b,c) from the past

0]

4]

8]

12]

16]

20]

24]

28]

17*4]		@ pull inp

18*4]		@ pull inp+len

256	@ rewind Ktbl

`16+3`*4	@ destroy frame

#if __ARM_ARCH__>=5

	ldmia	sp!,{r4-r11,pc}

#else

	ldmia	sp!,{r4-r11,lr}

	tst	lr,#1

	moveq	pc,lr			@ be binary compatible with V4, yet

	bx	lr			@ interoperable with Thumb ISA:-)

#endif

.size	sha256_block_data_order,.-sha256_block_data_order

___

######################################################################

# NEON stuff

#

{{{

map("q$_",(0..3));

my ($T0,$T1,$T2,$T3,$T4,$T5)=("q8","q9","q10","q11","d24","d25");

$t4;

my $j=0;



~m|q([1]?[0-9])|?"d".($1*2):"";     }

sub Dhi()   { shift=~m|q([1]?[0-9])|?"d".($1*2+1):"";   }



sub AUTOLOAD()          # thunk [simplified] x86-style perlasm

 $AUTOLOAD; $opcode ~ s/_/\./;

  my $arg = pop;

$arg" if ($arg*1 eq $arg);

    $code .= "\t$opcode\t".join(',',@_,$arg)."\n";

}



sub Xupdate()

{ use integer;

 shift;

  my @insns = (&$body,&$body,&$body,&$body);

  my ($a,$b,$c,$d,$e,$f,$g,$h);



	&vext_8		($T0,@X[0],@X[1],4);	# X[1..4]

	 eval(shift(@insns));

	 eval(shift(@insns));

	 eval(shift(@insns));

	&vext_8		($T1,@X[2],@X[3],4);	# X[9..12]

	 eval(shift(@insns));

	 eval(shift(@insns));

	 eval(shift(@insns));

	&vshr_u32	($T2,$T0,$sigma0[0]);

	 eval(shift(@insns));

	 eval(shift(@insns));

 X[0..3] += X[9..12]

 sigma0(X[1..4])

	&vadd_i32	(@X[0],@X[0],$T1);	# X[0..3] += sigma0(X[1..4])

	 eval(shift(@insns));

	 eval(shift(@insns));

	  &veor		($T5,$T5,$T4);

	 eval(shift(@insns));

	 eval(shift(@insns));

	  &vshr_u32	($T4,&Dhi(@X[3]),$sigma1[1]);

	 eval(shift(@insns));

	 eval(shift(@insns));

	  &vsli_32	($T4,&Dhi(@X[3]),32-$sigma1[1]);

	 eval(shift(@insns));

	 eval(shift(@insns));

	  &veor		($T5,$T5,$T4);		# sigma1(X[14..15])

	 eval(shift(@insns));

	 eval(shift(@insns));

 X[0..1] += sigma1(X[14..15])

 sigma1(X[16..17])

	&vadd_i32	(&Dhi(@X[0]),&Dhi(@X[0]),$T5);# X[2..3] += sigma1(X[16..17])

	 eval(shift(@insns));

	 eval(shift(@insns));

	&vadd_i32	($T0,$T0,@X[0]);

insns>=2) { eval(shift(@insns)); }

 "rotate" X[]

  my $body = shift;

 (&$body,&$body,&$body,&$body);

 remaining instructions

 "rotate" X[]

	'($a,$b,$c,$d,$e,$f,$g,$h)=@V;'.

 h+=X[i]+K[i]

".($Sigma1[1]-$Sigma1[0]))',

	'&add	($a,$a,$t2)',			# h+=Maj(a,b,c) from the past

	'&and	($t1,$t1,$e)',

	'&eor	($t2,$t0,$e,"ror#".($Sigma1[2]-$Sigma1[0]))',	# Sigma1(e)

	'&eor	($t0,$a,$a,"ror#".($Sigma0[1]-$Sigma0[0]))',

	'&eor	($t1,$t1,$g)',			# Ch(e,f,g)

$Sigma1[0]")',	Sigma1(e)

 a^b, b^c in next round

".($Sigma0[2]-$Sigma0[0]))',	
	'&add	($h,$h,$t1)',			# h+=Ch(e,f,g)

%d]",4*(($j+1)&15))	if (($j&15)!=15);'.

64]")			if ($j==31)',
31)',

	'&and	($t3,$t3,$t2)',			# (b^c)&=(a^b)

 d+=h

	'&add	($h,$h,$t0,"ror#$Sigma0[0]");'.	# h+=Sigma0(a)

	'&eor	($t3,$t3,$b)',			# Maj(a,b,c)

($t3,$t2);'

$code.=<<___;

if __ARM_MAX_ARCH__>=7

16*4+16

.Lsha256_block_data_order-K256

15		@ align for 128-bit stores

6	@ len to point at the end of inp

64]

68]

72]

76]		@ save original sp

64

0]

$code.=<<___;

	teq	$t1,#0				@ check for K256 terminator

	ldr	$t1,[sp,#0]

	sub	$Xfer,$Xfer,#64

	bne	.L_00_48



	ldr		$inp,[sp,#68]

	ldr		$t0,[sp,#72]

	sub		$Ktbl,$Ktbl,#256	@ rewind $Ktbl

	teq		$inp,$t0

	it		eq

	subeq		$inp,$inp,#64		@ avoid SEGV

	vld1.8		{@X[0]},[$inp]!		@ load next input block

	vld1.8		{@X[1]},[$inp]!

	vld1.8		{@X[2]},[$inp]!

	vld1.8		{@X[3]},[$inp]!

	it		ne

	strne		$inp,[sp,#68]

	mov		$Xfer,sp

___

	&Xpreload(\&body_00_15);

	&Xpreload(\&body_00_15);

	&Xpreload(\&body_00_15);

	&Xpreload(\&body_00_15);

<<___;

0]

	add	$A,$A,$t2			@ h+=Maj(a,b,c) from the past

	ldr	$t2,[$t1,#4]

	ldr	$t3,[$t1,#8]

	ldr	$t4,[$t1,#12]

	add	$A,$A,$t0			@ accumulate

	ldr	$t0,[$t1,#16]

	add	$B,$B,$t2

	ldr	$t2,[$t1,#20]

	add	$C,$C,$t3

	ldr	$t3,[$t1,#24]

	add	$D,$D,$t4

	ldr	$t4,[$t1,#28]

	add	$E,$E,$t0

	str	$A,[$t1],#4

	add	$F,$F,$t2

	str	$B,[$t1],#4

	add	$G,$G,$t3

	str	$C,[$t1],#4

	add	$H,$H,$t4

	str	$D,[$t1],#4

	stmia	$t1,{$E-$H}



	ittte	ne

	movne	$Xfer,sp

	ldrne	$t1,[sp,#0]

	eorne	$t2,$t2,$t2

	ldreq	sp,[sp,#76]			@ restore original sp

	itt	ne

	eorne	$t3,$B,$C

	bne	.L_00_48



	ldmia	sp!,{r4-r12,pc}

.size	sha256_block_data_order_neon,.-sha256_block_data_order_neon

#endif

___

}}}

######################################################################

# ARMv8 stuff

#

{{{

map("q$_",(0..2));

my @MSG=map("q$_",(8..11));

map("q$_",(12..15));

my $Ktbl="r3";



<<___;

#if __ARM_MAX_ARCH__>=7 && !defined(__KERNEL__)



# ifdef __thumb2__

#  define INST(a,b,c,d)	.byte	c,d|0xc,a,b

# else

#  define INST(a,b,c,d)	.byte	a,b,c,d

# endif



.type	sha256_block_data_order_armv8,%function

.align	5

sha256_block_data_order_armv8:

.LARMv8:

	vld1.32	{$ABCD,$EFGH},[$ctx]

# ifdef __thumb2__

	adr	$Ktbl,.LARMv8

	sub	$Ktbl,$Ktbl,#.LARMv8-K256

# else

	adrl	$Ktbl,K256

# endif

	add	$len,$inp,$len,lsl#6	@ len to point at the end of inp



.Loop_v8:

	vld1.8		{@MSG[0]-@MSG[1]},[$inp]!

	vld1.8		{@MSG[2]-@MSG[3]},[$inp]!

	vld1.32		{$W0},[$Ktbl]!

	vrev32.8	@MSG[0],@MSG[0]

	vrev32.8	@MSG[1],@MSG[1]

	vrev32.8	@MSG[2],@MSG[2]

	vrev32.8	@MSG[3],@MSG[3]

	vmov		$ABCD_SAVE,$ABCD	@ offload

	vmov		$EFGH_SAVE,$EFGH

	teq		$inp,$len

___

0;$i<12;$i++) {

$code.=<<___;

	vld1.32		{$W1},[$Ktbl]!

	vadd.i32	$W0,$W0,@MSG[0]

	sha256su0	@MSG[0],@MSG[1]

	vmov		$abcd,$ABCD

	sha256h		$ABCD,$EFGH,$W0

	sha256h2	$EFGH,$abcd,$W0

	sha256su1	@MSG[0],@MSG[2],@MSG[3]

___

($W1,$W0);	push(@MSG,shift(@MSG));

$code.=<<___;

	vld1.32		{$W1},[$Ktbl]!

	vadd.i32	$W0,$W0,@MSG[0]

	vmov		$abcd,$ABCD

	sha256h		$ABCD,$EFGH,$W0

	sha256h2	$EFGH,$abcd,$W0



	vld1.32		{$W0},[$Ktbl]!

	vadd.i32	$W1,$W1,@MSG[1]

	vmov		$abcd,$ABCD

	sha256h		$ABCD,$EFGH,$W1

	sha256h2	$EFGH,$abcd,$W1



	vld1.32		{$W1},[$Ktbl]

	vadd.i32	$W0,$W0,@MSG[2]

	sub		$Ktbl,$Ktbl,#256-16	@ rewind

	vmov		$abcd,$ABCD

	sha256h		$ABCD,$EFGH,$W0

	sha256h2	$EFGH,$abcd,$W0



	vadd.i32	$W1,$W1,@MSG[3]

	vmov		$abcd,$ABCD

	sha256h		$ABCD,$EFGH,$W1

	sha256h2	$EFGH,$abcd,$W1



	vadd.i32	$ABCD,$ABCD,$ABCD_SAVE

	vadd.i32	$EFGH,$EFGH,$EFGH_SAVE

	it		ne

	bne		.Loop_v8



	vst1.32		{$ABCD,$EFGH},[$ctx]



	ret		@ bx lr

.size	sha256_block_data_order_armv8,.-sha256_block_data_order_armv8

#endif

___

}}}

<<___;

#if __ARM_MAX_ARCH__>=7 && !defined(__KERNEL__)

.comm   OPENSSL_armcap_P,4,4

#endif

___



open SELF,$0;

while(<SELF>) {

	next if (/^#!/);

	last if (!s/^#/@/ and !/^$/);

	print;

}

close SELF;



 (

> 0xf3000c40,	"sha256h2"	
> 0xf3ba03c0,	"sha256su1"	
	my ($mnemonic,$arg)=@_;



~ m/q([0-9]+)(?:,\s*q([0-9]+))?,\s*q([0-9]+)/o) {

	    my $word = $opcode{$mnemonic}|(($1&7)<<13)|(($1&8)<<19)

					 |(($2&7)<<17)|(($2&8)<<4)

					 |(($3&7)<<1) |(($3&8)<<2);

	    # since ARMv7 instructions are always encoded little-endian.

	    # correct solution is to use .inst directive, but older

	    # assemblers don't implement it:-(

	    sprintf "INST(0x%02x,0x%02x,0x%02x,0x%02x)\t@ %s %s",

			$word&0xff,($word>>8)&0xff,

			($word>>16)&0xff,($word>>24)&0xff,

			$mnemonic,$arg;

	}

    }

}



foreach (split($/,$code)) {



	s/\`([^\`]*)\`/eval $1/geo;



	s/\b(sha256\w+)\s+(q.*)/unsha256($1,$2)/geo;



	s/\bret\b/bx	lr/go		or

 make it possible to compile with -march=armv4

 enforce flush

