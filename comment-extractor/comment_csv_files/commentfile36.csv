 SPDX-License-Identifier: GPL-2.0-only

/*

 * Generic HDLC support routines for Linux

 * X.25 support

 *

 * Copyright (C) 1999 - 2006 Krzysztof Halasa <khc@pm.waw.pl>

 Protects "up" */

 These functions are callbacks called by LAPB layer */

 Ignore return value :-( */

	/* There should be a pseudo header of 1 byte added by upper layers.

	 * Check to make sure it is there before reading it.

 Data to be transmitted */

 Send connect confirm. msg to level 3 */

 Send disconnect confirm. msg to level 3 */

 to be defined */

 data size wanted */

 backward compatibility */

 There's no header_ops so hard_header_len should be 0. */

		/* When transmitting data:

		 * first we'll remove a pseudo header of 1 byte,

		 * then we'll prepend an LAPB header of at most 3 bytes.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Generic HDLC support routines for Linux

 * HDLC Ethernet emulation support

 *

 * Copyright (C) 2002-2006 Krzysztof Halasa <khc@pm.waw.pl>

 Pad the frame with zeros */

 data size wanted */

 SPDX-License-Identifier: GPL-2.0-or-later

/*      FarSync WAN driver for Linux (2.6.x kernel version)

 *

 *      Actually sync driver for X.21, V.35 and V.24 on FarSync T-series cards

 *

 *      Copyright (C) 2001-2004 FarSite Communications Ltd.

 *      www.farsite.co.uk

 *

 *      Author:      R.J.Dunlop    <bob.dunlop@farsite.co.uk>

 *      Maintainer:  Kevin Curtis  <kevin.curtis@farsite.co.uk>

/*      Module info

/*      Driver configuration and global parameters

 *      ==========================================

/*      Number of ports (per card) and cards supported

/*      Default parameters for the link

#define FST_TX_QUEUE_LEN        100	/* At 8Mbps a longer queue length is

					 * useful

#define FST_TXQ_DEPTH           16	/* This one is for the buffering

					 * of frames on the way down to the card

					 * so that we can keep the card busy

					 * and maximise throughput

#define FST_HIGH_WATER_MARK     12	/* Point at which we flow control

					 * network layer

#define FST_LOW_WATER_MARK      8	/* Point at which we remove flow

					 * control from network layer

 Huge but possible */

 Common sane value */

 Raw frames */

 Cisco-HDLC (keepalives etc) */

/* Modules parameters and associated variables

/*      Card shared memory layout

 *      =========================

/*      This information is derived in part from the FarSite FarSync Smc.h

 *      file. Unfortunately various name clashes and the non-portability of the

 *      bit field declarations in that file have meant that I have chosen to

 *      recreate the information here.

 *

 *      The SMC (Shared Memory Configuration) has a version number that is

 *      incremented every time there is a significant change. This number can

 *      be used to check that we have not got out of step with the firmware

 *      contained in the .CDE files.

 Size of card memory (1Mb) */

#define SMC_BASE 0x00002000L	/* Base offset of the shared memory window main

				 * configuration structure

#define BFM_BASE 0x00010000L	/* Base offset of the shared memory window DMA

				 * buffers

 Size of packet buffers */

 Size of obsolete buffs used for DOS diags */

 Must be power of 2. Fixed by firmware */

 Interrupt retry time in milliseconds */

/*      The Am186CH/CC processors support a SmartDMA mode using circular pools

 *      of buffer descriptors. The structure is almost identical to that used

 *      in the LANCE Ethernet controllers. Details available as PDF from the

 *      AMD web site: https://www.amd.com/products/epd/processors/\

 *                    2.16bitcont/3.am186cxfa/a21914/21914.pdf

 Transmit descriptor */

	volatile u16 ladr;	/* Low order address of packet. This is a

				 * linear address in the Am186 memory space

	volatile u8 hadr;	/* High order address. Low 4 bits only, high 4

				 * bits must be zero

 Status and config */

	volatile u16 bcnt;	/* 2s complement of packet size in low 15 bits.

				 * Transmit terminal count interrupt enable in

				 * top bit.

 Not used in Tx */

 Receive descriptor */

 Low order address of packet */

 High order address */

 Status and config */

	volatile u16 bcnt;	/* 2s complement of buffer size in low 15 bits.

				 * Receive terminal count interrupt enable in

				 * top bit.

 Message byte count (15 bits) */

 Convert a length into the 15 bit 2's complement */

 #define cnv_bcnt(len)   (( ~(len) + 1 ) & 0x7FFF ) */

/* Since we need to set the high bit to enable the completion interrupt this

 * can be made a lot simpler

 Status and config bits for the above */

 SmartDMA owns the descriptor */

 Tx: start of packet */

 Tx: end of packet */

 Rx: error (OR of next 4 bits) */

 Rx: framing error */

 Rx: overflow error */

 Rx: CRC error */

 Rx: buffer error */

 Rx: start of packet */

 Rx: end of packet */

/* Interrupts from the card are caused by various events which are presented

 * in a circular buffer as several events may be processed on one physical int

 read, then increment and wrap */

 write, then increment and wrap */

/* Interrupt event codes.

 * Where appropriate the two low order bits indicate the port number

 Control signal changed */

 Initialisation complete */

 Initialisation failed */

 Abort sent */

 Transmission underflow */

 Port physical configuration. See farsync.h for field values */

 Physical interface type */

 Unused at present */

 1 => internal clock, 0 => external */

 1 => on, 0 => off */

 0 => normal, 1 => inverted */

 Padding */

 Speed in bps */

 TE1 port physical configuration */

 TE1 Status */

/* Finally sling all the above together into the shared memory structure.

 * Sorry it's a hodge podge of arrays, structures and unused bits, it's been

 * evolving under NT for some time so I guess we're stuck with it.

 * The structure starts at offset SMC_BASE.

 * See farsync.h for some field values.

 DMA descriptor rings */

 Obsolete small buffers */

	u8 taskStatus;		/* 0x00 => initialising, 0x01 => running,

				 * 0xFF => halted

	u8 interruptHandshake;	/* Set to 0x01 by adapter to signal interrupt,

				 * set to 0xEE by host to acknowledge interrupt

 Must match SMC_VERSION */

	u32 smcFirmwareVersion;	/* 0xIIVVRRBB where II = product ID, VV = major

				 * version, RR = revision and BB = build

 Obsolete completion flags */

 Diagnostics mailbox. Not used */

 interrupt causes */

 V.24 control input status */

 V.24 control output status */

 lsb: 0=> present, 1=> absent */

 lsb: 0=> present, 1=> absent */

 transmit descriptor ring index */

 receive descriptor ring index */

 command, modifier */

 Not used */

	/* Number of times the card thinks the host has

	 * missed an interrupt by not acknowledging

	 * within 2mS (I guess NT has problems)

	/* Driver private data used as an ID. We'll not

	 * use this as I'd rather keep such things

	 * in main memory rather than on the PCI bus

 Count of Tx underflows for stats */

 Debounced V.24 control input status */

 Adapter debounce timers. Don't touch */

 Number of ports detected at startup */

	u16 cardMode;		/* Bit-mask to enable features:

				 * Bit 0: 1 enables LED identify mode

 TE1 Bits */

	u32 endOfSmcSignature;	/* endOfSmcSignature MUST be the last member of

				 * the structure and marks the end of shared

				 * memory. Adapter code initializes it as

				 * END_SIG.

 endOfSmcSignature value */

 Mailbox values. (portMailbox) */

 No operation */

 Positive acknowledgement to PC driver */

 Negative acknowledgement to PC driver */

 Start an HDLC port */

 Stop an HDLC port */

 Abort the transmitter for a port */

 Set V24 outputs */

 PLX Chip Register Offsets */

 Control Register */

 Control Register */

 Interrupt control/status register */

 Interrupt control/status register */

 9054 DMA Registers */

/* Note that we will be using DMA Channel 0 for copying rx data

 * and Channel 1 for copying tx data

 Larger buffers are positioned in memory at offset BFM_BASE */

 Calculate offset of a buffer object within the shared memory window */

/*      Device driver private information

 *      =================================

/*      Per port (line or channel) information

 Device struct - must be first */

 Card we're associated with */

 Port index on the card */

 Line hardware (lineInterface copy) */

 Port is running */

 Normal or FarSync raw */

 Next Rx buffer to use */

 Next Tx buffer to use */

 Next Tx buffer to check for free */

 Indication of start/stop to network */

	/* A sixteen entry transmit queue

 index to get next buffer to tx */

 index to queue next packet */

 The queue */

/*      Per card information

 Card memory mapped to kernel space */

 Control memory for PCI cards */

 Physical memory window address */

 Physical control memory address */

 Interrupt request line number */

 Number of serial ports */

 Type index of card */

 State of card */

 Lock for SMP access */

 PCI card config in I/O space */

 Per port info */

 Information about the pci device */

 Inst of the card on the system */

 TxP or TxU */

 Convert an HDLC device pointer into a port info pointer and similar */

/*      Shared memory window access macros

 *

 *      We have a nice memory based structure above, which could be directly

 *      mapped on i386 but might not work on other architectures unless we use

 *      the readb,w,l and writeb,w,l macros. Unfortunately these macros take

 *      physical offsets so we have to convert. The only saving grace is that

 *      this should all collapse back to a simple indirection eventually.

/*      Debug support

/* Most common debug activity is to print something if the corresponding bit

 * is set in the debug mask. Note: this uses a non-ANSI extension in GCC to

 * support variable numbers of macro parameters. The inverted if prevents us

 * eating someone else's else clause.

/*      PCI ID lookup table

 End */

/*      Device Driver Work Queues

 *

 *      So that we don't spend too much time processing events in the

 *      Interrupt Service routine, we will declare a work queue per Card

 *      and make the ISR schedule a task in the queue for later execution.

 *      In the 2.4 Kernel we used to use the immediate queue for BH's

 *      Now that they are gone, tasklets seem to be much better than work

 *      queues.

	/* Grab the queue exclusively

	/* Making an entry in the queue is simply a matter of setting

	 * a bit for the card indicating that there is work to do in the

	 * bottom half for the card.  Note the limitation of 64 cards.

	 * That ought to be enough

	/* Grab the queue exclusively

	/* Call the bottom half for each card with work waiting

	/* Grab the queue exclusively

	/* Call the bottom half for each card with work waiting

/*      Card control functions

 *      ======================

/*      Place the processor in reset state

 *

 * Used to be a simple write to card control space but a glitch in the latest

 * AMD Am186CH processor means that we now have to do it by asserting and de-

 * asserting the PLX chip PCI Adapter Software Reset. Bit 30 in CNTRL register

 * at offset 9052_CNTRL.  Note the updates for the TXU.

		/* Assert PLX software reset and Am186 hardware reset

		 * and then deassert the PLX software reset but 186 still in reset

		/* We are delaying here to allow the 9054 to reset itself

		/* We are delaying here to allow the 9054 to reload its eeprom

/*      Release the processor from reset

		/* Force posted writes to complete

		/* Release LRESET DO = 1

		 * Then release Local Hold, DO = 1

/*      Clear the cards interrupt flag

		/* Poke the appropriate PLX chip register (same as enabling interrupts)

/*      Enable card interrupts

/*      Disable card interrupts

/*      Process the result of trying to pass a received frame up the stack

			/* Nothing to do here

/*      Initilaise DMA for PLX 9054

	/* This is only required for the PLX 9054

/*      Tx dma complete interrupt

	/* Everything is now set, just tell the card to go

/* Mark it for our own raw sockets interface

/*      Rx dma complete interrupt

 Reset buffer descriptor */

 Update stats */

 Push upstream */

/*      Receive a frame through the DMA

	/* This routine will setup the DMA and start it

 Copy to here */

 from here */

 for this length */

 In this direction */

	/* We use the dmarx_in_progress flag to flag the channel as busy

 Start the transfer */

/*      Send a frame through the DMA

	/* This routine will setup the DMA and start it.

 Copy from here */

 to here */

 for this length */

 In this direction */

	/* We use the dmatx_in_progress to flag the channel as busy

 Start the transfer */

/*      Issue a Mailbox command for a port.

 *      Note we issue them on a fire and forget basis, not expecting to see an

 *      error and not waiting for completion.

 Wait for any previous command to complete */

/*      Port output signals control

/*      Setup port Rx buffers

/*      Setup port Tx buffers

/*      TE1 Alarm change interrupt event

		/* Lost the link

		/* Link available

/*      Control signal change interrupt event

/*      Log Rx Errors

	/* Increment the appropriate error counter

/*      Rx Error Recovery

	/* Discard buffer descriptors until we see the start of the

	 * next frame.  Note that for long frames this could be in

	 * a subsequent interrupt.

 Discard the terminal buffer */

/*      Rx complete interrupt

 Check we have a buffer to process */

 Get buffer length */

 Discard the CRC */

		/* This seems to happen on the TE1 interface sometimes

		 * so throw the frame away and log the event.

 Return descriptor to card */

	/* Check buffer length and for other errors. We insist on one packet

	 * in one buffer. This simplifies things greatly and since we've

	 * allocated 8K it shouldn't be a real world limitation

 Allocate SKB */

 Return descriptor to card */

	/* We know the length we need to receive, len.

	 * It's not worth using the DMA for reads of less than

	 * FST_MIN_DMA_LEN

 Reset buffer descriptor */

 Update stats */

 Push upstream */

/*      The bottom half to the ISR

 *

	/*  Find a free buffer for the transmit

	 *  Step through each port on this card

			/* There doesn't seem to be a txdone event per-se

			 * We seem to have to deduce it, by checking the DMA_OWN

			 * bit on the next buffer we think we can use

				/* This is the case where one has wrapped and the

				 * maths gives us a negative number

				/* There is something to send

				/* copy the data and set the required indicators on the

				 * card.

 Enqueue the packet with normal io */

 Or do it through dma */

				/* If we have flow control on, can we now release it?

				/* Nothing to send so break out of the while loop

 Check for rx completions on all ports on this card */

				/* Don't spend forever in receive processing

				 * Schedule another event

 Leave the loop */

/*      The interrupt service routine

 *      Dev_id is our fst_card_info pointer

 Event buffer indices */

 Actual event for processing */

	/* Check to see if the interrupt was for this card

	 * return if not

	 * Note that the call to clear the interrupt is important

		/* It is possible to really be running, i.e. we have re-loaded

		 * a running card

		 * Clear and reprime the interrupt source

 Clear and reprime the interrupt source */

	/* Is the interrupt for this card (handshake == 1)

 Set the software acknowledge */

		/* Is it a DMA Interrupt

			/* DMA Channel 0 (Rx transfer complete)

			/* DMA Channel 1 (Tx transfer complete)

	/* Have we been missing Interrupts

 Scehdule the bottom half of the ISR */

 Drain the event queue */

			/* Difficult to see how we'd get this given that we

			 * always load up the entire packet for DMA.

 Bump and wrap the index */

/*      Check that the shared memory configuration is one that we can handle

 *      and that some basic parameters are correct

 Check structure version and end marker */

 Firmware status flag, 0x00 = initialising, 0x01 = OK, 0xFF = fail */

	/* Finally check the number of ports reported by firmware against the

	 * number we assumed at card detection. Should never happen with

	 * existing firmware etc so we just report it for the moment.

	/* Set things according to the user set valid flags

	 * Several of the old options have been invalidated/replaced by the

	 * generic hdlc package.

	/* Only mark information as valid if card is running.

	 * Copy the data anyway in case it is useful for diagnostics

	/* The T2U can report cable presence for both A or B

	 * in bits 0 and 1 of cableStatus.  See which port we are and

	 * do the mapping.

			/* Port A

			/* Port B

	/* Some additional bits if we are TE1

	/* First check what line type is set, we'll default to reporting X.21

	 * if nothing is set as IF_IFACE_SYNC_SERIAL implies it can't be

	 * changed

 only type requested */

 Lucky card and linux use same encoding here */

 Code write (download) */

		/* First copy in the header with the length and offset of data

		 * to write

		/* Sanity check the parameters. We don't support partial writes

		 * when going over the top

 Now copy the data to the card. */

		/* Writes to the memory of a card in the reset state constitute

		 * a download

		/* If card has just been started check the shared memory config

		 * version and marker

 If everything checked out enable card interrupts */

		/* Most of the settings have been moved to the generic ioctls

		 * this just covers debug and board ident now

	/* Only init things if card is actually running. This allows open to

	 * succeed for downloads etc.

	/* Setting currently fixed in FarSync card so we check and forget

 Drop packet with error if we don't have carrier */

 Drop it if it's too big! MTU failure ? */

	/* We are always going to queue the packet

	 * so that the bottom half is the only place we tx from

	 * Check there is room in the port txq

		/* This is the case where the next free has wrapped but the

		 * last used hasn't

		/* We have got enough buffers in the pipeline.  Ask the network

		 * layer to stop sending frames down

 I'm using this to signal stop sent up */

		/* This shouldn't have happened but such is life

	/* queue the buffer

 Scehdule the bottom half which now does transmit processing */

/*      Card setup having checked hardware resources.

 *      Should be pretty bizarre if we get an error here (kernel memory

 *      exhaustion is one possibility). If we do see a problem we report it

 *      via a printk and leave the corresponding interface and all that follow

 *      disabled.

 Should never be seen */

	/* We're working on a number of ports based on the card ID. If the

	 * firmware detects something different later (should never happen)

	 * we'll have to revise it in some way then.

/*      Initialise card when detected.

 *      Returns 0 to indicate success, or errno otherwise.

	/* We are going to be clever and allow certain cards not to be

	 * configured.  An exclude list can be provided in /etc/modules.conf

		/* There are cards to exclude

		 *

 Allocate driver private data */

 Try to enable the device */

 Get virtual addresses of memory regions */

 Register the interrupt handler */

 Record info we need */

 Fill in the net device info */

		/* Since this is a PCI setup this is purely

		 * informational. Give them the buffer addresses

		 * and basic card I/O.

 Reset the card's processor */

 Initialise DMA (if required) */

 Record driver data for later use */

 Remainder of card setup */

 Record instance and bump it */

		/* Allocate a dma buffer for transmit and receives

 Success */

/*      Cleanup and close down a card

		/* Free dma buffers

 SPDX-License-Identifier: GPL-2.0-or-later

 $Id: cosa.c,v 1.31 2000/03/08 17:47:16 kas Exp $ */

/*  Copyright (C) 1995-1997  Jan "Yenya" Kasprzak <kas@fi.muni.cz>

 *  Generic HDLC port Copyright (C) 2008 Krzysztof Halasa <khc@pm.waw.pl>

/* The driver for the SRP and COSA synchronous serial cards.

 *

 * HARDWARE INFO

 *

 * Both cards are developed at the Institute of Computer Science,

 * Masaryk University (https://www.ics.muni.cz/). The hardware is

 * developed by Jiri Novotny <novotny@ics.muni.cz>. More information

 * and the photo of both cards is available at

 * http://www.pavoucek.cz/cosa.html. The card documentation, firmwares

 * and other goods can be downloaded from ftp://ftp.ics.muni.cz/pub/cosa/.

 * For Linux-specific utilities, see below in the "Software info" section.

 * If you want to order the card, contact Jiri Novotny.

 *

 * The SRP (serial port?, the Czech word "srp" means "sickle") card

 * is a 2-port intelligent (with its own 8-bit CPU) synchronous serial card

 * with V.24 interfaces up to 80kb/s each.

 *

 * The COSA (communication serial adapter?, the Czech word "kosa" means

 * "scythe") is a next-generation sync/async board with two interfaces

 * - currently any of V.24, X.21, V.35 and V.36 can be selected.

 * It has a 16-bit SAB80166 CPU and can do up to 10 Mb/s per channel.

 * The 8-channels version is in development.

 *

 * Both types have downloadable firmware and communicate via ISA DMA.

 * COSA can be also a bus-mastering device.

 *

 * SOFTWARE INFO

 *

 * The homepage of the Linux driver is at https://www.fi.muni.cz/~kas/cosa/.

 * The CVS tree of Linux driver can be viewed there, as well as the

 * firmware binaries and user-space utilities for downloading the firmware

 * into the card and setting up the card.

 *

 * The Linux driver (unlike the present *BSD drivers :-) can work even

 * for the COSA and SRP in one computer and allows each channel to work

 * in one of the two modes (character or network device).

 *

 * AUTHOR

 *

 * The Linux driver was written by Jan "Yenya" Kasprzak <kas@fi.muni.cz>.

 *

 * You can mail me bugfixes and even success reports. I am especially

 * interested in the SMP and/or muliti-channel success/failure reports

 * (I wonder if I did the locking properly :-).

 *

 * THE AUTHOR USED THE FOLLOWING SOURCES WHEN PROGRAMMING THE DRIVER

 *

 * The COSA/SRP NetBSD driver by Zdenek Salvet and Ivos Cernohlavek

 * The skeleton.c by Donald Becker

 * The SDL Riscom/N2 driver by Mike Natale

 * The Comtrol Hostess SV11 driver by Alan Cox

 * The Sync PPP/Cisco HDLC layer (syncppp.c) ported to Linux by Alan Cox

 for testing purposes only */

 Maximum length of the identification string. */

 Maximum length of the channel name */

 Per-channel data structure */

 Usage count; >0 for chrdev, -1 for netdev */

 Number of the channel */

 Pointer to the per-card structure */

 Size of transmitted data */

 Transmit buffer */

 channel name */

 The HW layer interface */

 routine called from the RX interrupt */

 routine called when the RX is done (from the EOT interrupt) */

 routine called when the TX is done (from the EOT interrupt) */

 Character device parts */

 generic HDLC device parts */

 cosa->firmware_status bits */

 Is the ROM monitor active? */

 Is the microcode downloaded? */

 Is the microcode running? */

 Card number */

 Card name - e.g "cosa0" */

 I/O ports */

 IRQ and DMA number */

 Firmware start address */

 Use busmastering? */

 # of channels on this card */

 For communicating with firmware */

 Downloaded, reseted, etc. */

 Bitmap of channels who are willing to send/receive data */

 RX or TX in progress? */

 usage count */

 For exclusive operations on this structure */

 ROM monitor ID string */

 card type */

/* Define this if you want all the possible ports to be autoprobed.

 * It is here but it probably is not a good idea to use this.

 #define COSA_ISA_AUTOPROBE	1*/

/* Character device major number. 117 was allocated for us.

 * The value of 0 means to allocate a first free one.

/* Encoding of the minor numbers:

 * The lowest CARD_MINOR_BITS bits means the channel on the single card,

 * the highest bits means the card number.

#define CARD_MINOR_BITS	4	/* How many bits in minor number are reserved

				 * for the single card

/* The following depends on CARD_MINOR_BITS. Unfortunately, the "MODULE_STRING"

 * macro doesn't like anything other than the raw number as an argument :-(

 #define MAX_CARDS	(1 << (8-CARD_MINOR_BITS)) */

 FIXME: 0xfc for 8-channel version */

/* for cosa->rxtx - indicates whether either transmit or receive is

 * in progress. These values are mean number of the bit.

 FIXME: I don't know this exactly */

1	/* Dump the data read or written to the channel */

1	/* Print the message when the IRQ is received */

1	/* Dump the I/O traffic */

 Maybe the following should be allocated dynamically */

 NOTE: DMA is not autoprobed!!! */

 IRQ can be safely autoprobed */

 for class stuff*/

 I use this mainly for testing purposes */

 Initialization stuff */

 HW interface */

 Network device stuff */

 Character device */

 Ioctls */

 COSA/SRP ROM monitor */

 Auxiliary functions */

 Interrupt handling */

 I/O ops debugging */

 ---------- Initialization stuff ---------- */

 Clean up the per-channel data */

 Chardev driver has no alloc'd per-channel data */

 Clean up the per-card data */

 Checking validity of parameters: */

 IRQ should be 2-7 or 10-15; negative IRQ means autoprobe */

	/* I/O address should be between 0x100 and 0x3ff and should be

	 * multiple of 8.

 DMA should be 0,1 or 3-7 */

	/* and finally, on 16-bit COSA DMA should be 4-7 and

	 * I/O base should not be multiple of 0x10

 Test the validity of identification string */

 Print a warning only if we are not autoprobing */

 Update the name of the region now we know the type of card */

 Now do IRQ autoprobe */

		pr_info("IRQ autoprobe\n"); */

		/* Enable interrupt on tx buffer empty (it sure is)

		 * really sure ?

		 * FIXME: When this code is not used as module, we should

		 * probably call udelay() instead of the interruptible sleep.

 Disable all IRQs from the card */

 Empty the received data register */

	return -1; */

 FIXME: how to determine this? */

 Initialize the per-channel data */

 Initialize the chardev data structures */

 Register the network interface */

---------- network device ---------- */

	/* We can safely fall back to non-dma-able memory, because we have

	 * the cosa->bouncebuf pre-allocated.

 ARGSUSED */

---------- Character device ---------- */

 Expect size <= COSA_MTU */

 Reader has died */

 Allocate the buffer */

 Writer was interrupted */

 in netdev mode */

 To be done ... */

 ---------- Ioctls ---------- */

/* Ioctl subroutines can safely be made inline, because they are called

 * only from cosa_ioctl().

 High-level function to download data into COSA memory. Calls download() */

 If something fails, force the user to reset the card */

 High-level function to read COSA memory. Calls readmem() */

 If something fails, force the user to reset the card */

 High-level function to start microcode. Calls startmicrocode(). */

 Buffer of size at least COSA_MAX_ID_STRING is expected */

 Buffer of size at least COSA_MAX_ID_STRING is expected */

 Reset the device */

 Start the firmware */

 Download the firmware */

---------- HW layer interface ---------- */

/* The higher layer can bind itself to the HW layer by setting the callbacks

 * in the channel_data structure and by using these routines.

/* FIXME: This routine probably should check for cosa_start_tx() called when

 * the previous transmit is still unfinished. In this case the non-zero

 * return value should indicate to the caller that the queuing(sp?) up

 * the transmit has failed.

 Tell the firmware we are ready */

/* The "kickme" function: When the DMA times out, this is called to

 * clean up the driver status.

 * FIXME: Preliminary support, the interface is probably wrong.

 FIXME: Anything else? */

/* Check if the whole buffer is DMA-able. It means it is below the 16M of

 * physical memory and doesn't span the 64k boundary. For now it seems

 * SKB's never do this, but we'll check this anyway.

 ---------- The SRP/COSA ROM monitor functions ---------- */

/* Downloading SRP microcode: say "w" to SRP monitor, it answers by "w=",

 * drivers need to say 4-digit hex number meaning start address of the microcode

 * separated by a single space. Monitor replies by saying " =". Now driver

 * has to write 4-digit hex number meaning the last byte address ended

 * by a single space. Monitor has to reply with a space. Now the download

 * begins. After the download monitor replies with "\r\n." (CR LF dot).

 ??? */

/* Starting microcode is done via the "g" command of the SRP monitor.

 * The chat should be the following: "g" "g=" "<addr><CR>"

 * "<CR><CR><LF><CR><LF>".

/* Reading memory is done via the "r" command of the SRP monitor.

 * The chat is the following "r" "r=" "<addr> " " =" "<last_byte> " " "

 * Then driver can read the data and the conversation is finished

 * by SRP monitor sending "<CR><LF>." (dot at the end).

 *

 * This routine is not needed during the normal operation and serves

 * for debugging purposes only.

 ??? */

/* This function resets the device and reads the initial prompt

 * of the device's ROM monitor.

 Reset the card ... */

 Disable all IRQs from the card */

	/* Try to read the ID string. The card then prints out the

	 * identification string ended by the "\n\x2e".

	 *

	 * The following loop is indexed through i (instead of id)

	 * to avoid looping forever when for any reason

	 * the port returns '\r', '\n' or '\x2e' permanently.

 Perhaps we should fail when i==COSA_MAX_ID_STRING-1 ? */

 ---------- Auxiliary routines for COSA/SRP monitor ---------- */

/* This routine gets the data byte from the card waiting for the SR_RX_RDY

 * bit to be set in a loop. It should be used in the exceptional cases

 * only (for example when resetting the card or downloading the firmware.

 read data and return them */

 sleep if not ready to read */

/* This routine puts the data byte to the card waiting for the SR_TX_RDY

 * bit to be set in a loop. It should be used in the exceptional cases

 * only (for example when resetting the card or downloading the firmware).

 read data and return them */

 sleep if not ready to read */

/* The following routine puts the hexadecimal number into the SRP monitor

 * and verifies the proper echo of the sent bytes. Returns 0 on success,

 * negative number on failure (-1,-3,-5,-7) means that put_wait_data() failed,

 * (-2,-4,-6,-8) means that reading echo failed.

 Well, I should probably replace this by something faster. */

 ---------- Interrupt routines ---------- */

/* There are three types of interrupt:

 * At the beginning of transmit - this handled is in tx_interrupt(),

 * at the beginning of receive - it is in rx_interrupt() and

 * at the end of transmit/receive - it is the eot_interrupt() function.

 * These functions are multiplexed by cosa_interrupt() according to the

 * COSA status byte. I have moved the rx/tx/eot interrupt handling into

 * separate functions to make it more readable. These functions are inline,

 * so there should be no overhead of function call.

 *

 * In the COSA bus-master mode, we need to tell the card the address of a

 * buffer. Unfortunately, COSA may be too slow for us, so we must busy-wait.

 * It's time to use the bottom half :-(

/* Transmit interrupt routine - called when COSA is willing to obtain

 * data from the OS. The most tricky part of the routine is selection

 * of channel we (OS) want to send packet for. For SRP we should probably

 * use the round-robin approach. The newer COSA firmwares have a simple

 * flow-control - in the status word has bits 2 and 3 set to 1 means that the

 * channel 0 or 1 doesn't want to receive data.

 *

 * It seems there is a bug in COSA firmware (need to trace it further):

 * When the driver status says that the kernel has no more data for transmit

 * (e.g. at the end of TX DMA) and then the kernel changes its mind

 * (e.g. new packet is queued to hard_start_xmit()), the card issues

 * the TX interrupt but does not mark the channel as ready-to-transmit.

 * The fix seems to be to push the packet to COSA despite its request.

 * We first try to obey the card's opinion, and then fall back to forced TX.

 flow control, see the comment above */

 in second pass, accept first ready-to-TX channel */

 Can be safely ignored */

 start the DMA */

 Reject the packet */

 start the DMA */

 Packet for unknown channel? */

	/* Clear the RXBIT, TXBIT and IRQBIT (the latest should be

	 * cleared anyway). We should do it as soon as possible

	 * so that we can tell the COSA we are done and to give it a time

	 * for recovery.

 We may be too fast for SRP. Try to wait a bit more. */

 ---------- I/O debugging routines ---------- */

/* These routines can be used to monitor COSA/SRP I/O and to printk()

 * the data being transferred on the data and status I/O port in a

 * readable way.

 EOF -- this file has not been truncated */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Generic HDLC support routines for Linux

 *

 * Copyright (C) 1999 - 2008 Krzysztof Halasa <khc@pm.waw.pl>

 *

 * Currently supported:

 *	* raw IP-in-HDLC

 *	* Cisco HDLC

 *	* Frame Relay with ANSI or CCITT LMI (both user and network side)

 *	* PPP

 *	* X.25

 *

 * Use sethdlc utility to set line parameters, protocol and PVCs

 *

 * How does it work:

 * - proto->open(), close(), start(), stop() calls are serialized.

 *   The order is: open, [ start, stop ... ] close ...

 * - proto->start() and stop() are called with spin_lock_irq held.

 First make sure "dev" is an HDLC device */

 call hardware driver directly */

 not an HDLC device */

 Only interested in carrier changes */

 no change in DCD line level */

 Must be called by hardware driver when HDLC device is being opened */

 no protocol attached */

 Must be called by hardware driver when HDLC device is being closed */

 Not handled by currently attached protocol (if any) */

	/* Re-init all variables changed by HDLC protocol drivers,

	 * including ether_setup() called from hdlc_raw_eth.c.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Generic HDLC support routines for Linux

 * HDLC support

 *

 * Copyright (C) 1999 - 2006 Krzysztof Halasa <khc@pm.waw.pl>

 data size wanted */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Hitachi (now Renesas) SCA-II HD64572 driver for Linux

 *

 * Copyright (C) 1998-2008 Krzysztof Halasa <khc@pm.waw.pl>

 *

 * Source of information: HD64572 SCA-II User's Manual

 *

 * We use the following SCA memory map:

 *

 * Packet buffer descriptor rings - starting from card->rambase:

 * rx_ring_buffers * sizeof(pkt_desc) = logical channel #0 RX ring

 * tx_ring_buffers * sizeof(pkt_desc) = logical channel #0 TX ring

 * rx_ring_buffers * sizeof(pkt_desc) = logical channel #1 RX ring (if used)

 * tx_ring_buffers * sizeof(pkt_desc) = logical channel #1 TX ring (if used)

 *

 * Packet data buffers - starting from card->rambase + buff_offset:

 * rx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 RX buffers

 * tx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 TX buffers

 * rx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 RX buffers (if used)

 * tx_ring_buffers * HDLC_MAX_MRU     = logical channel #0 TX buffers (if used)

 enable DMIB and MSCI RXINTA interrupts */

 called with "X + 1" etc.

 Descriptor offset always fits in 16 bits */

 DMA disable - to halt state */

 software ABORT - to initial state */

 current desc addr */

 clear frame end interrupt counter */

 Receive */

 set buffer length */

 Chain mode, Multi-frame */

 enable interrupts */

 DMA enable */

 Transmit */

 Chain mode, Multi-frame */

 enable interrupts */

 MSCI interrupt service */

 Reset MSCI CDCD status bit */

 Receive DMA service */

 read DMA Status */

 Reset DSR status bits */

 Dropped one or more frames */

 No frame received */

 partial frame received */

 received last fragment */

 Set new error descriptor address */

 make sure RX DMA is enabled */

 Transmit DMA service */

 read DMA Status */

 Reset DSR status bits */

 not yet transmitted */

 Free descriptor */

 Try lower br for better accuracy*/

 brv = 2^9 = 512 max in specs */

 Baud Rate = CLOCK_BASE / TMC / 2^BR */

 For baud=CLOCK_BASE we use tmc=1 br=0 */

 tmc=0 means 256 - low baud rates */

 Minimum clock rate */

 8bit = 0 */

 baud divisor - time constant*/

 Set BRG bits */

 no address field check */

 flag character 0x7E */

 Skip the rest of underrun frame */

 +1=RX DMA activation condition */

 +1 = TX start */

 =Critical TX DMA activ condition */

 =TX DMA activation condition */

 +1=TX DMA deactivation condition*/

/* We're using the following interrupts:

   - RXINTA (DCD changes only)

   - DMIB (EOM - single frame transfer complete)

 reset channel */

 DEBUG_RINGS */

 previous xmit should stop queue */

 Enable TX DMA */

 allow 1 packet gap */

 Round RAM size to 32 bits, fill from end to start */

 Wait Control */

 DMA Master disable */

 DMA priority */

 DMA disable - to halt state */

 DMA Master enable */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Goramo PCI200SYN synchronous serial card driver for Linux

 *

 * Copyright (C) 2002-2008 Krzysztof Halasa <khc@pm.waw.pl>

 *

 * For information see <https://www.kernel.org/pub/linux/utils/net/hdlc/>

 *

 * Sources of information:

 *    Hitachi HD64572 SCA-II User's Manual

 *    PLX Technology Inc. PCI9052 Data Book

 PLX control window size (128b) */

 SCA window size (1Kb) */

/*      PLX PCI9052 local configuration and shared runtime registers.

 *      This structure can be used to access 9052 registers (memory mapped).

 00-0Ch : Local Address Ranges */

 10h : Local ROM Range */

 14-20h : Local Address Base Addrs */

 24h : Local ROM Base */

 28-34h : Local Bus Descriptors */

 38h : ROM Bus Descriptor */

 3C-48h : Chip Select Base Addrs */

 4Ch : Interrupt Control/Status */

 50h : EEPROM ctrl, Init Ctrl, etc */

 TX lock */

 partial frame received, next frame invalid*/

 rx ring buffer 'in' pointer */

 tx ring buffer 'in' and 'last' pointers */

 SCA registers */

 physical port # - 0 or 1 */

 buffer memory base (virtual) */

 SCA memory base (virtual) */

 PLX registers memory base (virtual) */

 number of buffers in a ring */

 offset of first buffer of first channel */

 interrupt request level */

 BRG output */

 RX clock */

 RXC input */

 BRG output */

 RXC input */

 RX clock */

 EXTernal clock */

 RXC input */

 TXC input */

 data size wanted */

 No such clock setting */

 Update settings */

 buffer memory base */

 SCA memory base */

 PLX registers memory base */

 Reset PLX */

 Flush the write - do not use sca_flush */

 Flush the write - do not use sca_flush */

 number of TX + RX buffers for one port - this is dual port card */

 Enable interrupts on the PCI bridge */

 Allocate IRQ */

 SPDX-License-Identifier: GPL-2.0-or-later

/* Freescale QUICC Engine HDLC Device Driver

 *

 * Copyright 2016 Freescale Semiconductor Inc.

	/* This sets HPM register in CMXUCR register which configures a

	 * open drain connected HDLC bus

 Loopback mode */

 use the same clock when work in loopback */

 Initialize SI */

 Write to QE CECR, UCCx channel to Stop Transmission */

 Set UPSMR normal mode (need fixed)*/

 hdlc_bus mode */

		/* bus mode and retransmit enable, with collision window

		 * set to 8 bytes

 explicitly disable CDS & CTSP */

 set automatic sync to explicitly ignore CD signal */

 Alloc Rx BD */

 Alloc Tx BD */

 Alloc parameter ram for ucc hdlc */

 init parameter base */

 Zero out parameter ram */

 Alloc riptr, tiptr */

 Set RIPTR, TIPTR */

 Set MRBLR */

 Set RBASE, TBASE */

 Set RSTATE, TSTATE */

 Set C_MASK, C_PRES for 16bit CRC */

 Get BD buffer */

 Start from the next BD that should be filled */

 Save the skb pointer so we can free it later */

 Update the current skb pointer (wrapping if this was the last) */

 copy skb data to tx buffer for sdma processing */

 set bd status and length */

 Move to next BD in the ring */

 Start from the next BD that should be filled */

 BD pointer */

 Normal processing. */

 Underrun */

 Carrier lost */

 BD contains already transmitted buffer.   */

 Handle the transmitted buffer and release */

 the BD to be used with the current frame  */

 We freed a buffer, so now we can restart transmission */

 Advance the confirmation BD pointer */

 while there are received buffers and BD is full (~R_E) */

 update to point at the next bd */

 Tx event processing */

 Errors and other events */

 data size wanted */

 Enable the TDM port */

 store si clk */

 store si sync */

 store ucc clk */

 backup gumr guemr*/

 backup HDLC parameter */

 store the clk configuration */

 save power */

 restore gumr guemr */

 Set Virtual Fifo registers */

 utfb, urfb are offsets from MURAM base */

 Rx Tx and sync clock routing */

 rebuild SIRAM */

 Write to QE CECR, UCCx channel to Stop Transmission */

 Set UPSMR normal mode */

 init parameter base */

 restore ucc parameter */

 rebuild BD entry */

 if hdlc is busy enable TX and RX */

 Enable the TDM port */

	/* We've remapped the addresses, and we don't need the device any

	 * more, so we should release it.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Intel IXP4xx HSS (synchronous serial port) driver for Linux

 *

 * Copyright (C) 2007-2008 Krzysztof Hałasa <khc@pm.waw.pl>

 orig 1 */

 1, 2 or 4 */

 total 4 dwords per HSS */

 also length of all RX queues */

 also length of all TX queues */

 NPE needs more space */

 microseconds */

 doesn't matter at this point */

 Queue IDs */

 orig size = 32 dwords */

 orig size = 32 dwords */

 orig size = 16 dwords */

 orig size = 16 dwords */

 orig size = 64 dwords */

 PKT_PIPE_HDLC_CFG_WRITE flags */

 default = flags */

 default = CRC-16 */

 default = LE */

 hss_config, PCRs */

 Frame sync sampling, default = active low */

 Frame sync pin: input (default) or output generated off a given clk edge */

 Frame and data clock sampling on edge, default = falling */

 Clock direction, default = input */

 Generate/Receive frame pulses, default = enabled */

 Data rate is full (default) or half the configured clk speed */

 Invert data between NPE and HSS FIFOs? (default = no) */

 TX/RX endianness, default = LSB */

 Normal (default) / open drain mode (TX only) */

 No framing bit transmitted and expected on RX? (default = framing bit) */

 Drive data pins? */

 Voice 56k type: drive the data pins low (default), high, high Z */

 Unassigned type: drive the data pins low (default), high, high Z */

 T1 @ 1.544MHz only: Fbit dictated in FIFO (default) or high Z */

 56k data endiannes - which bit unused: high (default) or low */

 56k data transmission type: 32/8 bit data (default) or 56K data */

 hss_config, cCR */

 Number of packetized clients, default = 1 */

 default = no loopback */

 HSS number, default = 0 (first) */

 hss_config, clkCR: main:10, num:10, denom:12 */

65 KHz*/

/* HSS_CONFIG_CLOCK_CR register consists of 3 parts:

 *     A (10 bits), B (10 bits) and C (12 bits).

 * IXP42x HSS clock generator operation (verified with an oscilloscope):

 * Each clock bit takes 7.5 ns (1 / 133.xx MHz).

 * The clock sequence consists of (C - B) states of 0s and 1s, each state is

 * A bits wide. It's followed by (B + 1) states of 0s and 1s, each state is

 * (A + 1) bits wide.

 *

 * The resulting average clock frequency (assuming 33.333 MHz oscillator) is:

 * freq = 66.666 MHz / (A + (B + 1) / (C + 1))

 * minimum freq = 66.666 MHz / (A + 1)

 * maximum freq = 66.666 MHz / A

 *

 * Example: A = 2, B = 2, C = 7, CLOCK_CR register = 2 << 22 | 2 << 12 | 7

 * freq = 66.666 MHz / (2 + (2 + 1) / (7 + 1)) = 28.07 MHz (Mb/s).

 * The clock sequence is: 1100110011 (5 doubles) 000111000 (3 triples).

 * The sequence takes (C - B) * A + (B + 1) * (A + 1) = 5 * 2 + 3 * 3 bits

 * = 19 bits (each 7.5 ns long) = 142.5 ns (then the sequence repeats).

 * The sequence consists of 4 complete clock periods, thus the average

 * frequency (= clock rate) is 4 / 142.5 ns = 28.07 MHz (Mb/s).

 * (max specified clock rate for IXP42x HSS is 8.192 Mb/s).

 hss_config, LUT entries */

 HDLC - packetized */

 Voice56K - 7-bit channelized */

 Voice64K - 8-bit channelized */

 offsets into HSS config */

 port configuration registers */

 loopback control, HSS# */

 clock generator control */

 frame configuration registers */

 channel look-up tables */

 NPE command codes */

 writes the ConfigWord value to the location specified by offset */

 triggers the NPE to load the contents of the configuration table */

 triggers the NPE to return an HssErrorReadResponse message */

/* triggers the NPE to reset internal status and enable the HssPacketized

 * operation for the flow specified by pPipe

 HDLC packet status values - desc->status */

 stop or shutdown occurrence */

 HDLC alignment error */

 HDLC Frame Check Sum error */

#define ERR_RXFREE_Q_EMPTY	4 /* RX-free queue became empty while receiving

				   * this packet (if buf_len < pkt_len)

 HDLC frame size too long */

 abort sequence received */

 disconnect is in progress */

 coherent */

 NPE message structure */

 HDLC packet descriptor */

 pointer to next buffer, unused */

 buffer length */

 packet length */

 pointer to data buffer in RAM */

 packet length */

 buffer length */

 pointer to data buffer in RAM */

/*****************************************************************************

 * global variables

/*****************************************************************************

 * utility functions

/*****************************************************************************

 * HSS access

 HSS_LOAD_CONFIG for port #1 returns port_id = #4 */

 HDLC may stop working without this - check FIXME */

 rx_cfg */

 tx_cfg */

 make sure it's halted */

 HDLC mode configuration */

 msg.data8b = inv_mask */

 msg.data8c = or_mask */

 including CRC */

 ??? FIXME */

/*****************************************************************************

 * packetized (HDLC) operation

	/* Don't check for queue overflow here, we've allocated sufficient

	 * length and queues >= 32 don't support this check anyway.

 all work done */

 FIXME - error_count counts modulo 256, perhaps we should use it */

 FIXME - remove printk */

 put the desc back on RX-ready queue */

 process received frame */

 put the new buffer on RX-free queue */

 not all work done */

 TX-ready queue was empty */

 no need to keep alignment */

 keep 32-bit alignment */

 empty */

 we could miss TX ready interrupt */

 tables */

 Setup RX buffers */

 Populate queues with buffers, no failure after this point */

 we may already have RX data, enables IRQ */

 allocated RX buffers */

 cancel TX */

 a is 10-bit, b is 10-bit, c is 12-bit */

 10-bit value - we can go as slow as ca. 65 kb/s */

 > 66.666 MHz */

 minimum divider is 1 (a = 0, b = 1, c = 1) */

 don't divide by 0 later */

 12-bit - no need to check more 'b's */

 also try a bit higher rate */

 data size wanted */

 No such clock setting */

 Update settings */

/*****************************************************************************

 * initialization

 SPDX-License-Identifier: GPL-2.0-only

/*	Comtrol SV11 card driver

 *

 *	This is a slightly odd Z85230 synchronous driver. All you need to

 *	know basically is

 *

 *	Its a genuine Z85230

 *

 *	It supports DMA using two DMA channels in SYNC mode. The driver doesn't

 *	use these facilities

 *

 *	The control port is at io+1, the data at io+3 and turning off the DMA

 *	is done by writing 0 to io+4

 *

 *	The hardware does the bus handling to avoid the need for delays between

 *	touching control registers.

 *

 *	Port B isn't wired (why - beats me)

 *

 *	Generic HDLC port Copyright (C) 2008 Krzysztof Halasa <khc@pm.waw.pl>

/*	Network driver support routines

/*	Frame receive. Simple for our card as we do HDLC and there

 *	is no funny garbage involved

 Drop the CRC - it's not a good idea to try and negotiate it ;) */

	/*	Send it to the PPP layer. We don't have time to process

	 *	it right now.

/*	We've been placed in the UP state

	/*	Link layer up

	/*

	 *	Go go go

	/*	Discard new frames

/*	Passed network frames, fire them downwind.

/*	Description block for a Comtrol Hostess SV11 card

	/*	Get the needed I/O space

	/*	Stuff in the I/O addressing

 DMA off */

	/* We want a fast IRQ for this device. Actually we'd like an even faster

	 * IRQ ;) - This is one driver RtLinux is made for

		/*	You can have DMA off or 1 and 3 thats the lot

		 *	on the Comtrol.

 DMA on */

	/* Kill our private IRQ line the hostess can end up chattering

	 * until the configuration is set

	/*	Begin normal initialise

	/*	Now we can take the IRQ

 SPDX-License-Identifier: GPL-2.0-only

/*

 * wanXL serial card driver for Linux

 * host part

 *

 * Copyright (C) 2003 Krzysztof Halasa <khc@pm.waw.pl>

 *

 * Status:

 *   - Only DTE (external clock) support with NRZ and NRZI encodings

 *   - wanXL100 will require minor driver modifications, no access to hw

 adapter reset */

 MAILBOX #1 - PUTS COMMANDS */

 Abort and Jump */

 little-endian Byte Swap Mode */

 big-endian Byte Swap Mode */

 MAILBOX #2 - DRAM SIZE */

 PUTS Memory Size Register mask */

 for wanxl_xmit */

 physical port #0 - 3 */

 1, 2 or 4 ports */

 PLX PCI9060 virtual base address */

 for pci_name(pdev) */

 shared between host and card */

 1 - 4 port structures follow */

 Cable and/or personality module change interrupt service */

 Transmit complete interrupt service */

 Free descriptor */

 Receive complete interrupt service */

 Free descriptor */

 should never happen - previous xmit should stop queue */

 request packet to be queued */

 data size wanted */

 No such clock setting */

 signal the card */

 ask the card to close the port, should it be still alive */

 signal the card */

 wait for posted write */

 wait for posted write */

 unregister and free all host resources */

 PLX PCI base address */

 memory PCI base addr */

 memory virtual base addr */

	/* QUICC can only access first 256 MB of host RAM directly,

	 * but PLX9060 DMA does 32-bits for actual packet data transfers

	/* FIXME when PCI/DMA subsystems are fixed.

	 * We set both dma_mask and consistent_dma_mask to 28 bits

	 * and pray pci_alloc_consistent() will use this info. It should

	 * work on most platforms

	/* FIXME when PCI/DMA subsystems are fixed.

	 * We set both dma_mask and consistent_dma_mask back to 32 bits

	 * to indicate the card can do 32-bit DMA addressing

 set up PLX mapping */

 hmm - PUTS completed with non-zero code? */

 PUTS still testing the hardware */

 get on-board memory size (PUTS detects no more than 4 MB) */

 set up on-board RAM mapping */

 sanity check the board's reported memory size */

 Allocate IRQ */

 get carrier status etc.*/

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/net/wan/slic_ds26522.c

 *

 * Copyright (C) 2016 Freescale Semiconductor, Inc.

 *

 * Author:Zhao Qiang<qiang.zhao@nxp.com>

/* the read/write format of address is

 * w/r|A13|A12|A11|A10|A9|A8|A7|A6|A5|A4|A3|A2|A1|A0|x

 write spi addr and value */

 Receive E1 Mode, Framer Disabled */

 Transmit E1 Mode, Framer Disable */

 Receive E1 Mode Framer Enable */

 Transmit E1 Mode Framer Enable */

 RCR1, receive E1 B8zs & ESF */

 RSYSCLK=2.048MHz, RSYNC-Output */

 TCR1 Transmit E1 b8zs */

 TSYSCLK=2.048MHz, TSYNC-Output */

 Set E1TAF */

 Set E1TNAF register */

 Receive E1 Mode Framer Enable & init Done */

 Transmit E1 Mode Framer Enable & init Done */

 Configure LIU E1 mode */

 E1 Mode default 75 ohm w/Transmit Impedance Matlinking */

 E1 Mode default 75 ohm Long Haul w/Receive Impedance Matlinking */

 Enable Transmit output */

 set clock */

 set gtcr */

 Global LIU Software Reset Register */

 Global Framer and BERT Software Reset Register */

 Perform RX/TX SRESET,Reset receiver */

 Reset tranceiver */

 Zero all Framer Registers */

 setup ds26522 for E1 specification */

 sentinel */ },

 SPDX-License-Identifier: GPL-2.0-or-later

/*	Sealevel Systems 4021 driver.

 *

 *	(c) Copyright 1999, 2001 Alan Cox

 *	(c) Copyright 2001 Red Hat Inc.

 *	Generic HDLC port Copyright (C) 2008 Krzysztof Halasa <khc@pm.waw.pl>

	Network driver support routines */

/*	Frame receive. Simple for our card as we do HDLC and there

 *	is no funny garbage involved

 Drop the CRC - it's not a good idea to try and negotiate it ;) */

	We've been placed in the UP state */

	Link layer up. */

	Discard new frames */

	Passed network frames, fire them downwind. */

	Allocate and setup Sealevel board. */

	Get the needed I/O space */

	Stuff in the I/O addressing */

	Select 8530 delays for the old board */

	Assert DTR enable DMA */

	/* We want a fast IRQ for this device. Actually we'd like an even faster

	 * IRQ ;) - This is one driver RtLinux is made for

	Begin normal initialise */

	Now we can take the IRQ */

 DMA off on the card, drop DTR */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * SDL Inc. RISCom/N2 synchronous serial card driver for Linux

 *

 * Copyright (C) 1998-2003 Krzysztof Halasa <khc@pm.waw.pl>

 *

 * For information see <https://www.kernel.org/pub/linux/utils/net/hdlc/>

 *

 * Note: integrated CSU/DSU/DDS are not supported by this driver

 *

 * Sources of information:

 *    Hitachi HD64570 SCA User's Manual

 *    SDL Inc. PPP/HDLC/CISCO driver

 9.8304 MHz */

 16 RAM pages at max */

 512 KB */

 pointer to hw=xxx command line string */

 RISCom/N2 Board Registers */

 PC Control Register */

 Run 64570 */

 Enable VPM - needed if using RAM above 1 MB */

 Open window */

 16-bit bus */

 Memory Base Address Register */

 Page Scan Register  */

 Modem Control Reg */

 TX lock */

 port enabled */

 partial frame received, next frame invalid*/

 rx ring buffer 'in' pointer */

 tx ring buffer 'in' and 'last' pointers */

 SCA registers */

 physical port # - 0 or 1 */

 logical port # */

 ISA window base address */

 ISA physical base address */

 number of bytes */

 IO Base address */

 offset of first buffer of first channel */

 number of buffers in a ring */

 IRQ (3-15) */

 BRG output */

 RX clock */

 RXC input */

 BRG output */

 RXC input */

 RX clock */

 Clock EXTernal */

 RXC input */

 TXC input */

 set DTR ON */

 open window */

 enable dma */

 set DTR OFF */

 data size wanted */

 No such clock setting */

 Update settings */

 FIXME */ {

 number of TX + RX buffers for one port */

 run SCA */

 Set up SCA memory */

 no parameters specified, abort */

 Default = both ports disabled */

 Port 0 enabled */

 Port 1 enabled */

 at least one port must be used */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *	"LAPB via ethernet" driver release 001

 *

 *	This code REQUIRES 2.1.15 or higher/ NET3.038

 *

 *	This is a "pseudo" network driver to allow LAPB over Ethernet.

 *

 *	This driver can use any ethernet destination address, and can be

 *	limited to accept frames from one dedicated ethernet card only.

 *

 *	History

 *	LAPBETH 001	Jonathan Naylor		Cloned from bpqether.c

 *	2000-10-29	Henner Eisen	lapb_data_indication() return status.

 *	2000-11-14	Henner Eisen	dev_hold/put, NETDEV_GOING_DOWN support

/* If this number is made larger, check that the temporary string buffer

 * in lapbeth_new_device is large enough to store the probe device name.

 link to ethernet device */

 lapbeth device (lapb#) */

 Protects "up" */

 ------------------------------------------------------------------------ */

/*	Get the LAPB device for the ethernet device

 ------------------------------------------------------------------------ */

/*	Receive a LAPB frame via an ethernet interface.

 Remove the length bytes */

 Set the length of the data */

/*	Send a LAPB frame via an ethernet interface

	/* There should be a pseudo header of 1 byte added by upper layers.

	 * Check to make sure it is there before reading it.

/*	Set AX.25 callsign

/* open/close a device

 ------------------------------------------------------------------------ */

/*	Setup a new device.

	/* When transmitting data:

	 * first this driver removes a pseudo header of 1 byte,

	 * then the lapb module prepends an LAPB header of at most 3 bytes,

	 * then this driver prepends a length field of 2 bytes,

	 * then the underlying Ethernet device prepends its own header.

/*	Free a lapb network device.

/*	Handle device status changes.

 *

 * Called from notifier with RTNL held.

 New ethernet device -> new LAPB interface	 */

 ethernet device closes -> close LAPB interface */

 ethernet device disappears -> remove LAPB interface */

 ------------------------------------------------------------------------ */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Moxa C101 synchronous serial card driver for Linux

 *

 * Copyright (C) 2000-2003 Krzysztof Halasa <khc@pm.waw.pl>

 *

 * For information see <https://www.kernel.org/pub/linux/utils/net/hdlc/>

 *

 * Sources of information:

 *    Hitachi HD64570 SCA User's Manual

 *    Moxa C101 User's Manual

 9.8304 MHz */

 pointer to hw=xxx command line string */

 TX lock */

 ISA window base address */

 ISA physical base address */

 partial frame received, next frame invalid*/

 number of buffers in a ring */

 offset of first buffer of first channel */

 rx ring buffer 'in' pointer */

 tx ring buffer 'in' and 'last' pointers */

 SCA registers */

 IRQ (3-15) */

 EDA address register must be set in EDAL, EDAH order - 8 bit ISA bus */

 read MSCI ST1 status */

 Reset MSCI TX underrun and CDCD (ignored) status bit */

 TX Underrun error detected */

 read MSCI1 ST1 status */

 Reset MSCI CDCD status bit - uses ch#2 DCD input */

 TX clock */

 BRG output */

 RXC input */

 BRG output */

 RXC input */

 RX clock */

 EXTernal clock */

 RXC input */

 TXC input */

 RTS uses ch#2 output */

 DCD is connected to port 2 !@#$%^& - disable MSCI0 CDCD interrupt */

 enable MSCI1 CDCD interrupt */

 TXINT #0 and RXINT #1 */

 data size wanted */

 No such clock setting */

 Update settings */

 Resets SCA? */

 FIXME */ {

 Bytes 1D00-1FFF reserved */

 Resets SCA? */

 Power-up for RAM? */

 Set up C101 memory */

 no parameters specified, abort */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Generic HDLC support routines for Linux

 * Frame Relay support

 *

 * Copyright (C) 1999 - 2006 Krzysztof Halasa <khc@pm.waw.pl>

 *



	Theory of PVC state



 DCE mode:



 (exist,new) -> 0,0 when "PVC create" or if "link unreliable"

	 0,x -> 1,1 if "link reliable" when sending FULL STATUS

	 1,1 -> 1,0 if received FULL STATUS ACK



 (active)    -> 0 when "ifconfig PVC down" or "link unreliable" or "PVC create"

	     -> 1 when "PVC up" and (exist,new) = 1,0



 DTE mode:

 (exist,new,active) = FULL STATUS if "link reliable"

		    = 0, 0, 0 if "link unreliable"

 No LMI:

 active = open and "link reliable"

 exist = new = not used



 CCITT LMI: ITU-T Q.933 Annex A

 ANSI LMI: ANSI T1.617 Annex D

 CISCO LMI: the original, aka "Gang of Four" LMI



 LMI DLCI */

 Call Reference */

 ANSI locking shift */

 report type */

 keep alive */

 PVC status */

 full report  */

 link integrity report */

 single PVC report */

 reply */

 report type element length */

 link integrity element length */

 LMI frame lengths */

 bridged Ethernet interface	*/

 Sorted in ascending DLCI order */

 Cisco LMI reporting only */

 last errors bit list */

 TX sequence number */

 RX sequence number */

 the list is sorted */

 the list is sorted */

 Put it in the chain */

 Control packets */

 OUI 00-00-00 indicates an Ethertype follows */

 This should be an Ethertype: */

 OUI 00-80-C2 stands for the 802.1 organization */

 PID 00-07 stands for Ethernet frames without FCS */

 Frad must be UP in order to activate PVC */

 data size wanted */

 Pad the frame with zeros */

	/* We already requested the header space with dev->needed_headroom.

	 * So this is just a protection in case the upper layer didn't take

	 * dev->needed_headroom into consideration.

 TX Congestion counter */

 LMI start/restart */

 ifconfig PVC up */

 Request full status */

 Activate all PVCs */

 Deactivate all PVCs */

 Shift the list */

 errors count */

 TX sequence from peer */

 Should confirm our sequence */

 Ask for full report next time */

 Stop sending full report - the last one has been confirmed by DTE */

 Tell DTE that new PVC is now active */

 got request */

 DTE */

 got response, no request pending */

 Next full report after N391 polls */

 OUI 00-00-00 indicates an Ethertype follows */

 Ethertype */

 OUI 00-80-C2 stands for the 802.1 organization */

 PID 00-07 stands for Ethernet frames without FCS */

 PID unsupported */

 OUI unsupported */

 Remove 4-byte header (hdr, UI, NLPID) */

 Remove 4-byte header (hdr, UI, NLPID) */

 A SNAP header follows */

 Incomplete SNAP header */

 PVC traffic */

 Mark error */

 First poll after 1 s */

 Shutdown all PVCs for this FRAD */

 PVC in use */

 the destructor will free_netdev(dev) */

 All PVCs destroyed */

 destructors will free_netdev() main and ether */

 Different proto */

 data size wanted */

 Different proto */

 Different proto */

 Only 10 bits, DLCI 0 reserved */

 bridged Ethernet device */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Cyclades PC300 synchronous serial card driver for Linux

 *

 * Copyright (C) 2000-2008 Krzysztof Halasa <khc@pm.waw.pl>

 *

 * For information see <https://www.kernel.org/pub/linux/utils/net/hdlc/>.

 *

 * Sources of information:

 *    Hitachi HD64572 SCA-II User's Manual

 *    Original Cyclades PC300 Linux driver

 *

 * This driver currently supports only PC300/RSV (V.24/V.35) and

 * PC300/X21 cards.

 PLX control window size (128 B) */

 SCA window size (1 KB) */

 Masks to access the init_ctrl PLX register */

 card types */

/*      PLX PCI9050-1 local configuration and shared runtime registers.

 *      This structure can be used to access 9050 registers (memory mapped).

 00-0Ch : Local Address Ranges */

 10h : Local ROM Range */

 14-20h : Local Address Base Addrs */

 24h : Local ROM Base */

 28-34h : Local Bus Descriptors */

 38h : ROM Bus Descriptor */

 3C-48h : Chip Select Base Addrs */

 4Ch : Interrupt Control/Status */

 50h : EEPROM ctrl, Init Ctrl, etc */

 TX lock */

 partial frame received, next frame invalid*/

 rx ring buffer 'in' pointer */

 tx ring buffer 'in' and 'last' pointers */

 SCA registers */

 physical port # - 0 or 1 */

 RSV, X21, etc. */

 1 or 2 ports */

 buffer memory base (virtual) */

 SCA memory base (virtual) */

 PLX registers memory base (virtual) */

 Saved value - 9050 bug workaround */

 number of buffers in a ring */

 offset of first buffer of first channel */

 interrupt request level */

 BRG output */

 RX clock */

 RXC input */

 BRG output */

 RXC input */

 RX clock */

 EXTernal clock */

 RXC input */

 TXC input */

 data size wanted */

 No such clock setting */

 Update settings */

 buffer memory base */

 SCA memory base */

 PLX registers memory base */

 PLX PCI 9050 workaround for local configuration register read bug */

 not fully supported */

 Reset PLX */

 Flush the write - do not use sca_flush */

 Flush the write - do not use sca_flush */

 Reload Config. Registers from EEPROM */

 Flush the write - do not use sca_flush */

 Flush the write - do not use sca_flush */

 number of TX + RX buffers for one port */

 Enable interrupts on the PCI bridge, LINTi1 active low */

 Allocate IRQ */

 COTE not set - allows better TX DMA settings

 sca_out(sca_in(PCR, card) | PCR_COTE, PCR, card);

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Generic HDLC support routines for Linux

 * Point-to-point protocol support

 *

 * Copyright (C) 1999 - 2008 Krzysztof Halasa <khc@pm.waw.pl>

 also bytes# to dump */

 protocol ID */

 ID of last Configuration-Request */

 local sequence number for requests */

 ID of last Echo-Request (LCP) */

 used when holding the spin lock */

 unknown protocol */

/* State transition table (compare STD-51)

   Events                                   Actions

   TO+  = Timeout with counter > 0          irc = Initialize-Restart-Count

   TO-  = Timeout with counter expired      zrc = Zero-Restart-Count



   RCR+ = Receive-Configure-Request (Good)  scr = Send-Configure-Request

   RCR- = Receive-Configure-Request (Bad)

   RCA  = Receive-Configure-Ack             sca = Send-Configure-Ack

   RCN  = Receive-Configure-Nak/Rej         scn = Send-Configure-Nak/Rej



   RTR  = Receive-Terminate-Request         str = Send-Terminate-Request

   RTA  = Receive-Terminate-Ack             sta = Send-Terminate-Ack



   RUC  = Receive-Unknown-Code              scj = Send-Code-Reject

   RXJ+ = Receive-Code-Reject (permitted)

       or Receive-Protocol-Reject

   RXJ- = Receive-Code-Reject (catastrophic)

       or Receive-Protocol-Reject

	/* CLOSED     STOPPED STOPPING REQ_SENT ACK_RECV ACK_SENT OPENED

 START */

 STOP */

 TO+ */

 TO- */

 RCR+ */

 RCR- */

 RCA */

 RCN */

 RTR */

 RTA */

 RUC */

 RXJ+ */

 RXJ- */

/* SCA: RCR+ must supply id, len and data

   SCN: RCR- must supply code, id, len and data

   STA: RTR must supply id

 set Configure-Req/Terminate-Req timer */

 send Configure-Request */

 send Configure-Ack */

 send Configure-Nak/Reject */

 send Terminate-Request */

 send Terminate-Ack */

 send Code-Reject */

 out of memory, ignore CR packet */

 MRU always OK and > 1500 bytes? */

 async control character map */

 NAK it */

 reject invalid magic number */

 reject this option */

 Check HDLC header */

 no complete CP header? */ ||

 truncated packet? */)

 HDLC and CP headers stripped from skb */

 LCP only */

 send Echo-Reply */

 discard */

 LCP, IPCP and IPV6CP */

	/* mod_timer could be called after we entered this function but

	 * before we got the lock.

 send keep-alive packet */

 return protocol only, no settable parameters */

 no settable parameters */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Generic HDLC support routines for Linux

 * Cisco HDLC support

 *

 * Copyright (C) 2000 - 2006 Krzysztof Halasa <khc@pm.waw.pl>

 Cisco multicast address */

 Cisco unicast address */

 Cisco keepalive protocol */

 Cisco interface/system info */

 Cisco address request */

 Cisco address reply */

 Cisco keepalive request */

 code */

 reliability */

 TX sequence number, 0 = none */

 RX sequence number */

 we will need do_div here if 1000 % HZ != 0 */

 Packet is not needed, drop it. */

 Stolen from syncppp.c :-) */

 is the mask correct? */

 our current REQ may be in transit */

 switch (keepalive type) */

 switch (protocol) */

 Mark error */

 First poll after 1 s */

 data size wanted */

 SPDX-License-Identifier: GPL-2.0

/*

 * Prints out len, max to 80 octets using printk, 20 per line

  DEBUG  */

 --------------------------- end if_lmc_linux.c ------------------------ */

 SPDX-License-Identifier: GPL-2.0-only

 $Id: lmc_media.c,v 1.13 2000/04/11 05:25:26 asj Exp $ */

 Processor type for cache alignment. */

 /*

  * Copyright (c) 1997-2000 LAN Media Corporation (LMC)

  * All rights reserved.  www.lanmedia.com

  *

  * This code is written by:

  * Andrew Stanley-Jones (asj@cban.com)

  * Rob Braun (bbraun@vix.com),

  * Michael Graff (explorer@vix.com) and

  * Matt Thomas (matt@3am-software.com).

/*

 * protocol independent method.

/*

 * media independent methods to check on media status, link, light LEDs,

 * etc.

 special media init stuff */

 reset to default state */

 reset status to state provided */

 set clock source */

 set line speed */

 set cable length */

 set scrambler */

 get link status */

 set link status */

 set CRC length */

 set T1 or E1 circuit type */

 special media init stuff */

 reset to default state */

 reset status to state provided */

 set clock source */

 set line speed */

 set cable length */

 set scrambler */

 get link status */

 set link status */

 set CRC length */

 set T1 or E1 circuit type */

 special media init stuff */

 reset to default state */

 reset status to state provided */

 set clock source */

 set line speed */

 set cable length */

 set scrambler */

 get link status */

 set link status */

 set CRC length */

 set T1 or E1 circuit type */

 special media init stuff */

 reset to default state */

 reset status to state provided */

 set clock source */

 set line speed */

 set cable length */

 set scrambler */

 get link status */

 set link status */

 set CRC length */

 set T1 or E1 circuit type */

/*

 *  HSSI methods

/*

 * Given a user provided state, set ourselves up to match it.  This will

 * always reset the card if needed.

  /*

   * check for change in clock source

/*

 * 1 == internal, 0 == external

/*

 * return hardware link status.

 * 0 == link is down, 1 == link is up.

    /*

     * We're using the same code as SSI since

     * they're practically the same

/*

 * 0 == 16bit, 1 == 32bit

 32 bit */

 16 bit */

 HSSI is blank */

/*

 *  DS3 methods

/*

 * Set cable length

/*

 * Given a user provided state, set ourselves up to match it.  This will

 * always reset the card if needed.

  /*

   * check for change in cable length setting

  /*

   * Check for change in scrambler setting (requires reset)

 writes zeros everywhere */

 set some essential bits */

 ser, xtx */

 emode */

 rcgen, tcgen */

 clear counters and latched bits */

/*

 * 1 == DS3 payload scrambled, 0 == not scrambled

/*

 * return hardware link status.

 * 0 == link is down, 1 == link is up.

    /* LMC5245 (DS3) & LMC1200 (DS1) LED definitions

     * led0 yellow = far-end adapter is in Red alarm condition

     * led1 blue   = received an Alarm Indication signal

     *               (upstream failure)

     * led2 Green  = power to adapter, Gate Array loaded & driver

     *               attached

     * led3 red    = Loss of Signal (LOS) or out of frame (OOF)

     *               conditions detected on T3 receive signal

 Turn on Xbit error as our cisco does */

 turn on red LED */

 turn on red LED */

 Turn off Xbit error */

/*

 * 0 == 16bit, 1 == 32bit

 32 bit */

 16 bit */

/*

 *  SSI methods

  /*

   * make TXCLOCK always be an output

/*

 * Given a user provided state, set ourselves up to match it.  This will

 * always reset the card if needed.

  /*

   * check for change in clock source

/*

 * 1 == internal, 0 == external

  /* original settings for clock rate of:

   *  100 Khz (8,25,0,0,2) were incorrect

   *  they should have been 80,125,1,3,3

   *  There are 17 param combinations to produce this freq.

   *  For 1.5 Mhz use 120,100,1,1,2 (226 param. combinations)

 really, this is the rate we are */

/*

 * return hardware link status.

 * 0 == link is down, 1 == link is up.

  /*

   * missing CTS?  Hmm.  If we require CTS on, we may never get the

   * link to come up, so omit it in this test.

   *

   * Also, it seems that with a loopback cable, DCD isn't asserted,

   * so just check for things like this:

   *      DSR _must_ be asserted.

   *      One of DCD or CTS must be asserted.

  /* LMC 1000 (SSI) LED definitions

   * led0 Green = power to adapter, Gate Array loaded &

   *              driver attached

   * led1 Green = DSR and DTR and RTS and CTS are set

   * led2 Green = Cable detected

   * led3 red   = No timing is available from the

   *              cable or the on-board frequency

   *              generator.

 Is the transmit clock still available */

 ====== transmit clock determination ===== */

 no clock found ? */

 turn ON red LED */

 turn OFF red LED */

 Also HSSI CA */

 Over all good status? */

/*

 * 0 == 16bit, 1 == 32bit

 32 bit */

 16 bit */

/*

 * These are bits to program the ssi frequency generator

  /*

   * set the data bit as we need it.

  /*

   * set the clock to high

  /*

   * set the clock to low again.

  /*

   * Set the TXCLOCK, GENERATOR, SERIAL, and SERIALCLK

   * as outputs.

  /*

   * a shifting we will go...

  /*

   * stop driving serial-related signals

/*

 *  T1 methods

/*

 * The framer regs are multiplexed through MII regs 17 & 18

/* Save a warning

static int

lmc_t1_read (lmc_softc_t * const sc, int a)

{

  lmc_mii_writereg (sc, 0, 17, a);

  return lmc_mii_readreg (sc, 0, 18);

}

 reset 8370 */

 set T1 or E1 line.  Uses sc->lmcmii16 reg in function so update it */

 CR0     - primary control             */

 JAT_CR  - jitter atten config         */

 LOOP    - loopback config             */

 DL3_TS  - external data link timeslot */

 PIO     - programmable I/O            */

 POE     - programmable OE             */

 CMUX    - clock input mux             */

 LIU_CR  - RX LIU config               */

 RLIU_CR - RX LIU config               */

 RCR0    - RX config                   */

 RALM    - RX alarm config             */

 LATCH   - RX alarm/err/cntr latch     */

 TLIU_CR - TX LIU config               */

 TCR0    - TX framer config            */

 TCR1    - TX config                   */

 TFRM    - TX frame format             */

 TERROR  - TX error insert             */

 TMAN    - TX manual Sa/FEBE config    */

 TALM    - TX alarm signal config      */

 TPATT   - TX test pattern config      */

 TLB     - TX inband loopback config   */

 CLAD_CR - clock rate adapter config   */

 CSEL    - clad freq sel               */

 DL1_CTL - DL1 control                 */

 DL2_CTL - DL2 control                 */

 SBI_CR  - sys bus iface config        */

 RSB_CR  - RX sys bus config           */

 TSB_CR  - TX sys bus config           */

 SBCn - sys bus per-channel ctl    */

 TPCn - TX per-channel ctl         */

 RPCn - RX per-channel ctl         */

 SBCn - sys bus per-channel ctl    */

 Right now we can only clock from out internal source */

/* * Given a user provided state, set ourselves up to match it.  This will * always reset the card if needed.

  /*

/*

 * return hardware link status.

 * 0 == link is down, 1 == link is up.

  /* LMC5245 (DS3) & LMC1200 (DS1) LED definitions

   * led0 yellow = far-end adapter is in Red alarm condition

   * led1 blue   = received an Alarm Indication signal

   *               (upstream failure)

   * led2 Green  = power to adapter, Gate Array loaded & driver

   *               attached

   * led3 red    = Loss of Signal (LOS) or out of frame (OOF)

   *               conditions detected on T3 receive signal

 turn on blue LED */

    /*

     * Yellow Alarm is nasty evil stuff, looks at data patterns

     * inside the channel and confuses it with HDLC framing

     * ignore all yellow alarms.

     *

     * Do listen to MultiFrame Yellow alarm which while implemented

     * different ways isn't in the channel and hence somewhat

     * more reliable

    /*

     * Loss of signal and los of frame

     * Use the green bit to identify which one lit the led

/*

 * 1 == T1 Circuit Type , 0 == E1 Circuit Type

/*

 32 bit */

 16 bit */ sc->lmc_miireg16 &= ~LMC_MII16_T1_CRC;

/*

 * 1 == internal, 0 == external

 SPDX-License-Identifier: GPL-2.0-only

 /*

  * Copyright (c) 1997-2000 LAN Media Corporation (LMC)

  * All rights reserved.  www.lanmedia.com

  *

  * This code is written by:

  * Andrew Stanley-Jones (asj@cban.com)

  * Rob Braun (bbraun@vix.com),

  * Michael Graff (explorer@vix.com) and

  * Matt Thomas (matt@3am-software.com).

  *

  * With Help By:

  * David Boggs

  * Ron Crane

  * Allan Cox

  *

  * Driver for the LanMedia LMC5200, LMC5245, LMC1000, LMC1200 cards.

 Processor type for cache alignment. */

 attach

FOLD00*/

            /*

	     * They set a few basics because they don't use HDLC

FOLD00*/

 Packet type for skbuff kind of useless */

FOLD00*/

 SPDX-License-Identifier: GPL-2.0-only

 /*

  * Copyright (c) 1997-2000 LAN Media Corporation (LMC)

  * All rights reserved.  www.lanmedia.com

  * Generic HDLC port Copyright (C) 2008 Krzysztof Halasa <khc@pm.waw.pl>

  *

  * This code is written by:

  * Andrew Stanley-Jones (asj@cban.com)

  * Rob Braun (bbraun@vix.com),

  * Michael Graff (explorer@vix.com) and

  * Matt Thomas (matt@3am-software.com).

  *

  * With Help By:

  * David Boggs

  * Ron Crane

  * Alan Cox

  *

  * Driver for the LanMedia LMC5200, LMC5245, LMC1000, LMC1200 cards.

  *

  * To control link specific options lmcctl is required.

  * It can be obtained from ftp.lanmedia.com.

  *

  * Linux driver notes:

  * Linux uses the device struct lmc_private to pass private information

  * around.

  *

  * The initialization portion of this driver (the lmc_reset() and the

  * lmc_dec_reset() functions, as well as the led controls and the

  * lmc_initcsrs() functions.

  *

  * The watchdog function runs every second and checks to see if

  * we still have link, and that the timing source is what we expected

  * it to be.  If link is lost, the interface is marked down, and

  * we no longer can transmit.

 Processor type for cache alignment. */

#include <asm/spinlock.h>

/*

 * linux reserves 16 device specific IOCTLs.  We call them

 * LMCIOC* to control various bits of our world.

fold00*/

    /*

     * Most functions mess with the structure

     * Disable interrupts while we do the polling

        /*

         * Return current driver state.  Since we keep this up

         * To date internally, just copy this out to the user.

fold01*/

fold01*/

fold01*/

 no change */

fold01*/

fold01*/

fold01*/

 Reset driver and bring back to current state */

 end ifdef _DBG_EVENTLOG */

fold01*/

fold01*/

fold02*/

            /*

             * Stop the xwitter whlie we restart the hardware

fold02*/

                    /*

                     * Make all of them 0 and make input

                    /*

                     * make the reset output

                    /*

                     * RESET low to force configuration.  This also forces

                     * the transmitter clock to be internal, but we expect to reset

                     * that later anyway.

                    /*

                     * hold for more than 10 microseconds

                    /*

                     * stop driving Xilinx-related signals

 Reset the frammer hardware */

                    lmc_softreset(sc);

fold02*/

                    /*

                     * Make all of them 0 and make input

                    /*

                     * make the reset output

                    /*

                     * RESET low to force configuration.  This also forces

                     * the transmitter clock to be internal, but we expect to reset

                     * that later anyway.

                    /*

                     * hold for more than 10 microseconds

                    /*

                     * busy wait for the chip to reset

                    /*

                     * stop driving Xilinx-related signals

fold02*/

                    /*

                     * Clear the Xilinx and start prgramming from the DEC

                    /*

                     * Set ouput as:

                     * Reset: 0 (active)

                     * DP:    0 (active)

                     * Mode:  1

                     *

                    /*

                     * Wait at least 10 us 20 to be safe

                    /*

                     * Clear reset and activate programming lines

                     * Reset: Input

                     * DP:    Input

                     * Clock: Output

                     * Data:  Output

                     * Mode:  Output

                    /*

                     * Set LOAD, DATA, Clock to 1

                    /*

                     * busy wait for the chip to reset

 Data is 0 */

 Data is 1 */

 Assume it's 1 */

 Clock to zero */

 Put the clack back to one */

fold02*/

 the watchdog process that cruises around */

fold00*/

    /* Make sure the tx jabber and rx watchdog are off,

     * and the transmit and receive processes are running.

    /* --- begin time out check -----------------------------------

     * check for a transmit interrupt timeout

 wait for the watchdog to come around again */

 DEC chip is stuck, hit it with a RESET!!!! */

 look at receive & transmit process state to make sure they are running */

        /* look at: DSR - 02  for Reg 16

         *                  CTS - 08

         *                  DCD - 10

         *                  RI  - 20

         * for Reg 17

 reset the transmit timeout detection flag */

 --- end time out check ----------------------------------- */

    /*

     * hardware level link lost, but the interface is marked as up.

     * Mark it as down.

 lmc_reset (sc); Why reset??? The link can go down ok */

 Inform the world that link has been lost */

    /*

     * hardware link is up, but the interface is marked as down.

     * Bring it back up again.

 lmc_reset (sc); Again why reset??? */

 Call media specific watchdog functions */

    /*

     * Poke the transmitter to make sure it

     * never stops, even if we run out of mem

    /*

     * Check for code that failed

     * and try and fix it as appropriate

        /*

         * Failed to setup the recv/xmit rin

         * Try again

        /*

         * We failed to alloc mem in the

         * interrupt handler, go through the rings

         * and rebuild them

    /*

     * remember the timer value

    /*

     * restart this timer.

	/*

	 * Allocate our own device structure

 1 second */

	/*

	 * This will get the protocol layer ready and do any 1 time init's

	 * Must have a valid sc and dev structure

 Init the spin lock so can call it latter */

    /*

     *

     * Check either the subvendor or the subdevice, some systems reverse

     * the setting in the bois, seems to be version and arch dependent?

     * Fix the error, exchange the two values 

 drive no signals yet */

    /* verify that the PCI Sub System ID matches the Adapter Model number

     * from the MII register

 detect LMC1200 */

 detect LMC1000 */

 detect LMC5245 */

 detect LMC5200 */

    /*

     * reset clock

/*

 * Called from pci when removing module.

/* After this is called, packets can be sent.

 * Does not initialize the addresses

 Since we have to use PCI bus, this should work on x86,alpha,ppc */

 Assert Terminal Active */

    /*

     * reset to last state.

    /* setup default bits to be used in tulip_desc_t transmit descriptor

 disable 32 bit CRC generated by ASIC */

 Acknoledge the Terminal Active and light LEDs */

 dev->flags |= IFF_UP; */

    /*

     * select what interrupts we want to get

 Should be using the default interrupt mask defined in the .h file. */

 Run watchdog */

    /*

     * Set the if up now - pfb

    /*

     * Setup a timer for the watchdog on probe, and start it running.

     * Since lmc_ok == 0, it will be a NOP for now.

/* Total reset to compensate for the AdTran DSU doing bad things

 *  under heavy load

fold00*/

 stop interrupts */

 Clear the interrupt mask */

 sc->lmc_miireg16 |= LMC_MII16_LED_ALL; */

/* This is what is called when you ifconfig down a device.

 * This disables the timer for the watchdog and keepalives,

 * and disables the irq for dev.

 not calling release_region() as we should */

 Ends the transfer of packets */

 When the interface goes down, this is called */

fold00*/

 Don't let anything else go on right now */

    dev->start = 0;

 stop interrupts */

 Clear the interrupt mask */

 Stop Tx and Rx on the chip */

 Turn off the Transmission bit */

 Turn off the Receive bit */

 release the interrupt */

 free skbuffs in the Rx queue */

/* Interrupt handling routine.  This will take an incoming packet, or clean

 * up after a trasmit.

fold00*/

    /*

     * Read the csr to find what interrupts we have (if any)

    /*

     * Make sure this is our interrupt

 always go through this loop at least once */

        /*

         * Clear interrupt bits, we handle all case below

        /*

         * One of

         *  - Transmit process timed out CSR5<1>

         *  - Transmit jabber timeout    CSR5<3>

         *  - Transmit underflow         CSR5<5>

         *  - Transmit Receiver buffer unavailable CSR5<7>

         *  - Receive process stopped    CSR5<8>

         *  - Receive watchdog timeout   CSR5<9>

         *  - Early transmit interrupt   CSR5<10>

         *

         * Is this really right? Should we do a running reset for jabber?

         * (being a WAN card and all)

 reset the transmit timeout detection flag -baz */

                /*

                 * If bit 31 is 1 the tulip owns it break out of the loop

 i.e., have an empty slot in ring */

                /*

                 * If we have no skbuff or have cleared it

                 * Already continue to the next buffer

		/*

		 * Check the total error summary to look for any errors

            /*

             * Why was there a break here???

 end handle transmit interrupt */

        /*

         * Get current csr status to make sure

         * we've cleared all interrupts

 end interrupt loop */

 normal path, tbusy known to be zero */

 If the queue is less than half full, don't interrupt */

 Do not interrupt on completion of this packet */

 This generates an interrupt on completion of this packet */

 Do not interrupt on completion of this packet */

 This generates an interrupt on completion of this packet */

 ring full, go busy */

 last descriptor in ring */

 flag as such for Tulip */

 don't pad small packets either */

    /* set the transmit timeout flag to be checked in

     * the watchdog timer handler. -baz

 give ownership to the chip */

 send now! */

 debug -baz */

 debug -baz */

 debug -baz */

 Check first segment and last segment */

 Oversized frame */

 Catch a dribbling bit error */

 Catch a CRC error by the Xilinx */

        /*

         * We ran out of memory at some point

         * just allocate an skb buff and continue.

        /*

         * I'm not sure of the sanity of this

         * Packets could be arriving at a constant

         * 44.210mbits/sec and we're going to copy

         * them into a new buffer??

 len > LMC_MTU * 0.75 */

            /*

             * If it's a large packet don't copy it just hand it up

 skb_reset_network_header(skb); */

            /*

             * This skb will be destroyed by the upper layers, make a new one

 Transferred to 21140 below */

                /*

                 * We've run out of memory, stop trying to allocate

                 * memory and exit the interrupt handler

                 *

                 * The chip may run out of receivers and stop

                 * in which care we'll try to allocate the buffer

                 * again.  (once a second)

 skb_reset_network_header(nsb); */

    /* detect condition for LMC1000 where DSU cable attaches and fills

     * descriptors with bogus packets

     *

    if (localLengthErrCnt > LMC_RXDESCS - 3) {

	sc->extra_stats.rx_BadPktSurgeCnt++;

	LMC_EVENT_LOG(LMC_EVENT_BADPKTSURGE, localLengthErrCnt,

		      sc->extra_stats.rx_BadPktSurgeCnt);

 save max count of receive descriptors serviced */

 debug -baz */

fold00*/

 __SLOW_DOWN_IO; */

 __SLOW_DOWN_IO; */

 __SLOW_DOWN_IO; */

 __SLOW_DOWN_IO; */

fold00*/

 __SLOW_DOWN_IO; */

 __SLOW_DOWN_IO; */

 __SLOW_DOWN_IO; */

 __SLOW_DOWN_IO; */

fold00*/

 Initialize the receive rings and buffers. */

    /*

     * Setup each one of the receiver buffers

     * allocate an skbuff for each one, setup the descriptor table

     * and point each buffer at the next one

 owned by 21140 */

 used to be PKT_BUF_SZ now uses skb since we lose some to head room */

        /* use to be tail which is dumb since you're thinking why write

         * to the end of the packj,et but since there's nothing there tail == data

 This is fair since the structure is static and we have the next address */

    /*

     * Sets end of ring

 Set end of buffers flag */

 Point back to the start */

 write base address */

 Initialize the transmit rings and buffers */

 have buffer */

 free it */

 We just dropped a packet */

fold00*/

fold00*/

fold00*/

 Already on! */

fold00*/

 Already set don't do anything */

fold00*/

    /*

     * make some of the GPIO pins be outputs

    /*

     * RESET low to force state reset.  This also forces

     * the transmitter clock to be internal, but we expect to reset

     * that later anyway.

    /*

     * hold for more than 10 microseconds

    /*

     * stop driving Xilinx-related signals

    /*

     * Call media specific init routine

fold00*/

    /*

     * disable all interrupts

    /*

     * Reset the chip with a software reset command.

     * Wait 10 microseconds (actually 50 PCI cycles but at

     * 33MHz that comes to two microseconds but wait a

     * bit longer anyways)

    /*

     * We want:

     *   no ethernet address in frames we write

     *   disable padding (txdesc, padding disable)

     *   ignore runt frames (rdes0 bit 15)

     *   no receiver watchdog or transmitter jabber timer

     *       (csr15 bit 0,14 == 1)

     *   if using 16-bit CRC, turn off CRC (trans desc, crc disable)

    /*

     * disable receiver watchdog and transmit jabber

fold00*/

    /*

     * Chip seems to have locked up

     * Reset it

     * This whips out all our descriptor

     * table and starts from scartch

 restart the tx processes */

 immediate transmit */

 -baz */

 prevent tx timeout */

/*      cops.c: LocalTalk driver for Linux.

 *

 *	Authors:

 *      - Jay Schulist <jschlst@samba.org>

 *

 *	With more than a little help from;

 *	- Alan Cox <alan@lxorguk.ukuu.org.uk>

 *

 *      Derived from:

 *      - skeleton.c: A network driver outline for linux.

 *        Written 1993-94 by Donald Becker.

 *	- ltpc.c: A driver for the LocalTalk PC card.

 *	  Written by Bradford W. Johnson.

 *

 *      Copyright 1993 United States Government as represented by the

 *      Director, National Security Agency.

 *

 *      This software may be used and distributed according to the terms

 *      of the GNU General Public License, incorporated herein by reference.

 *

 *	Changes:

 *	19970608	Alan Cox	Allowed dual card type support

 *					Can set board type in insmod

 *					Hooks for cops_setup routine

 *					(not yet implemented).

 *	19971101	Jay Schulist	Fixes for multiple lt* devices.

 *	19980607	Steven Hirsch	Fixed the badly broken support

 *					for Tangent type cards. Only

 *                                      tested on Daystar LT200. Some

 *                                      cleanup of formatting and program

 *                                      logic.  Added emacs 'local-vars'

 *                                      setup for Jay's brace style.

 *	20000211	Alan Cox	Cleaned up for softnet

/*

 *  Sources:

 *      COPS Localtalk SDK. This provides almost all of the information

 *      needed.

/*

 * insmod/modprobe configurable stuff.

 *	- IO Port, choose one your card supports or 0 if you dare.

 *	- IRQ, also choose one your card supports or nothing and let

 *	  the driver figure it out.

 For udelay() */

 Our Stuff */

 Firmware code for Tangent type cards. */

 Firmware code for Dayna type cards. */

/*

 *      The name of the card. Is used for messages and in the requests for

 *      io regions, irqs and dma channels

 Module exported */

 Default IO for Dayna */

 Default IRQ */

/*

 *	COPS Autoprobe information.

 *	Right now if port address is right but IRQ is not 5 this will

 *      return a 5 no matter what since we will still get a status response.

 *      Need one more additional check to narrow down after we have gotten

 *      the ioaddr. But since only other possible IRQs is 3 and 4 so no real

 *	hurry on this. I *STRONGLY* recommend using IRQ 5 for your card with

 *	this driver.

 * 

 *	This driver has 2 modes and they are: Dayna mode and Tangent mode.

 *	Each mode corresponds with the type of card. It has been found

 *	that there are 2 main types of cards and all other cards are

 *	the same and just have different names or only have minor differences

 *	such as more IO ports. As this driver is tested it will

 *	become more clear on exactly what cards are supported. The driver

 *	defaults to using Dayna mode. To change the drivers mode, simply

 *	select Dayna or Tangent mode when configuring the kernel.

 *

 *      This driver should support:

 *      TANGENT driver mode:

 *              Tangent ATB-II, Novell NL-1000, Daystar Digital LT-200,

 *		COPS LT-1

 *      DAYNA driver mode:

 *              Dayna DL2000/DaynaTalk PC (Half Length), COPS LT-95, 

 *		Farallon PhoneNET PC III, Farallon PhoneNET PC II

 *	Other cards possibly supported mode unknown though:

 *		Dayna DL2000 (Full length), COPS LT/M (Micro-Channel)

 *

 *	Cards NOT supported by this driver but supported by the ltpc.c

 *	driver written by Bradford W. Johnson <johns393@maroon.tc.umn.edu>

 *		Farallon PhoneNET PC

 *		Original Apple LocalTalk PC card

 * 

 *      N.B.

 *

 *      The Daystar Digital LT200 boards do not support interrupt-driven

 *      IO.  You must specify 'irq=0xff' as a module parameter to invoke

 *      polled mode.  I also believe that the port probing logic is quite

 *      dangerous at best and certainly hopeless for a polled card.  Best to 

 *      specify both. - Steve H.

 *

/*

 * Zero terminated list of IO ports to probe.

/*

 * Zero terminated list of IRQ ports to probe.

 use 0 for production, 1 for verification, 2 for debug, 3 for verbose debug */

 The number of low I/O ports used by the card. */

 Information that needs to be kept for each board. */

 Holds what board type is. */

 Set to 1 once have nodeid. */

 Node ID when acquired. */

 Full node address */

 RX/TX lock */

 Index to functions, as function prototypes. */

/*

 *      Check for a network adaptor of this type, and return '0' iff one exists.

 *      If dev->base_addr == 0, probe all likely locations.

 *      If dev->base_addr in [1..0x1ff], always return failure.

 *        otherwise go with what we pass in.

 Check a single specified location. */

 Don't probe at all. */

		/* FIXME  Does this really work for cards which generate irq?

		 * It's definitely N.G. for polled Tangent. sh

		 * Dayna cards don't autoprobe well at all, but if your card is

		 * at IRQ 5 & IO 0x240 we find it every time. ;) JS

/*

 *      This is the real probe routine. Linux has a history of friendly device

 *      probes on the ISA bus. A good device probes avoids doing writes, and

 *      verifies that the correct device exists and functions.

 Grab the region so no one else tries to probe our ioports. */

        /*

         * Since this board has jumpered interrupts, allocate the interrupt

         * vector now. There is no point in waiting since no other device

         * can use the interrupt, and this marks the irq as busy. Jumpered

         * interrupts are typically not reported by the boards, and we must

         * used AutoIRQ to find them.

 COPS AutoIRQ routine */

 Once no IRQ found on this port */

		/* Fixup for users that don't know that IRQ 2 is really

		 * IRQ 9, or don't know which one to set.

		/* Polled operation requested. Although irq of zero passed as

		 * a parameter tells the init routines to probe, we'll

		 * overload it to denote polled operation at runtime.

 Reserve any actual interrupt. */

 Copy local board variable to lp struct. */

 Tell the user where the card is and what mode we're in. */

{       /*

         * This does not use the IRQ to determine where the IRQ is. We just

         * assume that when we get a correct status response that it's the IRQ.

         * This really just verifies the IO port but since we only have access

         * to such a small number of IRQs (5, 4, 3) this is not bad.

         * This will probably not work for more than one card.

 wait for response */

 no IRQ found */

/*

 * Open/initialize the board. This is called (in the current kernel)

 * sometime after booting when the 'ifconfig' program is run.

		/*

		 * I don't know if the Dayna-style boards support polled 

		 * operation.  For now, only allow it for Tangent.

 Poll 20 times per second */

 Start the card up. */

/*

 *	This allows for a dynamic start/restart of the entire card.

	/*

         *      Once the card has the firmware loaded and has acquired

         *      the nodeid, if it is reset it will lose it all.

 Need to reset card before load firmware. */

 Load the firmware. */

	/*

	 *	If atalkd already gave us a nodeid we will use that

	 *	one again, else we wait for atalkd to give us a nodeid

	 *	in cops_ioctl. This may cause a problem if someone steals

	 *	our nodeid while we are resetting.

 Wait 1 second */

/*

 *      Reset the LocalTalk board.

 Clear request latch. */

 Clear the TANG_TX_READY flop. */

 Reset the adapter. */

 Assert the reset port */

 Clear the reset */

 Get card's firmware code and do some checks on it. */

 Check to make sure firmware is correct length. */

                /*

                 *      We must wait for a status response

                 *      with the DAYNA board.

        /*

         *      Upload the firmware and kick. Byte-by-byte works nicely here.

 Tell Dayna to run the firmware code. */

 Tell Tang to run the firmware code. */

 Clear initial ready signal. */

/*

 * 	Get the LocalTalk Nodeid from the card. We can suggest

 *	any nodeid 1-254. The card will try and get that exact

 *	address else we can specify 0 as the nodeid and the card

 *	will autoprobe for a nodeid.

 Empty any pending adapter responses. */

 Clear interrupts. */

 Kick any packets waiting. */

 Output command packet length as 2. */

 Send LAP_INIT command byte. */

 Suggest node address. */

 Empty any pending adapter responses. */

 Clear interrupt. */

 Kick out packets waiting. */

 Not sure what Tangent does if nodeid picked is used. */

 Seed. */

 Get a random try */

 Command length LSB */

 Command length MSB */

 Send LAP_INIT byte */

 LAP address hint. */

 Int. level to use */

 Set nodeid holder to 0. */

 Get *True* nodeid finally. */

 Clear any interrupt. */

 Grab the nodeid put in lp->node_acquire. */

 Grab the nodeid put in lp->node_acquire. */

 Set got nodeid to 1. */

/*

 *	Poll the Tangent type cards to see if we have work.

 We've been downed */

 poll 20 times per second */

/*

 *      The typical workload of the driver:

 *      Handle the network interface interrupts.

/*

 *      We have a good packet(s), get it/them out of the buffers.

 Send out Zero length. */

 Send read command out. */

 Wait for DMA to turn around. */

 Get response length. */

 Input IO code. */

 Malloc up new buffer. */

 Discard packet */

 Eat the Data */

 Interrupt the card */

 Restore interrupts. */

 Check for bad response length */

 Set nodeid and then get out. */

 Nodeid taken from received packet. */

 One last check to make sure we have a good packet. */

 Point to entire packet. */

 Point to data (Skip header). */

 Update the counters. */

 Send packet to a higher place. */

 Restart the card. */

 prevent tx timeout */

/*

 *	Make the card transmit a LocalTalk packet.

        /*

         * Block a timer-based transmit from overlapping. 

 Wait for adapter transmit buffer. */

 Wait for adapter transmit buffer. */

 Output IO length. */

 Output IO code. */

 Check the transmit buffer again. */

 Send out the data. */

 Dayna requires you kick the card */

 Restore interrupts. */

 Done sending packet, update counters and cleanup. */

/*

 *	Dummy function to keep the Appletalk layer happy.

/*

 *      System ioctls for the COPS LocalTalk card.

 Get and set the nodeid and network # atalkd wants. */

 Set broardcast address. */

 Set hardware address. */

/*

 *	The inverse routine to cops_open().

	/* If we were running polled, yank the timer.

 MODULE */

/*

 *	ipddp.c: IP to Appletalk-IP Encapsulation driver for Linux

 *		 Appletalk-IP to IP Decapsulation driver for Linux

 *

 *	Authors:

 *      - DDP-IP Encap by: Bradford W. Johnson <johns393@maroon.tc.umn.edu>

 *	- DDP-IP Decap by: Jay Schulist <jschlst@samba.org>

 *

 *	Derived from:

 *	- Almost all code already existed in net/appletalk/ddp.c I just

 *	  moved/reorginized it into a driver file. Original IP-over-DDP code

 *	  was done by Bradford W. Johnson <johns393@maroon.tc.umn.edu>

 *      - skeleton.c: A network driver outline for linux.

 *        Written 1993-94 by Donald Becker.

 *	- dummy.c: A dummy net driver. By Nick Holloway.

 *	- MacGate: A user space Daemon for Appletalk-IP Decap for

 *	  Linux by Jay Schulist <jschlst@samba.org>

 *

 *      Copyright 1993 United States Government as represented by the

 *      Director, National Security Agency.

 *

 *      This software may be used and distributed according to the terms

 *      of the GNU General Public License, incorporated herein by reference.

 Our stuff */

 Index to functions, as function prototypes. */

 Initialize the device structure. */

 IP over DDP tunnel */

        /*

         *      The worst case header we will need is currently a

         *      ethernet header (14 bytes) and a ddp header (sizeof ddpehdr+1)

         *      We send over SNAP so that takes another 8 bytes.

 Let the user now what mode we are in */

/*

 * Transmit LLAP/ELAP frame using aarp_send_ddp.

	/*

         * Find appropriate route to use, based only on IP number.

		/* 

		 * Pull off the excess room that should not be there.

		 * This is due to a hard-header problem. This is the

		 * quick fix for now though, till it breaks.

 Create the Extended DDP header */

	/*

         * For Localtalk we need aarp_send_ddp to strip the

         * long DDP header and place a shot DDP header on it.

 FIXME more hops?? */

 FIXME more hops?? */

 ddp type = IP */

 Protocol has changed */

/*

 * Create a routing entry. We first verify that the

 * record does not already exist. If it does we return -EEXIST

/*

 * Delete a route, we only delete a FULL match.

 * If route does not exist we return -ENOENT.

/*

 * Find a routing entry, we only return a FULL match

/***    ltpc.c -- a driver for the LocalTalk PC card.

 *

 *      Copyright (c) 1995,1996 Bradford W. Johnson <johns393@maroon.tc.umn.edu>

 *

 *      This software may be used and distributed according to the terms

 *      of the GNU General Public License, incorporated herein by reference.

 *

 *      This is ALPHA code at best.  It may not work for you.  It may

 *      damage your equipment.  It may damage your relations with other

 *      users of your network.  Use it at your own risk!

 *

 *      Based in part on:

 *      skeleton.c      by Donald Becker

 *      dummy.c         by Nick Holloway and Alan Cox

 *      loopback.c      by Ross Biro, Fred van Kampen, Donald Becker

 *      the netatalk source code (UMICH)

 *      lots of work on the card...

 *

 *      I do not have access to the (proprietary) SDK that goes with the card.

 *      If you do, I don't want to know about it, and you can probably write

 *      a better driver yourself anyway.  This does mean that the pieces that

 *      talk to the card are guesswork on my part, so use at your own risk!

 *

 *      This is my first try at writing Linux networking code, and is also

 *      guesswork.  Again, use at your own risk!  (Although on this part, I'd

 *      welcome suggestions)

 *

 *      This is a loadable kernel module which seems to work at my site

 *      consisting of a 1.2.13 linux box running netatalk 1.3.3, and with

 *      the kernel support from 1.3.3b2 including patches routing.patch

 *      and ddp.disappears.from.chooser.  In order to run it, you will need

 *      to patch ddp.c and aarp.c in the kernel, but only a little...

 *

 *      I'm fairly confident that while this is arguably badly written, the

 *      problems that people experience will be "higher level", that is, with

 *      complications in the netatalk code.  The driver itself doesn't do

 *      anything terribly complicated -- it pretends to be an ether device

 *      as far as netatalk is concerned, strips the DDP data out of the ether

 *      frame and builds a LLAP packet to send out the card.  In the other

 *      direction, it receives LLAP frames from the card and builds a fake

 *      ether packet that it then tosses up to the networking code.  You can

 *      argue (correctly) that this is an ugly way to do things, but it

 *      requires a minimal amount of fooling with the code in ddp.c and aarp.c.

 *

 *      The card will do a lot more than is used here -- I *think* it has the

 *      layers up through ATP.  Even if you knew how that part works (which I

 *      don't) it would be a big job to carve up the kernel ddp code to insert

 *      things at a higher level, and probably a bad idea...

 *

 *      There are a number of other cards that do LocalTalk on the PC.  If

 *      nobody finds any insurmountable (at the netatalk level) problems

 *      here, this driver should encourage people to put some work into the

 *      other cards (some of which I gather are still commercially available)

 *      and also to put hooks for LocalTalk into the official ddp code.

 *

 *      I welcome comments and suggestions.  This is my first try at Linux

 *      networking stuff, and there are probably lots of things that I did

 *      suboptimally.  

 *

/***

 *

 * $Log: ltpc.c,v $

 * Revision 1.1.2.1  2000/03/01 05:35:07  jgarzik

 * at and tr cleanup

 *

 * Revision 1.8  1997/01/28 05:44:54  bradford

 * Clean up for non-module a little.

 * Hacked about a bit to clean things up - Alan Cox 

 * Probably broken it from the origina 1.8

 *



 * 1998/11/09: David Huggins-Daines <dhd@debian.org>

 * Cleaned up the initialization code to use the standard autoirq methods,

   and to probe for things in the standard order of i/o, irq, dma.  This

   removes the "reset the reset" hack, because I couldn't figure out an

   easy way to get the card to trigger an interrupt after it.

 * Added support for passing configuration parameters on the kernel command

   line and through insmod

 * Changed the device name from "ltalk0" to "lt0", both to conform with the

   other localtalk driver, and to clear up the inconsistency between the

   module and the non-module versions of the driver :-)

 * Added a bunch of comments (I was going to make some enums for the state

   codes and the register offsets, but I'm still not sure exactly what their

   semantics are)

 * Don't poll anymore in interrupt-driven mode

 * It seems to work as a module now (as of 2.1.127), but I don't think

   I'm responsible for that...



 *

 * Revision 1.7  1996/12/12 03:42:33  bradford

 * DMA alloc cribbed from 3c505.c.

 *

 * Revision 1.6  1996/12/12 03:18:58  bradford

 * Added virt_to_bus; works in 2.1.13.

 *

 * Revision 1.5  1996/12/12 03:13:22  root

 * xmitQel initialization -- think through better though.

 *

 * Revision 1.4  1996/06/18 14:55:55  root

 * Change names to ltpc. Tabs. Took a shot at dma alloc,

 * although more needs to be done eventually.

 *

 * Revision 1.3  1996/05/22 14:59:39  root

 * Change dev->open, dev->close to track dummy.c in 1.99.(around 7)

 *

 * Revision 1.2  1996/05/22 14:58:24  root

 * Change tabs mostly.

 *

 * Revision 1.1  1996/04/23 04:45:09  root

 * Initial revision

 *

 * Revision 0.16  1996/03/05 15:59:56  root

 * Change ARPHRD_LOCALTLK definition to the "real" one.

 *

 * Revision 0.15  1996/03/05 06:28:30  root

 * Changes for kernel 1.3.70.  Still need a few patches to kernel, but

 * it's getting closer.

 *

 * Revision 0.14  1996/02/25 17:38:32  root

 * More cleanups.  Removed query to card on get_stats.

 *

 * Revision 0.13  1996/02/21  16:27:40  root

 * Refix debug_print_skb.  Fix mac.raw gotcha that appeared in 1.3.65.

 * Clean up receive code a little.

 *

 * Revision 0.12  1996/02/19  16:34:53  root

 * Fix debug_print_skb.  Kludge outgoing snet to 0 when using startup

 * range.  Change debug to mask: 1 for verbose, 2 for higher level stuff

 * including packet printing, 4 for lower level (card i/o) stuff.

 *

 * Revision 0.11  1996/02/12  15:53:38  root

 * Added router sends (requires new aarp.c patch)

 *

 * Revision 0.10  1996/02/11  00:19:35  root

 * Change source LTALK_LOGGING debug switch to insmod ... debug=2.

 *

 * Revision 0.9  1996/02/10  23:59:35  root

 * Fixed those fixes for 1.2 -- DANGER!  The at.h that comes with netatalk

 * has a *different* definition of struct sockaddr_at than the Linux kernel

 * does.  This is an "insidious and invidious" bug...

 * (Actually the preceding comment is false -- it's the atalk.h in the

 * ancient atalk-0.06 that's the problem)

 *

 * Revision 0.8  1996/02/10 19:09:00  root

 * Merge 1.3 changes.  Tested OK under 1.3.60.

 *

 * Revision 0.7  1996/02/10 17:56:56  root

 * Added debug=1 parameter on insmod for debugging prints.  Tried

 * to fix timer unload on rmmod, but I don't think that's the problem.

 *

 * Revision 0.6  1995/12/31  19:01:09  root

 * Clean up rmmod, irq comments per feedback from Corin Anderson (Thanks Corey!)

 * Clean up initial probing -- sometimes the card wakes up latched in reset.

 *

 * Revision 0.5  1995/12/22  06:03:44  root

 * Added comments in front and cleaned up a bit.

 * This version sent out to people.

 *

 * Revision 0.4  1995/12/18  03:46:44  root

 * Return shortDDP to longDDP fake to 0/0.  Added command structs.

 *

/* ltpc jumpers are:

*

*	Interrupts -- set at most one.  If none are set, the driver uses

*	polled mode.  Because the card was developed in the XT era, the

*	original documentation refers to IRQ2.  Since you'll be running

*	this on an AT (or later) class machine, that really means IRQ9.

*

*	SW1	IRQ 4

*	SW2	IRQ 3

*	SW3	IRQ 9 (2 in original card documentation only applies to XT)

*

*

*	DMA -- choose DMA 1 or 3, and set both corresponding switches.

*

*	SW4	DMA 3

*	SW5	DMA 1

*	SW6	DMA 3

*	SW7	DMA 1

*

*

*	I/O address -- choose one.  

*

*	SW8	220 / 240

/*	To have some stuff logged, do 

*	insmod ltpc.o debug=1

*

*	For a whole bunch of stuff, use higher numbers.

*

*	The default is 0, i.e. no messages except for the probe results.

 insmod-tweakable variables */

 our stuff */

 function prototypes */

 Dma Memory related stuff, cribbed directly from 3c505.c */

 DMA data buffer, DMA command buffer */

 private struct, holds our appletalk address */

 transmit queue element struct */

 command buffer */

 data buffer */

 read or write data */

 the transmit queue itself */

 and... the queue elements we'll be using */

 and their corresponding mailboxes */

 returns true if it stayed c */

 this uses base+6, but it's ok */

 twenty second or so total */

 timed out */

 get the first free mailbox */

 read a command from the card */

 called *only* from idle, non-reentrant */

 read data from the card */

 called *only* from idle, non-reentrant */

 on entry, 0xfb and ltdmabuf holds data */

 on entry, 0xfb */

 on exit, ltdmabuf holds data */

 on entry, 0xfa and ltdmacbuf holds command */

 ready made command for getting the result from the card */

/* idle expects to be called with the IRQ line high -- either because of

 * an interrupt, or because the line is tri-stated

	/* FIXME This is initialized to shut the warning up, but I need to

	 * think this through again.

 this tri-states the IRQ line */

 incoming command */

 incoming data */

 result ready */

 ?? */

 waiting for command */

 we timed out, so return */

 we don't seem to have a command */

 data transfer ready */

				/* non-zero mailbox numbers are for

				   commmands, 0 is for GETRESULT

 this was a result */

 now set the interrupts back as appropriate */

 the first read takes it out of tri-state (but still high) */

 the second resets it */

	/* note that after this point, any read of base+6 will

 this should be initted rather */

 this should be initted rather */

 end of idle handlers -- what should be seen is do_read, do_write */

 LLAP to DDP translation */

 on entry, command is in ltdmacbuf, data in ltdmabuf */

 called from idle, non-reentrant */

 correct for short ddp */

 add LLAP header */

 save pointer to llap header */

 copy ddp(s,e)hdr + contents */

 toss it onwards */

 the handler for the board interrupt */

 disable further interrupts from board */

 handle whatever is coming in */

 idle re-enables interrupts from board */ 

/***

 *

 *    The ioctls that the driver responds to are:

 *

 *    SIOCSIFADDR -- do probe using the passed node hint.

 *    SIOCGIFADDR -- return net, node.

 *

 *    some of this stuff should be done elsewhere.

 *

 we'll keep the localtalk node address in dev->pa_addr */

 this does the probe and returns the node addr */

 get all llap frames raw */

 This needs to be present to keep netatalk happy. */

 Actually netatalk needs fixing! */

 poll 20 times per second */

 DDP to LLAP translation */

	/* in kernel 1.3.xx, on entry skb->data points to ddp header,

	 * and skb->len is the length of the ddp data + ddp header

 skip past LLAP header */

 this is host order */

 initialization stuff */

 set up request */

 FIXME -- do timings better! */

 mailbox */

 address */

 read 0x0100 bytes */

 dunno if this is necessary */

 release the other dma channel (if we opened both of them) */

 probe for the I/O port address */

 give up in despair */

 probe for the IRQ line */

 reset the interrupt line */

 trigger an interrupt (I hope) */

 allocate a DMA buffer */

 reset the card */

 clear reset */

 enable dma */

 tri-state interrupt line */

	/* now, figure out which dma channel we're using, unless it's

	/* well, 0 is a legal DMA channel, but the LTPC card doesn't

 no dma channel */

 print out friendly message */

 the card will want to send a result at this point */

	/* (I think... leaving out this part makes the kernel crash,

 grab it and don't let go :-) */

 enable interrupts from board */

 and reset irq line */

 polled mode -- 20 times per second */

 this is really, really slow... should it poll more often? */

 handles "ltpc=io,irq,dma" kernel command lines */

 do nothing :-) */

 usage message */

 ignore any other parameters */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/net/team/team.c - Network team device driver

 * Copyright (c) 2011 Jiri Pirko <jpirko@redhat.com>

/**********

 * Helpers

/*

 * Since the ability to change device address for open port device is tested in

 * team_port_add, this function can be called without control of return value

/*******************

 * Options handling

 One for each option instance */

 No array but still need one instance */

/****************

 * Mode handling

	/*

	 * To avoid checks in rx/tx skb paths, ensure here that non-null and

	 * correct ops are always set.

/*

 * We can benefit from the fact that it's ensured no port is present

 * at the time of mode change. Therefore no packets are in fly so there's no

 * need to set mode operations in any special way.

 Check if mode was previously set and do cleanup if so */

 Clear ops area so no callback is called any longer */

 zero private data area */

/*********************

 * Peers notification

/*******************************

 * Send multicast group rejoins

/************************

 * Rx path frame handler

 note: already called with rcu_read_lock */

 allow exact match delivery for disabled ports */

/*************************************

 * Multiqueue Tx port select override

/*

 * note: already called with rcu_read_lock

/****************

 * Port handling

/*

 * Enable/disable port by adding to enabled port hashlist and setting

 * port->index (Might be racy so reader could see incorrect ifindex when

 * processing a flying packet, but that is not a problem). Write guarded

 * by team->lock.

 set promiscuity level to new slave */

 set allmulti level to new slave */

/*****************

 * Net device ops

 cleanup */

/*

 * note: already called with rcu_read_lock

	/*

	 * This helper function exists to help dev_pick_tx get the correct

	 * destination queue.  Using a helper function skips a call to

	 * skb_tx_hash and will put the skbs in the queue we expect on their

	 * way down to the team driver.

	/*

	 * Save the original txq to restore before passing to the driver

	/*

	 * Alhough this is reader, it's guarded by team lock. It's not possible

	 * to traverse list in reverse under rcu_read_lock

		/*

		 * rx_dropped, tx_dropped & rx_nohandler are u32,

		 * updated without syncp protection.

	/*

	 * Alhough this is reader, it's guarded by team lock. It's not possible

	 * to traverse list in reverse under rcu_read_lock

/***********************

 * ethtool interface

/***********************

 * rt netlink interface

	/*

	 * Indicate we support unicast address filtering. That way core won't

	 * bring us to promisc mode in case a unicast addr is added.

	 * Let this up to underlay drivers.

 Don't allow team devices to change network namespaces. */

/***********************************

 * Generic netlink custom interface

/*

 * Netlink cmd functions should be locked by following two functions.

 * Since dev gets held here, that ensures dev won't disappear in between.

 != 0 for per-port options */

	/* If one port is selected, called wants to send port list containing

	 * only this port. Otherwise go through all listed ports and send all

/******************

 * Change checkers

 rtnl lock is held */

/************************************

 * Net device notifier event handler

 Forbid to change mtu of underlaying device */

 Forbid to change type of underlaying device */

 Propagate to master device */

/***********************

 * Module init and exit

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/net/team/team_mode_loadbalance.c - Load-balancing mode for team

 * Copyright (c) 2012 Jiri Pirko <jpirko@redhat.com>

 LACPDU packets should go to exact delivery */

 hash is a char */

 in tenths of second */

 priv extension */

 Basic tx selection based solely by hash */

 Hash to port mapping select tx port */

 If no valid port in the table, fall back to simple hash */

 Clear old filter data */

 set default tx port selector */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/net/team/team_mode_random.c - Random mode for team

 * Copyright (c) 2013 Jiri Pirko <jiri@resnulli.us>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/net/team/team_mode_activebackup.c - Active-backup mode for team

 * Copyright (c) 2011 Jiri Pirko <jpirko@redhat.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/net/team/team_mode_broadcast.c - Broadcast mode for team

 * Copyright (c) 2012 Jiri Pirko <jpirko@redhat.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * drivers/net/team/team_mode_roundrobin.c - Round-robin mode for team

 * Copyright (c) 2011 Jiri Pirko <jpirko@redhat.com>

/*

 * CoreChip-sz SR9700 one chip USB 1.1 Ethernet Devices

 *

 * Author : Liu Junliang <liujunliang_ljl@163.com>

 *

 * Based on dm9601.c

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2.  This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

 ready */

 access is 16bit */

 Access NSR_LINKST bit for link status instead of MII_BMSR */

 Get the Link Status directly */

	/* We use the 20 byte dev->data for our 8 byte filter buffer

	 * to avoid allocating memory that is tricky to free later

 rx_ctl setting : enable, disable_long, disable_crc */

 broadcast address */

 bulkin buffer is preferably not less than 3K */

	/* read MAC

	 * After Chip Power on, the Chip will reload the MAC from

	 * EEPROM automatically to PAR. In case there is no EEPROM externally,

	 * a default MAC address is stored in PAR for making chip work properly.

 power up and reset phy */

 at least 10ms, here 20ms for safe */

 at least 1ms, here 2ms for reading right register */

 receive broadcast packets */

	/* skb content (packets) format :

	 *                    p0            p1            p2    ......    pm

	 *                 /      \

	 *            /                \

	 *        /                            \

	 *  /                                        \

	 * p0b0 p0b1 p0b2 p0b3 ...... p0b(n-4) p0b(n-3)...p0bn

	 *

	 * p0 : packet 0

	 * p0b0 : packet 0 byte 0

	 *

	 * b0: rx status

	 * b1: packet length (incl crc) low

	 * b2: packet length (incl crc) high

	 * b3..n-4: packet data

	 * bn-3..bn: ethernet packet crc

 one skb may contains multiple packets */

 ignore the CRC length */

 the last packet of current skb */

 skb_clone is used for address align */

	/* SR9700 can only send out one ethernet packet at once.

	 *

	 * b0 b1 b2 b3 ...... b(n-4) b(n-3)...bn

	 *

	 * b0: rx status

	 * b1: packet length (incl crc) low

	 * b2: packet length (incl crc) high

	 * b3..n-4: packet data

	 * bn-3..bn: ethernet packet crc

	/* usbnet adds padding if length is a multiple of packet size

	 * if so, adjust length value in header

	/* format:

	   b0: net status

	   b1: tx status 1

	   b2: tx status 2

	   b3: rx status

	   b4: rx overflow

	   b5: rx count

	   b6: tx count

	   b7: gpr

 SR9700 device */

 END */

www.corechip-sz.com/");

 SPDX-License-Identifier: GPL-2.0-only

/******************************************************************************

 *

 * Driver for Option High Speed Mobile Devices.

 *

 *  Copyright (C) 2008 Option International

 *                     Filip Aben <f.aben@option.com>

 *                     Denis Joseph Barrow <d.barow@option.com>

 *                     Jan Dumon <j.dumon@option.com>

 *  Copyright (C) 2007 Andrew Bird (Sphere Systems Ltd)

 *  			<ajb@spheresystems.co.uk>

 *  Copyright (C) 2008 Greg Kroah-Hartman <gregkh@suse.de>

 *  Copyright (C) 2008 Novell, Inc.

 *

/******************************************************************************

 *

 * Description of the device:

 *

 * Interface 0:	Contains the IP network interface on the bulk end points.

 *		The multiplexed serial ports are using the interrupt and

 *		control endpoints.

 *		Interrupt contains a bitmap telling which multiplexed

 *		serialport needs servicing.

 *

 * Interface 1:	Diagnostics port, uses bulk only, do not submit urbs until the

 *		port is opened, as this have a huge impact on the network port

 *		throughput.

 *

 * Interface 2:	Standard modem interface - circuit switched interface, this

 *		can be used to make a standard ppp connection however it

 *              should not be used in conjunction with the IP network interface

 *              enabled for USB performance reasons i.e. if using this set

 *              ideally disable_net=1.

 *

 These definitions are used with the struct hso_net flags element */

 - use *_bit operations on it. (bit indices not values.) */

 Number of ttys to handle */

****************************************************************************/

 Debugging functions                                                       */

****************************************************************************/

****************************************************************************/

 Enumerators                                                               */

****************************************************************************/

****************************************************************************/

 Structs                                                                   */

****************************************************************************/

	/* rx/tx urb could be either a bulk urb or a control urb depending

 should contain allocated length */

 should contain allocated length */

 from usb_serial_port */

	/* Hacks required to get flow control

	 * working on the serial receive buffers

	 * so as not to drop characters on the floor.

 Type of interface */

 Type of port */

 Additional device info */

****************************************************************************/

 Prototypes                                                                */

****************************************************************************/

 Serial driver functions */

 Helper functions */

****************************************************************************/

 Helping functions                                                         */

****************************************************************************/

 #define DEBUG */

 Debugging functions */

 module parameters */

 driver info */

 the usb driver itself (registered in hso_init) */

 serial structures */

 list of devices we support */

 Icon-Edge */

 Module HSxPA */

 Icon-321 */

 Icon-322 */

 GE40x */

 GE40x */

 GE40x */

 GI 0401 */

 GTM 382 */

 GE40x */

 Option GTM671WFS */

 Sysfs attribute */

 converts mux value to a port spec value */

 converts port spec value to a mux value */

 log a meaningful explanation of an USB status */

 Network interface functions */

 called when net interface is brought up by ifconfig */

 setup environment */

 We are up and running. */

 Tell the kernel we are ready to start receiving from it */

 called when interface is brought down by ifconfig */

 we don't need the queue anymore */

 no longer running */

 done */

 USB tells is xmit done, we should start the netqueue again */

 Sanity check */

 Do we still have a valid kernel network device? */

	/* log status, but don't act on it, we don't need to resubmit anything

 Tell the network interface we are ready for another frame */

 called by kernel when we need to transmit a packet */

 Tell the kernel, "No more frames 'til we are done with this one." */

 log if asked */

 Copy it from kernel memory to OUR memory */

 Fill in the URB for shipping it out. */

 Deal with the Zero Length packet problem, I hope */

 Send the URB on its merry way. */

 we're done */

 called when a packet did not ack after watchdogtimeout */

 Tell syslog we are hosed. */

 Tear the waiting frame off the list */

 Update statistics */

 make a real packet from the received USB buffer */

 log if needed */

 waiting for IP header. */

 wanted bytes - size of ip header */

				/* header is complete allocate an sk_buffer and

 Allocate an sk_buff */

 We got no receive buffer. */

				/* Copy what we got so far. make room for iphdr

 ETH_HLEN */

 Filip actually use .tot_len */

			/* Copy the rest of the bytes that are left in the

 Make room for temp_bytes after tail. */

 Packet is complete. Inject into stack. */

 We have IP packet here */

 Ship it off to the kernel */

 No longer our buffer. */

 update out statistics */

 Recovery mechanism for WAIT_SYNC state. */

 Moving data from usb to kernel (in interrupt state) */

 is al ok?  (Filip: Who's Al ?) */

 Sanity check */

 Somebody killed our network interface... */

 do we even have a packet? */

		/* Handle the IP stream, add header and push it onto network

	/* We are done with this URB, resubmit it. Prep the USB to wait for

	/* Give this to the USB subsystem so it can tell us when more data

 Serial driver functions */

	/*

	 * The default requirements for this device are:

 disable ignore break */

 disable break causes interrupt */

 disable mark parity errors */

 disable clear high bit of input characters */

 disable translate NL to CR */

 disable ignore CR */

 disable translate CR to NL */

 disable enable XON/XOFF flow control */

 disable postprocess output characters */

 disable echo input characters */

 disable echo new line */

		| ICANON	/* disable erase, kill, werase, and rprnt

		| ISIG		/* disable interrupt, quit, and suspend special

 disable non-POSIX special characters */

 no size */

 disable parity bit */

 clear current baud rate */

 clear current buad rate */

 character size 8 bits */

 baud rate 115200 */

	/*

	 *	Fix up unsupported bits

 disable enable XON/XOFF flow control */

 no size */

 disable parity bit */

 clear current baud rate */

 clear current buad rate */

 character size 8 bits */

 baud rate 115200 */

	/* We are done with this URB, resubmit it. Prep the USB to wait for

	/* Give this to the USB subsystem so it can tell us when more data

 Re issue a read as long as we receive data. */

 read callback for Diag and CS port */

 sanity check */

 Anyone listening? */

 Valid data, handle RX data */

/*

 * This needs to be a tasklet otherwise we will

 * end up recursively calling this function.

 open the requested serial port */

 sanity check */

 setup */

 check for port already opened, if not set the termios */

 Force default termio settings */

 done */

 close the requested serial port */

 Open failed, no close cleanup required */

 reset the rts and dtr */

 do the actual close */

 close the requested serial port */

 sanity check */

 done */

 how much room is there for writing */

 return free room */

 setup the term */

 the actual setup */

 done */

 how many characters in the buffer */

 sanity check */

 Sanity checks */

 tiocmget is only supported on HSO_PORT_MODEM */

	/* wIndex should be the USB interface number of the port to which the

	 * notification applies, which should always be the Modem port.

/*

 * next few functions largely stolen from drivers/serial/serial_core.c

/* Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change

 * - mask passed in arg for lines of interest

 *   (use |'ed TIOCM_RNG/DSR/CD/CTS for masking)

 * Caller should use TIOCGICOUNT to see which one it was

	/*

	 * note the counters on entry

 see if a signal did it */

/*

 * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)

 * Return: write counters to the user passed counter struct

 * NB: both 1->0 and 0->1 transitions are counted except for

 *     RI where only 0->1 is counted.

 sanity check */

 sanity check */

 starts a transmit */

 Wakeup USB interface if necessary */

 Switch pointers around to avoid memcpy */

 If serial->tx_data is set, it means we switched buffers */

 make a request (for reading and writing data to muxed serial port) */

 Sanity check */

 initialize */

 Reading command */

 Writing command */

 syslog */

 Load ctrl urb */

 Send it on merry way */

 done */

 called by intr_callback when read occurs */

 clean data */

 make the request */

 used for muxed serial port callback (muxed serial read) */

 sanity check */

 status check */

 what request? */

 loop over all muxed ports to find the one sending this */

 max 8 channels on MUX */

					/* Setup and send a ctrl req read on

 Resubmit interrupt urb */

 called for writing to muxed serial port */

 write callback for Diag and CS port */

 sanity check */

 called for writing diag or CS serial port */

 callback after read or write on muxed serial port */

 sanity check */

 what request? */

 response to a read command */

 response to a write command */

 handle RX data for serial port */

 Sanity check */

 Push data to tty */

 Base driver functions */

 send URBs for all read buffers */

 Prep a receive URB */

 Put it out there so the device can send us stuff */

	/* If it is not the MUX port fill in and submit a bulk urb (already

 unlink and free RX URB */

 free the RX buffer */

 unlink and free TX URB */

 register our minor number */

 RX, allocate urb and initialize */

 prepare our RX buffer */

 TX, allocate urb and initialize */

 prepare our TX buffer */

 Creates a general hso device */

 Removes a network device in the network device table */

 Frees our network device */

 start freeing */

 initialize the network interface */

 fill in the other fields */

 and initialize the semaphore */

 Adds a network device in the network device table */

 Creates and sets up everything for rfkill */

 Creates our network device */

 allocate our network device, then we can put in our private data */

 call hso_net_init to do the basic initialization */

 start allocating */

 registering our net device */

 Frees an AT channel ( goes for both mux and non-mux ) */

 Creates a bulk AT channel */

 setup the proc dirs and files if needed */

 done, return it */

 Creates a multiplexed AT channel */

 setup the proc dirs and files if needed */

 done, return it */

 Gets the port spec for a certain interface */

 check if we have a valid interface */

 called once for each interface upon device insertion */

	/* Get the interface/port specification from either driver_info or from

		/* if_num is controlled by the device, driver_info is a 0 terminated

	/* Check if we need to switch to alt interfaces prior to port

 Allocate new hso device(s) */

 Create the network device */

 TODO: de-allocate everything */

 It's a regular bulk interface */

 save our data pointer in this device */

 done */

 device removed, cleaning up */

 remove reference of our private data */

 called by kernel when we need to suspend device */

 Stop all serial ports */

 Stop all network ports */

 called by kernel when we need to resume device */

 Start all serial ports */

 Start all network ports */

				/* First transmit any lingering data,

			/* hso_stop_net_device doesn't stop the net queue since

 Helper functions */

 Get the endpoint ! */

 Get the byte that describes which ports are enabled */

 interrupt urb needs to be submitted, used for serial read of muxed port */

 operations setup of the serial interface */

 put it in the log */

 Initialise the serial table semaphore and table */

 allocate our driver using the proper amount of supported minors */

 fill in all needed values */

 if major number is provided as parameter, use that one */

 register the tty driver */

 register this module as an usb driver */

 done */

 deregister the usb driver */

 Module definitions */

 change the debug level (eg: insmod hso.ko debug=0x04) */

 set the major tty number (eg: insmod hso.ko tty_major=245) */

 disable network interface (eg: insmod hso.ko disable_net=1) */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *  Copyright (c) 2001 Vojtech Pavlik

 *

 *  CATC EL1210A NetMate USB Ethernet driver

 *

 *  Sponsored by SuSE

 *

 *  Based on the work of

 *		Donald Becker

 * 

 *  Old chipset support added by Simon Evans <spse@secret.org.uk> 2002

 *    - adds support for Belkin F5U011

/*

 * 

 * Should you need to contact me, the author, you can do so either by

 * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:

 * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic

/*

 * Version information.

/*

 * Some defines.

 Time between stats updates */

 Max time the queue can be stopped */

 Max Ethernet packet size */

 Max packets per rx buffer (> 0, < 16) */

 Max full sized packets per tx buffer (> 0) */

 Max control requests in flight (power of two) */

 Max size of receive packet for F5U011 */

/*

 * Control requests.

 F5U011 only */

/*

 * Registers.

 F5U011 uses different bit */

/*

 * The catc struct.

 Set if device is an F5U011 */

 Used for F5U011 */

 Used for F5U011 - counter of waiting rx packets */

/*

 * Useful macros.

/*

 * Receive routines.

 F5U011 only does one packet per RX */

 success */

 unlink */

 -EPIPE:  should clear the halt */

 error */

/*

 * Transmit routines.

/*

 * Control messages.

/*

 * Statistics.

/*

 * Receive modes. Broadcast, Multicast, Promisc.

/*

 * Open, close.

/*

 * USB probe, disconnect.

 The F5U011 has the same vendor/product as the netmate but a device version of 0x130 */

/*

 * Module functions and tables.

 CATC Netmate, Belkin F5U011 */

 CATC Netmate II, Belkin F5U111 */

 smartBridges smartNIC */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * USB CDC EEM network interface driver

 * Copyright (C) 2009 Oberthur Technologies

 * by Omar Laazimani, Olivier Condemine

/*

 * This driver is an implementation of the CDC "Ethernet Emulation

 * Model" (EEM) specification, which encapsulates Ethernet frames

 * for transport over USB using a simpler USB device model than the

 * previous CDC "Ethernet Control Model" (ECM, or "CDC Ethernet").

 *

 * For details, see https://usb.org/sites/default/files/CDC_EEM10.pdf

 *

 * This version has been tested with GIGAntIC WuaoW SIM Smart Card on 2.6.24,

 * 2.6.27 and 2.6.30rc2 kernel.

 * It has also been validated on Openmoko Om 2008.12 (based on 2.6.24 kernel).

 * build on 23-April-2009

 2 byte header */

-------------------------------------------------------------------------*/

 no jumbogram (16K) support for now */

/*

 * EEM permits packing multiple Ethernet frames into USB transfers

 * (a "bundle"), but for TX we don't try to do that.

	/* When ((len + EEM_HEAD + ETH_FCS_LEN) % dev->maxpacket) is

	 * zero, stick two bytes of zero length EEM packet on the end.

	 * Else the framework would add invalid single byte padding,

	 * since it can't know whether ZLPs will be handled right by

	 * all the relevant hardware and software.

 we don't use the "no Ethernet CRC" option */

	/* EEM packet header format:

	 * b0..13:	length of ethernet frame

	 * b14:		bmCRC (1 == valid Ethernet CRC)

	 * b15:		bmType (0 == data)

 Bundle a zero length EEM packet if needed */

	/*

	 * Our task here is to strip off framing, leaving skb with one

	 * data frame for the usbnet framework code to process.  But we

	 * may have received multiple EEM payloads, or command payloads.

	 * So we must process _everything_ as if it's a header, except

	 * maybe the last data payload

	 *

	 * REVISIT the framework needs updating so that when we consume

	 * all payloads (the last or only message was a command, or a

	 * zero length EEM packet) that is not accounted as an rx_error.

 incomplete EEM header? */

		/*

		 * EEM packet header format:

		 * b0..14:	EEM type dependent (Data or Command)

		 * b15:		bmType

		/*

		 * The bmType bit helps to denote when EEM

		 * packet is data or command :

		 *	bmType = 0	: EEM data payload

		 *	bmType = 1	: EEM (link) command

			/*

			 * EEM (link) command packet:

			 * b0..10:	bmEEMCmdParam

			 * b11..13:	bmEEMCmd

			 * b14:		bmReserved (must be 0)

			 * b15:		1 (EEM command)

 Responding to echo requests is mandatory. */

 Echo command */

 bogus command? */

			/*

			 * Host may choose to ignore hints.

			 *  - suspend: peripheral ready to suspend

			 *  - response: suggest N millisec polling

			 *  - response complete: suggest N sec polling

			 *

			 * Suspend is reported and maybe heeded.

 Suspend hint */

 Response hint */

 Response complete hint */

			/*

			 * Hosts should never receive host-to-peripheral

			 * or reserved command codes; or responses to an

			 * echo command we didn't send.

 Echo response */

 Tickle */

 reserved */

 zero length EEM packet? */

			/*

			 * EEM data packet header :

			 * b0..13:	length of ethernet frame

			 * b14:		bmCRC

			 * b15:		0 (EEM data)

 bogus EEM payload? */

 bogus ethernet frame? */

			/*

			 * Treat the last payload differently: framework

			 * code expects our "fixup" to have stripped off

			 * headers, so "skb" is a data packet (or error).

			 * Else if it's not the last payload, keep "skb"

			 * for further processing.

			/*

			 * The bmCRC helps to denote when the CRC field in

			 * the Ethernet frame contains a calculated CRC:

			 *	bmCRC = 1	: CRC is calculated

			 *	bmCRC = 0	: CRC = 0xDEADBEEF

-------------------------------------------------------------------------*/

 EMPTY == end of list */

 SPDX-License-Identifier: GPL-2.0-only

/* huawei_cdc_ncm.c - handles Huawei devices using the CDC NCM protocol as

 * transport layer.

 * Copyright (C) 2013	 Enrico Mioso <mrkiko.rs@gmail.com>

 *

 * ABSTRACT:

 * This driver handles devices resembling the CDC NCM standard, but

 * encapsulating another protocol inside it. An example are some Huawei 3G

 * devices, exposing an embedded AT channel where you can set up the NCM

 * connection.

 * This code has been heavily inspired by the cdc_mbim.c driver, which is

 * Copyright (c) 2012  Smith Micro Software, Inc.

 * Copyright (c) 2012  Bjørn Mork <bjorn@mork.no>

 Driver data */

 can be called while disconnecting */

	/* altsetting should always be 1 for NCM devices - so we hard-coded

	 * it here. Some huawei devices will need the NDP part of the NCM package to

	 * be at the end of the frame.

	/* For many Huawei devices the NTB32 mode is the default and the best mode

	 * they work with. Huawei E5785 and E5885 devices refuse to work in NTB16 mode at all.

		/* The wMaxCommand buffer must be big enough to hold

		 * any message from the modem. Experience has shown

		 * that some replies are more than 256 bytes long

 wMaxCommand */

 Prevent usbnet from using the status descriptor */

 should we call subdriver's resume function? */

 Huawei NCM devices disguised as vendor specific */

 Terminating entry */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Copyright (c) 2014 Realtek Semiconductor Corp. All rights reserved.

 Information for net-next */

 Information for net */

 RTL_VER_04 only */

 RTL_VER_04 only */

 CONFIG1, CONFIG2 */

 CONFIG3, CONFIG4 */

 CONFIG6 */

 RTL8153A */

 RTL8153B */

 RTL8153A */

 RTL8153B */

 RTL8153B */

 RTL8153A */

 RTL8153B */

 OCP Registers */

 nway state for 8153 */

 SRAM Register */

 PLA_RCR */

 PLA_RCR1 */

 PLA_RXFIFO_CTRL0 */

 PLA_RXFIFO_FULL */

 PLA_RXFIFO_CTRL1 */

 PLA_RXFIFO_CTRL2 */

 PLA_TXFIFO_CTRL */

 PLA_DMY_REG0 */

 PLA_FMC */

 PLA_EEEP_CR */

 PLA_WDT6_CTRL */

 PLA_TCR0 */

 PLA_TCR1 */

 PLA_MTPS */

 PLA_RSTTALLY */

 PLA_CR */

 PLA_CRWECR */

 PLA_OOB_CTRL */

 PLA_MISC_1 */

 PLA_SFF_STS_7 */

 PLA_CPCR */

 PLA_CFG_WOL */

 PLA_TEREDO_CFG */

 PLA_BDC_CR */

 PLA_EFUSE_CMD */

 PLA_CONFIG34 */

 PLA_CONFIG6 */

 PLA_USB_CFG */

 PLA_CONFIG5 */

 PLA_LED_FEATURE */

 PLA_PHY_PWR */

 PLA_MAC_PWR_CTRL */

 PLA_MAC_PWR_CTRL2 */

 PLA_MAC_PWR_CTRL3 */

 PLA_MAC_PWR_CTRL4 */

 PLA_GPHY_INTR_IMR */

 PLA_PHYAR */

 PLA_EEE_CR */

 PLA_BOOT_CTRL */

 PLA_LWAKE_CTRL_REG */

 PLA_SUSPEND_FLAG */

 PLA_INDICATE_FALG */

 PLA_MACDBG_PRE and PLA_MACDBG_POST */

 PLA_EXTRA_STATUS */

 RTL_VER_05 only */

 PLA_GPHY_CTRL */

 PLA_POL_GPIO_CTRL */

 USB_USB2PHY */

 USB_SSPHYLINK1 */

 USB_SSPHYLINK2 */

 USB_CSR_DUMMY1 */

 USB_CSR_DUMMY2 */

 USB_DEV_STAT */

 USB_FW_FIX_EN0 */

 USB_FW_FIX_EN1 */

 USB_LPM_CONFIG */

 USB_TX_AGG */

 USB_RX_BUF_TH */

 USB_TX_DMA */

 USB_BMU_RESET */

 USB_BMU_CONFIG */

 USB_UPT_RXDMA_OWN */

 USB_FW_TASK */

 USB_RX_AGGR_NUM */

 USB_UPS_CTRL */

 USB_PM_CTRL_STATUS */

 USB_ECM_OPTION */

 USB_CSTMR */

 USB_MISC_2 */

 USB_ECM_OP */

 USB_GPHY_CTRL */

 USB_SPEED_OPTION */

 USB_FW_CTRL */

 USB_FC_TIMER */

 USB_USB_CTRL */

 USB_U2P3_CTRL */

 USB_POWER_CUT */

 USB_MISC_0 */

 USB_RX_EARLY_TIMEOUT */

 USB_WDT1_CTRL */

 USB_WDT11_CTRL */

 USB_LPM_CTRL */

 bit 4 ~ 5: fifo empty boundary */

 0x1fb * 64 = 32448 bytes */

 bit 2 ~ 3: LMP timer */

 500 ms */

 500 us */

 USB_AFE_CTRL2 */

 USB_UPHY_XTAL */

 USB_UPS_CFG */

 RTL8156A */

 USB_UPS_FLAGS */

 OCP_ALDPS_CONFIG */

 OCP_PHY_STATUS */

 OCP_NCTL_CFG */

 OCP_POWER_CFG */

 OCP_EEE_CONFIG1 */

 bit 4 ~ 6 */

 bit 0 ~ 2 */

 OCP_EEE_CONFIG2 */

 bit 12 ~ 15 */

 OCP_EEE_CONFIG3 */

 bit 7 ~ 15 */

 bit 6 ~ 5 */

 bit 0 ~ 3 */

 OCP_EEE_AR */

 bit[15:14] function */

 bit[4:0] device addr */

 OCP_EEE_CFG */

 OCP_DOWN_SPEED */

 OCP_10GBT_CTRL */

 Advertise 2.5GBASE-T fast-retrain */

 OCP_PHY_STATE */

 OCP_PHY_PATCH_STAT */

 OCP_PHY_PATCH_CMD */

 OCP_PHY_LOCK */

 OCP_ADC_CFG */

 OCP_SYSCLK_CFG */

 SRAM_GREEN_CFG */

 SRAM_LPF_CFG */

 SRAM_10M_AMP1 */

 SRAM_10M_AMP2 */

 SRAM_IMPEDANCE */

 SRAM_PHY_LOCK */

 MAC PASSTHRU */

 RTL_VER_04 only */

 rtl8152 flags */

 IP checksum fail */

 UDP checksum fail */

 TCP checksum fail */

 First segment of a packet */

 Final segment of a packet */

 Calculate UDP/IP checksum */

 Calculate TCP/IP checksum */

 Calculate IPv4 checksum */

 Calculate IPv6 checksum */

 use for hw setting */

/**

 * struct fw_block - block type and total length

 * @type: type of the current block, such as RTL_FW_END, RTL_FW_PLA,

 *	RTL_FW_USB and so on.

 * @length: total length of the current block.

/**

 * struct fw_header - header of the firmware file

 * @checksum: checksum of sha256 which is calculated from the whole file

 *	except the checksum field of the file. That is, calculate sha256

 *	from the version field to the end of the file.

 * @version: version of this firmware.

 * @blocks: the first firmware block of the file

/**

 * struct fw_mac - a firmware block used by RTL_FW_PLA and RTL_FW_USB.

 *	The layout of the firmware block is:

 *	<struct fw_mac> + <info> + <firmware data>.

 * @blk_hdr: firmware descriptor (type, length)

 * @fw_offset: offset of the firmware binary data. The start address of

 *	the data would be the address of struct fw_mac + @fw_offset.

 * @fw_reg: the register to load the firmware. Depends on chip.

 * @bp_ba_addr: the register to write break point base address. Depends on

 *	chip.

 * @bp_ba_value: break point base address. Depends on chip.

 * @bp_en_addr: the register to write break point enabled mask. Depends

 *	on chip.

 * @bp_en_value: break point enabled mask. Depends on the firmware.

 * @bp_start: the start register of break points. Depends on chip.

 * @bp_num: the break point number which needs to be set for this firmware.

 *	Depends on the firmware.

 * @bp: break points. Depends on firmware.

 * @reserved: reserved space (unused)

 * @fw_ver_reg: the register to store the fw version.

 * @fw_ver_data: the firmware version of the current type.

 * @info: additional information for debugging, and is followed by the

 *	binary data of firmware.

 any value determined by firmware */

/**

 * struct fw_phy_patch_key - a firmware block used by RTL_FW_PHY_START.

 *	This is used to set patch key when loading the firmware of PHY.

 * @blk_hdr: firmware descriptor (type, length)

 * @key_reg: the register to write the patch key.

 * @key_data: patch key.

 * @reserved: reserved space (unused)

/**

 * struct fw_phy_nc - a firmware block used by RTL_FW_PHY_NC.

 *	The layout of the firmware block is:

 *	<struct fw_phy_nc> + <info> + <firmware data>.

 * @blk_hdr: firmware descriptor (type, length)

 * @fw_offset: offset of the firmware binary data. The start address of

 *	the data would be the address of struct fw_phy_nc + @fw_offset.

 * @fw_reg: the register to load the firmware. Depends on chip.

 * @ba_reg: the register to write the base address. Depends on chip.

 * @ba_data: base address. Depends on chip.

 * @patch_en_addr: the register of enabling patch mode. Depends on chip.

 * @patch_en_value: patch mode enabled mask. Depends on the firmware.

 * @mode_reg: the regitster of switching the mode.

 * @mode_pre: the mode needing to be set before loading the firmware.

 * @mode_post: the mode to be set when finishing to load the firmware.

 * @reserved: reserved space (unused)

 * @bp_start: the start register of break points. Depends on chip.

 * @bp_num: the break point number which needs to be set for this firmware.

 *	Depends on the firmware.

 * @bp: break points. Depends on firmware.

 * @info: additional information for debugging, and is followed by the

 *	binary data of firmware.

/* Maximum number of multicast addresses to filter (vs. Rx-all-multicast).

 * The RTL chips use a 64 element hash table based on the Ethernet CRC.

 both size and indix must be 4 bytes align */

 both size and indix must be 4 bytes align */

/* Devices containing proper chips can support a persistent

 * host system provided MAC address.

 * Examples of this are Dell TB15 and Dell WD15 docks

 test for -AD variant of RTL8153 */

 test for MAC address pass-through bit */

 test for RTL8153-BND and RTL8153-BD */

 returns _AUXMAC_#AABBCCDDEEFF# */

			/* if device doesn't support MAC pass through this will

			 * be expected to be non-zero

 When link down, the driver would cancel all bulks. */

 This avoid the re-submitting bulk */

 the urb is in unlink state */

 success */

 unlink */

 -EPIPE:  should clear the halt */

/* r8152_csum_workaround()

 * The hw limits the value of the transport offset. When the offset is out of

 * range, calculate the checksum by sw.

 limit the skb numbers for rx_queue */

 When link down, the driver would cancel all bulks. */

 This avoid the re-submitting bulk */

 The rx would be stopped, so skip submitting */

 Multicast hash filter */

 Unconditionally log net taps. */

 Too many to filter perfectly -- accept all multicasts. */

 Only RTL8152_MAX_RX rx_agg need to be submitted. */

	/* The usb_kill_urb() couldn't be used in atomic.

	 * Therefore, move the list of rx_info to a tmp one.

	 * Then, list_for_each_entry_safe could be used without

	 * spin lock.

		/* At least RTL8152_MAX_RX rx_agg have the page_count being

		 * equal to 1, so the other ones could be freed safely.

 Move back the list of temp to the rx_info */

		/* The RTL8153B uses USB_RX_EXTRA_AGGR_TMR for rx timeout

		 * primarily. For USB_RX_EARLY_TIMEOUT, we fix it to 128ns.

 MAC clock speed down */

 MAC clock speed down */

 aldps_spdwn_ratio, tp10_spdwn_ratio */

 eee_spdwn_ratio */

 10M abiq&ldvbias */

 100M short abiq&ldvbias */

 1000M short abiq&ldvbias */

 10M abiq&ldvbias */

 100M short abiq&ldvbias */

 1000M short abiq&ldvbias */

		/* The bit 0 ~ 7 are relative with teredo settings. They are

		 * W1C (write 1 to clear), so set all 1 to disable it.

 Clear the bp to stop the firmware before loading a new one */

 wait 3 ms to make sure the firmware is stopped */

/* Verify the checksum for the firmware file. It is calculated from the version

 * field to the end of the file. Compare the result with the checksum field to

 * make sure the file is correct.

 next block */

	/* Enable backup/restore of MACDBG. This is required after clearing PLA

	 * break points and before applying the PLA firmware.

 rx share fifo credit full threshold */

 rx share fifo credit near full threshold */

 rx share fifo credit near full threshold */

 TX share fifo free credit full threshold */

 Wait till the WTD timer is ready. It would take at most 104 ms. */

 set USB_BP_4 to support USB_SPEED_SUPER only */

 reset UPHY timer to 36 ms */

 enable bp0 if support USB_SPEED_SUPER only */

 reset UPHY timer to 36 ms */

 enable U3P3 check, set the counter to 4 */

 enable fc timer and set timer to 1 second. */

 enable bp0 for RTL8153-BND */

 Modify U3PHY parameter for compatibility issue */

 disable ALDPS before updating the PHY parameters */

 disable EEE before updating the PHY parameters */

 Enable LPF corner auto tune */

 Adjust 10M Amplitude */

 data of bit16 */

 disable ALDPS before updating the PHY parameters */

 disable EEE before updating the PHY parameters */

 U1/U2/L1 idle timer. 500 us */

	/* ADC Bias Calibration:

	 * read efuse offset 0x7d to get a 17-bit data. Remove the dummy/fake

	 * bit (bit3) to rebuild the real 16-bit data. Write the data to the

	 * ADC ioffset.

	/* ups mode tx-link-pulse timing adjustment:

	 * rg_saw_cnt = OCP reg 0xC426 Bit[13:0]

	 * swr_cnt_1ms_ini = 16000000 / rg_saw_cnt

 Advnace EEE */

 rx share fifo credit full threshold */

 TX share fifo free credit full threshold */

		/* Clear teredo wake event. bit[15:8] is the teredo wakeup

		 * type. Set it to zero. bits[7:0] are the W1C bits about

		 * the events. Set them to all 1 to clear them.

 USB 0xb45e[3:0] l1_nyet_hird */

	/* Adjust the tx fifo free credit full threshold, otherwise

	 * the fifo would be too small to send a jumbo frame packet.

 rx share fifo credit full threshold */

 TX share fifo free credit full threshold */

 share FIFO settings */

	/* Clear teredo wake event. bit[15:8] is the teredo wakeup

	 * type. Set it to zero. bits[7:0] are the W1C bits about

	 * the events. Set them to all 1 to clear them.

 phy state */

 bit 15: TXDIS_STATE, bit 14: ABD_STATE */

	/* If the device is unplugged or !netif_running(), the workqueue

	 * doesn't need to wake the device, and could return directly.

 don't schedule tasket before linking */

		/* Delay execution in case request_firmware() is not ready yet.

 enable rx aggregation */

 rx aggregation */

 MSC timer = 0xfff * 8ms = 32760 ms */

 MAC clock speed down */

 Disable Test IO for 32QFN */

 rx aggregation */

 15 us */

 Disable spi_en */

 MSC timer = 0xfff * 8ms = 32760 ms */

 MAC clock speed down */

 rx aggregation */

 15 us */

 disable ALDPS before updating the PHY parameters */

 disable EEE before updating the PHY parameters */

 AAGC */

 EEE parameter */

  XG PLL */

 GIGA Master */

 Advance EEE */

 enable ADC Ibias Cal */

 enable Thermal Sensor */

 Nway 2.5G Lite */

 CS DSP solution */

 MDI SWAP */

 p0 */

 p3 */

 p0 */

 p3 */

 p1 */

 p2 */

 p1 */

 p2 */

 disable ALDPS before updating the PHY parameters */

 disable EEE before updating the PHY parameters */

 2.5G INRX */

 EEE parameter */

 ADC_PGA parameter */

 Green Table-PGA, 1G full viterbi */

 XG PLL */

 MSC timer = 0xfff * 8ms = 32760 ms */

 U1/U2/L1 idle timer. 500 us */

 rx aggregation */

 15 us */

 MSC timer = 0xfff * 8ms = 32760 ms */

 U1/U2/L1 idle timer. 500 us */

 enable fc timer and set timer to 600 ms. */

 rx aggregation */

 15 us */

 Check Rx endpoint address */

 Check Tx endpoint address */

 Check interrupt endpoint address */

 The vendor mode is not always config #1, so to find it out. */

 reset the MAC address in case of policy change */

	/* This means a linking change occurs and the driver doesn't detect it,

	 * yet. If the driver has disabled tx/rx and hw is linking on, the

	 * device wouldn't wake up by receiving any packet.

	/* If the linking down is occurred by nway, the device may miss the

	 * linking change event. And it wouldn't wake when linking on.

 Internal PHY */

 MTU range: 68 - 1500 or 9194 */

 Retry in case request_firmware() is not ready yet. */

 table of devices that work with this driver */

 Realtek */

 Microsoft */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * GeneSys GL620USB-A based links

 * Copyright (C) 2001 by Jiun-Jie Huang <huangjj@genesyslogic.com.tw>

 * Copyright (C) 2001 by Stanislav Brabec <utx@penguin.cz>

 #define	DEBUG			
 #define	VERBOSE			
/*

 * GeneSys GL620USB-A (www.genesyslogic.com.tw)

 *

 * ... should partially interop with the Win32 driver for this hardware.

 * The GeneSys docs imply there's some NDIS issue motivating this framing.

 *

 * Some info from GeneSys:

 *  - GL620USB-A is full duplex; GL620USB is only half duplex for bulk.

 *    (Some cables, like the BAFO-100c, use the half duplex version.)

 *  - For the full duplex model, the low bit of the version code says

 *    which side is which ("left/right").

 *  - For the half duplex type, a control/interrupt handshake settles

 *    the transfer direction.  (That's disabled here, partially coded.)

 *    A control URB would block until other side writes an interrupt.

 *

 * Original code from Jiun-Jie Huang <huangjj@genesyslogic.com.tw>

 * and merged into "usbnet" by Stanislav Brabec <utx@penguin.cz>.

 control msg write command

 interrupt pipe index

 interrupt read buffer size

 interrupt pipe interval value

 max transmit packet number per transmit

 max packet length

 max receive buffer size

 This check is no longer done by usbnet */

 get the packet count of the received skb

 set the current packet pointer to the first packet

 decrement the length for the packet count size 4 bytes

 get the packet length

 this may be a broken packet

 allocate the skb for the individual packet

 copy the packet data to the new skb

 advance to the next packet

 shift the data pointer to the next gl_packet

 skip the packet length field 4 bytes

 FIXME:  magic numbers, bleech

 attach the packet count to the header

 add padding byte

 GL620USB-A

	/* NOT: USB_DEVICE(0x05e3, 0x0501),	// GL620USB

	 * that's half duplex, not currently supported

 END

 SPDX-License-Identifier: GPL-2.0-or-later

 /***************************************************************************

 *

 * Copyright (C) 2007-2010 SMSC

 *

/* Loop until the read is completed with timeout

 confirm MII not busy */

 set the address, index & direction (read from PHY) */

 confirm MII not busy */

 set the address, index & direction (write to PHY) */

 Issue write/erase enable command */

 Fill data register */

 Send "write" command */

 returns hash bit number for given MAC address */

 defer register writes to a sleepable context */

 set fct_flow thresholds to 20% and 80% */

 write to clear phy interrupt status */

 maybe the boot loader passed the MAC address in devicetree */

 device tree values are valid so use them */

 try reading mac address from EEPROM */

 eeprom values are valid so use them */

 no useful static MAC address found. generate a random one */

 Initialize MII structure */

 reset phy and wait for reset to complete */

 phy workaround for gig link */

 read and write to clear phy interrupt status */

 add 4 to size for FCS */

 Enable or disable Rx checksum offload engine */

 it's racing here! */

 Set the phy in Gig loopback */

 Wait for the link up */

 phy reset */

 set FIFO sizes */

 only set default GPIO/LED settings if no EEPROM is detected */

 Don't need rfe_ctl_lock during initialisation */

 Enable or disable checksum offload engines */

 enable PHY interrupts */

 allow mac to detect speed and duplex from phy */

 Init all registers */

 clear wol status, enable energy detection */

 clear wol status */

 read to clear */

 enable interrupt source */

 first, a dummy read, needed to latch some MII phys */

 interface is ifconfig down so fully power down hw */

 link is down so enter EDPD mode */

 enable PHY wakeup events for if cable is attached */

 enable PHY wakeup events so we remote wakeup if cable is pulled */

 determine if link is up using only _nopm functions */

 if we get this far we're not autosuspending */

	/* if no wol options set, or if link is down and we're not waking on

	 * PHY activity, enter lowest power SUSPEND2 mode

 disable energy detect (link up) & wake up events */

		/* if link is down then configure EDPD and enter SUSPEND1,

		 * otherwise enter SUSPEND0 below

 enable energy detect power-down mode */

 enter SUSPEND1 mode */

 disable all filters */

 clear any pending pattern match packet status */

 disable magic, bcast & unicast wakeup sources */

 clear wol status, enable energy detection */

 clear any pending magic packet status */

 enable receiver to enable frame reception */

 some wol options are enabled, so enter SUSPEND0 */

	/*

	 * TODO: resume() might need to handle the suspend failure

	 * in system sleep

 do this first to ensure it's cleared even in error case */

 Disable wakeup sources */

 clear wake-up status */

 This check is no longer done by usbnet */

 get the packet length */

 MAX_SINGLE_PACKET_SIZE + 4(CRC) + 2(COE) + 4(Vlan) */

 last frame in this batch */

 remove fcs */

 remove fcs */

 padding bytes before the next frame starts */

 SMSC7500 USB Gigabit Ethernet Device */

 SMSC7500 USB Gigabit Ethernet Device */

 END */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * CDC Ethernet based networking peripherals

 * Copyright (C) 2003-2005 by David Brownell

 * Copyright (C) 2006 by Ole Andre Vadla Ravnas (ActiveSync)

 #define	DEBUG			
 #define	VERBOSE			
	/* filtering on the device is an optional feature and not worth

	 * the hassle so we just roughly care about snooping and if any

	 * multicast is requested, we take every multicast

 We need to override usbnet_*_link_ksettings in bind() */

/* probes control interface, claims data interface, collects the bulk

 * endpoints, activates data interface (if needed), maybe sets MTU.

 * all pure cdc, except for certain firmware workarounds, and knowing

 * that rndis uses one different rule.

	/* expect strict spec conformance for the descriptors, but

	 * cope with firmware which stores them in the wrong place

		/* Motorola SB4100 (and others: Brad Hards says it's

		 * from a Broadcom design) put CDC descriptors here

	/* Maybe CDC descriptors are after the endpoint?  This bug has

	 * been seen on some 2Wire Inc RNDIS-ish products.

	/* this assumes that if there's a non-RNDIS vendor variant

	 * of cdc-acm, it'll fail RNDIS requests cleanly.

 in that case a quirk is mandatory */

	/* we need a master/control interface (what we're

	 * probed with) and a slave/data interface; union

	 * descriptors sort this all out.

 fall back to hard-wiring for RNDIS */

		/* Ambit USB Cable Modem (and maybe others)

		 * interchanges master and slave interface.

 some devices merge these - skip class check */

 a data interface altsetting does the real i/o */

	/* Communication class functions with bmCapabilities are not

	 * RNDIS.  But some Wireless class RNDIS functions use

	 * bmCapabilities for their own purpose. The failsafe is

	 * therefore applied only to Communication class RNDIS

	 * functions.  The rndis test is redundant, but a cheap

	 * optimization.

		/* because of Zaurus, we may be ignoring the host

		 * side link address we were given.

	/* Microsoft ActiveSync based and some regular RNDIS devices lack the

	 * CDC descriptors, so we'll hard-wire the interfaces and not check

	 * for descriptors.

	 *

	 * Some Android RNDIS devices have a CDC Union descriptor pointing

	 * to non-existing interfaces.  Ignore that and attempt the same

	 * hard-wired 0 and 1 interfaces.

	/* claim data interface and set it up ... with side effects.

	 * network traffic can't flow until an altsetting is enabled.

 ensure immediate exit from usbnet_disconnect */

 status endpoint: optional for CDC Ethernet, not RNDIS (or ACM) */

 override ethtool_ops */

/* like usbnet_generic_cdc_bind() but handles filter initialization

 * correctly

	/* Some devices don't initialise properly. In particular

	 * the packet filter is not reset. There are devices that

	 * don't do reset all the way. So the packet filter should

	 * be set to a sane initial value.

 combined interface - nothing  to do */

 disconnect master --> disconnect slave */

 ensure immediate exit from usbnet_disconnect */

 and vice versa (just in case) */

 ensure immediate exit from usbnet_disconnect */

/* Communications Device Class, Ethernet Control model

 *

 * Takes two interfaces.  The DATA interface is inactive till an altsetting

 * is selected.  Configuration data includes class descriptors.  There's

 * an optional status endpoint on the control interface.

 *

 * This should interop with whatever the 2.4 "CDCEther.c" driver

 * (by Brad Hards) talked with, with more functionality.

 SPEED_CHANGE can get split into two 8-byte packets */

 tx/rx rates */

	/* USB_CDC_NOTIFY_RESPONSE_AVAILABLE can happen too (e.g. RNDIS),

	 * but there are no standard formats for the response data.

/* Make sure packets have correct destination MAC address

 *

 * A firmware bug observed on some devices (ZTE MF823/831/910) is that the

 * device sends packets with a static, bogus, random MAC address (event if

 * device MAC address has been updated). Always set MAC address to that of the

 * device.

/* Ensure correct link state

 *

 * Some devices (ZTE MF823/831/910) export two carrier on notifications when

 * connected. This causes the link state to be incorrect. Work around this by

 * always setting the state to off, then on.

-------------------------------------------------------------------------*/

/* BLACKLIST !!

 *

 * First blacklist any products that are egregiously nonconformant

 * with the CDC Ethernet specs.  Minor braindamage we cope with; when

 * they're not even trying, needing a separate driver is only the first

 * of the differences to show up.

/* SA-1100 based Sharp Zaurus ("collie"), or compatible;

 * wire-incompatible with true CDC Ethernet implementations.

 * (And, it seems, needlessly so...)

/* PXA-25x based Sharp Zaurii.  Note that it seems some of these

 * (later models especially) may have shipped only with firmware

 * advertising false "CDC MDLM" compatibility ... but we're not

 * clear which models did that, so for now let's assume the worst.

 A-300 */

 B-500/SL-5600 */

 C-700 */

 C-750 C-760 */

 SL-6000 */

 reported with some C860 units */

 C-860 */

/* Olympus has some models with a Zaurus-compatible option.

 * R-1000 uses a FreeScale i.MXL cpu (ARMv4T)

 R-1000 */

 LG Electronics VL600 wants additional headers on every frame */

 Logitech Harmony 900 - uses the pseudo-MDLM (BLAN) driver */

 Novatel USB551L and MC551 - handled by qmi_wwan */

 Novatel E362 - handled by qmi_wwan */

 Dell Wireless 5800 (Novatel E362) - handled by qmi_wwan */

 Dell Wireless 5800 (Novatel E362) - handled by qmi_wwan */

 Dell Wireless 5804 (Novatel E371) - handled by qmi_wwan */

 Novatel Expedite E371 - handled by qmi_wwan */

 HP lt2523 (Novatel E371) - handled by qmi_wwan */

 AnyDATA ADU960S - handled by qmi_wwan */

 Huawei E1820 - handled by qmi_wwan */

 Realtek RTL8152 Based USB 2.0 Ethernet Adapters */

 Realtek RTL8153 Based USB 3.0 Ethernet Adapters */

 Samsung USB Ethernet Adapters */

 Linksys USB3GIGV1 Ethernet Adapter */

 ThinkPad USB-C Dock (based on Realtek RTL8153) */

 ThinkPad Thunderbolt 3 Dock (based on Realtek RTL8153) */

 ThinkPad Thunderbolt 3 Dock Gen 2 (based on Realtek RTL8153) */

 Lenovo Thinkpad USB 3.0 Ethernet Adapters (based on Realtek RTL8153) */

 Lenovo USB C to Ethernet Adapter (based on Realtek RTL8153) */

 Lenovo USB-C Travel Hub (based on Realtek RTL8153) */

 Lenovo Powered USB-C Travel Hub (4X90S92381, based on Realtek RTL8153) */

 ThinkPad USB-C Dock Gen 2 (based on Realtek RTL8153) */

 NVIDIA Tegra USB 3.0 Ethernet Adapters (based on Realtek RTL8153) */

 Microsoft Surface 2 dock (based on Realtek RTL8152) */

 Microsoft Surface Ethernet Adapter (based on Realtek RTL8153) */

 Microsoft Surface Ethernet Adapter (based on Realtek RTL8153B) */

 TP-LINK UE300 USB 3.0 Ethernet Adapters (based on Realtek RTL8153) */

 Aquantia AQtion USB to 5GbE Controller (based on AQC111U) */

 ASIX USB 3.1 Gen1 to 5G Multi-Gigabit Ethernet Adapter(based on AQC111U) */

 ASIX USB 3.1 Gen1 to 2.5G Multi-Gigabit Ethernet Adapter(based on AQC112U) */

 USB-C 3.1 to 5GBASE-T Ethernet Adapter (based on AQC111U) */

 QNAP QNA-UC5G1T USB to 5GbE Adapter (based on AQC111U) */

/* WHITELIST!!!

 *

 * CDC Ether uses two interfaces, not necessarily consecutive.

 * We match the main interface, ignoring the optional device

 * class so we could handle devices that aren't exclusively

 * CDC ether.

 *

 * NOTE:  this match must come AFTER entries blacklisting devices

 * because of bugs/quirks in a given product (like Zaurus, above).

 ZTE (Vodafone) K3805-Z */

 ZTE (Vodafone) K3806-Z */

 ZTE (Vodafone) K4510-Z */

 ZTE (Vodafone) K3770-Z */

 ZTE (Vodafone) K3772-Z */

 Telit modules */

 Dell DW5580 modules */

 Huawei ME906 and ME909 */

 ZTE modules */

 U-blox TOBY-L2 */

 U-blox SARA-U2 */

 Cinterion PLS8 modem by GEMALTO */

 Cinterion AHS3 modem by GEMALTO */

 Cinterion PLS83/PLS63 modem by GEMALTO/THALES */

 Various Huawei modems with a network port like the UMG1831 */

 END */

/*

 * ipheth.c - Apple iPhone USB Ethernet driver

 *

 * Copyright (c) 2009 Diego Giagio <diego@giagio.com>

 * All rights reserved.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions

 * are met:

 * 1. Redistributions of source code must retain the above copyright

 *    notice, this list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright

 *    notice, this list of conditions and the following disclaimer in the

 *    documentation and/or other materials provided with the distribution.

 * 3. Neither the name of GIAGIO.COM nor the names of its contributors

 *    may be used to endorse or promote products derived from this software

 *    without specific prior written permission.

 *

 * Alternatively, provided that this notice is retained in full, this

 * software may be distributed under the terms of the GNU General

 * Public License ("GPL") version 2, in which case the provisions of the

 * GPL apply INSTEAD OF those given above.

 *

 * The provided data structures and external interfaces from this code

 * are not restricted to be used by modules with a GPL compatible license.

 *

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS

 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT

 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR

 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT

 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,

 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT

 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,

 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY

 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT

 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE

 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH

 * DAMAGE.

 *

 *

 * Attention: iPhone device must be paired, otherwise it won't respond to our

 * driver. For more info: http://giagio.com/wiki/moin.cgi/iPhoneEthernetDriver

 *

 padding at front of URB */

 on URB error, trigger immediate poll

 request */

 request type */

 value */

 index */

 request */

 request type */

 value */

 index */

 Paranoid */

 Set up endpoints */

 carrier down and transmit queues stopped until packet from device

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Net1080 based USB host-to-host cables

 * Copyright (C) 2000-2005 by David Brownell

 #define	DEBUG			
 #define	VERBOSE			
/*

 * Netchip 1080 driver ... http://www.netchip.com

 * (Sept 2004:  End-of-life announcement has been sent.)

 * Used in (some) LapLink cables

/*

 * NetChip framing of ethernet packets, supporting additional error

 * checks for links that may drop bulk packets from inside messages.

 * Odd USB length == always short read for last usb packet.

 *	- nc_header

 *	- Ethernet header (14 bytes)

 *	- payload

 *	- (optional padding byte, if needed so length becomes odd)

 *	- nc_trailer

 *

 * This framing is to be avoided for non-NetChip devices.

 packed:

 sizeof nc_header (LE, all)

 payload size (including ethhdr)

 detects dropped packets

 all else is optional, and must start with:

 __le16	vendorId;	
 __le16	productId;

 packets may use FLAG_FRAMING_NC and optional pad

 packets _could_ be up to 64KB... */

/*

 * Zero means no timeout; else, how long a 64 byte bulk packet may be queued

 * before the hardware drops it.  If that's done, the driver will need to

 * frame network packets to guard against the dropped USB packets.  The win32

 * driver sets this for both sides of the link.

 ms

/*

 * We ignore most registers and EEPROM contents.

/*

 * Vendor specific requests to read/write data

 reading some registers is trouble

-------------------------------------------------------------------------*/

/*

 * Control register

 bits 15-13 reserved, r/o

 bits 7-4 reserved, r/o

-------------------------------------------------------------------------*/

/*

 * Status register

 XXX the packet counts don't seem right

 (1 at reset, not 0); maybe UNSPEC too

-------------------------------------------------------------------------*/

/*

 * TTL register

-------------------------------------------------------------------------*/

 nc_dump_registers(dev);

 This check is no longer done by usbnet */

 out of band data for us?

 switch (vendor/product ids) { ... }

 There's enough head and tail room */

 There's enough total room, so just readjust */

 Create a new skb to use with the correct size */

 header first */

 maybe pad; then trailer */

 NetChip ref design

 Laplink Gold

 END

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * MOSCHIP MCS7830 based (7730/7830/7832) USB 2.0 Ethernet Devices

 *

 * based on usbnet.c, asix.c and the vendor provided mcs7830 driver

 *

 * Copyright (C) 2010 Andreas Mohr <andi@lisas.de>

 * Copyright (C) 2006 Arnd Bergmann <arnd@arndb.de>

 * Copyright (C) 2003-2005 David Hollis <dhollis@davehollis.com>

 * Copyright (C) 2005 Phil Chang <pchang23@sbcglobal.net>

 * Copyright (c) 2002-2003 TiVo Inc.

 *

 * Definitions gathered from MOSCHIP, Data Sheet_7830DA.pdf (thanks!).

 *

 * 2010-12-19: add 7832 USB PID ("functionality same as MCS7830"),

 *             per active notification by manufacturer

 *

 * TODO:

 * - support HIF_REG_CONFIG_SLEEPMODE/HIF_REG_CONFIG_TXENABLE (via autopm?)

 * - implement ethtool_ops get_pauseparam/set_pauseparam

 *   via HIF_REG_PAUSE_THRESHOLD (>= revision C only!)

 * - implement get_eeprom/[set_eeprom]

 * - switch PHY on/off on ifup/ifdown (perhaps in usbnet.c, via MII)

 * - mcs7830_get_regs() handling is weird: for rev 2 we return 32 regs,

 *   can access only ~ 24, remaining user buffer is uninitialized garbage

 * - anything else?

 requests */

 HIF_REG_XX corresponding index value */

 hmm, spec sez: "R/W", "Except bit 3" (likely TXENABLE). */

 0..ff; reset: 0 */

 Trailing status byte in Ethernet Rx frame */

 < 64 bytes */

 framelen != Ethernet length field */

 non-even number of nibbles */

 > 1518 bytes */

 frame is correct */

 [7:6] reserved */

 it worked --> adopt it on netdev side */

 write the MII command */

 wait for the data to become valid, should be within < 1ms */

 read actual register contents */

 write the new register contents */

 write the MII command */

 wait for the command to be accepted by the PHY */

/*

 * This algorithm comes from the original mcs7830 version 1.4 driver,

 * not sure if it is needed.

 Enable all media types */

 First reset BMCR */

 Enable Auto Neg */

 Restart Auto Neg (Keep the Enable Auto Neg Bit Set) */

/*

 * if we can read register 22, the chip revision is C or higher

 Rev C or later */

 earlier revision */

/*

 * On rev. C we need to set the pause threshold

	/* implementation specific to data->config

 this should not be needed, but it doesn't work otherwise */

 just broadcast and directed */

		/* We use the 20 byte dev->data

		 * for our 8 byte filter buffer

		 * to avoid allocating memory that

 Build the multicast hash filter. */

 re-configure known MAC (suspend case etc.) */

 Set up PHY */

 credits go to asix_set_multicast */

 common usbnet calls */

 Initial startup: Gather MAC address setting from EEPROM */

 reserve space for the status byte on rx */

 The chip always appends a status byte that we need to strip */

 This check is no longer done by usbnet */

		/* hmm, perhaps usbnet.c already sees a globally visible

	/* YES, this function is successful enough that ethtool -d

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * USB Network driver infrastructure

 * Copyright (C) 2000-2005 by David Brownell

 * Copyright (C) 2003-2005 David Hollis <dhollis@davehollis.com>

/*

 * This is a generic "USB networking" framework that works with several

 * kinds of full and high speed networking devices:  host-to-host cables,

 * smart usb peripherals, and actual Ethernet adapters.

 *

 * These devices usually differ in terms of control protocols (if they

 * even have one!) and sometimes they define new framing to wrap or batch

 * Ethernet packets.  Otherwise, they talk to USB pretty much the same,

 * so interface (un)binding, endpoint I/O queues, fault handling, and other

 * issues can usefully be addressed by this framework.

 #define	DEBUG			
 #define	VERBOSE			
-------------------------------------------------------------------------*/

/*

 * Nineteen USB 1.1 max size bulk transactions per frame (ms), max.

 * Several dozen bytes of IPv4 data can fit in two such transactions.

 * One maximum size Ethernet packet takes twenty four of them.

 * For high speed, each frame comfortably fits almost 36 max size

 * Ethernet packets (so queues should be bigger).

 *

 * The goal is to let the USB host controller be busy for 5msec or

 * more before an irq is required, under load.  Jumbograms change

 * the equation.

 reawaken network queue this soon after stopping; else watchdog barks

/* throttle rx/tx briefly after some faults, so hub_wq might disconnect()

 * us (it polls at HZ/4 usually) before we report too many false errors.

 between wakeups

-------------------------------------------------------------------------*/

 randomly generated ethernet address

 use ethtool to change the level for any given device */

-------------------------------------------------------------------------*/

 handles CDC Ethernet and many other network "bulk data" interfaces */

		/* take the first altsetting with in-bulk + out-bulk;

		 * remember any status endpoint, just in case;

		 * ignore other endpoints and altsettings.

 ignore endpoints which cannot transfer data */

 success */

 software-driven interface shutdown */

 urb killed */

 hardware gone */

	/* NOTE:  not throttling like RX/TX, since this endpoint

	 * already polls infrequently

 avoid 1 msec chatter:  min 8 msec poll rate */

 Submit the interrupt URB if not previously submitted, increasing refcount */

 For resume; submit interrupt URB if previously submitted */

 Kill the interrupt URB if all submitters want it killed */

 For suspend; always kill interrupt URB */

/* Passes this packet up the stack, updating its accounting.

 * Some link protocols batch packets, so their rx_fixup paths

 * can return clones as well as just modify the original skb.

 only update if unset to allow minidriver rx_fixup override */

 must be called if hard_mtu or rx_urb_size changed */

		/*

		 * Not take default 5ms qlen for super speed HC to

		 * save memory, and iperf tests show 2.5ms qlen can

		 * work well

/*-------------------------------------------------------------------------

 *

 * Network Device Driver (peer link to "Host Device", from USB host)

 *

 no second zero-length packet read wanted after mtu-sized packets

 max qlen depend on hard_mtu and rx_urb_size */

 The caller must hold list->lock */

-------------------------------------------------------------------------*/

/* some LK 2.4 HCDs oopsed if we freed or resubmitted urbs from

 * completion callbacks.  2.5 should have fixed those bugs...

	/* defer_bh() is never called with list == &dev->done.

	 * spin_lock_nested() tells lockdep that it is OK to take

	 * dev->done.lock here with list->lock held.

/* some work can't be done in tasklets, so we use keventd

 *

 * NOTE:  annoying asymmetry:  if it's active, schedule_work() fails,

 * but tasklet_schedule() doesn't.  hope the failure is rare.

-------------------------------------------------------------------------*/

 prevent rx skb allocation when error ratio is high */

-------------------------------------------------------------------------*/

 With RX_ASSEMBLE, rx_fixup() must update counters */

 else network stack removes extra byte if we forced a short packet

 all data was already cloned from skb inside the driver */

-------------------------------------------------------------------------*/

 success */

	/* stalls need manual reset. this is rare ... except that

	 * when going through USB 2.0 TTs, unplug appears this way.

	 * we avoid the highspeed version of the ETIMEDOUT/EILSEQ

	 * storm, recovering as needed.

 software-driven interface shutdown */

 async unlink */

 hardware gone */

	/* we get controller i/o faults during hub_wq disconnect() delays.

	 * throttle down resubmits, to avoid log floods; just temporarily,

	 * so we still recover when the fault isn't a hub_wq delay.

 data overrun ... flush fifo? */

 stop rx if packet error rate is high */

-------------------------------------------------------------------------*/

-------------------------------------------------------------------------*/

 unlink pending rx/tx; completion handlers do all other cleanup

		/*

		 * Get reference count of the URB to avoid it to be

		 * freed during usb_unlink_urb, which may trigger

		 * use-after-free problem inside usb_unlink_urb since

		 * usb_unlink_urb is always racing with .complete

		 * handler(include defer_bh).

 during some PM-driven resume scenarios,

 these (async) unlinks complete immediately

 Flush all pending rx urbs

 minidrivers may need to do this when the MTU changes

-------------------------------------------------------------------------*/

 precondition: never called in_interrupt

 ensure there are no more active urbs */

 maybe wait for deletions to finish. */

 to not race resume */

	/* allow minidriver to stop correctly (wireless devices to turn off

	/* deferred work (task, timer, softirq) must also stop.

	 * can't flush_scheduled_work() until we drop rtnl (later),

	 * else workers could deadlock; so make workers a NOP.

-------------------------------------------------------------------------*/

 posts reads, and enables write queuing

 precondition: never called in_interrupt

 put into "known safe" state

 hard_mtu or rx_urb_size may change in reset() */

 insist peer be connected

 start any status interrupt transfer */

 reset rx error state */

 delay posting reads until we're fully open

-------------------------------------------------------------------------*/

/* ethtool methods; minidrivers may need to add some more, but

 * they'll probably want to use this base set.

/* These methods are written on the assumption that the device

 * uses MII

	/* the assumption that speed is equal on tx and rx

	 * is deeply engrained into the networking layer.

	 * For wireless stuff it is not true.

	 * We assume that rx_speed matters more.

 link speed/duplex might have changed */

 hard_mtu or rx_urb_size may change in link_reset() */

 If a check_connect is defined, return its result */

 if the device has mii operations, use those */

 Otherwise, dtrt for drivers calling netif_carrier_{on,off} */

 drivers may override default ethtool_ops in their bind() routine */

-------------------------------------------------------------------------*/

 kill URBs for reading packets to save bus bandwidth */

		/*

		 * tx_timeout will unlink URBs for sending packets and

		 * tx queue is stopped by netcore after link becomes off

 submitting URBs for reading packets */

 hard_mtu or rx_urb_size may change during link change */

/* work that cannot be done in interrupt context uses keventd.

 *

 * NOTE:  with 2.5 we could do more of this using completion callbacks,

 * especially now that control transfers can be queued.

 usb_clear_halt() needs a thread context */

 tasklet could resubmit itself forever if memory is tight */

 handle link change from link resetting */

-------------------------------------------------------------------------*/

 software-driven interface shutdown */

 async unlink

 hardware gone

		/* like rx, tx gets controller i/o faults during hub_wq

		 * delays and so it uses the same throttling mechanism.

-------------------------------------------------------------------------*/

	/* this needs to be handled individually because the generic layer

	 * doesn't know what is sufficient and could not restore private

	 * information if a remedy of an unconditional reset were used.

-------------------------------------------------------------------------*/

 reserve one for zero packet */

 some devices want funky USB-level framing, for

 win32 driver (usually) and/or hardware quirks

 packet collected; minidriver waiting for more */

	/* don't assume the hardware handles USB_ZERO_PACKET

	 * NOTE:  strictly conforming cdc-ether devices should expect

	 * the ZLP here, but ignore the one-byte packet.

	 * NOTE2: CDC NCM specification is different from CDC ECM when

	 * handling ZLP/short packets, so cdc_ncm driver will make short

	 * packet itself if needed.

		/* Driver has set number of packets and a length delta.

		 * Calculate the complete length and ensure that it's

		 * positive.

 if this triggers the device is still a sleep */

 transmission will be done in resume */

 no use to process more packets */

 don't refill the queue all at once */

-------------------------------------------------------------------------*/

 tasklet (work deferred from completions, in_irq) or timer

 restart RX again after disabling due to high error rate */

	/* waiting for all pending urbs to complete?

	 * only then can we forgo submitting anew

 or are we maybe short a few urbs?

/*-------------------------------------------------------------------------

 *

 * USB Device Driver support

 *

 precondition: never called in_interrupt

-------------------------------------------------------------------------*/

 precondition: never called in_interrupt

	/* usbnet already took usb runtime pm, so have to enable the feature

	 * for usb interface, otherwise usb_autopm_get_interface may return

	 * failure if RUNTIME_PM is enabled.

 set up our own records

 netdev_printk() needs this so do it as early as possible */

	/* rx and tx sides can use different message sizes;

	 * bind() should set rx_urb_size in that case.

 allow device-specific bind/init procedures

 NOTE net->name still not usable ...

 heuristic:  "usb%d" for links we know are two-host,

 else "eth%d" when there's reasonable doubt.  userspace

 can rename the link if it knows better.

 WLAN devices should always be named "wlan%d" */

 WWAN devices should always be named "wwan%d" */

 devices that cannot do ARP */

 maybe the remote can't receive an Ethernet MTU */

 that is a broken device */

 let userspace know we have a random address */

 initialize max rx_qlen and tx_qlen */

 ok, it's ready to go.

	/* subdrivers must undo all they did in bind() if they

	 * fail it, but we may fail later and a deferred kevent

	 * may trigger an error resubmitting itself and, worse,

	 * schedule a timer. So we kill it all just in case.

-------------------------------------------------------------------------*/

/*

 * suspend the whole driver as soon as the first interface is suspended

 * resume only when the last interface is resumed

 don't autosuspend while transmitting */

		/*

		 * accelerate emptying of the rx and queues, to avoid

		 * having everything error out.

		/*

		 * reattach so runtime management can use and

		 * wake the device

 resume interrupt URB if it was previously submitted */

			/* handle remote wakeup ASAP

			 * we cannot race against stop

/*

 * Either a subdriver implements manage_power, then it is assumed to always

 * be ready to be suspended or it reports the readiness to be suspended

 * explicitly

/*

 * For devices that can do without special commands

 update link after link is reseted */

-------------------------------------------------------------------------*/

/*

 * The function can't be called inside suspend/resume callback,

 * otherwise deadlock will be caused.

/*

 * The function can't be called inside suspend/resume callback,

 * otherwise deadlock will be caused.

/*

 * The function can be called inside suspend/resume callback safely

 * and should only be called by suspend/resume callback generally.

/*

 * The function can be called inside suspend/resume callback safely

 * and should only be called by suspend/resume callback generally.

/*

 * The caller must make sure that device can't be put into suspend

 * state until the control URB completes.

-------------------------------------------------------------------------*/

 Compiler should optimize this out. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Simple "CDC Subset" USB Networking Links

 * Copyright (C) 2000-2005 by David Brownell

/*

 * This supports simple USB network links that don't require any special

 * framing or hardware control operations.  The protocol used here is a

 * strict subset of CDC Ethernet, with three basic differences reflecting

 * the goal that almost any hardware should run it:

 *

 *  - Minimal runtime control:  one interface, no altsettings, and

 *    no vendor or class specific control requests.  If a device is

 *    configured, it is allowed to exchange packets with the host.

 *    Fancier models would mean not working on some hardware.

 *

 *  - Minimal manufacturing control:  no IEEE "Organizationally

 *    Unique ID" required, or an EEPROMs to store one.  Each host uses

 *    one random "locally assigned" Ethernet address instead, which can

 *    of course be overridden using standard tools like "ifconfig".

 *    (With 2^46 such addresses, same-net collisions are quite rare.)

 *

 *  - There is no additional framing data for USB.  Packets are written

 *    exactly as in CDC Ethernet, starting with an Ethernet header and

 *    terminated by a short packet.  However, the host will never send a

 *    zero length packet; some systems can't handle those robustly.

 *

 * Anything that can transmit and receive USB bulk packets can implement

 * this protocol.  That includes both smart peripherals and quite a lot

 * of "host-to-host" USB cables (which embed two devices back-to-back).

 *

 * Note that although Linux may use many of those host-to-host links

 * with this "cdc_subset" framing, that doesn't mean there may not be a

 * better approach.  Handling the "other end unplugs/replugs" scenario

 * well tends to require chip-specific vendor requests.  Also, Windows

 * peers at the other end of host-to-host cables may expect their own

 * framing to be used rather than this "cdc_subset" model.

 PDA style devices are always connected if present */

/*-------------------------------------------------------------------------

 *

 * ALi M5632 driver ... does high speed

 *

 * NOTE that the MS-Windows drivers for this chip use some funky and

 * (naturally) undocumented 7-byte prefix to each packet, so this is a

 * case where we don't currently interoperate.  Also, once you unplug

 * one end of the cable, you need to replug the other end too ... since

 * chip docs are unavailable, there's no way to reset the relevant state

 * short of a power cycle.

 *

/*-------------------------------------------------------------------------

 *

 * AnchorChips 2720 driver ... http://www.cypress.com

 *

 * This doesn't seem to have a way to detect whether the peer is

 * connected, or need any reset handshaking.  It's got pretty big

 * internal buffers (handles most of a frame's worth of data).

 * Chip data sheets don't describe any vendor control messages.

 *

 no reset available!

 no check_connect available!

 direction distinguishes these

 CONFIG_USB_AN2720 */

/*-------------------------------------------------------------------------

 *

 * Belkin F5U104 ... two NetChip 2280 devices + Atmel AVR microcontroller

 *

 * ... also two eTEK designs, including one sold as "Advance USBNET"

 *

 CONFIG_USB_BELKIN */

/*-------------------------------------------------------------------------

 *

 * EPSON USB clients

 *

 * This is the same idea as Linux PDAs (below) except the firmware in the

 * device might not be Tux-powered.  Epson provides reference firmware that

 * implements this interface.  Product developers can reuse or modify that

 * code, such as by using their own product and vendor codes.

 *

 * Support was from Juro Bystricky <bystricky.juro@erd.epson.com>

 *

 CONFIG_USB_EPSON2888 */

/*-------------------------------------------------------------------------

 *

 * info from Jonathan McDowell <noodles@earth.li>

 *

 CONFIG_USB_KC2190 */

/*-------------------------------------------------------------------------

 *

 * Intel's SA-1100 chip integrates basic USB support, and is used

 * in PDAs like some iPaqs, the Yopy, some Zaurus models, and more.

 * When they run Linux, arch/arm/mach-sa1100/usb-eth.c may be used to

 * network using minimal USB framing data.

 *

 * This describes the driver currently in standard ARM Linux kernels.

 * The Zaurus uses a different driver (see later).

 *

 * PXA25x and PXA210 use XScale cores (ARM v5TE) with better USB support

 * and different USB endpoint numbering than the SA1100 devices.  The

 * mach-pxa/usb-eth.c driver re-uses the device ids from mach-sa1100

 * so we rely on the endpoint descriptors.

 *

 CONFIG_USB_ARMLINUX */

-------------------------------------------------------------------------*/

/*

 * chip vendor names won't normally be on the cables, and

 * may not be on the device.

 ALi defaults

 SiteCom CN-124

 AnchorChips defaults

 Xircom PGUNET

 Belkin

 eTEK

 Advance USBNET (eTEK)

 EPSON USB client

 KC-190

/*

 * SA-1100 using standard ARM Linux kernels, or compatible.

 * Often used when talking to Linux PDAs (iPaq, Yopy, etc).

 * The sa-1100 "usb-eth" driver handles the basic framing.

 *

 * PXA25x or PXA210 ...  these use a "usb-eth" driver much like

 * the sa1100 one, but hardware uses different endpoint numbers.

 *

 * Or the Linux "Ethernet" gadget on hardware that can't talk

 * CDC Ethernet (e.g., no altsettings), in either of two modes:

 *  - acting just like the old "usb-eth" firmware, though

 *    the implementation is different

 *  - supporting RNDIS as the first/default configuration for

 *    MS-Windows interop; Linux needs to use the other config

 1183 = 0x049F, both used as hex values?

 Compaq "Itsy" vendor/product id

 usb-eth, or compatible

 G.Mate "Yopy"

 "blob" bootloader

 "blob" bootloader

 Linux Ethernet/RNDIS gadget, mostly on PXA, second config

 e.g. Gumstix, current OpenZaurus, ... or anything else

 that just enables this gadget option.

 END

-------------------------------------------------------------------------*/

/* CoreChip-sz SR9800 one chip USB 2.0 Ethernet Devices

 *

 * Author : Liu Junliang <liujunliang_ljl@163.com>

 *

 * Based on asix_common.c, asix_devices.c

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2.  This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.*

 This check is no longer done by usbnet */

 get the packet length */

 TODO: callers not checking for error ret */

 SR9800 have a 16-bit RX_CTL value */

 just broadcast and directed */

		/* We use the 20 byte dev->data

		 * for our 8 byte filter buffer

		 * to avoid allocating memory that

		 * is tricky to free later

 Build the multicast hash filter. */

 Get the PHY Identifier from the PHYSID1 & PHYSID2 MII registers */

 Poll for the rare case the FW or phy isn't ready yet.  */

	/* Crude hack to ensure that we don't overwrite memory

	 * if an odd length is supplied

 sr9800 returns 2 bytes from eeprom on read */

 Inherit standard device info */

	/* We use the 20 byte dev->data

	 * for our 6 byte mac buffer

	 * to avoid allocating memory that

	 * is tricky to free later

 Set RX_CTL to default values with 2k buffer, and enable cactus */

 Rewrite MAC address */

 set the embedded Ethernet PHY in power-down state */

 set the embedded Ethernet PHY in power-up state */

 set the embedded Ethernet PHY in reset state */

 set the embedded Ethernet PHY in power-up state */

	/* LED Setting Rule :

	 * AABB:CCDD

	 * AA : MFA0(LED0)

	 * BB : MFA1(LED1)

	 * CC : MFA2(LED2), Reserved for SR9800

	 * DD : MFA3(LED3), Reserved for SR9800

 Get the MAC address */

 Initialize MII structure */

 Reset the PHY to normal operation mode */

 Init PHY routine */

 Read PHYID register *AFTER* the PHY was reset properly */

 medium mode setting */

 SR9800 Device  */

 END */

www.corechip-sz.com");

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * PL-2301/2302 USB host-to-host link cables

 * Copyright (C) 2000-2005 by David Brownell

 #define	DEBUG			
 #define	VERBOSE			
/*

 * Prolific PL-2301/PL-2302 driver ... http://www.prolific.com.tw/ 

 *

 * The protocol and handshaking used here should be bug-compatible

 * with the Linux 2.2 "plusb" driver, by Deti Fliegl.

 *

 * HEADS UP:  this handshaking isn't all that robust.  This driver

 * gets confused easily if you unplug one end of the cable then

 * try to connect it again; you'll need to restart both ends. The

 * "naplink" software (used by some PlayStation/2 developers) does

 * the handshaking much better!   Also, sometimes this hardware

 * seems to get wedged under load.  Prolific docs are weak, and

 * don't identify differences between PL2301 and PL2302, much less

 * anything to explain the different PL2302 versions observed.

 *

 * NOTE:  pl2501 has several modes, including pl2301 and pl2302

 * compatibility.   Some docs suggest the difference between 2301

 * and 2302 is only to make MS-Windows use a different driver...

 *

 * pl25a1 glue based on patch from Tony Gibbs.  Prolific "docs" on

 * this chip are as usual incomplete about what control messages

 * are supported.

/*

 * Bits 0-4 can be used for software handshaking; they're set from

 * one end, cleared from the other, "read" with the interrupt byte.

 (feature only) suspend enable */

 reserved bit -- rx ready (6) ? */

 (interrupt only) transmit ready */

 reset output pipe */

 reset input pipe */

 transmission complete */

 transmission received */

 peer exists */

	/* some units seem to need this reset, others reject it utterly.

	 * FIXME be more like "naplink" or windows drivers.

 some PL-2302 versions seem to fail usb_set_interface() */

-------------------------------------------------------------------------*/

/*

 * Proilific's name won't normally be on the cables, and

 * may not be on the device.

 full speed cables */

 PL-2301

 PL-2302

 high speed cables */

 PL-25A1, no eeprom */

 Belkin F5U258/F5U279 (PL-25A1) */

	USB_DEVICE(0x3923, 0x7825),     /* National Instruments USB

					 * Host-to-Host Cable

 super speed cables */

	USB_DEVICE(0x067b, 0x27a1),     /* PL-27A1, no eeprom

					 * also: goobay Active USB 3.0

					 * Data Link,

					 * Unitek Y-3501

 END

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for USB ethernet port of Conexant CX82310-based ADSL routers

 * Copyright (C) 2010 by Ondrej Zary

 * some parts inspired by the cxacru driver

 no effect? */

 no effect? */

 returns nothing? */

 read MAC address */

 not useful, link is always up */

 unknown, needed during init */

/*

 * execute control command

 *  - optionally send some data (command parameters)

 *  - optionally wait for the reply

 *  - optionally read some data from the reply

 create command packet */

 send command packet */

 wait for reply, retry if it's empty */

 length of partial packet data */

 remaining (missing) data length */

 partial packet data */

 avoid ADSL modems - continue only if iProduct is "USB NET CARD" */

	/*

	 * this must not include ethernet header as the device can send partial

	 * packets with no header (and sometimes even empty URBs)

 we can send at most 1514 bytes of data (+ 2-byte header) per URB */

 we can receive URBs up to 4KB from the device */

 wait for firmware to become ready (indicated by the link being up) */

 the command can time out during boot - it's not an error */

 enable ethernet mode (?) */

 get the MAC address */

 start (does not seem to have any effect?) */

/*

 * RX is NOT easy - we can receive multiple packets per skb, each having 2-byte

 * packet length at the beginning.

 * The last packet might be incomplete (when it crosses the 4KB URB size),

 * continuing in the next skb (without any headers).

 * If a packet has odd length, there is one extra byte at the end (before next

 * packet or at the end of the URB).

	/*

	 * If the last skb ended with an incomplete packet, this skb contains

	 * end of that packet at the beginning.

 a skb can contain multiple packets */

 first two bytes are packet length */

 if last packet in the skb, let usbnet to process it */

 incomplete packet, save it for the next skb */

 process the packet */

 let usbnet process the last packet */

 TX is easy, just add 2 bytes of length at the beginning */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Copyright (c) 2002 Petko Manolov (petkan@users.sourceforge.net)

 Version Information */

 This one has the link status */

 Transmit status register errors */

 Receive status register errors */

 Media status register definitions */

 Interrupt pipe data */

 rtl8150 flags */

 Define these values to match your device */

 table of devices that work with this driver */

/*

**

**	device related part of the code

**

 Set the IDR registers. */

 Get the CR contents. */

 Set the WEPROM bit (eeprom write enable). */

	/* Write the MAC address into eeprom. Eeprom writes must be word-sized,

 Clear the WEPROM bit (preventing accidental eeprom writes). */

 the urb is in unlink state */

 protect against short packets (tell me why we got some?!?) */

 success */

 unlink */

 -EPIPE:  should clear the halt */

 Report link status changes to the network stack */

/*

**

**	network related part of the code

**

 RCR bit7=1 attach Rx info at the end;  =0 HW CRC (which is broken) */

 ~RX_MULTICAST, ~RX_PROMISCUOUS */

 Can we get/handle EPIPE here? */

 100ms */

/*

 * Davicom DM96xx USB 10/100Mbps ethernet devices

 *

 * Peter Korsgaard <jacmet@sunsite.dk>

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2.  This program is licensed "as is" without any warranty of any

 * kind, whether express or implied.

#define DEBUG

/* datasheet:

 http://ptm2.cc.utu.fi/ftp/network/cards/DM9601/From_NET/DM9601-DS-P01-930914.pdf

 control requests */

 registers */

 low + high */

 6 bytes */

 8 bytes */

 only on dm9620 */

 chip id values */

 2 byte header */

 3 byte header + 4 byte crc tail */

 ready */

 ready */

 access is 16bit */

 Inherit standard device info */

	/* We use the 20 byte dev->data for our 8 byte filter buffer

 broadcast address */

	/* dm9620/21a require room for 4 byte padding, even in dm9601

	 * mode, so we need +1 to be able to receive full size

	 * ethernet frames.

 reset */

 read MAC */

	/*

	 * Overwrite the auto-generated address only with good ones.

 put dm9620 devices in dm9601 mode */

 power up phy */

 receive broadcast packets */

	/* format:

	   b1: rx status

	   b2: packet length (incl crc) low

	   b3: packet length (incl crc) high

	   b4..n-4: packet data

	   bn-3..bn: ethernet crc

	/* format:

	   b1: packet length low

	   b2: packet length high

	   b3..n: packet data

	/* workaround for dm962x errata with tx fifo getting out of

	 * sync if a USB bulk transfer retry happens right after a

	 * packet with odd / maxpacket length by adding up to 3 bytes

	 * padding.

 hw header doesn't count as part of length */

	/* format:

	   b0: net status

	   b1: tx status 1

	   b2: tx status 2

	   b3: rx status

	   b4: rx overflow

	   b5: rx count

	   b6: tx count

	   b7: gpr

 Corega FEther USB-TXC */

 Davicom USB-100 */

 ZT6688 USB NIC */

 ShanTou ST268 USB NIC */

 ADMtek ADM8515 USB NIC */

 Hirose USB-100 */

 DM9601 USB to Fast Ethernet Adapter */

 DM9601 USB to Fast Ethernet Adapter */

 DM9000E */

 DM9620 USB to Fast Ethernet Adapter */

 DM9621A USB to Fast Ethernet Adapter */

 DM9622 USB to Fast Ethernet Adapter */

 DM962OA USB to Fast Ethernet Adapter */

 DM9621A USB to Fast Ethernet Adapter */

 ZyXEL Keenetic Plus DSL xDSL modem */

 END

 SPDX-License-Identifier: GPL-2.0-or-later

 Realtek RTL8153 Based USB 3.0 Ethernet Adapters */

 Lenovo Powered USB-C Travel Hub (4X90S92381, based on Realtek RTL8153) */

 END */

/*

 * USB 10M/100M ethernet adapter

 *

 * This file is licensed under the terms of the GNU General Public License

 * version 2. This program is licensed "as is" without any warranty of any

 * kind, whether express or implied

 *

/* Address space:

 * 00-63 : MII

 * 64-128: MAC

 *

 * Note: all accesses must be 16-bit

/* Control register bits

 *

 * Note: bits 13 and 15 are reserved

/* Status register bits

 *

 * Note: bits 7-15 are reserved

/* FIFO depth register bits

 *

 * Note: bits 6 and 14 are reserved

	/* usbnet adds padding if length is a multiple of packet size

	 * if so, adjust length value in header

 Undocumented register */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Host Side support for RNDIS Networking Links

 * Copyright (C) 2005 by David Brownell

/*

 * RNDIS is NDIS remoted over USB.  It's a MSFT variant of CDC ACM ... of

 * course ACM was intended for modems, not Ethernet links!  USB's standard

 * for Ethernet links is "CDC Ethernet", which is significantly simpler.

 *

 * NOTE that Microsoft's "RNDIS 1.0" specification is incomplete.  Issues

 * include:

 *    - Power management in particular relies on information that's scattered

 *	through other documentation, and which is incomplete or incorrect even

 *	there.

 *    - There are various undocumented protocol requirements, such as the

 *	need to send unused garbage in control-OUT messages.

 *    - In some cases, MS-Windows will emit undocumented requests; this

 *	matters more to peripheral implementations than host ones.

 *

 * Moreover there's a no-open-specs variant of RNDIS called "ActiveSync".

 *

 * For these reasons and others, ** USE OF RNDIS IS STRONGLY DISCOURAGED ** in

 * favor of such non-proprietary alternatives as CDC Ethernet or the newer (and

 * currently rare) "Ethernet Emulation Model" (EEM).

/*

 * RNDIS notifications from device: command completion; "reverse"

 * keepalives; etc

 FIXME for keepalives, respond immediately (asynchronously)

 if not an RNDIS status, do like cdc_status(dev,urb) does

/*

 * RNDIS indicate messages.

/*

 * RPC done RNDIS-style.  Caller guarantees:

 * - message is properly byteswapped

 * - there's no other request pending

 * - buf can hold up to 1KB response (required by RNDIS spec)

 * On return, the first few entries are already byteswapped.

 *

 * Call context is likely probe(), before interface name is known,

 * which is why we won't try to use it in the diagnostics.

	/* REVISIT when this gets called from contexts other than probe() or

	 * disconnect(): either serialize, or dispatch responses on xid

 Issue the request; xid is unique, don't bother byteswapping it */

	/* Some devices don't respond on the control channel until

 Poll the control channel; the request probably completed immediately */

 then likely retry */

 fault/event */

 ping */

 device probably issued a protocol stall; ignore */

/*

 * rndis_query:

 *

 * Performs a query for @oid along with 0 or more bytes of payload as

 * specified by @in_len. If @reply_len is not set to -1 then the reply

 * length is checked against this value, resulting in an error if it

 * doesn't match.

 *

 * NOTE: Adding a payload exactly or greater than the size of the expected

 * response payload is an evident requirement MSFT added for ActiveSync.

 *

 * The only exception is for OIDs that return a variably sized response,

 * in which case no payload should be added.  This undocumented (and

 * nonsensical!) issue was found by sniffing protocol requests from the

 * ActiveSync 4.1 Windows driver.

 same as usbnet_netdev_ops but MTU change not allowed */

 we can't rely on i/o from stack working, or stack allocation */

	/* max transfer (in spec) is 0x4000 at full speed, but for

	 * TX we'll stick to one Ethernet packet plus RNDIS framing.

	 * For RX we handle drivers that zero-pad to end-of-packet.

	 * Don't let userspace change these settings.

	 *

	 * NOTE: there still seems to be weirdness here, as if we need

	 * to do some more things to make sure WinCE targets accept this.

	 * They default to jumbograms of 8KB or 16KB, which is absurd

	 * for such low data rates and which is also more than Linux

	 * can usually expect to allocate for SKB data...

 it might not even be an RNDIS device!! */

 REVISIT:  peripheral "alignment" request is ignored ... */

	/* module has some device initialization code needs to be done right

 Check physical medium */

 OID is optional so don't fail here. */

 Get designated host ethernet address */

 set a nonzero filter to enable data transfers */

 try to clear any rndis state/activity (no i/o from stack!) */

/*

 * DATA -- host must not write zlps

 This check is no longer done by usbnet */

 peripheral may have batched packets to us... */

 don't choke if we see oob, per-packet data, etc */

 at most one packet left? */

 try to return all the packets in the batch */

 caller will usbnet_skb_return the remaining packet */

 enough head room as-is? */

 enough room, but needs to be readjusted? */

 create a new skb, with the correct size (and tailpad) */

	/* fill out the RNDIS header.  we won't bother trying to batch

	 * packets; Linux minimizes wasted bandwidth through tx queues.

 FIXME make the last packet always be short ... */

-------------------------------------------------------------------------*/

 2Wire HomePortal 1000SW */

 ACM */, 0x0ff),

 RNDIS is MSFT's un-official variant of CDC ACM */

 ACM */, 0x0ff),

 "ActiveSync" is an undocumented variant of RNDIS, used in WM5 */

 RNDIS for tethering */

 Novatel Verizon USB730L */

 END

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012  Bjørn Mork <bjorn@mork.no>

 *

 * The probing code is heavily inspired by cdc_ether, which is:

 * Copyright (C) 2003-2005 by David Brownell

 * Copyright (C) 2006 by Ole Andre Vadla Ravnas (ActiveSync)

/* This driver supports wwan (3G/LTE/?) devices using a vendor

 * specific management protocol called Qualcomm MSM Interface (QMI) -

 * in addition to the more common AT commands over serial interface

 * management

 *

 * QMI is wrapped in CDC, using CDC encapsulated commands on the

 * control ("master") interface of a two-interface CDC Union

 * resembling standard CDC ECM.  The devices do not use the control

 * interface for any other CDC messages.  Most likely because the

 * management protocol is used in place of the standard CDC

 * notifications NOTIFY_NETWORK_CONNECTION and NOTIFY_SPEED_CHANGE

 *

 * Alternatively, control and data functions can be combined in a

 * single USB interface.

 *

 * Handling a protocol like QMI is out of the scope for any driver.

 * It is exported as a character device using the cdc-wdm driver as

 * a subdriver, enabling userspace applications ("modem managers") to

 * handle it.

 *

 * These devices may alternatively/additionally be configured using AT

 * commands on a serial interface

 driver specific data */

 needs "set DTR" request */

 No header */

 drop the packet, bogus length */

 control packet, we do not know what to do */

 extract padding length and check for valid length info */

 not ip - do not know what to do */

 Account for reference in struct qmimux_priv_priv */

 Get rid of the reference to real_dev */

 No header */

 don't bother if already set */

 Restoring min/max mtu values set originally by usbnet */

 recalculate buffers after changing hard_header_len */

 no change? */

 ip mode cannot be cleared when pass through mode is set */

 we don't want to modify a running netdev */

 let other drivers deny the change */

 mux_id [1 - 254] for compatibility with ip(8) and the rmnet driver */

 no change? */

 pass through mode can be set for raw ip devices only */

 default ethernet address used by the modem */

/* Make up an ethernet header if the packet doesn't have one.

 *

 * A firmware bug common among several devices cause them to send raw

 * IP packets under some circumstances.  There is no way for the

 * driver/host to know when this will happen.  And even when the bug

 * hits, some packets will still arrive with an intact header.

 *

 * The supported devices are only capably of sending IPv4, IPv6 and

 * ARP packets on a point-to-point link. Any packet with an ethernet

 * header will have either our address or a broadcast/multicast

 * address as destination.  ARP packets will always have a header.

 *

 * This means that this function will reliably add the appropriate

 * header iff necessary, provided our hardware address does not start

 * with 4 or 6.

 *

 * Another common firmware bug results in all packets being addressed

 * to 00:a0:c6:00:00:00 despite the host address being different.

 * This function will also fixup such packets.

 This check is no longer done by usbnet */

 possibly bogus destination - rewrite just in case */

 pass along other packets without modifications */

 normally set by eth_type_trans */

 very simplistic detection of IPv4 or IPv6 headers */

 disallow addresses which may be confused with IP headers */

/* using a counter to merge subdriver requests with our own into a

 * combined state

		/* need autopm_get/put here to ensure the usbcore sees

		 * the new value

 can be called while disconnecting */

 collect all three endpoints and register subdriver */

 collect bulk endpoints */

 update status endpoint if separate control interface */

 require interrupt endpoint for subdriver */

 for subdriver power management */

 register subdriver */

 prevent usbnet from using status endpoint */

 save subdriver struct for suspend/resume wrappers */

/* Send CDC SetControlLineState request, setting or clearing the DTR.

 * "Required for Autoconnect and 9x30 to wake up" according to the

 * GobiNet driver. The requirement has been verified on an MDM9230

 * based Sierra Wireless MC7455

 set up initial state */

 and a number of CDC descriptors */

 Use separate control and data interfaces if we found a CDC Union */

 ignore and continue... */

 errors aren't fatal - we can live with the dynamic address */

 claim data interface and set it up */

	/* disabling remote wakeup on MDM9x30 devices has the same

	 * effect as clearing DTR. The device will not respond to QMI

	 * requests until we set DTR again.  This is similar to a

	 * QMI_CTL SYNC request, clearing a lot of firmware state

	 * including the client ID allocations.

	 *

	 * Our usage model allows a session to span multiple

	 * open/close events, so we must prevent the firmware from

	 * clearing out state the clients might need.

	 *

	 * MDM9x30 is the first QMI chipset with USB3 support. Abuse

	 * this fact to enable the quirk for all USB3 devices.

	 *

	 * There are also chipsets with the same "set DTR" requirement

	 * but without USB3 support.  Devices based on these chips

	 * need a quirk flag in the device ID table.

	/* Never use the same address on both ends of the link, even if the

	 * buggy firmware told us to. Or, if device is assigned the well-known

	 * buggy firmware MAC address, replace it with a random address,

 make MAC addr easily distinguishable from an IP header */

 set local assignment bit */

 clear "IP" bit */

 disable MDM9x30 quirk */

 allow user to unbind using either control or data */

 only if not shared */

/* suspend/resume wrappers calling both usbnet and the cdc-wdm

 * subdriver if present.

 *

 * NOTE: cdc-wdm also supports pre/post_reset, but we cannot provide

 * wrappers for those without adding usbnet reset support first.

	/* Both usbnet_suspend() and subdriver->suspend() MUST return 0

	 * in system sleep context, otherwise, the resume callback has

	 * to recover device from previous suspend failure.

 map QMI/wwan function by a fixed interface number */

 devices requiring "set DTR" quirk */

 Gobi 1000 QMI/wwan interface number is 3 according to qcserial */

 Gobi 2000/3000 QMI/wwan interface number is 0 according to qcserial */

/* Many devices have QMI and DIAG functions which are distinguishable

 * from other vendor specific functions by class, subclass and

 * protocol all being 0xff. The DIAG function has exactly 2 endpoints

 * and is silently rejected when probed.

 *

 * This makes it possible to match dynamically numbered QMI functions

 * as seen on e.g. many Quectel modems.

 1. CDC ECM like devices match on the control interface */

 Huawei E392, E398 and possibly others sharing both device id and more... */

 Vodafone/Huawei K5005 (12d1:14c8) and similar modems */

 HUAWEI_INTERFACE_NDIS_CONTROL_QUALCOMM */

 Motorola Mapphone devices with MDM6600 */

 2. Combined interface devices matching on class+protocol */

 Huawei E367 and possibly others in "Windows mode" */

 Huawei E392, E398 and possibly others in "Windows mode" */

 HUAWEI_NDIS_SINGLE_INTERFACE_VDF */

 HUAWEI_INTERFACE_NDIS_HW_QUALCOMM */

 Pantech UML290, P4200 and more */

 Pantech UML290 - newer firmware */

 Novatel USB551L and MC551 */

 Novatel E362 */

 Novatel Expedite E371 */

 Dell Wireless 5800 (Novatel E362) */

 Dell Wireless 5800 V2 (Novatel E362) */

 Dell Wireless 5804 (Novatel E371) */

 ADU960S */

 HP lt2523 (Novatel E371) */

 HP lt4112 LTE/HSPA+ Gobi 4G Module (Huawei me906e) */

 Quectel EC25, EC20 R2.0  Mini PCIe */

 Quectel EP06/EG06/EM06 */

 Quectel EG12/EM12 */

 Quectel EM160R-GL */

 Quectel RM500Q-GL */

 3. Combined interface devices matching on interface number */

 Yota / Megafon M100-1 */

 4G LTE usb-modem U901 */

 Alcatel-sbell ASB TL131 TDD LTE (China Mobile) */

 ublox R410M */

 YUGA CLM920-NC5 */

 Netgear Aircard 779S */

 Huawei E173 */

 Huawei E1820 */

 Wistron NeWeb D16Q1 */

 Wistron NeWeb D16Q1 */

 Wistron NeWeb D16Q1 */

 Wistron NeWeb M18Q5 */

 M9615A DM11-1 D51QC */

 Wistron NeWeb D18Q1 */

 Wistron NeWeb D18Q1 */

 Wistron NeWeb D18Q1 */

 Wistron NeWeb D18 */

 Wistron NeWeb D18 */

 Wistron NeWeb D19Q1 */

 Fibocom NL668 series */

 ASKEY WWHC050 */

 CMOTech 6003 */

 CMOTech CHE-628S */

 CMOTech CMU-301 */

 CMOTech CHU-628 */

 CMOTech CHU-720S */

 CMOTech 7002 */

 CMOTech CHU-629K */

 CMOTech 7004 */

 CMOTech CGU-629 */

 CMOTech CHU-629S */

 CMOTech CHU-720I */

 CMOTech 7212 */

 CMOTech 7213 */

 CMOTech 7251 */

 CMOTech 7252 */

 CMOTech 7253 */

 ONDA MT689DC */

 ZTE (Vodafone) K3520-Z */

 ZTE (Vodafone) K3565-Z */

 ZTE (Vodafone) K4505-Z */

 ZTE MF683 */

 ZTE MF820D */

 ZTE EuFi890 */

 ZTE MF820S */

 ZTE MF821 */

 ONDA MT8205 4G LTE */

 ZTE MF880 */

 ZTE MF821D */

 ZTE ZM8620 */

 Telewell TW-LTE 4G */

 ZTE (Vodafone) K3570-Z */

 ZTE (Vodafone) K3571-Z */

 ZTE (Vodafone) K5006-Z */

 ZTE MF667 */

 ZTE P685M */

 ZTE MF60 */

 ZTE MF91 */

 Telewell TW-LTE 4G v2 */

 ZTE ME3620 */

 ZTE (Vodafone) K3765-Z */

 D-Link DWM-221 */

 D-Link DWM-221 B1 */

 D-Link DWM-222 */

 D-Link DWM-222 A2 */

 Olicard 600 */

 BroadMobi BM806U */

 BroadMobi BM818 */

 Sierra Wireless MC7700 */

 Sierra Wireless MC7750 */

 Sierra Wireless MC7710 in QMI mode */

 Sierra Wireless MC7710 in QMI mode */

 Sierra Wireless MC7304/MC7354, WP76xx */

 Sierra Wireless MC7304/MC7354 */

 Sierra Wireless EM7700 */

 Sierra Wireless EM7355 */

 Sierra Wireless MC7305/MC7355 */

 Sierra Wireless MC7305/MC7355 */

 Netgear AirCard 340U */

 Sierra Wireless Modem */

 Sierra Wireless Modem */

 Netgear AirCard 341U */

 Sierra Wireless Modem */

 Sierra Wireless Modem */

 Sierra Wireless EM7305 */

 Sierra Wireless EM7305 */

 Sierra Wireless MC74xx */

 Sierra Wireless MC74xx */

 Sierra Wireless EM74xx */

 Sierra Wireless EM74xx */

 Sierra Wireless EM74xx */

 Sierra Wireless EM74xx */

 Sierra Wireless EM7565 */

 Telekom Speedstick LTE II (Alcatel One Touch L100V LTE) */

 Alcatel L800MA */

 TP-LINK HSUPA Modem MA180 */

 TP-LINK MA260 */

 Telit LE910C1-EUX */

 Telit LE922A */

 Telit FN980 */

 Telit LN920 */

 Telit ME910 */

 Telit ME910 dual modem */

 Telit LE920 */

 Telit LE920, LE920A4 */

 Telit LE910Cx */

 Telit LE910Cx */

 Telit LE910Cx */

 Telit LN940 series */

 Telewell TW-3G HSPA+ */

 Telewell TW-3G HSPA+ */

 XS Stick W100-2 from 4G Systems */

 Olivetti Olicard 100 */

 Olivetti Olicard 120 */

 Olivetti Olicard 140 */

 Olivetti Olicard 155 */

 Olivetti Olicard 200 */

 Olivetti Olicard 160 */

 Olivetti Olicard 500 */

 Cinterion PLxx */

 Cinterion PLS83/PLS63 */

 Cinterion PHxx,PXxx */

 Cinterion ALASxx (1 RmNet) */

 Cinterion PHxx,PXxx (2 RmNet) */

 Cinterion PHxx,PXxx (2 RmNet) */

 Cinterion PHxx,PXxx (1 RmNet + USB Audio)*/

 Cinterion CLS8 */

 Cinterion MV31 RmNet */

 Dell Wireless 5806 Gobi(TM) 4G LTE Mobile Broadband Card */

 Dell Wireless 5570 HSPA+ (42Mbps) Mobile Broadband Card */

 Dell Wireless 5570e HSPA+ (42Mbps) Mobile Broadband Card */

 Dell Wireless 5808 Gobi(TM) 4G LTE Mobile Broadband Card */

 Dell Wireless 5808e Gobi(TM) 4G LTE Mobile Broadband Card */

 Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card */

 Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card (rev3) */

 Dell Wireless 5811e */

 Dell Wireless 5811e */

 Dell Wireless 5816e */

 Dell Wireless 5821e */

 Dell Wireless 5821e preproduction config */

 Dell Wireless 5821e with eSIM support*/

 HP lt4111 LTE/EV-DO/HSPA+ Gobi 4G Module */

 HP lt4120 Snapdragon X5 LTE */

 WeTelecom WPD-600N */

 SIMCom 7100E, 7230E, 7600E ++ */

 Quectel EC21 Mini PCIe */

 Quectel EG91 */

 Quectel EG95 */

 Quectel BG96 */

 Fibocom NL678 series */

 Foxconn T77W968 LTE */

 Foxconn T77W968 LTE with eSIM support*/

 Cellient MPL200 (rebranded Qualcomm 05c6:9025) */

 4. Gobi 1000 devices */

 Acer Gobi Modem Device */

 HP un2400 Gobi Modem Device */

 Panasonic Gobi Modem device */

 Dell Gobi Modem device */

 Novatel/Verizon USB-1000 */

 Novatel Gobi Modem device */

 Novatel Gobi Modem device */

 Novatel Gobi Modem device */

 Novatel Gobi Modem device */

 Novatel Gobi Modem device */

 Novatel Gobi Modem device */

 Asus Gobi Modem device */

 ONDA Gobi Modem device */

 Generic Gobi Modem device */

 Generic Gobi Modem device */

 Generic Gobi Modem device */

 Generic Gobi Modem device */

 Generic Gobi Modem device */

 Generic Gobi Modem device */

 5. Gobi 2000 and 3000 devices */

 Dell Gobi 2000 Modem device (N0218, VU936) */

 Dell Gobi 3000 Composite */

 Generic Gobi 2000 Modem device */

 Sony Gobi 2000 Modem device (N0279, VU730) */

 Samsung Gobi 2000 Modem device (VL176) */

 HP Gobi 2000 Modem device (VP412) */

 Acer Gobi 2000 Modem device (VP413) */

 Quectel EC20 Mini PCIe */

 Asus Gobi 2000 Modem device (VR305) */

 Top Global Gobi 2000 Modem device (VR306) */

 iRex Technologies Gobi 2000 Modem device (VR307) */

 Option GTM681W */

 Sierra Wireless Modem */

 Sierra Wireless Modem */

 Sierra Wireless Gobi 2000 Modem device (VT773) */

 Sierra Wireless Gobi 2000 Modem device (VT773) */

 Sierra Wireless Gobi 2000 Modem device (VT773) */

 Sierra Wireless Gobi 2000 Modem device (VT773) */

 Sierra Wireless Gobi 2000 Modem device (VT773) */

 Sierra Wireless Gobi 2000 Modem device (VT773) */

 Sierra Wireless Gobi 2000 Modem device (VT773) */

 Sierra Wireless Gobi 2000 Modem device (VT773) */

 Sierra Wireless Gobi 2000 Modem device (VT773) */

 Sierra Wireless Gobi 2000 Modem device (VT773) */

 Sierra Wireless Gobi 2000 Modem device (MC8305) */

 CMDTech Gobi 2000 Modem device (VU922) */

 Gobi 2000 Modem device */

 Sierra Wireless Gobi 3000 Modem device (MC8355) */

 HP un2430 Mobile Broadband Module */

 Sierra Wireless Gobi 3000 Modem device */

 Sierra Wireless Gobi 3000 Modem device */

 Sierra Wireless MC7770 */

 Sony Gobi 3000 Composite */

 Foxconn Gobi 3000 Modem device (Novatel E396) */

 END */

	/* Workaround to enable dynamic IDs.  This disables usbnet

	 * blacklisting functionality.  Which, if required, can be

	 * reimplemented here by using a magic "blacklist" value

	 * instead of 0 in the static device id table

	/* There are devices where the same interface number can be

	 * configured as different functions. We should only bind to

	 * vendor specific functions when matching on interface number

 Quectel EC20 quirk where we've QMI on interface 4 instead of 0 */

	/* Several Quectel modems supports dynamic interface configuration, so

	 * we need to match on class/subclass/protocol. These values are

	 * identical for the diagnostic- and QMI-interface, but bNumEndpoints is

	 * different. Ignore the current interface if the number of endpoints

	 * equals the number for the diag interface (two).

 called twice if separate control and data intf */

 SPDX-License-Identifier: GPL-2.0-or-later

/* Aquantia Corp. Aquantia AQtion USB to 5GbE Controller

 * Copyright (C) 2003-2005 David Hollis <dhollis@davehollis.com>

 * Copyright (C) 2005 Phil Chang <pchang23@sbcglobal.net>

 * Copyright (C) 2002-2003 TiVo Inc.

 * Copyright (C) 2017-2018 ASIX

 * Copyright (C) 2018 Aquantia Corp.

 Inherit standard device info */

Not supported*/

 fall-through */

 RX bulk configuration */

 Set high low water level */

 Set the MAC address */

 Address */

 Data */

 Address */

 Data */

 Address */

 Data */

 Check if vendor configuration */

 store aqc111_data pointer in device data field */

 Init the MAC address */

 Set Rx urb size */

 Set TX needed headroom & tailroom */

 Force bz */

 Power down ethernet PHY */

 For Jumbo packet 16KB */

 RX bulk configuration */

 Set high low water level */

 Link up */

 Vlan Tag Filter */

 Power up ethernet PHY */

 Set the MAC address */

 Phy advertise */

 Put PHY to low power*/

 checksum error bit is set */

 It must be a TCP or UDP packet with a valid checksum */

RX Header Offset*/

 RX Descriptor Header */

 Check these packets */

 self check descs position */

 self check desc_offset from header*/

 Get the first RX packet descriptor */

 Next RX Packet Descriptor */

 Clone SKB */

 Next RX Packet Header */

Length of actual data*/

 TSO MSS */

 Vlan Tag */

 Copy TX header */

 Stop RX operations*/

 Force bz */

 Disable RX path */

 Power up ethernet PHY */

 Configure RX control register => start operation */

 END */

 SPDX-License-Identifier: GPL-2.0-or-later

/****************************************************************

 *

 *     kaweth.c - driver for KL5KUSB101 based USB->Ethernet

 *

 *     (c) 2000 Interlan Communications

 *     (c) 2000 Stephane Alnet

 *     (C) 2001 Brad Hards

 *     (C) 2002 Oliver Neukum

 *

 *     Original author: The Zapman <zapman@interlan.net>

 *     Inspired by, and much credit goes to Michael Rothwell

 *     <rothwell@interlan.net> for the test equipment, help, and patience

 *     Based off of (and with thanks to) Petko Manolov's pegaus.c driver.

 *     Also many thanks to Joel Silverman and Ed Surprenant at Kawasaki

 *     for providing the firmware and driver resources.

 *

/* TODO:

 * Develop test procedures for USB net interfaces

 * Run test procedures

 * Fix bugs from previous two steps

 * Snoop other OSs for any tricks we're not doing

 * Reduce arbitrary timeouts

 * Smart multicast support

 * Temporary MAC change support

 * Tunable SOFs parameter - ioctl()?

 * Ethernet stats collection

 * Code formatting improvements

 Table 7 */

 from id_table */

/****************************************************************

 *     usb_device_id

 AOX Endpoints USB Ethernet */

 I-O DATA USB-ET/T */

 3Com 3C19250 */

 3Com 3C460 */

 ATEN USB Ethernet */

 D-Link DSB-650C */

 Peracom Enet */

 Optus@Home UEP1045A */

 Peracom Enet2 */

 KLSI KL5KUSB101B */

 KLSI KL5KUSB101B (Board change) */

 Linksys USB10T */

 ADS USB-10BT */

 ADS USB-10BT */

 SMC 2202USB */

 Correga K.K. */

 D-Link DU-E10 */

 Allied Telesyn AT-USB10 USB Ethernet Adapter */

 NetGear EA-101 */

 NetGear EA-101 */

 PortGear Ethernet Adapter */

 PortGear Ethernet Adapter */

 Jaton USB Ethernet Device Adapter */

 Kingston Technology USB Ethernet Adapter */

 Portsmith Express Ethernet Adapter */

 ASANTE USB To Ethernet Adapter */

 Mobility USB-Ethernet Adapter */

 Shark Pocket Adapter */

 Silicom U2E */

 Psion Dacom Gold Port Ethernet */

 Entrega E45 */

 Entrega USB Ethernet Adapter */

 PortGear Ethernet Adapter */

 Actiontec USB Ethernet */

 D-link DSB-650C */

 Null terminator */

/****************************************************************

 *     kaweth_driver

/****************************************************************

 *     usb_eth_dev

/****************************************************************

 *     kaweth_ethernet_configuration

 *     Refer Table 8

/****************************************************************

 *     kaweth_device

/****************************************************************

 *     kaweth_read_configuration

/****************************************************************

 *     kaweth_set_urb_size

/****************************************************************

 *     kaweth_set_sofs_wait

/****************************************************************

 *     kaweth_set_receive_filter

/****************************************************************

 *     kaweth_download_firmware

/****************************************************************

 *     kaweth_trigger_firmware

/****************************************************************

 *     kaweth_reset

/****************************************************************

	int_callback

 success */

 unlink */

 -EPIPE:  should clear the halt */

 error */

 we check the link state to report changes */

/****************************************************************

 *     kaweth_resubmit_rx_urb

/****************************************************************

 *     kaweth_usb_receive

 we are killed - set a flag and wake the disconnect handler */

 Align IP on 16 byte boundaries */

/****************************************************************

 *     kaweth_open

 overriding the descriptor */

/****************************************************************

 *     kaweth_kill_urbs

	/* a scheduled work may have resubmitted,

/****************************************************************

 *     kaweth_close

/****************************************************************

 *     kaweth_usb_transmit_complete

/****************************************************************

 *     kaweth_start_xmit

 We now decide whether we can put our special header into the sk_buff */

/****************************************************************

 *     kaweth_set_rx_mode

/****************************************************************

 *     kaweth_async_set_rx_mode

/****************************************************************

 *     kaweth_tx_timeout

/****************************************************************

 *     kaweth_suspend

/****************************************************************

 *     kaweth_resume

/****************************************************************

 *     kaweth_probe

 from id_table */

	/*

	 * If high byte of bcdDevice is nonzero, firmware is already

	 * downloaded. Don't try to do it again, or we'll hang the device.

 Download the firmware */

 Device will now disappear for a moment...  */

 kaweth is zeroed as part of alloc_netdev */

/****************************************************************

 *     kaweth_disconnect

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * ASIX AX88172A based USB 2.0 Ethernet Devices

 * Copyright (C) 2012 OMICRON electronics GmbH

 *

 * Supports external PHYs via phylib. Based on the driver for the

 * AX88772. Original copyrights follow:

 *

 * Copyright (C) 2003-2006 David Hollis <dhollis@davehollis.com>

 * Copyright (C) 2005 Phil Chang <pchang23@sbcglobal.net>

 * Copyright (C) 2006 James Painter <jamie.painter@iname.com>

 * Copyright (c) 2002-2003 TiVo Inc.

 set MAC link settings according to information from phylib */

 link changes are detected by polling the phy */

 use phylib infrastructure */

 mii bus name is usb-<usb bus number>-<usb device number> */

 Get the MAC address */

 are we using the internal or the external phy? */

 Asix framing packs multiple eth frames into a 2K usb bulk transfer */

		/* hard_mtu  is still the default - the device does not support

 init MDIO bus */

 Rewrite MAC address */

 Set RX_CTL to default values with 2k buffer, and enable cactus */

 Connect to PHY */

	/* During power-up, the AX88172A set the power down (BMCR_PDOWN)

	 * bit of the PHY. Bring the PHY up again.

 SPDX-License-Identifier: GPL-2.0-or-later

 /***************************************************************************

 *

 * Copyright (C) 2007-2008 SMSC

 *

/* Loop until the read is completed with timeout

 confirm MII not busy */

 set the address, index & direction (read from PHY) */

 confirm MII not busy */

 set the address, index & direction (write to PHY) */

 Issue write/erase enable command */

 Fill data register */

 Send "write" command */

/* returns hash bit number for given MAC address

 * example:

 Initiate async writes, as we can't wait for completion here */

 Enable or disable Tx & Rx checksum offload engines */

 all smsc95xx registers */

 maybe the boot loader passed the MAC address in devicetree */

 device tree values are valid so use them */

 try reading mac address from EEPROM */

 eeprom values are valid so use them */

 no useful static MAC address found. generate a random one */

 starts the TX path */

 Enable Tx at MAC */

 Enable Tx at SCSRs */

 Starts the Receive path */

 set Rx data offset=2, Make IP header aligns on word boundary. */

 Configure GPIO pins as LED outputs */

 Init Tx */

 Don't need mac_cr_lock during initialisation */

 Init Rx */

 Set Vlan */

 Enable or disable checksum offload engines */

 enable PHY interrupts */

	/* LAN95xx devices do not alter the computed checksum of 0 to 0xffff.

	 * RFC 2460, ipv6 UDP calculated checksum yields a result of zero must

	 * be changed to 0xffff. RFC 768, ipv4 UDP computed checksum is zero,

	 * it is transmitted as all ones. The zero transmitted checksum means

	 * transmitter generated no checksum. Hence, enable csum offload only

	 * for ipv4 packets.

 Init all registers */

 detect device revision as different features may be available */

 read to clear */

 enable interrupt source */

 first, a dummy read, needed to latch some MII phys */

 clear wol status */

 enable energy detection */

 read back PM_CTRL */

	/* reconfigure link pulse detection timing for

	 * compatibility with non-standard link partners

 enable energy detect power-down mode */

 enter SUSPEND1 mode */

 clear wol status, enable energy detection */

 clear wol status */

 interface is ifconfig down so fully power down hw */

		/* link is down so enter EDPD mode, but only if device can

		 * reliably resume from it.  This check should be redundant

		 * as current FEATURE_REMOTE_WAKEUP parts also support

 enable PHY wakeup events for if cable is attached */

 enable PHY wakeup events so we remote wakeup if cable is pulled */

 determine if link is up using only _nopm functions */

 if we get this far we're not autosuspending */

	/* if no wol options set, or if link is down and we're not waking on

	 * PHY activity, enter lowest power SUSPEND2 mode

 disable energy detect (link up) & wake up events */

		/* if link is down then configure EDPD and enter SUSPEND1,

		 * otherwise enter SUSPEND0 below

 clear any pending pattern match packet status */

 clear any pending magic packet status */

 enable/disable wakeup sources */

 enable wol wakeup source */

 phy energy detect wakeup source */

 enable receiver to enable frame reception */

 some wol options are enabled, so enter SUSPEND0 */

	/*

	 * TODO: resume() might need to handle the suspend failure

	 * in system sleep

 do this first to ensure it's cleared even in error case */

 clear wake-up sources */

 clear wake-up status */

 This check is no longer done by usbnet */

 get the packet length */

 ETH_FRAME_LEN + 4(CRC) + 2(COE) + 4(Vlan) */

 last frame in this batch */

 remove fcs */

 remove fcs */

 padding bytes before the next frame starts */

/* The TX CSUM won't work if the checksum lies in the last 4 bytes of the

 * transmission. This is fairly unlikely, only seems to trigger with some

 * short TCP ACK packets sent.

 *

 * Note, this calculation should probably check for the alignment of the

 * data as well, but a straight check for csum being in the last four bytes

 * of the packet should be ok for now.

 We do not advertise SG, so skbs should be already linearized */

 Make writable and expand header space by overhead if required */

		/* Must deallocate here as returning NULL to indicate error

		 * means the skb won't be deallocated in the caller.

			/* workaround - hardware tx checksum does not work

 this chip revision isn't capable of remote wakeup */

 SMSC9500 USB Ethernet Device */

 SMSC9505 USB Ethernet Device */

 SMSC9500A USB Ethernet Device */

 SMSC9505A USB Ethernet Device */

 SMSC9512/9514 USB Hub & Ethernet Device */

 SMSC9500 USB Ethernet Device (SAL10) */

 SMSC9505 USB Ethernet Device (SAL10) */

 SMSC9500A USB Ethernet Device (SAL10) */

 SMSC9505A USB Ethernet Device (SAL10) */

 SMSC9512/9514 USB Hub & Ethernet Device (SAL10) */

 SMSC9500A USB Ethernet Device (HAL) */

 SMSC9505A USB Ethernet Device (HAL) */

 SMSC9500 USB Ethernet Device (Alternate ID) */

 SMSC9500A USB Ethernet Device (Alternate ID) */

 SMSC9512/9514 USB Hub & Ethernet Device (Alternate ID) */

 SMSC LAN9530 USB Ethernet Device */

 SMSC LAN9730 USB Ethernet Device */

 SMSC LAN89530 USB Ethernet Device */

 END */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * ASIX AX8817X based USB 2.0 Ethernet Devices

 * Copyright (C) 2003-2006 David Hollis <dhollis@davehollis.com>

 * Copyright (C) 2005 Phil Chang <pchang23@sbcglobal.net>

 * Copyright (C) 2006 James Painter <jamie.painter@iname.com>

 * Copyright (c) 2002-2003 TiVo Inc.

	/* Reset the variables that have a lifetime outside of

	 * asix_rx_fixup_internal() so that future processing starts from a

	 * known set of initial conditions.

 Discard any incomplete Ethernet frame in the netdev buffer */

	/* Assume the Data header 32-bit word is at the start of the current

	 * or next URB socket buffer so reset all the state variables.

	/* When an Ethernet frame spans multiple URB socket buffers,

	 * do a sanity test for the Data header synchronisation.

	 * Attempt to detect the situation of the previous socket buffer having

	 * been truncated or a socket buffer was missing. These situations

	 * cause a discontinuity in the data stream and therefore need to avoid

	 * appending bad data to the end of the current netdev socket buffer.

	 * Also avoid unnecessarily discarding a good current netdev socket

	 * buffer.

 take frame length from Data header 32-bit word */

			/* Sometimes may fail to get a netdev socket buffer but

			 * continue to process the URB socket buffer so that

			 * synchronisation of the Ethernet frame Data header

			 * word is maintained.

	/* We need to push 4 bytes in front of frame (packet_len)

	 * and maybe add 4 bytes after the end (if padlen is 4)

	 *

	 * Avoid skb_copy_expand() expensive call, using following rules :

	 * - We are allowed to push 4 bytes in headroom if skb_header_cloned()

	 *   is false (and if we have 4 bytes of headroom)

	 * - We are allowed to put 4 bytes at tail if skb_cloned()

	 *   is false (and if we have 4 bytes of tailroom)

	 *

	 * TCP packets for example are cloned, but __skb_header_release()

	 * was called in tcp stack, allowing us to use headroom for our needs.

 following should not happen, but better be safe */

 TODO: callers not checking for error ret */

 set MAC link settings according to information from phylib */

/*

 * AX88772 & AX88178 have a 16-bit RX_CTL value

 just broadcast and directed */

		/* We use the 20 byte dev->data

		 * for our 8 byte filter buffer

		 * to avoid allocating memory that

 Build the multicast hash filter. */

 MDIO read and write wrappers for phylib */

 ax8817x returns 2 bytes from eeprom on read */

	/* align data to 16 bit boundaries, read the missing data from

 write data to EEPROM */

 Inherit standard device info */

	/* We use the 20 byte dev->data

	 * for our 6 byte mac buffer

	 * to avoid allocating memory that

 SPDX-License-Identifier: GPL-2.0-only

/*

 * phonet.c -- USB CDC Phonet host driver

 *

 * Copyright (C) 2008-2009 Nokia Corporation. All rights reserved.

 *

 * Author: Rémi Denis-Courmont

/*

 * Network device callbacks

 Can't use pskb_pull() on page in IRQ */

 Last fragment */

/*

 * USB driver callbacks

 Nokia */

 Data interface has one inactive and one active setting */

 Endpoints */

 Force inactive mode until the network device is brought UP */

 Set disconnected flag so that disconnect() returns early. */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Ethernet interface part of the LG VL600 LTE modem (4G dongle)

 *

 * Copyright (C) 2011 Intel Corporation

 * Author: Andrzej Zaborowski <balrogg@gmail.com>

/*

 * The device has a CDC ACM port for modem control (it claims to be

 * CDC ACM anyway) and a CDC Ethernet port for actual network data.

 * It will however ignore data on both ports that is not encapsulated

 * in a specific way, any data returned is also encapsulated the same

 * way.  The headers don't seem to follow any popular standard.

 *

 * This driver adds and strips these headers from the ethernet frames

 * sent/received from the CDC Ethernet port.  The proprietary header

 * replaces the standard ethernet header in a packet so only actual

 * ethernet frames are allowed.  The headers allow some form of

 * multiplexing by using non standard values of the .h_proto field.

 * Windows/Mac drivers do send a couple of such frames to the device

 * during initialisation, with protocol set to 0x0906 or 0x0b06 and (what

 * seems to be) a flag in the .dummy_flags.  This doesn't seem necessary

 * for modem operation but can possibly be used for GPS or other functions.

	/* ARP packets don't go through, but they're also of no use.  The

	 * subnet has only two hosts anyway: us and the gateway / DHCP

	 * server (probably simulated by modem firmware or network operator)

	 * whose address changes every time we connect to the intarwebz and

	 * who doesn't bother answering ARP requests either.  So hardware

	 * addresses have no meaning, the destination and the source of every

 IPv6 NDP relies on multicast.  Enable it by default. */

	/* Frame lengths are generally 4B multiplies but every couple of

	 * hours there's an odd number of bytes sized yet correct frame,

	/* Allow a packet (or multiple packets batched together) to be

	 * split across many frames.  We don't allow a new batch to

	 * begin in the same frame another one is ending however, and no

	/* Yes, check that frame->magic == 0x53544448 (or 0x44544d48),

 Save this fragment for later assembly */

		/* Packet header is same size as the ethernet header

		 * (sizeof(*packet) == sizeof(*ethhdr)), additionally

		 * the h_proto field is in the same place so we just leave it

		 * alone and fill in the remaining fields.

 Copy the addresses from packet contents */

			/* Inbound IPv6 packets have an IPv4 ethertype (0x800)

			 * for some reason.  Peek at the L3 header to check

			 * for IPv6 packets, and set the ethertype to IPv6

			 * (0x86dd) so Linux can understand it.

 Not the last packet in this batch */

 Already encapsulated? */

 Drop, device can only deal with ethernet packets */

 There's enough head and tail room */

 There's enough total room, just readjust */

 Alloc a new skb with the required size */

	/* Packet header is same size as ethernet packet header

	 * (sizeof(*packet) == sizeof(struct ethhdr)), additionally the

	 * h_proto field is in the same place so we just leave it alone and

	 * overwrite the remaining fields.

	/* The VL600 wants IPv6 packets to have an IPv4 ethertype

	 * Since this modem only supports IPv4 and IPv6, just set all

	 * frames to 0x0800 (ETH_P_IP)

 Pad */

 End */

/*

 * cdc_ncm.c

 *

 * Copyright (C) ST-Ericsson 2010-2012

 * Contact: Alexey Orishko <alexey.orishko@stericsson.com>

 * Original author: Hans Petter Selasky <hans.petter.selasky@stericsson.com>

 *

 * USB Host Driver for Network Control Model (NCM)

 * http://www.usb.org/developers/docs/devclass_docs/NCM10_012011.zip

 *

 * The NCM encoding, decoding and initialization logic

 * derives from FreeBSD 8.x. if_cdce.c and if_cdcereg.h

 *

 * This software is available to you under a choice of one of two

 * licenses. You may choose this file to be licensed under the terms

 * of the GNU General Public License (GPL) Version 2 or the 2-clause

 * BSD license listed below:

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions

 * are met:

 * 1. Redistributions of source code must retain the above copyright

 *    notice, this list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright

 *    notice, this list of conditions and the following disclaimer in the

 *    documentation and/or other materials provided with the distribution.

 *

 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND

 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE

 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE

 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE

 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL

 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS

 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)

 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT

 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY

 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF

 * SUCH DAMAGE.

 clamp new_rx to sane values */

 dwNtbInMaxSize spec violation? Use MIN size for both limits */

 clamp new_tx to sane values */

 some devices set dwNtbOutMaxSize too low for the above default */

 no need to restrict values - anything from 0 to infinity is OK */

 no change? */

 flush pending data before changing flag */

 handle rx_max and tx_max changes */

 inform device about NTB input size changes */

 tell device to use new size */

 usbnet use these values for sizing rx queues */

	/* Adding a pad byte here if necessary simplifies the handling

	 * in cdc_ncm_fill_tx_frame, making tx_max always represent

	 * the real skb max size.

	 *

	 * We cannot use dev->maxpacket here because this is called from

	 * .bind which is called before usbnet sets up dev->maxpacket

 we might need to flush any pending tx buffers if running */

 make sure tx_curr_skb is reallocated if it was empty */

 max qlen depend on hard_mtu and rx_urb_size */

 never pad more than 3 full USB packets per transfer */

 helpers for NCM and MBIM differences */

/* initial one-time device setup.  MUST be called with the data interface

 * in altsetting 0

 GET_NTB_PARAMETERS is required */

 set CRC Mode */

 use ndp16 by default */

	/* set NTB format, if both formats are supported.

	 *

	 * "The host shall only send this command while the NCM Data

	 *  Interface is in alternate setting 0."

 set initial device values */

 devices prior to NCM Errata shall set this field to zero */

 max count of tx datagrams */

 set up maximum NDP size */

 initial coalescing timer interval */

 set a new max datagram size */

 set default based on descriptors */

 inform the device about the selected Max Datagram Size? */

 read current mtu value from device */

 set MTU to max supported by the device if necessary */

 do not exceed operator preferred MTU */

	/*

	 * verify that the structure alignment is:

	 * - power of two

	 * - not greater than the maximum transmit length

	 * - not less than four bytes

	/*

	 * verify that the payload alignment is:

	 * - power of two

	 * - not greater than the maximum transmit length

	 * - not less than four bytes

 verify the payload remainder */

 adjust TX-remainder according to NCM specification. */

	/* be conservative when selecting initial buffer size to

	 * increase the number of hosts this will work for

 clamp rx_max and tx_max and inform device */

 sanitize the modulus and remainder values */

 set max datagram size */

 ignore endpoints which cannot transfer data */

/* we need to override the usbnet change_mtu ndo for two reasons:

 *  - respect the negotiated maximum datagram size

 *  - avoid unwanted changes to rx and tx buffers

 store ctx pointer in device data field */

 only the control interface can be successfully probed */

 get some pointers */

 parse through descriptors associated with control interface */

 some buggy devices have an IAD but no CDC Union */

 check if we got everything */

 claim data interface, if different from control */

 Device-specific flags */

	/* Reset data interface. Some devices will not reset properly

	 * unless they are configured first.  Toggle the altsetting to

	 * force a reset.

	 * Some other devices do not work properly with this procedure

	 * that can be avoided using quirk CDC_MBIM_FLAG_AVOID_ALTSETTING_TOGGLE

 initialize basic device settings */

	/* Some firmwares need a pause here or they will silently fail

	 * to set up the interface properly.  This value was decided

	 * empirically on a Sierra Wireless MC7455 running 02.08.02.00

	 * firmware.

 configure data interface */

 finish setting up the device specific data */

 Allocate the delayed NDP if needed. */

 override ethtool_ops */

 add our sysfs attrs */

 must handle MTU changes */

 no setup */

 handle devices with combined control and data interface */

 disconnect master --> disconnect slave */

/* Return the number of the MBIM control interface altsetting iff it

 * is preferred and available,

	/* The MBIM spec defines a NCM compatible default altsetting,

	 * which we may have matched:

	 *

	 *  "Functions that implement both NCM 1.0 and MBIM (an

	 *   “NCM/MBIM function”) according to this recommendation

	 *   shall provide two alternate settings for the

	 *   Communication Interface.  Alternate setting 0, and the

	 *   associated class and endpoint descriptors, shall be

	 *   constructed according to the rules given for the

	 *   Communication Interface in section 5 of [USBNCM10].

	 *   Alternate setting 1, and the associated class and

	 *   endpoint descriptors, shall be constructed according to

	 *   the rules given in section 6 (USB Device Model) of this

	 *   specification."

 MBIM backwards compatible function? */

	/* The NCM data altsetting is fixed, so we hard-coded it.

	 * Additionally, generic NCM devices are assumed to accept arbitrarily

	 * placed NDP.

/* return a pointer to a valid struct usb_cdc_ncm_ndp16 of type sign, possibly

 * allocating a new one within skb

	/* If NDP should be moved to the end of the NCM package, we can't follow the

	* NTH16 header as we would normally do. NDP isn't written to the SKB yet, and

	* the wNdpIndex field in the header is actually not consistent with reality. It will be later.

		/* We can only push a single NDP to the end. Return

		 * NULL to send what we've already got and queue this

		 * skb for later.

 follow the chain of NDPs, looking for a match */

 align new NDP */

 verify that there is room for the NDP and the datagram (reserve) */

 link to it */

 push a new empty NDP */

	/* If NDP should be moved to the end of the NCM package, we can't follow the

	 * NTH32 header as we would normally do. NDP isn't written to the SKB yet, and

	 * the wNdpIndex field in the header is actually not consistent with reality. It will be later.

		/* We can only push a single NDP to the end. Return

		 * NULL to send what we've already got and queue this

		 * skb for later.

 follow the chain of NDPs, looking for a match */

 align new NDP */

 verify that there is room for the NDP and the datagram (reserve) */

 link to it */

 push a new empty NDP */

	/* When our NDP gets written in cdc_ncm_ndp(), then skb_out->len gets updated

	 * accordingly. Otherwise, we should check here.

 if there is a remaining skb, it gets priority */

 check if we are resuming an OUT skb */

 allocate a new OUT skb */

			/* If the memory allocation fails we will wait longer

			 * each time before attempting another full size

			 * allocation again to not overload the system

			 * further.

			/* See if a very small allocation is possible.

			 * We will send this packet immediately and hope

			 * that there is more memory available later.

 No allocation possible so we will abort */

 fill out the initial 16-bit NTB header */

 fill out the initial 32-bit NTB header */

 count total number of frames in this NTB */

 recent payload counter for this skb_out */

 send any remaining skb first */

 check for end of skb */

 get the appropriate NDP for this skb */

 align beginning of next frame */

 check if we had enough room left for both NDP and frame */

 won't fit, MTU problem? */

 no room for skb - store for later */

 count reason for transmitting */

 calculate frame number within this NDP */

 OK, add this skb */

 count real tx payload data */

 send now if this NDP is full */

 count reason for transmitting */

 free up any dangling skb */

 wait for more frames */

 push variables */

 wait for more frames */

 push variables */

 set the pending count */

 count reason for transmitting */

 frame goes out */

 variables will be reset at next call */

 If requested, put NDP at end of frame. */

 Zero out delayed NDP - signature checking will naturally fail. */

	/* If collected data size is less or equal ctx->min_tx_pkt

	 * bytes, we send buffers as it is. If we get more data, it

	 * would be more efficient for USB HS mobile device with DMA

	 * engine to receive a full size NTB, than canceling DMA

	 * transfer and receiving a short packet.

	 *

	 * This optimization support is pointless if we end up sending

	 * a ZLP after full sized NTBs.

 force short packet */

 set final frame length */

 return skb */

 keep private stats: framing overhead and number of NTBs */

	/* usbnet will count all the framing overhead by default.

	 * Adjust the stats so that the tx_bytes counter show real

	 * payload data instead.

 Start timer, if there is a remaining non-empty skb */

 start timer, if not already started */

 count reason for transmitting */

	/*

	 * The Ethernet API we are using does not support transmitting

	 * multiple Ethernet frames in a single call. This driver will

	 * accumulate multiple Ethernet frames and send out a larger

	 * USB frame when the USB buffer is full or when a single jiffies

	 * timeout happens.

 verify NTB header and return offset of first NDP, or negative error */

 verify NDP header and return number of datagrams, or negative error */

 we process NDP entries except for the last one */

 verify NDP header and return number of datagrams, or negative error */

 we process NDP entries except for the last one */

 arbitrary max preventing infinite loop */

		/*

		 * CDC NCM ch. 3.7

		 * All entries after first NULL entry are to be ignored

 empty NTB */

 sanity checking */

 create a fresh copy to reduce truesize */

 count payload bytes in this NTB */

 are there more NDPs to process? */

 update stats */

 RTL8156 shipped before 2021 sends notification about every 32ms. */

 test for split data in 8-byte chunks */

		/*

		 * According to the CDC NCM specification ch.7.1

		 * USB_CDC_NOTIFY_NETWORK_CONNECTION notification shall be

		 * sent by device after USB_CDC_NOTIFY_SPEED_CHANGE.

		/* RTL8156 shipped before 2021 sends notification about

		 * every 32ms. Don't forward notification if state is same.

 Same as cdc_ncm_info, but with FLAG_WWAN */

 Same as wwan_info, but with FLAG_NOARP  */

 Ericsson MBM devices like F5521gw */

 Telit LE910 V2 */

	/* DW5812 LTE Verizon Mobile Broadband Card

	 * Unlike DW5550 this device requires FLAG_NOARP

	/* DW5813 LTE AT&T Mobile Broadband Card

	 * Unlike DW5550 this device requires FLAG_NOARP

 Dell branded MBM devices like DW5550 */

 Toshiba branded MBM devices */

 tag Huawei devices as wwan */

 Infineon(now Intel) HSPA Modem platform */

 u-blox TOBY-L4 */

 Generic CDC-NCM devices */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * ASIX AX88179/178A USB 3.0/2.0 to Gigabit Ethernet Devices

 *

 * Copyright (C) 2011-2013 ASIX

 Check AX88179 version. UA1:Bit2 = 0,  UA2:Bit2 = 1 */

 Disable RX path */

 Force bulk-in zero length */

 change clock */

 Configure RX control register => stop operation */

 This function is used to enable the autodetach function. */

 This function is determined by offset 0x43 of EEPROM */

 Enable Auto Detach bit */

 Power up ethernet PHY */

 Ethernet PHY Auto Detach*/

 Enable clock */

 Configure RX control register => start operation */

 ax88179/178A returns 2 bytes from eeprom on read */

	/* align data to 16 bit boundaries, read the missing data from

 reload EEPROM data */

 Get Supported EEE */

 Get advertisement EEE */

 Get LP advertisement EEE */

 just broadcast and directed */

		/* We use the 20 byte dev->data for our 8 byte filter buffer

		 * to avoid allocating memory that is tricky to free later

 max qlen depend on hard_mtu and rx_urb_size */

 Set the MAC address */

 Read EEPROM content */

 Loaded the old eFuse LED Mode */

 Check AX88179 version. UA1 or UA2*/

 UA1 */

 Check EEPROM */

 load internal ROM for defaule setting */

 LED full duplex setting */

 Maybe the boot loader passed the MAC address via device tree */

 Power up ethernet PHY */

 Read MAC address from DTB or asix chip */

 RX bulk configuration */

 Initialize MII structure */

 Enable checksum offload */

 Configure RX control register => start operation */

 Configure default medium type => giga */

 Restart autoneg */

 Configure RX control register => stop operation */

 Power down ethernet PHY */

 checksum error bit is set */

 It must be a TCP or UDP packet with a valid checksum */

 This check is no longer done by usbnet */

 Check CRC or runt packet */

 Skip IP alignment pseudo header */

 Skip IP alignment pseudo header */

 Enable padding */

link up, check the usb device control TX FIFO full or empty*/

 RX bulk configuration */

 Power up ethernet PHY */

 Ethernet PHY Auto Detach*/

 Read MAC address from DTB or asix chip */

 RX bulk configuration */

 Enable checksum offload */

 Configure RX control register => start operation */

 Configure default medium type => giga */

 Restart autoneg */

 ASIX AX88179 10/100/1000 */

 ASIX AX88178A 10/100/1000 */

 Cypress GX3 SuperSpeed to Gigabit Ethernet Bridge Controller */

 D-Link DUB-1312 USB 3.0 to Gigabit Ethernet Adapter */

 Sitecom USB 3.0 to Gigabit Adapter */

 Samsung USB Ethernet Adapter */

 Lenovo OneLinkDock Gigabit LAN */

 Belkin B2B128 USB 3.0 Hub + Gigabit Ethernet Adapter */

 Toshiba USB 3.0 GBit Ethernet Adapter */

 Magic Control Technology U3-A9003 USB 3.0 Gigabit Ethernet Adapter */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (c) 2012  Smith Micro Software, Inc.

 * Copyright (c) 2012  Bjørn Mork <bjorn@mork.no>

 *

 * This driver is based on and reuse most of cdc_ncm, which is

 * Copyright (C) ST-Ericsson 2010-2012

 alternative VLAN for IP session 0 if not untagged */

 driver specific data - must match cdc_ncm usage */

 flags for the cdc_mbim_state.flags field */

 IP session 0 is tagged  */

 using a counter to merge subdriver requests with our own into a combined state */

 need autopm_get/put here to ensure the usbcore sees the new value */

 can be called while disconnecting */

 creation of this VLAN is a request to tag IP session 0 */

 we don't map these to MBIM session */

 this is a request for an untagged IP session 0 */

/* Change the control interface altsetting and update the .driver_info

 * pointer if the matching entry after changing class codes points to

 * a different struct

 should we change control altsetting on a NCM/MBIM function? */

 we will hit this for NCM/MBIM functions if prefer_mbim is false */

 The MBIM descriptor and the status endpoint are required */

 can't let usbnet use the interrupt endpoint */

 MBIM cannot do ARP */

 no need to put the VLAN tci in the packet headers */

 monitor VLAN additions and removals */

 disconnect subdriver from control interface */

 let NCM unbind clean up both control and data interface */

 verify that the ethernet protocol is IPv4 or IPv6 */

		/* Some applications using e.g. packet sockets will

		 * bypass the VLAN acceleration and create tagged

		 * ethernet frames directly.  We primarily look for

		 * the accelerated out-of-band tag, but fall back if

		 * required

 Is IP session <0> tagged too? */

 drop all untagged packets */

 map MBIM_IPS0_VID to IPS<0> */

		/* mapping VLANs to MBIM sessions:

		 *   no tag     => IPS session <0> if !FLAG_IPS0_VLAN

		 *   1 - 255    => IPS session <vlanid>

		 *   256 - 511  => DSS session <vlanid - 256>

		 *   512 - 4093 => unsupported, drop

		 *   4094       => IPS session <0> if FLAG_IPS0_VLAN

 VLAN ID 0 - 255 */

 VLAN ID 256 - 511 */

/* Some devices are known to send Neighbor Solicitation messages and

 * require Neighbor Advertisement replies.  The IPv6 core will not

 * respond since IFF_NOARP is set, so we must handle them ourselves.

	/* we'll only respond to requests from unicast addresses to

	 * our solicited node addresses.

 need to send the NA on the VLAN dev, if any */

 ipv6_stub != NULL if in6_dev_get returned an inet6_dev */

 router */,

 solicited */,

 override */,

 inc_opt */);

 IPS session? */

 add an ethernet header */

 add datagram */

 map MBIM session to VLAN */

 arbitrary max preventing infinite loop */

 tag IPS<0> packets too if MBIM_IPS0_VID exists */

		/*

		 * CDC NCM ch. 3.7

		 * All entries after first NULL entry are to be ignored

 empty NTB */

 sanity checking */

 count payload bytes in this NTB */

 are there more NDPs to process? */

 update stats */

	/*

	 * Both usbnet_suspend() and subdriver->suspend() MUST return 0

	 * in system sleep context, otherwise, the resume callback has

	 * to recover device from previous suspend failure.

/* MBIM and NCM devices should not need a ZLP after NTBs with

 * dwNtbOutMaxSize length. Nevertheless, a number of devices from

 * different vendor IDs will fail unless we send ZLPs, forcing us

 * to make this the default.

 *

 * This default may cause a performance penalty for spec conforming

 * devices wanting to take advantage of optimizations possible without

 * ZLPs.  A whitelist is added in an attempt to avoid this for devices

 * known to conform to the MBIM specification.

 *

 * All known devices supporting NCM compatibility mode are also

 * conforming to the NCM and MBIM specifications. For this reason, the

 * NCM subclass entry is also in the ZLP whitelist.

/* The spefication explicitly allows NDPs to be placed anywhere in the

 * frame, but some devices fail unless the NDP is placed after the IP

 * packets.  Using the CDC_NCM_FLAG_NDP_TO_END flags to force this

 * behaviour.

 *

 * Note: The current implementation of this feature restricts each NTB

 * to a single NDP, implying that multiplexed sessions cannot share an

 * NTB. This might affect performance for multiplexed sessions.

/* Some modems (e.g. Telit LE922A6) do not work properly with altsetting

 * toggle done in cdc_ncm_bind_common. CDC_MBIM_FLAG_AVOID_ALTSETTING_TOGGLE

 * flag is used to avoid this procedure.

	/* This duplicate NCM entry is intentional. MBIM devices can

	 * be disguised as NCM by default, and this is necessary to

	 * allow us to bind the correct driver_info to such devices.

	 *

	 * bind() will sort out this for us, selecting the correct

	 * entry and reject the other

 ZLP conformance whitelist: All Ericsson MBIM devices */

	/* Some Huawei devices, ME906s-158 (12d1:15c1) and E3372

	 * (12d1:157d), are known to fail unless the NDP is placed

	 * after the IP packets.  Applying the quirk to all Huawei

	 * devices is broader than necessary, but harmless.

	/* The HP lt4132 (03f0:a31d) is a rebranded Huawei ME906s-158,

	 * therefore it too requires the above "NDP to end" quirk.

 Telit LE922A6 in MBIM composition */

 Telit LN920 */

 default entry */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * ASIX AX8817X based USB 2.0 Ethernet Devices

 * Copyright (C) 2003-2006 David Hollis <dhollis@davehollis.com>

 * Copyright (C) 2005 Phil Chang <pchang23@sbcglobal.net>

 * Copyright (C) 2006 James Painter <jamie.painter@iname.com>

 * Copyright (c) 2002-2003 TiVo Inc.

 Get the PHY Identifier from the PHYSID1 & PHYSID2 MII registers */

 Poll for the rare case the FW or phy isn't ready yet.  */

/* We need to override some ethtool_ops so we require our

   own structure so we don't interfere with other usbnet

 just broadcast and directed */

		/* We use the 20 byte dev->data

		 * for our 8 byte filter buffer

		 * to avoid allocating memory that

 Build the multicast hash filter. */

 give phy_id a chance to process reset */

 See IEEE 802.3 "22.2.4.1.1 Reset": 500ms max */

 Toggle the GPIOs in a manufacturer/model specific way */

 Get the MAC address */

 Initialize MII structure */

 cf asix_tx_fixup() */

 cf asix_tx_fixup() */

 Rewrite MAC address */

 Set RX_CTL to default values with 2k buffer, and enable cactus */

 Rewrite MAC address */

 Set RX_CTL to default values with 2k buffer, and enable cactus */

 Check if the PHY registers have default settings */

 Restore PHY registers default setting if not */

 Rewrite MAC address */

 Set RX_CTL to default values with 2k buffer, and enable cactus */

 Set RX_CTL to default values with 2k buffer, and enable cactus */

 Stop MAC operation */

 mii bus name is usb-<usb bus number>-<usb device number> */

 Maybe the boot loader passed the MAC address via device tree */

 Try getting the MAC address from EEPROM */

 cf asix_tx_fixup() */

 cf asix_tx_fixup() */

 Asix framing packs multiple eth frames into a 2K usb bulk transfer */

		/* hard_mtu  is still the default - the device does not support

	/* On unplugged USB, we will get MDIO communication errors and the

	 * PHY will be set in to PHY_HALTED state.

 Clear out the center LED bits - 0x03F0 */

 Power up external GigaPHY through AX88178 GPIO pin */

 Read PHYID register *AFTER* powering up PHY */

 Set AX88178 to enable MII/GMII/RGMII interface for external PHY */

 Rewrite MAC address */

 max qlen depend on hard_mtu and rx_urb_size */

 Get the MAC address */

 Initialize MII structure */

 Blink LEDS so users know driver saw dongle */

 Asix framing packs multiple eth frames into a 2K usb bulk transfer */

		/* hard_mtu  is still the default - the device does not support

/*

 * USBLINK 20F9 "USB 2.0 LAN" USB ethernet adapter, typically found in

 * no-name packaging.

 * USB device strings are:

 *   1: Manufacturer: USBLINK

 *   2: Product: HG20F9 USB2.0

 *   3: Serial: 000003

 * Appears to be compatible with Asix 88772B.

 Linksys USB200M

 Netgear FA120

 DLink DUB-E100

 Intellinet, ST Lab USB Ethernet

 Hawking UF200, TrendNet TU2-ET100

 Billionton Systems, USB2AR

 Billionton Systems, GUSB2AM-1G-B

 ATEN UC210T

 Buffalo LUA-U2-KTX

 Buffalo LUA-U2-GT 10/100/1000

 Sitecom LN-029 "USB 2.0 10/100 Ethernet adapter"

 Sitecom LN-031 "USB 2.0 10/100/1000 Ethernet adapter"

 Sitecom LN-028 "USB 2.0 10/100/1000 Ethernet adapter"

 corega FEther USB2-TX

 Surecom EP-1427X-2

 goodway corp usb gwusb2e

 JVC MP-PRX1 Port Replicator

 Lenovo U2L100P 10/100

 ASIX AX88772B 10/100

 ASIX AX88772 10/100

 ASIX AX88178 10/100/1000

 Logitec LAN-GTJ/U2A

 Linksys USB200M Rev 2

 0Q0 cable ethernet

 DLink DUB-E100 H/W Ver B1

 DLink DUB-E100 H/W Ver B1 Alternate

 DLink DUB-E100 H/W Ver C1

 Linksys USB1000

 IO-DATA ETG-US2

 Belkin F5D5055

 Apple USB Ethernet Adapter

 Cables-to-Go USB Ethernet Adapter

 ABOCOM for pci

 ASIX 88772a

 Asus USB Ethernet Adapter

 ASIX 88172a demo board */

	/*

	 * USBLINK HG20F9 "USB 2.0 LAN"

	 * Appears to have gazumped Linksys's manufacturer ID but

	 * doesn't (yet) conflict with any known Linksys product.

 END

 SPDX-License-Identifier: GPL-2.0+

/*

 * Copyright (C) 2015 Microchip Technology

 Flow control turned on when Rx FIFO level rises above this level (bytes) */

 Flow control turned off when Rx FIFO level falls below this level (bytes) */

 USB related defines */

 default autosuspend delay (mSec)*/

 statistic update interval (mSec) */

 time to wait for MAC or FCT to stop (jiffies) */

 time to wait between polling MAC or FCT state (ms) */

 defines interrupts from interrupt EP */

 multicast hash table */

 perfect filter table */

 for dataport access */

 for rfe register access */

 skb->cb is one of these */

 for stats access */

 for irq bus access */

 serialise open/stop wrt suspend/resume */

 for phy access */

 count any extra framing */

 size for rx urbs */

 define external phy id */

 use ethtool to change the level for any given device */

 Loop until the read is completed with timeout called with phy_mutex held */

	/* depends on chip, some EEPROM pins are muxed with LED function.

	 * disable & restore LED function to access EEPROM.

	/* depends on chip, some EEPROM pins are muxed with LED function.

	 * disable & restore LED function to access EEPROM.

 Issue write/erase enable command */

 Fill data register */

 Send "write" command */

 clear it and wait to be cleared */

 clear it and wait to be cleared */

 set to BYTE program mode */

 returns hash bit number for given MAC address */

 pfilter_table[0] has own HW address */

 set first 32 into Perfect Filter */

 defer register writes to a sleepable context */

 threshold value should be set before enabling flow */

	/* Resetting the device while there is activity on the MDIO

	 * bus can result in the MAC interface locking up and not

	 * completing register access transactions.

	/* Wait for the reset to complete before allowing any further

	 * MAC register accesses otherwise the MAC may lock up.

 clear LAN78xx interrupt status */

 reset MAC */

 disable U2 */

 enable U1 */

 enable U1 & U2 */

/* some work can't be done in tasklets, so we use keventd

 *

 * NOTE:  annoying asymmetry:  if it's active, schedule_work() fails,

 * but tasklet_schedule() doesn't.	hope the failure is rare.

	/* Invalid EEPROM_INDICATOR at offset zero will result in a failure

	 * to load data from EEPROM

 EEE_TX_LPI_REQ_DLY & tx_lpi_timer are same uSec unit */

 change speed & duplex */

 force link down */

 Read Device/MAC registers */

 Read PHY registers */

 valid address present in Device Tree */

 eeprom values are valid so use them */

 generate random MAC */

 MDIO read and write wrappers for phylib */

 confirm MII not busy */

 set the address, index & direction (read from PHY) */

 confirm MII not busy */

 set the address, index & direction (write to PHY) */

 set to internal PHY id */

 scan thru PHYAD[2..0] */

	/* At forced 100 F/H mode, chip may fail to set mode correctly

	 * when cable is switched between long(~50+m) and short one.

	 * As workaround, set to 10 before setting to 100

	 * at forced 100 F/H mode.

 disable phy interrupt */

 set to 10 first */

 set to 100 later */

 clear pending interrupt generated while workaround */

 enable phy interrupt back */

	/* call register access here because irq_bus_lock & irq_bus_sync_unlock

	 * are only two callbacks executed in non-atomic contex.

 create mapping for PHY interrupt */

 LED2/PME_N/IRQ_N/RGMII_ID pin to IRQ_N mode */

 RGMII MAC TXC Delay Enable */

 RGMII TX DLL Tune Adjust */

 Micrel9301RNX PHY configuration */

 RGMII Control Signal Pad Skew */

 RGMII RX Data Pad Skew */

 RGMII RX Clock Pad Skew */

 external PHY fixup for KSZ9031RNX */

 external PHY fixup for LAN8835 */

 add more external PHY fixup here if needed */

 if phyirq is not set, use polling mode in phylib */

 set to AUTOMDIX */

 MAC doesn't support 1000T Half */

 support both flow controls */

 Ensure the appropriate LEDs are enabled */

 add 4 to size for FCS */

		/* Get reference count of the URB to avoid it to be

		 * freed during usb_unlink_urb, which may trigger

		 * use-after-free problem inside usb_unlink_urb since

		 * usb_unlink_urb is always racing with .complete

		 * handler(include defer_bh).

		/* during some PM-driven resume scenarios,

		 * these (async) unlinks complete immediately

 no second zero-length packet read wanted after mtu-sized packets */

 Added to support MAC address changes */

 Enable or disable Rx checksum offload engine */

 defer register writes to a sleepable context */

 defer register writes to a sleepable context */

 Get values from EEPROM first */

 Stop the h/w block (if not already stopped) */

 Start the MAC transmitter */

 Start the Tx FIFO */

 Stop the Tx FIFO */

 Stop the MAC transmitter */

/* The caller must ensure the Tx path is stopped before calling

 * lan78xx_flush_tx_fifo().

 Start the Rx FIFO */

 Start the MAC receiver*/

 Stop the MAC receiver */

 Stop the Rx FIFO */

/* The caller must ensure the Rx path is stopped before calling

 * lan78xx_flush_rx_fifo().

 save DEVID for later usage */

 Respond to the IN token with a NAK */

 Init LTM */

 set FIFO sizes */

 Don't need rfe_ctl_lock during initialisation */

 Enable or disable checksum offload engines */

 reset PHY */

 LAN7801 only has RGMII mode */

 Implies there is no external eeprom. Set mac speed */

	/* initialize for stats update

	 * some counters are 20bits and some are 32bits

 for Link Check */

 ensure there are no more active urbs */

 maybe wait for deletions to finish. */

 ignore errors that occur stopping the Tx and Rx data paths */

	/* deferred work (task, timer, softirq) must also stop.

	 * can't flush_scheduled_work() until we drop rtnl (later),

	 * else workers could deadlock; so make workers a NOP.

 software-driven interface shutdown */

 throttle TX patch at slower than SUPER SPEED USB */

 Init all registers */

	/* HW Checksum offload appears to be flawed if used when not stripping

	 * VLAN headers. Drop back to S/W checksums under these conditions.

 get the packet length */

 last frame in this batch */

 remove fcs */

 remove fcs */

 padding bytes before the next frame starts */

 async unlink */

 hardware gone */

 data overrun ... flush fifo? */

 handle previous packets first */

 copy to a single skb */

 send USB_ZERO_PACKET */

 if this triggers the device is still a sleep */

 transmission will be done in resume */

 no use to process more packets */

 reset update timer delta */

 success */

 software-driven interface shutdown */

 urb killed */

 hardware gone */

 hardware gone */

	/* NOTE:  not throttling like RX/TX, since this endpoint

	 * already polls infrequently

 netdev_printk() needs this */

 MTU range: 68 - 9000 */

 Reject broken descriptors. */

 driver requires remote-wakeup capability during autosuspend. */

	 /* Default delay of 2sec has more overhead than advantage.

	  * Set to 10sec as default.

 auto suspend (selective suspend) */

 set goodframe wakeup */

 set WUF_CFG & WUF_MASK for IPv4 Multicast */

 for IPv6 Multicast */

		/* set WUF_CFG & WUF_MASK

		 * for packettype (offset 12,13) = ARP (0x0806)

 when multiple WOL bits are set */

 clear WUPS */

 don't autosuspend while transmitting */

 stop RX */

 stop Tx */

 empty out the Rx and Tx queues */

 reattach */

		/* Interface is down; don't allow WOL and PHY

		 * events to wake up the host

 LAN7800 USB Gigabit Ethernet Device */

 LAN7850 USB Gigabit Ethernet Device */

 LAN7801 USB Gigabit Ethernet Device */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * USB network interface driver for Samsung Kalmia based LTE USB modem like the

 * Samsung GT-B3730 and GT-B3710.

 *

 * Copyright (C) 2011 Marius Bjoernstad Kotsbak <marius@kotsbak.com>

 *

 * Sponsored by Quicklink Video Distribution Services Ltd.

 *

 * Based on the cdc_eem module.

/*

 * The Samsung Kalmia based LTE USB modems have a CDC ACM port for modem control

 * handled by the "option" module and an ethernet data port handled by this

 * module.

 *

 * The stick must first be switched into modem mode by usb_modeswitch

 * or similar tool. Then the modem gets sent two initialization packets by

 * this module, which gives the MAC address of the device. User space can then

 * connect the modem using AT commands through the ACM port and then use

 * DHCP on the network interface exposed by this module. Network packets are

 * sent to and from the modem in a proprietary format discovered after watching

 * the behavior of the windows driver for the modem.

 *

 * More information about the use of the modem is available in usb_modeswitch

 * forum and the project page:

 *

 * http://www.draisberghof.de/usb_modeswitch/bb/viewtopic.php?t=465

 * https://github.com/mkotsbak/Samsung-GT-B3730-linux-driver

 #define	DEBUG */

 #define	VERBOSE */

-------------------------------------------------------------------------*/

 Don't bind to AT command interface */

 Found as optimal after testing

 According to empiric data for data packages */

 Align to 4 bytes by padding with zeros */

	/*

	 * Our task here is to strip off framing, leaving skb with one

	 * data frame for the usbnet framework code to process.

 incomplete header? */

 subtract start header and end header */

 Some small packets misses end marker */

-------------------------------------------------------------------------*/

 The unswitched USB ID, to get the module auto loaded: */

 The stick switched into modem (by e.g. usb_modeswitch): */

 EMPTY == end of list */} };

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (c) 2009 Peter Holik

 *

 * Intellon usb PLC (Powerline Communications) usb net driver

 *

 * http://www.tandel.be/downloads/INT51X1_Datasheet.pdf

 *

 * Based on the work of Jan 'RedBully' Seiffert

/*

 2 byte header */

 no filter */

 filtered */

 if packet and our header is smaller than 64 pad to 64 (+ ZLP) */

	/*

	 * usbnet would send a ZLP if packetlength mod urbsize == 0 for us,

	 * but we need to know ourself, because this would add to the length

	 * we send down to the device...

 do not expect to see traffic of other PLCs */

 ~PROMISCUOUS, ~MULTICAST */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *  Copyright (c) 1999-2021 Petko Manolov (petkan@nucleusys.com)

 *

/*

 * Version Information

/*

 * The Belkin F8T012xx1 bluetooth adaptor has the same vendor and product

 * IDs as the Belkin F5D5050, so we need to teach the pegasus driver to

 * ignore adaptors belonging to the "Wireless" class 0xE0. For this one

 * case anyway, seeing as the pegasus is for "Wired" adaptors.

 use ethtool to change the level for any given device */

****/

/*

 * There is only one way to write to a single ADM8511 register and this is via

 * specific control request.  'data' is ignored by the device, but it is here to

 * not break the API.

 Returns non-negative int on success, error on failure */

 Returns zero on success, error on failure */

 PEGASUS_WRITE_EEPROM */

 TX & RX enable, append status, no CRC */

 set full duplex */

 set 100 Mbps */

 stall, or disconnect from TT */

 FIXME schedule work to clear the halt */

 long or runt	*/

 extra bits	*/

	/*

	 * If the packet is unreasonably long, quietly drop it rather than

	 * kernel panicing by calling skb_put.

	/*

	 * at this point we are sure pegasus->rx_skb != NULL

	 * so we go ahead and pass up the packet.

 FIXME schedule_work() to clear the tx halt */

 prevent tx timeout */

 unlink */

		/* some Pegasus-I products report LOTS of data

		 * toggle errors... avoid log spamming

 byte 0 == tx_status1, reg 2B */

		/* d[5].LINK_STATUS lies on some adapters.

		 * d[0].NO_CARRIER kicks in only with failed TX.

		 * ... so monitoring with MII may be safest.

 bytes 3-4 == rx_lostpkt, reg 2E/2F */

 stall, or disconnect from TT */

 cleanup should already have been scheduled */

 disconnect() upcoming */

 also handles three patterns of some kind in hardware */

 FIXME this 0x10 bit still needs to get set in the chip... */

	/* Special quirk to keep the driver from handling the Belkin Bluetooth

	 * dongle which happens to have the same ID.

 name now points to a null terminated string*/

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2002 Pavel Machek <pavel@ucw.cz>

 * Copyright (C) 2002-2005 by David Brownell

 #define	DEBUG			
 #define	VERBOSE			
/*

 * All known Zaurii lie about their standards conformance.  At least

 * the earliest SA-1100 models lie by saying they support CDC Ethernet.

 * Some later models (especially PXA-25x and PXA-27x based ones) lie

 * and say they support CDC MDLM (for access to cell phone modems).

 *

 * There are non-Zaurus products that use these same protocols too.

 *

 * The annoying thing is that at the same time Sharp was developing

 * that annoying standards-breaking software, the Linux community had

 * a simple "CDC Subset" working reliably on the same SA-1100 hardware.

 * That is, the same functionality but not violating standards.

 *

 * The CDC Ethernet nonconformance points are troublesome to hosts

 * with a true CDC Ethernet implementation:

 *   - Framing appends a CRC, which the spec says drivers "must not" do;

 *   - Transfers data in altsetting zero, instead of altsetting 1;

 *   - All these peripherals use the same ethernet address.

 *

 * The CDC MDLM nonconformance is less immediately troublesome, since all

 * MDLM implementations are quasi-proprietary anyway.

	/* Belcarra's funky framing has other options; mostly

	 * TRAILERS (!) with 4 bytes CRC, and maybe 2 pad bytes.

 PDA style devices are always connected if present */

/* Some more recent products using Lineo/Belcarra code will wrongly claim

 * CDC MDLM conformance.  They aren't conformant:  data endpoints live

 * in the control interface, there's no data interface, and it's not used

 * to talk to a cell phone radio.  But at least we can detect these two

 * pseudo-classes, rather than growing this product list with entries for

 * each new nonconformant product (sigh).

		/* use bDescriptorSubType, and just verify that we get a

		 * "BLAN" (or "SAFE") descriptor.

 expect bcdVersion 1.0, ignore */

 hey, this one might _really_ be MDLM! */

 "SAFE" */

 "BLAN" */

			/* assuming we either noticed BLAN already, or will

			 * find it soon, there are some data bytes here:

			 *  - bmNetworkCapabilities (unused)

			 *  - bmDataCapabilities (bits, see below)

			 *  - bPad (ignored, for PADAFTER -- BLAN-only)

			 * bits are:

			 *  - 0x01 -- Zaurus framing (add CRC)

			 *  - 0x02 -- PADBEFORE (CRC includes some padding)

			 *  - 0x04 -- PADAFTER (some padding after CRC)

			 *  - 0x08 -- "fermat" packet mangling (for hw bugs)

			 * the PADBEFORE appears not to matter; we interop

			 * with devices that use it and those that don't.

				/* bmDataCapabilities == 0 would be fine too,

				 * but framing is minidriver-coupled for now.

 same extra framing as for non-BLAN mode */

 bLength */

	/* There's probably a CDC Ethernet descriptor there, but we can't

	 * rely on the Ethernet address it provides since not all vendors

	 * bother to make it unique.  Likewise there's no point in tracking

	 * of the CDC event notifications.

 SA-1100 based Sharp Zaurus ("collie"), or compatible. */

/* PXA-2xx based models are also lying-about-cdc.  If you add any

 * more devices that claim to be CDC Ethernet, make sure they get

 * added to the blacklist in cdc_ether too.

 *

 * NOTE:  OpenZaurus versions with 2.6 kernels won't use these entries,

 * unlike the older ones with 2.4 "embedix" kernels.

 A-300 */

 B-500/SL-5600 */

 C-700 */

 C-750 C-760 */

 C-750/C-760/C-860/SL-C3000 PDA in MDLM mode */

 SL-6000 */

 reported with some C860 units */

 C-860 */

 Motorola Rokr E6 */

 Motorola MOTOMAGX phones */

/* Olympus has some models with a Zaurus-compatible option.

 * R-1000 uses a FreeScale i.MXL cpu (ARMv4T)

 R-1000 */

 Logitech Harmony 900 - uses the pseudo-MDLM (BLAN) driver */

 END

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * USB-to-WWAN Driver for Sierra Wireless modems

 *

 * Copyright (C) 2008, 2009, 2010 Paxton Smith, Matthew Safar, Rory Filer

 *                          <linux@sierrawireless.com>

 *

 * Portions of this based on the cdc_ether driver by David Brownell (2003-2005)

 * and Ole Andre Vadla Ravnas (ActiveSync) (2006).

 *

 * IMPORTANT DISCLAIMER: This driver is not commercially supported by

 * Sierra Wireless. Use at your own risk.

 if defined debug messages enabled */

#define	DEBUG*/

/* atomic counter partially included in MAC address to make sure 2 devices

 * do not end up with the same MAC - concept breaks in case of > 255 ifaces

/*

 * SYNC Timer Delay definition used to set the expiry time

 Max. MTU supported. The modem buffers are limited to 1500 */

/* The SIERRA_NET_USBCTL_BUF_LEN defines a buffer size allocated for control

 * message reception ... and thus the max. received packet.

 * (May be the cause for parse_hip returning -EINVAL)

 Overriding the default usbnet rx_urb_size */

 Private data structure */

 air link up or down */

 part of HIP hdr for tx'd packets */

 SYNC message */

 Shutdown message */

 Backpointer to the container */

 interface number */

 Bit masks, must be a power of 2 */

 For retrying SYNC sequence */

 HIP message type */

 Modem -> host */

 Modem -> host */

 Host -> modem */

 Host -> modem */

 3G UMTS Link Sense Indication definitions */

 Reverse Channel Grant Indication HIP message */

 LSI Protocol types */

 LSI Coverage */

 LSI Session */

 LSI Link types */

 eventually use a union for the rest - assume umts for now */

 network name len */

 network name (UCS2, bigendian) */

 NW-supplied PDP address len */

 NW-supplied PDP address (bigendian)) */

 NW-supplied 1st DNS address len (bigendian) */

 NW-supplied 1st DNS address */

 NW-supplied 2nd DNS address len */

 NW-supplied 2nd DNS address (bigendian)*/

 NW-supplied 1st Wins address len */

 NW-supplied 1st Wins address (bigendian)*/

 NW-supplied 2nd Wins address len */

 NW-supplied 2nd Wins address (bigendian) */

 NW-supplied GW address len */

 NW-supplied GW address (bigendian) */

 NW-supplied PDP IPv4 address len */

 NW-supplied PDP IPv4 address (bigendian)) */

 NW-supplied PDP IPv6 address len */

 NW-supplied PDP IPv6 address (bigendian)) */

 NW-supplied 1st DNS v4 address len (bigendian) */

 NW-supplied 1st DNS v4 address */

 NW-supplied 1st DNS v6 address len */

 NW-supplied 1st DNS v6 address (bigendian)*/

 NW-supplied 2nd DNS v4 address len (bigendian) */

 NW-supplied 2nd DNS v4 address */

 NW-supplied 2nd DNS v6 address len */

 NW-supplied 2nd DNS v6 address (bigendian)*/

 Our own net device operations structure */

 get private data associated with passed in usbnet device */

 set private data associated with passed in usbnet device */

 is packet IPv4/IPv6 */

/*

 * check passed in packet and make sure that:

 *  - it is linear (no scatter/gather)

 *  - it is ethernet (mac_header properly set)

 ethernet header */

/*----------------------------------------------------------------------------*

 *                              BEGIN HIP                                     *

 HIP header */

 Extended HIP header */

 7 bits */

 14 bits */

 10 bits */

 11 bits */

 if real packet shorter than the claimed length */

	/* the following doesn't have the full functionality. We

	 * currently build only one kind of header, so it is faster this way

/*----------------------------------------------------------------------------*

 *                              END HIP                                       *

 Validate the session state */

 Validate the protocol  - only support UMTS for now */

 Validate the link type */

 Validate the coverage */

 Set link_sense true */

	/* The SIERRA_NET_HIP_MSYNC_ID command appears to request that the

	 * firmware restart itself.  After restarting, the modem will respond

	 * with the SIERRA_NET_HIP_RESTART_ID indication.  The driver continues

	 * sending MSYNC commands every few seconds until it receives the

	 * RESTART event from the firmware

 tell modem we are ready */

 Now, start a timer and make sure we get the Restart Indication */

 Query the modem for the LSI message */

 Validate packet length */

 Switch on received message types */

 Got sync resp - stop timer & clear mask */

 Ignored */

 The sync timer bit might be set */

/*

 * Sync Retransmit Timer Handler. On expiry, kick the work queue

 Kick the tasklet */

 Add cases to handle other standard notifications. */

 USB 305 sends those */

 Inherit standard device info */

 Report link is down whenever the interface is down */

 _u8 vendor specific request */

 __u8 request type */

 __u16 value not used */

 __u16 index  not used */

 char *data */

 __u16 size */

/*

 * collects the bulk endpoints, the status endpoint.

 We have three endpoints, bulk in and out, and a status */

 Status endpoint set in usbnet_get_endpoints() */

 Initialize sierra private data */

 change MAC addr to include, ifacenum, and to be unique */

 prepare shutdown message template */

 set context index initially to 0 - prepares tx hdr template */

 prepare sync message template */

 decrease the rx_urb_size and max_tx_size to 4k on USB 1.1 */

 Set up the netdev */

 Use the shared workqueue */

 Only need to do this once */

 verify fw attributes */

 test whether firmware supports DHCP */

 found incompatible firmware version */

 kill the timer and work */

 tell modem we are going away */

 clone skb */

 remove len bytes from original */

 trim next packet to it's length */

 ---------------------------- Receive data path ----------------------*/

 could contain multiple packets */

 dev->net->stats.rx_errors incremented by caller */

 Validate Extended HIP header */

 dev->net->stats.rx_errors incremented by caller */

		/* We are going to accept this packet, prepare it.

		 * In case protocol is IPv6, keep it, otherwise force IPv4.

 Last packet in batch handled by usbnet */

 while */

 ---------------------------- Transmit data path ----------------------*/

 enough head room as is? */

 Save the Eth/IP length and set up HIP hdr */

 Handle ZLP issue */

			/*

			 * compensate in the future if necessary

 headroom */

 tx_dropped incremented by usbnet */

 filter the packet out, release it  */

 Interrupt URB now set up; initiate sync sequence */

 Sierra Wireless USB-to-WWAN modem */

 AT&T Direct IP modem */

 Sierra Wireless Direct IP LTE modem */

 AT&T Direct IP LTE modem */

 last item */

 We are based on usbnet, so let it handle the USB driver specifics */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

	/* siphash gives us a secure 64bit number based on a random key. Since

	 * the bits are uniformly distributed, we can then mask off to get the

	 * bits we need.

 Returns a strong reference to a peer */

	/* Since the indices are random and thus all bits are uniformly

	 * distributed, we can find its bucket simply by masking.

/* At the moment, we limit ourselves to 2^20 total peers, which generally might

 * amount to 2^20*3 items in this hashtable. The algorithm below works by

 * picking a random number and testing it. We can see that these limits mean we

 * usually succeed pretty quickly:

 *

 * >>> def calculation(tries, size):

 * ...     return (size / 2**32)**(tries - 1) *  (1 - (size / 2**32))

 * ...

 * >>> calculation(1, 2**20 * 3)

 * 0.999267578125

 * >>> calculation(2, 2**20 * 3)

 * 0.0007318854331970215

 * >>> calculation(3, 2**20 * 3)

 * 5.360489012673497e-07

 * >>> calculation(4, 2**20 * 3)

 * 3.9261394135792216e-10

 *

 * At the moment, we don't do any masking, so this algorithm isn't exactly

 * constant time in either the random guessing or in the hash list lookup. We

 * could require a minimum of 3 tries, which would successfully mask the

 * guessing. this would not, however, help with the growing hash lengths, which

 * is another thing to consider moving forward.

 First we try to find an unused slot, randomly, while unlocked. */

 If it's already in use, we continue searching. */

	/* Once we've found an unused slot, we lock it, and then double-check

	 * that nobody else stole it from us.

 If it was stolen, we start over. */

	/* Otherwise, we know we have it exclusively (since we're locked),

	 * so we insert.

	/* Calling init here NULLs out index_hash, and in fact after this

	 * function returns, it's theoretically possible for this to get

	 * reinserted elsewhere. That means the RCU lookup below might either

	 * terminate early or jump between buckets, in which case the packet

	 * simply gets dropped, which isn't terrible.

 Returns a strong reference to a entry->peer */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

 Must be called with bh disabled. */

 Bogus IP header */

		/* Packet has offset at impossible location or isn't big enough

		 * to have UDP fields.

		/* UDP packet is reporting too small of a size or lying about

		 * its size.

 Final len does not agree with calculated len */

	/* This is global, so that our load calculation applies to the whole

	 * system. We don't care about races with it at all.

			/* Calling this function will either send any existing

			 * packets in the queue and not send a keepalive, which

			 * is the best case, Or, if there's nothing in the

			 * queue, it will send a keepalive, in order to give

			 * immediate confirmation of the session.

	/* We ensure that the network header is part of the packet before we

	 * call skb_cow_data, so that there's no chance that data is removed

	 * from the skb, so that later we can extract the original endpoint.

	/* Another ugly situation of pushing and pulling the header so as to

	 * keep endpoint information intact.

 This is RFC6479, a replay detection bitmap algorithm that avoids bitshifts */

 A packet with length 0 is a keepalive packet */

	/* We've already verified the Poly1305 auth tag, which means this packet

	 * was not modified in transit. We can therefore tell the networking

	 * stack that all checksums of every layer of encapsulation have already

	 * been checked "by the hardware" and therefore is unnecessary to check

	 * again in software.

 All levels */

 We don't need the extra reference. */

		/* Queues up a call to packet_process_queued_handshake_

		 * packets(skb):

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

	/* This could be much faster if it actually just compared the common

	 * bits properly, by precomputing a mask bswap(~0 << (32 - cidr)), and

	 * the rest, but it turns out that common_bits is already super fast on

	 * modern processors, even taking into account the unfortunate bswap.

	 * So, we just inline it like this instead.

 Returns a strong reference to a peer */

 Aligned so it can be passed to fls/fls64 */

 Aligned so it can be passed to fls */

 Aligned so it can be passed to fls64 */

 Returns a strong reference to a peer */

 Returns a strong reference to a peer */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

 Protected by init_lock, hence not atomic. */

 Calling this function with a NULL work uninits all entries. */

	/* We only take the bottom half of the net pointer, so that we can hash

	 * 3 words in the end. This way, siphash's len param fits into the final

	 * u32, and we don't incur an extra round.

 Only use 64 bits, so as to ratelimit the whole /64. */

			/* Quasi-inspired by nft_limit.c, but this is actually a

			 * slightly different algorithm. Namely, we incorporate

			 * the burst as part of the maximum tokens, rather than

			 * as part of the rate.

	/* xt_hashlimit.c uses a slightly different algorithm for ratelimiting,

	 * but what it shares in common is that it uses a massive hashtable. So,

	 * we borrow their wisdom about good table sizes on different systems

	 * dependent on RAM. This calculation here comes from there.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

 This function is rate limited. */

	/* We check last_sent_handshake here in addition to the actual function

	 * we're queueing up, so that we don't queue things if not strictly

	 * necessary:

	/* Queues up calling packet_send_queued_handshakes(peer), where we do a

	 * peer_put(peer) after:

		/* If the work was already queued, we want to drop the

		 * extra reference:

	/* We do this modulo business with the MTU, just in case the networking

	 * layer gives us a packet that's bigger than the MTU. In that case, we

	 * wouldn't want the final subtraction to overflow in the case of the

	 * padded_size being clamped. Fortunately, that's very rarely the case,

	 * so we optimize for that not happening.

	/* Force hash calculation before encryption so that flow analysis is

	 * consistent over the inner packet.

 Calculate lengths. */

 Expand data section to have room for padding and auth tag. */

	/* Set the padding to zeros, and make sure it and the auth tag are part

	 * of the skb.

	/* Expand head section to have room for our header and the network

	 * stack's headers.

 Finalize checksum calculation for the inner packet, if required. */

	/* Only after checksumming can we safely add on the padding at the end

	 * and the header.

 Now we can encrypt the scattergather segments */

 Steal the current queue into our local one. */

 First we make sure we have a valid reference to a valid key. */

	/* After we know we have a somewhat valid key, we now try to assign

	 * nonces to all of the packets in the queue. If we can't assign nonces

	 * for all of them, we just consider it a failure and wait for the next

	 * handshake.

		/* 0 for no outer TOS: no leak. TODO: at some later point, we

		 * might consider using flowi->tos as outer instead.

	/* We orphan the packets if we're waiting on a handshake, so that they

	 * don't block a socket's pool.

	/* Then we put them back on the top of the queue. We're not too

	 * concerned about accidentally getting things a little out of order if

	 * packets are being added really fast, because this queue is for before

	 * packets can even be sent and it's small anyway.

	/* If we're exiting because there's something wrong with the key, it

	 * means we should initiate a new handshake.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

 Must hold peer->handshake.static_identity->lock */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

 Remove from configuration-time lookup structures. */

 Mark as dead, so that we don't allow jumping contexts after. */

 The caller must now synchronize_net() for this to take effect. */

	/* No more keypairs can be created for this peer, since is_dead protects

	 * add_new_keypair, so we can now destroy existing ones.

	/* Destroy all ongoing timers that were in-flight at the beginning of

	 * this function.

	/* The transition between packet encryption/decryption queues isn't

	 * guarded by is_dead, but each reference's life is strictly bounded by

	 * two generations: once for parallel crypto and once for serial

	 * ingestion, so we can simply flush twice, and be sure that we no

	 * longer have references inside these queues.

 a) For encrypt/decrypt. */

 b.1) For send (but not receive, since that's napi). */

 b.2.1) For receive (but not send, since that's wq). */

	/* b.2.1) It's now safe to remove the napi struct, which must be done

	 * here from process context.

	/* Ensure any workstructs we own (like transmit_handshake_work or

	 * clear_peer_work) no longer are in use.

	/* After the above flushes, a peer might still be active in a few

	 * different contexts: 1) from xmit(), before hitting is_dead and

	 * returning, 2) from wg_packet_consume_data(), before hitting is_dead

	 * and returning, 3) from wg_receive_handshake_packet() after a point

	 * where it has processed an incoming handshake packet, but where

	 * all calls to pass it off to timers fails because of is_dead. We won't

	 * have new references in (1) eventually, because we're removed from

	 * allowedips; we won't have new references in (2) eventually, because

	 * wg_index_hashtable_lookup will always return NULL, since we removed

	 * all existing keypairs and no more can be created; we won't have new

	 * references in (3) eventually, because we're removed from the pubkey

	 * hash table, which allows for a maximum of one handshake response,

	 * via the still-uncleared index hashtable entry, but not more than one,

	 * and in wg_cookie_message_consume, the lookup eventually gets a peer

	 * with a refcount of zero, so no new reference is taken.

/* We have a separate "remove" function make sure that all active places where

 * a peer is currently operating will eventually come to an end and not pass

 * their reference onto another context.

 Avoid having to traverse individually for each one. */

	/* The final zeroing takes care of clearing any remaining handshake key

	 * material and other potentially sensitive information.

	/* Remove ourself from dynamic runtime lookup structures, now that the

	 * last reference is gone.

	/* Remove any lingering packets that didn't have a chance to be

	 * transmitted.

 Free the memory used. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

/*

 * - Timer for retransmitting the handshake if we don't hear back after

 * `REKEY_TIMEOUT + jitter` ms.

 *

 * - Timer for sending empty packet if we have received a packet but after have

 * not sent one for `KEEPALIVE_TIMEOUT` ms.

 *

 * - Timer for initiating new handshake if we have sent a packet but after have

 * not received one (even empty) for `(KEEPALIVE_TIMEOUT + REKEY_TIMEOUT) +

 * jitter` ms.

 *

 * - Timer for zeroing out all ephemeral keys after `(REJECT_AFTER_TIME * 3)` ms

 * if no new keys have been received.

 *

 * - Timer for, if enabled, sending an empty authenticated packet every user-

 * specified seconds.

		/* We drop all packets without a keypair and don't try again,

		 * if we try unsuccessfully for too long to make a handshake.

		/* We set a timer for destroying any residue that might be left

		 * of a partial exchange.

		/* We clear the endpoint address src address, in case this is

		 * the cause of trouble.

	/* We clear the endpoint address src address, in case this is the cause

	 * of trouble.

			/* If the work was already on the queue, we want to drop

			 * the extra reference.

 Should be called after an authenticated data packet is sent. */

 Should be called after an authenticated data packet is received. */

/* Should be called after any type of authenticated packet is sent, whether

 * keepalive, data, or handshake.

/* Should be called after any type of authenticated packet is received, whether

 * keepalive, data, or handshake.

 Should be called after a handshake initiation message is sent. */

/* Should be called after a handshake response message is received and processed

 * or when getting key confirmation via the first data message.

/* Should be called after an ephemeral key is created, which is before sending a

 * handshake response or after receiving a handshake response.

/* Should be called before a packet with authentication, whether

 * keepalive, data, or handshakem is sent, or after one is received.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

/* This implements Noise_IKpsk2:

 *

 * <- s

 * ******

 * -> e, es, s, ss, {t}

 * <- e, ee, se, psk, {}

 Must hold peer->handshake.static_identity->lock */

	/* We zero the next_keypair before zeroing the others, so that

	 * wg_noise_received_with_keypair returns early before subsequent ones

	 * are zeroed.

		/* If we're the initiator, it means we've sent a handshake, and

		 * received a confirmation response, which means this new

		 * keypair can now be used.

			/* If there already was a next keypair pending, we

			 * demote it to be the previous keypair, and free the

			 * existing current. Note that this means KCI can result

			 * in this transition. It would perhaps be more sound to

			 * always just get rid of the unused next keypair

			 * instead of putting it in the previous slot, but this

			 * might be a bit less robust. Something to think about

			 * for the future.

		} else /* If there wasn't an existing next keypair, we replace

			* the previous with the current one.

		/* At this point we can get rid of the old previous keypair, and

		 * set up the new keypair.

		/* If we're the responder, it means we can't use the new keypair

		 * until we receive confirmation via the first data packet, so

		 * we get rid of the existing previous one, the possibly

		 * existing next one, and slide in the new next one.

 We first check without taking the spinlock. */

	/* After locking, we double check that things didn't change from

	 * beneath us.

	/* When we've finally received the confirmation, we slide the next

	 * into the current, the current into the previous, and get rid of

	 * the old previous.

 Must hold static_identity->lock */

/* This is Hugo Krawczyk's HKDF:

 *  - https://eprint.iacr.org/2010/264.pdf

 *  - https://tools.ietf.org/html/rfc5869

 Extract entropy from data into secret */

 Expand first key: key = secret, data = 0x1 */

 Expand second key: key = secret, data = first-key || 0x2 */

 Expand third key: key = secret, data = second-key || 0x3 */

 Clear sensitive data from stack */

 Always zero for Noise_IK */, key);

 Always zero for Noise_IK */, key))

	/* In order to prevent some sort of infoleak from precise timers, we

	 * round down the nanoseconds part to the closest rounded-down power of

	 * two to the maximum initiations per second allowed anyway by the

	 * implementation.

cr.yp.to/libtai/tai64.html */

	/* We need to wait for crng _before_ taking any locks, since

	 * curve25519_generate_secret uses get_random_bytes_wait.

 e */

 es */

 s */

 ss */

 {t} */

 e */

 es */

 s */

 Lookup which peer we're actually talking to */

 ss */

 {t} */

 Success! Copy everything to peer */

	/* We need to wait for crng _before_ taking any locks, since

	 * curve25519_generate_secret uses get_random_bytes_wait.

 e */

 ee */

 se */

 psk */

 {} */

 e */

 ee */

 se */

 psk */

 {} */

 Success! Copy everything to peer */

	/* It's important to check that the state is still the same, while we

	 * have an exclusive lock.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

		/* At some point we might put this check near the ip_rt_send_

		 * redirect call of ip_forward in net/ipv4/ip_forward.c, similar

		 * to the current secpath check.

	/* If the machine is constantly suspending and resuming, as part of

	 * its normal operation rather than as a somewhat rare event, then we

	 * don't actually want to clear keys.

		/* We only need to keep the original dst around for icmp,

		 * so at this point we're in a position to drop it.

	/* If the queue is getting too big, we start removing the oldest packets

	 * until it's small again. We do this before adding the new packet, so

	 * we don't remove GSO segments that are in excess.

 The final references are cleared in the below calls to destroy_workqueue. */

 Wait for all the peers to be actually freed. */

 We need to keep the dst around in case of icmp replies. */

	/* We wait until the end to assign priv_destructor, so that

	 * register_netdevice doesn't call it for us if it fails.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

	/* If the last cursor was removed via list_del_init in peer_remove, then

	 * we just treat this the same as there being no more peers left. The

	 * reason is that seq_nr should indicate to userspace that this isn't a

	 * coherent dump anyway, so they'll try again.

	/* At this point, we can't really deal ourselves with safely zeroing out

	 * the private key material after usage. This will need an additional API

	 * in the kernel for marking skbs as zero_on_free.

 Peer doesn't exist yet. Add a new one. */

 The peer is new, so there aren't allowed IPs to remove. */

			/* We silently ignore peers that have the same public

			 * key as the device. The reason we do it silently is

			 * that we'd like for people to be able to reuse the

			 * same set of API calls across peers.

		/* Take additional reference, as though we've just been

		 * looked up.

		/* We remove before setting, to prevent race, which means doing

		 * two 25519-genpub ops.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

 TODO: addr->sin6_flowinfo */

	/* No other possibilities if the endpoint is valid, which it is,

	 * as we checked above.

	/* First we check unlocked, in order to optimize, since it's pretty rare

	 * that an endpoint will change. If we happen to be mid-write, and two

	 * CPUs wind up writing the same thing or something slightly different,

	 * it doesn't really matter much either.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

  1 */ T(0, true);

  2 */ T(1, true);

  3 */ T(1, false);

  4 */ T(9, true);

  5 */ T(8, true);

  6 */ T(7, true);

  7 */ T(7, false);

  8 */ T(T_LIM, true);

  9 */ T(T_LIM - 1, true);

 10 */ T(T_LIM - 1, false);

 11 */ T(T_LIM - 2, true);

 12 */ T(2, true);

 13 */ T(2, false);

 14 */ T(T_LIM + 16, true);

 15 */ T(3, false);

 16 */ T(T_LIM + 16, false);

 17 */ T(T_LIM * 4, true);

 18 */ T(T_LIM * 4 - (T_LIM - 1), true);

 19 */ T(10, false);

 20 */ T(T_LIM * 4 - T_LIM, false);

 21 */ T(T_LIM * 4 - (T_LIM + 1), false);

 22 */ T(T_LIM * 4 - (T_LIM - 2), true);

 23 */ T(T_LIM * 4 + 1 - T_LIM, false);

 24 */ T(0, false);

 25 */ T(REJECT_AFTER_MESSAGES, false);

 26 */ T(REJECT_AFTER_MESSAGES - 1, true);

 27 */ T(REJECT_AFTER_MESSAGES, false);

 28 */ T(REJECT_AFTER_MESSAGES - 1, false);

 29 */ T(REJECT_AFTER_MESSAGES - 2, true);

 30 */ T(REJECT_AFTER_MESSAGES + 1, false);

 31 */ T(REJECT_AFTER_MESSAGES + 2, false);

 32 */ T(REJECT_AFTER_MESSAGES - 2, false);

 33 */ T(REJECT_AFTER_MESSAGES - 3, true);

 34 */ T(0, false);

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

 *

 * This contains some basic static unit tests for the allowedips data structure.

 * It also has two additional modes that are disabled and meant to be used by

 * folks directly playing with this file. If you define the macro

 * DEBUG_PRINT_TRIE_GRAPHVIZ to be 1, then every time there's a full tree in

 * memory, it will be printed out as KERN_DEBUG in a format that can be passed

 * to graphviz (the dot command) to visualize it. If you define the macro

 * DEBUG_RANDOM_TRIE to be 1, then there will be an extremely costly set of

 * randomized tests done against a trivial implementation, which may take

 * upwards of a half-hour to complete. There's no set of users who should be

 * enabling these, and the only developers that should go anywhere near these

 * nobs are the ones who are reading this comment.

 replaces previous entry, and maskself is required */

 replaces previous entry */

 maskself is required */

 maskself is required */

	/* These will hit the WARN_ON(len >= 128) in free_node if something

	 * goes wrong.

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (C) 2015-2019 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.

 Uninit one extra time to check underflow detection. */

 SPDX-License-Identifier: GPL-2.0

/*

 * Lantiq / Intel PMAC driver for XRX200 SoCs

 *

 * Copyright (C) 2010 Lantiq Deutschland

 * Copyright (C) 2012 John Crispin <john@phrozen.org>

 * Copyright (C) 2017 - 2018 Hauke Mehrtens <hauke@hauke-m.de>

 DMA */

 cpu port mac */

 Add Ethernet header to packets from DMA to PMAC */

 Add VLAN tag to Packets from DMA to PMAC */

 Add CRC to packets from DMA to PMAC */

 Add status header to packets from PMAC to DMA */

 Remove CRC from packets from PMAC to DMA */

 Remove Layer-2 header from packets from PMAC to DMA */

 Status header is present from DMA to PMAC */

 Add special tag from PMAC to switch */

 Remove specail Tag from PMAC to DMA */

 Check CRC from DMA to PMAC */

 Enable reaction to Pause frames in the PMAC */

 drop all the packets from the DMA ring */

	/* The boot loader does not always deactivate the receiving of frames

	 * on the ports and then some packets queue up in the PPE buffers.

	 * They already passed the PMAC so they do not have the tags

	 * configured here. Read the these packets here and drop them.

	 * The HW should have written them into memory after 10us

 Make sure the address is written before we give it to HW */

 dma needs to start on a burst length value aligned address */

 Make sure the address is written before we give it to HW */

 free the allocated RX ring */

 free the allocated RX ring */

 alloc the network device */

 load the memory ranges */

 get the clock */

 bring up the dma engine and IP core */

 enable clock gate */

 set IPG to 12 */

 enable status header, enable CRC */

 setup NAPI */

 free stack related instances */

 remove the actual device */

 release the clock */

 shut down hardware */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Dave DNET Ethernet Controller driver

 *

 * Copyright (C) 2008 Dave S.r.l. <www.dave.eu>

 * Copyright (C) 2009 Ilya Yanok, Emcraft Systems Ltd, <yanok@emcraft.com>

 function for reading internal MAC register */

 issue a read */

	/* since a read/write op to the MAC is very slow,

 read data read from the MAC register */

 all done */

 function for writing internal MAC register */

 load data to write */

 issue a write */

	/* since a read/write op to the MAC is very slow,

	/*

	 * from MAC docs:

	 * "Note that the MAC address is stored in the registers in Hexadecimal

	 * form. For example, to set the MAC Address to: AC-DE-48-00-00-80

	 * would require writing 0xAC (octet 0) to address 0x0B (high byte of

	 * Mac_addr[15:0]), 0xDE (octet 1) to address 0x0A (Low byte of

	 * Mac_addr[15:0]), 0x48 (octet 2) to address 0x0D (high byte of

	 * Mac_addr[15:0]), 0x00 (octet 3) to address 0x0C (Low byte of

	 * Mac_addr[15:0]), 0x00 (octet 4) to address 0x0F (high byte of

	 * Mac_addr[15:0]), and 0x80 (octet 5) to address * 0x0E (Low byte of

	 * Mac_addr[15:0]).

 only 5 bits allowed for phy-addr and reg_offset */

 prepare reg_value for a read */

 write control word */

 wait for end of transfer */

 prepare for a write operation */

 only 5 bits allowed for phy-addr and reg_offset */

 only 16 bits on data */

 prepare reg_value for a write */

 write data to write first */

 write control word */

 find the first phy */

 TODO : add pin_irq */

 attach the mac to the phy */

 mask with MAC supported features */

 For Neptune board: LINK1000 as Link LED and TX as activity LED */

		/*

		 * break out of while loop if there are no more

		 * packets waiting

 Align IP on 16 byte boundaries */

			/*

			 * 'skb_put()' points to the start of sk_buff

			 * data area.

		/* We processed all packets available.  Tell NAPI it can

		 * stop polling then re-enable rx interrupts.

 read and clear the DNET irq (clear on read) */

 restart the queue if we had stopped it for TX fifo almost full */

 RX FIFO error checking */

 we can only flush the RX FIFOs */

 TX FIFO error checking */

 we can only flush the TX FIFOs */

			/*

			 * There's no point taking any more interrupts

			 * until we have processed the buffers

 Disable Rx interrupts and schedule NAPI poll */

 check if there is enough room for the current frame */

		/*

		 * inform MAC that a packet's written and ready to be

		 * shipped out

 free the buffer */

 put ts_mac in IDLE state i.e. disable rx/tx */

	/*

	 * RX FIFO almost full threshold: only cmd FIFO almost full is

	 * implemented for RX side

	/*

	 * TX FIFO almost empty threshold: only data FIFO almost empty

	 * is implemented for TX side

 flush rx/tx fifos */

 Copy All Frames */

 No BroadCast */

 clear irq before enabling them */

 enable RX/TX interrupt, recv packet ready interrupt */

 if the phy is not yet register, retry later */

 schedule a link state check */

 read stats from hardware */

 Convert HW stats into netdevice stats */

			    /* ignore IGP violation error

 TODO: Actually, we have some interesting features... */

 choose a random ethernet address */

 register the PHY board fixup (for Marvell 88E1111) */

 we can live without it, so just issue a warning */

/*

	Written 1998-2000 by Donald Becker.



	This software may be used and distributed according to the terms of

	the GNU General Public License (GPL), incorporated herein by reference.

	Drivers based on or derived from this code fall under the GPL and must

	retain the authorship, copyright and license notice.  This file is not

	a complete program and may only be used when the entire operating

	system is licensed under the GPL.



	The author may be reached as becker@scyld.com, or C/O

	Scyld Computing Corporation

	410 Severn Ave., Suite 210

	Annapolis MD 21403



	Support information and updates available at

	http://www.scyld.com/network/pci-skeleton.html



	Linux kernel updates:



	Version 2.51, Nov 17, 2001 (jgarzik):

	- Add ethtool support

	- Replace some MII-related magic numbers with constants



 1-> print debug message */

 Maximum number of multicast addresses to filter (vs. Rx-all-multicast). */

 Set the copy breakpoint for the copy-only-tiny-frames scheme. */

 Setting to > 1518 effectively disables this feature.          */

 Used to pass the media type, etc.                            */

 Both 'options[]' and 'full_duplex[]' should exist for driver */

 interoperability.                                            */

 The media type is usually passed in 'options[]'.             */

 More are supported, limit only on options */

 Operational parameters that are set at compile time.                 */

 Keep the ring sizes a power of two for compile efficiency.           */

 The compiler will convert <unsigned>'%'<2^N> into a bit mask.        */

 Making the Tx ring too large decreases the effectiveness of channel  */

 bonding and packet priority.                                         */

 There are no ill effects from too-large receive rings.               */

 88-12-9 modify,

 #define TX_RING_SIZE    16

 #define RX_RING_SIZE    32

 Operational parameters that usually are not changed. */

 Time in jiffies before concluding the transmitter is hung. */

 Size of each temporary Rx buffer. */

 Include files, designed to support most kernel versions 2.0.0 and later. */

 Processor type for cache alignment. */

/* This driver was written to use PCI memory space, however some x86 systems

 Kernel compatibility defines, some common to David Hinds' PCMCIA package. */

 This is only in the support-all-kernels source code. */

 A chip capabilities table, matching the entries in pci_tbl[] above. */

 89/6/13 add, */

 for different PHY */

 Offsets to the Command and Status Registers. */

 physical address 0-3 */

 physical address 4-5 */

 multicast address 0-3 */

 multicast address 4-7 */

 flow-control address 0-3 */

 flow-control address 4-5 */

 receive & transmit configuration */

 bus command */

 transmit polling demand */

 receive polling demand */

 receive current word pointer */

 transmit list base address */

 receive list base address */

 interrupt status */

 interrupt mask */

 flow control high/low threshold */

 bootrom/eeprom and mii management */

 tally counters for crc and mpa */

 tally counter for transmit status */

 basic mode control and status */

 phy identifier */

	ANARANLPAR = 0x54,	/* auto-negotiation advertisement and link

 auto-negotiation expansion and pci conf. */

 bypass & receive error mask and phy status */

 Bits in the interrupt status/enable registers. */

 The bits in the Intr Status/Enable registers, mostly interrupt sources. */

 receive flow control xon packet */

 receive flow control xoff packet */

 link status change */

 autonegotiation completed */

 fatal bus error */

 mask bit12-11 */

 parity error */

 target abort */

 master error */

 transmit underflow */

 receive overflow */

 transmit early int */

 receive early int */

 counter overflow */

 receive buffer unavailable */

 transmit buffer unavilable */

 transmit interrupt */

 receive interrupt */

 receive error */

 Bits in the NetworkConfig register, W for writing, R for reading */

 FIXME: some names are invented by me. Marked with (name?) */

 If you have docs and know bit names, please fix 'em */

 enhanced mode (name?) */

 full duplex */

 10 mbit */

 tx enable (name?) */

 1000 mbit */

 CR_W_RXBURSTMASK= 0x00000e00, Im unsure about this */

 promiscuous mode */

 accept broadcast */

 accept mutlicast */

 receive runt pkt */

 receive long pkt */

 receive error pkt */

 rx enable (unicast?) (name?) */

 tx stopped (name?) */

 full duplex detected */

 10 mbit detected */

 rx stopped (name?) */

 The Tulip Rx and Tx buffer descriptors. */

 Bits in network_desc.status */

 own bit */

 frame length */

 multicast address received */

 broadcast address received */

 physical address received */

 first descriptor */

 last descriptor */

 error summary */

 runt packet received */

 long packet received */

 frame align error */

 crc error */

 receive error */

 interrupt control */

 own bit */

 jabber timeout */

 carrier sense lost */

 late collision */

 excessive collision */

 fifo underflow */

 deferred */

 heartbeat fail */

 collision retry count */

 interrupt control */

 early transmit interrupt */

 last descriptor */

 first descriptor */

 crc control */

 padding control */

 retry late collision */

 packet size bit21-11 */

 transmit buffer bit 10-0 */

 BootROM/EEPROM/MII Management Register */

 ST+OP+PHYAD+REGAD+TA */

 ST:01+OP:10+PHYAD+REGAD+TA:Z0 */

 ST:01+OP:01+PHYAD+REGAD+TA:10 */

 ------------------------------------------------------------------------- */

      Constants for Myson PHY                                              */

 ------------------------------------------------------------------------- */

 89-7-27 add, (begin) */

 bit10

 bit11

 89-7-27 add, (end) */

 ------------------------------------------------------------------------- */

      Constants for Seeq 80225 PHY                                         */

 ------------------------------------------------------------------------- */

 ------------------------------------------------------------------------- */

      Constants for Ahdoc 101 PHY                                          */

 ------------------------------------------------------------------------- */

 89/6/13 add, */

 -------------------------------------------------------------------------- */

      Constants                                                             */

 -------------------------------------------------------------------------- */

 for 1000BaseT Control Register */

 for phy specific status register, marvell phy.

 89/12/29 add, for phy specific status register, levelone phy, (begin)

 89/12/29 add, for phy specific status register, levelone phy, (end)

 for 3-in-1 case, BMCRSR register */

 for PHY */

 Descriptor rings first for alignment. */

 Media monitoring timer. */

 Reset timer */

 Frequently used values: keep some adjacent for cache effect. */

 Based on MTU+slack. */

 These values are keep track of the transceiver/media in use. */

 Last dev->if_port value. */

 MII transceiver section. */

 MII device addresses. */

 MII device addresses. */

 read ethernet id */

 Reset the chip to erase previous misconfiguration. */

 Make certain the descriptor lists are aligned. */

 find the connected MII xcvrs */

 get phy type */

 89/6/23 add, (begin) */

 get phy type */

 The lower four bits are the media type. */

 89/6/13 add, (begin) */

      if (np->PHYType==MarvellPHY)

 89/6/13 add, (end) */

 enable MII output */

 send 32 1's preamble */

 low MDC; MDO is already high (miir) */

 high MDC */

 calculate ST+OP+PHYAD+REGAD+TA */

 sent out */

 low MDC, prepare MDO */

 high MDC */

 next */

 read data */

 low MDC */

 read MDI */

 high MDC, and wait */

 next */

 low MDC */

 write data */

 low MDC, prepare MDO */

 high MDC */

 next */

 low MDC */

 Reset */

 Initialize other registers. */

	/* Configure the PCI bus bursts and FIFO thresholds.

	   486: Set 8 longword burst.

	   586: no burst limit.

	   Burst length 5:3

	   0 0 0   1

	   0 0 1   4

	   0 1 0   8

	   0 1 1   16

	   1 0 0   32

	   1 0 1   64

	   1 1 0   128

	   1 1 1   256

	   Wait the specified 50 PCI cycles after a reset by initializing

	   Tx and Rx queues and the address filter list.

 little-endian, 8 burst length */

 big-endian */

 rx 128 burst length */

 89/12/29 add,

 90/1/16 modify,

   np->imrvalue=FBE|TUNF|CNTOVF|RBU|TI|RI;

 set PROG bit */

 set enhanced bit */

 89/9/1 modify,

   np->crvalue = 0x00e40001;    /* tx store and forward, tx/rx enable */

 tx store and forward, tx/rx enable */

 Clear and Enable interrupts by setting the interrupt mask. */

 Set the timer to check for link beat. */

 timer handler */

 function: Routine will read MII Status Register to get link status.       */

 input   : dev... pointer to the adapter block.                            */

 output  : none.                                                           */

 3-in-1 case */

 full duplex */

 half duplex */

 10M */

 100M */

 this PHY is SEEQ 80225 */

 100M */

 10M */

 full duplex mode */

 half duplex mode */

 100M */

 10M */

 full duplex mode */

 half duplex mode */

 89/6/13 add, (begin) */

 full duplex mode */

 half duplex mode */

 1000M */

 100M */

 10M */

 89/6/13 add, (end) */

 89/7/27 add, (begin) */

 89/7/27 add, (end) */

 89/12/29 add */

 full duplex mode */

 half duplex mode */

 1000M */

 100M */

 10M */

 Take lock before calling this */

  allocate skb for rx buffers */

 Better luck next round. */

 we need to detect the media type again */

 Take lock before calling */

 Reset chip and disable rx, tx and interrupts */

 Reset the chip's Tx and Rx processes. */

 Disable interrupts by clearing the interrupt mask. */

 Reset the chip to erase previous misconfiguration. */

	/* Ueimor: wait for 50 PCI cycles (and flush posted writes btw).

 Take lock before calling */

 Restore chip after reset */

 changes np->crvalue, writes it into TCRRCR */

 Clear and Enable interrupts by setting the interrupt mask. */

	/* works for me without this:

 FIXME: or netif_wake_queue(dev); ? */

 prevent tx timeout */

 or .._start_.. ?? */

 Initialize the Rx and Tx rings, along with various 'dev' bits. */

 initialize rx variables */

 initial rx descriptors. */

 for the last rx descriptor */

 allocate skb for rx buffers */

 initialize tx variables */

 do we need np->tx_ring[i].control = XXX; ?? */

 for the last tx descriptor */

 pkt size */

 buffer size */

 89/12/29 add,

 for the first descriptor */

 pkt size */

 buffer size */

 for the last descriptor */

 pkt size */

 buf size */

 89/12/29 add,

 pkt size */

 buffer size */

 89/12/29 add,

 Take lock before calling */

 Chip probably hosed tx ring. Clean up. */

 initialize tx variables */

 needed? */

 probably not needed. We do it for purely paranoid reasons */

 for the last tx descriptor */

 Take lock and stop rx before calling this */

/* The interrupt handler does all of the Rx thread work and cleans up

 Acknowledge all of the current interrupt sources ASAP. */

 90/1/16 delete,



      if (intr_status & FBE)

      {   /* fatal error */

          stop_nic_tx(ioaddr, 0);

          stop_nic_rx(ioaddr, 0);

          break;

      };

 missed pkts */

 crc error */

 this pkt is combined by two tx descriptors */

 Free the original skb. */

 end of for loop */

 read transmit status for enhanced mode only */

 or netif_tx_disable(dev); ?? */

 Prevent other paths from enabling tx,rx,intrs */

 or simply = 0? */

 read the tally counters */

 missed pkts */

 crc error */

/* This routine is logically part of the interrupt handler, but separated

 If EOP is set on the next entry, it's a new packet. Send it up. */

 there was a fatal error */

 end of a packet. */

 this pkt is too long, over one rx buffer */

 check this packet is received completely? */

 goto next rx descriptor */

 RXLSD did not find, something error */

 free all rx descriptors related this long pkt */

 rx error, need to reset this chip */

 exit the while loop */

 this received pkt is ok */

 Omit the four octet CRC from the length. */

			/* Check if the packet is long enough to accept without copying

 16 byte align the IP header */

 Call copy + cksum if available. */

 end of while loop */

  allocate skb for rx buffers */

 The chip only need report frame silently dropped. */

 for dev->set_multicast_list */

 Take lock before calling */

 Multicast hash filter */

 Set promiscuous. */

 Too many to match, or accept all multicasts. */

 Disable interrupts by clearing the interrupt mask. */

 Stop the chip's Tx and Rx processes. */

 Free all the skbuffs in the Rx queue. */

 terminate list */

 SPDX-License-Identifier: GPL-2.0-only

 /*

 * drivers/net/ethernet/ec_bhf.c

 *

 * Copyright (C) 2014 Darek Marcinkiewicz <reksio@newterm.pl>

/* This is a driver for EtherCAT master module present on CCAT FPGA.

 * Those can be found on Bechhoff CX50xx industrial PCs.

 Make sure that we perceive changes to tx_dnext. */

		/* Make sure that updates to tx_dnext are perceived

		 * by timer routine.

	/* We want to allocate a chunk of memory that is:

	 * - aligned to the mask we just read

	 * - is of size 2^mask bytes (at most)

	 * In order to ensure that we will allocate buffer of

	 * 2 * 2^mask bytes.

/*

 *  Driver for the IDT RC32434 (Korina) on-chip ethernet controller.

 *

 *  Copyright 2004 IDT Inc. (rischelp@idt.com)

 *  Copyright 2006 Felix Fietkau <nbd@openwrt.org>

 *  Copyright 2008 Florian Fainelli <florian@openwrt.org>

 *  Copyright 2017 Roman Yeryomin <roman@advem.lv>

 *

 *  This program is free software; you can redistribute  it and/or modify it

 *  under  the terms of  the GNU General  Public License as published by the

 *  Free Software Foundation;  either version 2 of the  License, or (at your

 *  option) any later version.

 *

 *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED

 *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF

 *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN

 *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,

 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT

 *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF

 *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON

 *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT

 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF

 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 *

 *  You should have received a copy of the  GNU General Public License along

 *  with this program; if not, write  to the Free Software Foundation, Inc.,

 *  675 Mass Ave, Cambridge, MA 02139, USA.

 *

 *  Writing to a DMA status register:

 *

 *  When writing to the status register, you should mask the bit you have

 *  been testing the status register with. Both Tx and Rx DMA registers

 *  should stick to this procedure.

 Reserved. */

 Reserved. */

 Reserved. */

 Reserved. */

 Reserved. */

 Reserved. */

 Reserved. */

 Ethernet interrupt registers */

 Ethernet FIFO registers */

 Ethernet ARC/multicast registers */

 Ethernet SAL registers */

 Ethernet SAH registers */

 Ethernet GPF register */

 Ethernet PFG register */

 Ethernet CFSA[0-3] registers */

 Ethernet MAC1 registers */

 Ethernet MAC2 registers */

 Ethernet IPGT register */

 Ethernet IPGR registers */

 Ethernet CLRT registers */

 Ethernet MAXF register */

 Ethernet test registers */

 MII registers */

 Values for the DEVCS field of the Ethernet DMA Rx and Tx descriptors. */

 DMA descriptor (in physical memory). */

 Control. use DMAD_* */

 Current Address. */

 Device control and status. */

 Next descriptor in chain. */

 DMA descriptors interrupts */

 Chain on finished */

 Chain on done */

 Interrupt on finished */

 Interrupt on done */

 Terminated */

 Done */

 Finished */

 DMA register (within Internal Register Map).  */

 Control. */

 Status. */

 Mask. */

 Descriptor pointer. */

 Next descriptor pointer. */

 DMA channels specific registers */

 DMA status registers */

 no more than 2.5MHz */

 the following must be powers of two */

 number of receive descriptors */

 number of transmit descriptors */

/* KORINA_RBSIZE is the hardware's default maximum receive

 * frame size in bytes. Having this hardcoded means that there

 size of one resource buffer = Ether MTU */

 Information that need to be kept for each board. */

 transmit descriptor ring */

 receive descriptor ring  */

 NIC xmit lock */

 transmit packet */

 stop queue when full, drop pkts if queue already full */

 Setup the transmit descriptor. */

 Update tail */

 Move tail */

 Write to NDPTR */

 Move head to tail */

 Update tail */

 Link to prev */

 Link to prev */

 Move tail */

 Write to NDPTR */

 Move head to tail */

 Update tail */

 Move tail */

 Update tail */

 Ethernet Rx DMA interrupt */

		/* check that this is a whole packet

		 * WARNING: DMA_FD bit incorrectly set

 Update statistics counters */

 Malloc up new buffer. */

 Do not count the CRC */

 Pass the packet to upper layers */

 Update the mcast stats */

 Restore descriptor's curr_addr */

/*

 * Set or clear the multicast filter for this adaptor.

 always accept broadcasts */

 Set promiscuous mode */

 All multicast and broadcast */

 Build the hash table */

 Accept filtered multicast */

 Fill the MAC hash tables with their values */

 Process all desc that are done */

 Should never happen */

 Underflow */

 Oversized frame */

 Excessive deferrals */

 Collisions: medium busy */

 Late collision */

 We must always free the original skb */

 Go on to next transmission */

 Clear the DMA status register */

 autoneg is off: Link is always assumed to be up */

 Let MMI library update carrier status */

 ethtool helpers */

 Initialize the transmit descriptors */

 Initialize the receive descriptors */

	/* loop back receive descriptors, so the last

/*

 * Initialize the RC32434 ethernet controller.

 Disable DMA */

 reset ethernet logic */

 Enable Ethernet Interface */

 Allocate rings */

 Start Rx DMA */

 Accept only packets destined for this Ethernet device address */

 Set all Ether station address registers to their initial values */

 Frame Length Checking, Pad Enable, CRC Enable, Full Duplex set */

 Back to back inter-packet-gap */

 Non - Back to back inter-packet-gap */

	/* Management Clock Prescaler Divisor

 don't transmit until fifo contains 48b */

/*

 * Restart the RC32434 ethernet controller.

	/*

	 * Disable interrupts

 Initialize */

	/* Install the interrupt handler

 Disable interrupts */

 max possible input clk */

 just use the rx dma irq */

 SPDX-License-Identifier: GPL-2.0-only

/*

 *

 *   Copyright (C) 2011 John Crispin <blogic@openwrt.org>

 use 2 static channels for TX/RX */

 enable crc generation */

 nothing to do  */

 dma needs to start on a burst length value aligned address */

 store the mac for the unicast filter */

 ensure that the unicast filter is not enabled in promiscious mode */

 Set addr_assign_type here, ltq_etop_set_mac_address would reset it. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * JMicron JMC2x0 series PCIe Ethernet Linux Device Driver

 *

 * Copyright 2008 JMicron Technology Corporation

 * https://www.jmicron.com/

 * Copyright (c) 2009 - 2010 Guo-Fu Tseng <cooldavid@cooldavid.org>

 *

 * Author: Guo-Fu Tseng <cooldavid@cooldavid.org>

	/*

	 * Setup CRC pattern

	/*

	 * Setup Mask

	/*

	 * Enable Interrupts

	/*

	 * Disable Interrupts

			/*

			 * If we did not enable AN

			 * Speed/Duplex Info should be obtained from SMI

			/*

			 * Keep polling for speed/duplex resolve complete

		/*

		 * The speed/duplex setting of jme->reg_ghc already cleared

		 * by jme_reset_mac_processor()

	/*

	 * 16 Bytes align

	/*

	 * Select Queue 0

	/*

	 * Setup TX Queue 0 DMA Bass Address

	/*

	 * Setup TX Descptor Count

	/*

	 * Enable TX Engine

	/*

	 * Start clock for TX MAC Processor

	/*

	 * Disable TX Engine

	/*

	 * Stop clock for TX MAC Processor

	/*

	 * 16 Bytes align

	/*

	 * Initiallize Receive Descriptors

	/*

	 * Select Queue 0

	/*

	 * Setup RX DMA Bass Address

	/*

	 * Setup RX Descriptor Count

	/*

	 * Setup Unicast Filter

	/*

	 * Enable RX Engine

	/*

	 * Start clock for RX MAC Processor

	/*

	 * Start RX Engine

	/*

	 * Disable RX Engine

	/*

	 * Stop clock for RX MAC Processor

		/*

		 * Disable all interrupt before issue timer

	/*

	 * Disable interrupt

		/*

		 * Link change event is critical

		 * all other events are ignored

	/*

	 * Re-enable interrupt

	/*

	 * Check if it's really an interrupt for us

	/*

	 * Check if the device still exist

  Enabel PHY test mode 1 */

  Disable PHY test mode */

 2000ms */

	/*

	 * Set OWN bit at final.

	 * When kernel transmit faster than NIC.

	 * And NIC trying to send this descriptor before we tell

	 * it to start sending this TX queue.

	 * Other fields are already filled correctly.

	/*

	 * Set checksum flags while not tso

	/*

	 * Set tx buffer info after telling NIC to send

	 * For better tx_clean timing

/*

 * This function is already protected by netif_tx_lock()

	/*

	 * Force to Reset the link again

	/*

	 * Check If user changed duplex only while force_media.

	 * Hardware would not generate link change interrupt.

	/*

	 * ethtool will check the boundary for us

	/*

	 * ethtool will check the boundary for us

	/*

	 * set up PCI device basics

	/*

	 * alloc and init net device

 MTU range: 1280 - 9202*/

	/*

	 * init adapter info

	/*

	 * Get Max Read Req Size from PCI Config Space

	/*

	 * Must check before reset_mac_processor

	/*

	 * Reset MAC processor and reload EEPROM for MAC Address

	/*

	 * Tell stack that we are not ready to work until open()

 SPDX-License-Identifier: GPL-2.0-only

/*

 * linux/drivers/net/ethernet/ethoc.c

 *

 * Copyright (C) 2007-2008 Avionic Design Development GmbH

 * Copyright (C) 2008-2009 Avionic Design GmbH

 *

 * Written by Thierry Reding <thierry.reding@avionic-design.de>

 32 KBytes */

 register offsets */

 mode register */

 receive enable */

 transmit enable */

 no preamble */

 broadcast address */

 individual address mode */

 promiscuous mode */

 interframe gap for incoming frames */

 loopback */

 no back-off */

 excess defer enable */

 full duplex */

 FIXME: reset (undocumented) */

 delayed CRC enable */

 CRC enable */

 huge packets enable */

 padding enabled */

 receive small packets */

 interrupt source and mask registers */

 transmit frame */

 transmit error */

 receive frame */

 receive error */

 transmit control frame */

 receive control frame */

 packet length register */

 transmit buffer number register */

 control module mode register */

 pass all receive frames */

 receive control flow */

 transmit control flow */

 MII mode register */

 needs to be an even number */

 no preamble */

 MII command register */

 scan status */

 read status */

 write control data */

 MII address register */

 MII transmit data register */

 MII receive data register */

 MII status register */

 TX buffer descriptor */

 carrier sense lost */

 defer indication */

 late collision */

 retransmission limit */

 transmitter underrun */

 TX CRC enable */

 pad enable for short packets */

 interrupt request enable */

 TX buffer ready */

 RX buffer descriptor */

 late collision */

 RX CRC error */

 short frame */

 too long */

 dribble nibble */

 invalid symbol */

 receiver overrun */

 control frame */

 interrupt request enable */

/**

 * struct ethoc - driver-private device structure

 * @iobase:	pointer to I/O memory region

 * @membase:	pointer to buffer memory region

 * @big_endian: just big or little (endian)

 * @num_bd:	number of buffer descriptors

 * @num_tx:	number of send buffers

 * @cur_tx:	last send buffer written

 * @dty_tx:	last buffer actually sent

 * @num_rx:	number of receive buffers

 * @cur_rx:	current receive buffer

 * @vma:        pointer to array of virtual memory addresses for buffers

 * @netdev:	pointer to network device structure

 * @napi:	NAPI structure

 * @msg_enable:	device state flags

 * @lock:	device lock

 * @mdio:	MDIO bus for PHY access

 * @clk:	clock

 * @phy_id:	address of attached PHY

 * @old_link:	previous link info

 * @old_duplex: previous duplex info

/**

 * struct ethoc_bd - buffer descriptor

 * @stat:	buffer statistics

 * @addr:	physical memory address

 setup transmission buffers */

 TODO: reset controller? */

 TODO: setup registers */

 enable FCS generation and automatic padding */

 set full-duplex mode */

			/* If packet (interrupt) came in between checking

			 * BD_EMTPY and clearing the interrupt source, then we

			 * risk missing the packet as the RX interrupt won't

			 * trigger right away when we reenable it; hence, check

			 * BD_EMTPY here again to make sure there isn't such a

			 * packet waiting for us...

 strip the CRC */

 clear the buffer descriptor so it can be reused */

			/* If interrupt came in between reading in the BD

			 * and clearing the interrupt source, then we risk

			 * missing the event as the TX interrupt won't trigger

			 * right away when we reenable it; hence, check

			 * BD_EMPTY here again to make sure there isn't such an

			 * event pending...

	/* Figure out what triggered the interrupt...

	 * The tricky bit here is that the interrupt source bits get

	 * set in INT_SOURCE for an event regardless of whether that

	 * event is masked or not.  Thus, in order to figure out what

	 * triggered the interrupt, we need to remove the sources

	 * for all events that are currently masked.  This behaviour

	 * is not particularly well documented but reasonable...

 We always handle the dropped packet interrupt */

 Handle receive/transmit event by switching to polling */

 reset MII command register */

 reset MII command register */

 set loopback mode if requested */

 receive broadcast frames if requested */

 enable promiscuous mode if requested */

 receive multicast frames */

/**

 * ethoc_probe - initialize OpenCores ethernet MAC

 * @pdev:	platform device

 allocate networking device */

 obtain I/O memory space */

 obtain buffer memory space */

 obtain device IRQ number */

 setup driver-private data */

 Allocate buffer memory */

 calculate the number of TX/RX buffers, maximum 128 supported */

 num_tx must be a power of two */

 Allow the platform setup code to pass in a MAC address. */

	/* Check that the given MAC address is valid. If it isn't, read the

	 * current MAC from the controller.

	/* Check the MAC again for validity, if it still isn't choose and

	 * program a random one.

 Allow the platform setup code to adjust MII management bus clock. */

 register MII bus */

 setup the net_device structure */

 setup NAPI */

/**

 * ethoc_remove - shutdown OpenCores ethernet MAC

 * @pdev:	platform device

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * PXA168 ethernet driver.

 * Most of the code is derived from mv643xx ethernet driver.

 *

 * Copyright (C) 2010 Marvell International Ltd.

 *		Sachin Sanap <ssanap@marvell.com>

 *		Zhangfei Gao <zgao6@marvell.com>

 *		Philip Rakity <prakity@marvell.com>

 *		Mark Brown <markb@marvell.com>

/*

 * Registers

 smi register */

 0 - Write, 1 - Read  */

 0 - Write, 1 - Read  */

 Write operation      */

 Read operation */

 RX & TX descriptor command */

 RX descriptor status */

 TX descriptor command */

 SDMA_CMD */

 Bit definitions of the Port Config Reg */

 Bit definitions of the Port Config Extend Reg */

 Bit definitions of the SDMA Config Reg */

/*

 * Bit definitions of the Interrupt Cause Reg

 * and Interrupt MASK Reg is the same

 hw aligns IP header */

 16K (1/2K address - PCR_HS == 1) */

 Bit definitions for Port status */

 Bit definitions for work to be done */

/*

 * Misc definitions.

 Descriptor command status            */

 Descriptor buffer byte count         */

 Buffer size                          */

 Descriptor buffer pointer            */

 Next descriptor pointer              */

 Command/status field                 */

 buffer byte count                    */

 pointer to buffer for this descriptor */

 Pointer to next descriptor           */

 User Ethernet port number    */

 Rx ring resource error flag */

 Next available and first returning Rx resource */

 Next available and first returning Tx resource */

 Size of Tx Ring per queue */

 Number of tx descriptors in use */

 Size of Rx Ring per queue */

 Number of rx descriptors in use */

	/*

	 * Used in case RX Ring is empty, which can occur when

	 * system does not have resources (skb's)

 clock */

	/*

	 * Ethernet controller base address.

 Pointer to the hardware address filter table */

 Bit fields of a Hash Table Entry */

 Get 'used' Rx descriptor */

 Return the descriptor to DMA ownership */

 Move the used descriptor pointer to the next descriptor */

 Any Rx return cancels the Rx resource error status */

	/*

	 * If RX ring is empty of SKB, set a timer to try allocating

	 * again at a later time.

/*

 * ----------------------------------------------------------------------------

 * This function will calculate the hash function of the address.

 * Inputs

 * mac_addr_orig    - MAC address.

 * Outputs

 * return the calculated entry.

	/* Make a copy of MAC address since we are going to performe bit

	 * operations on it

/*

 * ----------------------------------------------------------------------------

 * This function will add/del an entry to the address table.

 * Inputs

 * pep - ETHERNET .

 * mac_addr - MAC address.

 * skip - if 1, skip this address.Used in case of deleting an entry which is a

 *	  part of chain in the hash table.We can't just delete the entry since

 *	  that will break the chain.We need to defragment the tables time to

 *	  time.

 * rd   - 0 Discard packet upon match.

 *	- 1 Receive packet upon match.

 * Outputs

 * address table entry is added/deleted.

 * 0 if success.

 * -ENOSPC if table full

	/*

	 * Pick the appropriate table, start scanning for free/reusable

	 * entries at the index obtained by hashing the specified MAC address

 if same address put in same position */

	/*

	 * Update the selected entry

/*

 * ----------------------------------------------------------------------------

 *  Create an addressTable entry from MAC address info

 *  found in the specifed net_device struct

 *

 *  Input : pointer to ethernet interface network device structure

 *  Output : N/A

 Delete old entry */

 Add new entry */

	/*

	 * Hardware expects CPU to build a hash table based on a predefined

	 * hash function and populate it based on hardware address. The

	 * location of the hash table is identified by 32-bit pointer stored

	 * in HTPR internal register. Two possible sizes exists for the hash

	 * table 8kB (256kB of DRAM required (4 x 64 kB banks)) and 1/2kB

	 * (16kB of DRAM required (4 x 4 kB banks)).We currently only support

	 * 1/2kB.

	/* TODO: Add support for 8kB hash table and alternative hash

	 * function.Driver can dynamically switch to them if the 1/2kB hash

	 * table is full.

	/*

	 * Remove the old list of MAC address and add dev->addr

	 * and multicast address.

 Assignment of Tx CTRP of given queue */

 Assignment of Rx CRDP of given queue */

 Clear all interrupts */

 Enable all interrupts for receive, transmit and error. */

 Start RX DMA engine */

 Stop all interrupts for receive, transmit and error. */

 Clear all interrupts */

 Stop RX DMA */

 abort dma command */

	/* Abort any transmit and receive operations and put DMA

	 * in idle state.

 Disable port */

/*

 * txq_reclaim - Free the tx desc data for completed descriptors

 * If force is non-zero, frees uncompleted descriptors as well

 Do not process Rx ring in case of Rx ring resource error */

 Rx descriptors exhausted. */

 Set the Rx ring resource error flag */

		/*

		 * Update statistics.

		 * Note byte count includes 4 byte CRC count

		/*

		 * In case received a packet without first / last bits on OR

		 * the error summary bit is on, the packets needs to be droped.

			/*

			 * The -4 is for the CRC in the trailer of the

			 * received packet

 Fill RX ring with skb's */

 Disable interrupts */

	/*

	 * Reserve 2+14 bytes for an ethernet header (the hardware

	 * automatically prepends 2 bytes of dummy data to each

	 * received packet), 16 bytes for up to four VLAN tags, and

	 * 4 bytes for the trailing FCS -- 36 bytes total.

	/*

	 * Make sure that the skb size is a multiple of 8 bytes, as

	 * the lower three bits of the receive descriptor's buffer

	 * size field are ignored by the hardware.

	/*

	 * If NET_SKB_PAD is smaller than a cache line,

	 * netdev_alloc_skb() will cause skb->data to be misaligned

	 * to a cache line boundary.  If this is the case, include

	 * some extra space to allow re-aligning the data area.

 Extended Port Configuration */

 Disable HW AN */

 Two byte prefix aligns IP hdr */

 Enable DSCP in IP */

 do not force link pass */

 Transmit - high priority queue */

 Bail out if there has nothing changed */

 Disable interrupts */

 Write to ICR to clear interrupts. */

	/* Abort any transmit and receive operations and put DMA

	 * in idle state.

 Initialize address hash table */

 SDMA configuration */

 Burst size = 32 bytes */

 Rx interrupt on frame */

 Little endian transmit */

 Little endian receive */

 Max retransmit count */

 Port Configuration */

 Hash size is 1/2kb */

 Allocate RX skb rings */

 Allocate RX ring */

 initialize the next_desc_ptr links in the Rx descriptors ring */

 Save Rx desc pointer to driver struct. */

 Free preallocated skb's on RX rings */

 Free RX ring */

 Allocate TX ring */

 Initialize the next_desc_ptr links in the Tx descriptors ring */

 Free outstanding skb's on TX ring */

 Free TX ring */

 Fill RX ring with skb's */

 Disable interrupts */

 Write to ICR to clear interrupts. */

	/*

	 * Stop and then re-open the interface. This will allocate RX

	 * skbs of the new MTU.

	 * There is a possible danger that the open will not succeed,

	 * due to memory being full.

	/*

	 * We call txq_reclaim every time since in NAPI interupts are disabled

	 * and due to this we miss the TX_DONE interrupt,which is not updated in

	 * interrupt status register.

 We handled the current skb, but now we are out of space.*/

 wait for the SMI register to become available */

 now wait for the data to be valid */

 MTU range: 68 - 9500 */

 try reading the mac address, if set by the bootloader */

 Hardware supports only 3 ports */

/*

 * Driver for Marvell NETA network card for Armada XP and Armada 370 SoCs.

 *

 * Copyright (C) 2012 Marvell

 *

 * Rami Rosen <rosenr@marvell.com>

 * Thomas Petazzoni <thomas.petazzoni@free-electrons.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 Registers */

 Only exists on Armada XP and Armada 370 */

/* Exception Interrupt Port/Queue Cause register

 *

 * Their behavior depend of the mapping done using the PCPX2Q

 * registers. For a given CPU if the bit associated to a queue is not

 * set, then for the register a read from this CPU will always return

 * 0 and a write won't do anything

/* bits  0..7  = TXQ SENT, one bit per queue.

 * bits  8..15 = RXQ OCCUP, one bit per queue.

 * bits 16..23 = RXQ FREE, one bit per queue.

 * bit  29 = OLD_REG_SUM, see old reg ?

 * bit  30 = TX_ERR_SUM, one bit for 4 ports

 * bit  31 = MISC_SUM,   one bit for 4 ports

 Data Path Port/Queue Cause Register */

 Descriptor ring Macros */

 Various constants */

 Coalescing */

 interrupt per packet */

/* The two bytes Marvell header. Either contains a special value used

 * by Marvell switches when a specific hardware mode is enabled (not

 * supported by this driver) or is filled automatically by zeroes on

 * the RX side. Those two bytes being at the front of the Ethernet

 * header, they allow to have the IP header aligned on a 4 bytes

 * boundary automatically: the hardware skips those two bytes on its

 * own.

 Timeout constants */

/* The RSS lookup table actually has 256 entries but we do not use

 * them yet

 Max number of Rx descriptors */

 Max number of Tx descriptors */

 Max number of allowed TCP segments for software TSO */

 descriptor aligned size */

/* Number of bytes to be taken into account by HW when putting incoming data

 * to the buffers. It is needed in case NET_SKB_PAD exceeds maximum packet

 * offset supported in MVNETA_RXQ_CONFIG_REG(q) registers.

 Driver assumes that the last 3 bits are 0 */

 xdp */

 Pointer to the shared port */

 Pointer to the CPU-local NAPI struct */

 Cause of the previous interrupt */

	/* Protect the access to the percpu interrupt registers,

	 * ensuring that the configuration remains coherent.

 Core clock */

 AXI clock */

 Flags for special SoC configurations */

/* The mvneta_tx_desc and mvneta_rx_desc structures describe the

 * layout of the transmit and reception DMA descriptors, and their

 * layout is therefore defined by the hardware design

 Options used by HW for packet transmitting.*/

 csum_l4 (for future use)		*/

 Data size of transmitted packet in bytes */

 Physical addr of transmitted buffer	*/

 hw_cmd - (for future use, PMT)	*/

 Reserved - (for future use)		*/

 Info about received packet		*/

 pnc_info - (for future use, PnC)	*/

 Size of received packet in bytes	*/

 Physical address of the buffer	*/

 pnc_flow_id  (for future use, PnC)	*/

 cookie for access to RX buffer in rx path */

 prefetch_cmd, for future use		*/

 csum_l4 - (for future use, PnC)	*/

 pnc_extra PnC (for future use, PnC)	*/

 hw_cmd (for future use, PnC and HWF)	*/

 Data size of transmitted packet in bytes */

 csum_l4 (for future use)		*/

 Options used by HW for packet transmitting.*/

 hw_cmd - (for future use, PMT)	*/

 Physical addr of transmitted buffer	*/

 Reserved - (for future use)		*/

 Size of received packet in bytes	*/

 pnc_info - (for future use, PnC)	*/

 Info about received packet		*/

 pnc_flow_id  (for future use, PnC)	*/

 Physical address of the buffer	*/

 csum_l4 - (for future use, PnC)	*/

 prefetch_cmd, for future use		*/

 cookie for access to RX buffer in rx path */

 pnc_extra PnC (for future use, PnC)	*/

 hw_cmd (for future use, PnC and HWF)	*/

 Number of this TX queue, in the range 0-7 */

 Number of TX DMA descriptors in the descriptor ring */

	/* Number of currently used TX DMA descriptor in the

	 * descriptor ring

 Array of transmitted buffers */

 Index of last TX DMA descriptor that was inserted */

 Index of the TX DMA descriptor to be cleaned up */

 Virtual address of the TX DMA descriptors array */

 DMA address of the TX DMA descriptors array */

 Index of the last TX DMA descriptor */

 Index of the next TX DMA descriptor to process */

 DMA buffers for TSO headers */

 DMA address of TSO headers */

 Affinity mask for CPUs*/

 rx queue number, in the range 0-7 */

 num of rx descriptors in the rx descriptor ring */

 page_pool */

 Virtual address of the RX buffer */

 Virtual address of the RX DMA descriptors array */

 DMA address of the RX DMA descriptors array */

 Index of the last RX DMA descriptor */

 Index of the next RX DMA descriptor to process */

 Index of first RX DMA descriptor to refill */

/* The hardware supports eight (8) rx queues, but we are only allowing

 * the first one to be used. Therefore, let's just allocate one queue.

 HW BM need that each port be identify by a unique ID */

 Utility/helper methods */

 Write helper method */

 Read helper method */

 Increment txq get counter */

 Increment txq put counter */

 Clear all MIB counters */

 Perform dummy reads from MIB counters */

 Get System Network Statistics */

 Rx descriptors helper methods */

/* Checks whether the RX descriptor having this status is both the first

 * and the last descriptor for the RX packet. Each RX packet is currently

 * received through a single RX descriptor, so not having each RX

 * descriptor with its first and last bits set is an error

 Add number of descriptors ready to receive new packets */

	/* Only MVNETA_RXQ_ADD_NON_OCCUPIED_MAX (255) descriptors can

	 * be added at once

 Get number of RX descriptors occupied by received packets */

/* Update num of rx desc called upon return from rx path or

 * from mvneta_rxq_drop_pkts().

 Only 255 descriptors can be added at once */

 Get pointer to next RX descriptor to be processed by SW */

 Change maximum receive size of the port. */

 Set rx queue offset */

 Offset is in */

 Tx descriptors helper methods */

 Update HW with number of TX descriptors to be sent */

 Only 255 Tx descriptors can be added at once */

 Get pointer to next TX descriptor to be processed (send) by HW */

/* Release the last allocated TX descriptor. Useful to handle DMA

 * mapping failures in the TX path.

 Set rxq buf size */

 Disable buffer management (BM) */

 Enable buffer management (BM) */

 Notify HW about port's assignment of pool for bigger packets */

 Notify HW about port's assignment of pool for smaller packets */

 Set port's receive buffer size for assigned BM pool */

 Configure MBUS window in order to enable access BM internal SRAM */

 Find first not occupied window */

 Get BM window information */

 Open NETA -> BM window */

/* Assign and initialize pools for port. In case of fail

 * buffer manager will remain disabled for current port.

 Create port's long pool depending on mtu */

 If short pool id is not defined, assume using single pool */

 Create port's short pool */

 Update settings of a pool for bigger packets */

 Release all buffers from long pool */

 Fill entire long pool */

 Start the Ethernet port RX and TX activity */

 Enable all initialized TXs. */

 Enable all initialized RXQs. */

 Stop the Ethernet port activity */

 Stop Rx port activity. Check port Rx activity. */

 Issue stop command for active channels only */

 Wait for all Rx activity to terminate. */

	/* Stop Tx port activity. Check port Tx activity. Issue stop

	 * command for active channels only

 Wait for all Tx activity to terminate. */

 Check TX Command reg that all Txqs are stopped */

 Double check to verify that TX FIFO is empty */

 Enable the port by setting the port enable bit of the MAC control register */

 Enable port */

 Disable the port and wait for about 200 usec before retuning */

 Reset the Enable bit in the Serial Control Register */

 Multicast tables methods */

 Set all entries in Unicast MAC Table; queue==-1 means reject all */

 Set all entries in Special Multicast MAC Table; queue==-1 means reject all */

 Set all entries in Other Multicast MAC Table. queue==-1 means reject all */

	/* All the queue are unmasked, but actually only the ones

	 * mapped to this CPU will be unmasked

	/* All the queue are masked, but actually only the ones

	 * mapped to this CPU will be masked

	/* All the queue are cleared, but actually only the ones

	 * mapped to this CPU will be cleared

/* This method sets defaults to the NETA port:

 *	Clears interrupt Cause and Mask registers.

 *	Clears all MAC tables.

 *	Sets defaults to all registers.

 *	Resets RX and TX descriptor rings.

 *	Resets PHY.

 * This method can be called after mvneta_port_down() to return the port

 *	settings to defaults.

 Clear all Cause registers */

 Mask all interrupts */

 Enable MBUS Retry bit16 */

	/* Set CPU queue access map. CPUs are assigned to the RX and

	 * TX queues modulo their number. If there is only one TX

	 * queue then it is assigned to the CPU associated to the

	 * default RX queue.

			/* With only one TX queue we configure a special case

			 * which will allow to get all the irq on a single

			 * CPU

 Reset RX and TX DMAs */

 Disable Legacy WRR, Disable EJP, Release from reset */

 Set Port Acceleration Mode */

 HW buffer management + legacy parser */

 SW buffer management + legacy parser */

 Update val of portCfg register accordingly with all RxQueue types */

 Build PORT_SDMA_CONFIG_REG */

 Default burst size */

 Assign port SDMA configuration */

	/* Disable PHY polling in hardware, since we're using the

	 * kernel phylib to do this.

 Set port interrupt enable register - default enable all */

 Set max sizes for tx queues */

 Set MTU */

 TX token size and all TXQs token size must be larger that MTU */

 Set unicast address */

 Locate the Unicast table entry */

 offset from unicast tbl base */

 offset within the above reg  */

 Clear accepts frame bit at specified unicast DA tbl entry */

 Set mac address */

 Accept frames of this address */

/* Set the number of packets that will be received before RX interrupt

 * will be generated by HW.

/* Set the time delay in usec before RX interrupt will be generated by

 * HW.

 Set threshold for TX_DONE pkts coalescing */

 Handle rx descriptor fill by setting buf_cookie and buf_phys_addr */

 Decrement sent descriptors counter */

 Only 255 TX descriptors can be updated at once */

 Get number of TX descriptors already sent by HW */

/* Get number of sent descriptors and decrement counter.

 *  The number of sent descriptors is returned.

 Get number of sent descriptors */

 Decrement sent descriptors counter */

 Set TXQ descriptors fields relevant for CSUM calculation */

	/* Fields: L3_offset, IP_hdrlen, L3_type, G_IPv4_chk,

	 * G_L4_chk, L4_type; required only for checksum

	 * calculation

 Display more error info */

 update per-cpu counter */

 Handle RX checksum offload based on the descriptor's status */

/* Return tx queue pointer (find last set bit) according to <cause> returned

 * form tx_done reg. <cause> must not be null. The return value is always a

 * valid queue for matching the first one found in <cause>.

 Free tx queue skbuffs */

 need for xdp_return_frame_bulk */

 Handle end of transmission */

 Refill processing for SW buffer management */

 Allocate page per descriptor */

 Handle tx checksum */

 Calculate IPv4 checksum and L4 checksum */

 Read l4_protocol from one of IPv6 extra headers */

 Drop packets received by the RXQ and free buffers */

 Return dropped buffer to the pool */

 xdp */

 ndo_xdp_xmit */

 Due xdp_adjust_tail: DMA sync for_device cover max len CPU touch */

 Prefetch header */

 last fragment */

 Main rx processing when using software buffer management */

 Get number of received packets */

 Fairness NAPI loop */

 Check errors only for FIRST descriptor */

 Middle or Last descriptor */

 no last descriptor this time */

 return some buffers to hardware queue, one at a time is too slow */

 Update rxq management counters */

 Main rx processing when using hardware buffer management */

 Get number of received packets */

 Fairness NAPI loop */

 Return the buffer to the pool */

 leave the descriptor untouched */

 better copy a small frame and not unmap the DMA region */

 Return the buffer to the pool */

 leave the descriptor and buffer untouched */

 Refill processing */

		/* After refill old buffer has to be unmapped regardless

		 * the skb is successfully built or not.

 Linux processing */

 Update rxq management counters */

 last descriptor in the TCP packet */

 last descriptor in SKB */

 Count needed descriptors */

 Initialize the TSO handler, and prepare the first payload */

 prepare packet headers: MAC + IP + TCP */

	/* Release all used data descriptors; header descriptors must not

	 * be DMA-unmapped.

 Handle tx fragmentation processing */

 Last descriptor */

 Descriptor in the middle: Not First, Not Last */

	/* Release all descriptors that were used to map fragments of

	 * this packet, as well as the corresponding DMA mappings

 Main tx processing */

 Get a descriptor for the first part of the packet */

 First and Last descriptor */

 First but not Last */

 Continue with other skb fragments */

 Free tx resources, when resetting a port */

 reset txq */

/* Handle tx done - called in softirq context. The <cause_tx_done> argument

 * must be a valid cause according to MVNETA_TXQ_INTR_MASK_ALL.

/* Compute crc8 of the specified address, using a unique algorithm ,

 * according to hw spec, different than generic crc8 algorithm

/* This method controls the net device special MAC multicast support.

 * The Special Multicast Table for MAC addresses supports MAC of the form

 * 0x01-00-5E-00-00-XX (where XX is between 0x00 and 0xFF).

 * The MAC DA[7:0] bits are used as a pointer to the Special Multicast

 * Table entries in the DA-Filter table. This method set the Special

 * Multicast Table appropriate entry.

 Register offset from SMC table base    */

 Entry offset within the above reg */

/* This method controls the network device Other MAC multicast support.

 * The Other Multicast Table is used for multicast of another type.

 * A CRC-8 is used as an index to the Other Multicast Table entries

 * in the DA-Filter table.

 * The method gets the CRC-8 value from the calling routine and

 * sets the Other Multicast Table appropriate entry according to the

 * specified CRC-8 .

 Register offset from OMC table base */

 Entry offset within the above reg   */

 Clear accepts frame bit at specified Other DA table entry */

/* The network device supports multicast using two tables:

 *    1) Special Multicast Table for MAC addresses of the form

 *       0x01-00-5E-00-00-XX (where XX is between 0x00 and 0xFF).

 *       The MAC DA[7:0] bits are used as a pointer to the Special Multicast

 *       Table entries in the DA-Filter table.

 *    2) Other Multicast Table for multicast of another type. A CRC-8 value

 *       is used as an index to the Other Multicast Table entries in the

 *       DA-Filter table.

 Configure Fitering mode of Ethernet port */

 Set / Clear UPM bit in port configuration register */

 Accept all Unicast addresses */

 Reject all Unicast addresses */

 register unicast and multicast addresses */

 Accept all: Multicast + Unicast */

 Accept single Unicast */

 Accept all multicast */

 Accept only initialized multicast */

 Interrupt handling - the callback for request_irq() */

 Interrupt handling - the callback for request_percpu_irq() */

/* NAPI handler

 * Bits 0 - 7 of the causeRxTx register indicate that are transmitted

 * packets on the corresponding TXQ (Bit 0 is for TX queue 1).

 * Bits 8 -15 of the cause Rx Tx register indicate that are received

 * packets on the corresponding RXQ (Bit 8 is for RX queue 0).

 * Each CPU has its own causeRxTx register

 Read cause register */

 Release Tx descriptors */

	/* For the case where the last mvneta_poll did not process all

	 * RX packets

 Handle rxq fill: allocates rxq skbs; called when initializing a port */

	/* Add this number of RX descriptors as non occupied (ready to

	 * get packets)

 Free all packets pending transmit from all TXQs and reset TX port */

 free the skb's in the tx ring */

 Rx/Tx queue initialization/cleanup methods */

 Allocate memory for RX descriptors */

 Set Rx descriptors queue starting address */

 Set coalescing pkts and time */

 Set Offset */

 Set Offset */

 Fill RXQ with buffers from RX pool */

 Create a specified RX queue */

 Cleanup Rx queue */

	/* A queue must always have room for at least one skb.

	 * Therefore, stop the queue when the free entries reaches

	 * the maximum number of descriptors per skb.

 Allocate memory for TX descriptors */

 Allocate DMA buffers for TSO MAC/IP/TCP headers */

 Setup XPS mapping */

 Set maximum bandwidth for enabled TXQs */

 Set Tx descriptors queue starting address */

 Create and initialize a tx queue */

 Free allocated resources when mvneta_txq_init() fails to allocate memory*/

 Set minimum bandwidth for disabled TXQs */

 Set Tx descriptors queue starting address and size */

 Cleanup all Tx queues */

 Cleanup all Rx queues */

 Init all Rx queues */

 Init all tx queues */

 start the Rx/Tx activity */

 Enable polling on the port */

 Unmask interrupts. It has to be done from each CPU */

 We may have called phylink_speed_down before */

 Stop the port activity */

 Clear all ethernet port interrupts */

 Mask all ethernet port interrupts */

 Change the device mtu */

	/* The interface is running, so we have to force a

	 * reallocation of the queues

 Get mac address */

 Handle setting mac address */

 Remove previous address table entry */

 Set new addr in hw */

	/* We only support QSGMII, SGMII, 802.3z and RGMII modes.

	 * When in 802.3z mode, we must have AN enabled:

	 * "Bit 2 Field InBandAnEn In-band Auto-Negotiation enable. ...

	 * When <PortType> = 1 (1000BASE-X) this field must be set to 1."

 Allow all the expected bits */

 Asymmetric pause is unsupported */

 Half-duplex at speeds higher than 100Mbit is unsupported */

 10M and 100M are only supported in non-802.3z mode */

	/* Even though it might look weird, when we're configured in

	 * SGMII or QSGMII mode, the RGMII bit needs to be set.

		/* Phy or fixed speed - nothing to do, leave the

		 * configured speed, duplex and flow control as-is.

 SGMII mode receives the state from the PHY */

 802.3z negotiation - only 1000base-X */

 The MAC only supports FD mode */

	/* Armada 370 documentation says we can only change the port mode

	 * and in-band enable when the link is down, so force it down

	 * while making these changes. We also do this for GMAC_CTRL2

	/* When at 2.5G, the link partner can send frames with shortened

	 * preambles.

		/* When inband doesn't cover flow control or flow control is

		 * disabled, we need to manually configure it. This bit will

		 * only have effect if MVNETA_GMAC_AN_FLOW_CTRL_EN is unset.

 PHY WoL may be enabled but device wakeup disabled */

/* Electing a CPU must be done in an atomic way: it should be done

 * after or before the removal/insertion of a CPU and this function is

 * not reentrant.

	/* Use the cpu associated to the rxq when it is online, in all

	 * the other cases, use the cpu 0 which can't be offline.

 Map the default receive queue to the elected CPU */

		/* We update the TX queue map only if we have one

		 * queue. In this case we associate the TX queue to

		 * the CPU bound to the default RX queue

		/* Update the interrupt mask on each CPU according the

		 * new mapping

	/* Armada 3700's per-cpu interrupt for mvneta is broken, all interrupts

	 * are routed to CPU 0, so we don't need all the cpu-hotplug support

	/*

	 * Configuring the driver for a new CPU while the driver is

	 * stopping is racy, so just avoid it.

	/*

	 * We have to synchronise on tha napi of each CPU except the one

	 * just being woken up

 Mask all ethernet port interrupts */

	/*

	 * Enable per-CPU interrupts on the CPU that is

	 * brought up.

	/*

	 * Enable per-CPU interrupt on the one CPU we care

	 * about.

 Unmask all ethernet port interrupts */

	/*

	 * Thanks to this lock we are sure that any pending cpu election is

	 * done.

 Mask all ethernet port interrupts */

 Disable per-CPU interrupts on the CPU that is brought down. */

 Check if a new CPU must be elected now this on is down */

 Unmask all ethernet port interrupts */

 Connect to port interrupt line */

		/* Enable per-CPU interrupt on all the CPU to handle our RX

		 * queue interrupts

		/* Register a CPU notifier to handle the case where our CPU

		 * might be taken offline.

 Stop the port, free port interrupt line */

		/* Inform that we are stopping so we don't want to setup the

		 * driver for new CPUs in the notifiers. The code of the

		 * notifier for CPU online is protected by the same spinlock,

		 * so when we get the lock, the notifer work is done.

 Ethtool methods */

 Set link ksettings (phy address, speed) for ethtools */

 Get link ksettings for ethtools */

 Set interrupt coalescing for ethtools */

 get coalescing for ethtools */

 Docs say to read low 32-bit then high */

 We have to synchronise on the napi of each CPU */

 Update unicast mapping */

 Update val of portCfg register accordingly with all RxQueue types */

 Update the elected CPU matching the new rxq_def */

 We have to synchronise on the napi of each CPU */

 Current code for Armada 3700 doesn't support RSS features yet */

	/* We require at least one supported parameter to be changed

	 * and no change in any of the unsupported parameters

 Current code for Armada 3700 doesn't support RSS features yet */

 * scale;

	/* The Armada 37x documents do not give limits for this other than

	 * it being an 8-bit register.

 Initialize hw */

 Disable port */

 Set port default values */

 Initialize TX descriptor rings */

 Create Rx descriptor rings */

 platform glue : initialize decoding windows */

		/* For Armada3700 open default 4GB Mbus window, leaving

		 * arbitration of target/attribute to a different layer

		 * of configuration.

 Power up the port */

 MAC Cause register should be cleared */

 Device initialization routine */

		/* If a COMPHY is present, we can support any of the serdes

		 * modes and switch between them.

 No COMPHY, with only 2500BASE-X mode supported */

 No COMPHY, we can switch between 1000BASE-X and SGMII */

 Get special SoC configurations */

 Alloc per-cpu port structure */

 Alloc per-cpu stats */

	/* Armada3700 requires setting default configuration of Mbus

	 * windows, however without using filled mbus_dram_target_info

	 * structure.

 Obtain access to BM resources if enabled and already initialized */

		/* Set RX packet offset correction for platforms, whose

		 * NET_SKB_PAD, exceeds 64B. It should be 64B for 64-bit

		 * platforms and 0B for 32-bit ones.

 sw buffer management */

	/* Armada3700 network controller does not support per-cpu

	 * operation, so only single NAPI should be initialized.

 MTU range: 68 - 9676 */

 9676 == 9700 - 20 and rounding to 8 */

 Device removal routine */

/*

 * Driver for Marvell NETA network controller Buffer Manager.

 *

 * Copyright (C) 2015 Marvell

 *

 * Marcin Wojtas <mw@semihalf.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 Clear BM cause register */

	/* In order to update buf_cookie field of RX descriptor properly,

	 * BM hardware expects buf virtual address to be placed in the

	 * first four bytes of mapped buffer.

 Create pool */

 Set pool address */

/* Notify the driver that BM pool is being used as specific type and return the

 * pool pointer on success

 Allocate buffers in case BM pool hasn't been used yet */

 Create new pool */

 Allocate buffers for this pool */

 Free all buffers from the pool */

 Get buffer physical address (indirect access) */

		/* Work-around to the problems when destroying the pool,

		 * when it occurs that a read access to BPPI returns 0.

 Update BM driver with number of buffers removed from pool */

 Cleanup pool */

 Activate BM unit */

 Create all pools with maximum size */

 Reset read pointer */

 Reset write pointer */

 Configure pool size according to DT or use default value */

 Obtain custom pkt_size from DT */

 Mask BM all interrupts */

 Clear BM cause register */

 Set BM configuration register */

 Reduce MaxInBurstSize from 32 BPs to 16 BPs */

 Allocate and initialize BM pools structures */

 Initialize buffer manager internals */

 Dectivate BM unit */

/*

 * Driver for the MDIO interface of Marvell network interfaces.

 *

 * Since the MDIO interface of Marvell network interfaces is shared

 * between all network interfaces, having a single driver allows to

 * handle concurrent accesses properly (you may have four Ethernet

 * ports, but they in fact share the same SMI interface to access

 * the MDIO bus). This driver is currently used by the mvneta and

 * mv643xx_eth drivers.

 *

 * Copyright (C) 2012 Marvell

 *

 * Thomas Petazzoni <thomas.petazzoni@free-electrons.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

/*

 * SMI Timeout measurements:

 * - Kirkwood 88F6281 (Globalscale Dreamplug): 45us to 95us (Interrupt)

 * - Armada 370       (Globalscale Mirabox):   41us to 43us (Polled)

 1000us = 1ms */

	/*

	 * If we have access to the error interrupt pin (which is

	 * somewhat misnamed as it not only reflects internal errors

	 * but also reflects SMI completion), use that to wait for

	 * SMI access completion instead of polling the SMI busy bit.

/* Wait for the SMI unit to be ready for another operation

			/* wait_event_timeout does not guarantee a delay of at

			 * least one whole jiffie, so timeout must be no less

			 * than two.

	/* For the platforms not supporting DT/ACPI fall-back

	 * to mdiobus_register via of_mdiobus_register.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * New driver for Marvell Yukon 2 chipset.

 * Based on earlier sk98lin, and skge driver.

 *

 * This driver intentionally does not support all the features

 * of the original driver such as link fail-over and link management because

 * those should be done at higher levels.

 *

 * Copyright (C) 2005 Stephen Hemminger <shemminger@osdl.org>

/*

 * The Yukon II chipset takes 64 bit command blocks (called list elements)

 * that are organized into three (receive, transmit, status) different rings

 * similar to Tigon3.

/* This is the worst case number of transmit list elements for a single skb:

 * VLAN:GSO + CKSUM + Data + skb_frags * DMA

 defaults above */

 SK-9Sxx */

 SK-9Exx */

 SK-9E21M */

 DGE-560T */

 DGE-550SX */

 DGE-560SX */

 DGE-550T */

 88E8021 */

 88E8022 */

 88E8061 */

 88E8062 */

 88E8021 */

 88E8022 */

 88E8061 */

 88E8062 */

 88E8035 */

 88E8036 */

 88E8038 */

 88E8039 */

 88E8040 */

 88E8040T */

 88EC033 */

 88E8042 */

 88E8048 */

 88E8052 */

 88E8050 */

 88E8053 */

 88E8055 */

 88E8056 */

 88E8070 */

 88EC036 */

 88EC032 */

 88EC034 */

 88EC042 */

 88E8058 */

 88E8071 */

 88E8072 */

 88E8055 */

 88E8075 */

 88E8057 */

 88E8059 */

 88E8079 */

 Avoid conditionals by using array */

 Access to PHY via serial interconnect */

 switch power to VCC (WA for VAUX problem) */

 disable Core Clock Division, */

 enable bits are inverted */

 set all bits to 0 except bits 15..12 and 8 */

 set all bits to 0 except bits 28 & 27 */

 Enable workaround for dev 4.107 on Yukon-Ultra & Extreme */

 Turn on "driver loaded" LED */

 enable bits are inverted */

 switch power to VAUX if supported and PME from D3cold */

 turn off "driver loaded LED" */

 disable all GMAC IRQ's */

 clear MC hash */

 flow control to advertise bits */

 flow control to advertise bits when using 1000BaseX */

 flow control to GMA disable bits */

 on PHY 88E1040 Rev.D0 (and newer) downshift control changed */

 set downshift counter to 3x and enable downshift */

 set master & slave downshift counter to 1x */

 enable automatic crossover */

 Enable Class A driver for FE+ A0 */

 disable energy detect */

 enable automatic crossover */

 downshift on PHY 88E1112 and 88E1149 is changed */

 set downshift counter to 3x and enable downshift */

 workaround for deviation #4.88 (CRC errors) */

 disable Automatic Crossover */

 special setup for PHY 88E1112 Fiber */

 Fiber: select 1000BASE-X only mode MAC Specific Ctrl Reg. */

 select page 1 to access Fiber registers */

 for SFP-module set SIGDET polarity to low */

 special defines for FIBER (88E1040S only) */

 Restart Auto-negotiation */

 forced speed/duplex settings */

 Disable auto update for duplex flow control and duplex */

 Forward pause packets to GMAC? */

 Setup Phy LED's */

 on 88E3082 these bits are at 11..9 (shifted left) */

 delete ACT LED control bits */

 change ACT LED control to blink mode */

 Enable Link Partner Next Page */

 disable Energy Detect and enable scrambler */

 set LED2 -> ACT, LED1 -> LINK, LED0 -> SPEED */

 select page 3 to access LED control register */

 set LED Function Control register */

 LINK/ACT */

 10 Mbps */

 100 Mbps */

 1000 Mbps */

 set Polarity Control register */

 restore page register */

 select page 3 to access LED control register */

 set LED Function Control register */

 LINK/ACT */

 10 Mbps */

 100 Mbps */

 1000 Mbps */

 set Blink Rate in LED Timer Control Register */

 restore page register */

 set Tx LED (LED_TX) to blink mode on Rx OR Tx activity */

 turn off the Rx LED (LED_RX) */

 apply fixes in PHY AFE */

 increase differential signal amplitude in 10BASE-T */

 fix for IEEE A/B Symmetry failure in 1000BASE-T */

 set page register to 0 */

 apply workaround for integrated resistors calibration */

 apply fixes in PHY AFE */

 apply RDAC termination workaround */

 set page register back to 0 */

 no effect on Yukon-XL */

 turn on 100 Mbps LED (LED_LINK100) */

 This a phy register setup workaround copied from vendor driver. */

 { 0x155, 0x130b },*/

 { 0x154, 0x2f39 },*/

 { 0x158, 0x1223 },*/

 Start Workaround for OptimaEEE Rev.Z0 */

 apply AFE settings */

 End Workaround for OptimaEEE */

 Enable 10Base-Te (EEE) */

 Enable phy interrupt on auto-negotiation complete (or link up) */

 release GPHY Control reset */

 release GMAC reset */

 select page 2 to access MAC control register */

 allow GMII Power Down */

 set page register back to 0 */

 setup General Purpose Control Register */

 select page 2 to access MAC control register */

 enable Power Down */

 set page register back to 0 */

 set IEEE compatible Power Down Mode (dev. #4.99) */

 set PHY to PowerDown/COMA Mode */

 configure IPG according to used link speed */

 Enable Rx/Tx */

 Force a renegotiation */

 Put device in state to listen for Wake On Lan */

 Bring hardware out of reset */

	/* Force to 10/100

	 * sky2_reset will re-enable on resume

 Set GMAC to no flow control and auto update for speed/duplex */

 Set WOL address */

 Turn on appropriate WOL control bits */

 Disable PiG firmware */

 Needed by some broken BIOSes, use PCI rather than PCI-e for WOL */

 block receiver */

 Yukon-Extreme B0 and further Extreme devices */

 set Tx GMAC FIFO Almost Empty Threshold */

 WA DEV_472 -- looks like crossed wires on port 2 */

 clear GMAC 1 Control reset */

 Enable Transmit FIFO Underrun */

 MIB clear */

 transmit control */

 receive control reg: unicast + multicast + no FCS  */

 transmit flow control */

 transmit parameter */

 serial mode register */

 virtual address for data */

 physical address: used for pause frames */

 ignore counter overflows */

 Configure Rx MAC FIFO */

 Hardware errata - clear flush mask */

 Flush Rx MAC FIFO on any flow control or error */

 Set threshold to 0xa (64 bytes) + 1 to workaround pause bug  */

 Another magic mystery workaround from sk98lin */

 Configure Tx MAC FIFO */

 On chips without ram buffer, pause is controlled by MAC level */

 Pause threshold is scaled by 8 in bytes */

 disable dynamic watermark */

 Assign Ram Buffer allocation to queue */

 convert from K bytes to qwords used for hw register */

		/* On receive queue's set the thresholds

		 * give receiver priority when > 3/4 full

		 * send pause when down to 2K

		/* Enable store & forward on Tx queue's because

		 * Tx FIFO is only 1K on Yukon

 Setup Bus Memory Interface */

/* Setup prefetch unit registers. This is the interface between

 * hardware and driver list elements

 Update chip's next pointer */

 Make sure write' to descriptors are complete before we tell hardware */

 Space needed for frame data + headers rounded up */

 Stopping point for hardware truncation */

 Space needed for frame data + headers rounded up */

 Compute residue after pages */

 Optimize to handle small packets and headers */

 Build description to hardware for one receive segment */

 Build description to hardware for one possibly fragmented skb */

/* Tell chip where to start receive checksum.

 * Actually has two checksums, but set both same to avoid possible byte

 * order problems.

 Enable/disable receive hash calculation (RSS) */

 Supports IPv6 and other modes */

 Program RSS initial values */

 Need to turn on (undocumented) flag to make hashing work  */

/*

 * The RX Stop command will not work for Yukon-2 if the BMU does not

 * reach the end of packet and since we can't make sure that we have

 * incoming data, we must reset the BMU while it is not doing a DMA

 * transfer. Since it is possible that the RX path is still active,

 * the RX RAM buffer will be stopped first, so any possible incoming

 * data will not trigger a DMA. After the RAM buffer is stopped, the

 * BMU is polled until any DMA in progress is ended and only then it

 * will be reset.

 disable the RAM Buffer receive queue */

 reset the Rx prefetch unit */

 Clean out receive buffer area, assumes receiver hardware stopped */

 Basic MII support */

 Phy still in reset */

 Can't do transmit offload of vlan without hw vlan */

 Amount of required worst case padding in rx buffer */

/*

 * Allocate an skb for receiving. If the MTU is large enough

 * make the skb non-linear with a fragment list of pages.

		/*

		 * Workaround for a bug in FIFO that cause hang

		 * if the FIFO if the receive buffer is not 64 byte aligned.

		 * The buffer returned from netdev_alloc_skb is

		 * aligned except if slab debugging is enabled.

 Fill Rx ring */

/*

 * Setup receiver buffer pool.

 * Normal case this ends up creating one list element for skb

 * in the receive ring. Worst case if using large MTU and each

 * allocation falls on a different 64 bit region, that results

 * in 6 list elements per ring entry.

 * One element is used for checksum enable/disable, and one

 * extra to avoid wrap.

 On PCI express lowering the watermark gives better performance */

	/* These chips have no ram buffer?

	 * MAC Rx RAM Read is controlled by hardware

 submit Rx ring */

	/*

	 * The receiver hangs if it receives frames larger than the

	 * packet buffer. As a workaround, truncate oversize frames, but

	 * the register is limited to 9 bits, so if you do frames > 2052

	 * you better get the MTU right!

 Tell chip about available buffers */

		/*

		 * Disable flushing of non ASF packets;

		 * must be done after initializing the BMUs;

		 * drivers without ASF support should do this too, otherwise

		 * it may happen that they cannot run on ASF devices;

		 * remember that the MAC FIFO isn't reset during initialization.

 Enable RX Home Address & Routing Header checksum fix */

 Enable TX Home Address & Routing Header checksum fix */

 must be power of 2 */

	/*

	 * On dual port PCI-X card, there is an problem where status

	 * can be received out of order due to split transactions

 Register is number of 4K blocks on internal RAM buffer. */

 Make sure SyncQ is disabled */

 This is copied from sk98lin 10.0.5.3; no one tells me about erratta's */

 Set almost empty threshold */

 Setup device IRQ and enable napi to process */

 Bring up network interface. */

 With single port, IRQ is setup when device is brought up */

 Enable interrupts from phy/mac for port */

 enable PHY Quick Link */

 Modular subtraction in ring */

 Number of list elements available for next tx */

 Estimate of number of transmit list elements required */

 possible vlan */

/*

 * Put one packet in ring for transmit.

 * A single packet can generate multiple list elements, and

 * the number of ring elements will probably be less than the number

 * of list elements used.

 Send high bits if needed */

 Check for TCP Segmentation Offload */

 Add VLAN tag, can piggyback on LRGLEN or ADDR64 */

 Handle TCP checksum offload */

 On Yukon EX (some versions) encoding change. */

 auto checksum */

 sum start */

 sum write */

 initial checksum value */

 one packet */

/*

 * Free ring elements from starting at tx_cons until "done"

 *

 * NB:

 *  1. The hardware will tell us about partial completion of multi-part

 *     buffers so make sure not to free skb to early.

 *  2. This may run in parallel start_xmit because the it only

 *     looks at the tail of the queue of FIFO (tx_cons), not

 *     the head (tx_prod)

 Disable Force Sync bit and Enable Alloc bit */

 Stop Interval Timer and Limit Counter of Tx Arbiter */

 Reset the PCI FIFO of the async Tx queue */

 Reset the Tx prefetch units */

 Force flow control off */

 Stop transmitter */

 Workaround shared GMAC reset */

 Force any delayed status interrupt and NAPI */

 Free any pending frames stuck in HW queue */

 Network shutdown */

 Never really got started! */

 Disable port IRQ */

 Turn on link LED */

 Turn off link LED */

	/* Since the pause result bits seem to in different positions on

	 * different chips. look at registers.

 Shift for bits in fiber PHY */

 Interrupt from PHY */

 Special quick link interrupt (Yukon-2 Optima only) */

 disable irq */

 reset PHY Link Detect */

/* Transmit timeout is only called if we are running, carrier is up

 * and tx queue is full (stopped).

 can't restart safely under softirq */

 prevent tx timeout */

 Some architectures need the IP header to be aligned */

 For small just reuse existing skb for next receive */

 Adjust length of skb with fragments to match received data */

 put header into skb */

 don't need this page */

 Normal packet - take skb from ring element and put in a new one  */

/*

 * Receive one packet.

 * For larger packets, get new buffer.

 Account for vlan tag */

	/* This chip has hardware problems that generates bogus status.

	 * So do only marginal checking and expect higher level protocols

	 * to handle crap frames.

 if length reported by DMA does not match PHY, packet was truncated */

 Transmit complete */

 Wake unless it's detached, and called e.g. from sky2_close() */

 If this happens then driver assuming wrong format for chip type */

	/* Both checksum counters are programmed to start at

	 * the same offset, so unless there is a problem they

	 * should match. This failure is an early indication that

	 * hardware receive checksumming won't work.

		/* Disable checksum offload

		 * It will be reenabled on next ndo_set_features, but if it's

		 * really broken, will get disabled again

 Process status response ring */

 This chip reports checksum status differently */

 Stop after net poll weight */

 TX index reports status for both ports */

 Fully processed status ring so clear irq */

 Clear IRQ */

 PCI-Express uncorrectable Error occurred */

 This should never happen it is a bug. */

 If idle and MAC or PCI is stuck */

 Check if the PCI RX hang */

 Check for lost IRQ once a second */

 For chips with Rx FIFO, check if stuck */

 Hardware/software error handling */

 Reading this mask interrupts as side effect */

 Chip internal frequency for clock calculations */

 Enable all clocks and check for bad PCI access */

 New transmit checksum */

 This rev is really old, and requires untested workarounds */

 The workaround for status conflicts VLAN tag detection. */

 disable ASF */

		/*

		 * CPU clock divider shouldn't be used because

		 * - ASF firmware may malfunction

		 * - Yukon-Supreme: Parallel FLASH doesn't support divided clocks

 do a SW reset */

 allow writes to PCI config */

 clear PCI errors, if any */

 If error bit is stuck on ignore it */

 enable MACSec clock gating */

 disable PCI-E PHY power down (set PHY reg 0x80, bit 7 */

 set PHY Link Detect Timer to 1.1 second (11x 100ms) */

 re-enable PEX PM in PEX PHY debug reg. 8 (clear bit 12) */

 set PHY Link Detect Timer to 0.4 second (4x 100ms) */

 reset PHY Link Detect */

 check if PSMv2 was running before */

 restore the PCIe Link Control register */

 change PHY Interrupt polarity to low active */

 adapt HW for low active PHY Interrupt */

 re-enable PEX PM in PEX PHY debug reg. 8 (clear bit 12) */

 Clear I2C IRQ noise */

 turn off hardware timer (unused) */

 Turn off descriptor polling */

 Turn off receive timestamp */

 enable the Tx Arbiters */

 Initialize ram interface */

 Set the list last index */

 set Status-FIFO ISR watermark */

 enable status unit */

/* Take device down (offline).

 * Equivalent to doing dev_stop() but this does not

 * inform upper layers of the transition.

 stop txq */

 Bring device back after doing sky2_detach */

 virtual address for data */

 physical address: used for pause frames */

 promiscuous */

/* Can have one global because blinking is controlled by

 * ethtool and that is always under RTNL mutex

 blink LED's for finding board */

 cycle on/off once per second */

 Note: this affect both ports */

/*

 * Hardware is limited to min of 128 and max of 2048 for ring size

 * and  rounded up to next power of two

 * to avoid division in modulus calculation

	/* This complicated switch statement is to make sure and

	 * only access regions that are unreserved.

	 * Some blocks are only valid on dual port cards.

 second port */

 Tx Arbiter 2 */

 RX2 */

 TX2 */

 Ram Buffer 2 */

 Tx Ram Buffer 2 */

 Rx MAC Fifo 1 */

 Tx MAC Fifo 2 */

 GPHY 2 */

 Pattern Ram 2 */

 TCP Segmentation 2 */

 GMAC 2 */

 Control */

 Mac address */

 Tx Arbiter 1 */

 PCI express reg */

 RX1 */

 TX1 */

 Rx Ram Buffer 1 */

 Tx Ram Buffer 1 */

 Rx MAC Fifo 1 */

 Tx MAC Fifo 1 */

 Descriptor and status unit */

 GPHY 1*/

 Pattern Ram 1 */

 TCP Segmentation 1 */

 PCI space */

 GMAC 1 */

/*

 * Returns copy of control register region

 * Note: ethtool_get_regs always provides full size (16k) buffer

 skip poisonous diagnostic ram region in block 3 */

 Can take up to 10.6 ms for write */

 Partial writes not supported */

	/* In order to do Jumbo packets on these chips, need to turn off the

	 * transmit store/forward. Therefore checksum offload won't work.

 Some hardware requires receive checksum for RSS to work. */

 Dump contents of tx ring */

/*

 * Use network device events to create/remove/rename

 * debugfs file entries

/* Two copies of network device operations to handle special case of

 * not allowing netpoll on second port

 Initialize network device */

 Auto speed and flow control */

 Enable receive hashing unless hardware is known broken */

 MTU range: 60 - 1500 or 9000 */

	/* try to get mac address in the following order:

	 * 1) from device tree data

	 * 2) from internal registers set by bootloader

 if the address is invalid, use a random value */

 Handle software interrupt used during MSI test */

 Test interrupt path by forcing a a software IRQ */

 MSI test failed, go back to INTx mode */

 This driver supports yukon2 chipset only */

 0xb3 */

 0xb4 */

 0xb5 */

 0xb6 */

 0xb7 */

 0xb8 */

 0xb9 */

 0xba */

 0xbb */

 0xbc */

 0xbd */

 0xbe */

	/* Get configuration information

	 * Note: only regular PCI config access once to test for HW issues

	 *       other PCI access through shared memory for speed and to

	 *	 avoid MMCONFIG problems.

	/* The sk98lin vendor driver uses hardware byte swapping but

	 * this driver uses software swapping.

 ring for status responses */

 Re-enable all clocks */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * New driver for Marvell Yukon chipset and SysKonnect Gigabit

 * Ethernet adapters. Based on earlier sk98lin, e100 and

 * FreeBSD if_sk drivers.

 *

 * This driver intentionally does not support all the features

 * of the original driver such as link fail-over and link management because

 * those should be done at higher levels.

 *

 * Copyright (C) 2004, 2005 Stephen Hemminger <shemminger@osdl.org>

 defaults above */

 3Com 3C940 */

 3Com 3C940B */

 SK-9xx */

 SK-98xx V2.0 */

 D-Link DGE-530T (rev.B) */

 D-Link DGE-530T */

 D-Link DGE-530T Rev C1 */

 Marvell Yukon 88E8001/8003/8010 */

 Belkin */

 CNet PowerG-2000 */

 Linksys EG1064 v2 */

 Linksys EG1032 v2 */

 Avoid conditionals by using array */

/*

 * Returns copy of whole control register region

 * Note: skip RAM address register because accessing it will

 * 	 cause bus hangs!

 Wake on Lan only supported on Yukon chips with rev 1 or above */

 Turn on Vaux */

 WA code for COMA mode -- clear PHY reset */

 Force to 10/100 skge_reset will re-enable on resume	 */

 no 1000 HD/FD */

 Set GMAC to no flow control and auto update for speed/duplex */

 Set WOL address */

 Turn on appropriate WOL control bits */

 block receiver */

/* Determine supported/advertised modes based on hardware.

 * Note: ethtool ADVERTISED_xxx == SUPPORTED_xxx

/* Use hardware MIB variables for critical path statistics and

 * transmit feedback not reported at interrupt.

 * Other errors are accounted for in interrupt handler.

 Chip internal frequency for clock calculations */

 Chip HZ to microseconds */

 Microseconds to chip HZ */

 Note: interrupt timer is per board, but can turn on/off per port */

 blink LED's for finding board */

 cycle on/off twice per second */

 back to regular LED state */

/*

 * Allocate ring elements and chain them together

 * One-to-one association of board descriptors with ring elements

 Allocate and setup a new buffer for receiving */

/* Resume receiving using existing skb,

 * Note: DMA address is not changed by chip.

 * 	 MTU not changed while receiver active.

 Free all  buffers in receive ring, assumes receiver stopped */

/* Allocate buffers for receive ring

 * For receive:  to_clean is next received frame.

 Both station may send PAUSE */

 set blink source counter */

 configure mac arbiter */

 configure mac arbiter timeout values */

 configure packet arbiter timeout */

 reset the statistics module */

 clear Mode Reg */

 reset TX CMD Reg */

 reset RX CMD Reg */

 disable Broadcom PHY IRQ */

 Flush TX and RX fifo */

 Convert mode to MII values  */

 special defines for FIBER (88E1011S only) */

 Check status of Broadcom phy link */

 read twice because of latch */

 Check Duplex mismatch */

 We are using IEEE 802.3z/D5.0 Table 37-4 */

/* Broadcom 5400 only supports giagabit! SysKonnect did not put an additional

 * Phy on for 100 or 10Mbit operation

 magic workaround patterns for Broadcom */

 read Id from external PHY (all have the same address) */

 Optimize MDIO transfer by suppressing preamble. */

		/*

		 * Workaround BCOM Errata for the C0 type.

		 * Write magic patterns to reserved registers.

		/*

		 * Workaround BCOM Errata for the A1 type.

		 * Write magic patterns to reserved registers.

	/*

	 * Workaround BCOM Errata (#10523) for all BCom PHYs.

	 * Disable Power Management after reset.

 Dummy read */

 enable tx led */

 always 1000mbit */

		/*

		 * Workaround BCOM Errata #1 for the C5 type.

		 * 1000Base-T Link Acquisition Failure in Slave Mode

		 * Set Repeater/DTE bit 10 of the 1000Base-T Control Register

 Force to slave */

 Set autonegotiation pause parameters */

 Handle Jumbo frames */

 Use link status change interrupt */

 Restart Auto-negotiation */

 Set DuplexMode in Config register */

		/*

		 * Do NOT enable Auto-negotiation here. This would hold

		 * the link down because no IDLEs are transmitted

 Poll PHY for status changes */

 read twice because of latch */

 Check Duplex mismatch */

 We are using IEEE 802.3z/D5.0 Table 37-4 */

 Enable PAUSE receive, disable PAUSE transmit */

 Disable PAUSE receive, enable PAUSE transmit */

/* Poll to check for link coming up.

 *

 * Since internal PHY is wired to a level triggered pin, can't

 * get an interrupt when carrier is detected, need to poll for

 * link coming up.

	/*

	 * Verify that the link by checking GPIO register three times.

	 * This pin has the signal from the link_sync pin connected to it.

 Re-enable interrupt to detect link down */

 Unreset the XMAC. */

	/*

	 * Perform additional initialization for external PHYs,

	 * namely for the 1000baseTX cards that use the XMAC's

	 * GMII mode.

 Take external Phy out of reset */

 Enable GMII interface */

 Set Station Address */

 We don't use match addresses so clear */

 Clear MIB counters */

 Clear two times according to Errata #3 */

 configure Rx High Water Mark (XM_RX_HI_WM) */

 We don't need the FCS appended to the packet. */

		/*

		 * If in manual half duplex mode the other side might be in

		 * full duplex mode, so ignore if a carrier extension is not seen

		 * on frames received

 We want short frames padded to 60 bytes. */

 Increase threshold for jumbo frames on dual port */

	/*

	 * Enable the reception of all error frames. This is

	 * a necessary evil due to the design of the XMAC. The

	 * XMAC's receive FIFO is only 8K in size, however jumbo

	 * frames can be up to 9000 bytes in length. When bad

	 * frame filtering is enabled, the XMAC's RX FIFO operates

	 * in 'store and forward' mode. For this to work, the

	 * entire frame has to fit into the FIFO, but that means

	 * that jumbo frames larger than 8192 bytes will be

	 * truncated. Disabling all bad frame filtering causes

	 * the RX FIFO to operate in streaming mode, in which

	 * case the XMAC will start transferring frames out of the

	 * RX FIFO as soon as the FIFO threshold is reached.

	/*

	 * Initialize the Receive Counter Event Mask (XM_RX_EV_MSK)

	 *	- Enable all bits excepting 'Octets Rx OK Low CntOv'

	 *	  and 'Octets Rx OK Hi Cnt Ov'.

	/*

	 * Initialize the Transmit Counter Event Mask (XM_TX_EV_MSK)

	 *	- Enable all bits excepting 'Octets Tx OK Low CntOv'

	 *	  and 'Octets Tx OK Hi Cnt Ov'.

 Configure MAC arbiter */

 configure timeout values */

 Configure Rx MAC FIFO */

 Configure Tx MAC FIFO */

 Enable frame flushing if jumbo frames used */

 enable timeout timers if normal frames */

 Disable Tx and Rx */

 Clear Tx packet arbiter timeout IRQ */

 Reset the MAC */

 For external PHYs there must be special handling */

 wait for update to complete */

 special case for 64 bit octet counter */

	/*

	 * enabling pause frame reception is required for 1000BT

	 * because the XMAC is not reset if the link is going down

 Disable Pause Frame Reception */

 Enable Pause Frame Reception */

		/*

		 * Configure Pause Frame Generation

		 * Use internal and external Pause Frame Generation.

		 * Sending pause frames is edge triggered.

		 * Send a Pause frame with the maximum pause time if

		 * internal oder external FIFO full condition occurs.

		 * Send a zero pause time frame to re-start transmission.

 XM_PAUSE_DA = '010000C28001' (default) */

 XM_MAC_PTIME = 0xffff (maximum) */

 remember this value is defined in big endian (!) */

		/*

		 * disable pause frame generation is required for 1000BT

		 * because the XMAC is not reset if the link is going down

 Disable Pause Mode in Mode Register */

 Turn on detection of Tx underrun */

 get MMU Command Reg. */

	/*

	 * Workaround BCOM Errata (#10523) for all BCom Phys

	 * Enable Power Management after link up

 enable Rx/Tx */

	/* Workaround BCom Errata:

	 *	enable and disable loopback mode if "NO HCD" occurs.

 Marvell Phy Initialization */

 Set Flow-control capabilities */

 Restart Auto-negotiation */

 forced speed/duplex settings */

 Enable phy interrupt on autonegotiation complete (or link up) */

 disable PHY IRQs */

 clear MC hash */

 Apparently, early versions of Yukon-Lite had wrong chip_id? */

 WA code for COMA mode -- set PHY reset */

 hard reset */

 WA code for COMA mode -- clear PHY reset */

 Set hardware config mode */

 Clear GMC reset */

 disable Rx flow-control */

 enable Tx & Rx flow-control */

 MIB clear */

 transmit control */

 receive control reg: unicast + multicast + no FCS  */

 transmit flow control */

 transmit parameter */

 configure the Serial Mode Register */

 physical address: used for pause frames */

 virtual address for data */

 enable interrupt mask for counter overflows */

 Initialize Mac Fifo */

 Configure Rx MAC FIFO */

 disable Rx GMAC FIFO Flush for YUKON-Lite Rev. A0 only */

	/*

	 * because Pause Packet Truncation in GMAC is not working

	 * we have to increase the Flush Threshold to 64 bytes

	 * in order to flush pause packets in Rx FIFO on Yukon-1

 Configure Tx MAC FIFO */

 Go into power down mode */

 switch IEEE compatible power down mode on */

 set GPHY Control reset */

 Enable Transmit FIFO Underrun */

 enable Rx/Tx */

 restore Asymmetric Pause bit */

 We are using IEEE 802.3z/D5.0 Table 37-4 */

 XXX restart autonegotiation? */

 Basic MII support */

 Phy still in reset */

 Set thresholds on receive queue's */

		/* Enable store & forward on Tx queue's because

		 * Tx FIFO is only 4K on Genesis and 1K on Yukon

 Setup Bus Memory Interface */

 optimization to reduce window on 32bit/33mhz */

 Initialize MAC */

 Configure RAMbuffers - equally between ports and tx/rx */

 Start receiver BMU */

 stop receiver */

 Stop transmitter */

 Disable Force Sync bit and Enable Alloc bit */

 Stop Interval Timer and Limit Counter of Tx Arbiter */

 Reset PCI FIFO */

 Reset the RAM Buffer async Tx queue */

		/* This seems backwards, but it is what the sk98lin

		 * does.  Looks like hardware is wrong?

 single buffer i.e. no fragments */

 Make sure all the descriptors written */

 Free resources associated with this reing element */

 skb header vs. fragment */

 Free all buffers in transmit ring */

 promiscuous */

 all multicast */

 no multicast */

/* Get receive buffer from descriptor.

 * Handles copy of small buffers and reallocation failures

 Free all buffers in Tx ring which are no longer owned by device */

 Can run lockless until we need to synchronize to restart queue. */

 restart receiver */

/* Parity errors seem to happen when Genesis is connected to a switch

 * with no other ports present. Heartbeat error??

 HW-Bug #8: cleared by GMF_CLI_TX_FC instead of GMF_CLI_TX_PE */

 Handle device specific framing and timeout interrupts */

 clear xmac errors */

 Timestamp (unused) overflow */

 Write the error bits back to clear them. */

 if error still set then just ignore it */

/*

 * Interrupt from PHY are handled in tasklet (softirq)

 * because accessing phy registers requires spin wait which might

 * cause excess interrupt latency.

 Reading this register masks IRQ */

 disable Rx */

/*

 * Setup the board data structure, but don't bring up

 * the port(s)

 do a SW reset */

 clear PCI errors, if any */

 restore CLK_RUN bits (for Yukon-Lite) */

 read the adapters RAM size */

 special case: 4 x 64k x 36, offset = 0x80000 */

 Use PHY IRQ for all but fiber based Genesis board */

 switch power to VCC (WA for VAUX problem) */

 avoid boards with stuck Hardware error bits */

 Clear PHY COMA */

 turn off hardware timer (unused) */

 enable the Tx Arbiters */

 Initialize ram interface */

	/* Set interrupt moderation for Transmit only

	 * Receive interrupts avoided by NAPI

 Leave irq disabled until first port is brought up. */

/*

 * Use network device events to create/remove/rename

 * debugfs file entries

 Initialize network device */

 MTU range: 60 - 9000 */

 Auto speed and flow control */

 Only used for Genesis XMAC */

 read the mac address */

 byte swap descriptors in hardware */

 space for skge@pci:0000:04:00.0 */

 Some motherboards are broken and has zero in ROM. */

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for Marvell Discovery (MV643XX) and Marvell Orion ethernet ports

 * Copyright (C) 2002 Matthew Dharm <mdharm@momenco.com>

 *

 * Based on the 64360 driver from:

 * Copyright (C) 2002 Rabeeh Khoury <rabeeh@galileo.co.il>

 *		      Rabeeh Khoury <rabeeh@marvell.com>

 *

 * Copyright (C) 2003 PMC-Sierra, Inc.,

 *	written by Manish Lachwani

 *

 * Copyright (C) 2003 Ralf Baechle <ralf@linux-mips.org>

 *

 * Copyright (C) 2004-2006 MontaVista Software, Inc.

 *			   Dale Farnsworth <dale@farnsworth.org>

 *

 * Copyright (C) 2004 Steven J. Hill <sjhill1@rockwellcollins.com>

 *				     <sjhill@realitydiluted.com>

 *

 * Copyright (C) 2007-2008 Marvell Semiconductor

 *			   Lennert Buytenhek <buytenh@marvell.com>

 *

 * Copyright (C) 2013 Michael Stapelberg <michael@stapelberg.de>

/*

 * Registers shared between all ports.

/*

 * Main per-port registers.  These live at offset 0x0400 for

 * port #0, 0x0800 for port #1, and 0x0c00 for port #2.

/*

 * Misc per-port registers.

/*

 * SDMA configuration register default value.

/*

 * Misc definitions.

 Max number of allowed TCP segments for software TSO */

/*

 * RX/TX descriptors.

 Descriptor buffer byte count		*/

 Buffer size				*/

 Descriptor command status		*/

 Next descriptor pointer		*/

 Descriptor buffer pointer		*/

 buffer byte count			*/

 CPU provided TCP checksum		*/

 Command/status field			*/

 Pointer to next descriptor		*/

 pointer to buffer for this descriptor*/

 Descriptor command status		*/

 Buffer size				*/

 Descriptor buffer byte count		*/

 Descriptor buffer pointer		*/

 Next descriptor pointer		*/

 Command/status field			*/

 CPU provided TCP checksum		*/

 buffer byte count			*/

 pointer to buffer for this descriptor*/

 Pointer to next descriptor		*/

 RX & TX descriptor command */

 RX & TX descriptor status */

 RX descriptor status */

 TX descriptor command */

 global *******************************************************************/

	/*

	 * Ethernet controller base address.

	/*

	 * Per-port MBUS window access register value.

	/*

	 * Hardware-specific parameters.

 per-port *****************************************************************/

 Non MIB hardware counters */

 array to track the type of the dma mapping */

	/*

	 * RX state.

	/*

	 * TX state.

	/*

	 * Hardware-specific parameters.

 port register accessors **************************************************/

 rxq/txq helper functions *************************************************/

		/*

		 * Update statistics.

		 *

		 * Note that the descriptor byte count includes 2 dummy

		 * bytes automatically inserted by the hardware at the

		 * start of the packet (which we don't count), and a 4

		 * byte CRC at the end of the packet (which we do count).

		/*

		 * In case we received a packet without first / last bits

		 * on, or the error summary bit is set, the packet needs

		 * to be dropped.

		/*

		 * The -4 is for the CRC in the trailer of the

		 * received packet

		/*

		 * The hardware automatically prepends 2 bytes of

		 * dummy data to each received packet, so that the

		 * IP header ends up 16-byte aligned.

 tx ***********************************************************************/

		/* TODO: Revisit this. With the usage of GEN_TCP_UDP_CHK_FULL

		 * it seems we don't need to pass the initial checksum.

 Errata BTS #50, IHL must be 5 if no HW checksum */

 Copy unaligned small data fragment to TSO header data area */

 Alignment is okay, map buffer and hand off to hardware */

 last descriptor in the TCP packet */

 last descriptor in SKB */

	/* Should we set this? Can't use the value from skb_tx_csum()

	 * as it's not the correct initial L4 checksum to use.

	/* Defer updating the first command descriptor until all

	 * following descriptors have been written.

 Count needed descriptors */

 Initialize the TSO handler, and prepare the first payload */

 prepare packet headers: MAC + IP + TCP */

 ensure all other descriptors are written before first cmd_sts */

 clear TX_END status */

 ensure all descriptors are written before poking hardware */

	/* TODO: Release all used data descriptors; header descriptors must not

	 * be DMA-unmapped.

		/*

		 * The last fragment will generate an interrupt

		 * which will free the skb on TX completion.

 ensure all other descriptors are written before first cmd_sts */

 clear TX_END status */

 ensure all descriptors are written before poking hardware */

 tx napi ******************************************************************/

 tx rate control **********************************************************/

/*

 * Set total maximum TX rate (shared by all TX queues for this port)

 * to 'rate' bits per second, with a maximum burst of 'burst' bytes.

	/*

	 * Turn on fixed priority mode.

 mii management interface *************************************************/

 enable auto negotiation */

 force gigabit, half duplex not supported */

 statistics ***************************************************************/

 Clear non MIB hw counters also */

 Non MIB hardware counters */

 interrupt coalescing *****************************************************/

/*

 * Hardware coalescing parameters are set in units of 64 t_clk

 * cycles.  I.e.:

 *

 *	coal_delay_in_usec = 64000000 * register_value / t_clk_rate

 *

 *	register_value = coal_delay_in_usec * t_clk_rate / 64000000

 *

 * In the ->set*() methods, we round the computed register value

 * to the nearest integer.

 ethtool ******************************************************************/

	/*

	 * The MAC does not support 1000baseT_Half.

	/* Given that mv643xx_eth works without the marvell-specific PHY driver,

	 * this debugging hint is useful to have.

	/*

	 * The MAC does not support 1000baseT_Half.

 address handling *********************************************************/

 Allocate both mc_spec and mc_other tables */

 rx/tx queue initialisation ***********************************************/

	/* A queue must always have room for at least one skb.

	 * Therefore, stop the queue when the free entries reaches

	 * the maximum number of descriptors per skb.

 Allocate DMA buffers for TSO MAC/IP/TCP headers */

 netdev ops and related ***************************************************/

	/*

	 * Perform PHY reset, if there is a PHY.

	/*

	 * Configure basic link parameters.

	/*

	 * Configure TX path and queues.

	/*

	 * Receive all unmatched unicast, TCP, UDP, BPDU and broadcast

	 * frames to RX queue #0, and include the pseudo-header when

	 * calculating receive checksums.

	/*

	 * Treat BPDUs as normal multicasts, and disable partition mode.

	/*

	 * Add configured unicast addresses to address filter table.

	/*

	 * Enable the receive queues.

	/*

	 * Reserve 2+14 bytes for an ethernet header (the hardware

	 * automatically prepends 2 bytes of dummy data to each

	 * received packet), 16 bytes for up to four VLAN tags, and

	 * 4 bytes for the trailing FCS -- 36 bytes total.

	/*

	 * Make sure that the skb size is a multiple of 8 bytes, as

	 * the lower three bits of the receive descriptor's buffer

	 * size field are ignored by the hardware.

	/*

	 * If NET_SKB_PAD is smaller than a cache line,

	 * netdev_alloc_skb() will cause skb->data to be misaligned

	 * to a cache line boundary.  If this is the case, include

	 * some extra space to allow re-aligning the data area.

 Reset the Enable bit in the Configuration Register */

	/*

	 * Stop and then re-open the interface. This will allocate RX

	 * skbs of the new MTU.

	 * There is a possible danger that the open will not succeed,

	 * due to memory being full.

 platform glue ************************************************************/

	/*

	 * Check whether we have a 14-bit coal limit field in bits

	 * [21:8], or a 16-bit coal limit in bits [25,21:7] of the

	 * SDMA config register.

	/*

	 * Check whether the MAC supports TX rate control, and if

	 * yes, whether its associated registers are in the old or

	 * the new place.

 bail out if not registered from DT */

	/*

	 * (Re-)program MBUS remapping windows if we are asked to.

	/* Historical default if unspecified. We could also read/write

	 * the interface state in the PSC1

 Attempt to connect to the PHY using orion-mdio */

	/* Kirkwood resets some registers on gated clocks. Especially

	 * CLK125_BYPASS_EN must be cleared but is not available on

	 * all other SoCs/System Controllers using this driver.

	/*

	 * Start with a default rate, and if there is a clock, allow

	 * it to override the default.

 MTU range: 64 - 9500 */

 Mask all interrupts on ethernet port */

 SPDX-License-Identifier: GPL-2.0

/*

 * RSS and Classifier helpers for Marvell PPv2 Network Controller

 *

 * Copyright (C) 2014 Marvell

 *

 * Marcin Wojtas <mw@semihalf.com>

 TCP over IPv4 flows, Not fragmented, no vlan tag */

 TCP over IPv4 flows, Not fragmented, with vlan tag */

 TCP over IPv4 flows, fragmented, no vlan tag */

 TCP over IPv4 flows, fragmented, with vlan tag */

 UDP over IPv4 flows, Not fragmented, no vlan tag */

 UDP over IPv4 flows, Not fragmented, with vlan tag */

 UDP over IPv4 flows, fragmented, no vlan tag */

 UDP over IPv4 flows, fragmented, with vlan tag */

 TCP over IPv6 flows, not fragmented, no vlan tag */

 TCP over IPv6 flows, not fragmented, with vlan tag */

 TCP over IPv6 flows, fragmented, no vlan tag */

 TCP over IPv6 flows, fragmented, with vlan tag */

 UDP over IPv6 flows, not fragmented, no vlan tag */

 UDP over IPv6 flows, not fragmented, with vlan tag */

 UDP over IPv6 flows, fragmented, no vlan tag */

 UDP over IPv6 flows, fragmented, with vlan tag */

 IPv4 flows, no vlan tag */

 IPv4 flows, with vlan tag */

 IPv6 flows, no vlan tag */

 IPv6 flows, with vlan tag */

 Non IP flow, no vlan tag */

 Non IP flow, with vlan tag */

 Update classification flow table registers */

 Update classification lookup table register */

 Operations on flow entry */

 Initialize the parser entry for the given flow */

 Initialize the Lookup Id table entry for the given flow */

 The default RxQ for this port is set in the C2 lookup */

	/* We point on the first lookup in the sequence for the flow, that is

	 * the C2 lookup.

 CLS is always enabled, RSS is enabled/disabled in C2 lookup */

 Writing TCAM_DATA4 flushes writes to TCAM_DATA0-4 and INV to HW */

 Initialize the flow table entries for the given flow */

 Assign default values to all entries in the flow */

 RSS config C2 lookup */

 Add all ports */

 C3Hx lookups */

		/* Set a default engine. Will be overwritten when setting the

		 * real HEK parameters

 Adds a field to the Header Extracted Key generation parameters*/

 Clear old fields */

 Returns the size, in bits, of the corresponding HEK field */

/* Set the hash generation options for the given traffic flow.

 * One traffic flow (in the ethtool sense) has multiple classification flows,

 * to handle specific cases such as fragmentation, or the presence of a

 * VLAN / DSA Tag.

 *

 * Each of these individual flows has different constraints, for example we

 * can't hash fragmented packets on L4 data (else we would risk having packet

 * re-ordering), so each classification flows masks the options with their

 * supported ones.

 *

		/* Use C3HB engine to access L4 infos. This adds L4 infos to the

		 * hash parameters

/* Returns the hash opts for this flow. There are several classifier flows

 * for one traffic flow, this returns an aggregation of all configurations.

 Match on Lookup Type */

 Update RSS status after matching this entry */

 Mark packet as "forwarded to software", needed for RSS */

	/* Configure the default rx queue : Update Queue Low and Queue High, but

	 * don't lock, since the rx queue selection might be overridden by RSS

 Classifier default initialization */

 Enable classifier */

 Clear classifier flow table */

 Clear classifier lookup table */

 Clear C2 TCAM engine table */

	/* Disable the FIFO stages in C2 engine, which are only used in BIST

	 * mode

 Set way for the port */

	/* Pick the entry to be accessed in lookup ID decoding table

	 * according to the way and lkpid.

 Set initial CPU queue for receiving packets */

 Disable classification engines */

 Update lookup ID table entry */

	/* The RxQ number is used to select the RSS table. It that case, we set

	 * it to be the ctx number.

 Reset the default destination RxQ to the port's first rx queue. */

 Clear the port map so that the entry doesn't match anymore */

 Set CPU queue number for oversize packets */

 Match on Lookup Type */

		/* We want to keep the default color derived from the Header

		 * Parser drop entries, for VLAN and MAC filtering. This will

		 * assign a default color of Green or Red, and we want matches

		 * with a non-drop action to keep that color.

 Update RSS status after matching this entry */

		/* Always lock the RSS_EN decision. We might have high prio

		 * rules steering to an RXQ, and a lower one steering to RSS,

		 * we don't want the low prio RSS rule overwriting this flag.

 Mark packet as "forwarded to software", needed for RSS */

 Get the global ctx number */

	/* The order of insertion in C2 tcam must match the order in which

	 * the fields are found in the header

 Don't update the offset yet */

			/* VLAN pri is always at offset 13 relative to the

			 * current offset

		/* vlan id and prio always seem to take a full 16-bit slot in

		 * the Header Extracted Key.

	/* When both an RSS context and an queue index are set, the index

	 * is considered as an offset to be added to the indirection table

	 * entries. We don't support this, so reject this rule.

	/* For now, only use the C2 engine which has a HEK size limited to 64

	 * bits for TCAM matching.

	/* We need to manually set the rss_ctx, since this info isn't present

	 * in info->fs

 Replace an already existing rule */

 Remove the rule from the engines. */

 Number of RXQs per CPU */

 CPU that will handle this rx queue */

	/* Indirection to better distribute the paquets on the CPUs when

	 * configuring the RSS queues.

 Find the first free RSS table */

	/* Set the table width: replace the whole classifier Rx queue number

	 * with the ones configured in RSS table entries.

	/* Find the first available context number in the port, starting from 1.

	 * Context 0 on each port is reserved for the default context.

 Invalidate any active classification rule that use this context */

	/* Configure the first table to evenly distribute the packets across

	 * real Rx Queues. The table entries map a hash to a port Rx Queue.

 Configure default flows */

 SPDX-License-Identifier: GPL-2.0

/*

 * Driver for Marvell PPv2 network controller for Armada 375 SoC.

 *

 * Copyright (C) 2014 Marvell

 *

 * Marcin Wojtas <mw@semihalf.com>

/* The prototype is added here to be used in start_dev when using ACPI. This

 * will be removed once phylink is used for all modes (dt+ACPI).

 Queue modes */

 Utility/helper methods */

 internal DMA mapping in page_pool */

/* These accessors should be used to access:

 *

 * - per-thread registers, where each thread has its own copy of the

 *   register.

 *

 *   MVPP2_BM_VIRT_ALLOC_REG

 *   MVPP2_BM_ADDR_HIGH_ALLOC

 *   MVPP22_BM_ADDR_HIGH_RLS_REG

 *   MVPP2_BM_VIRT_RLS_REG

 *   MVPP2_ISR_RX_TX_CAUSE_REG

 *   MVPP2_ISR_RX_TX_MASK_REG

 *   MVPP2_TXQ_NUM_REG

 *   MVPP2_AGGR_TXQ_UPDATE_REG

 *   MVPP2_TXQ_RSVD_REQ_REG

 *   MVPP2_TXQ_RSVD_RSLT_REG

 *   MVPP2_TXQ_SENT_REG

 *   MVPP2_RXQ_NUM_REG

 *

 * - global registers that must be accessed through a specific thread

 *   window, because they are related to an access to a per-thread

 *   register

 *

 *   MVPP2_BM_PHY_ALLOC_REG    (related to MVPP2_BM_VIRT_ALLOC_REG)

 *   MVPP2_BM_PHY_RLS_REG      (related to MVPP2_BM_VIRT_RLS_REG)

 *   MVPP2_RXQ_THRESH_REG      (related to MVPP2_RXQ_NUM_REG)

 *   MVPP2_RXQ_DESC_ADDR_REG   (related to MVPP2_RXQ_NUM_REG)

 *   MVPP2_RXQ_DESC_SIZE_REG   (related to MVPP2_RXQ_NUM_REG)

 *   MVPP2_RXQ_INDEX_REG       (related to MVPP2_RXQ_NUM_REG)

 *   MVPP2_TXQ_PENDING_REG     (related to MVPP2_TXQ_NUM_REG)

 *   MVPP2_TXQ_DESC_ADDR_REG   (related to MVPP2_TXQ_NUM_REG)

 *   MVPP2_TXQ_DESC_SIZE_REG   (related to MVPP2_TXQ_NUM_REG)

 *   MVPP2_TXQ_INDEX_REG       (related to MVPP2_TXQ_NUM_REG)

 *   MVPP2_TXQ_PENDING_REG     (related to MVPP2_TXQ_NUM_REG)

 *   MVPP2_TXQ_PREF_BUF_REG    (related to MVPP2_TXQ_NUM_REG)

 *   MVPP2_TXQ_PREF_BUF_REG    (related to MVPP2_TXQ_NUM_REG)

 Get number of maximum RXQ */

	/* According to the PPv2.2 datasheet and our experiments on

	 * PPv2.1, RX queues have an allocation granularity of 4 (when

	 * more than a single one on PPv2.2).

	 * Round up to nearest multiple of 4.

 Get number of physical egress port */

 Get number of physical TXQ */

 Returns a struct page if page_pool is set, otherwise a buffer */

 Buffer Manager configuration routines */

 Create pool */

	/* Number of buffer pointers must be a multiple of 16, as per

	 * hardware constraints

	/* PPv2.1 needs 8 bytes per buffer pointer, PPv2.2 and PPv2.3 needs 16

	 * bytes per buffer pointer

 Set 8 Pools BPPI threshold for MVPP23 */

 Set pool buffer size */

 Free all buffers from the pool */

 Update BM driver with number of buffers removed from pool */

 Check number of buffers in BM pool */

 HW has one buffer ready which is not reflected in the counters */

 Cleanup pool */

 Check buffer counters after free */

 Create all pools with maximum size */

 Routine enable PPv23 8 pool mode */

 the pool in use */

 Mask BM all interrupts */

 Clear BM cause register */

 Allocate and initialize BM pools */

 Short pool */

 Long pool */

 Jumbo pool */

 Attach long pool to rxq */

 Get queue physical ID */

 Attach short pool to rxq */

 Get queue physical ID */

 Routine enable flow control for RXQs condition */

	/* Remove Flow control enable bit to prevent race between FW and Kernel

	 * If Flow control was enabled, it would be re-enabled.

 Set same Flow control for all RXQs */

 Set stop and start Flow control RXQ thresholds */

 Set RXQ port ID */

		/* Calculate RXQ host ID:

		 * In Single queue mode: Host ID equal to Host ID used for

		 *			 shared RX interrupt

		 * In Multi queue mode: Host ID equal to number of

		 *			RXQ ID / number of CoS queues

		 * In Single resource mode: Host ID always equal to 0

 Set RXQ host ID */

 Notify Firmware that Flow control config space ready for update */

 Routine disable flow control for RXQs condition */

	/* Remove Flow control enable bit to prevent race between FW and Kernel

	 * If Flow control was enabled, it would be re-enabled.

 Disable Flow control for all RXQs */

 Set threshold 0 to disable Flow control */

 Notify Firmware that Flow control config space ready for update */

 Routine disable/enable flow control for BM pool condition */

	/* Remove Flow control enable bit to prevent race between FW and Kernel

	 * If Flow control were enabled, it would be re-enabled.

 Check if BM pool should be enabled/disable */

 Set BM pool start and stop thresholds per port */

 Remove BM pool from the port */

		/* Zero BM pool start and stop thresholds to disable pool

		 * flow control if pool empty (not used by any port)

 Notify Firmware that Flow control config space ready for update */

 disable/enable flow control for BM pool on all ports */

	/* Enable global flow control. In this stage global

	 * flow control enabled, but still disabled per port.

 Check if Firmware running and disable FC if not*/

 Release buffer to BM */

	/* MVPP2_BM_VIRT_RLS_REG is not interpreted by HW, and simply

	 * returned in the "cookie" field of the RX

	 * descriptor. Instead of storing the virtual address, we

	 * store the physical address

 Allocate buffers for the pool */

 Update BM driver with number of buffers added to pool */

/* Notify the driver that BM pool is being used as specific type and return the

 * pool pointer on success

	/* Allocate buffers in case BM pool is used as long pool, but packet

	 * size doesn't match MTU or BM pool hasn't being used yet

		/* Set default buffer number or free all the buffers in case

		 * the pool is not empty

 Allocate buffers for this pool */

	/* Allocate buffers in case BM pool is used as long pool, but packet

	 * size doesn't match MTU or BM pool hasn't being used yet

		/* Set default buffer number or free all the buffers in case

		 * the pool is not empty

 Allocate buffers for this pool */

 Initialize pools for swf, shared buffers variant */

	/* If port pkt_size is higher than 1518B:

	 * HW Long pool - SW Jumbo pool, HW Short pool - SW Long pool

	 * else: HW Long pool - SW Long pool, HW Short pool - SW Short pool

 Initialize pools for swf, percpu buffers variant */

	/* Update L4 checksum when jumbo enable/disable on port.

	 * Only port 0 supports hardware checksum offload due to

	 * the Tx FIFO size limitation.

	 * Also, don't set NETIF_F_HW_CSUM because L3_offset in TX descriptor

	 * has 7 bits, so the maximum L3 offset is 128.

	/* If port MTU is higher than 1518B:

	 * HW Long pool - SW Jumbo pool, HW Short pool - SW Long pool

	 * else: HW Long pool - SW Long pool, HW Short pool - SW Short pool

 Remove port from old short & long pool */

 Add port to new short & long pool */

 Update L4 checksum when jumbo enable/disable on port */

/* Mask the current thread's Rx/Tx interrupts

 * Called by on_each_cpu(), guaranteed to run with migration disabled,

 * using smp_processor_id() is OK.

 If the thread isn't used, don't do anything */

/* Unmask the current thread's Rx/Tx interrupts.

 * Called by on_each_cpu(), guaranteed to run with migration disabled,

 * using smp_processor_id() is OK.

 If the thread isn't used, don't do anything */

 Only GOP port 0 has an XLG MAC */

 Port configuration routines */

/* Set Flow Control timer x100 faster than pause quanta to ensure that link

 * partner won't send traffic if port is in XOFF mode.

 Enable the GMAC link status irq for this port */

 Enable the XLG/GIG irqs for this port */

/* Sets the PHY mode of the COMPHY (which configures the serdes lanes).

 *

 * The PHY mode used by the PPv2 driver comes from the network subsystem, while

 * the one given to the COMPHY comes from the generic PHY subsystem. Hence they

 * differ.

 *

 * The COMPHY configures the serdes lanes regardless of the actual use of the

 * lanes by the physical layer. This is why configurations like

 * "PPv2 (2500BaseX) - COMPHY (2500SGMII)" are valid.

 Set IEEE 802.3x Flow Control Xon Packet Transmission Mode */

 Configure loopback port */

/* Some counters are accessed indirectly by first writing an index to

 * MVPP2_CTRS_IDX. The index can represent various resources depending on the

 * register we access, it can be a hit counter for some classification tables,

 * a counter specific to a rxq, a txq or a buffer pool.

/* Due to the fact that software statistics and hardware statistics are, by

 * design, incremented at different moments in the chain of packet processing,

 * it is very likely that incoming packets could have been dropped after being

 * counted by hardware but before reaching software statistics (most probably

 * multicast packets), and in the oppposite way, during transmission, FCS bytes

 * are added in between as well as TSO skb will be split and header bytes added.

 * Hence, statistics gathered from userspace with ifconfig (software) and

 * ethtool (hardware) cannot be compared.

 Gather XDP Statistics */

	/* Rxqs are numbered from 0 from the user standpoint, but not from the

	 * driver's. We need to add the  port->first_rxq offset.

 Gather XDP Statistics */

	/* No need to read again the counters right after this function if it

	 * was called asynchronously by the user (ie. use of ethtool).

	/* Update statistics for the given port, then take the lock to avoid

	 * concurrent accesses on the ethtool_stats structure during its copy.

 Change maximum receive size of the port */

 Change maximum receive size of the port */

 Set defaults to the MVPP2 port */

 Update TX FIFO MIN Threshold */

 Min. TX threshold must be less than minimal packet length */

 Disable Legacy WRR, Disable EJP, Release from reset */

 Set TXQ scheduling to Round-Robin */

 Close bandwidth for all queues */

	/* Set refill period to 1 usec, refill tokens

	 * and bucket size to maximum

 Set MaximumLowLatencyPacketSize value to 256 */

 Enable Rx cache snoop */

 At default, mask all interrupts to all present cpus */

 Enable/disable receiving packets */

/* Enable transmit via physical egress queue

 * - HW starts take descriptors from DRAM

 Enable all initialized TXs. */

/* Disable transmit via physical egress queue

 * - HW doesn't take descriptors from DRAM

 Issue stop command for active channels only */

 Wait for all Tx activity to terminate. */

		/* Check port TX Command register that all

		 * Tx queues are stopped

 Rx descriptors helper methods */

 Get number of Rx descriptors occupied by received packets */

/* Update Rx queue status with the number of occupied and available

 * Rx descriptor slots.

	/* Decrement the number of used descriptors and increment count

	 * increment the number of free descriptors.

 Get pointer to next RX descriptor to be processed by SW */

 Set rx queue offset */

 Convert offset from bytes to units of 32 bytes */

 Offset is in */

 Tx descriptors helper methods */

 Get pointer to next Tx descriptor to be processed (send) by HW */

/* Update HW with number of aggregated Tx descriptors to be sent

 *

 * Called only from mvpp2_tx(), so migration is disabled, using

 * smp_processor_id() is OK.

 aggregated access - relevant TXQ number is written in TX desc */

/* Check if there are enough free descriptors in aggregated txq.

 * If not, update the number of occupied descriptors and repeat the check.

 *

 * Called only from mvpp2_tx(), so migration is disabled, using

 * smp_processor_id() is OK.

 Update number of occupied aggregated Tx descriptors */

/* Reserved Tx descriptors allocation request

 *

 * Called only from mvpp2_txq_reserved_desc_num_proc(), itself called

 * only by mvpp2_tx(), so migration is disabled, using

 * smp_processor_id() is OK.

/* Check if there are enough reserved descriptors for transmission.

 * If not, request chunk of reserved descriptors and check again.

	/* Not enough descriptors reserved! Update the reserved descriptor

	 * count and check again.

 Compute total of used descriptors */

 OK, the descriptor could have been updated: check again. */

/* Release the last allocated Tx descriptor. Useful to handle DMA

 * mapping failures in the Tx path.

 Set Tx descriptors fields relevant for CSUM calculation */

	/* fields: L3_offset, IP_hdrlen, L3_type, G_IPv4_chk,

	 * G_L4_chk, L4_type required only for checksum calculation

 enable IPv4 csum */

 enable IPv4 */

 enable IPv6 */

 enable TCP */

 generate L4 csum */

 enable UDP */

 generate L4 csum */

/* Get number of sent descriptors and decrement counter.

 * The number of sent descriptors is returned.

 * Per-thread access

 *

 * Called only from mvpp2_txq_done(), called from mvpp2_tx()

 * (migration disabled) and from the TX completion tasklet (migration

 * disabled) so using smp_processor_id() is OK.

 Reading status reg resets transmitted descriptor counter */

/* Called through on_each_cpu(), so runs on all CPUs, with migration

 * disabled, therefore using smp_processor_id() is OK.

 If the thread isn't used, don't do anything */

 Set max sizes for Tx queues */

 WA for wrong Token bucket update: Set MTU value = 3*real MTU value */

 Indirect access to registers */

 Set MTU */

 TXP token size and all TXQs token size must be larger that MTU */

 Set the number of non-occupied descriptors threshold */

/* Set the number of packets that will be received before Rx interrupt

 * will be generated by HW.

 For some reason in the LSP this is done on each CPU. Why ? */

 PKT-coalescing registers are per-queue + per-thread */

 Set the time delay in usec before Rx interrupt */

 re-evaluate to get actual register value */

 re-evaluate to get actual register value */

 Free Tx queue skbuffs */

 need for xdp_return_frame_bulk */

 Handle end of transmission */

 Rx/Tx queue initialization/cleanup methods */

 Allocate and initialize descriptors for aggr TXQ */

 Allocate memory for TX descriptors */

 Aggr TXQ no reset WA */

	/* Set Tx descriptors queue starting address indirect

	 * access

 Create a specified Rx queue */

 Allocate memory for RX descriptors */

 Zero occupied and non-occupied counters - direct access */

 Set Rx descriptors queue starting address - indirect access */

 Set Offset */

 Set coalescing pkts and time */

 Set the number of non occupied descriptors threshold */

 Add number of descriptors ready for receiving packets */

 Every RXQ has a pool for short and another for long packets */

 Push packets received by the RXQ to BM pool */

 Cleanup Rx queue */

	/* Clear Rx descriptors queue starting address and size;

	 * free descriptor number

 Create and initialize a Tx queue */

 Allocate memory for Tx descriptors */

 Set Tx descriptors queue starting address - indirect access */

	/* Calculate base address in prefetch buffer. We reserve 16 descriptors

	 * for each existing TXQ.

	 * TCONTS for PON port must be continuous from 0 to MVPP2_MAX_TCONT

	 * GBE ports assumed to be continuous from 0 to MVPP2_MAX_PORTS

 WRR / EJP configuration - indirect access */

 Free allocated TXQ resources */

 Set minimum bandwidth for disabled TXQs */

 Set Tx descriptors queue starting address and size */

 Cleanup Tx ports */

	/* The napi queue has been stopped so wait for all packets

	 * to be transmitted.

 Release all packets */

 Reset queue */

 Cleanup all Tx queues */

 Reset Tx ports and delete Tx queues */

 Cleanup all Rx queues */

 Init all Rx queues for port */

 Init all tx queues for port */

 Assign this queue to a CPU */

 The callback for per-port interrupt */

 Per-port interrupt for link status changes */

 Check the external status register */

		/* If it's not the XLG, we must be using the GMAC.

		 * Check the summary status.

 Process all the Tx queues */

 Set the timer in case not all the packets were processed */

 Main RX/TX processing routines */

 Display more error info */

 Handle RX checksum offload */

 Allocate a new skb and add it to BM pool */

 Handle tx checksum */

 Calculate IPv4 checksum and L4 checksum */

 Read l4_protocol from one of IPv6 extra headers */

 Enable transmit */

 Finalize TX processing */

 Check number of available descriptors */

 Get a descriptor for the first part of the packet */

 XDP_REDIRECT or AF_XDP */

 XDP_TX */

	/* The first of the TX queues are used for XPS,

	 * the second half for XDP_TX

	/* The first of the TX queues are used for XPS,

	 * the second half for XDP_TX

 Due xdp_adjust_tail: DMA sync for_device cover max len CPU touch */

 Main rx processing */

 Get number of received packets and clamp the to-do */

 Buffer header not supported */

		/* In case of an error, release the requested buffer pointer

		 * to the Buffer Manager. This request process is controlled

		 * by the hardware, and the information about the buffer is

		 * comprised by the RX descriptor.

 Prefetch header */

		/* If we have RX hardware timestamping enabled, grab the

		 * timestamp from the queue and convert.

 Return the buffer to the pool */

 xdp */

 Update Rx queue management counters */

 We only need to clear the low bits */

 Direct PTP Sync messages to queue 1 */

 Take a reference on the skb and insert into our queue */

	/*

	 * 3:0		- PTPAction

	 * 6:4		- PTPPacketFormat

	 * 7		- PTP_CF_WraparoundCheckEn

	 * 9:8		- IngressTimestampSeconds[1:0]

	 * 10		- Reserved

	 * 11		- MACTimestampingEn

	 * 17:12	- PTP_TimestampQueueEntryID[5:0]

	 * 18		- PTPTimestampQueueSelect

	 * 19		- UDPChecksumUpdateEn

	 * 27:20	- TimestampOffset

	 *			PTP, NTPTransmit, OWAMP/TWAMP - L3 to PTP header

	 *			NTPTs, Y.1731 - L3 to timestamp entry

	 * 35:28	- UDP Checksum Offset

	 *

	 * stored in tx descriptor bits 75:64 (11:0) and 191:168 (35:12)

 Handle tx fragmentation processing */

 Last descriptor */

 Descriptor in the middle: Not First, Not Last */

	/* Release all descriptors that were used to map fragments of

	 * this packet, as well as the corresponding DMA mappings

 Check number of available descriptors */

 Main tx processing */

 Check number of available descriptors */

 Get a descriptor for the first part of the packet */

 First and Last descriptor */

 First but not Last */

 Continue with other skb fragments */

 Enable transmit */

 Finalize TX processing */

 Set the timer in case not all frags were processed */

	/* Rx/Tx cause register

	 *

	 * Bits 0-15: each bit indicates received packets on the Rx queue

	 * (bit 0 is for Rx queue 0).

	 *

	 * Bits 16-23: each bit indicates transmitted packets on the Tx queue

	 * (bit 16 is for Tx queue 0).

	 *

	 * Each CPU has its own Rx/Tx cause register

 Clear the cause register */

 Process RX packets */

			/* Clear the bit associated to this Rx queue

			 * so that next iteration will continue from

			 * the next Rx queue.

 Set the GMAC & XLG MAC in reset */

 Set the MPCS and XPCS in reset */

 comphy reconfiguration */

 gop reconfiguration */

 Set hw internals when starting port */

 Enable interrupts on all threads */

 Set hw internals when stopping port */

 Disable interrupts on all threads */

	/* The Tx ring size cannot be smaller than the minimum number of

	 * descriptors needed for TSO.

 Allocate the Rx/Tx queues */

 In default link is down */

 Unmask interrupts on all CPUs */

 Start hardware statistics gathering */

 Mask interrupts on all threads */

 Clear the whole UC and MC list */

 Reconfigure parser accept the original MAC address */

/* Shut down all the ports, reconfigure the pools as percpu or shared,

 * then bring up again all ports.

 nrxqs is the same for all ports */

 No port is using jumbo frames */

 Reconfigure BM to the original MTU */

 All pools are equal in terms of DMA direction */

 It seems we must also release the TX reset when enabling the TSU */

			/* Invalidate all registered VID filters for this

			 * port

 device is up and bpf is added/removed, must setup the RX queues */

 bpf is just replaced, RXQ and MTU are already setup */

 device was up, restore the link */

 Check Page Pool DMA Direction */

 Ethtool methods */

 Set interrupt coalescing for ethtools */

 get coalescing for ethtools */

	/* The interface is running, so we have to force a

	 * reallocation of the queues

 Reallocate Rx queues with the original ring size */

 Reallocate Tx queues with the original ring size */

 Device ops */

/* Used for PPv2.1, or PPv2.2 with the old Device Tree binding that

 * had a single IRQ defined per-port.

 Configure Rx queue group interrupt for this port */

 Handle the more complicated PPv2.2 and PPv2.3 case */

 Initialize port HW */

 Checks for hardware constraints */

 Disable port */

	/* Associate physical Tx queues to this port and initialize.

	 * The mapping is predefined.

 Allocate and initialize Rx queue for this port */

 Map physical Rx queue to port's logical Rx queue */

 Map this Rx queue to a physical queue */

 Create Rx descriptor rings */

 Port default configuration */

 Port's classifier configuration */

 Provide an initial Rx packet size */

 Initialize pools for swf */

 Clear all port stats */

/* Checks if the port dt description has the required Tx interrupts:

 * - PPv2.1: there are no such interrupts.

 * - PPv2.2 and PPv2.3:

 *   - The old DTs have: "rx-shared", "tx-cpuX" with X in [0...3]

 *   - The new ones have: "hifX" with X in [0..8]

 *

 * All those variants are supported to keep the backward compatibility.

 ACPI */

 SGMII mode receives the speed and duplex from PHY */

 802.3z mode has fixed speed and duplex */

			/* The FLOW_CTRL_AUTONEG bit selects either the hardware

			 * automatically or the bits in MVPP22_GMAC_CTRL_4_REG

			 * manually controls the GMAC pause modes.

 Configure advertisement bits */

 We are only interested in the advertisement bits changing */

	/* When in 802.3z mode, we must have AN enabled:

	 * Bit 2 Field InBandAnEn In-band Auto-Negotiation enable. ...

	 * When <PortType> = 1 (1000BASE-X) this field must be set to 1.

 Wait for reset to deassert */

 Configure port type */

 Configure negotiation style */

		/* Phy or fixed speed - no in-band AN, nothing to do, leave the

		 * configured speed, duplex and flow control as-is.

		/* SGMII in-band mode receives the speed and duplex from

		/* 1000BaseX and 2500BaseX ports cannot negotiate speed nor can

		 * they negotiate duplex: they are always operating with a fixed

		 * speed of 1000/2500Mbps in full duplex, so force 1000/2500

		 * speed and full duplex here.

 Check for invalid configuration */

		/* Force the link down when changing the interface or if in

		 * in-band mode to ensure we do not change the configuration

		 * while the hardware is indicating link is up. We force both

		 * XLG and GMAC down to ensure that they're both in a known

		 * state.

 Make sure the port is disabled when reconfiguring the mode */

 Place GMAC into reset */

 Reconfigure the serdes lanes */

	/* Select the appropriate PCS operations depending on the

	 * configured interface mode. We will only switch to a mode

	 * that the validate() checks have already passed.

 mac (re)configuration */

 Unmask interrupts */

 Release GMAC reset and wait */

	/* Allow the link to come up if in in-band mode, otherwise the

	 * link is forced via mac_link_down()/mac_link_up()

		/* We can always update the flow control enable bits;

		 * these will only be effective if flow control AN

		 * (MVPP2_GMAC_FLOW_CTRL_AUTONEG) is disabled.

 Work-around for ACPI */

	/* Phylink isn't used as of now for ACPI, so the MAC has to be

	 * configured manually when the interface is started. This will

	 * be removed as soon as the phylink ACPI support lands in.

/* In order to ensure backward compatibility for ACPI, check if the port

 * firmware node comprises the necessary description allowing to use phylink.

 Ports initialization */

	/*

	 * Rewrite 10GBASE-KR to 10GBASE-R for compatibility with existing DT.

	 * Existing usage of 10GBASE-KR is not correct; no backplane

	 * negotiation is done, and this driver does not actually support

	 * 10GBASE-KR.

 the link irq is optional */

		/* We may want a property to describe whether we should use

		 * MAC hardware timestamping.

 Alloc per-cpu and ethtool stats */

 MTU range: 68 - 9704 */

 9704 == 9728 - 20 and rounding to 8 */

			/* If a COMPHY is present, we can support any of the

			 * serdes modes and switch between them.

 No COMPHY, with only 2500BASE-X mode supported */

			/* No COMPHY, we can switch between 1000BASE-X and SGMII

	/* Cycle the comphy to power it down, saving 270mW per port -

	 * don't worry about an error powering it up. When the comphy

	 * driver does this, we can remove this code.

 Ports removal routine */

 Initialize decoding windows */

 Initialize Rx FIFO's */

/* Initialize TX FIFO's: the total FIFO size is 48kB on PPv2.2 and PPv2.3.

 * 4kB fixed space must be assigned for the loopback port.

 * Redistribute remaining avialable 44kB space among all active ports.

 * Guarantee minimum 32kB for 10G port and 8kB for port 1, capable of 2.5G

 * SGMII link.

 The loopback requires fixed 4kB of the FIFO space assignment. */

 Set RX FIFO size to 0 for inactive ports. */

 Assign remaining RX FIFO space among all active ports. */

 Configure Rx FIFO Flow control thresholds */

	/* Port 0: maximum speed -10Gb/s port

	 *	   required by spec RX FIFO threshold 9KB

	 * Port 1: maximum speed -5Gb/s port

	 *	   required by spec RX FIFO threshold 4KB

	 * Port 2: maximum speed -1Gb/s port

	 *	   required by spec RX FIFO threshold 2KB

 Without loopback port */

 Configure Rx FIFO Flow control thresholds */

/* Initialize TX FIFO's: the total FIFO size is 19kB on PPv2.2 and PPv2.3.

 * 1kB fixed space must be assigned for the loopback port.

 * Redistribute remaining avialable 18kB space among all active ports.

 * The 10G interface should use 10kB (which is maximum possible size

 * per single port).

 The loopback requires fixed 1kB of the FIFO space assignment. */

 Set TX FIFO size to 0 for inactive ports. */

 Assign remaining TX FIFO space among all active ports. */

 AXI Bridge Configuration */

 BM */

 Descriptors */

 Buffer Data */

 Initialize network controller common part HW */

 MBUS windows configuration */

 Disable HW PHY polling */

 Allocate and initialize aggregated TXQs */

 Fifo Init */

 Allow cache snoop when transmiting packets */

 Buffer Manager initialization */

 Parser default initialization */

 Classifier default initialization */

	/* multi queue mode isn't supported on PPV2.1, fallback to single

	 * mode

			/* In case the MDIO memory region is declared in

			 * the ACPI, it can already appear as 'in-use'

			 * in the OS. Because it is overlapped by second

			 * region of the network controller, make

			 * sure it is released, before requesting it again.

			 * The care is taken by mvpp2 driver to avoid

			 * concurrent access to this memory region.

 Map CM3 SRAM */

 Enable global Flow Control only if handler to SRAM not NULL */

			/* The system controller regmap is optional for dt

			 * compatibility reasons. When not provided, the

			 * configuration of the GoP relies on the

			 * firmware/bootloader.

 Get system's tclk rate */

		/* Sadly, the BM pools all share the same register to

		 * store the high 32 bits of their address. So they

		 * must all have the same high 32 bits, which forces

		 * us to restrict coherent memory to DMA_BIT_MASK(32).

 Map DTS-active ports. Should be done before FIFO mvpp2_init */

 Init mss lock */

 Initialize network controller */

 Initialize ports */

	/* Statistics must be gathered regularly because some of them (like

	 * packets counters) are 32-bit registers and could overflow quite

	 * quickly. For instance, a 10Gb link used at full bandwidth with the

	 * smallest packets (64B) will overflow a 32-bit counter in less than

	 * 30 seconds. Then, use a workqueue to fill 64-bit counters.

 SPDX-License-Identifier: GPL-2.0

/*

 * Header Parser helpers for Marvell PPv2 Network Controller

 *

 * Copyright (C) 2014 Marvell

 *

 * Marcin Wojtas <mw@semihalf.com>

 Update parser tcam and sram hw entries */

 Clear entry invalidation bit */

 Write sram index - indirect access */

 Write tcam index - indirect access */

 Initialize tcam entry from hw */

 Write tcam index - indirect access */

 Write sram index - indirect access */

 Invalidate tcam hw entry */

 Write index - indirect access */

 Enable shadow table entry and set its lookup ID */

 Update ri fields in shadow table entry */

 Update lookup field in tcam sw entry */

 Update mask for single port in tcam sw entry */

 Update port map in tcam sw entry */

 Obtain port map from tcam sw entry */

 Set byte of data and its enable bits in tcam sw entry */

 Get byte of data and its enable bits from tcam sw entry */

 Compare tcam data bytes with a pattern */

 Update ai bits in tcam sw entry */

 Get ai bits from tcam sw entry */

 Set ethertype in tcam sw entry */

 Set vid in tcam sw entry */

 Set bits in sram sw entry */

 Clear bits in sram sw entry */

 Update ri bits in sram sw entry */

 Obtain ri bits from sram sw entry */

 Update ai bits in sram sw entry */

 Read ai bits from sram sw entry */

 ai is stored on bits 90->97; so it spreads across two u32 */

/* In sram sw entry set lookup ID field of the tcam key to be used in the next

 * lookup interation

/* In the sram sw entry set sign and value of the next lookup offset

 * and the offset value generated to the classifier

 Set sign */

 Set value */

 Reset and set operation */

 Set base offset as current */

/* In the sram sw entry set sign and value of the user defined offset

 * generated to the classifier

 Set sign */

 Set value */

 Set offset type */

 Set offset operation */

 Set base offset as current */

 Find parser flow entry */

 Go through the all entires with MVPP2_PRS_LU_FLOWS */

 Sram store classification lookup ID in AI bits [5:0] */

 Return first free tcam index, seeking from start to end */

 Drop flow control pause frames */

 For all ports - drop flow control frames */

 Set match on DA */

 Mask all ports */

 Update shadow table and hw entry */

 Enable/disable dropping all mac da's */

 Entry exist - update port only */

 Entry doesn't exist - create new */

 Non-promiscuous mode for all ports - DROP unknown packets */

 Update shadow table */

 Mask all ports */

 Update port mask */

 Set port to unicast or multicast promiscuous mode */

 promiscuous mode - Accept unknown unicast or multicast packets */

 Continue - set next lookup */

 Set result info bits */

 Match UC or MC addresses */

 Shift to ethertype */

 Mask all ports */

 Update shadow table */

 Update port mask */

 Set entry for dsa packets */

 Entry exist - update port only */

 Entry doesn't exist - create new */

 Update shadow table */

 Set tagged bit in DSA tag */

 Set ai bits for next iteration */

 Set result info bits to 'single vlan' */

 If packet is tagged continue check vid filtering */

 Shift 4 bytes for DSA tag or 8 bytes for EDSA tag*/

 Set result info bits to 'no vlans' */

 Mask all ports */

 Update port mask */

 Set entry for dsa ethertype */

 Entry exist - update port only */

 Entry doesn't exist - create new */

 Set ethertype */

 Shift ethertype + 2 byte reserved + tag*/

 Update shadow table */

 Set tagged bit in DSA tag */

 Clear all ai bits for next iteration */

 If packet is tagged continue check vlans */

 Set result info bits to 'no vlans' */

 Mask/unmask all ports, depending on dsa type */

 Update port mask */

 Search for existing single/triple vlan entry */

 Go through the all entries with MVPP2_PRS_LU_VLAN */

 Get vlan type */

 Get current ai value from tcam */

 Clear double vlan bit */

 Add/update single/triple vlan entry */

 Create new tcam entry */

 Get last double vlan tid */

 VLAN tag detected, proceed with VID filtering */

 Clear all ai bits for next iteration */

 Update ports' mask */

 Get first free double vlan ai number */

 Search for existing double vlan entry */

 Go through the all entries with MVPP2_PRS_LU_VLAN */

 Add or update double vlan entry */

 Create new tcam entry */

 Set ai value for new double vlan entry */

 Get first single/triple vlan tid */

 Shift 4 bytes - skip outer vlan tag */

 Update ports' mask */

 IPv4 header parsing for fragmentation and L4 offset */

 Not fragmented packet */

 Finished: go to flowid generation */

 Set L3 offset */

 Unmask all ports */

 Update shadow table and hw entry */

 Fragmented packet */

 Clear ri before updating */

 Update shadow table and hw entry */

 IPv4 L3 multicast or broadcast */

 Go again to ipv4 */

 Shift back to IPv4 proto */

 Unmask all ports */

 Update shadow table and hw entry */

 Set entries for protocols over IPv6  */

 Finished: go to flowid generation */

 Unmask all ports */

 Write HW */

 IPv6 L3 multicast entry */

 Finished: go to flowid generation */

 Shift back to IPv6 NH */

 Unmask all ports */

 Update shadow table and hw entry */

 Parser per-port initialization */

 Set lookup ID */

 Set maximum number of loops for packet received from port */

	/* Set initial offset for packet header extraction for the first

	 * searching loop

 Default flow entries initialization for all ports */

 Mask all ports */

 Set flow ID*/

 Update shadow table and hw entry */

 Set default entry for Marvell Header field */

 Unmask all ports */

 Update shadow table and hw entry */

 Set MH entry that skip parser */

 Mask all ports */

 Update shadow table and hw entry */

/* Set default entires (place holder) for promiscuous, non-promiscuous and

 * multicast MAC addresses

 Non-promiscuous mode for all ports - DROP unknown packets */

 Unmask all ports */

 Update shadow table and hw entry */

 Create dummy entries for drop all and promiscuous modes */

 Set default entries for various types of dsa packets */

 None tagged EDSA entry - place holder */

 Tagged EDSA entry - place holder */

 None tagged DSA entry - place holder */

 Tagged DSA entry - place holder */

 None tagged EDSA ethertype entry - place holder*/

 Tagged EDSA ethertype entry - place holder*/

 None tagged DSA ethertype entry */

 Tagged DSA ethertype entry */

 Set default entry, in case DSA or EDSA tag not found */

 Shift 0 bytes */

 Clear all sram ai bits for next iteration */

 Unmask all ports */

 Initialize parser entries for VID filtering */

 Set default vid entry */

 Skip VLAN header - Set offset to 4 bytes */

 Clear all ai bits for next iteration */

 Unmask all ports */

 Update shadow table and hw entry */

 Set default vid entry for extended DSA*/

 Set default vid entry */

 Skip VLAN header - Set offset to 8 bytes */

 Clear all ai bits for next iteration */

 Unmask all ports */

 Update shadow table and hw entry */

 Match basic ethertypes */

 Ethertype: PPPoE */

 Update shadow table and hw entry */

 Ethertype: ARP */

 Generate flow in the next iteration*/

 Set L3 offset */

 Update shadow table and hw entry */

 Ethertype: LBTD */

 Generate flow in the next iteration*/

 Set L3 offset */

 Update shadow table and hw entry */

 Ethertype: IPv4 with header length >= 5 */

 goto ipv4 dst-address (skip eth_type + IP-header-size - 4) */

 Set L4 offset */

 Update shadow table and hw entry */

 Ethertype: IPv6 without options */

 Skip DIP of IPV6 header */

 Set L3 offset */

 Default entry for MVPP2_PRS_LU_L2 - Unknown ethtype */

 Unmask all ports */

 Generate flow in the next iteration*/

 Set L3 offset even it's unknown L3 */

 Update shadow table and hw entry */

/* Configure vlan entries and detect up to 2 successive VLAN tags.

 * Possible options:

 * 0x8100, 0x88A8

 * 0x8100, 0x8100

 * 0x8100

 * 0x88A8

 Double VLAN: 0x8100, 0x88A8 */

 Double VLAN: 0x8100, 0x8100 */

 Single VLAN: 0x88a8 */

 Single VLAN: 0x8100 */

 Set default double vlan entry */

 Clear ai for next iterations */

 Unmask all ports */

 Update shadow table and hw entry */

 Set default vlan none entry */

 Unmask all ports */

 Update shadow table and hw entry */

 Set entries for PPPoE ethertype */

 IPv4 over PPPoE with options */

 goto ipv4 dest-address (skip eth_type + IP-header-size - 4) */

 Set L3 offset */

 Update shadow table and hw entry */

 IPv4 over PPPoE without options */

 Clear ri before updating */

 Update shadow table and hw entry */

 IPv6 over PPPoE */

 Jump to DIP of IPV6 header */

 Set L3 offset */

 Update shadow table and hw entry */

 Non-IP over PPPoE */

 Finished: go to flowid generation */

 Set L3 offset even if it's unknown L3 */

 Update shadow table and hw entry */

 Initialize entries for IPv4 */

 Set entries for TCP, UDP and IGMP over IPv4 */

 IPv4 Broadcast */

 IPv4 Multicast */

 Default IPv4 entry for unknown protocols */

 Finished: go to flowid generation */

 Set L3 offset */

 Unmask all ports */

 Update shadow table and hw entry */

 Default IPv4 entry for unicast address */

 Go again to ipv4 */

 Shift back to IPv4 proto */

 Unmask all ports */

 Update shadow table and hw entry */

 Initialize entries for IPv6 */

 Set entries for TCP, UDP and ICMP over IPv6 */

 IPv4 is the last header. This is similar case as 6-TCP or 17-UDP */

 Result Info: UDF7=1, DS lite */

 IPv6 multicast */

 Entry for checking hop limit */

 Finished: go to flowid generation */

 Update shadow table and hw entry */

 Default IPv6 entry for unknown protocols */

 Finished: go to flowid generation */

 Set L4 offset relatively to our current place */

 Unmask all ports */

 Update shadow table and hw entry */

 Default IPv6 entry for unknown ext protocols */

 Finished: go to flowid generation */

 Unmask all ports */

 Update shadow table and hw entry */

 Default IPv6 entry for unicast address */

 Finished: go to IPv6 again */

 Shift back to IPV6 NH */

 Unmask all ports */

 Update shadow table and hw entry */

 Find tcam entry with matched pair <vid,port> */

 Go through the all entries with MVPP2_PRS_LU_VID */

 Write parser entry for VID filtering */

 Scan TCAM and see if entry with this <vid,port> already exist */

 No such entry */

 Go through all entries from first to last in vlan range */

 There isn't room for a new VID filter */

 Mask all ports */

 Enable the current port */

 Continue - set next lookup */

 Skip VLAN header - Set offset to 4 or 8 bytes */

 Set match on VID */

 Clear all ai bits for next iteration */

 Update shadow table */

 Write parser entry for VID filtering */

 Scan TCAM and see if entry with this <vid,port> already exist */

 No such entry */

 Remove all existing VID filters on this port */

 Remove VID filering entry for this port */

 Invalidate the guard entry */

 Add guard entry that drops packets when no VID is matched on this port */

 Mask all ports */

 Update port mask */

 Continue - set next lookup */

 Skip VLAN header - Set offset to 4 or 8 bytes */

 Drop VLAN packets that don't belong to any VIDs on this port */

 Clear all ai bits for next iteration */

 Update shadow table */

 Parser default initialization */

 Enable tcam table */

 Clear all tcam and sram entries */

 Invalidate all tcam entries */

 Always start from lookup = 0 */

 Compare MAC DA with tcam entry data */

 Find tcam entry with matched pair <MAC DA, port> */

 Go through the all entires with MVPP2_PRS_LU_MAC */

 Update parser's mac da entry */

 Scan TCAM and see if entry with this <MAC DA, port> already exist */

 No such entry */

 Create new TCAM entry */

 Go through the all entries from first to last */

 Mask all ports */

 Update port mask */

 Invalidate the entry if no ports are left enabled */

 Continue - set next lookup */

 Set match on DA */

 Set result info bits */

 Shift to ethertype */

 Update shadow table and hw entry */

 Remove old parser entry */

 Add new parser entry */

 Set addr in the device */

 We only want entries active on this port */

 Read mac addr from entry */

		/* Special cases : Don't remove broadcast and port's own

		 * address

 Remove entry from TCAM */

 Add port to EDSA entries */

 Remove port from DSA entries */

 Add port to DSA entries */

 Remove port from EDSA entries */

 Remove port form EDSA and DSA entries */

 Set prs flow for the port */

 Such entry not exist */

 Go through the all entires from last to first */

 Set flow ID*/

 Update shadow table */

 SPDX-License-Identifier: GPL-2.0

/*

 * Marvell PP2.2 TAI support

 *

 * Note:

 *   Do NOT use the event capture support.

 *   Do Not even set the MPP muxes to allow PTP_EVENT_REQ to be used.

 *   It will disrupt the operation of this driver, and there is nothing

 *   that this driver can do to prevent that.  Even using PTP_EVENT_REQ

 *   as an output will be seen as a trigger input, which can't be masked.

 *   When ever a trigger input is seen, the action in the TCFCR0_TCF

 *   field will be performed - whether it is a set, increment, decrement

 *   read, or frequency update.

 *

 * Other notes (useful, not specified in the documentation):

 * - PTP_PULSE_OUT (PTP_EVENT_REQ MPP)

 *   It looks like the hardware can't generate a pulse at nsec=0. (The

 *   output doesn't trigger if the nsec field is zero.)

 *   Note: when configured as an output via the register at 0xfX441120,

 *   the input is still very much alive, and will trigger the current TCF

 *   function.

 * - PTP_CLK_OUT (PTP_TRIG_GEN MPP)

 *   This generates a "PPS" signal determined by the CCC registers. It

 *   seems this is not aligned to the TOD counter in any way (it may be

 *   initially, but if you specify a non-round second interval, it won't,

 *   and you can't easily get it back.)

 * - PTP_PCLK_OUT

 *   This generates a 50% duty cycle clock based on the TOD counter, and

 *   seems it can be set to any period of 1ns resolution. It is probably

 *   limited by the TOD step size. Its period is defined by the PCLK_CCC

 *   registers. Again, its alignment to the second is questionable.

 *

 * Consequently, we support none of these.

 nanosecond period in 32.32 fixed point

 This timestamp is updated every two seconds */

 Read and discard fractional part */

	/* Trigger the operation. Note that an external unmaskable

	 * event on PTP_EVENT_REQ will also trigger this action.

/* The adjustment has a range of +0.5ns to -0.5ns in 2^32 steps, so has units

 * of 2^-32 ns.

 *

 * units(s) = 1 / (2^32 * 10^9)

 * fractional = abs_scaled_ppm / (2^16 * 10^6)

 *

 * What we want to achieve:

 *  freq_adjusted = freq_nominal * (1 + fractional)

 *  freq_delta = freq_adjusted - freq_nominal => positive = faster

 *  freq_delta = freq_nominal * (1 + fractional) - freq_nominal

 * So: freq_delta = freq_nominal * fractional

 *

 * However, we are dealing with periods, so:

 *  period_adjusted = period_nominal / (1 + fractional)

 *  period_delta = period_nominal - period_adjusted => positive = faster

 *  period_delta = period_nominal * fractional / (1 + fractional)

 *

 * Hence:

 *  period_delta = period_nominal * abs_scaled_ppm /

 *		   (2^16 * 10^6 + abs_scaled_ppm)

 *

 * To avoid overflow, we reduce both sides of the divide operation by a factor

 * of 16.

 Convert to a signed 32-bit adjustment */

		/* -S32_MIN warns, -val < S32_MIN fails, so go for the easy

		 * solution.

 We can't deal with S64_MIN */

	/* XXX: the only way to read the PTP time is for the CPU to trigger

	 * an event. However, there is no way to distinguish between the CPU

	 * triggered event, and an external event on PTP_EVENT_REQ. So this

	 * is incompatible with external use of PTP_EVENT_REQ.

 We don't seem to have a reading... */

	/* Trigger an update to load the value from the TLV registers

	 * into the TOD counter. Note that an external unmaskable event on

	 * PTP_EVENT_REQ will also trigger this action.

	/* As the fractional nanosecond is a signed offset, if the MSB (sign)

	 * bit is set, we have to increment the whole nanoseconds.

 Release the TAI reset */

	/* The tstamp consists of 2 bits of seconds and 30 bits of nanoseconds.

	 * We use our stored timestamp (tai->stamp) to form a full timestamp,

	 * and we must read the seconds exactly once.

	/* Calculate the delta in seconds between our stored timestamp and

	 * the value read from the queue. Allow timestamps one second in the

	 * past, otherwise consider them to be in the future.

	/* The step size consists of three registers - a 16-bit nanosecond step

	 * size, and a 32-bit fractional nanosecond step size split over two

	 * registers. The fractional nanosecond step size has units of 2^-32ns.

	 *

	 * To calculate this, we calculate:

	 *   (10^9 + freq / 2) / (freq * 2^-32)

	 * which gives us the nanosecond step to the nearest integer in 16.32

	 * fixed point format, and the fractional part of the step size with

	 * the MSB inverted.  With rounding of the fractional nanosecond, and

	 * simplification, this becomes:

	 *   (10^9 << 32 + freq << 31 + (freq + 1) >> 1) / freq

	 *

	 * So:

	 *   div = (10^9 << 32 + freq << 31 + (freq + 1) >> 1) / freq

	 *   nano = upper_32_bits(div);

	 *   frac = lower_32_bits(div) ^ 0x80000000;

	 * Will give the values for the registers.

	 *

	 * This is all seems perfect, but alas it is not when considering the

	 * whole story.  The system is clocked from 25MHz, which is multiplied

	 * by a PLL to 1GHz, and then divided by three, giving 333333333Hz

	 * (recurring).  This gives exactly 3ns, but using 333333333Hz with

	 * the above gives an error of 13*2^-32ns.

	 *

	 * Consequently, we use the period rather than calculating from the

	 * frequency.

 SPDX-License-Identifier: GPL-2.0

/*

 * Driver for Marvell PPv2 network controller for Armada 375 SoC.

 *

 * Copyright (C) 2018 Marvell

 Entries for Header Parser debug info */

 Entries for Classifier C2 engine debug info */

 Entries for Classifier Flow Table debug info */

 Entries for Classifier flows debug info */

 Entries for per-port flows debug info */

 We only want entries active on this port */

 Read mac addr from entry */

 Create entry for each port */

 Create each attr */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Admin Function driver

 *

 * Copyright (C) 2021 Marvell.

 *

	/* If the pcifunc is not initialized then nothing to do.

	 * This same function will be called again via rvu_switch_update_rules

	 * after pcifunc is initialized.

 AF is requester */

	/* If the pcifunc is not initialized then nothing to do.

	 * This same function will be called again via rvu_switch_update_rules

	 * after pcifunc is initialized.

 AF is requester */

		/* rvu_get_nix_blkaddr sets up the corresponding NIX block

		 * address and NIX RX and TX interfaces for a pcifunc.

		 * Generally it is called during attach call of a pcifunc but it

		 * is called here since we are pre-installing rules before

		 * nixlfs are attached

		/* MCAM RX rule for a PF/VF already exists as default unicast

		 * rules installed by AF. Hence change the channel in those

		 * rules to ignore channel so that packets with the required

		 * DMAC received from LBK(by other PF/VFs in system) or from

		 * external world (from wire) are accepted.

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Admin Function driver

 *

 * Copyright (C) 2018 Marvell.

 *

 Init header to reset value */

/* Initialize mailbox with the set of mailbox region addresses

 * in the array hwbase.

 Init header to reset value */

	/* If bounce buffer is implemented copy mbox messages from

	 * bounce buffer to hw mbox memory.

 Reset header for next messages */

 Sync mbox data into memory */

	/* num_msgs != 0 signals to the peer that the buffer has a number of

	 * messages.  So this should be written after writing all the messages

	 * to the shared memory.

	/* The interrupt should be fired after num_msgs is written

	 * to the shared memory

 Check if there is space in mailbox */

 Clear the whole msg region */

 Init message header with reset values */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Admin Function driver

 *

 * Copyright (C) 2018 Marvell.

 *

 Get current head pointer where to append this instruction */

 sync into memory */

 Ring the doorbell and wait for result */

 TODO: Replace this with some error code */

	/* Currently we are not supporting enqueuing multiple instructions,

	 * so always choose first entry in result memory.

	/* Hardware uses same aq->res->base for updating result of

	 * previous instruction hence wait here till it is done.

 Clean result + context memory */

 Context needs to be written at RES_ADDR + 128 */

 Mask needs to be written at RES_ADDR + 256 */

 Copy context and write mask */

 Set pool's context address */

 POOL's context */

 Submit the instruction to AQ */

 Set aura bitmap if aura hw context is enabled */

 Set pool bitmap if pool hw context is enabled */

 Copy read context into mailbox */

 Reset this NPA LF */

 Alloc memory for aura HW contexts */

 Alloc memory for pool HW contexts */

 Get no of queue interrupts supported */

 Alloc memory for Qints HW contexts */

 Clear way partition mask and set aura offset to '0' */

 Set aura size & enable caching of contexts */

 Configure aura HW context's base */

 Enable caching of qints hw context */

 set stack page info */

 Reset this NPA LF */

 Set admin queue endianness */

 Do not bypass NDC cache */

 Disable caching of stack pages */

 For CN10K NPA BATCH DMA set 35 cache lines */

	/* Result structure can be followed by Aura/Pool context at

	 * RES + 128bytes and a write mask at RES + 256 bytes, depending on

	 * operation type. Alloc sufficient result memory for all operations.

 Initialize admin queue */

 Disable all pools */

 Disable all auras */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Admin Function driver

 *

 * Copyright (C) 2020 Marvell.

 *

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Admin Function driver

 *

 * Copyright (C) 2018 Marvell.

 *

 Broadcast, Promisc and AllMulticast */

 Ucast for LFs */

	/* Due to a HW issue in these silicon versions, parse nibble enable

	 * configuration has to be identical for both Rx and Tx interfaces.

 Config CPI base for the PKIND */

 If timestamp is enabled then configure NPC to shift 8 bytes */

	/* Given a PF/VF and NIX LF number calculate the unicast mcam

	 * entry index based on the NIX block assigned to the PF/VF.

 Check if this is for a PF */

 Reserved entries exclude PF0 */

		/* Broadcast address matching entry should be first so

		 * that the packet can be replicated to all VFs.

 0,1 & 2,3 banks are combined for this keysize */

	/* 0, 2, 4, 6 indices refer to BANKX_CAMX_W0 and

	 * 1, 3, 5, 7 indices refer to BANKX_CAMX_W1.

	 *

	 * Also, only 48 bits of BANKX_CAMX_W1 are valid.

 BANK(X)_CAM_W0<63:0> = MCAM_KEY[KW0]<63:0> */

 BANK(X)_CAM_W1<47:0> = MCAM_KEY[KW1]<47:0> */

		/* BANK(X + 1)_CAM_W0<15:0> = MCAM_KEY[KW1]<63:48>

		 * BANK(X + 1)_CAM_W0<63:16> = MCAM_KEY[KW2]<47:0>

		/* BANK(X + 1)_CAM_W1<15:0> = MCAM_KEY[KW2]<63:48>

		 * BANK(X + 1)_CAM_W1<47:16> = MCAM_KEY[KW3]<31:0>

		/* BANK(X + 2)_CAM_W0<31:0> = MCAM_KEY[KW3]<63:32>

		 * BANK(X + 2)_CAM_W0<63:32> = MCAM_KEY[KW4]<31:0>

		/* BANK(X + 2)_CAM_W1<31:0> = MCAM_KEY[KW4]<63:32>

		 * BANK(X + 2)_CAM_W1<47:32> = MCAM_KEY[KW5]<15:0>

		/* BANK(X + 3)_CAM_W0<47:0> = MCAM_KEY[KW5]<63:16>

		 * BANK(X + 3)_CAM_W0<63:48> = MCAM_KEY[KW6]<15:0>

 BANK(X + 3)_CAM_W1<47:0> = MCAM_KEY[KW6]<63:16> */

	/* Similar to npc_get_keyword, but fills mcam_entry structure from

	 * CAM registers.

 get ucast entry rule entry index */

 do nothing when target is LBK/PF or owner is not PF */

 save entry2target_pffunc */

 don't enable rule when nixlf not attached or initialized */

 copy VF default entry action to the VF mcam entry */

 Save bank id, to set action later on */

 Disable before mcam entry update */

 Clear mcam entry to avoid writes being suppressed by NPC */

	/* CAM1 takes the comparison value and

	 * CAM0 specifies match for a bit in key being '0' or '1' or 'dontcare'.

	 * CAM1<n> = 0 & CAM0<n> = 1 => match if key<n> = 0

	 * CAM1<n> = 1 & CAM0<n> = 0 => match if key<n> = 1

	 * CAM1<n> = 0 & CAM0<n> = 0 => always match i.e dontcare.

 Interface should be set in all banks */

			/* Last bit must be set and rest don't care

			 * for TX interfaces

 Set the match key */

 PF installing VF rule */

 Set 'action' */

 Set TAG 'action' */

 Enable the entry */

 Copy INTF's, W0's, W1's CAM0 and CAM1 configuration */

 Copy action */

 Copy TAG action */

 Enable or disable */

 AF's and SDP VFs work in promiscuous mode */

	/* Don't change the action if entry is already enabled

	 * Otherwise RSS action may get overwritten.

 AF is requester */

	/* If the corresponding PF's ucast action is RSS,

	 * use the same action for promisc also

 RX_ACTION set to MCAST for CGX PF's */

	/* For cn10k the upper two bits of the channel number are

	 * cpt channel number. with masking out these bits in the

	 * mcam entry, same entry used for NIX will allow packets

	 * received from cpt for parsing.

 AF is requester */

 Get 'pcifunc' of PF device */

 Skip LBK VFs */

	/* If pkt replication is not supported,

	 * then only PF is allowed to add a bcast match entry.

 Get 'pcifunc' of PF device */

		/* Early silicon doesn't support pkt replication,

		 * so install entry with UCAST action, so that PF

		 * receives all broadcast packets.

 AF is requester */

 Get 'pcifunc' of PF device */

 Only CGX PF/VF can add allmulticast entry */

 Get 'pcifunc' of PF device */

	/* If the corresponding PF's ucast action is RSS,

	 * use the same action for multicast entry also

 RX_ACTION set to MCAST for CGX PF's */

 LSB bit of 1st byte in DMAC */

	/* For cn10k the upper two bits of the channel number are

	 * cpt channel number. with masking out these bits in the

	 * mcam entry, same entry used for NIX will allow packets

	 * received from cpt for parsing.

 AF is requester */

 Get 'pcifunc' of PF device */

 read vf flow entry enable status */

 disable before mcam entry update */

 update 'action' */

 Check if this is for reserved default entry */

 TODO: validate this mcam index */

 Ignore if no action was set earlier */

 update the VF flow rule action with the VF default entry action */

 update the action change in default rule */

	/* If PF's promiscuous entry is enabled,

	 * Set RSS action for that entry as well

 disable MCAM entry when packet replication is not supported by hw */

 return incase mce list is not enabled */

 Ucast MCAM match entry of this PF/VF */

	/* Nothing to do for VFs, on platforms where pkt replication

	 * is not supported

 add/delete pf_func to broadcast MCE list */

 Delete multicast and promisc MCAM entries */

	/* Enables only broadcast match entry. Promisc/Allmulti are enabled

	 * in set_rx_mode mbox handler.

 Disable MCAM entries directing traffic to this 'pcifunc' */

 Indicate that default rule is disabled */

 Free all MCAM entries owned by this 'pcifunc' */

 Free all MCAM counters owned by this 'pcifunc' */

 Delete MCAM entries owned by this 'pcifunc' */

 Program LDATA */

 Program LFLAGS */

 Program LDATA */

 Program LFLAGS */

 strtoull of "mkexprof" with base:36 */

 If user not selected mkex profile */

 Setting up the mapping for mkex profile image */

 Compare with mkex mod_param name string */

			/* Due to an errata (35786) in A0/B0 pass silicon,

			 * parse nibble enable configuration has to be

			 * identical for both Rx and Tx interfaces.

 Program selected mkex profile */

 Program CAM match entries for previous KPU extracted data */

 Program this KPU's actions */

 Enable all programmed entries */

 Disable first KPU_MAX_CST_ENT entries for built-in profile */

 Enable this KPU */

 Verify if the using known profile structure */

 Verify if profile is aligned with the required kernel changes */

 Verify if profile fits the HW */

 Loaded profile is a single KPU profile. */

 Loaded profile is coalesced image, offset of first KPU profile.*/

 Check if mapped image is coalesced image. */

 Profile image offsets are rounded up to next 8 multiple.*/

 Calculating offset of profile image based on profile size.*/

 Setting up the mapping for NPC profile image */

 Detect if profile is coalesced or single KPU profile and load */

 Cleaning up if KPU profile image from fwdata is not valid. */

 If user not specified profile customization */

 First prepare default KPU, then we'll customize top entries. */

	/* Order of preceedence for load loading NPC profile (high to low)

	 * Firmware binary in filesystem.

	 * Firmware database method.

	 * Default KPU profile.

 Loading the KPU profile using firmware database */

 Apply profile customization if firmware was loaded. */

		/* If image from firmware filesystem fails to load or invalid

		 * retry with firmware database method.

 Loading image from firmware database failed. */

 Disable all KPUs and their entries */

 Load and customize KPU profile. */

	/* First program IKPU profile i.e PKIND configs.

	 * Check HW max count to avoid configuring junk or

	 * writing to unsupported CSR addresses.

 Program KPU CAM and Action profiles */

 Actual number of MCAM entries vary by entry size */

 Number of banks combined per MCAM entry */

	/* Reserve one MCAM entry for each of the NIX LF to

	 * guarantee space to install default matching DMAC rule.

	 * Also reserve 2 MCAM entries for each PF for default

	 * channel based matching or 'bcast & promisc' matching to

	 * support BCAST and PROMISC modes of operation for PFs.

	 * PF0 is excluded.

 Allocate bitmaps for managing MCAM entries */

 Alloc memory for saving entry to RVU PFFUNC allocation mapping */

	/* Reserve 1/8th of MCAM entries at the bottom for low priority

	 * allocations and another 1/8th at the top for high priority

	 * allocations.

	/* Allocate bitmap for managing MCAM counters and memory

	 * for saving counter to RVU PFFUNC allocation mapping.

	/* Alloc memory for MCAM entry to counter mapping and for tracking

	 * counter's reference count.

 Alloc memory for saving target device of mcam rule */

 Extended set */

		/* 96xx supports only match_stats and npc_counters

		 * reflected in NPC_AF_CONST reg.

		 * STAT_SEL and ENA are at [0:8] and 9 bit positions.

		 * 98xx has both match_stat and ext and npc_counter

		 * reflected in NPC_AF_CONST2

		 * STAT_SEL_EXT added at [12:14] bit position.

		 * cn10k supports only ext and hence npc_counters in

		 * NPC_AF_CONST is 0 and npc_counters reflected in NPC_AF_CONST2.

		 * STAT_SEL bitpos incremented from [0:8] to [0:11] and ENA bit moved to 63

	/* Reserve last counter for MCAM RX miss action which is set to

	 * drop packet. This way we will know how many pkts didn't match

	 * any MCAM entry.

 Configure RX interfaces */

 Set RX MCAM search key size. LA..LE (ltype only) + Channel */

		/* If MCAM lookup doesn't result in a match, drop the received

		 * packet. And map this action to a counter to count dropped

		 * packets.

		/* NPC_AF_INTFX_MISS_STAT_ACT[14:12] - counter[11:9]

		 * NPC_AF_INTFX_MISS_STAT_ACT[8:0] - counter[8:0]

 Configure TX interfaces */

 Extract Ltypes LID_LA to LID_LE */

		/* Set TX miss action to UCAST_DEFAULT i.e

		 * transmit the packet on NIX LF SQ's default channel.

 First disable all MCAM entries, to stop traffic towards NIXLFs */

	/* Reserve PKIND#0 for LBKs. Power reset value of LBK_CH_PKIND is '0',

	 * no need to configure PKIND for all LBKs separately.

 Allocate mem for pkind to PF and channel mapping info */

 Configure KPU profile */

 Config Outer L2, IPv4's NPC layer info */

 Config Inner IPV4 NPC layer info */

	/* Enable below for Rx pkts.

	 * - Outer IPv4 header checksum validation.

	 * - Detect outer L2 broadcast address and set NPC_RESULT_S[L2B].

	 * - Detect outer L2 multicast address and set NPC_RESULT_S[L2M].

	 * - Inner IPv4 header checksum validation.

	 * - Set non zero checksum error code value

 Configure MKEX profile */

 verify AF installed entries */

	/* Verify if entry is valid and if it is indeed

	 * allocated to the requesting PFFUNC.

	/* Verify if counter is valid and if it is indeed

	 * allocated to the requesting PFFUNC.

 Set mapping and increment counter's refcnt */

 Enable stats */

 Remove mapping and reduce counter's refcnt */

 Disable stats */

/* Sets MCAM entry in bitmap as used. Update

 * reverse bitmap too. Should be called with

 * 'mcam->lock' held.

/* Sets MCAM entry in bitmap as free. Update

 * reverse bitmap too. Should be called with

 * 'mcam->lock' held.

 Scan all MCAM entries and free the ones mapped to 'pcifunc' */

 Free the entry in bitmap */

 Disable the entry */

 Update entry2counter mapping */

 Scan all MCAM counters and free the ones mapped to 'pcifunc' */

			/* This API is expected to be called after freeing

			 * MCAM entries, which inturn will remove

			 * 'entry to counter' mapping.

			 * No need to do it again.

/* Find area of contiguous free entries of size 'nr'.

 * If not found return max contiguous free entries available.

/* Find number of free MCAM entries available

 * within range i.e in between 'start' and 'end'.

	/* For a low priority entry allocation

	 * - If reference entry is not in hprio zone then

	 *      search range: ref_entry to end.

	 * - If reference entry is in hprio zone and if

	 *   request can be accomodated in non-hprio zone then

	 *      search range: 'start of middle zone' to 'end'

	 * - else search in reverse, so that less number of hprio

	 *   zone entries are allocated.

	/* For a high priority entry allocation, search is always

	 * in reverse to preserve hprio zone entries.

	 * - If reference entry is not in lprio zone then

	 *      search range: 0 to ref_entry.

	 * - If reference entry is in lprio zone and if

	 *   request can be accomodated in middle zone then

	 *      search range: 'hprio_end' to 'lprio_start'

 Check if there are any free entries */

	/* MCAM entries are divided into high priority, middle and

	 * low priority zones. Idea is to not allocate top and lower

	 * most entries as much as possible, this is to increase

	 * probability of honouring priority allocation requests.

	 *

	 * Two bitmaps are used for mcam entry management,

	 * mcam->bmap for forward search i.e '0 to mcam->bmap_entries'.

	 * mcam->bmap_reverse for reverse search i.e 'mcam->bmap_entries to 0'.

	 *

	 * Reverse bitmap is used to allocate entries

	 * - when a higher priority entry is requested

	 * - when available free entries are less.

	 * Lower priority ones out of avaialble free entries are always

	 * chosen when 'high vs low' question arises.

 Get the search range for priority allocation request */

	/* For a VF base MCAM match rule is set by its PF. And all the

	 * further MCAM rules installed by VF on its own are

	 * concatenated with the base rule set by its PF. Hence PF entries

	 * should be at lower priority compared to VF entries. Otherwise

	 * base rule is hit always and rules installed by VF will be of

	 * no use. Hence if the request is from PF and NOT a priority

	 * allocation request then allocate low priority entries.

	/* Find out the search range for non-priority allocation request

	 *

	 * Get MCAM free entry count in middle zone.

 Check if request can be accomodated in the middle zone */

		/* Expand search zone from half of hprio zone to

		 * half of lprio zone.

		/* Not enough free entries, search all entries in reverse,

		 * so that low priority ones will get used up.

		/* Allocate requested number of contiguous entries, if

		 * unsuccessful find max contiguous entries available.

		/* Allocate requested number of non-contiguous entries,

		 * if unsuccessful allocate as many as possible.

 Save the entry's index */

	/* If allocating requested no of entries is unsucessful,

	 * expand the search range to full bitmap length and retry.

	/* For priority entry allocation requests, if allocation is

	 * failed then expand search to max possible range and retry.

	/* Copy MCAM entry indices into mbox response entry_list.

	 * Requester always expects indices in ascending order, so

	 * so reverse the list if reverse bitmap is used for allocation.

 Mark the allocated entries as used and set nixlf mapping */

 Update available free count in mbox response */

 Check if ref_entry is within range */

	/* ref_entry can't be '0' if requested priority is high.

	 * Can't be last entry if requested priority is low.

	/* Since list of allocated indices needs to be sent to requester,

	 * max number of non-contiguous entries per mbox msg is limited.

 Alloc request from PFFUNC with no NIXLF attached should be denied */

 Free request from PFFUNC with no NIXLF attached, ignore */

 Update entry2counter mapping */

 Free up all entries allocated to requesting PFFUNC */

 For AF installed rules, the nix_intf should be set to target NIX */

		/* Check if both old and new entries are valid and

		 * does belong to this PFFUNC or not.

 new_entry should not have a counter mapped */

 Disable the new_entry */

 Copy rule from old entry to new entry */

 Copy counter mapping, if any */

 Enable new_entry and disable old_entry */

 If shift has failed then report the failed index */

 If the request is from a PFFUNC with no NIXLF attached, ignore */

	/* Since list of allocated counter IDs needs to be sent to requester,

	 * max number of non-contiguous counters per mbox msg is limited.

 Check if unused counters are available or not */

		/* Allocate requested number of contiguous counters, if

		 * unsuccessful find max contiguous entries available.

		/* Allocate requested number of non-contiguous counters,

		 * if unsuccessful allocate as many as possible.

 Mark counter as free/unused */

 Disable all MCAM entry's stats which are using this counter */

 Unmap the MCAM entry and counter */

 Disable all MCAM entry's stats which are using this counter */

 Try to allocate a MCAM entry */

 Now allocate counter */

 Free allocated MCAM entry */

 use default pkind to disable edsa/higig */

 rx pkind set req valid only for cgx mapped PFs */

 Tx pkind set request valid if PCIFUNC has NIXLF attached */

 Return the channel number in case of PF */

 Find the pkt steering rule installed by PF to this VF */

 Read the default ucast entry if there is no pkt steering rule */

 Read the mcam entry */

 read MCAM entry STAT_ACT register */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Admin Function driver

 *

 * Copyright (C) 2018 Marvell.

 *

 Returns bitmap of mapped PFs */

 Assumes only one pf mapped to a cgx lmac port */

 Return first enabled CGX instance if none are enabled then return NULL */

 Based on P2X connectivity find mapped NIX block for a PF */

 Firmware sets P2X_SELECT as either NIX0 or NIX1 */

	/* Alloc map table

	 * An additional entry is required since PF id starts from 1 and

	 * hence entry at offset 0 is invalid.

 Initialize all entries with an invalid cgx and lmac id */

 Reverse map table */

 Lock the event queue before we read the local link status */

 start worker to process the events */

 This is called from interrupt context and is expected to be atomic */

 post event to the event queue */

 start worker to process the events */

 check if notification is enabled */

 Send mbox message to PF */

 Dequeue an event */

 nothing more to process */

 process event */

 link change call back */

	/* CGX port id starts from 0 and are not necessarily contiguous

	 * Hence we allocate resources based on the maximum port id value.

 Initialize the cgxdata table */

 Map CGX LMAC interfaces to RVU PFs */

 Register for CGX events */

	/* Ensure event handler registration is completed, before

	 * we turn on the links

 Do link up for all CGX ports */

 Ensure event handler unregister is completed */

/* Most of the CGX configuration is restricted to the mapped PF only,

 * VF's of mapped PF and other PFs are not allowed. This fn() checks

 * whether a PFFUNC is permitted to do the config or not.

 Set / clear CTL_BCK to control pause frame forwarding to NIX */

	/* As cgx_lmac_addr_del does not clear entry for index 0

	 * so it needs to be done explicitly

 Rx stats */

 Tx stats */

	/* If msg is received from PFs(which are not mapped to CGX LMACs)

	 * or VF then no entries are allocated for DMAC filters at CGX level.

	 * So returning zero.

 copy 48 bit mac address to req->mac_addr */

	/* This msg is expected only from PFs that are mapped to CGX LMACs,

	 * if received from other PF/VF simply ACK, nothing to do.

	/* If PTP is enabled then inform NPC that packets to be

	 * parsed by this PF will have their data shifted by 8 bytes

	 * and if PTP is disabled then no shift is required

 This flag is required to clean up CGX conf if app gets killed */

 Send the current link status to PF */

	/* This msg is expected only from PF/VFs that are mapped to CGX LMACs,

	 * if received from other PF/VF simply ACK, nothing to do.

/* Finds cumulative status of NIX rx/tx counters from LF of a PF and those

 * from its VFs as well. ie. NIX rx/tx counters at the CGX port level

	/* Assumes LF of a PF and all of its VF belongs to the same

	 * NIX block

 Check if a lf is attached to this PF or one of its VFs */

 CGX is already started hence nothing to do */

 CGX is already stopped hence nothing to do */

	/* Start CGX when first of all NIXLFs is started.

	 * Stop CGX when last of all NIXLFs is stopped.

 Revert the usage count in case of error */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Admin Function driver

 *

 * Copyright (C) 2018 Marvell.

 *

 Only 64bit offsets */

 Should never happen */

 SPDX-License-Identifier: GPL-2.0

/* Marvell PTP driver

 *

 * Copyright (C) 2020 Marvell.

 *

 Check PTP block is present in hardware */

 Check driver is bound to PTP block */

	/* The hardware adds the clock compensation value to the PTP clock

	 * on every coprocessor clock cycle. Typical convention is that it

	 * represent number of nanosecond betwen each cycle. In this

	 * convention compensation value is in 64 bit fixed-point

	 * representation where upper 32 bits are number of nanoseconds

	 * and lower is fractions of nanosecond.

	 * The scaled_ppm represent the ratio in "parts per million" by which

	 * the compensation value should be corrected.

	 * To calculate new compenstation value we use 64bit fixed point

	 * arithmetic on following formula

	 * comp = tbase + tbase * scaled_ppm / (1M * 2^16)

	 * where tbase is the basic compensation value calculated

	 * initialy in the probe function.

 convert scaled_ppm to ppb */

 Return the current PTP clock */

 sclk is in MHz */

 Enable PTP clock */

 Set GPIO as PTP clock source */

 Set GPIO as timestamping source */

 Set 50% duty cycle for 1Hz output */

 Initial compensation value to start the nanosecs counter */

	/* For `ptp_get()` we need to differentiate between the case

	 * when the core has not tried to probe this device and the case when

	 * the probe failed.  In the later case we pretend that the

	 * initialization was successful and keep the error in

	 * `dev->driver_data`.

 Disable PTP clock */

	/* This function is the PTP mailbox handler invoked when

	 * called by AF consumers/netdev drivers via mailbox mechanism.

	 * It is used by netdev driver to get the PTP clock and to set

	 * frequency adjustments. Since mailbox can be called without

	 * notion of whether the driver is bound to ptp device below

	 * validation is needed as first step.

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Admin Function driver

 *

 * Copyright (C) 2019 Marvell.

 *

 NIX TX stats */

 NIX RX stats */

 Dump LMTST map table */

 don't allow partial reads */

 Reading num of VFs per PF */

 Dumps current provisioning status of all RVU block LFs */

 don't allow partial reads */

 Get the maximum width of a column */

 There can be no CGX devices at all */

/* The 'qsize' entry dumps current Aura/Pool context Qsize

 * and each context's current enable/disable status in a bitmap.

 Dumps given NPA Aura's context */

 Dumps given NPA Pool's context */

 Reads aura/pool's ctx from admin queue */

 Dumps given nix_sq's context */

 Dumps given nix_rq's context */

 Dumps given nix_cq's context */

 Ingress policers do not exist on all platforms */

 Ingress policers do not exist on all platforms */

 There can be no CGX devices at all */

 Link status */

 Rx stats */

 Tx stats */

 Rx stats */

 Tx stats */

 Display enabled dmac entries associated with current lmac */

 cgx debugfs dir */

 lmac debugfs dir */

 NPC debugfs APIs */

 MCAM keywidth on receive and transmit sides */

 MCAM entries */

 MCAM counters */

 CONFIG_DEBUG_FS */

 SPDX-License-Identifier: GPL-2.0-only

/* Marvell RVU Admin Function driver

 *

 * Copyright (C) 2020 Marvell.

 *

 CPT PF device id */

 Length of initial context fetch in 128 byte words */

 Disable all CPT AF interrupts */

 Disable all CPT AF interrupts */

 Check if requested 'CPTLF <=> NIXLF' mapping is valid */

 If default, use 'this' CPTLF's PFFUNC */

 Check if requested 'CPTLF <=> SSOLF' mapping is valid */

 If default, use 'this' CPTLF's PFFUNC */

 Set CPT LF group and priority */

		/* Set CPT LF NIX_PF_FUNC and SSO_PF_FUNC. EXE_LDWB is set

		 * on reset.

 Perform teardown */

 Reset LF */

		/* IPSec inline outbound path is already enabled for a given

		 * CPT LF, HRM states that inline inbound & outbound paths

		 * must not be enabled at the same time for a given CPT LF

 Check if requested 'CPTLF <=> SSOLF' mapping is valid */

 Enable CPT LF for IPsec inline inbound operations */

 Set SSO_PF_FUNC */

 Set SSO_PF_FUNC_OVRD for inline IPSec */

	/* Configure the X2P Link register with the cpt base channel number and

	 * range of channels it should propagate to X2P

		/* IPSec inline inbound path is already enabled for a given

		 * CPT LF, HRM states that inline inbound & outbound paths

		 * must not be enabled at the same time for a given CPT LF

 Check if requested 'CPTLF <=> NIXLF' mapping is valid */

 Enable CPT LF for IPsec inline outbound operations */

 Set NIX_PF_FUNC */

 Registers that can be accessed from PF/VF */

 Slot is not valid for that PF/VF */

 Translate local LF used by VFs to global CPT LF */

 Registers that can be accessed from PF */

 This message is accepted only if sent from CPT PF/VF */

 Get AE status */

 Get SE status */

 Get IE status */

 This message is accepted only if sent from CPT PF/VF */

 Get CPT engines status */

 Read CPT instruction PC registers */

 This message is accepted only if sent from CPT PF/VF */

	/* Set time limit to minimum values, so that rxc entries will be

	 * flushed out quickly.

 Disable instructions enqueuing */

 Disable executions in the LF's queue */

 Wait for CPT queue to become execution-quiescent */

 Enable BAR2 ALIAS for this pcifunc. */

 Set group drop to help clear out hardware */

 Send mbox message to CPT PF */

 Prepare CPT_INST_S */

 AF PF FUNC */

 Set QORD */

 Set EGRP */

	/* Subtract 1 from the NIX-CPT credit count to preserve

	 * credit counts.

 Wait for CPT instruction to be completed */

	/* Submit CPT_INST_S to track when all packets have been

	 * flushed through for the NIX PF FUNC in inline inbound case.

 Wait for rxc entries to be flushed out */

 Enable BAR2 ALIAS for this pcifunc. */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Admin Function driver

 *

 * Copyright (C) 2020 Marvell.

/* Compute keyword masks and figure out the number of keywords a field

 * spans in the key.

 NPC_MCAM_KEY_X1 */

 NPC_MCAM_KEY_X2 */

 NPC_MCAM_KEY_X4 */

 one KW only */

 two KWs */

 first KW mask */

 second KW mask i.e. mask for rest of bits */

 three KWs */

 first KW mask */

 second KW mask */

 third KW mask i.e. mask for rest of bits */

 Helper function to figure out whether field exists in the key */

	/* Fields with same layer id and different ltypes are mutually

	 * exclusive hence they can be overlapped

/* Helper function to check whether given field overlaps with any other fields

 * in the key. Due to limitations on key size and the key extraction profile in

 * use higher layers can overwrite lower layer's header fields. Hence overlap

 * needs to be checked.

 exclude input */

 form KW masks */

				/* check any input field bits falls in any

				 * other field bits.

 offset within key word */

 which word in key */

 bits in a nibble */

 check for LTYPE only as of now */

	/* Ether type can come from three layers

	 * (ethernet, single tagged, double tagged)

	/* Outer VLAN TCI can come from two layers

	 * (single tagged, double tagged)

	/* Handle header fields which can come from multiple layers like

	 * etype, outer vlan tci. These fields should have same position in

	 * the key otherwise to install a mcam rule more than one entry is

	 * needed which complicates mcam space management.

 if key profile programmed does not extract Ethertype at all */

 if key profile programmed extracts Ethertype from one layer */

 if key profile programmed extracts Ethertype from multiple layers */

 check none of higher layers overwrite Ethertype */

 if key profile does not extract outer vlan tci at all */

 if key profile extracts outer vlan tci from one layer */

 if key profile extracts outer vlan tci from multiple layers */

 check none of higher layers overwrite outer vlan tci */

 starting KW index and starting bit position */

	/* For Tx, Layer A has NIX_INST_HDR_S(64 bytes) preceding

	 * ethernet header.

	/* List LID, LTYPE, start offset from layer and length(in bytes) of

	 * packet header fields below.

	 * Example: Source IP is 4 bytes and starts at 12th byte of IP header

 PF_FUNC is 2 bytes at 0th byte of NPC_LT_LA_IH_NIX_ETHER */

 for tcp/udp/sctp corresponding layer type should be in the key */

 for AH/ICMP/ICMPv6/, check if corresponding layer type is present in the key */

 for ESP, check if corresponding layer type is present in the key */

 for vlan corresponding layer type should be in the key */

 for vlan ethertypes corresponding layer type should be in the key */

/* Scan key extraction profile and record how fields of our interest

 * fill the key structure. Also verify Channel and DMAC exists in

 * key and not overwritten by other header fields.

	/* Scan and note how parse result is going to be in key.

	 * A bit set in PARSE_NIBBLE_ENA corresponds to a nibble from

	 * parse result in the key. The enabled nibbles from parse result

	 * will be concatenated in key.

 Scan and note how layer data is going to be in key */

 Channel is mandatory */

 check that none of the fields overwrite channel */

 DMAC should be present in key for unicast filter to work */

 check that none of the fields overwrite DMAC */

/* npc_update_entry - Based on the masks generated during

 * the key scanning, updates the given entry with value and

 * masks for the field of interest. Maximum 16 bytes of a packet

 * header can be extracted by HW hence lo and hi are sufficient.

 * When field bytes are less than or equal to 8 then hi should be

 * 0 for value and mask.

 *

 * If exact match of value is required then mask should be all 1's.

 * If any bits in mask are 0 then corresponding bits in value are

 * dont care.

 place key value in kw[x] */

 update entry value */

 update entry mask */

 place remaining bits of key value in kw[x + 1] */

 update entry value */

 update entry mask */

 place remaining bits of key value in kw[x + 1], kw[x + 2] */

 update entry value */

 update entry mask */

	/* dummy is ready with values and masks for given key

	 * field now clear and update input entry with those

	/* For an ipv6 address fe80::2c68:63ff:fe5e:2d0a the packet

	 * values to be programmed in MCAM should as below:

	 * val_high: 0xfe80000000000000

	 * val_low: 0x2c6863fffe5e2d0a

 If only VLAN id is given then always match outer VLAN id */

 For tcp/udp/sctp LTYPE should be present in entry */

 For AH, LTYPE should be present in entry */

 For ESP, LTYPE should be present in entry */

	/* we try to allocate a counter to track the stats of this

	 * rule. If counter could not be allocated then proceed

	 * without counter because counters are limited than entries.

 Do not care channel */

	/* VTAG0 starts at 0th byte of LID_B.

	 * VTAG1 starts at 4th byte of LID_B.

	/* If AF is installing then do not care about

	 * PF_FUNC in Send Descriptor

	/* VTAG0 starts at 0th byte of LID_B.

	 * VTAG1 starts at 4th byte of LID_B.

 Default unicast rules do not exist for TX */

 update mcam entry with default unicast rule attributes */

 allocate new counter if rule has no counter */

	/* if user wants to delete an existing counter for a rule then

	 * free the counter

	/* AF owns the default rules so change the owner just to relax

	 * the checks in rvu_mbox_handler_npc_mcam_write_entry

 if counter is available then clear and use it */

 update rule */

 VF's MAC address is being changed via PF  */

	/* Each PF/VF info is maintained in struct rvu_pfvf.

	 * rvu_pfvf for the target PF/VF needs to be retrieved

	 * hence modify pcifunc accordingly.

 AF installing for a PF/VF */

 PF installing for its VF */

 msg received from PF/VF */

 ignore chan_mask in case pf func is not AF, revisit later */

 PF installing for its VF */

 update req destination mac addr */

 Proceed if NIXLF is attached or not for TX rules */

 don't enable rule when nixlf not attached or initialized */

	/* Packets reaching NPC in Tx path implies that a

	 * NIXLF is properly setup and transmitting.

	 * Hence rules can be enabled for Tx.

 Do not allow requests from uninitialized VFs */

 PF sets VF mac & VF NIXLF is not attached, update the mac addr */

 All rules */

 Range of rules */

 single rule */

 clear the mcam entry target pcifunc */

 Use default unicast entry action */

 Enable MCAM entries installed by PF with target as VF pcifunc */

 Disable MCAM entries installed by PF with target as VF pcifunc */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RPM CN10K driver

 *

 * Copyright (C) 2020 Marvell.

 RVU LMTST */

 Function to perform operations (read/write) on lmtst map table */

		/* Flushing the AP interceptor cache to make APR_LMT_MAP_ENTRY_S

		 * changes effective. Write 1 for flush and read is being used as a

		 * barrier and sets up a data dependency. Write to 0 after a write

		 * to 1 to complete the flush.

	/* PA[51:12] = RVU_AF_SMMU_TLN_FLIT0[57:18]

	 * PA[11:0] = IOVA[11:0]

 Read the current lmt addr of pcifunc */

	/* Storing the seondary's lmt base address as this needs to be

	 * reverted in FLR. Also making sure this default value doesn't

	 * get overwritten on multiple calls to this mailbox.

 Update the LMT table with new addr */

	/* Check if PF_FUNC wants to use it's own local memory as LMTLINE

	 * region, if so, convert that IOVA to physical address and

	 * populate LMT table with that address

 Update the lmt addr for this PFFUNC in the LMT table */

	/* Reconfiguring lmtst map table in lmt region shared mode i.e. make

	 * multiple PF_FUNCs to share an LMTLINE region, so primary/base

	 * pcifunc (which is passed as an argument to mailbox) is the one

	 * whose lmt base address will be shared among other secondary

	 * pcifunc (will be the one who is calling this mailbox).

		/* Calculating the LMT table index equivalent to primary

		 * pcifunc.

 Read the base lmt addr of the primary pcifunc */

		/* Update the base lmt addr of secondary with primary's base

		 * lmt addr.

	/* This mailbox can also be used to update word1 of APR_LMT_MAP_ENTRY_S

	 * like enabling scheduled LMTST, disable LMTLINE prefetch, disable

	 * early completion for ordered LMTST.

		/* Storing lmt map table entry word1 default value as this needs

		 * to be reverted in FLR. Also making sure this default value

		 * doesn't get overwritten on multiple calls to this mailbox.

 Disable early completion for Ordered LMTSTs. */

 Enable scheduled LMTST */

 Disables LMTLINE prefetch before receiving store data. */

 Resetting the lmtst map table to original base addresses */

 This corresponds to lmt map table index */

		/* Reverting back original lmt base addr for respective

		 * pcifunc.

		/* Reverting back to orginal word1 val of lmtst map table entry

		 * which underwent changes.

 No Programmable channels */

	/* If programmable channels are present then configure

	 * channels such that all channel numbers are contiguous

	 * leaving no holes. This way the new CPT channels can be

	 * accomodated. The order of channel numbers assigned is

	 * LBK, SDP, CGX and CPT. Also the base channel number

	 * of a block must be multiple of number of channels

	 * of the block.

 Round up base channel to multiple of number of channels */

	/* Out of 4096 channels start CPT from 2048 so

	 * that MSB for CPT channels is always set

	/* To loopback packets between multiple NIX blocks

	 * mutliple LBK blocks are needed. With two NIX blocks,

	 * four LBK blocks are needed and each LBK block

	 * source and destination are as follows:

	 * LBK0 - source NIX0 and destination NIX1

	 * LBK1 - source NIX0 and destination NIX1

	 * LBK2 - source NIX1 and destination NIX0

	 * LBK3 - source NIX1 and destination NIX1

	 * As per the HRM channel numbers should be programmed as:

	 * P2X and X2P of LBK0 as same

	 * P2X and X2P of LBK3 as same

	 * P2X of LBK1 and X2P of LBK2 as same

	 * P2X of LBK2 and X2P of LBK1 as same

 LBK0 */

 LBK3 */

 LBK1 */

 LBK2 */

	/* There is no read-only constant register to read

	 * the number of channels for LMAC and it is always 16.

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Admin Function driver

 *

 * Copyright (C) 2018 Marvell.

 *

 Supported devices */

 end of table */

 MKEX profile name */

 KPU profile name */

/* Poll a RVU block's register 'offset', for a 'zero'

 * or 'nonzero' at bits specified by 'mask'

	/* In scenarios where CPU is scheduled out before checking

	 * 'time_before' (above) and gets scheduled in such that

	 * jiffies are beyond timeout value, then check again if HW is

	 * done with the operation in the meantime.

 Get block LF's HW index from a PF_FUNC's block slot number */

/* Convert BLOCK_TYPE_E to a BLOCK_ADDR_E.

 * Some silicon variants of OcteonTX2 supports

 * multiple blocks of same type.

 *

 * @pcifunc has to be zero when no LF is yet attached.

 *

 * For a pcifunc if LFs are attached from multiple blocks of same type, then

 * return blkaddr of first encountered block.

 For now assume NIX0 */

 For now assume CPT0 */

 Check if this is a RVU PF or VF */

	/* Check if the 'pcifunc' has a NIX LF from 'BLKADDR_NIX0' or

	 * 'BLKADDR_NIX1'.

 Check if this is for a RVU PF or VF */

 Get numVFs attached to this PF and first HWVF */

 Get first HWVF attached to this PF */

 Check if it is a PF or VF */

 Check if VF is within number of VFs attached to this PF */

 For each block check if 'implemented' bit is set */

 Do a HW reset of all RVU blocks */

 Set this resource as being used */

 Get, to whom this LF is attached */

 Set start MSIX vector for this LF within this PF/VF */

 If PF is not enabled, nothing to do */

 Get num of MSIX vectors attached to this PF */

 Alloc msix bitmap for this PF */

 Allocate memory for MSIX vector to RVU block LF mapping */

		/* For PF0 (AF) firmware will set msix vector offsets for

		 * AF, block AF and PF0_INT vectors, so jump to VFs.

		/* Set MSIX offset for PF's 'RVU_PF_INT_VEC' vectors.

		 * These are allocated on driver init and never freed,

		 * so no need to set 'msix_lfmap' for these.

 Alloc msix bitmap for VFs */

 Get num of MSIX vectors attached to this VF */

 Alloc msix bitmap for this VF */

			/* Set MSIX offset for HWVF's 'RVU_VF_INT_VEC' vectors.

			 * These are allocated on driver init and never freed,

			 * so no need to set 'msix_lfmap' for these.

	/* HW interprets RVU_AF_MSIXTR_BASE address as an IOVA, hence

	 * create an IOMMU mapping for the physical address configured by

	 * firmware and reconfig RVU_AF_MSIXTR_BASE with IOVA.

 Restore msixtr base register */

 Free block LF bitmaps */

 Free MSIX bitmaps */

 Unmap MSIX vector base IOVA mapping */

 For PF0(AF), Assign MAC address to only VFs (LBKVFs) */

 Assign MAC address to PF */

 Assign MAC address to VFs*/

 Get firmware data base address */

 Init NIX LF's bitmap */

 Init CPT LF's bitmap */

 cache fifo size */

 Get HW supported max RVU PF & VF count */

 Init NPA LF's bitmap */

 Init SSO group's bitmap */

 Init SSO workslot's bitmap */

 Init TIM LF's bitmap */

 Allocate memory for PFVF data */

 Allocate memory for block LF/slot to pcifunc mapping info */

		/* Scan all blocks to check if low level firmware has

		 * already provisioned any of the resources to a PF/VF.

 Assign MACs for CGX mapped functions */

 NPA and NIX admin queue APIs */

 Alloc memory for instructions i.e AQ */

 Alloc memory for results */

/* Get current count of a RVU block's LF/slots

 * provisioned to a given RVU func.

 Return true if LFs of block type are attached to pcifunc */

 Check if this PFFUNC has a LF of type blktype attached */

 Wait for the lookup to finish */

 TODO: put some timeout here */

 Check LF valid bit */

	/* Get all the block addresses from which LFs are attached to

	 * the given pcifunc in num_blkaddr[].

	/* Based on the given global slot number retrieve the

	 * correct block address out of all attached block

	 * addresses and slot number in that block.

 This should never happen */

 Disable the LF */

 Update SW maintained mapping info as well */

 Free the resource */

 Clear MSIX vector offset for this LF */

 Check for partial resource detach */

	/* Check for RVU block's LFs attached to this func,

	 * if so, detach them.

 All CGX mapped PFs are set with assigned NIX block during init */

		/* Assign NIX based on VF number. All even numbered VFs get

		 * NIX0 and odd numbered gets NIX1

 NIX1 is not present on all silicons */

 if SDP1 then the blkaddr is NIX1 */

 Allocate the resource */

 Set start MSIX vector for this LF within this PF/VF */

 Only one NPA LF can be attached */

 Only one NIX LF can be attached */

 Is request within limits ? */

 Check if additional resources are available */

 Requester already has LFs from given block ? */

 If first request, detach all existing attached resources */

 Check if the request can be accommodated */

 Now attach the requested resources */

		/* RVU func doesn't know which exact LF or slot is attached

		 * to it, it always sees as slot 0,1,2. So for a 'modify'

		 * request, simply detach all existing attached LFs/slots

		 * and attach a fresh.

 Check and alloc MSIX vectors, must be contiguous */

 Config MSIX offset in LF */

 Update the bitmap as well */

 Clear MSIX offset in LF */

 Update the mapping */

 Free the same in MSIX bitmap */

 Set MSIX offsets for each block's LFs attached to this PF/VF */

 Get BLKADDR from which LFs are attached to pcifunc */

 NIX1 */

 Only PF can add VF permissions */

 disable multicast and promisc entries */

 Check if valid, if not reply with a invalid msg */

 some handlers should complete even if reply */	\

 could not be allocated */				\

 Process received mbox messages */

 Set which PF/VF sent this message based on mbox IRQ */

 Send mbox responses to VF/PF */

	/* For cn10k platform VF mailbox regions of a PF follows after the

	 * PF <-> AF mailbox region. Whereas for Octeontx2 it is read from

	 * RVU_PF_VF_BAR4_ADDR register.

	/* For cn10k platform AF <-> PF mailbox region of a PF is read from per

	 * PF registers. Whereas for Octeontx2 it is read from

	 * RVU_AF_PF_BAR4_ADDR register.

 start from 0 */

		/*The hdr->num_msgs is set to zero immediately in the interrupt

		 * handler to  ensure that it holds a correct value next time

		 * when the interrupt handler is called.

		 * pf->mbox.num_msgs holds the data for use in pfaf_mbox_handler

		 * pf>mbox.up_num_msgs holds the data for use in

		 * pfaf_mbox_up_handler.

 Clear interrupts */

 Sync with mbox memory region */

 Handle VF interrupts */

 Clear spurious irqs, if any */

 Enable mailbox interrupt for all PFs except PF0 i.e AF itself */

 Cleanup LF and reset it */

	/* Reset order should reflect inter-block dependencies:

	 * 1. Reset any packet/work sources (NIX, CPT, TIM)

	 * 2. Flush and reset SSO/SSOW

	 * 3. Cleanup pools (NPA)

 pcifunc = 0(PF0) | (vf + 1) */

 Signal FLR finish and enable IRQ */

 Signal FLR finish */

 Enable interrupt */

 Clear and disable the interrupt */

 clear interrupt */

 Disable the interrupt */

 PF is already dead do only AF related operations */

	/* Nothing to be done here other than clearing the

	 * TRPEND bit.

 clear the trpend due to ME(master enable) */

 clear interrupt */

 Handles ME interrupts from VFs of AF */

 Handles ME interrupts from PFs */

	/* Nothing to be done here other than clearing the

	 * TRPEND bit.

 clear the trpend due to ME(master enable) */

 clear interrupt */

 Disable the Mbox interrupt */

 Disable the PF FLR interrupt */

 Disable the PF ME interrupt */

	/* Make sure there are enough MSIX vectors configured so that

	 * VF interrupts can be handled. Offset equal to zero means

	 * that PF vectors are not configured and overlapping AF vectors.

 Enable MSI-X */

 Register mailbox interrupt handler */

 Enable mailbox interrupts from all PFs */

 Register FLR interrupt handler */

 Enable FLR interrupt for all PFs*/

 Register ME interrupt handler */

 Clear TRPEND bit for all PF */

 Enable ME interrupt for all PFs*/

 Get PF MSIX vectors offset. */

 Register MBOX0 interrupt. */

	/* Register MBOX1 interrupt. MBOX1 IRQ number follows MBOX0 so

	 * simply increment current offset by 1.

 Register FLR interrupt handler for AF's VFs */

 Register ME interrupt handler for AF's VFs */

 Enable FLR for all PFs*/

	/* Clear any pending interrupts and enable AF VF interrupts for

	 * the first 64 VFs.

 Mbox */

 FLR */

 Same for remaining VFs, if any. */

 Read number of available LBK channels from LBK(0)_CONST register. */

 Limit VFs in case we have more VFs than LBK channels available. */

	/* LBK channel number 63 is used for switching packets between

	 * CGX mapped VFs. Hence limit LBK pairs till 62 only.

	/* Save VFs number for reference in VF interrupts handlers.

	 * Since interrupts might start arriving during SRIOV enablement

	 * ordinary API cannot be used to get number of enabled VFs.

 Make sure IRQs are enabled before SRIOV. */

 Map Admin function CSRs */

 Store module params in rvu structure */

 Check which blocks the HW supports */

 Init mailbox btw AF and PFs */

 Enable AF's VFs (if any) */

 Initialize debugfs */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Admin Function driver

 *

 * Copyright (C) 2021 Marvell.

 *

 SDP PF device id */

 Maximum SDP blocks in a chip */

 SDP PF number */

 The RVU PF number is one less than bus number */

 SPDX-License-Identifier: GPL-2.0

/* Marvell OcteonTx2 CGX driver

 *

 * Copyright (C) 2018 Marvell.

 *

 Convert firmware speed encoding to user format(Mbps) */

 Convert firmware lmac type encoding to string */

 CGX PHY management internal APIs */

 Supported devices */

 end of table */

/* Helper function to get sequential index

 * given the enabled LMAC of a CGX

/* Ensure the required lock for event queue(where asynchronous events are

 * posted) is acquired before calling this API. Else an asynchronous event(with

 * latest link status) can reach the destination before this function returns

 * and could make the link status appear wrong.

 access mac_ops to know csr_offset */

 copy 6bytes from macaddr */

 memcpy(&cfg, mac_addr, 6); */

 Get mac_ops to know csr offset */

 Get available index where entry is to be installed */

	/* Restore index 0 to its default init value as done during

	 * cgx_lmac_init

 Reset CGXX_CMRX_RX_DMAC_CTL0 register to default state */

/* Allows caller to change macaddress associated with index

 * in dmac filter table including index 0 reserved for

 * interface mac address

 Validate the index */

 ensure index is already set */

 Validate the index */

 Skip deletion for reserved index i.e. index 0 */

 Read MAC address to check whether it is ucast or mcast */

 Configure CGX LMAC in internal loopback mode */

 Enable promiscuous mode on LMAC */

 Disable promiscuous mode */

 Enable or disable forwarding received pause frames to Tx block */

 Enable receive pause frames */

 Enable pause frames transmission */

 Set pause time and interval */

 ALL pause frames received are completely ignored */

 Disable pause frames transmission */

 Enable inbound PTP timestamping */

 Disable inbound PTP stamping */

 CGX Firmware interface low level support */

 Ensure no other command is in progress */

 Ensure command register is free */

 Update ownership in command request */

 Mark this lmac as pending, before we start */

 Start command in hardware */

 Ensure command is completed without errors */

 we have a valid command response */

 Ensure the latest updates are visible */

 Check for valid response */

	/* Fill default values incase of user did not pass

	 * valid parameters

 Hardware event handlers */

 update the local copy of link status */

 Ensure callback doesn't get unregistered until we finish it */

 Clear SW_INT for RPM and CMR_INT for CGX */

		/* Copy the response. Since only one command is active at a

		 * time, there is no way a response can get overwritten

 Ensure response is updated before thread context starts */

		/* There wont be separate events for link change initiated from

		 * software; Hence report the command responses as events

 Release thread waiting for completion  */

	/* Any new event or command response will be posted by firmware

	 * only after the current status is acked.

	 * Ack the interrupt register as well.

 APIs for PHY management using CGX firmware interface */

 callback registration for hardware events like link change */

 Do Link up for all the enabled lmacs */

 Enable interrupt */

	/* lmac_list specifies which lmacs are enabled

	 * when bit n is set to 1, LMAC[n] is enabled

 Reserve first entry for default MAC address */

 Add reference */

 Free all lmac related resources */

 Use mac_ops to get MAC specific features */

 MAP configuration registers */

 init wq for processing linkup requests */

 SPDX-License-Identifier: GPL-2.0

/* Marvell CN10K RPM driver

 *

 * Copyright (C) 2020 Marvell.

 *

 Enable 802.3 pause frame mode */

 Enable receive pause frames */

 Enable forward pause to TX block */

 Enable pause frames transmission */

 Set pause time and interval */

 Set pause interval as the hardware default is too short */

 ALL pause frames received are completely ignored */

 Disable forward pause to TX block */

 Disable pause frames transmission */

 Update idx to point per lmac Rx statistics page */

 Read lower 32 bits of counter */

	/* upon read of lower 32 bits, higher 32 bits are written

	 * to RPMX_MTI_STAT_DATA_HI_CDC

 Update idx to point per lmac Tx statistics page */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Admin Function Devlink

 *

 * Copyright (C) 2020 Marvell.

 *

 Clear interrupts */

 Clear interrupts */

 Clear interrupts */

 Clear interrupts */

 Get NIX AF MSIX vectors offset. */

 Register and enable NIX_AF_RVU_INT interrupt */

 Register and enable NIX_AF_GEN_INT interrupt */

 Register and enable NIX_AF_ERR_INT interrupt */

 Register and enable NIX_AF_RAS interrupt */

 Clear interrupts */

 Clear interrupts */

 Clear interrupts */

 Clear interrupts */

 Get NPA AF MSIX vectors offset. */

 Register and enable NPA_AF_RVU_INT interrupt */

 Register and enable NPA_AF_GEN_INT interrupt */

 Register and enable NPA_AF_ERR_INT interrupt */

 Register and enable NPA_AF_RAS interrupt */

 Devlink Params APIs */

 Devlink switch mode */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Admin Function driver

 *

 * Copyright (C) 2018 Marvell.

 *

/* For now considering MC resources needed for broadcast

 * pkt replication only. i.e 256 HWVFs + 12 PFs.

If blkaddr is 0, return the first nix block address*/

	/* MTU used for DWRR calculation is in power of 2 up until 64K bytes.

	 * Value of 4 is reserved for MTU value of 9728 bytes.

	 * Value of 5 is reserved for MTU value of 10240 bytes.

	/* MTU used for DWRR calculation is in power of 2 up until 64K bytes.

	 * Value of 4 is reserved for MTU value of 9728 bytes.

	 * Value of 5 is reserved for MTU value of 10240 bytes.

 Sync all in flight RX packets to LLC/DRAM */

	/* SW_SYNC ensures all existing transactions are finished and pkts

	 * are written to LLC/DRAM, queues should be teared down after

	 * successful SW_SYNC. Due to a HW errata, in some rare scenarios

	 * an existing transaction might end after SW_SYNC operation. To

	 * ensure operation is fully done, do the SW_SYNC twice.

 Check out of bounds */

 TLs aggegating traffic are shared across PF and VFs */

 By default we enable pause frames */

		/* If NIX1 block is present on the silicon then NIXes are

		 * assigned alternatively for lbk interfaces. NIX0 should

		 * send packets on lbk link 1 channels and NIX1 should send

		 * on lbk link 0 channels for the communication between

		 * NIX0 and NIX1.

		/* By default NIX0 is configured to send packet on lbk link 1

		 * (which corresponds to LBK1), same packet will receive on

		 * NIX1 over lbk link 0. If NIX1 sends packet on lbk link 0

		 * (which corresponds to LBK2) packet will receive on NIX0 lbk

		 * link 1.

		 * But if lbk links for NIX0 and NIX1 are negated, i.e NIX0

		 * transmits and receives on lbk link 0, whick corresponds

		 * to LBK1 block, back to back connectivity between NIX and

		 * LBK can be achieved (which is similar to 96xx)

		 *

		 *			RX		TX

		 * NIX0 lbk link	1 (LBK2)	1 (LBK1)

		 * NIX0 lbk link	0 (LBK0)	0 (LBK0)

		 * NIX1 lbk link	0 (LBK1)	0 (LBK2)

		 * NIX1 lbk link	1 (LBK3)	1 (LBK3)

		/* Note that AF's VFs work in pairs and talk over consecutive

		 * loopback channels.Therefore if odd number of AF VFs are

		 * enabled then the last VF remains with no pair.

	/* Add a UCAST forwarding rule in MCAM with this NIXLF attached

	 * RVU PF/VF's MAC address.

 Add this PF_FUNC to bcast pkt replication list */

 Install MCAM rule matching Ethernet broadcast mac address */

 Remove this PF_FUNC from bcast pkt replication list */

 Free and disable any MCAM entries used by this NIX LF */

 Disable DMAC filters used */

	/* Backpressure IDs range division

	 * CGX channles are mapped to (0 - 191) BPIDs

	 * LBK channles are mapped to (192 - 255) BPIDs

	 * SDP channles are mapped to (256 - 511) BPIDs

	 *

	 * Lmac channles and bpids mapped as follows

	 * cgx(0)_lmac(0)_chan(0 - 15) = bpid(0 - 15)

	 * cgx(0)_lmac(1)_chan(0 - 15) = bpid(16 - 31) ....

	 * cgx(1)_lmac(0)_chan(0 - 15) = bpid(64 - 79) ....

 Assign bpid based on cgx, lmac and chan id */

 Enable backpressure only for CGX mapped PFs and LBK/SDP interface */

 Map channel and bpid assign to it */

 IP's Length field */

 In ipv4, length field is at offset 2 bytes, for ipv6 it's 4 */

 i.e 2 bytes */

 No ID field in IPv6 header */

 IP's ID field */

 i.e 2 bytes */

 TCP's sequence number field */

 i.e 4 bytes */

 TCP's flags field */

 2 bytes */

 Get max HW supported format indices */

 Enable LSO */

	/* For TSO, set first and middle segment flags to

	 * mask out PSH, RST & FIN flags in TCP packet

	/* Setup default static LSO formats

	 *

	 * Configure format fields for TCPv4 segmentation offload

 Set rest of the fields to NOP */

 Configure format fields for TCPv6 segmentation offload */

 Set rest of the fields to NOP */

 RSS is not requested for this NIXLF */

 Alloc NIX RSS HW context memory and config the base */

 Config full RSS table size, enable RSS and caching */

 Config RSS group offset and sizes */

 Get current head pointer where to append this instruction */

 sync into memory */

 Ring the doorbell and wait for result */

 TODO: Replace this with some error code */

	/* Skip NIXLF check for broadcast MCE entry and bandwidth profile

	 * operations done by AF itself.

 Check if index exceeds max no of queues */

 Check if RSS is enabled and qidx is within range */

 Check if index exceeds MCE list length */

		/* Adding multicast lists for requests from PF/VFs is not

		 * yet supported, so ignore this.

 Check if SQ pointed SMQ belongs to this PF/VF or not */

	/* Currently we are not supporting enqueuing multiple instructions,

	 * so always choose first entry in result memory.

	/* Hardware uses same aq->res->base for updating result of

	 * previous instruction hence wait here till it is done.

 Clean result + context memory */

 Context needs to be written at RES_ADDR + 128 */

 Mask needs to be written at RES_ADDR + 256 */

 Submit the instruction to AQ */

 Set RQ/SQ/CQ bitmap if respective queue hw context is enabled */

 Copy read context into mailbox */

	/* Make copy of original context & mask which are required

	 * for resubmission

 exclude fields which HW can update */

	/* Context mask (cq_mask) holds mask value of fields which

	 * are changed in AQ WRITE operation.

	 * for example cq.drop = 0xa;

	 *	       cq_mask.drop = 0xff;

	 * Below logic performs '&' between cq and cq_mask so that non

	 * updated fields are masked out for request and response

	 * comparison

	/* HW errata 'AQ Modification to CQ could be discarded on heavy traffic'

	 * As a work around perfrom CQ context read after each AQ write. If AQ

	 * read shows AQ write is not updated perform AQ write again.

 CN10K mbox handler */

 Check if requested 'NIXLF <=> NPALF' mapping is valid */

 If default, use 'this' NIXLF's PFFUNC */

 Check if requested 'NIXLF <=> SSOLF' mapping is valid */

 If default, use 'this' NIXLF's PFFUNC */

	/* If RSS is being enabled, check if requested config is valid.

	 * RSS table size should be power of two, otherwise

	 * RSS_GRP::OFFSET + adder might go beyond that group or

	 * won't be able to use entire table.

 Reset this NIX LF */

 Alloc NIX RQ HW context memory and config the base */

 Set caching and queue count in HW */

 Alloc NIX SQ HW context memory and config the base */

 Alloc NIX CQ HW context memory and config the base */

 Initialize receive side scaling (RSS) */

 Alloc memory for CQINT's HW contexts */

 Alloc memory for QINT's HW contexts */

	/* Setup VLANX TPID's.

	 * Use VLAN1 for 802.1Q

	 * and VLAN0 for 802.1AD.

 Enable LMTST for this NIX LF */

 Set CQE/WQE size, NPA_PF_FUNC for SQBs and also SSO_PF_FUNC */

 Config Rx pkt length, csum checks and apad  enable / disable */

 Configure pkind for TX parse config */

 Disable NPC entries as NIXLF's contexts are not initialized yet */

 Configure RX VTAG Type 7 (strip) for vf vlan */

 Set macaddr of this PF/VF */

 set SQB size info */

 Get HW supported stat count */

 Get count of CQ IRQs and error IRQs supported per LF */

 Free any tx vtag def entries used by this NIX LF */

 Reset this NIX LF */

 Handle shaper update specially for few revisions */

 Check for rate register */

 Nothing special to do when state is not toggled */

 PIR/CIR disable */

 PIR/CIR enable */

 Wait until VLD(bit32) == 1 or C_CON(bit48) == 0 */

/* Disable shaping of pkts by a scheduler queue

 * at a given scheduler level.

 PIR not available at TL1 */

 Shaper state toggle needs wait/poll */

 Reset TL4's SDP link config */

 Reset TL2's CGX or LBK link config */

 Skip this if shaping is not supported */

 Clear level specific SW_XOFF */

 LBK links */

 SDP link */

 LBK links */

 CGX links */

 SDP link */

 For traffic aggregating scheduler level, one queue is enough */

 Get free SCHQ count and check if request can be accomodated */

 If contiguous queues are needed, check for availability */

	/* For traffic aggregating levels, queue alloc is based

	 * on transmit link to which PF_FUNC is mapped to.

 A single TL queue is allocated */

 Both contig and non-contig reqs doesn't make sense here */

	/* Adjust the queue request count if HW supports

	 * only one queue per level configuration.

 Allocate contiguous queue indices requesty first */

 Allocate non-contiguous queue indices */

 Update how many were allocated */

	/* Check if request is valid as per HW capabilities

	 * and can be accomodated.

 Allocate requested Tx scheduler queues */

 Reset queue config */

 enable cgx tx if disabled */

 Do SMQ flush and set enqueue xoff */

	/* Disable backpressure from physical link,

	 * otherwise SMQ flush may stall.

 Wait for flush to complete */

 restore cgx tx state */

 Disable TL2/3 queue links and all XOFF's before SMQ flush*/

	/* On PF cleanup, clear cfg done flag as

	 * PF would have changed default config.

		/* Do not clear pcifunc in txsch->pfvf_map[schq] because

		 * VF might be using this TL1 queue

 Flush SMQs */

 Now free scheduler queues to free pool */

		 /* TLs above aggregation level are shared across all PF

		  * and it's VFs, hence skip freeing them.

 Sync cached info for this LF in NDC-TX to LLC/DRAM */

	/* Clear SW_XOFF of this resource only.

	 * For SMQ level, all path XOFF's

	 * need to be made clear by user

	/* Flush if it is a SMQ. Onus of disabling

	 * TL2/3 queue links before SMQ flush is on user

 Free the resource */

 Check if this schq belongs to this PF/VF or not */

 Validate MDQ's TL4 parent */

 Validate TL4's TL3 parent */

 Validate TL3's TL2 parent */

 Validate TL2's TL1 parent */

	/* If shaping and coloring is not supported, then

	 * *_CIR and *_PIR registers should not be configured.

 Skip if PF has already done the config */

	/* On OcteonTx2 the config was in bytes and newer silcons

	 * it's changed to weight.

/* Register offset - [15:0]

 * Scheduler Queue number - [25:16]

		/* Enable all LBK links with channel 63 by default so that

		 * packets can be sent to LBK with a NPC TX MCAM rule

 Check if shaping and coloring is supported */

 Handle shaping state toggle specially */

 Replace PF/VF visible NIXLF slot with HW NIXLF id */

 Clear 'BP_ENA' config, if it's not allowed */

 Mark config as done for TL1 by PF */

		/* SMQ flush is special hence split register writes such

		 * that flush first and write rest of the bits later.

 RX VTAG Type 7 reserved for vf vlan */

 Scan all the entries and free the ones mapped to 'pcifunc' */

 rx vtag configuration */

 tx vtag configuration */

 Use RSS with RSS index 0 */

 All fields valid */

 Scan through the current list */

 If already exists, then delete */

 entry already exists */

 Add a new one to the list, at the tail */

 Get this PF/VF func's MCE index */

 Disable MCAM entry in NPC */

 Dump the updated list to HW */

 EOL should be set in last MCE */

 Get this PF/VF func's MCE index */

 skip multicast pkt replication for AF's VFs & SDP links */

 Skip PF0 (i.e AF) */

 If PF is not enabled, nothing to do */

 Get numVFs attached to this PF */

 This NIX0/1 block mapped to PF ? */

 save start idx of broadcast mce list */

 save start idx of multicast mce list */

 save the start idx of promisc mce list */

 idx-0 is for PF, followed by VFs */

			/* Add dummy entries now, so that we don't have to check

			 * for whether AQ_OP should be INIT/WRITE later on.

			 * Will be updated when a NIXLF is attached/detached to

			 * these PF/VFs.

 add dummy entries to multicast mce list */

 add dummy entries to promisc mce list */

 Alloc memory for multicast/mirror replication entries */

 Set max list length equal to max no of VFs per PF  + PF itself */

 Alloc memory for multicast replication buffers */

 Alloc pkind for NIX internal RX multicast/mirror replay */

 Allocate resource bimap for tx vtag def registers*/

 Alloc memory for saving entry to RVU PFFUNC allocation mapping */

	/* Get scheduler queue count of each type and alloc

	 * bitmap for each for alloc/free/attach operations.

		/* Allocate memory for scheduler queues to

		 * PF/VF pcifunc mapping info.

 Setup a default value of 8192 as DWRR MTU */

 CN10K supports LBK FIFO size 72 KB */

 RPM supports FIFO len 128 KB */

 Return '1' on OTx2 */

 Get stats count supported by HW */

 Reset tx stats */

 Reset rx stats */

 Returns the ALG index to be set into NPC_RX_ACTION */

 Scan over exiting algo entries to find a match */

 Clear all fields */

	/* Each of the 32 possible flow key algorithm definitions should

	 * fall into above incremental config (except ALG0). Otherwise a

	 * single NPC MCAM entry is not sufficient for supporting RSS.

	 *

	 * If a different definition or combination needed then NPC MCAM

	 * has to be programmed to filter such pkts and it's action should

	 * point to this definition to calculate flowtag or hash.

	 *

	 * The `for loop` goes over _all_ protocol field and the following

	 * variables depicts the state machine forward progress logic.

	 *

	 * keyoff_marker - Enabled when hash byte length needs to be accounted

	 * in field->key_offset update.

	 * field_marker - Enabled when a new field needs to be selected.

	 * group_member - Enabled when protocol is part of a group.

 Found a field marker, reset the field values */

 This should be set to 1, when SEL_CHAN is set */

 offset */

 1 byte */

 SIP offset */

 SIP + DIP, 8 bytes */

 Match only IPv4 */

 SIP offset */

 SIP + DIP, 32 bytes */

 Match only IPv6 */

 Sport + Dport, 4 bytes */

			/* Enum values for NPC_LID_LD and NPC_LID_LG are same,

			 * so no need to change the ltype_match, just change

			 * the lid for inner protocols

				/* Handle the case where any of the group item

				 * is enabled in the group but not the final one

			/* TCP/UDP/SCTP and ESP/AH falls at same offset so

			 * remember the TCP key offset of 40 byte hash key.

 VSID offset */

 DMAC 6 Byte */

 IPV6 hdr */

 1 Byte ext hdr*/

 4 bytes TID*/

 Skip TPID (2-bytes) */

 2 Bytes (Actually 12 bits) */

 Mask out the first nibble */

 SPI + sequence number */

 Found a valid flow key type */

			/* Use the key offset of TCP/UDP/SCTP fields

			 * for ESP/AH fields.

 Found a field marker, get the next field */

 Found a keyoff marker, update the new key_off */

 Processed all the flow key types */

 No room to add new flow hash algoritham */

 Generate algo fields for the given flow_cfg */

 Update ALGX_FIELDX register with generated fields */

 Store the flow_cfg for futher lookup */

 Failed to get algo index from the exiting list, reserve new  */

 Disable all flow key algx fieldx */

 IPv4/IPv6 SIP/DIPs */

 TCPv4/v6 4-tuple, SIP, DIP, Sport, Dport */

 UDPv4/v6 4-tuple, SIP, DIP, Sport, Dport */

 SCTPv4/v6 4-tuple, SIP, DIP, Sport, Dport */

 TCP/UDP v4/v6 4-tuple, rest IP pkts 2-tuple */

 TCP/SCTP v4/v6 4-tuple, rest IP pkts 2-tuple */

 UDP/SCTP v4/v6 4-tuple, rest IP pkts 2-tuple */

 TCP/UDP/SCTP v4/v6 4-tuple, rest IP pkts 2-tuple */

 untrusted VF can't overwrite admin(PF) changes */

 untrusted VF can't configure promisc/allmulti */

 add/del this PF_FUNC to/from mcast pkt replication list */

 add/del this PF_FUNC to/from promisc pkt replication list */

 install/uninstall allmulti entry */

 install/uninstall promisc entry */

 Update with requester's min/max lengths */

 Get this PF's numVFs and starting hwvf */

 For each VF, compare requested max/minlen */

 Compare requested max/minlen with PF's max/minlen */

 Update the request with max/min PF's and it's VF's max/min */

 Enable cgx tx if disabled for credits to be back */

 Disable new traffic to link */

 Wait for credits to return */

 Enable traffic back */

 Restore state of cgx tx */

 Check if requester wants to update SMQ's */

 Update min/maxlen in each of the SMQ attached to this PF/VF */

 Check if config is for SDP link */

 Check if the request is from CGX mapped RVU PF */

 Get CGX and LMAC to which this PF is mapped and find link */

 For VFs of PF0 ingress is LBK port, so config LBK link */

 Update transmit credits for CGX links */

 Set the interface configuration */

 CN10k supports 72KB FIFO size and max packet size of 64k */

 16 * max LBK datarate = 16 * 100Gbps */

	/* Set default min/max packet lengths allowed on NIX Rx links.

	 *

	 * With HW reset minlen value of 60byte, HW will treat ARP pkts

	 * as undersize and report them to SW as error pkts, hence

	 * setting it to 40 bytes.

	/* Set credits for Tx links assuming max packet length allowed.

	 * This will be reconfigured based on MTU set for PF/VF.

 Skip when cgx is not available or lmac cnt is zero */

 Enable credits and set credit pkt count to max allowed */

 Set Tx credits for LBK link */

 Enable credits and set credit pkt count to max allowed */

 Start X2P bus calibration */

 Wait for calibration to complete */

 Check if CGX devices are ready */

 Skip when cgx port is not available */

 Check if LBK is ready */

 Clear 'calibrate_x2p' bit */

 Set admin queue endianness */

 Do not bypass NDC cache */

 Disable caching of SQB aka SQEs */

	/* Result structure can be followed by RQ/SQ/CQ context at

	 * RES + 128bytes and a write mask at RES + 256 bytes, depending on

	 * operation type. Alloc sufficient result memory for all operations.

	/* On OcteonTx2 DWRR quantum is directly configured into each of

	 * the transmit scheduler queues. And PF/VF drivers were free to

	 * config any value upto 2^24.

	 * On CN10K, HW is modified, the quantum configuration at scheduler

	 * queues is in terms of weight. And SW needs to setup a base DWRR MTU

	 * at NIX_AF_DWRR_RPM_MTU / NIX_AF_DWRR_SDP_MTU. HW will do

	 * 'DWRR MTU * weight' to get the quantum.

	 *

	 * Check if HW uses a common MTU for all DWRR quantum configs.

	 * On OcteonTx2 this register field is '0'.

		/* As per a HW errata in 96xx A0/B0 silicon, NIX may corrupt

		 * internal state when conditional clocks are turned off.

		 * Hence enable them.

 Set chan/link to backpressure TL3 instead of TL2 */

		/* Disable SQ manager's sticky mode operation (set TM6 = 0)

		 * This sticky mode is known to cause SQ stalls when multiple

		 * SQs are mapped to same SMQ and transmitting pkts at a time.

 Calibrate X2P bus to check if CGX/LBK links are fine */

 Setup capabilities of the NIX block */

 Initialize admin queue */

 Restore CINT timer delay to HW reset values */

 For better performance use NDC TX instead of NDC RX for SQ's SQEs" */

 Configure segmentation offload formats */

		/* Config Outer/Inner L2, IP, TCP, UDP and SCTP NPC layer info.

		 * This helps HW protocol checker to identify headers

		 * and validate length and checksums.

			/* Enable APAD calculation for other protocols

			 * matching APAD0 and APAD1 lt def registers.

			/* Receive ethertype defination register defines layer

			 * information in NPC_RESULT_S to identify the Ethertype

			 * location in L2 header. Used for Ethertype overwriting

			 * in inline IPsec flow.

 Initialize CGX/LBK/SDP link credits, min/max pkt lengths */

 Enable Channel backpressure */

 Cleanup NPC MCAM entries, free Tx scheduler queues being used */

 reset HW config done for Switch headers */

 Disabling CGX and NPC config done for PTP */

 Undo NPC config done for PTP */

 Find existing matching LSO format, if any */

 Match found */

 Enable context prefetching */

 Set OPCODE and EGRP */

 Set CPT queue for inline IPSec */

 Set CPT credit */

 Set TT, TAG_CONST, SA_POW2_SIZE and LENM1_MAX */

 Set SA_IDX_W and SA_IDX_MAX */

 Set SA base address */

 overwrite vf mac address with default_mac */

 NIX ingress policers or bandwidth profiles APIs */

	/* Extract PCP and DEI fields from outer VLAN from byte offset

	 * 2 from the start of LB_PTR (ie TAG).

	 * VLAN0 is Outer VLAN and VLAN1 is Inner VLAN. Inner VLAN

	 * fields are considered when 'Tunnel enable' is set in profile.

 DSCP field in outer and tunneled IPv4 packets */

 DSCP field (traffic class) in outer and tunneled IPv6 packets */

 Context is all zeros, submit to AQ */

 Set AF as current owner for INIT ops to succeed */

			/* There is no enable bit in the profile context,

			 * so no context disable. So let's INIT them here

			 * so that PF/VF later on have to just do WRITE to

			 * setup policer rates and config.

		/* Allocate memory for maintaining ref_counts for MID level

		 * profiles, this will be needed for leaf layer profiles'

		 * aggregation.

 Set policer timeunit to 2us ie  (19 + 1) * 100 nsec = 2us */

 Bits [15:14] in profile index represent layer */

	/* Check if the profile is allocated to the requesting PCIFUNC or not

	 * with the exception of AF. AF is allowed to read and update contexts.

	/* If this profile is linked to higher layer profile then check

	 * if that profile is also allocated to the requesting PCIFUNC

	 * or not.

	/* Leaf layer profile can link only to mid layer and

	 * mid layer to top layer.

 Allocate a max of 'MAX_BANDPROF_PER_PFFUNC' profiles */

 Free all the profiles allocated to the PCIFUNC */

 Clear ratelimit aggregation, if any */

 Free the requested profile indices */

 Clear ratelimit aggregation, if any */

 Fetch the RQ's context to see if policing is enabled */

 Get the bandwidth profile ID mapped to this RQ */

 Check if any other leaf profile is marked with same match_id */

	/* Fetch the matching profile's context to check if it's already

	 * mapped to a mid level profile.

		/* Get Mid layer prof index and map leaf_prof index

		 * also such that flows that are being steered

		 * to different RQs and marked with same match_id

		 * are rate limited in a aggregate fashion

	/* Allocate a mid layer profile and

	 * map both 'leaf_prof' and 'leaf_match' profiles to it.

 Initialize mid layer profile same as 'leaf_prof' */

 Clear higher layer enable bit in the mid profile, just in case */

 Map both leaf profiles to this mid layer profile */

 Called with mutex rsrc_lock */

 If ref_count is zero, free mid layer profile */

 Return number of bandwidth profiles free at each layer */

 Set the policer timeunit in nanosec */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Ethernet driver

 *

 * Copyright (C) 2020 Marvell.

 *

 HW device stats */

 Driver level stats */

 Get device and per queue statistics */

		/* Fetch fwdata again because it's been recently populated with

		 * latest PHY FEC stats.

 Get no of queues device supports and current queue count */

 Set no of Tx, Rx queues to be used */

 Permitted lengths are 16 64 256 1K 4K 16K 64K 256K 1M  */

	/* On some silicon variants a skid or reserved CQEs are

	 * needed to avoid CQ overflow.

	/* Due pipelining impact minimum 2000 unused SQ CQE's

	 * need to be maintained to avoid CQ overflow, hence the

	 * minimum 4K size.

 Assigned to the nearest possible exponent. */

	/* 'cq_time_wait' is 8bit and is in multiple of 100ns,

	 * so clamp the user given value to the range of 1 to 25usec.

	/* Rx and Tx are mapped to same CQ, check which one

	 * is changed, if both then choose the min.

	/* Max ecount_wait supported is 16bit,

	 * so clamp the user given value to the range of 1 to 64k.

	/* Rx and Tx are mapped to same CQ, check which one

	 * is changed, if both then choose the min.

 Mimimum is IPv4 and IPv6, SIP/DIP */

 Mimimum is IPv4 and IPv6, SIP/DIP */

		/* Different config for v4 and v6 is not supported.

		 * Both of them have to be either 4-tuple or 2-tuple.

			/* If VLAN hashing is also requested for ESP then do not

			 * allow because of hardware 40 bytes flow key limit.

			/* Disable IPv4 proto hashing since IPv6 SA+DA(32 bytes)

			 * and ESP SPI+sequence(8 bytes) uses hardware maximum

			 * limit of 40 byte flow key.

 RSS context configuration */

 Get RSS configuration */

 Configure RSS table and hash key */

 LBK link is internal and always UP */

 Firmware does not support AUTO mode consider it as FEC_OFF */

 Add fec modes to existing modes */

 CGX link modes to Ethtool link mode mapping */

 SGMII  Mode */

 SGMII mode is set */

	/* Firmware does not support requesting multiple advertised modes

	 * return first set bit

 Check requested modes against supported modes by hardware */

	/* firmware expects 1 for half duplex and 0 for full duplex

	 * hence inverting

 VF's ethtool APIs */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Ethernet driver

 *

 * Copyright (C) 2020 Marvell.

 *

 First segment is always skb->data */

 The first 8 bytes is the timestamp */

		/* Check if data starts at some nonzero offset

		 * from the start of the buffer.  For now the

		 * only possible offset is 8 bytes in the case

		 * where packet is prepended by a timestamp.

	/* If more than MAX_SKB_FRAGS fragments are received then

	 * give back those buffer pointers to hardware for reuse.

		/* For now ignore all the NPC parser errors and

		 * pass the packets to stack.

 If RXALL is enabled pass on packets to stack. */

 Free buffer back to pool */

 Free CQEs to HW */

 Free CQEs to HW */

 Check if queue was stopped earlier due to ring full */

 Clear the IRQ */

 If interface is going down, don't re-enable IRQ */

 Re-enable interrupts */

 Packet data stores should finish before SQE is flushed to HW */

 Add SQE scatter/gather subdescriptor structure */

			/* Next subdc always starts at a 16byte boundary.

			 * So if sg->segs is whether 2 or 3, offset += 16bytes.

 Save DMA mapping info for later unmapping */

 Add SQE extended header subdescriptor */

 Only TSOv4 and TSOv6 GSO offloads are supported */

			/* HW adds payload size to 'ip_hdr->tot_len' while

			 * sending TSO segment, hence set payload length

			 * in IP header of the packet to just header length.

			/* HW adds payload size to length fields in IP and

			 * UDP headers while segmentation, hence adjust the

			 * lengths to just header sizes.

 wait for the memory operation */

 Add SQE header subdescriptor structure */

	/* Check if SQE was framed before, if yes then no need to

	 * set these constants again and again.

 Don't free Tx buffers to Aura */

 Post a CQE Tx after pkt transmission */

 Set SQE identifier which will be used later for freeing SKB */

 Offload TCP/UDP checksum to HW */

 get vlan protocol Ethertype */

			/* In case of TSO, HW needs this to be explicitly set.

			 * So set this always, instead of adding a check.

 Get payload length at skb->data */

 Skip skb->data, if there is no payload */

 Save DMA mapping info for later unmapping */

 Add SG descriptors with buffer addresses */

			/* Next subdc always starts at a 16byte boundary.

			 * So if sg->segs is whether 2 or 3, offset += 16bytes.

	/* Map SKB's fragments to DMA.

	 * It's done here to avoid mapping for every TSO segment's packet.

 Set SQE's SEND_HDR */

 Add TSO segment's pkt header */

 Add TSO segment's payload data fragments */

		/* DMA mappings and skb needs to be freed only after last

		 * TSO segment is transmitted out. So set 'PNC' only for

		 * last segment. Also point last segment's sqe_id to first

		 * segment's SQE index where skb address and DMA mappings

		 * are saved.

 Flush SQE to HW */

 On 96xx A0, HW TSO not supported */

	/* HW has an issue due to which when the payload of the last LSO

	 * segment is shorter than 16 bytes, some header fields may not

	 * be correctly modified, hence don't offload such TSO segments.

 HW TSO */

 SW TSO */

	/* Check if there is room for new SQE.

	 * 'Num of SQBs freed to SQ's pool - SQ's Aura count'

	 * will give free SQE count.

	/* If SKB doesn't fit in a single SQE, linearize it.

	 * TODO: Consider adding JUMP descriptor instead.

 Insert vlan tag before giving pkt to tso */

	/* Set SQE's SEND_HDR.

	 * Do not clear the first 64bit as it contains constant info.

 Add extended header if needed */

 Add SG subdesc with data frags */

 Flush SQE to HW */

 Free CQEs to HW */

 Free CQEs to HW */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Virtual Function ethernet driver

 *

 * Copyright (C) 2020 Marvell.

 *

 RVU VF Interrupt Vector Enumeration */

 Check if valid, if not reply with a invalid msg */

 Clear the IRQ */

 Read latest mbox data */

 Check for PF => VF response messages */

 Check for PF => VF notification messages */

 Disable VF => PF mailbox IRQ */

 Register mailbox interrupt handler */

	/* Enable mailbox interrupt for msgs coming from PF.

	 * First clear to avoid spurious interrupts, if any.

 Check mailbox communication with PF */

		/* For cn10k platform, VF mailbox region is in its BAR2

		 * register space

		/* Mailbox is a reserved memory (in RAM) region shared between

		 * admin function (i.e PF0) and this VF, shouldn't be mapped as

		 * device memory to allow unaligned accesses.

 LBKs do not receive link events so tell everyone we are up here */

 Check again, incase SQBs got freed up */

 Init VF <=> PF mailbox stuff */

 Register mailbox interrupt */

 Request AF to attach NPA and LIX LFs to this AF */

 Don't check for error.  Proceed without ptp */

 Assign default mac address */

 Support TSO on tag interface */

 To distinguish, for LBK VFs set netdev name explicitly */

 Need to subtract 1 to get proper VF number */

 Enable pause frames by default */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Ethernet driver

 *

 * Copyright (C) 2021 Marvell.

 *

 Total LMTLINES = num_online_cpus() * 32 (For Burst flush).*/

 Get memory to put this msg */

 128 byte */

 Only one SMQ is allocated, map all SQ's to that SMQ  */

 Cache SQB */

	/* Due pipelining impact minimum 2000 unused SQ CQE's

	 * need to maintain to avoid CQ overflow.

 Fill AQ info */

 Refill pool with new buffers */

	/* FIXME: val[0:10] LMT_ID.

	 * [12:15] no of LMTST - 1 in the burst.

	 * [19:63] data size of each LMTST in the burst except first.

	/* Target address for LMTST flush tells HW how many 128bit

	 * words are present.

	 * tar_addr[6:4] size of first LMTST - 1 in units of 128b.

 Free all bandwidth profiles allocated */

 1 second */

 Valid rate exponent range: 0 - 22 */

	/* Burst is calculated as

	 * (1+[BURST_MANTISSA]/256)*2^[BURST_EXPONENT]

	 * This is the upper limit on number tokens (bytes) that

	 * can be accumulated in the bucket.

 No float: can't express mantissa in this case */

	/* Calculate mantissa

	 * Find remaining bytes 'burst - 2^burst_exp'

	 * mantissa = (remaining bytes) / 2^ (burst_exp - 8)

	/* Figure out mantissa, exponent and divider from given max pkt rate

	 *

	 * To achieve desired rate HW adds

	 * (1+[RATE_MANTISSA]/256)*2^[RATE_EXPONENT] tokens (bytes) at every

	 * policer timeunit * 2^rdiv ie 2 * 2^rdiv usecs, to the token bucket.

	 * Here policer timeunit is 2 usecs and rate is in bits per sec.

	 * Since floating point cannot be used below algorithm uses 1000000

	 * scale factor to support rates upto 100Gbps.

 Enable policing and set the bandwidth profile (policer) index */

 Fill AQ info */

 Remove RQ's policer mapping */

 Get exponent and mantissa values for the desired rate */

 Init bandwidth profile */

 Set initial color mode to blind */

 Set rate and burst values */

		/* The amount of decremented tokens is calculated according to

		 * the following equation:

		 * max([ LMODE ? 0 : (packet_length - LXPTR)] +

		 *	     ([ADJUST_MANTISSA]/256 - 1) * 2^[ADJUST_EXPONENT],

		 *	1/256)

		 * if LMODE is 1 then rate limiting will be based on

		 * PPS otherwise bps.

		 * The aim of the ADJUST value is to specify a token cost per

		 * packet in contrary to the packet length that specifies a

		 * cost per byte. To rate limit based on PPS adjust mantissa

		 * is set as 384 and exponent as 1 so that number of tokens

		 * decremented becomes 1 i.e, 1 token per packeet.

	/* Two rate three color marker

	 * With PEIR/EIR set to zero, color will be either green or red

	/* Setting exponent value as 24 and mantissa as 0 configures

	 * the bucket with zero values making bucket unused. Peak

	 * information rate and Excess information rate buckets are

	 * unused here.

 Fill AQ info */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Physical Function ethernet driver

 *

 * Copyright (C) 2020 Marvell.

 *

 Supported devices */

 end of table */

 Disable VFs ME interrupts */

 Disable VFs FLR interrupts */

 clear transcation pending bit */

 Clear interrupt */

 Disable the interrupt */

 clear trpend bit */

 clear interrupt */

 Register ME interrupt handler*/

 Register FLR interrupt handler */

 Enable ME interrupt for all VFs*/

 Enable FLR interrupt for all VFs*/

 start from 0 */

		/* The hdr->num_msgs is set to zero immediately in the interrupt

		 * handler to  ensure that it holds a correct value next time

		 * when the interrupt handler is called.

		 * pf->mbox.num_msgs holds the data for use in pfaf_mbox_handler

		 * pf>mbox.up_num_msgs holds the data for use in

		 * pfaf_mbox_up_handler.

 Msgs are already copied, trigger VF's mbox irq */

 Restore VF's mbox bounce buffer region address */

		/* Set VF's mailbox memory as PF's bounce buffer memory, so

		 * that explicit copying of VF's msgs to PF=>AF mbox region

		 * and AF=>PF responses to VF's mbox region can be avoided.

 Check if msgs fit into destination area and has valid size */

 restore PF mbase and exit */

		/* At this point, all the VF messages sent to AF are acked

		 * with proper responses and responses are copied to VF

		 * mailbox hence raise interrupt to VF.

 Check if msgs fit into destination area */

 Set VF's number in each of the msg */

 Handle VF interrupts */

	/* On CN10K platform, PF <-> VF mailbox region follows after

	 * PF <-> AF mailbox region.

 Clear PF <=> VF mailbox IRQ */

 Enable PF <=> VF mailbox IRQ */

 Disable PF <=> VF mailbox IRQ */

 Register MBOX0 interrupt handler */

 Register MBOX1 interrupt handler */

 message response heading VF */

 Copy the link info sent by AF */

 notify VFs about link event */

 interface has not been fully configured yet */

 Check if valid, if not reply with a invalid msg */

 Skip processing VF's messages */

 Clear the IRQ */

 Disable AF => PF mailbox IRQ */

 Register mailbox interrupt handler */

	/* Enable mailbox interrupt for msgs coming from AF.

	 * First clear to avoid spurious interrupts, if any.

 Check mailbox communication with AF */

	/* Mailbox is a reserved memory (in RAM) region shared between

	 * admin function (i.e AF) and this PF, shouldn't be mapped as

	 * device memory to allow unaligned accesses.

 CQ */

 SQ */

	/* Disable interrupts.

	 *

	 * Completion interrupts behave in a level-triggered interrupt

	 * fashion, and hence have to be cleared only after it is serviced.

 Schedule NAPI */

 Disable CQs */

 Disable SQs */

 Free SQB pointers */

	/* The data transferred by NIX to memory consists of actual packet

	 * plus additional data which has timestamp and/or EDSA/HIGIG2

	 * headers if interface is configured in corresponding modes.

	 * NIX transfers entire data using 6 segments/buffers and writes

	 * a CQE_RX descriptor with those segment addresses. First segment

	 * has additional data prepended to packet. Also software omits a

	 * headroom of 128 bytes in each segment. Hence the total size of

	 * memory needed to receive a packet with 'mtu' is:

	 * frame size =  mtu + additional data;

	 * memory = frame_size + headroom * 6;

	 * each receive buffer size = memory / 6;

	/* Set required NPA LF's pool counts

	 * Auras and Pools are used in a 1:1 mapping,

	 * so, aura count = pool count.

 Maximum hardware supported transmit length */

 NPA init */

 NIX init */

 Enable backpressure */

 Init Auras and pools used by NIX RQ, for free buffer ptrs */

 Init Auras and pools used by NIX SQ, for queueing SQEs */

 Reset NPA LF */

 Ensure all SQE are processed */

 Stop transmission */

 Disable backpressure */

 Disable RQs */

Dequeue all CQEs */

 Free RQ buffer pointers*/

 Free all ingress bandwidth profiles allocated */

 Reset NIX LF */

 Disable NPA Pool and Aura hw context */

 Reset NPA LF */

 Write unicast address to mcam entries or del from mcam */

	/* RQ and SQs are mapped to different CQs,

	 * so find out max CQ IRQs (i.e CINTs) needed.

 CQ size of RQ */

 CQ size of SQ */

 Register NAPI handler */

		/* RQ0 & SQ0 are mapped to CINT0 and so on..

		 * 'cq_ids[0]' points to RQ's CQ and

		 * 'cq_ids[1]' points to SQ's CQ and

		 * 'cq_ids[2]' points to XDP's CQ and

 Set maximum frame size allowed in HW */

 Setup segmentation algorithms, if failed, clear offload capability */

 Initialize RSS */

 Register Queue IRQ handlers */

 Enable QINT IRQ */

 Register CQ IRQ handlers */

 Enable CQ IRQ */

 When reinitializing enable time stamping if it is enabled before */

 'intf_down' may be checked on any cpu */

 we have already received link status notification */

 Restore pause frame settings */

 Install DMAC Filters */

 If the DOWN flag is set resources are already freed */

 'intf_down' may be checked on any cpu */

 First stop packet Rx/Tx */

 Clear RSS enable flag */

 Cleanup Queue IRQ */

 Cleanup CQ NAPI and IRQ */

 Disable interrupt */

 Do not clear RQ/SQ ringsize settings */

 Check for minimum and maximum packet length */

 Check again, incase SQBs got freed up */

 reserved for future extensions */

 free old tx vtag entry */

 rx */

 tx */

 rx */

 af fills the destination mac addr */

 tx */

 configure tx vtag params */

 tx vlan cfg */

 qos is currently unsupported */

 Abort xmit if xdp queue is not */

	/* Network stack and XDP shared same rx queues.

	 * Use separate tx queues for XDP and network stack.

 Let AF reset VF permissions as sriov is disabled */

	/* Check if AF has setup revision for RVUM block,

	 * otherwise this driver probe should be deferred

	 * until AF driver comes up.

	/* NPA interrupts are inot registered, so alloc only

	 * upto NIX vector offset.

 Set number of queues */

 Map CSRs */

 Init PF <=> AF mailbox stuff */

 Register mailbox interrupt */

	/* Request AF to attach NPA and NIX LFs to this PF.

	 * NIX and NPA LFs are needed for this PF to function as a NIC.

 Assign default mac address */

 Don't check for error.  Proceed without ptp */

	/* NPA's pool is a stack to which SW frees buffer pointers via Aura.

	 * HW allocates buffer pointer from stack and uses it for DMA'ing

	 * ingress packet. In some scenarios HW can free back allocated buffer

	 * pointers to pool. This makes it impossible for SW to maintain a

	 * parallel list where physical addresses of buffer pointers (IOVAs)

	 * given to HW can be saved for later reference.

	 *

	 * So the only way to convert Rx packet's buffer address is to use

	 * IOMMU's iova_to_phys() handler which translates the address by

	 * walking through the translation tables.

 Support TSO on tag interface */

 HW supports tc offload but mutually exclusive with n-tuple filters */

 Initialize SR-IOV resources */

 Enable link notifications */

 Enable pause frames by default */

 Init PF <=> VF mailbox stuff */

 Disable link notifications */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Ethernet driver

 *

 * Copyright (C) 2020 Marvell.

 *

 check if PTP block is available */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Ethernet driver

 *

 * Copyright (C) 2021 Marvell.

 *

	/* Store dmacindex returned by CGX/RPM driver which will

	 * be used for macaddr update/remove

/* CGX/RPM blocks support max unicast entries of 32.

 * on typical configuration MAC block associated

 * with 4 lmacs, each lmac will have 8 dmac entries

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Ethernet driver

 *

 * Copyright (C) 2020 Marvell.

 *

 Sync MAC address with RVU AF */

 update dmac field in vlan offload rule */

 update dmac address in ntuple and DMAC filter list */

 Default or reserved index */

 Get memory to put this msg */

			/* The shared memory buffer can be full.

			 * Flush it and retry

 Fill AQ info */

	/* 352bit or 44byte key needs to be configured as below

	 * NIX_LF_RX_SECRETX0 = key<351:288>

	 * NIX_LF_RX_SECRETX1 = key<287:224>

	 * NIX_LF_RX_SECRETX2 = key<223:160>

	 * NIX_LF_RX_SECRETX3 = key<159:96>

	 * NIX_LF_RX_SECRETX4 = key<95:32>

	 * NIX_LF_RX_SECRETX5<63:32> = key<31:0>

 Init RSS key if it is not setup already */

 Set RSS group 0 as default indirection table */

 Flowkey or hash config to be used for generating flow tag */

 Setup UDP segmentation algorithm in HW */

 IP's Length field */

 In ipv4, length field is at offset 2 bytes, for ipv6 it's 4 */

 i.e 2 bytes */

 No ID field in IPv6 header */

 Increment IPID */

 i.e 2 bytes */

 Update length in UDP header */

 Setup segmentation algorithms in HW and retrieve algorithm index */

 UDPv4 segmentation */

 Setup UDP/IP header fields that HW should update per segment */

 UDPv6 segmentation */

 Setup UDP/IP header fields that HW should update per segment */

	/* Configure CQE interrupt coalescing parameters

	 *

	 * HW triggers an irq when ECOUNT > cq_ecount_wait, hence

	 * set 1 less than cq_ecount_wait. And cq_time_wait is in

	 * usecs, convert that to 100ns count.

 Schedule a task if no other task is running */

 If AF doesn't provide a valid MAC, generate a random one */

 Set topology e.t.c configuration */

 MDQ config */

 Set DWRR quantum */

 Enable this queue and backpressure */

		/* Default config for TL1.

		 * For VF this is always ignored.

		/* On CN10K, if RR_WEIGHT is greater than 16384, HW will

		 * clip it to 16384, so configuring a 24bit max value

		 * will work on both OTx2 and CN10K.

 Get memory to put this msg */

 Request one schq per level */

 Free the transmit schedulers */

 Clear the txschq list */

/* RED and drop levels of CQ on packet reception.

 * For CQ level is measure of emptiness ( 0x0 = full, 255 = empty).

/* RED and drop levels of AURA for packet reception.

 * For AURA level is measure of fullness (0x0 = empty, 255 = full).

 * Eg: For RQ length 1K, for pass/drop level 204/230.

 * RED accepts pkts if free pointers > 102 & <= 205.

 * Drops pkts if free pointers < 102.

 BP when 85% is full */

 RED when 95% is full */

 Drop when 99% is full */

 Get memory to put this msg */

 Use large packet buffer aura */

 Copying of packet to CQE not needed */

 Copy full 32bit flow_tag to CQE header */

 Enable RED dropping for AURA */

 Enable RED dropping for CQ/SSO */

 Fill AQ info */

 Get memory to put this msg */

 128 byte */

 Only one SMQ is allocated, map all SQ's to that SMQ  */

 Cache SQB */

	/* Due pipelining impact minimum 2000 unused SQ CQE's

	 * need to maintain to avoid CQ overflow.

 Fill AQ info */

 Set SQE threshold to 10% of total SQEs */

 Allocate memory for CQEs */

 Save CQE CPU base for faster reference */

	/* In case where all RQs auras point to single pool,

	 * all CQs receive buffer pool also point to same pool.

 Get memory to put this msg */

 Enable receive CQ backpressure */

 Set backpressure level is same as cq pass level */

 Fill AQ info */

			/* Schedule a WQ if we fails to free atleast half of the

			 * pointers else enable napi for this RQ.

 Initialize RX queues */

 Initialize TX queues */

 Initialize completion queues */

 Initialize work queue for receive buffer refill */

 Get memory to put this msg */

 Set RQ/SQ/CQ counts */

	/* We don't know absolute NPA LF idx attached.

	 * AF will replace 'RVU_DEFAULT_PF_FUNC' with

	 * NPA LF attached to this RVU PF/VF.

	/* Disable alignment pad, enable L2 length check,

	 * enable L4 TCP/UDP checksum verification.

 Free SQB and RQB pointers from the aura pool */

	/* Allocate memory for HW to update Aura count.

	 * Alloc one cache line, so that it fits all FC_STYPE modes.

 Initialize this aura's context via AF */

 Shared mbox memory buffer is full, flush it and retry */

 Will be filled by AF with correct pool context address */

 Store count on all updates */

 Enable backpressure for RQ aura */

		/* If NIX1 LF is attached then specify NIX1_RX.

		 *

		 * Below NPA_AURA_S[BP_ENA] is set according to the

		 * NPA_BPINTF_E enumeration given as:

		 * 0x0 + a*0x1 where 'a' is 0 for NIX0_RX and 1 for NIX1_RX so

		 * NIX0_RX is 0x0 + 0*0x1 = 0

		 * NIX1_RX is 0x0 + 1*0x1 = 1

		 * But in HRM it is given that

		 * "NPA_AURA_S[BP_ENA](w1[33:32]) - Enable aura backpressure to

		 * NIX-RX based on [BP] level. One bit per NIX-RX; index

		 * enumerated by NPA_BPINTF_E."

 Set backpressure level for RQ's Aura */

 Fill AQ info */

 Alloc memory for stack which is used to store buffer pointers */

 Initialize this pool's context via AF */

 Shared mbox memory buffer is full, flush it and retry */

 Fill AQ info */

	/* Calculate number of SQBs needed.

	 *

	 * For a 128byte SQE, and 4K size SQB, 31 SQEs will fit in one SQB.

	 * Last SQE is used for pointing to next SQB.

 Get no of stack pages needed */

 Initialize aura context */

 Initialize pool context */

 Flush accumulated messages */

 Allocate pointers and free them to aura/pool */

 Initialize aura context */

 Flush accumulated messages */

 Allocate pointers and free them to aura/pool */

	/* Pool - Stack of free buffer pointers

	 * Aura - Alloc/frees pointers from/to pool for NIX DMA.

 Get memory to put this msg */

 Set aura and pool counts */

 detach all */

 Send detach request to AF */

 Get memory to put this msg */

 Send attach request to AF */

	/* If the platform has two NIX blocks then LF may be

	 * allocated from NIX1.

 Get NPA and NIX MSIX vector offsets */

 Request AQ to disable this context */

 Mbox message handlers */

 Setup transmit scheduler list */

 CQ interrupts */

		/* HW counts VLAN insertion bytes (8 for double tag)

		 * irrespective of whether SQE is requesting to insert VLAN

		 * in the packet or not. Hence these 8 bytes have to be

		 * discounted from max packet size otherwise HW will throw

		 * SMQ errors

 Also save DWRR MTU, needed for DWRR weight calculation */

 Nothing to do here */					\

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU PF/VF Netdev Devlink

 *

 * Copyright (C) 2021 Marvell.

 Devlink Params APIs */

 Devlink OPs */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Ethernet driver

 *

 * Copyright (C) 2021 Marvell.

 *

 Egress rate limiting definitions */

 Bitfields in NIX_TLX_PIR register */

 lock for stats */

 Max flows changed, free the existing bitmap */

	/* Burst is calculated as

	 * ((256 + BURST_MANTISSA) << (1 + BURST_EXPONENT)) / 256

	 * Max supported burst size is 130,816 bytes.

	/* Rate calculation by hardware

	 *

	 * PIR_ADD = ((256 + mantissa) << exp) / 256

	 * rate = (2 * PIR_ADD) / ( 1 << div_exp)

	 * The resultant rate is in Mbps.

	/* 2Mbps to 100Gbps can be expressed with div_exp = 0.

	 * Setting this to '0' will ease the calculation of

	 * exponent and mantissa.

 Instead of disabling rate limiting, set all values to max */

 All SQs share the same TL4, so pick the first scheduler */

 Get exponent and mantissa values from the desired rate */

 Convert bytes per second to Mbps */

 npc_install_flow_req doesn't support passing a target pcifunc */

 use RX_VTAG_TYPE7 which is initialized to strip vlan tag */

 Ingress ratelimiting is not supported on OcteonTx2 */

				/* The algorithm used to calculate rate

				 * mantissa, exponent values for a given token

				 * rate (token can be byte or packet) requires

				 * token rate to be mutiplied by 8.

 All EtherTypes can be matched, no hw limitation */

 Send message to AF */

 allocate memory for the new flow and it's node */

 If a flow exists with the same cookie, delete it */

 Send message to AF */

 add new flow to flow-table */

 Ingress ratelimiting is not supported on OcteonTx2 */

 Convert to bits per second */

 Exclude receive queue 0 being used for police action */

 SPDX-License-Identifier: GPL-2.0

/* Marvell RVU Ethernet driver

 *

 * Copyright (C) 2020 Marvell.

 *

 Send message to AF to free MCAM entries */

 Free current ones and allocate new ones with requested count */

	/* In a single request a max of NPC_MAX_NONCONTIG_ENTRIES MCAM entries

	 * can only be allocated.

		/* Allocate higher priority entries for PFs, so that VF's entries

		 * will be on top of PF.

 Send message to AF */

		/* If this request is not fulfilled, no need to send

		 * further requests.

	/* Multiple MCAM entry alloc requests could result in non-sequential

	 * MCAM entries in the flow_ent[] array. Sort them in an ascending order,

	 * otherwise user installed ntuple filter index and MCAM entry index will

	 * not be in sync.

 Send message to AF */

 Allocate entries for Ntuple filters */

	/* Allocate bare minimum number of MCAM entries needed for

	 * unicast and ntuple filters.

 Check if MCAM entries are allocate or not */

 DMAC filters are not allocated */

/*  On success adds mcam entry

 *  On failure enable promisous mode

 dont have free mcam entries or uc list is greater than alloted */

 unicast offset starts with 32 0..31 for ntuple */

 check does mcam entry exists for given mac */

 Send message to AF */

 NPC profile doesn't extract AH/ESP header fields */

 NPC profile doesn't extract AH/ESP header fields */

 bits not set in mask are don't care */

 Partial masks not supported */

 Only ETH_P_8021Q and ETH_P_802AD types supported */

 Not Drop/Direct to queue but use action in default entry */

	/* CGX/RPM block dmac filtering configured for white listing

	 * check for action other than DROP

 free the allocated msg above */

		/* change to unicast only if action of default entry is not

		 * requested by user

 ethtool ring_cookie has (VF + 1) for VF */

 Send message to AF */

 Copy PF mac address */

 Install DMAC filter with PF mac address */

 struct copy */

 Sync dmac filter table with updated fields */

 Install PF mac address to DMAC filter list */

 add the new flow installed to list */

 Send message to AF */

 user not allowed to remove dmac filter with interface mac */

		/* If all dmac filters are removed delete macfilter with

		 * interface mac address and configure CGX/RPM block in

		 * promiscuous mode

 remove all flows */

 Send message to AF to free MCAM entries */

 Send message to AF */

 Send message to AF */

 Dont have enough mcam entries */

 config strip, capture and size */

 rx vlan cfg */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

 Copyright (c) 2020 Marvell International Ltd. All rights reserved */

 try to add rule to hash table first */

 add rule to hw */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

 Copyright (c) 2019-2020 Marvell International Ltd. All rights reserved */

 fw loader registers */

 fw registers */

 PRESTERA_CMD_REQ_CTL_REG flags */

 PRESTERA_CMD_RCV_CTL_REG flags */

 serialize access to dev->send_req */

 wait for finish previous reply from FW */

 wait for reply from FW */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

 Copyright (c) 2020 Marvell International Ltd. All rights reserved */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

 Copyright (c) 2020 Marvell International Ltd. All rights reserved */

 add eth type key,mask */

 add ip proto key,mask */

 add ethernet dst key,mask */

 add ethernet src key,mask */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

 Copyright (c) 2019-2020 Marvell International Ltd. All rights reserved */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

 Copyright (c) 2019-2020 Marvell International Ltd. All rights reserved */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

 Copyright (c) 2020 Marvell International Ltd. All rights reserved */

 port already in mirroring */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

 Copyright (c) 2019-2020 Marvell International Ltd. All rights reserved */

/* All driver-specific traps must be documented in

 * Documentation/networking/devlink/prestera.rst

 No policer is associated with following groups (policerid == 0)*/

 Initialize trap list, as well as associate CPU code with them. */

 Currently, driver does not support trap action altering */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

 Copyright (c) 2019-2020 Marvell International Ltd. All rights reserved */

	/* firmware requires that port's MAC address contains first 5 bytes

	 * of the base MAC address

	/* firmware requires that port's MAC address consist of the first

	 * 5 bytes of the base MAC address

 initialize config mac */

 initialize config phy (if this is inegral) */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

 Copyright (c) 2019-2020 Marvell International Ltd. All rights reserved */

 protect SDMA with concurrrent access from multiple CPUs */

 make sure buffer is set before reset the descriptor */

 ethertype field is part of the dsa header */

 remove DSA tag and update checksum */

 disable all rx queues */

 disable all rx queues */

 join tail with head to make a circular list */

 make sure all rx descs are filled before enabling all rx queues */

 make sure everything is written before enable xmit */

 make sure everything is cleaned up */

 join tail with head to make a circular list */

 make sure descriptors are written */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

 Copyright (c) 2019-2020 Marvell International Ltd. All rights reserved */

 make sure always 12 bytes size */

 check requests */

 check responses */

 check events */

 just rule action id, no specific data */

 put acl actions into the message */

 put acl matches into the message */

 SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0

 Copyright (c) 2020 Marvell International Ltd. All rights reserved */

 set the common parameters */

 only to CPU is supported */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 *      Davicom DM9000 Fast Ethernet driver for Linux.

 * 	Copyright (C) 1997  Sten Wang

 *

 * (C) Copyright 1997-1998 DAVICOM Semiconductor,Inc. All Rights Reserved.

 *

 * Additional updates, Copyright:

 *	Ben Dooks <ben@simtec.co.uk>

 *	Sascha Hauer <s.hauer@pengutronix.de>

 Board/System/Debug information/definition ---------------- */

 PHY address 0x01 */

/*

 * Transmit timeout, default 5 seconds.

/*

 * Debug messages level

/* DM9000 register address locking.

 *

 * The DM9000 uses an address register to control where data written

 * to the data register goes. This means that the address register

 * must be preserved over interrupts or similar calls.

 *

 * During interrupt and other critical calls, a spinlock is used to

 * protect the system, but the calls themselves save the address

 * in the address register in case they are interrupting another

 * access to the device.

 *

 * For general accesses a lock is provided so that calls which are

 * allowed to sleep are serialised so that the address register does

 * not need to be saved. This lock also serves to serialise access

 * to the EEPROM and PHY access registers which are shared between

 * these two devices.

/* The driver supports the original DM9000E, and now the two newer

 * devices, DM9000A and DM9000B.

 original DM9000 */

 Structure/enum declaration ------------------------------- */

 Register I/O base address */

 Data I/O address */

 IRQ */

 0:word, 2:byte */

 parent device */

 resources found */

 resources requested */

 phy and eeprom access lock */

 debug code */

 DM9000 network board routine ---------------------------- */

/*

 *   Read a byte from I/O port

/*

 *   Write a byte to I/O port

	/* Reset DM9000, see DM9000 Application Notes V1.22 Jun 11, 2004 page 29

	 * The essential point is that we have to do a double reset, and the

	 * instruction is to set LBK into MAC internal loopback mode.

 Application note says at least 20 us */

 routines for sending block to chip */

 input block from chip to memory */

 dump block from chip to null */

/*

 * Sleep, either by using msleep() or if we are suspending, then

 * use mdelay() to sleep.

 Read a word from phyxcer */

 Save previous register address */

 Fill the phyxcer register into REG_0C */

 Issue phyxcer read command */

 Wait read complete */

 Clear phyxcer read command */

 The read data keeps on REG_0D & REG_0E */

 restore the previous address */

 Write a word to phyxcer */

 Save previous register address */

 Fill the phyxcer register into REG_0C */

 Fill the written data into REG_0D & REG_0E */

 Issue phyxcer write command */

 Wait write complete */

 Clear phyxcer write command */

 restore the previous address */

/* dm9000_set_io

 *

 * select the specified set of io routines to use with the

 * device

	/* use the size of the data resource to work out what IO

	 * routines we want to use

 wait max 8msec */

	/* The DM9000 data sheets say we should be able to

	 * poll the ERRE bit in EPCR to wait for the EEPROM

	 * operation. From testing several chips, this bit

	 * does not seem to work.

	 *

	 * We attempt to use the bit, but fall back to the

	 * timeout (which is why we do not return an error

	 * on expiry) to say that the EEPROM operation has

	 * completed.

/*

 *  Read a word data from EEPROM

 delay for at-least 150uS */

/*

 * Write a word data to SROM

 wait at least 150uS to clear */

 ethtool ops */

 EEPROM access is aligned to two bytes */

 EEPROM access is aligned to two bytes */

 note, we could probably support wake-phy too */

 change in wol state, update IRQ state */

/* dm9000_release_board

 *

 * release a board, and any mapped resources

 unmap our resources */

 release the resources */

/*

 *  Set DM9000 multicast address

 broadcast address */

 the multicast address in Hash Table : 64 bits */

 Write the hash table to MAC MD table */

/*

 * Initialize dm9000 board

 I/O mode */

 ISR bit7:6 keeps I/O mode */

 Checksum mode */

 Let GPIO0 output */

	/* If we are dealing with DM9000B, some extra steps are required: a

	 * manual phy reset, and setting init params.

	/* if wol is needed, then always set NCR_WAKEEN otherwise we end

	 * up dumping the wake events if we disable this. There is already

 Program operating register */

 TX Polling clear */

 Less 3Kb, 200us */

 Flow Control */

 Special Mode */

 clear TX status */

 Clear interrupt status */

 Set address filter table */

 Init Driver variable */

 Our watchdog timed out. Called by the networking layer */

 Save previous register address */

 We can accept TX packets again */

 prevent tx timeout */

 Restore previous register address */

 The DM9000 is not smart enough to leave fragmented packets alone. */

 Set TX length to DM9000 */

 Issue TX polling command */

 Cleared after TX complete */

/*

 *  Hardware start transmission.

 *  Send a packet to media from the upper layer.

 Move data to DM9000 TX RAM */

 TX control: First packet immediately send, second packet queue */

 Second packet */

 free this SKB */

/*

 * DM9000 interrupt handler

 * receive the packet to upper layer, free the transmitted packet

 Got TX status */

 One packet sent complete */

 Queue packet check & send */

/*

 *  Received a packet and pass to upper layer

 Check packet ready or not */

 Dummy read */

 Get most updated data */

 Status check: this byte must be 0 or 1 */

 Stop Device */

 A packet ready now  & Get status/length */

 Packet Status check */

 rxhdr.RxStatus is identical to RSR register. */

 Move data from DM9000 */

 Read received packet from RX SRAM */

 Pass to upper layer */

 need to dump the packet's data */

 A real interrupt coming */

 holders of db->lock must always block IRQs */

 Save previous register address */

 Got DM9000 interrupt status */

 Got ISR */

 Clear ISR status */

 Received the coming packet */

 Transmit Interrupt check */

 fire a link-change request */

 Restore previous register address */

 clear, so we can avoid */

/*

 *Used by netconsole

/*

 *  Open the interface.

 *  The interface is opened whenever "ifconfig" actives it.

	/* If there is no IRQ type specified, tell the user that this is a

	 * problem

 GPIO0 on pre-activate PHY, Reg 1F is not set by reset */

 REG_1F bit0 activate phyxcer */

 delay needs by DM9000B */

 Initialize DM9000 board */

	/* Now that we have an interrupt handler hooked up we can unmask

	 * our interrupts

 Init driver variable */

 Poll initial link status */

 RESET device */

 PHY RESET */

 Power-Down PHY */

 Disable RX */

/*

 * Stop the interface.

 * The interface is stopped when it is brought.

 free interrupt */

/*

 * Search DM9000 board, allocate space and register it

 Point a board information structure */

 According to manual PWRST# Low Period Min 1ms */

 Needs 3ms to read eeprom when PWRST is deasserted */

 Init network device */

 setup board info structure */

 test to see if irq is really wakeup capable */

 fill in parameters for net-dev structure */

 ensure at least we have a default set of IO routines */

 check to see if anything is being over-ridden */

		/* check to see if the driver wants to over-ride the

		/* check to see if there are any IO routine

 try multiple times, DM9000 sometimes gets the read wrong */

 Identify what type of DM9000 we are working on */

 dm9000a/b are capable of hardware checksum offload */

 from this point we assume that we have found a DM9000 */

 try reading the node address from the attached EEPROM */

 try reading from mac */

 only shutdown if not using WoL */

			/* reset if we were not in wake mode to ensure if

 free device structure */

 sentinel */ }

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/*

 * Copyright (c) 2018 Synopsys, Inc. and/or its affiliates.

 * stmmac XGMAC support.

 Not supported */

 Finally set the OWN bit. Later the DMA will start! */

		/* When the own bit, for the first frame, has to be set, all

		 * descriptors for the same frame has to be set before, to

		 * avoid race condition.

 Finally set the OWN bit. Later the DMA will start! */

		/* When the own bit, for the first frame, has to be set, all

		 * descriptors for the same frame has to be set before, to

		 * avoid race condition.

 Inner VLAN */

 Outer VLAN */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright Altera Corporation (C) 2016. All rights reserved.

 *

 * Author: Tien Hock Loh <thloh@altera.com>

 SPDX-License-Identifier: GPL-2.0-or-later

/**

 * DOC: dwmac-rk.c - Rockchip RK3288 DWMAC specific glue layer

 *

 * Copyright (C) 2014 Chen-Zhi (Roger Chen)

 *

 * Chen-Zhi (Roger Chen)  <roger.chen@rock-chips.com>

 PX30_GRF_GMAC_CON1 */

 RK3128_GRF_MAC_CON0 */

 RK3128_GRF_MAC_CON1 */

 RK3228_GRF_MAC_CON0 */

 RK3228_GRF_MAC_CON1 */

 RK3228_GRF_COM_MUX */

 set MAC to RMII mode */

RK3288_GRF_SOC_CON1*/

RK3288_GRF_SOC_CON3*/

 RK3308_GRF_MAC_CON0 */

 RK3328_GRF_MAC_CON0 */

 RK3328_GRF_MAC_CON1 */

 RK3328_GRF_MACPHY_CON1 */

 RK3366_GRF_SOC_CON6 */

 RK3366_GRF_SOC_CON7 */

 RK3368_GRF_SOC_CON15 */

 RK3368_GRF_SOC_CON16 */

 RK3399_GRF_SOC_CON5 */

 RK3399_GRF_SOC_CON6 */

 RK3568_GRF_GMAC0_CON1 && RK3568_GRF_GMAC1_CON1 */

 RK3568_GRF_GMAC0_CON0 && RK3568_GRF_GMAC1_CON0 */

 gmac0 */

 gmac1 */

 sentinel */

 RV1108_GRF_GMAC_CON0 */

 PHY needs to be disabled before trying to reset it */

			/**

			 * if (!IS_ERR(bsp_priv->clk_mac))

			 *	clk_prepare_enable(bsp_priv->clk_mac);

			/**

			 * if (!IS_ERR(bsp_priv->clk_mac))

			 *	clk_disable_unprepare(bsp_priv->clk_mac);

	/* Some SoCs have multiple MAC controllers, which need

	 * to be distinguished.

rmii or rgmii*/

	/* If the stmmac is not already selected as gmac4,

	 * then make sure we fallback to gmac.

 Keep the PHY up if we use Wake-on-Lan. */

 The PHY was up for Wake-on-Lan. */

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2018 MediaTek Inc.

 Peri Configuration register for mt2712 */

 clock ids to be requested */

 list of clocks required for mac */

	/* The clock labeled as "rmii_internal" in mt2712_dwmac_clk_l is needed

	 * only in RMII(when MAC provides the reference clock), and useless for

	 * RGMII/MII/RMII(when PHY provides the reference clock).

	 * num_clks_to_config indicates the real number of clocks should be

	 * configured, equals to (plat->variant->num_clks - 1) in default for all the case,

	 * then +1 for rmii_clk_from_mac case.

 select phy interface in top control domain */

 550ps per stage for MII/RMII */

 170ps per stage for RGMII */

 550ps per stage for MII/RMII */

 170ps per stage for RGMII */

			/* case 1: mac provides the rmii reference clock,

			 * and the clock output to TXC pin.

			 * The egress timing can be adjusted by GTXC delay macro circuit.

			 * The ingress timing can be adjusted by TXC delay macro circuit.

			/* case 2: the rmii reference clock is from external phy,

			 * and the property "rmii_rxc" indicates which pin(TXC/RXC)

			 * the reference clk is connected to. The reference clock is a

			 * received signal, so rx_delay/rx_inv are used to indicate

			 * the reference clock timing adjustment

				/* the rmii reference clock from outside is connected

				 * to RXC pin, the reference clock will be adjusted

				 * by RXC delay macro circuit.

				/* the rmii reference clock from outside is connected

				 * to TXC pin, the reference clock will be adjusted

				 * by TXC delay macro circuit.

			/* tx_inv will inverse the tx clock inside mac relateive to

			 * reference clock from external phy,

			 * and this bit is located in the same register with fine-tune

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Oxford Semiconductor OXNAS DWMAC glue layer

 *

 * Copyright (C) 2016 Neil Armstrong <narmstrong@baylibre.com>

 * Copyright (C) 2014 Daniel Golle <daniel@makrotopia.org>

 * Copyright (C) 2013 Ma Haijun <mahaijuns@gmail.com>

 * Copyright (C) 2012 John Crispin <blogic@openwrt.org>

 System Control regmap offsets */

 Control Register */

 Delay register */

 Reset HW here before changing the glue configuration */

 Enable GMII_GTXCLK to follow GMII_REFCLK, required for gigabit PHY */

 Use simple mux for 25/125 Mhz clock switching */

 set auto switch tx clock source */

 enable tx & rx vardelay */

 set tx & rx vardelay */

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/*

 * Copyright (c) 2018 Synopsys, Inc. and/or its affiliates.

 * stmmac XGMAC support.

 Set ETS if desired */

 Read the MAC address from the hardware */

 Extract the MAC address from the high and low words */

 Handle multiple unicast addresses */

 Update counters */

 18 */

 19 */

 20 */

 26 */

 27 */

 28 */

 29 */

 30 */

 3 */

 7 */

 11 */

 15 */

 16 */

 17 */

 18 */

 19 */

 20 */

 21 */

 22 */

 23 */

 24 */

 25 */

 26 */

 27 */

 28 */

 29 */

 30 */

 31 */

 3 */

 7 */

 8 */

 9 */

 10 */

 11 */

 12 */

 13 */

 14 */

 15 */

 16 */

 17 */

 18 */

 19 */

 20 */

 21 */

 22 */

 23 */

 24 */

 25 */

 26 */

 27 */

 28 */

 29 */

 30 */

 31 */

 1. Enable Safety Features */

 2. Enable MTL Safety Interrupts */

 RX Parser Memory Correctable Error */

 EST Memory Correctable Error */

 RX Memory Correctable Error */

 TX Memory Correctable Error */

 3. Enable DMA Safety Interrupts */

 Descriptor Cache Memory Correctable Error */

 TSO Memory Correctable Error */

 Only ECC Protection for External Memory feature is selected */

 4. Enable Parity and Timeout for FSM */

 FSM Parity Feature */

 FSM Timeout Feature */

 Wait for ready */

 Write data */

 Write pos */

 Write OP */

 Start Write */

 Wait for done */

 Do not update unused entries */

 Do not update already updated entries (i.e. fragments) */

 Let last entry be updated last */

 Do not return fragments */

 Check if we already checked this prio */

 Check if this is the minimum prio */

 Force disable RX */

 Disable RX Parser */

 Set all entries as NOT in HW */

 Update entries by reverse order */

 Set special fragment requirements */

 Update all pass entry */

 Assume n. of parsable entries == n. of valid entries */

 Enable RX Parser */

 Re-enable RX */

 Finally, activate it */

 Only use SVLAN */

 For IPv6 not both SA/DA filters can be active */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2007-2015  STMicroelectronics Ltd

 *

 * Author: Alexandre Torgue <alexandre.torgue@st.com>

 DMA SW reset */

 ABNORMAL interrupts */

 TX/RX NORMAL interrupts */

	/* For MAC Addr registers se have to set the Address Enable (AE)

	 * bit that has no effect on the High Reg 0 where the bit 31 (MO)

	 * is RO.

 Enable disable MAC RX/TX */

 Read the MAC address from the hardware */

 Extract the MAC address from the high and low words */

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

 Copyright (c) 2017 Synopsys, Inc. and/or its affiliates.

 stmmac Support for 5.xx Ethernet QoS cores

 Update counters */

 20 */

 21 */

 22 */

 23 */

 25 */

 26 */

 27 */

 28 */

 29 */

 30 */

 31 */

 3 */

 7 */

 11 */

 15 */

 16 */

 17 */

 18 */

 19 */

 20 */

 21 */

 22 */

 23 */

 24 */

 25 */

 26 */

 27 */

 28 */

 29 */

 30 */

 31 */

 3 */

 4 */

 5 */

 6 */

 7 */

 8 */

 9 */

 10 */

 11 */

 12 */

 13 */

 14 */

 15 */

 16 */

 17 */

 18 */

 19 */

 20 */

 21 */

 22 */

 23 */

 24 */

 25 */

 26 */

 27 */

 28 */

 29 */

 30 */

 31 */

 1. Enable Safety Features */

 MTL ECC Error Addr Status Override */

 TSO ECC */

 MTL RX Parser ECC */

 MTL EST ECC */

 MTL RX FIFO ECC */

 MTL TX FIFO ECC */

 2. Enable MTL Safety Interrupts */

 RX Parser Memory Correctable Error */

 EST Memory Correctable Error */

 RX Memory Correctable Error */

 TX Memory Correctable Error */

 3. Enable DMA Safety Interrupts */

 TSO Memory Correctable Error */

 Only ECC Protection for External Memory feature is selected */

 5. Enable Parity and Timeout for FSM */

 FSM Parity Feature */

 FSM Timeout Feature */

 4. Enable Data Parity Protection */

	/*

	 * All the Automotive Safety features are selected without the "Parity

	 * Port Enable for external interface" feature.

 Wait for ready */

 Write data */

 Write pos */

 Write OP */

 Start Write */

 Wait for done */

 Do not update unused entries */

 Do not update already updated entries (i.e. fragments) */

 Let last entry be updated last */

 Do not return fragments */

 Check if we already checked this prio */

 Check if this is the minimum prio */

 Force disable RX */

 Disable RX Parser */

 Set all entries as NOT in HW */

 Update entries by reverse order */

 Set special fragment requirements */

 Update all pass entry */

 Assume n. of parsable entries == n. of valid entries */

 Enable RX Parser */

 Re-enable RX */

 Finally, activate it */

 Configure EST interrupt */

 Return if there is no error */

 Clear Interrupt */

 Clear Interrupt */

		/* Collecting info to shows all the queues that has HLBS

		 * issue. The only way to clear this is to clear the

		 * statistic

 Clear Interrupt */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Amlogic Meson8b, Meson8m2 and GXBB DWMAC glue layer

 *

 * Copyright (C) 2016 Martin Blumenstingl <martin.blumenstingl@googlemail.com>

 mux to choose between fclk_div2 (bit unset) and mpll2 (bit set) */

/* TX clock delay in ns = "8ns / 4 * tx_dly_val" (where 8ns are exactly one

 * cycle of the 125MHz RGMII TX clock):

 * 0ns = 0x0, 2ns = 0x1, 4ns = 0x2, 6ns = 0x3

 divider for the result of m250_sel */

/* Bypass (= 0, the signal from the GPIO input directly connects to the

 * internal sampling) or enable (= 1) the internal logic for RXEN and RXD[3:0]

 * timing tuning.

/* Controls whether the RXEN and RXD[3:0] signals should be aligned with the

 * input RX rising/falling edge and sent to the Ethernet internals. This sets

 * the automatically delay and skew automatically (internally).

/* An internal counter based on the "timing-adjustment" clock. The counter is

 * cleared on both, the falling and rising edge of the RX_CLK. This selects the

 * delay (= the counter value) when to start sampling RXEN and RXD[3:0].

/* Adjusts the skew between each bit of RXEN and RXD[3:0]. If a signal has a

 * large input delay, the bit for that signal (RXEN = bit 0, RXD[3] = bit 1,

 * ...) can be configured to be 1 to compensate for a delay of about 1ns.

/* Defined for adding a delay to the input RX_CLK for better timing.

 * Each step is 200ps. These bits are used with external RGMII PHYs

 * because RGMII RX only has the small window. cfg_rxclk_dly can

 * adjust the window between RX_CLK and RX_DATA and improve the stability

 * of "rx data valid".

 end of array */ }

 enable RGMII mode */

 disable RGMII mode -> enables RMII mode */

 enable RGMII mode */

 disable RGMII mode -> enables RMII mode */

 The timing adjustment logic is driven by a separate clock */

 only relevant for RMII mode -> disable in RGMII mode */

		/* Configure the 125MHz RGMII TX clock, the IP block changes

		 * the output automatically (= without us having to configure

		 * a register) based on the line-speed (125MHz for Gbit speeds,

		 * 25MHz for 100Mbit/s and 2.5MHz for 10Mbit/s).

 invert internal clk_rmii_i to generate 25/2.5 tx_rx_clk */

 enable TX_CLK and PHY_REF_CLK generator */

 use 2ns as fallback since this value was previously hardcoded */

 RX delay defaults to 0ps since this is what many boards use */

 convert ns to ps */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright Altera Corporation (C) 2014. All rights reserved.

 *

 * Adopted from dwmac-sti.c

	/* Overwrite val to GMII if splitter core is enabled. The phymode here

	 * is the actual phy mode on phy hardware, but phy interface from

	 * EMAC core is GMII.

 Assert reset to the enet controller before changing the phy mode */

	/* Deassert reset for the phy configuration to be sampled by

	 * the enet controller, and operation to start in requested mode

	/* Overwrite val to GMII if splitter core is enabled. The phymode here

	 * is the actual phy mode on phy hardware, but phy interface from

	 * EMAC core is GMII.

 Assert reset to the enet controller before changing the phy mode */

	/* Deassert reset for the phy configuration to be sampled by

	 * the enet controller, and operation to start in requested mode

	/* The socfpga driver needs to control the stmmac reset to set the phy

	 * mode. Create a copy of the core reset handle so it can be used by

	 * the driver later.

	/* Before the enet controller is suspended, the phy is suspended.

	 * This causes the phy clock to be gated. The enet controller is

	 * resumed before the phy, so the clock is still gated "off" when

	 * the enet controller is resumed. This code makes sure the phy

	 * is "resumed" before reinitializing the enet controller since

	 * the enet controller depends on an active phy clock to complete

	 * a DMA reset. A DMA reset will "time out" if executed

	 * with no phy clock input on the Synopsys enet controller.

	 * Verified through Synopsys Case #8000711656.

	 *

	 * Note that the phy clock is also gated when the phy is isolated.

	 * Phy "suspend" and "isolate" controls are located in phy basic

	 * control register 0, and can be modified by the phy driver

	 * framework.

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  PTP 1588 clock using the STMMAC.



  Copyright (C) 2013  Vayavya Labs Pvt Ltd





  Author: Rayagond Kokatanur <rayagond@vayavyalabs.com>

/**

 * stmmac_adjust_freq

 *

 * @ptp: pointer to ptp_clock_info structure

 * @ppb: desired period change in parts ber billion

 *

 * Description: this function will adjust the frequency of hardware clock.

/**

 * stmmac_adjust_time

 *

 * @ptp: pointer to ptp_clock_info structure

 * @delta: desired change in nanoseconds

 *

 * Description: this function will shift/adjust the hardware clock time.

 If EST is enabled, disabled it before adjust ptp time. */

 Caculate new basetime and re-configured EST after PTP time adjust. */

/**

 * stmmac_get_time

 *

 * @ptp: pointer to ptp_clock_info structure

 * @ts: pointer to hold time/result

 *

 * Description: this function will read the current time from the

 * hardware clock and store it in @ts.

/**

 * stmmac_set_time

 *

 * @ptp: pointer to ptp_clock_info structure

 * @ts: time value to set

 *

 * Description: this function will set the current time on the

 * hardware clock.

 Reject requests with unsupported flags */

 Enable External snapshot trigger */

 Enable Timestamp Interrupt */

 Disable Timestamp Interrupt */

/**

 * stmmac_get_syncdevicetime

 * @device: current device time

 * @system: system counter value read synchronously with device time

 * @ctx: context provided by timekeeping code

 * Description: Read device and system clock simultaneously and return the

 * corrected clock values in ns.

 structure describing a PTP hardware clock */

 will be overwritten in stmmac_ptp_register */

 will be overwritten in stmmac_ptp_register */

/**

 * stmmac_ptp_register

 * @priv: driver private structure

 * Description: this function will register the ptp clock driver

 * to kernel. It also does some house keeping work.

/**

 * stmmac_ptp_unregister

 * @priv: driver private structure

 * Description: this function will remove/unregister the ptp clock driver

 * from the kernel.

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/*

 * Copyright (c) 2018 Synopsys, Inc. and/or its affiliates.

 * stmmac XGMAC support.

 DMA SW reset */

		/* Set Threshold for Activating Flow Control to min 2 frames,

		 * i.e. 1500 * 2 = 3000 bytes.

		 *

		 * Set Threshold for Deactivating Flow Control to min 1 frame,

		 * i.e. 1500 bytes.

			/* This violates the above formula because of FIFO size

			 * limit therefore overflow may occur in spite of this.

 Full-2.5K */

 Full-1.5K */

 Full-4.5K */

 Full-3K */

 Enable MTL RX overflow */

 Use static TC to Queue mapping */

 ABNORMAL interrupts */

 TX/RX NORMAL interrupts */

 Clear interrupts */

  MAC HW feature 0 */

 MAC HW feature 1 */

 MAC HW feature 2 */

 MAC HW feature 3 */

 Segment max 256 bytes */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * This is the driver for the GMAC on-chip Ethernet controller for ST SoCs.

 * DWC Ether MAC version 4.00  has been used for developing this code.

 *

 * This only implements the mac core functions for this chip.

 *

 * Copyright (C) 2015  STMicroelectronics Ltd

 *

 * Author: Alexandre Torgue <alexandre.torgue@st.com>

 Enable GMAC interrupts */

 Enable FPE interrupt */

 routing configuration */

 some packets require extra ops */

 enable AV algorithm */

 configure send slope */

 configure idle slope (same register as tx weight) */

 configure high credit */

 configure high credit */

 The receiver must be enabled for WOL before powering down */

	/* Enable the link status receive on RGMII, SGMII ore SMII

	 * receive path and instruct the transmit to enter in LPI

	 * state.

 Program LPI entry timer value into register */

 Enable/disable LPI entry timer */

	/* Program the timers in the LPI timer control register:

	 * LS: minimum time (ms) for which the link

	 *  status from PHY should be ok before transmitting

	 *  the LPI pattern.

	 * TW: minimum time (us) for which the core waits

	 *  after it has stopped transmitting the LPI pattern.

 Single Rx VLAN Filter */

 For single VLAN filter, VID 0 means VLAN promiscuous */

 Extended Rx VLAN Filter Enable */

 Single Rx VLAN Filter */

 Extended Rx VLAN Filter Enable */

 Single Rx VLAN Filter */

 Extended Rx VLAN Filter Enable */

 Single Rx VLAN Filter */

 Extended Rx VLAN Filter Enable */

 VLAN Tag Filter Fail Packets Queuing */

 Pass all multi */

 Set all the bits of the HASH tab */

 Hash filter for multicast */

			/* The upper n bits of the calculated CRC are used to

			 * index the contents of the hash table. The number of

			 * bits used depends on the hardware configuration

			 * selected at core configuration time.

			/* The most significant bit determines the register to

			 * use (H/L) while the other 5 bits determine the bit

			 * within the register.

 Handle multiple unicast addresses */

		/* Switch to promiscuous mode if more than 128 addrs

		 * are required

 VLAN filtering */

 RGMII or SMII interface */

 Check the link status */

 Check MTL Interrupt */

 read Queue x Interrupt status */

  clear Interrupt */

 Discard disabled bits */

 Not used events (e.g. MMC interrupts) are not handled. */

 Clear the PMT bits 5 and 6 by reading the PMT status reg */

 MAC tx/rx EEE LPI entry/exit interrupts */

 Clear LPI interrupt by reading MAC_LPI_Control_Status */

 GMAC debug */

 Only use SVLAN */

 For IPv6 not both SA/DA filters can be active */

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  STMMAC Ethernet Driver -- MDIO bus implementation

  Provides Bus interface for MII registers



  Copyright (C) 2007-2009  STMicroelectronics Ltd





  Author: Carl Shaw <carl.shaw@st.com>

  Maintainer: Giuseppe Cavallaro <peppe.cavallaro@st.com>

 GMAC4 defines */

 XGMAC defines */

 Set port as Clause 45 */

 HW does not support C22 addr >= 4 */

 Set port as Clause 22 */

 Wait until any existing MII operation is complete */

 Wait until any existing MII operation is complete */

 Set the MII address register to read */

 Wait until any existing MII operation is complete */

 Read the data from the MII data register */

 Wait until any existing MII operation is complete */

 Wait until any existing MII operation is complete */

 Set the MII address register to write */

 Wait until any existing MII operation is complete */

/**

 * stmmac_mdio_read

 * @bus: points to the mii_bus structure

 * @phyaddr: MII addr

 * @phyreg: MII reg

 * Description: it reads data from the MII register from within the phy device.

 * For the 7111 GMAC, we must set the bit 0 in the MII address register while

 * accessing the PHY registers.

 * Fortunately, it seems this has no drawback for the 7109 MAC.

 Read the data from the MII data register */

/**

 * stmmac_mdio_write

 * @bus: points to the mii_bus structure

 * @phyaddr: MII addr

 * @phyreg: MII reg

 * @phydata: phy data

 * Description: it writes the data into the MII register from within the device.

 Wait until any existing MII operation is complete */

 Set the MII address register to write */

 Wait until any existing MII operation is complete */

/**

 * stmmac_mdio_reset

 * @bus: points to the mii_bus structure

 * Description: reset the MII bus

	/* This is a workaround for problems with the STE101P PHY.

	 * It doesn't complete its reset until at least one clock cycle

	 * on MDC, so perform a dummy mdio read. To be updated for GMAC4

	 * if needed.

 Try to probe the XPCS by scanning all addresses. */

/**

 * stmmac_mdio_register

 * @ndev: net device structure

 * Description: it registers the MII bus

 Right now only C22 phys are supported */

 Check if DT specified an unsupported phy addr */

 Looks like we need a dummy read for XGMAC only and C45 PHYs */

		/*

		 * If an IRQ was provided to be assigned after

		 * the bus probe, do it here.

		/*

		 * If we're going to bind the MAC to this PHY bus,

		 * and no PHY number was provided to the MAC,

		 * use the one probed here.

/**

 * stmmac_mdio_unregister

 * @ndev: net device structure

 * Description: it unregisters the MII bus

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2021, Intel Corporation. */

	/* XDP ZC does not span multiple frame, make sure XSK pool buffer

	 * size can at least store Q-in-Q frame.

		/* For now, the driver doesn't support XDP functionality with

		 * jumbo frames so we return error.

 Disable RX SPH for XDP operation */

 SPDX-License-Identifier: GPL-2.0

/*

 * dwmac-imx.c - DWMAC Specific Glue layer for NXP imx8

 *

 * Copyright 2020 NXP

 *

 TBD: depends on imx8dxl scu interfaces to be upstreamed */

 nothing to do now */

		/* Binding doc describes the propety:

		   is required by i.MX8MP.

		   is optinoal for i.MX8DXL.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * dwmac-sun8i.c - Allwinner sun8i DWMAC specific glue layer

 *

 * Copyright (C) 2017 Corentin Labbe <clabbe.montjoie@gmail.com>

/* General notes on dwmac-sun8i:

 * Locking: no locking is necessary in this file because all necessary locking

 *		is done in the "stmmac files"

/* struct emac_variant - Describe dwmac-sun8i hardware variant

 * @default_syscon_value:	The default value of the EMAC register in syscon

 *				This value is used for disabling properly EMAC

 *				and used as a good starting value in case of the

 *				boot process(uboot) leave some stuff.

 * @syscon_field		reg_field for the syscon's gmac register

 * @soc_has_internal_phy:	Does the MAC embed an internal PHY

 * @support_mii:		Does the MAC handle MII

 * @support_rmii:		Does the MAC handle RMII

 * @support_rgmii:		Does the MAC handle RGMII

 *

 * @rx_delay_max:		Maximum raw value for RX delay chain

 * @tx_delay_max:		Maximum raw value for TX delay chain

 *				These two also indicate the bitmask for

 *				the RX and TX delay chain registers. A

 *				value of zero indicates this is not supported.

/* struct sunxi_priv_data - hold all sunxi private data

 * @tx_clk:	reference to MAC TX clock

 * @ephy_clk:	reference to the optional EPHY clock for the internal PHY

 * @regulator:	reference to the optional regulator

 * @rst_ephy:	reference to the optional EPHY reset for the internal PHY

 * @variant:	reference to the current board variant

 * @regmap:	regmap for using the syscon

 * @internal_phy_powered: Does the internal PHY is enabled

 * @use_internal_phy: Is the internal PHY selected for use

 * @mux_handle:	Internal pointer used by mdio-mux lib

 EMAC clock register @ 0x30 in the "system control" address range */

 EMAC clock register @ 0x164 in the CCU address range */

	/* The "Internal PHY" of H6 is not on the die. It's on the

	 * co-packaged AC200 chip instead.

 Use in EMAC_BASIC_CTL0 */

 Use in EMAC_BASIC_CTL1 */

 Used in EMAC_RX_FRM_FLT */

 Used in RX_CTL1*/

 Used in TX_CTL1*/

 Used in RX_CTL0 */

 Used in TX_CTL0 */

 Used in EMAC_TX_FLOW_CTL */

 Used in EMAC_INT_STA */

 H3 specific bits for EPHY */

 1: 24MHz, 0: 25MHz */

 1: active low, 0: active high */

 1: shutdown, 0: power up */

 1: internal PHY, 0: external PHY */

 H3/A64 specific bits */

 1: enable RMII (overrides EPIT) */

 Generic system control EMAC_CLK bits */

 EMAC PHY Interface Type */

 1: RGMII, 0: MII */

/* sun8i_dwmac_dma_reset() - reset the EMAC

 * Called from stmmac via stmmac_dma_ops->reset

/* sun8i_dwmac_dma_init() - initialize the EMAC

 * Called from stmmac via stmmac_dma_ops->init

 Write RX descriptors address */

 Write TX descriptors address */

/* sun8i_dwmac_dump_regs() - Dump EMAC address space

 * Called from stmmac_dma_ops->dump_regs

 * Used for ethtool

/* sun8i_dwmac_dump_mac_regs() - Dump EMAC address space

 * Called from stmmac_ops->dump_regs

 * Used for ethtool

		/* Undocumented bit (called TX_NEXT_FRM in BSP), the original

		 * comment is

		 * "Operating on second frame increase the performance

		 * especially when transmit store-and-forward is used."

 burst len */

/* Set MAC address at slot reg_n

 * All slot > 0 need to be enabled with MAC_ADDR_TYPE_DST

 * If addr is NULL, clear the slot

 caution this function must return non 0 to work */

 Disable unused address filter slots */

	/* The timeout was previoulsy set to 10ms, but some board (OrangePI0)

	 * need more if no cable plugged. 100ms seems OK

 Search in mdio-mux node for internal PHY node and get its clk/reset */

 Seek for internal PHY */

	/* Make sure the EPHY is properly reseted, as U-Boot may leave

	 * it at deasserted state, and thus it may fail to reset EMAC.

	 *

	 * This assumes the driver has exclusive access to the EPHY reset.

/* MDIO multiplexing switch function

 * This function is called by the mdio-mux layer when it thinks the mdio bus

 * multiplexer needs to switch.

 * 'current_child' is the current value of the mux register

 * 'desired_child' is the value of the 'reg' property of the target child MDIO

 * node.

 * The first time this function is called, current_child == -1.

 * If current_child == desired_child, then the mux is already set to the

 * correct bus.

		/* After changing syscon value, the MAC need reset or it will

		 * use the last value (and so the last PHY set).

 Force EPHY xtal frequency to 24MHz. */

		/* of_mdio_parse_addr returns a valid (0 ~ 31) PHY

		 * address. No need to mask it again.

		/* For SoCs without internal PHY the PHY selection bit should be

		 * set to 0 (external PHY).

 Clear interface mode bits */

 default */

	/* The loopback bit seems to be re-set when link change

	 * Simply mask it each time

	 * Speed 10/100/1000 are set in BIT(2)/BIT(3)

 Synopsys Id is not available */

 platform device might not be probed yet */

 If no regmap is found then the other device driver is at fault */

 Optional regulator for PHY */

	/* The "GMAC clock control" register might be located in the

	 * CCU address range (on the R40), or the system control address

	 * range (on most other sun8i and later SoCs).

	 *

	 * The former controls most if not all clocks in the SoC. The

	 * latter has an SoC identification register, and on some SoCs,

	 * controls to map device specific SRAM to either the intended

	 * peripheral, or the CPU address space.

	 *

	 * In either case, there should be a coordinated and restricted

	 * method of accessing the register needed here. This is done by

	 * having the device export a custom regmap, instead of a generic

	 * syscon, which grants all access to all registers.

	 *

	 * To support old device trees, we fall back to using the syscon

	 * interface if possible.

	/* platform data specifying hardware features and callbacks.

	 * hardware features were copied from Allwinner drivers.

	/* The mux must be registered after parent MDIO

	 * so after stmmac_dvr_probe()

 SPDX-License-Identifier: GPL-2.0

 Copyright (c) 2018-19, Linaro Limited

 RGMII_IO_MACRO_CONFIG fields */

 SDCC_HC_REG_DLL_CONFIG fields */

 SDCC_HC_REG_DDR_CONFIG fields */

 SDCC_HC_REG_DLL_CONFIG2 fields */

 SDC4_STATUS bits */

 RGMII_IO_MACRO_CONFIG2 fields */

 Clock rates */

 Set CDR_EN */

 Set CDR_EXT_EN */

 Clear CK_OUT_EN */

 Set DLL_EN */

 Wait for CK_OUT_EN clear */

 Set CK_OUT_EN */

 Wait for CK_OUT_EN set */

 Set DDR_CAL_EN */

 Disable loopback mode */

 Select RGMII, write 0 to interface select */

 Set PRG_RCLK_DLY to 57 for 1.8 ns delay */

 Write 0x5 to PRG_RCLK_DLY_CODE */

 Write 0x5 to PRG_RCLK_DLY_CODE */

 Reset to POR values and enable clk */

 Initialize the DLL first */

 Set DLL_RST */

 Set PDN */

 Clear DLL_RST */

 Clear PDN */

 Set DLL_EN */

 Set CK_OUT_EN */

 Set USR_CTL bit 26 with mask of 3 bits */

 wait for DLL LOCK */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Amlogic Meson6 and Meson8 DWMAC glue layer

 *

 * Copyright (C) 2014 Beniamino Galvani <b.galvani@gmail.com>

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  This contains the functions to handle the pci driver.



  Copyright (C) 2011-2012  Vayavya Labs Pvt Ltd





  Author: Rayagond Kokatanur <rayagond@vayavyalabs.com>

  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>

 clk_csr_i = 20-35MHz & MDC = clk_csr_i/16 */

 Set default value for multicast hash bins */

 Set default value for unicast filter entries */

 Set the maxmtu to a default of JUMBO_LEN */

 Set default number of RX and TX queues to use */

 Disable Priority config by default */

 Disable RX queues routing by default */

 Set common default data first */

 TODO: AXI */

 Set default value for multicast hash bins */

 Set default value for unicast filter entries */

 Set the maxmtu to a default of JUMBO_LEN */

 Set default number of RX and TX queues to use */

 Axi Configuration */

/**

 * stmmac_pci_probe

 *

 * @pdev: pci device pointer

 * @id: pointer to table of device id/id's.

 *

 * Description: This probing function gets called for all PCI devices which

 * match the ID table and are not "owned" by other driver yet. This function

 * gets passed a "struct pci_dev *" for each device whose entry in the ID table

 * matches the device. The probe functions returns zero when the driver choose

 * to take "ownership" of the device or an error code(-ve no) otherwise.

 Enable pci device */

 Get the base address of device */

/**

 * stmmac_pci_remove

 *

 * @pdev: platform device pointer

 * Description: this function calls the main to free the net resources

 * and releases the PCI resources.

 synthetic ID, no official vendor */

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  Copyright (C) 2007-2009  STMicroelectronics Ltd





  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>

 DMA SW reset */

 CSR1 enables the transmit DMA to check for new descriptor */

 read the status register (CSR5) */

 Enable it to monitor DMA rx/tx status in case of critical problems */

 ABNORMAL interrupts */

 TX/RX NORMAL interrupts */

 to schedule NAPI on real RIE event. */

 Optional hardware blocks, interrupts should be disabled */

 Clear the interrupt by writing a logic 1 to the CSR5[15-0] */

	/* For MAC Addr registers we have to set the Address Enable (AE)

	 * bit that has no effect on the High Reg 0 where the bit 31 (MO)

	 * is RO.

 Enable disable MAC RX/TX */

 Read the MAC address from the hardware */

 Extract the MAC address from the high and low words */

 SPDX-License-Identifier: GPL-2.0

/*

 * dwmac-ingenic.c - Ingenic SoCs DWMAC specific glue layer

 *

 * Copyright (c) 2021 周琰杰 (Zhou Yanjie) <zhouyanjie@wanyeetech.com>

 Update MAC PHY control register */

 Update MAC PHY control register */

 Update MAC PHY control register */

 Update MAC PHY control register */

 Update MAC PHY control register */

 Get MAC PHY control register */

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * This is the driver for the GMAC on-chip Ethernet controller for ST SoCs.

 * DWC Ether MAC version 4.xx  has been used for  developing this code.

 *

 * This contains the functions to handle the dma.

 *

 * Copyright (C) 2015  STMicroelectronics Ltd

 *

 * Author: Alexandre Torgue <alexandre.torgue@st.com>

	/* Depending on the UNDEF bit the Master AXI will perform any burst

	 * length according to the BLEN programmed (by default all BLEN are

	 * set).

 Enable OSP to get best performance */

 common channel control register config */

 Mask interrupts by writing to CSR7 */

 common channel control register config */

 Mask interrupts by writing to CSR7 */

 Set the Fixed burst mode */

 Mixed Burst has no effect when fb is set */

	/* Enable flow control only if each channel gets 4 KiB or more FIFO and

	 * only if channel is not an AVB channel.

		/* Set Threshold for Activating Flow Control to min 2 frames,

		 * i.e. 1500 * 2 = 3000 bytes.

		 *

		 * Set Threshold for Deactivating Flow Control to min 1 frame,

		 * i.e. 1500 bytes.

			/* This violates the above formula because of FIFO size

			 * limit therefore overflow may occur in spite of this.

 Full-2.5K */

 Full-1.5K */

 Full-4.5K */

 Full-3K */

 Transmit COE type 2 cannot be done in cut-through mode. */

 Set the transmit threshold */

	/* For an IP with DWC_EQOS_NUM_TXQ == 1, the fields TXQEN and TQS are RO

	 * with reset values: TXQEN on, TQS == DWC_EQOS_TXFIFO_SIZE.

	 * For an IP with DWC_EQOS_NUM_TXQ > 1, the fields TXQEN and TQS are R/W

	 * with reset values: TXQEN off, TQS 256 bytes.

	 *

	 * TXQEN must be written for multi-channel operation and TQS must

	 * reflect the available fifo size per queue (total fifo size / number

	 * of enabled queues).

  MAC HW feature0 */

 MMC */

 IEEE 1588-2008 */

 802.3az - Energy-Efficient Ethernet (EEE) */

 TX and RX csum */

 MAC HW feature1 */

	/* RX and TX FIFO sizes are encoded as log2(n / 128). Undo that by

	 * shifting and store the sizes in bytes.

 MAC HW feature2 */

 TX and RX number of channels */

 TX and RX number of queues */

 PPS output */

 IEEE 1588-2002 */

 Number of Auxiliary Snapshot Inputs */

 MAC HW feature3 */

 5.10 Features */

 Enable/disable TSO feature and set MSS */

 enable TSO */

 enable TSO */

 Segment max 256 bytes */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * dwmac-sti.c - STMicroelectronics DWMAC Specific Glue layer

 *

 * Copyright (C) 2003-2014 STMicroelectronics (R&D) Limited

 * Author: Srinivas Kandagatla <srinivas.kandagatla@st.com>

 * Contributors: Giuseppe Cavallaro <peppe.cavallaro@st.com>

/* STiH4xx register definitions (STiH415/STiH416/STiH407/STiH410 families)

 *

 * Below table summarizes the clock requirement and clock sources for

 * supported phy interface modes with link speeds.

 * ________________________________________________

 *|  PHY_MODE	| 1000 Mbit Link | 100 Mbit Link   |

 * ------------------------------------------------

 *|	MII	|	n/a	 |	25Mhz	   |

 *|		|		 |	txclk	   |

 * ------------------------------------------------

 *|	GMII	|     125Mhz	 |	25Mhz	   |

 *|		|  clk-125/txclk |	txclk	   |

 * ------------------------------------------------

 *|	RGMII	|     125Mhz	 |	25Mhz	   |

 *|		|  clk-125/txclk |	clkgen     |

 *|		|    clkgen	 |		   |

 * ------------------------------------------------

 *|	RMII	|	n/a	 |	25Mhz	   |

 *|		|		 |clkgen/phyclk-in |

 * ------------------------------------------------

 *

 *	  Register Configuration

 *-------------------------------

 * src	 |BIT(8)| BIT(7)| BIT(6)|

 *-------------------------------

 * txclk |   0	|  n/a	|   1	|

 *-------------------------------

 * ck_125|   0	|  n/a	|   0	|

 *-------------------------------

 * phyclk|   1	|   0	|  n/a	|

 *-------------------------------

 * clkgen|   1	|   1	|  n/a	|

 *-------------------------------

/* STiD127 register definitions

 *-----------------------

 * src	 |BIT(6)| BIT(7)|

 *-----------------------

 * MII   |  1	|   n/a	|

 *-----------------------

 * RMII  |  n/a	|   1	|

 * clkgen|	|	|

 *-----------------------

 * RMII  |  n/a	|   0	|

 * phyclk|	|	|

 *-----------------------

 * RGMII |  1	|  n/a	|

 * clkgen|	|	|

 *-----------------------

/*

 * 3 bits [4:2]

 *	000-GMII/MII

 *	001-RGMII

 *	010-SGMII

 *	100-RMII

 MII interface */

 Clock from external PHY */

 TXCLK Retiming*/

 PHY clock */

 GMAC glue-logic control register */

 GMAC ext clk selection register */

 On GiGa clk source can be either ext or from clkgen */

 Switch to clkgen for these speeds */

 clk selection from extra syscfg register */

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  This is the driver for the GMAC on-chip Ethernet controller for ST SoCs.

  DWC Ether MAC 10/100/1000 Universal version 3.41a  has been used for

  developing this code.



  This contains the functions to handle the dma.



  Copyright (C) 2007-2009  STMicroelectronics Ltd





  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>

	/* Depending on the UNDEF bit the Master AXI will perform any burst

	 * length according to the BLEN programmed (by default all BLEN are

	 * set).

	/*

	 * Set the DMA PBL (Programmable Burst Length) mode.

	 *

	 * Note: before stmmac core 3.50 this mode bit was 4xPBL, and

	 * post 3.5 mode bit acts as 8*PBL.

 Set the Fixed burst mode */

 Mixed Burst has no effect when fb is set */

 Mask interrupts by writing to CSR7 */

 RX descriptor base address list must be written into DMA CSR3 */

 TX descriptor base address list must be written into DMA CSR4 */

	/* Leave flow control disabled if receive fifo size is less than

	 * 4K or 0. Otherwise, send XOFF when fifo is 1K less than full,

	 * and send XON when 2K less than full.

 Configure flow control based on rx fifo size */

 Transmit COE type 2 cannot be done in cut-through mode. */

		/* Operating on second frame increase the performance

		 * especially when transmit store-and-forward is used.

 Set the transmit threshold */

		/* 0x00000000 is the value read on old hardware that does not

		 * implement this register

 MMC */

 IEEE 1588-2002 */

 IEEE 1588-2008 */

 802.3az - Energy-Efficient Ethernet (EEE) */

 TX and RX csum */

 TX and RX number of channels */

 Alternate (enhanced) DESC mode */

 SPDX-License-Identifier: GPL-2.0

/* Toshiba Visconti Ethernet Support

 *

 * (C) Copyright 2020 TOSHIBA CORPORATION

 * (C) Copyright 2020 Toshiba Electronic Devices & Storage Corporation

 lock to protect register update */

 adjust link */

 No bit control */

 Stop internal clock */

 Start clock */

 Enable TX/RX clock */

 release internal-reset */

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  This contains the functions to handle the platform driver.



  Copyright (C) 2007-2011  STMicroelectronics Ltd





  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>

/**

 * dwmac1000_validate_mcast_bins - validates the number of Multicast filter bins

 * @dev: struct device of the platform device

 * @mcast_bins: Multicast filtering bins

 * Description:

 * this function validates the number of Multicast filtering bins specified

 * by the configuration through the device tree. The Synopsys GMAC supports

 * 64 bins, 128 bins, or 256 bins. "bins" refer to the division of CRC

 * number space. 64 bins correspond to 6 bits of the CRC, 128 corresponds

 * to 7 bits, and 256 refers to 8 bits of the CRC. Any other setting is

 * invalid and will cause the filtering algorithm to use Multicast

 * promiscuous mode.

/**

 * dwmac1000_validate_ucast_entries - validate the Unicast address entries

 * @dev: struct device of the platform device

 * @ucast_entries: number of Unicast address entries

 * Description:

 * This function validates the number of Unicast address entries supported

 * by a particular Synopsys 10/100/1000 controller. The Synopsys controller

 * supports 1..32, 64, or 128 Unicast filter entries for it's Unicast filter

 * logic. This function validates a valid, supported configuration is

 * selected, and defaults to 1 Unicast address if an unsupported

 * configuration is selected.

/**

 * stmmac_axi_setup - parse DT parameters for programming the AXI register

 * @pdev: platform device

 * Description:

 * if required, from device-tree the AXI internal register can be tuned

 * by using platform parameters.

/**

 * stmmac_mtl_setup - parse DT parameters for multiple queues configuration

 * @pdev: platform device

 * @plat: enet data

	/* For backwards-compatibility with device trees that don't have any

	 * snps,mtl-rx-config or snps,mtl-tx-config properties, we fall back

	 * to one RX and TX queues each.

	/* First Queue must always be in DCB mode. As MTL_QUEUE_DCB = 1 we need

	 * to always set this, otherwise Queue will be classified as AVB

	 * (because MTL_QUEUE_AVB = 0).

 Processing RX queues common config */

 Processing individual RX queue config */

 TODO: Dynamic mapping to be included in the future */

 RX queue specific packet type routing */

 Processing TX queues common config */

 Processing individual TX queue config */

 Credit Base Shaper parameters used by AVB */

/**

 * stmmac_dt_phy - parse device-tree driver parameters to allocate PHY resources

 * @plat: driver data platform structure

 * @np: device tree node

 * @dev: device pointer

 * Description:

 * The mdio bus will be allocated in case of a phy transceiver is on board;

 * it will be NULL if the fixed-link is configured.

 * If there is the "snps,dwmac-mdio" sub-node the mdio will be allocated

 * in any case (for DSA, mdio must be registered even if fixed-link).

 * The table below sums the supported configurations:

 *	-------------------------------

 *	snps,phy-addr	|     Y

 *	-------------------------------

 *	phy-handle	|     Y

 *	-------------------------------

 *	fixed-link	|     N

 *	-------------------------------

 *	snps,dwmac-mdio	|

 *	  even if	|     Y

 *	fixed-link	|

 *	-------------------------------

 *

 * It returns 0 in case of success otherwise -ENODEV.

		/**

		 * If snps,dwmac-mdio is passed from DT, always register

		 * the MDIO

/**

 * stmmac_of_get_mac_mode - retrieves the interface of the MAC

 * @np: - device-tree node

 * Description:

 * Similar to `of_get_phy_mode()`, this function will retrieve (from

 * the device-tree) the interface mode on the MAC side. This assumes

 * that there is mode converter in-between the MAC & PHY

 * (e.g. GMII-to-RGMII).

/**

 * stmmac_probe_config_dt - parse device-tree driver parameters

 * @pdev: platform_device structure

 * @mac: MAC address to use

 * Description:

 * this function is to read the driver parameters from device-tree and

 * set some private fields that will be used by the main at runtime.

	/* Some wrapper drivers still rely on phy_node. Let's save it while

 PHYLINK automatically parses the phy-handle property */

 Get max speed of operation from device tree */

 Default to phy auto-detection */

	/* Default to get clk_csr from stmmac_clk_crs_set(),

	 * or get clk_csr from device tree.

	/* "snps,phy-addr" is not a standard property. Mark it as deprecated

	 * and warn of its use. Remove this when phy node support is added.

 To Configure PHY by using all device-tree supported properties */

	/* Set the maxmtu to a default of JUMBO_LEN in case the

	 * parameter is not present in the device tree.

 Set default value for multicast hash bins */

 Set default value for unicast filter entries */

	/*

	 * Currently only the properties needed on SPEAr600

	 * are provided. All other properties should be added

	 * once needed on other platforms.

		/* Note that the max-frame-size parameter as defined in the

		 * ePAPR v1.1 spec is defined as max-frame-size, it's

		 * actually used as the IEEE definition of MAC Client

		 * data, or MTU. The ePAPR specification is confusing as

		 * the definition is max-frame-size, but usage examples

		 * are clearly MTUs

 clock setup */

 Fall-back to main clock in case of no PTP ref is passed */

/**

 * stmmac_remove_config_dt - undo the effects of stmmac_probe_config_dt()

 * @pdev: platform_device structure

 * @plat: driver data platform structure

 *

 * Release resources claimed by stmmac_probe_config_dt().

 CONFIG_OF */

	/* Get IRQ information early to have an ability to ask for deferred

	 * probe if needed before we went too far with resource allocation.

	/* On some platforms e.g. SPEAr the wake up irq differs from the mac irq

	 * The external wake up irq can be passed through the platform code

	 * named as "eth_wake_irq"

	 *

	 * In case the wake up interrupt is not passed from the platform

	 * so the driver will continue to use the mac irq (ndev->irq)

/**

 * stmmac_pltfr_remove

 * @pdev: platform device pointer

 * Description: this function calls the main to free the net resources

 * and calls the platforms hook and release the resources (e.g. mem).

/**

 * stmmac_pltfr_suspend

 * @dev: device pointer

 * Description: this function is invoked when suspend the driver and it direcly

 * call the main suspend function and then, if required, on some platform, it

 * can call an exit helper.

/**

 * stmmac_pltfr_resume

 * @dev: device pointer

 * Description: this function is invoked when resume the driver before calling

 * the main resume function, on some platforms, it can call own init helper

 * if required.

 Disable clock in case of PWM is off */

 enable the clk previously disabled */

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  This is the driver for the MAC 10/100 on-chip Ethernet controller

  currently tested on all the ST boards based on STb7109 and stx7200 SoCs.



  DWC Ether MAC 10/100 Universal version 4.0 has been used for developing

  this code.



  This contains the functions to handle the dma.



  Copyright (C) 2007-2009  STMicroelectronics Ltd





  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>

 Enable Application Access by writing to DMA CSR0 */

 Mask interrupts by writing to CSR7 */

 RX descriptor base addr lists must be written into DMA CSR3 */

 TX descriptor base addr lists must be written into DMA CSR4 */

/* Store and Forward capability is not used at all.

 *

 * The transmit threshold can be programmed by setting the TTC bits in the DMA

 * control register.

 DMA controller has two counters to track the number of the missed frames. */

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  This is the driver for the ST MAC 10/100/1000 on-chip Ethernet controllers.

  ST Ethernet IPs are built around a Synopsys IP Core.



	Copyright(C) 2007-2011 STMicroelectronics Ltd





  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>



  Documentation available at:

	http://www.stlinux.com

  Support available at:

	https://bugzilla.stlinux.com/

 CONFIG_DEBUG_FS */

 Module parameters */

 Limit to make sure XDP TX and slow path can coexist */

/* By default the driver will use the ring mode to manage tx and rx descriptors,

 * but allow user to force to use the chain instead of the ring

 For MSI interrupts handling */

/**

 * stmmac_verify_args - verify the driver parameters.

 * Description: it checks the driver parameters and set a default in case of

 * errors.

/**

 * stmmac_disable_all_queues - Disable all queues

 * @priv: driver private structure

 synchronize_rcu() needed for pending XDP buffers to drain */

/**

 * stmmac_enable_all_queues - Enable all queues

 * @priv: driver private structure

/**

 * stmmac_clk_csr_set - dynamically set the MDC clock

 * @priv: driver private structure

 * Description: this is to dynamically set the MDC clock according to the csr

 * clock input.

 * Note:

 *	If a specific clk_csr value is passed from the platform

 *	this means that the CSR Clock Range selection cannot be

 *	changed at run-time and it is fixed (as reported in the driver

 *	documentation). Viceversa the driver will try to set the MDC

 *	clock dynamically according to the actual clock input.

	/* Platform provided default clk_csr would be assumed valid

	 * for all other cases except for the below mentioned ones.

	 * For values higher than the IEEE 802.3 specified frequency

	 * we can not estimate the proper divider as it is not known

	 * the frequency of clk_csr_i. So we do not change the default

	 * divider.

/**

 * stmmac_rx_dirty - Get RX queue dirty

 * @priv: driver private structure

 * @queue: RX queue index

 Clear/set the SW EEE timer flag based on LPI ET enablement */

/**

 * stmmac_enable_eee_mode - check and enter in LPI mode

 * @priv: driver private structure

 * Description: this function is to verify and enter in LPI mode in case of

 * EEE.

 check if all TX queues have the work finished */

 still unfinished work */

 Check and enter in LPI mode */

/**

 * stmmac_disable_eee_mode - disable and exit from LPI mode

 * @priv: driver private structure

 * Description: this function is to exit and disable EEE in case of

 * LPI state is true. This is called by the xmit.

/**

 * stmmac_eee_ctrl_timer - EEE TX SW timer.

 * @t:  timer_list struct containing private info

 * Description:

 *  if there is no data transfer and if we are not in LPI state,

 *  then MAC Transmitter can be moved to LPI state.

/**

 * stmmac_eee_init - init EEE

 * @priv: driver private structure

 * Description:

 *  if the GMAC supports the EEE (from the HW cap reg) and the phy device

 *  can also manage EEE, this function enable the LPI state and start related

 *  timer.

	/* Using PCS we cannot dial with the phy registers at this stage

	 * so we do not support extra feature like EEE.

 Check if MAC core supports the EEE feature. */

 Check if it needs to be deactivated */

 Correct the clk domain crossing(CDC) error */

/* stmmac_get_tx_hwtstamp - get HW TX timestamps

 * @priv: driver private structure

 * @p : descriptor pointer

 * @skb : the socket buffer

 * Description :

 * This function will read timestamp from the descriptor & pass it to stack.

 * and also perform some sanity checks.

 exit if skb doesn't support hw tstamp */

 check tx tstamp status */

 pass tstamp to stack */

/* stmmac_get_rx_hwtstamp - get HW RX timestamps

 * @priv: driver private structure

 * @p : descriptor pointer

 * @np : next descriptor pointer

 * @skb : the socket buffer

 * Description :

 * This function will read received packet's timestamp from the descriptor

 * and pass it to stack. It also perform some sanity checks.

 For GMAC4, the valid timestamp is from CTX next desc. */

 Check if timestamp is available */

/**

 *  stmmac_hwtstamp_set - control hardware timestamping.

 *  @dev: device pointer.

 *  @ifr: An IOCTL specific structure, that can contain a pointer to

 *  a proprietary structure used to pass information to the driver.

 *  Description:

 *  This function configures the MAC to enable/disable both outgoing(TX)

 *  and incoming(RX) packets time stamping based on user input.

 *  Return Value:

 *  0 on success and an appropriate -ve integer on failure.

 reserved for future extensions */

 time stamp no incoming packet at all */

 PTP v1, UDP, any kind of event packet */

			/* 'xmac' hardware can support Sync, Pdelay_Req and

			 * Pdelay_resp by setting bit14 and bits17/16 to 01

			 * This leaves Delay_Req timestamps out.

			 * Enable all events *and* general purpose message

			 * timestamping

 PTP v1, UDP, Sync packet */

 take time stamp for SYNC messages only */

 PTP v1, UDP, Delay_req packet */

 take time stamp for Delay_Req messages only */

 PTP v2, UDP, any kind of event packet */

 take time stamp for all event messages */

 PTP v2, UDP, Sync packet */

 take time stamp for SYNC messages only */

 PTP v2, UDP, Delay_req packet */

 take time stamp for Delay_Req messages only */

 PTP v2/802.AS1 any layer, any kind of event packet */

 PTP v2/802.AS1, any layer, Sync packet */

 take time stamp for SYNC messages only */

 PTP v2/802.AS1, any layer, Delay_req packet */

 take time stamp for Delay_Req messages only */

 time stamp any incoming packet */

 PTP v1, UDP, any kind of event packet */

 program Sub Second Increment reg */

 Store sub second increment and flags for later use */

		/* calculate default added value:

		 * formula is :

		 * addend = (2^32)/freq_div_ratio;

		 * where, freq_div_ratio = 1e9ns/sec_inc

 initialize system time */

 lower 32 bits of tv_sec are safe until y2106 */

/**

 *  stmmac_hwtstamp_get - read hardware timestamping.

 *  @dev: device pointer.

 *  @ifr: An IOCTL specific structure, that can contain a pointer to

 *  a proprietary structure used to pass information to the driver.

 *  Description:

 *  This function obtain the current hardware timestamping settings

 *  as requested.

/**

 * stmmac_init_ptp - init PTP

 * @priv: driver private structure

 * Description: this is to verify if the HW supports the PTPv1 or PTPv2.

 * This is done by looking at the HW cap. register.

 * This function also registers the ptp driver.

 Check if adv_ts can be enabled for dwmac 4.x / xgmac core */

 Dwmac 3.x core with extend_desc can support adv_ts */

/**

 *  stmmac_mac_flow_ctrl - Configure flow control in all queues

 *  @priv: driver private structure

 *  @duplex: duplex passed to the next function

 *  Description: It is used for configuring the flow control in all queues

 Cut down 1G if asked to */

 Half-Duplex can only work with single queue */

 If PCS is supported, check which modes it supports. */

 Nothing to do, xpcs_config() handles everything */

 Flow Control operation */

/**

 * stmmac_check_pcs_mode - verify if RGMII/SGMII is supported

 * @priv: driver private structure

 * Description: this is to verify if the HW supports the PCS.

 * Physical Coding Sublayer (PCS) interface that can be used when the MAC is

 * configured for the TBI, RTBI, or SGMII PHY interface.

/**

 * stmmac_init_phy - PHY initialization

 * @dev: net device structure

 * Description: it initializes the driver's PHY state, and attaches the PHY

 * to the mac driver.

 *  Return value:

 *  0 on success

	/* Some DT bindings do not set-up the PHY handle. Let's try to

	 * manually parse it

 Display RX rings */

 Display RX ring */

 Display TX rings */

 Display RX ring */

 Display TX ring */

/**

 * stmmac_clear_rx_descriptors - clear RX descriptors

 * @priv: driver private structure

 * @queue: RX queue index

 * Description: this function is called to clear the RX descriptors

 * in case of both basic and extended descriptors are used.

 Clear the RX descriptors */

/**

 * stmmac_clear_tx_descriptors - clear tx descriptors

 * @priv: driver private structure

 * @queue: TX queue index.

 * Description: this function is called to clear the TX descriptors

 * in case of both basic and extended descriptors are used.

 Clear the TX descriptors */

/**

 * stmmac_clear_descriptors - clear descriptors

 * @priv: driver private structure

 * Description: this function is called to clear the TX and RX descriptors

 * in case of both basic and extended descriptors are used.

 Clear the RX descriptors */

 Clear the TX descriptors */

/**

 * stmmac_init_rx_buffers - init the RX descriptor buffer.

 * @priv: driver private structure

 * @p: descriptor pointer

 * @i: descriptor index

 * @flags: gfp flag

 * @queue: RX queue index

 * Description: this function is called to allocate a receive buffer, perform

 * the DMA mapping and init the descriptor.

/**

 * stmmac_free_rx_buffer - free RX dma buffers

 * @priv: private structure

 * @queue: RX queue index

 * @i: buffer index.

/**

 * stmmac_free_tx_buffer - free RX dma buffers

 * @priv: private structure

 * @queue: RX queue index

 * @i: buffer index.

/**

 * dma_free_rx_skbufs - free RX dma buffers

 * @priv: private structure

 * @queue: RX queue index

/**

 * dma_free_rx_xskbufs - free RX dma buffers from XSK pool

 * @priv: private structure

 * @queue: RX queue index

/**

 * __init_dma_rx_desc_rings - init the RX descriptor ring (per queue)

 * @priv: driver private structure

 * @queue: RX queue index

 * @flags: gfp flag.

 * Description: this function initializes the DMA RX descriptors

 * and allocates the socket buffers. It supports the chained and ring

 * modes.

		/* RX XDP ZC buffer pool may not be populated, e.g.

		 * xdpsock TX-only.

 Setup the chained descriptor addresses */

 RX INITIALIZATION */

/**

 * __init_dma_tx_desc_rings - init the TX descriptor ring (per queue)

 * @priv: driver private structure

 * @queue : TX queue index

 * Description: this function initializes the DMA TX descriptors

 * and allocates the socket buffers. It supports the chained and ring

 * modes.

 Setup the chained descriptor addresses */

/**

 * init_dma_desc_rings - init the RX/TX descriptor rings

 * @dev: net device structure

 * @flags: gfp flag.

 * Description: this function initializes the DMA RX/TX descriptors

 * and allocates the socket buffers. It supports the chained and ring

 * modes.

/**

 * dma_free_tx_skbufs - free TX dma buffers

 * @priv: private structure

 * @queue: TX queue index

/**

 * stmmac_free_tx_skbufs - free TX skb buffers

 * @priv: private structure

/**

 * __free_dma_rx_desc_resources - free RX dma desc resources (per queue)

 * @priv: private structure

 * @queue: RX queue index

 Release the DMA RX socket buffers */

 Free DMA regions of consistent memory previously allocated */

 Free RX queue resources */

/**

 * __free_dma_tx_desc_resources - free TX dma desc resources (per queue)

 * @priv: private structure

 * @queue: TX queue index

 Release the DMA TX socket buffers */

 Free TX queue resources */

/**

 * __alloc_dma_rx_desc_resources - alloc RX resources (per queue).

 * @priv: private structure

 * @queue: RX queue index

 * Description: according to which descriptor can be used (extend or basic)

 * this function allocates the resources for TX and RX paths. In case of

 * reception, for example, it pre-allocated the RX socket buffer in order to

 * allow zero-copy mechanism.

 RX queues buffers and DMA */

/**

 * __alloc_dma_tx_desc_resources - alloc TX resources (per queue).

 * @priv: private structure

 * @queue: TX queue index

 * Description: according to which descriptor can be used (extend or basic)

 * this function allocates the resources for TX and RX paths. In case of

 * reception, for example, it pre-allocated the RX socket buffer in order to

 * allow zero-copy mechanism.

 TX queues buffers and DMA */

/**

 * alloc_dma_desc_resources - alloc TX/RX resources.

 * @priv: private structure

 * Description: according to which descriptor can be used (extend or basic)

 * this function allocates the resources for TX and RX paths. In case of

 * reception, for example, it pre-allocated the RX socket buffer in order to

 * allow zero-copy mechanism.

 RX Allocation */

/**

 * free_dma_desc_resources - free dma desc resources

 * @priv: private structure

 Release the DMA TX socket buffers */

	/* Release the DMA RX socket buffers later

	 * to ensure all pending XDP_TX buffers are returned.

/**

 *  stmmac_mac_enable_rx_queues - Enable MAC rx queues

 *  @priv: driver private structure

 *  Description: It is used for enabling the rx queues in the MAC

/**

 * stmmac_start_rx_dma - start RX DMA channel

 * @priv: driver private structure

 * @chan: RX channel index

 * Description:

 * This starts a RX DMA channel

/**

 * stmmac_start_tx_dma - start TX DMA channel

 * @priv: driver private structure

 * @chan: TX channel index

 * Description:

 * This starts a TX DMA channel

/**

 * stmmac_stop_rx_dma - stop RX DMA channel

 * @priv: driver private structure

 * @chan: RX channel index

 * Description:

 * This stops a RX DMA channel

/**

 * stmmac_stop_tx_dma - stop TX DMA channel

 * @priv: driver private structure

 * @chan: TX channel index

 * Description:

 * This stops a TX DMA channel

/**

 * stmmac_start_all_dma - start all RX and TX DMA channels

 * @priv: driver private structure

 * Description:

 * This starts all the RX and TX DMA channels

/**

 * stmmac_stop_all_dma - stop all RX and TX DMA channels

 * @priv: driver private structure

 * Description:

 * This stops the RX and TX DMA channels

/**

 *  stmmac_dma_operation_mode - HW DMA operation mode

 *  @priv: driver private structure

 *  Description: it is used for configuring the DMA operation mode register in

 *  order to program the tx/rx DMA thresholds or Store-And-Forward mode.

 Adjust for real per queue fifo size */

		/*

		 * In case of GMAC, SF mode can be enabled

		 * to perform the TX COE in HW. This depends on:

		 * 1) TX COE if actually supported

		 * 2) There is no bugged Jumbo frame support

		 *    that needs to not insert csum in the TDES.

 configure all channels */

 Avoids TX time-out as we are sharing with slow path */

		/* We are sharing with slow path and stop XSK TX desc submission when

		 * available TX ring is less than threshold.

		/* To return XDP buffer to XSK pool, we simple call

		 * xsk_tx_completed(), so we don't need to fill up

		 * 'buf' and 'xdpf'.

	/* Return true if all of the 3 conditions are met

	 *  a) TX Budget is still available

	 *  b) work_done = true when XSK TX desc peek is empty (no more

	 *     pending XSK TX for transmission)

/**

 * stmmac_tx_clean - to manage the transmission completion

 * @priv: driver private structure

 * @budget: napi budget limiting this functions packet handling

 * @queue: TX queue index

 * Description: it reclaims the transmit resources after transmission completes.

 Try to clean all TX complete frame in 1 shot */

 Check if the descriptor is owned by the DMA */

		/* Make sure descriptor fields are read after reading

		 * the own bit.

 Just consider the last segment and ...*/

 ... verify the status error condition */

		/* For XSK TX, we try to send as many as possible.

		 * If XSK work done (XSK TX desc empty and budget still

		 * available), return "budget - 1" to reenable TX IRQ.

		 * Else, return "budget" to make NAPI continue polling.

 We still have pending packets, let's call for a new scheduling */

 Combine decisions from TX clean and XSK TX */

/**

 * stmmac_tx_err - to manage the tx error

 * @priv: driver private structure

 * @chan: channel index

 * Description: it cleans the descriptors and restarts the transmission

 * in case of transmission errors.

/**

 *  stmmac_set_dma_operation_mode - Set DMA operation mode by channel

 *  @priv: driver private structure

 *  @txmode: TX operating mode

 *  @rxmode: RX operating mode

 *  @chan: channel index

 *  Description: it is used for configuring of the DMA operation mode in

 *  runtime in order to program the tx/rx DMA thresholds or Store-And-Forward

 *  mode.

 Adjust for real per queue fifo size */

/**

 * stmmac_dma_interrupt - DMA ISR

 * @priv: driver private structure

 * Description: this is the DMA ISR. It is called by the main ISR.

 * It calls the dwmac dma routine and schedule poll method in case of some

 * work can be done.

 Make sure we never check beyond our status buffer. */

 Try to bump up the dma threshold on this failure */

/**

 * stmmac_mmc_setup: setup the Mac Management Counters (MMC)

 * @priv: driver private structure

 * Description: this masks the MMC irq, in fact, the counters are managed in SW.

/**

 * stmmac_get_hw_features - get MAC capabilities from the HW cap. register.

 * @priv: driver private structure

 * Description:

 *  new GMAC chip generations have a new register to indicate the

 *  presence of the optional feature/functions.

 *  This can be also used to override the value passed through the

 *  platform and necessary for old MAC10/100 and GMAC chips.

/**

 * stmmac_check_ether_addr - check if the MAC addr is valid

 * @priv: driver private structure

 * Description:

 * it is to verify if the MAC address is valid, in case of failures it

 * generates a random MAC address

/**

 * stmmac_init_dma_engine - DMA init.

 * @priv: driver private structure

 * Description:

 * It inits the DMA invoking the specific MAC/GMAC callback.

 * Some DMA parameters can be passed from the platform;

 * in case of these are not passed a default is kept for the MAC or GMAC.

 DMA Configuration */

 DMA CSR Channel configuration */

 DMA RX Channel Configuration */

 DMA TX Channel Configuration */

/**

 * stmmac_tx_timer - mitigation sw timer for tx.

 * @t: data pointer

 * Description:

 * This is the timer handler to directly invoke the stmmac_tx_clean.

/**

 * stmmac_init_coalesce - init mitigation options.

 * @priv: driver private structure

 * Description:

 * This inits the coalesce parameters: i.e. timer rate,

 * timer handler and default threshold used for enabling the

 * interrupt on completion bit.

 set TX ring length */

 set RX ring length */

/**

 *  stmmac_set_tx_queue_weight - Set TX queue weight

 *  @priv: driver private structure

 *  Description: It is used for setting TX queues weight

/**

 *  stmmac_configure_cbs - Configure CBS in TX queue

 *  @priv: driver private structure

 *  Description: It is used for configuring CBS in AVB TX queues

 queue 0 is reserved for legacy traffic */

/**

 *  stmmac_rx_queue_dma_chan_map - Map RX queue to RX dma channel

 *  @priv: driver private structure

 *  Description: It is used for mapping RX queues to RX dma channels

/**

 *  stmmac_mac_config_rx_queues_prio - Configure RX Queue priority

 *  @priv: driver private structure

 *  Description: It is used for configuring the RX Queue Priority

/**

 *  stmmac_mac_config_tx_queues_prio - Configure TX Queue priority

 *  @priv: driver private structure

 *  Description: It is used for configuring the TX Queue Priority

/**

 *  stmmac_mac_config_rx_queues_routing - Configure RX Queue Routing

 *  @priv: driver private structure

 *  Description: It is used for configuring the RX queue routing

 no specific packet type routing specified for the queue */

/**

 *  stmmac_mtl_configuration - Configure MTL

 *  @priv: driver private structure

 *  Description: It is used for configurring MTL

 Configure MTL RX algorithms */

 Configure MTL TX algorithms */

 Configure CBS in AVB TX queues */

 Map RX MTL to DMA channels */

 Enable MAC RX Queues */

 Set RX priorities */

 Set TX priorities */

 Set RX routing */

 Receive Side Scaling */

/**

 * stmmac_hw_setup - setup mac in a usable state.

 *  @dev : pointer to the device structure.

 *  @init_ptp: initialize PTP if set

 *  Description:

 *  this is the main function to setup the HW in a usable state because the

 *  dma engine is reset, the core registers are configured (e.g. AXI,

 *  Checksum features, timers). The DMA is ready to start receiving and

 *  transmitting.

 *  Return value:

 *  0 on success and an appropriate (-)ve integer as defined in errno.h

 *  file on failure.

 DMA initialization and SW reset */

 Copy the MAC addr into the HW  */

 PS and related bits will be programmed according to the speed */

 Initialize the MAC Core */

 Initialize MTL*/

 Initialize Safety Features */

 Enable the MAC Rx/Tx */

 Set the HW DMA mode and the COE */

 Convert the timer from msec to usec */

 set TX and RX rings length */

 Enable TSO */

 TSO and TBS cannot co-exist */

 Enable Split Header */

 VLAN Tag Insertion */

 TBS */

 Configure real RX and TX queues */

 Start the ball rolling... */

 If MAC IRQ request error, no more IRQ to free */

 For common interrupt */

	/* Request the Wake IRQ in case of another line

	 * is used for WoL

	/* Request the LPI IRQ in case of another line

	 * is used for LPI

	/* Request the Safety Feature Correctible Error line in

	 * case of another line is used

	/* Request the Safety Feature Uncorrectible Error line in

	 * case of another line is used

 Request Rx MSI irq */

 Request Tx MSI irq */

	/* Request the Wake IRQ in case of another line

	 * is used for WoL

 Request the IRQ lines */

 Request the IRQ lines */

/**

 *  stmmac_open - open entry point of the driver

 *  @dev : pointer to the device structure.

 *  Description:

 *  This function is the open entry point of the driver.

 *  Return value:

 *  0 on success and an appropriate (-)ve integer as defined in errno.h

 *  file on failure.

 Extra statistics */

 Earlier check for TBS */

 Setup per-TXQ tbs flag before TX descriptor alloc */

 We may have called phylink_speed_down before */

/**

 *  stmmac_release - close entry point of the driver

 *  @dev : device pointer.

 *  Description:

 *  This is the stop entry point of the driver.

 Stop and disconnect the PHY */

 Free the IRQ lines */

 Stop TX/RX DMA and clear the descriptors */

 Release and free the Rx/Tx resources */

 Disable the MAC Rx/Tx */

/**

 *  stmmac_tso_allocator - close entry point of the driver

 *  @priv: driver private structure

 *  @des: buffer start address

 *  @total_len: total length to fill in descriptors

 *  @last_segment: condition for the last descriptor

 *  @queue: TX queue index

 *  Description:

 *  This function fills descriptor and request new descriptors according to

 *  buffer length to fill

	/* The own bit must be the latest setting done when prepare the

	 * descriptor and then barrier is needed to make sure that

	 * all is coherent before granting the DMA engine.

/**

 *  stmmac_tso_xmit - Tx entry point of the driver for oversized frames (TSO)

 *  @skb : the socket buffer

 *  @dev : device pointer

 *  Description: this is the transmit function that is called on TSO frames

 *  (support available on GMAC4 and newer chips).

 *  Diagram below show the ring programming in case of TSO frames:

 *

 *  First Descriptor

 *   --------

 *   | DES0 |---> buffer1 = L2/L3/L4 header

 *   | DES1 |---> TCP Payload (can continue on next descr...)

 *   | DES2 |---> buffer 1 and 2 len

 *   | DES3 |---> must set TSE, TCP hdr len-> [22:19]. TCP payload len [17:0]

 *   --------

 *	|

 *     ...

 *	|

 *   --------

 *   | DES0 | --| Split TCP Payload on Buffers 1 and 2

 *   | DES1 | --|

 *   | DES2 | --> buffer 1 and 2 len

 *   | DES3 |

 *   --------

 *

 * mss is fixed when enable tso, so w/o programming the TDES3 ctx field.

 Compute header lengths */

 Desc availability based on threshold should be enough safe */

 This is a hard error, log it. */

 no frags */

 set new MSS value if needed */

 Check if VLAN can be inserted by HW */

 first descriptor: fill Headers on Buf1 */

 Fill start of payload in buff2 of first descriptor */

 If needed take extra descriptors to fill the remaining payload */

 Prepare fragments */

 Only the last descriptor gets to point to the skb. */

 Manage tx mitigation */

	/* We've used all descriptors we need for this skb, however,

	 * advance cur_tx so that it references a fresh descriptor.

	 * ndo_start_xmit will fill this descriptor the next time it's

	 * called and stmmac_tx_clean may clean up to this descriptor.

 declare that device is doing timestamping */

 Complete the first descriptor before granting the DMA */

 If context desc is used to change MSS */

		/* Make sure that first descriptor has been completely

		 * written, including its own bit. This is because MSS is

		 * actually before first descriptor, so we need to make

		 * sure that MSS's own bit is the last thing written.

/**

 *  stmmac_xmit - Tx entry point of the driver

 *  @skb : the socket buffer

 *  @dev : device pointer

 *  Description : this is the tx entry point of the driver.

 *  It programs the chain or the ring and supports oversized frames

 *  and SG feature.

 Manage oversized TCP frames for GMAC4 device */

 This is a hard error, log it. */

 Check if VLAN can be inserted by HW */

 To program the descriptors according to the size of the frame */

 should reuse desc w/o issues */

 Prepare the descriptor and set the own bit too */

 Only the last descriptor gets to point to the skb. */

	/* According to the coalesce parameter the IC bit for the latest

	 * segment is reset and the timer re-started to clean the tx status.

	 * This approach takes care about the fragments: desc is the first

	 * element in case of no SG.

	/* We've used all descriptors we need for this skb, however,

	 * advance cur_tx so that it references a fresh descriptor.

	 * ndo_start_xmit will fill this descriptor the next time it's

	 * called and stmmac_tx_clean may clean up to this descriptor.

	/* Ready to fill the first descriptor and set the OWN bit w/o any

	 * problems because all the descriptors are actually ready to be

	 * passed to the DMA engine.

 declare that device is doing timestamping */

 Prepare the first descriptor setting the OWN bit too */

 pop the vlan tag */

/**

 * stmmac_rx_refill - refill used skb preallocated buffers

 * @priv: driver private structure

 * @queue: RX queue index

 * Description : this is to reallocate the skb for the reception process

 * that is based on zero-copy.

 Not first descriptor, buffer is always zero */

 First descriptor, get split header length */

 First descriptor, not last descriptor and not split header */

 First descriptor and last descriptor and not split header */

 Not split header, buffer is not available */

 Not last descriptor */

 Last descriptor */

 Avoids TX time-out as we are sharing with slow path */

 read the status of the incoming frame */

 check if managed by the DMA otherwise go ahead */

 Prefetch the next RX descriptor */

 Ensure a valid XSK buffer before proceed */

 XSK pool expects RX frame 1:1 mapped to XSK buffer */

 XDP ZC Frame only support primary buffers for now */

		/* ACS is set; GMAC core strips PAD/FCS for IEEE 802.3

		 * Type frames (LLC/LLC-SNAP)

		 *

		 * llc_snap is never checked in GMAC >= 4, so this ACS

		 * feature is always disabled and packets need to be

		 * stripped manually.

 RX buffer is good and fit into a XSK pool buffer */

/**

 * stmmac_rx - manage the receive process

 * @priv: driver private structure

 * @limit: napi bugget

 * @queue: RX queue index.

 * Description :  this the function called by the napi poll method.

 * It gets all the frames inside the ring.

 read the status of the incoming frame */

 check if managed by the DMA otherwise go ahead */

 Buffer is good. Go on. */

		/* ACS is set; GMAC core strips PAD/FCS for IEEE 802.3

		 * Type frames (LLC/LLC-SNAP)

		 *

		 * llc_snap is never checked in GMAC >= 4, so this ACS

		 * feature is always disabled and packets need to be

		 * stripped manually.

			/* Due xdp_adjust_tail: DMA sync for_device

			 * cover max len CPU touch

 For Not XDP_PASS verdict */

					/* Clear skb as it was set as

					 * status by XDP program.

 XDP program may expand or reduce tail */

 XDP program may adjust header */

 Data payload copied into SKB, page ready for recycle */

 Data payload appended into SKB */

 Data payload appended into SKB */

 Got entire packet into SKB. Finish it. */

	/* If either TX or RX work is not complete, return budget

	 * and keep pooling

 all work done, exit the polling mode */

		/* Both RX and TX work done are compelte,

		 * so enable both RX & TX IRQs.

/**

 *  stmmac_tx_timeout

 *  @dev : Pointer to net device structure

 *  @txqueue: the index of the hanging transmit queue

 *  Description: this function is called when a packet transmission fails to

 *   complete within a reasonable time. The driver will mark the error in the

 *   netdev structure and arrange for the device to be reset to a sane state

 *   in order to transmit a new packet.

/**

 *  stmmac_set_rx_mode - entry point for multicast addressing

 *  @dev : pointer to the device structure

 *  Description:

 *  This function is a driver entry point which gets called by the kernel

 *  whenever multicast addresses must be enabled/disabled.

 *  Return value:

 *  void.

/**

 *  stmmac_change_mtu - entry point to change MTU size for the device.

 *  @dev : device pointer.

 *  @new_mtu : the new MTU size for the device.

 *  Description: the Maximum Transfer Unit (MTU) is used by the network layer

 *  to drive packet transmission. Ethernet has an MTU of 1500 octets

 *  (ETH_DATA_LEN). This value can be changed with ifconfig.

 *  Return value:

 *  0 on success and an appropriate (-)ve integer as defined in errno.h

 *  file on failure.

 If condition true, FIFO is too small or MTU too large */

	/* Some GMAC devices have a bugged Jumbo frame support that

	 * needs to have the Tx COE disabled for oversized frames

	 * (due to limited buffer sizes). In this case we disable

	 * the TX csum insertion in the TDES and not use SF.

 Disable tso if asked by ethtool */

 Keep the COE Type in case of csum is supporting */

	/* No check needed because rx_coe has been set before and it will be

	 * fixed in case of issue.

 If LP has sent verify mPacket, LP is FPE capable */

 If user has requested FPE enable, quickly response */

 If Local has sent verify mPacket, Local is FPE capable */

 If LP has sent response mPacket, LP is entering FPE ON */

 If Local has sent response mPacket, Local is entering FPE ON */

 To handle GMAC own interrupts */

 For LPI we need to save the tx status */

 PCS link status */

/**

 *  stmmac_interrupt - main ISR

 *  @irq: interrupt number.

 *  @dev_id: to pass the net device pointer.

 *  Description: this is the main driver interrupt service routine.

 *  It can call:

 *  o DMA service routine (to manage incoming frame reception and transmission

 *    status)

 *  o Core interrupts to manage: remote wake-up, management counter, LPI

 *    interrupts.

 Check if adapter is up */

 Check if a fatal error happened */

 To handle Common interrupts */

 To handle DMA interrupts */

 Check if adapter is up */

 To handle Common interrupts */

 Check if adapter is up */

 Check if a fatal error happened */

 Check if adapter is up */

 Try to bump up the dma threshold on this failure */

 Check if adapter is up */

/* Polling receive - used by NETCONSOLE and other diagnostic tools

 * to allow network I/O with interrupts disabled.

 If adapter is down, do nothing */

/**

 *  stmmac_ioctl - Entry point for the Ioctl

 *  @dev: Device pointer.

 *  @rq: An IOCTL specefic structure, that can contain a pointer to

 *  a proprietary structure used to pass information to the driver.

 *  @cmd: IOCTL command

 *  Description:

 *  Currently it supports the phy_mii_ioctl(...) and HW time stamping.

		/*

		 * There is no way to determine the number of TSO/USO

		 * capable Queues. Let's use always the Queue 0

		 * because if TSO/USO is supported then at least this

		 * one will be capable.

/* Use network device events to rename debugfs file entries.

 Create per netdev entries */

 Entry to report DMA RX/TX rings */

 Entry to report the DMA HW features */

 CONFIG_DEBUG_FS */

 VID = 0 always passes filter */

 Avoids TX time-out as we are sharing with slow path */

		/* EQoS does not have per-DMA channel SW interrupt,

		 * so we schedule RX Napi straight-away.

/**

 *  stmmac_hw_init - Init the MAC device

 *  @priv: driver private structure

 *  Description: this function is to configure the MAC device according to

 *  some platform parameters or the HW capability register. It prepares the

 *  driver to use either ring or chain modes and to setup either enhanced or

 *  normal descriptors.

 dwmac-sun8i only work in chain mode */

 Initialize HW Interface */

 Get the HW capability (new GMAC newer than 3.50a) */

		/* We can override some gmac/dma configuration fields: e.g.

		 * enh_desc, tx_coe (e.g. that are passed through the

		 * platform) with the values from the HW capability

		 * register (if supported).

 TXCOE doesn't work in thresh DMA mode */

 In case of GMAC4 rx_coe is from HW cap register. */

 Run HW quirks, if any */

	/* Rx Watchdog is available in the COREs newer than the 3.40.

	 * In some case, for example on bugged HW this feature

	 * has to be disable and this can be done by passing the

	 * riwt_off field from the platform.

 Bail out immediately if FPE handshake is OFF */

 Sleep then retry */

/**

 * stmmac_dvr_probe

 * @device: device pointer

 * @plat_dat: platform data pointer

 * @res: stmmac resource pointer

 * Description: this is the main probe function used to

 * call the alloc_etherdev, allocate the priv structure.

 * Return:

 * returns 0 on success, otherwise errno.

 Verify driver arguments */

 Allocate workqueue */

 Initialize Link Partner FPE workqueue */

	/* Override with kernel parameters if supplied XXX CRS XXX

	 * this needs to have multiple instances

		/* Some reset controllers have only reset callback instead of

		 * assert + deassert callbacks pair.

 Init MAC and get the capabilities */

	/* Only DWMAC core version 5.20 onwards supports HW descriptor prefetch.

	/* The current IP register MAC_HW_Feature1[ADDR64] only define

	 * 32/40/64 bit width, but some SOC support others like i.MX8MP

	 * support 34 bits but it map to 40 bits width in MAC_HW_Feature1[ADDR64].

	 * So overwrite dma_cap.addr64 according to HW real design.

			/*

			 * If more than 32 bits can be addressed, make sure to

			 * enable enhanced addressing mode.

 Both mac100 and gmac support receive VLAN tag detection */

 Initialize RSS */

 MTU range: 46 - hw-specific max */

	/* Will not overwrite ndev->max_mtu if plat->maxmtu > ndev->max_mtu

	 * as well as plat->maxmtu < ndev->min_mtu which is a invalid range.

 RX/TX pause on */

 Setup channels NAPI */

	/* If a specific clk_csr value is passed from the platform

	 * this means that the CSR Clock Range selection cannot be

	 * changed at run-time and it is fixed. Viceversa the driver'll try to

	 * set the MDC clock dynamically according to the csr actual

	 * clock input.

 MDIO bus Registration */

	/* Let pm_runtime_put() disable the clocks.

	 * If CONFIG_PM is not enabled, the clocks will stay powered.

/**

 * stmmac_dvr_remove

 * @dev: device pointer

 * Description: this function resets the TX/RX processes, disables the MAC RX/TX

 * changes the link status, releases the DMA descriptor rings.

	/* Serdes power down needs to happen after VLAN filter

	 * is deleted that is triggered by unregister_netdev().

/**

 * stmmac_suspend - suspend callback

 * @dev: device pointer

 * Description: this is the function to suspend the device and it is called

 * by the platform driver to stop the network queue, release the resources,

 * program the PMT register (for WoL), clean and release driver resources.

 Stop TX/RX DMA */

 Enable Power down mode by programming the PMT regs */

 Disable FPE */

/**

 * stmmac_reset_queues_param - reset queue parameters

 * @priv: device pointer

/**

 * stmmac_resume - resume callback

 * @dev: device pointer

 * Description: when resume this function is invoked to setup the DMA and CORE

 * in a usable state.

	/* Power Down bit, into the PM register, is cleared

	 * automatically as soon as a magic packet or a Wake-up frame

	 * is received. Anyway, it's better to manually clear

	 * this bit because it can generate problems while resuming

	 * from another devices (e.g. serial console).

 reset the phy so that it's ready */

 MODULE */

 Create debugfs main directory if it doesn't exist yet */

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  Copyright (C) 2013  Vayavya Labs Pvt Ltd



  This implements all the API for managing HW timestamp & PTP.





  Author: Rayagond Kokatanur <rayagond@vayavyalabs.com>

  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>

	/* For GMAC3.x, 4.x versions, in "fine adjustement mode" set sub-second

	 * increment to twice the number of nanoseconds of a clock cycle.

	 * The calculation of the default_addend value by the caller will set it

	 * to mid-range = 2^31 when the remainder of this division is zero,

	 * which will make the accumulator overflow once every 2 ptp_clock

	 * cycles, adding twice the number of nanoseconds of a clock cycle :

	 * 2000000000ULL / ptp_clock.

 0.465ns accuracy */

 issue command to initialize the system time value */

 wait for present system time initialize to complete */

 issue command to update the addend value */

 wait for present addend update to complete */

		/* If the new sec value needs to be subtracted with

		 * the system time, then MAC_STSUR reg should be

		 * programmed with (2^32 – <new_sec_value>)

 issue command to initialize the system time value */

 wait for present system time adjust/update to complete */

 Get the TSSS value */

 Get the TSS and convert sec time value to nanosecond */

	/* Read timestamp status to clear interrupt from either external

	 * timestamp or start/end of PPS.

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  Specialised functions for managing Chained mode



  Copyright(C) 2011  STMicroelectronics Ltd



  It defines all the functions used to handle the normal/enhanced

  descriptors in case of the DMA is configured to work in chained or

  in ring mode.





  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>

 do not close the descriptor and do not set own bit */

 last descriptor can be set now */

	/*

	 * In chained mode the des3 points to the next element in the ring.

	 * The latest element has to point to the head.

		/* NOTE: Device will overwrite des3 with timestamp value if

		 * 1588-2002 time stamping is enabled, hence reinitialize it

		 * to keep explicit chaining in the descriptor.

		/* NOTE: Device will overwrite des3 with timestamp value if

		 * 1588-2002 time stamping is enabled, hence reinitialize it

		 * to keep explicit chaining in the descriptor.

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  This contains the functions to handle the enhanced descriptors.



  Copyright (C) 2007-2014  STMicroelectronics Ltd





  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>

 Get tx owner first */

 Verify tx error by looking at the last segment. */

	/* bits 5 7 0 | Frame status

	 * ----------------------------------------------------------

	 *      0 0 0 | IEEE 802.3 Type frame (length < 1536 octects)

	 *      1 0 0 | IPv4/6 No CSUM errorS.

	 *      1 0 1 | IPv4/6 CSUM PAYLOAD error

	 *      1 1 0 | IPv4/6 CSUM IP HR error

	 *      1 1 1 | IPv4/6 IP PAYLOAD AND HEADER errorS

	 *      0 0 1 | IPv4/6 unsupported IP PAYLOAD

	 *      0 1 1 | COE bypassed.. no IPv4/6 frame

	 *      0 1 0 | Reserved.

 GMII */

	/* After a payload csum error, the ES bit is set.

	 * It doesn't match with the information reported into the databook.

	 * At any rate, we need to understand if the CSUM hw computation is ok

 Finally set the OWN bit. Later the DMA will start! */

		/* When the own bit, for the first frame, has to be set, all

		 * descriptors for the same frame has to be set before, to

		 * avoid race condition.

	/* The type-1 checksum offload engines append the checksum at

	 * the end of frame and the two bytes of checksum are added in

	 * the length.

	 * Adjust for that in the framelen for type-1 checksum offload

	 * engines.

 convert high/sec time stamp value to nanosecond */

 timestamp is corrupted, hence don't store it */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Adaptrum Anarion DWMAC glue layer

 *

 * Copyright (C) 2017, Adaptrum, Inc.

 * (Written by Alexandru Gagniuc <alex.g at adaptrum.com> for Adaptrum, Inc.)

 Reset logic, configure interface mode, then release reset. SIMPLE! */

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  Specialised functions for managing Ring mode



  Copyright(C) 2011  STMicroelectronics Ltd



  It defines all the functions used to handle the normal/enhanced

  descriptors in case of the DMA is configured to work in chained or

  in ring mode.





  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>

 Fill DES3 in case of RING mode */

 In ring mode we need to fill the desc3 because it is used as buffer */

 des3 is only used for jumbo frames tx or time stamping */

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  This contains the functions to handle the normal descriptors.



  Copyright (C) 2007-2009  STMicroelectronics Ltd





  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>

 Get tx owner first */

 Verify tx error by looking at the last segment. */

/* This function verifies if each incoming frame has some errors

 * and, if required, updates the multicast statistics.

 * In case of success, it returns good_frame because the GMAC device

	/* The type-1 checksum offload engines append the checksum at

	 * the end of frame and the two bytes of checksum are added in

	 * the length.

	 * Adjust for that in the framelen for type-1 checksum offload

	 * engines

 convert high/sec time stamp value to nanosecond */

 timestamp is corrupted, hence don't store it */

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/*

 * Copyright (c) 2018 Synopsys, Inc. and/or its affiliates.

 * stmmac HW Interface Handling

 GMAC older than 3.50 has no extended descriptors */

 NOTE: New HW versions shall go to the end of this table */

 Save ID for later use */

 Lets assume some safe values first */

 Check for HW specific setup first */

 Fallback to generic HW */

 Use synopsys_id var because some setups can override this */

 Only use generic HW helpers if needed */

 Entry found */

 Save quirks, if needed for posterior use */

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  This is the driver for the MAC 10/100 on-chip Ethernet controller

  currently tested on all the ST boards based on STb7109 and stx7200 SoCs.



  DWC Ether MAC 10/100 Universal version 4.0 has been used for developing

  this code.



  This only implements the mac core functions for this chip.



  Copyright (C) 2007-2009  STMicroelectronics Ltd





  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>

	/* Clear ASTP bit because Ethernet switch tagging formats such as

	 * Broadcom tags can look like invalid LLC/SNAP packets and cause the

	 * hardware to truncate packets on reception.

 no multicast */

		/* Perfect filter mode for physical address and Hash

		 * filter for multicast

			/* The upper 6 bits of the calculated CRC are used to

			 * index the contens of the hash table

			/* The most significant bit determines the register to

			 * use (H/L) while the other 5 bits determine the bit

			 * within the register.

 No PMT module supported on ST boards with this Eth chip. */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * dwmac-stm32.c - DWMAC Specific Glue layer for STM32 MCU

 *

 * Copyright (C) STMicroelectronics SA 2017

 * Author:  Alexandre Torgue <alexandre.torgue@st.com> for STMicroelectronics.

 CLOCK feed to PHY*/

/*  Ethernet PHY interface selection in register SYSCFG Configuration

 *------------------------------------------

 * src	 |BIT(23)| BIT(22)| BIT(21)|BIT(20)|

 *------------------------------------------

 * MII   |   0	 |   0	  |   0    |   1   |

 *------------------------------------------

 * GMII  |   0	 |   0	  |   0    |   0   |

 *------------------------------------------

 * RGMII |   0	 |   0	  |   1	   |  n/a  |

 *------------------------------------------

 * RMII  |   1	 |   0	  |   0	   |  n/a  |

 *------------------------------------------

/* STM32MP1 register definitions

 *

 * Below table summarizes the clock requirement and clock sources for

 * supported phy interface modes.

 * __________________________________________________________________________

 *|PHY_MODE | Normal | PHY wo crystal|   PHY wo crystal   |No 125Mhz from PHY|

 *|         |        |      25MHz    |        50MHz       |                  |

 * ---------------------------------------------------------------------------

 *|  MII    |	 -   |     eth-ck    |	      n/a	  |	  n/a        |

 *|         |        | st,ext-phyclk |                    |		     |

 * ---------------------------------------------------------------------------

 *|  GMII   |	 -   |     eth-ck    |	      n/a	  |	  n/a        |

 *|         |        | st,ext-phyclk |                    |		     |

 * ---------------------------------------------------------------------------

 *| RGMII   |	 -   |     eth-ck    |	      n/a	  |      eth-ck      |

 *|         |        | st,ext-phyclk |                    | st,eth-clk-sel or|

 *|         |        |               |                    | st,ext-phyclk    |

 * ---------------------------------------------------------------------------

 *| RMII    |	 -   |     eth-ck    |	    eth-ck        |	  n/a        |

 *|         |        | st,ext-phyclk | st,eth-ref-clk-sel |		     |

 *|         |        |               | or st,ext-phyclk   |		     |

 * ---------------------------------------------------------------------------

 *

 MAC glue-logic mode register */

 Do not manage others interfaces */

 Need to update PMCCLRR (clear register) */

 Update PMCSETR (set register) */

 Do not manage others interfaces */

  Get TX/RX clocks */

 Get mode register */

 Ethernet PHY have no crystal */

 Gigabit Ethernet 125MHz clock selection. */

 Ethernet 50Mhz RMII clock selection */

  Get ETH_CLK clocks */

  Clock used for low power mode */

  Optional Clock for sysconfig */

	/* Get IRQ information early to have an ability to ask for deferred

	 * probe if needed before we went too far with resource allocation.

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  DWMAC Management Counters



  Copyright (C) 2011  STMicroelectronics Ltd





  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>

 MAC Management Counters register offset */

 MMC Control */

 MMC RX Interrupt */

 MMC TX Interrupt */

 MMC Interrupt Mask */

 MMC Interrupt Mask */

 MMC TX counter registers */

/* Note:

 * _GB register stands for good and bad frames

 * _G is for good only.

 MMC RX counter registers */

 IPC*/

 IPv4*/

 IPV6*/

 Protocols*/

 XGMAC MMC Registers */

 To mask all all interrupts.*/

/* This reads the MAC core counters (if actaully supported).

 * by default the MMC core is programmed to reset each

 * counter after a read. So all the field of the mmc struct

 * have to be incremented.

 MMC RX counter registers */

 IPC */

 IPv4 */

 IPV6 */

 Protocols */

/* This reads the MAC core counters (if actaully supported).

 * by default the MMC core is programmed to reset each

 * counter after a read. So all the field of the mmc struct

 * have to be incremented.

 MMC RX counter registers */

 SPDX-License-Identifier: GPL-2.0

/* Copyright (c) 2020, Intel Corporation

 mdio address for serdes & etc */

/* This struct is used to associate PCI Function of MAC controller on a board,

 * discovered via DMI, with the address of PHY connected to the MAC. The

 * negative value of the address means that MAC controller is not connected

 * with PHY.

 Set the serdes rate and the PCLK rate */

 assert clk_req */

 check for clk_ack assertion */

 assert lane reset */

 check for assert lane reset reflection */

  move power state to P0 */

 Check for P0 state */

 PSE only - ungate SGMII PHY Rx Clock */

 PSE only - gate SGMII PHY Rx Clock */

  move power state to P3 */

 Check for P3 state */

 de-assert clk_req */

 check for clk_ack de-assert */

 de-assert lane reset */

 check for de-assert lane reset reflection */

 Determine the link speed mode: 2.5Gbps/1Gbps */

/* Program PTP Clock Frequency for different variant of

 * Intel mGBE that has slightly different GPO mapping

 For PSE GbE, use 200MHz */

 For PCH GbE, use 200MHz */

	/* Both internal crosstimestamping and external triggered event

	 * timestamping cannot be run concurrently.

 Enable Internal snapshot trigger */

 Clear FIFO */

 Release the mutex */

	/* Trigger Internal snapshot signal

	 * Create a rising edge by just toggle the GPO1 to low

	 * and back to high.

 Poll for time sync operation done */

 Repeat until the timestamps are from the FIFO last segment */

		/* On systems that support ART, ART frequency can be obtained

		 * from ECX register of CPUID leaf (0x15).

 clk_csr_i = 20-35MHz & MDC = clk_csr_i/16 */

 Set default value for multicast hash bins */

 Set default value for unicast filter entries */

 Set the maxmtu to a default of JUMBO_LEN */

 Set default number of RX and TX queues to use */

 Disable Priority config by default */

 Disable RX queues routing by default */

	/* Multiplying factor to the clk_eee_i clock time

	 * period to make it closer to 100 ns. This value

	 * should be programmed such that the clk_eee_time_period *

	 * (MULT_FACT_100NS + 1) should be within 80 ns to 120 ns

	 * clk_eee frequency is 19.2Mhz

	 * clk_eee_time_period is 52ns

	 * 52ns * (1 + 1) = 104ns

	 * MULT_FACT_100NS = 1

 Disable Priority config by default */

 Disable RX queues routing by default */

 Disable Priority config by default */

 Default TX Q0 to use TSO and rest TXQ for TBS */

 FIFO size is 4096 bytes for 1 tx/rx queue */

 Set system clock */

 Set default value for multicast hash bins */

 Set default value for unicast filter entries */

 Set the maxmtu to a default of JUMBO_LEN */

 Use the last Rx queue */

 Intel mgbe SGMII interface uses pcs-xcps */

 Ensure mdio bus scan skips intel serdes and pcs-xpcs */

 Setup MSI vector offset specific to Intel mGbE controller */

 SerDes power up and power down are done in BIOS for ADL */

 SerDes power up and power down are done in BIOS for ADL */

	/* There are 2 types of SIMATIC IOT2000: IOT2020 and IOT2040.

	 * The asset tag "6ES7647-0AA00-0YA2" is only for IOT2020 which

	 * has only one pci network device while other asset tags are

	 * for IOT2040 which has two.

 Set common default data first */

	/* Refuse to load the driver and register net device if MAC controller

	 * does not connect to any PHY interface.

 Return error to the caller on DMI enabled boards. */

		/* Galileo boards with old firmware don't support DMI. We always

		 * use 1 here as PHY address, so at least the first found MAC

		 * controller would be probed.

 AXI (TODO) */

 For RX MSI */

 For TX MSI */

/**

 * intel_eth_pci_probe

 *

 * @pdev: pci device pointer

 * @id: pointer to table of device id/id's.

 *

 * Description: This probing function gets called for all PCI devices which

 * match the ID table and are not "owned" by other driver yet. This function

 * gets passed a "struct pci_dev *" for each device whose entry in the ID table

 * matches the device. The probe functions returns zero when the driver choose

 * to take "ownership" of the device or an error code(-ve no) otherwise.

 Enable pci device */

	/* Initialize all MSI vectors to invalid so that it can be set

	 * according to platform data settings below.

	 * Note: MSI vector takes value from 0 upto 31 (STMMAC_MSI_VEC_MAX)

/**

 * intel_eth_pci_remove

 *

 * @pdev: pci device pointer

 * Description: this function calls the main to free the net resources

 * and releases the PCI resources.

/* Intel(R) Programmable Services Engine (Intel(R) PSE) consist of 2 MAC

 * which are named PSE0 and PSE1

 SPDX-License-Identifier: GPL-2.0

/* Intel DWMAC platform driver

 *

 * Copyright(C) 2020 Intel Corporation

 Enable TX clock */

 Check and configure TX clock rate */

 Check and configure PTP ref clock rate */

/*

 * DWMAC glue for NXP LPC18xx/LPC43xx Ethernet

 *

 * Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 Register defines for CREG syscon */

 SPDX-License-Identifier: GPL-2.0

/*

 * Copyright (c) 2019 Synopsys, Inc. and/or its affiliates.

 * stmmac Selftests Support

 *

 * Author: Jose Abreu <joabreu@synopsys.com>

 HACK */

 Save previous results into internal struct */

 These will be loopback results so no need to save them */

	/*

	 * The number of MMC counters available depends on HW configuration

	 * so we just use this one to validate the feature. I hope there is

	 * not a version without this counter.

 We have no traffic in the line so, sooner or later it will go LPI */

 First compute the hash for desired addr */

 Now, check if it collides with any existing one */

 No collisions, address is good to go */

 Check if it collides with any existing one */

 No collisions, address is good to go */

 We only need to check the bd_addr for collisions */

 Shall receive packet */

 Shall NOT receive packet */

 We only need to check the bd_addr for collisions */

 Shall receive packet */

 Shall NOT receive packet */

 We only need to check the mc_addr for collisions */

 Shall receive packet */

 Shall NOT receive packet */

 We only need to check the uc_addr for collisions */

 Shall receive packet */

 Shall NOT receive packet */

 Compute minimum number of packets to make FIFO full */

 Wait for some time in case RX Watchdog is enabled */

 Means filter did not work. */

	/*

	 * As we use HASH filtering, false positives may appear. This is a

	 * specially chosen ID so that adjacent IDs (+4) have different

	 * HASH values.

	/*

	 * As we use HASH filtering, false positives may appear. This is a

	 * specially chosen ID so that adjacent IDs (+4) have different

	 * HASH values.

 Shall NOT receive packet */

 Shall receive packet */

 Shall NOT receive packet */

 Shall receive packet */

 Shall NOT receive packet */

 Check for UDP first */

 Check for TCP now */

 500 ms*/

 Find first TBS enabled Queue, if any */

 Check if expected time has elapsed */

 Test will handle it */

 Wait for queues drain */

		/*

		 * First tests will always be MAC / PHY loobpack. If any of

		 * them is not supported we abort earlier.

/*

 * Qualcomm Atheros IPQ806x GMAC glue layer

 *

 * Copyright (C) 2015 The Linux Foundation

 *

 * Permission to use, copy, modify, and/or distribute this software for any

 * purpose with or without fee is hereby granted, provided that the above

 * copyright notice and this permission notice appear in all copies.

 *

 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES

 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF

 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR

 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES

 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN

 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF

 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

/* Mode is coded on 1 bit but is different depending on the MAC ID:

 * MAC0: QSGMII=0 RGMII=1

 * MAC1: QSGMII=0 SGMII=0 RGMII=1

 * MAC2 & MAC3: QSGMII=0 SGMII=1

 Only GMAC1/2/3 support SGMII and their CTL register are not contiguous */

 Disable the clocks */

 Set the divider */

 Enable the clock back */

	/* The GMACs are called 1 to 4 in the documentation, but to simplify the

	 * code and keep it consistent with the Linux convention, we'll number

	 * them from 0 to 3 here.

 Setup the register map for the nss common registers */

 Setup the register map for the qsgmii csr registers */

 Inter frame gap is set to 12 */

 We also initiate an AXI low power exit request */

 Configure the clock src according to the mode */

 Enable PTP clock */

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  STMMAC Ethtool support



  Copyright (C) 2007-2009  STMicroelectronics Ltd





  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>

 Transmit errors */

 Receive errors */

 Tx/Rx IRQ error info */

 Tx/Rx IRQ Events */

 MMC info */

 EEE */

 Extended RDES status */

 PCS */

 DEBUG */

 TSO */

 EST */

 HW MAC Management counters (if supported) */

 Get and convert ADV/LP_ADV from the HW AN registers */

 should never happen indeed */

 Encoding of PSE bits is defined in 802.3z, 37.2.1.4 */

 Reg49[3] always set because ANE is always supported */

 Only support ANE */

 Copy DMA registers to where ethtool expects them */

 Update the DMA HW counters for dwmac10/100 */

 If supported, for new GMAC chips expose the MMC counters */

 Currently only support WOL through Magic packet. */

	/* By default almost all GMAC devices support the WoL via

	 * magic frame but we can disable it if the HW capability

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * dwmac-sunxi.c - Allwinner sunxi DWMAC specific glue layer

 *

 * Copyright (C) 2013 Chen-Yu Tsai

 *

 * Chen-Yu Tsai  <wens@csie.org>

	/* Set GMAC interface port mode

	 *

	 * The GMAC TX clock lines are configured by setting the clock

	 * rate, which then uses the auto-reparenting feature of the

	 * clock driver, and enabling/disabling the clock.

 only GMII mode requires us to reconfigure the clock lines */

 Optional regulator for PHY */

	/* platform data specifying hardware features and callbacks.

/*

 * Generic DWMAC platform driver

 *

 * Copyright (C) 2007-2011  STMicroelectronics Ltd

 * Copyright (C) 2015 Joachim Eastwood <manabian@gmail.com>

 *

 * This file is licensed under the terms of the GNU General Public

 * License version 2. This program is licensed "as is" without any

 * warranty of any kind, whether express or implied.

 Set default value for multicast hash bins */

 Set default value for unicast filter entries */

 Custom initialisation (if needed) */

 SPDX-License-Identifier: GPL-2.0-only

/*******************************************************************************

  This is the driver for the GMAC on-chip Ethernet controller for ST SoCs.

  DWC Ether MAC 10/100/1000 Universal version 3.41a  has been used for

  developing this code.



  This only implements the mac core functions for this chip.



  Copyright (C) 2007-2009  STMicroelectronics Ltd





  Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>

 Configure GMAC core */

	/* Clear ACS bit because Ethernet switch tagging formats such as

	 * Broadcom tags can look like invalid LLC/SNAP packets and cause the

	 * hardware to truncate packets on reception.

 Mask GMAC interrupts */

 Tag detection without filtering */

 pass all multi */

 Fall back to all multicast if we've no filter */

 Hash filter for multicast */

			/* The upper n bits of the calculated CRC are used to

			 * index the contents of the hash table. The number of

			 * bits used depends on the hardware configuration

			 * selected at core configuration time.

			/* The most significant bit determines the register to

			 * use (H/L) while the other 5 bits determine the bit

			 * within the register.

 Handle multiple unicast addresses (perfect filtering) */

		/* Switch to promiscuous mode if more than unicast

		 * addresses are requested than supported by hardware.

 Enable Receive all mode (to debug filtering_fail errors) */

	/* Set flow such that DZPQ in Mac Register 6 is 0,

	 * and unicast pause detect is enabled.

 RGMII or SMII interface */

 Check the link status */

 Discard masked bits */

 Not used events (e.g. MMC interrupts) are not handled. */

 clear the PMT bits 5 and 6 by reading the PMT status reg */

 MAC tx/rx EEE LPI entry/exit interrupts */

 Clean LPI interrupt by reading the Reg 12 */

TODO - en_tx_lpi_clockgating treatment */

	/* Enable the link status receive on RGMII, SGMII ore SMII

	 * receive path and instruct the transmit to enter in LPI

	 * state.

	/* Program the timers in the LPI timer control register:

	 * LS: minimum time (ms) for which the link

	 *  status from PHY should be ok before transmitting

	 *  the LPI pattern.

	 * TW: minimum time (us) for which the core waits

	 *  after it has stopped transmitting the LPI pattern.

 SPDX-License-Identifier: (GPL-2.0 OR MIT)

/*

 * Copyright (c) 2018 Synopsys, Inc. and/or its affiliates.

 * stmmac TC Handling (HW only)

 Reset HW values */

 Accept */

 Drop */

 Unsupported */

 Only 1 match per entry */

 Set entry and fragments as not used */

 Fail silently as we can still use remaining features, e.g. CBS */

 Reserve one last filter which lets all pass */

 Queue 0 is not AVB capable */

 Port Transmit Rate and Speed Divider */

 Final adjustments for HW */

 Nothing to do, maybe inverse filter ? */

 Nothing to do here */

 Nothing to do here */

 Nothing to do here */

 Nothing to do here */

 Nothing to do here */

 When RSS is enabled, the filtering will be bypassed */

 Adjust for real system time */

	/* Actual FPE register configuration will be done after FPE handshake

	 * is success.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Synopsys DWC Ethernet Quality-of-Service v4.10a linux driver

 *

 * Copyright (C) 2016 Joao Pinto <jpinto@synopsys.com>

		/**

		 * Since the register has a reset value of 1, if property

		 * is missing, default to 1.

		/**

		 * If property exists, to keep the behavior from dwc_eth_qos,

		 * subtract one after parsing.

		/**

		 * Since the register has a reset value of 1, if property

		 * is missing, default to 1.

		/**

		 * If property exists, to keep the behavior from dwc_eth_qos,

		 * subtract one after parsing.

 converts burst-map bitmask to burst array */

 dwc-qos needs GMAC4, AAL, TSO and PMT */

 calibrate */

 MDIO bus was already reset just above */

	/**

	 * Since stmmac_platform supports name IRQ only, basic platform

	 * resource initialization is done in the glue logic.

 SPDX-License-Identifier: GPL-2.0

/* Copyright (c) 2020, Loongson Corporation

 clk_csr_i = 20-35MHz & MDC = clk_csr_i/16 */

 Set default value for multicast hash bins */

 Set default value for unicast filter entries */

 Set the maxmtu to a default of JUMBO_LEN */

 Set default number of RX and TX queues to use */

 Disable Priority config by default */

 Disable RX queues routing by default */

 Default to phy auto-detection */

 Enable pci device */

 Get the base address of device */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * This contains the functions to handle the descriptors for DesignWare databook

 * 4.xx.

 *

 * Copyright (C) 2015  STMicroelectronics Ltd

 *

 * Author: Alexandre Torgue <alexandre.torgue@st.com>

 Get tx owner first */

 Verify tx error by looking at the last segment. */

 Context type from W/B descriptor must be zero */

 Tx Timestamp Status is 1 so des0 and des1'll have valid values */

 convert high/sec time stamp value to nanosecond */

 Corrupted value */

 A valid Timestamp is ready to be read */

 Timestamp not ready */

 Get the status from normal w/b descriptor */

 Check if timestamp is OK from context descriptor */

 Finally set the OWN bit. Later the DMA will start! */

		/* When the own bit, for the first frame, has to be set, all

		 * descriptors for the same frame has to be set before, to

		 * avoid race condition.

 Finally set the OWN bit. Later the DMA will start! */

		/* When the own bit, for the first frame, has to be set, all

		 * descriptors for the same frame has to be set before, to

		 * avoid race condition.

 Inner VLAN */

 Outer VLAN */

 SPDX-License-Identifier: GPL-2.0-only

/* Ethtool support for Altera Triple-Speed Ethernet MAC driver

 * Copyright (C) 2008-2014 Altera Corporation. All rights reserved

 *

 * Contributors:

 *   Dalon Westergreen

 *   Thomas Chou

 *   Ian Abbott

 *   Yuriy Kozlov

 *   Tobias Klauser

 *   Andriy Smolskyy

 *   Roman Bulgakov

 *   Dmytro Mytarchuk

 *

 * Original driver contributed by SLS.

 * Major updates contributed by GlobalLogic

/* Fill in a buffer with the strings which correspond to the

 * stats

 Extended aOctetsTransmittedOK counter */

 Extended aOctetsReceivedOK counter */

 Extended etherStatsOctets counter */

	/* Set version to a known value, so ethtool knows

	 * how to do any special formatting of this data.

	 * This version number will need to change if and

	 * when this register table is changed.

	 *

	 * version[31:0] = 1: Dump the first 128 TSE Registers

	 *      Upper bits are all 0 by default

	 *

	 * Upper 16-bits will indicate feature presence for

	 * Ethtool register decoding in future version.

 SPDX-License-Identifier: GPL-2.0-only

/* Altera Triple-Speed Ethernet MAC driver

 * Copyright (C) 2008-2014 Altera Corporation. All rights reserved

 *

 * Contributors:

 *   Dalon Westergreen

 *   Thomas Chou

 *   Ian Abbott

 *   Yuriy Kozlov

 *   Tobias Klauser

 *   Andriy Smolskyy

 *   Roman Bulgakov

 *   Dmytro Mytarchuk

 *   Matthew Gerlach

 *

 * Original driver contributed by SLS.

 * Major updates contributed by GlobalLogic

 Module parameters */

/* Make sure DMA buffer size is larger than the max frame size

 * plus some alignment offset and a VLAN header. If the max frame size is

 * 1518, a VLAN header would be additional 4 bytes and additional

 * headroom for alignment is 2 bytes, 2048 is just fine.

/* Allow network stack to resume queueing packets after we've

 * finished transmitting at least 1/4 of the packets in the queue.

/* PCS Register read/write functions

 Check PCS scratch memory */

/* MDIO specific functions

 set MDIO address */

 get the data */

 set MDIO address */

 write the data */

/* Unmap and free Tx buffer resources

 Create Rx ring buffer */

 Create Tx ring buffer */

 Init Rx ring */

 Release the DMA TX/RX socket buffers */

/* Reallocate the skb for the reception process

/* Pull out the VLAN tag and fix up the packet

/* Receive a packet: retrieve and pass over to upper levels

	/* Check for count < limit first as get_rx_status is changing

	* the response-fifo so we must process the next packet

	* after calling get_rx_status if a response is pending.

	* (reading the last byte of the response pops the value from the fifo.)

		/* DMA trasfer from TSE starts with 2 aditional bytes for

		 * IP payload alignment. Status returned by get_rx_status()

		 * contains DMA transfer length. Packet is 2 bytes shorter.

/* Reclaim resources after transmission completes

 Free sent buffers */

/* NAPI polling function

/* DMA TX & RX FIFO interrupt routing

 reset IRQs */

/* Transmit a packet (called by the kernel). Dispatches

 * either the SGDMA method for transmitting or the

 * MSGDMA method, assumes no scatter/gather support,

 * implying an assumption that there's only one

 * physically contiguous fragment starting at

 * skb->data, for length of skb_headlen(skb).

 This is a hard error, log it. */

 Map the first skb fragment */

/* Called every time the controller might need to be made

 * aware of new link state.  The PHY code conveys this

 * information through variables in the phydev structure, and this

 * function converts those variables into the appropriate

 * register values, and can bring down the device if needed.

 only change config if there is a link */

 Read old config */

 Check duplex */

 Check speed */

 Avoid get phy addr and create mdio if no phy is present */

	/* try to get PHY address from device tree, use PHY autodetection if

	 * no valid address is given

 Create/attach to MDIO bus */

/* Initialize driver's PHY state, and attach to the PHY

 Avoid init phy in case of no phy present */

 check if a fixed-link is defined in device-tree */

			/* In the case of a fixed PHY, the DT node associated

			 * to the PHY is the Ethernet MAC DT node.

	/* Stop Advertising 1000BASE Capability if interface is not GMII

	/* Broken HW is sometimes missing the pull-up resistor on the

	 * MDIO line, which results in reads to non-existent devices returning

	 * 0 rather than 0xffff. Catch this here and treat 0 as a non-existent

	 * device as well. If a fixed-link is used the phy_id is always 0.

	 * Note: phydev->phy_id is the result of reading the UID PHY registers.

 Set primary MAC address */

/* MAC software reset.

 * When reset is triggered, the MAC function completes the current

 * transmission or reception, and subsequently disables the transmit and

 * receive logic, flushes the receive FIFO buffer, and resets the statistics

 * counters.

/* Initialize MAC core registers

 Setup Rx FIFO */

 Setup Tx FIFO */

 MAC Address Configuration */

 MAC Function Configuration */

	/* Disable RX/TX shift 16 for alignment of all received frames on 16-bit

	 * start address

 Set the MAC options */

 No padding Removal on Receive */

 CRC Removal */

	cmd |= MAC_CMDCFG_RX_ERR_DISC;	/* Automatically discard frames

					 * with CRC errors

 Default speed and duplex setting, full/100 */

/* Start/stop MAC transmission logic

/* Change the MTU

 clear the hash filter */

 set the hash filter */

/* Set or clear the multicast filter for this adaptor

/* Set or clear the multicast filter for this adaptor

/* Initialise (if necessary) the SGMII PCS component

 Nothing to do, not in SGMII mode */

	/* The TSE SGMII PCS block looks a little like a PHY, it is

	 * mapped into the zeroth MDIO space of the MAC and it has

	 * ID registers like a PHY would.  Sadly this is often

	 * configured to zeroes, so don't be surprised if it does

	 * show 0x00000000.

	/* Starting on page 5-29 of the MegaCore Function User Guide

	 * Set SGMII Link timer to 1.6ms

 Enable SGMII Interface and Enable SGMII Auto Negotiation */

 Enable Autonegotiation */

 Reset PCS block */

 We failed to reset the block, return a timeout */

/* Open and initialize the interface

 Reset and configure TSE MAC and probe associated PHY */

 no-op if MAC not operating in SGMII mode*/

	/* Note that reset_mac will fail if the clocks are gated by the PHY

	 * due to the PHY being put into isolation or power down mode.

	 * This is not an error if reset fails due to no clock.

 Create and initialize the TX/RX descriptors chains. */

 Register RX interrupt */

 Register TX interrupt */

 Enable DMA interrupts */

 Setup RX descriptor chain */

 Start MAC Rx/Tx */

/* Stop TSE MAC interface and put the device in an inactive state

 Stop the PHY */

 Disable DMA interrupts */

 Free the IRQ lines */

 disable and reset the MAC, empties fifo */

	/* Note that reset_mac will fail if the clocks are gated by the PHY

	 * due to the PHY being put into isolation or power down mode.

	 * This is not an error if reset fails due to no clock.

/* Probe Altera TSE MAC device

 Get the mapped address to the SGDMA descriptor memory */

 Start of that memory is for transmit descriptors */

 First half is for tx descriptors, other half for tx */

 MAC address space */

 xSGDMA Rx Dispatcher address space */

 xSGDMA Tx Dispatcher address space */

 Rx IRQ */

 Tx IRQ */

 get FIFO depths from device tree */

 get hash filter settings for this instance */

	/* Set hash filter to not set for now until the

	 * multicast filter receive issue is debugged

 get supplemental address settings for this instance */

 Max MTU is 1500, ETH_DATA_LEN */

	/* Get the max mtu from the device tree. Note that the

	 * "max-frame-size" parameter is actually max mtu. Definition

	 * in the ePAPR v1.1 spec and usage differ, so go with usage.

	/* The DMA buffer size already accounts for an alignment bias

	 * to avoid unaligned access exceptions for the NIOS processor,

 get default MAC address from device tree */

 get phy addr and create mdio */

 initialize netdev */

	/* Scatter/gather IO is not supported,

	 * so it is turned off

	/* VLAN offloading of tagging, stripping and filtering is not

	 * supported by hardware, but driver will accommodate the

	 * extra 4-byte VLAN tag for processing by upper layers

 setup NAPI interface */

/* Remove Altera TSE MAC device

 SPDX-License-Identifier: GPL-2.0-only

/* Altera TSE SGDMA and MSGDMA Linux driver

 * Copyright (C) 2014 Altera Corporation. All rights reserved

 SPDX-License-Identifier: GPL-2.0-only

/* Altera TSE SGDMA and MSGDMA Linux driver

 * Copyright (C) 2014 Altera Corporation. All rights reserved

 Initialize descriptor memory to all 0's, sync memory to cache */

/* This function resets the SGDMA controller and clears the

 * descriptor memory used for transmits and receives.

 Initialize descriptor memory to 0 */

/* For SGDMA, interrupts remain enabled after initially enabling,

 * so no need to provide implementations for abstract enable

 * and disable

/* transmits buffer through SGDMA. Returns number of buffers

 * transmitted, 0 if not possible.

 *

 * tx_lock is held by the caller

 wait 'til the tx sgdma is ready for the next transmit request */

 current descriptor */

 next descriptor */

 address of packet to xmit */

 write addr 0 for tx dma */

 length of packet */

 Generate EOP */

 read fixed */

 Generate SOP */

 enqueue the request to the pending transmit queue */

/* tx_lock held to protect access to queued tx list

/* status is returned on upper 16 bits,

 * length is returned in lower 16 bits

 Clear control */

 clear status */

 kick the rx sgdma after reaping this descriptor */

			/* If the SGDMA indicated an end of packet on recv,

			 * then it's expected that the rxstatus from the

			 * descriptor is non-zero - meaning a valid packet

			 * with a nonzero length, or an error has been

			 * indicated. if not, then all we can do is signal

			 * an error and return no packet received. Most likely

			 * there is a system design error, or an error in the

			 * underlying kernel (cache or cache management problem)

 Private functions */

 Clear the next descriptor as not owned by hardware */

 Channel is implicitly zero, initialized to 0 by default */

/* If hardware is busy, don't restart async read.

 * if status register is 0 - meaning initial state, restart async read,

 * probably for the first time when populating a receive buffer.

 * If read status indicate not busy and a status, restart the async

 * DMA read.

 current descriptor */

 next descriptor */

 read addr 0 for rx dma */

 write addr for rx dma */

 read 'til EOP */

 EOP: NA for rx dma */

 read fixed: NA for rx dma */

 SOP: NA for rx DMA */

 clear control and status */

/* adds a tse_buffer to the tail of a tx buffer list.

 * assumes the caller is managing and holding a mutual exclusion

 * primitive to avoid simultaneous pushes/pops to the list.

/* adds a tse_buffer to the tail of a rx buffer list

 * assumes the caller is managing and holding a mutual exclusion

 * primitive to avoid simultaneous pushes/pops to the list.

/* dequeues a tse_buffer from the transmit buffer list, otherwise

 * returns NULL if empty.

 * assumes the caller is managing and holding a mutual exclusion

 * primitive to avoid simultaneous pushes/pops to the list.

/* dequeues a tse_buffer from the receive buffer list, otherwise

 * returns NULL if empty

 * assumes the caller is managing and holding a mutual exclusion

 * primitive to avoid simultaneous pushes/pops to the list.

/* dequeues a tse_buffer from the receive buffer list, otherwise

 * returns NULL if empty

 * assumes the caller is managing and holding a mutual exclusion

 * primitive to avoid simultaneous pushes/pops to the list while the

 * head is being examined.

/* check and return rx sgdma status without polling

/* waits for the tx sgdma to finish it's current operation, returns 0

 * when it transitions to nonbusy, returns 1 if the operation times out

 if DMA is busy, wait for current transactino to finish */

 SPDX-License-Identifier: GPL-2.0-only

/* Altera TSE SGDMA and MSGDMA Linux driver

 * Copyright (C) 2014 Altera Corporation. All rights reserved

 No initialization work to do for MSGDMA */

 Reset Rx mSGDMA */

 clear all status bits */

 Reset Tx mSGDMA */

 clear all status bits */

 return 0 to indicate transmit is pending */

 Get number of sent descriptors */

 Tx FIFO is not empty */

 Check for buffered last packet */

/* Put buffer to the mSGDMA RX FIFO

/* status is returned on upper 16 bits,

 * length is returned in lower 16 bits

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2012-2013 Solarflare Communications Inc.

 Hardware control for EF10 architecture including 'Huntington'. */

 VLAN list entry */

/* On all EF10s up to and including SFC9220 (Medford1), all PFs use BAR 0 for

 * I/O space and BAR 2(&3) for memory.  On SFC9250 (Medford2), there is no I/O

 * bar; PFs use BAR 0/1 for memory.

 SFC9250 PF */

 All VFs use BAR 0/1 for memory */

	/* record the DPCPU firmware IDs to determine VEB vswitching support.

 keep default VI stride */

 leave num_mac_stats as the default value, MC_CMD_MAC_NSTATS */

 Firmware without GET_WORKAROUNDS - not a problem. */

 Bug61265 workaround is always enabled if implemented. */

			/* Workaround is implemented but not enabled.

			 * Try to enable it.

 If we failed to set the workaround just carry on. */

 Not available - fall back to Huntington defaults. */

 1536 cycles */

		/* We add VID 0 on init. 8021q adds it on module init

		 * for all interfaces with VLAN filtring feature.

	/* 8021q removes VID 0 on module unload for all interfaces

	 * with VLAN filtering feature. We need to keep it to receive

	 * untagged traffic.

 we assume later that we can copy from this buffer in dwords */

	/* Get the MC's warm boot count.  In case it's rebooting right

	 * now, be prepared to retry.

	/* In case we're recovering from a crash (kexec), we want to

	 * cancel any outstanding request by the previous user of this

	 * function.  We send a special message using the least

	 * significant bits of the 'high' (doorbell) register.

 Reset (most) configuration for this function */

 Enable event logging */

	/* We can have one VI for each vi_stride-byte region.

	 * However, until we use TX option descriptors we need up to four

	 * TX queues per channel for different checksumming combinations.

 Add unspecified VID to support VLAN filtering being disabled */

	/* If VLAN filtering is enabled, we need VID 0 to get untagged

	 * traffic.  It is added automatically if 8021q module is loaded,

	 * but we can't rely on it since module may be not loaded.

			/* Don't display the MC error if we didn't have space

			 * for a VF.

 Link a buffer to each VI in the write-combining mapping */

 Link a buffer to each TX queue */

		/* Extra channels, even those with TXQs (PTP), do not require

		 * PIO resources.

			/* We assign the PIO buffers to queues in

			 * reverse order to allow for the following

			 * special case.

			/* When the host page size is 4K, the first

			 * host page in the WC mapping may be within

			 * the same VI page as the last TX queue.  We

			 * can only link one buffer to each VI.

				/* This is non-fatal; the TX path just

				 * won't use PIO for this queue

	/* inbuf was defined for MC_CMD_LINK_PIOBUF.  We can use the same

	 * buffer for MC_CMD_UNLINK_PIOBUF because it's shorter.

 All our existing PIO buffers went away */

 !EFX_USE_PIO */

 EFX_USE_PIO */

	/* If the parent PF has no VF data structure, it doesn't know about this

	 * VF so fail probe.  The VF needs to be re-created.  This can happen

	 * if the PF driver was unloaded while any VF was assigned to a guest

	 * (using Xen, only).

/* Note that the failure path of this function does not free

 * resources, as this will be done by efx_ef10_remove().

	/* Try to allocate PIO buffers if wanted and if the full

	 * number of PIO buffers would be sufficient to allocate one

	 * copy-buffer per TX channel.  Failure is non-fatal, as there

	 * are only a small number of PIO buffers shared between all

	 * functions of the controller.

	/* PIO buffers should be mapped with write-combining enabled,

	 * and we want to make single UC and WC mappings rather than

	 * several of each (in fact that's the only option if host

	 * page size is >4K).  So we may allocate some extra VIs just

	 * for writing PIO buffers through.

	 *

	 * The UC mapping contains (channel_vis - 1) complete VIs and the

	 * first 4K of the next VI.  Then the WC mapping begins with

	 * the remainder of this last VI.

		/* pio_write_vi_base rounds down to give the number of complete

		 * VIs inside the UC mapping.

 In case the last attached driver failed to free VIs, do it now */

		/* We didn't get the VIs to populate our channels.

		 * We could keep what we got but then we'd have more

		 * interrupts than we need.

		 * Instead calculate new max_channels and restart

	/* If we didn't get enough VIs to map all the PIO buffers, free the

	 * PIO buffers

 Shrink the original UC mapping of the memory BAR */

 Set up the WC mapping if needed */

 We cannot let the number of VIs change now */

		/* Log an error on failure, but this is non-fatal.

		 * Permission errors are less important - we've presumably

		 * had the PIO buffer licence removed.

 add encapsulated checksum offload features */

 add encapsulated TSO features */

 don't fail init if RSS setup doesn't work */

 All our allocations have been reset */

 Driver-created vswitches and vports must be re-created */

	/* We assume for now that our PCI function is permitted to

	 * reset everything.

 no invisible reset implemented */

	/* Unprivileged functions return -EPERM, but need to return success

	 * here so that the datapath is brought back up.

	/* If it was a port reset, trigger reallocation of MC resources.

	 * Note that on an MC reset nothing needs to be done now because we'll

	 * detect the MC reset later and handle it then.

	 * For an FLR, we never get an MC reset event, but the MC has reset all

	 * resources assigned to us, so we have to trigger reallocation now.

/* On 7000 series NICs, these statistics are only provided by the 10G MAC.

 * For a 10G/40G switchable port we do not expose these because they might

 * not include all the packets they should.

 * On 8000 series NICs these statistics are always provided.

/* These statistics are only provided by the 40G MAC.  For a 10G/40G

 * switchable port we do expose these because the errors will otherwise

 * be silent.

/* These statistics are only provided if the firmware supports the

 * capability PM_AND_RXDP_COUNTERS.

/* These statistics are only provided if the NIC supports MC_CMD_MAC_STATS_V2,

 * indicated by returning a value >= MC_CMD_MAC_NSTATS_V2 in

 * MC_CMD_GET_CAPABILITIES_V4_OUT_MAC_STATS_NUM_STATS.

 * These bits are in the second u64 of the raw mask.

/* These statistics are only provided if the NIC supports MC_CMD_MAC_STATS_V3,

 * indicated by returning a value >= MC_CMD_MAC_NSTATS_V3 in

 * MC_CMD_GET_CAPABILITIES_V4_OUT_MAC_STATS_NUM_STATS.

 * These bits are in the second u64 of the raw mask.

 8000 series have everything even at 40G */

 Only show vadaptor stats when EVB capability is present */

 Only show FEC stats when NIC supports MC_CMD_MAC_STATS_V2 */

	/* CTPIO stats appear in V3. Only show them on devices that actually

	 * support CTPIO. Although this driver doesn't use CTPIO others might,

	 * and we may be reporting the stats for the underlying port.

 Use vadaptor stats. */

 Use port stats. */

 Update derived statistics */

	/* MC Firmware reads RX_BYTES and RX_GOOD_BYTES from the MAC.

	 * It then calculates RX_BAD_BYTES and DMAs it to us with RX_BYTES.

	 * We report these as port_rx_ stats. We are not given RX_GOOD_BYTES.

	 * Here we calculate port_rx_good_bytes.

	/* The asynchronous reads used to calculate RX_BAD_BYTES in

	 * MC Firmware are done such that we should not see an increase in

	 * RX_BAD_BYTES when a good packet has arrived. Unfortunately this

	 * does mean that the stat can decrease at times. Here we do not

	 * update the stat unless it has increased or has gone to zero

	 * (In the case of the NIC rebooting).

	 * Please see Bug 33781 for a discussion of why things work this way.

 Expect ENOENT if DMA queues have not been set up */

	/* In atomic context, cannot update HW stats.  Just update the

	 * software stats and return so the caller can continue.

	/* The hardware provides 'low' and 'high' (doorbell) registers

	 * for passing the 64-bit address of an MCDI request to

	 * firmware.  However the dwords are swapped by firmware.  The

	 * least significant bits of the doorbell are then 0 for all

	 * MCDI requests due to alignment.

 All our allocations have been reset */

 The datapath firmware might have been changed */

	/* MAC statistics have been cleared on the NIC; clear the local

	 * statistic that we update with efx_update_diff_stat().

		/* The firmware is presumably in the process of

		 * rebooting.  However, we are supposed to report each

		 * reboot just once, so we must only do that once we

		 * can read and store the updated warm boot count.

/* Handle an MSI interrupt

 *

 * Handle an MSI hardware interrupt.  This routine schedules event

 * queue processing.  No interrupt acknowledgement cycle is necessary.

 * Also, we never need to check that the interrupt is for us, since

 * MSI interrupts cannot be shared.

 Note test interrupts */

 Schedule processing of the channel */

 Read the ISR which also ACKs the interrupts */

 Note test interrupts */

 low two bits of label are what we want for type */

 This writes to the TX_DESC_WPTR and also pushes data */

/* Add Firmware-Assisted TSO v2 option descriptors to a queue.

	/* 8000-series EF10 hardware requires that IP Total Length be

	 * greater than or equal to the value it will have in each segment

	 * (which is at most mss + 208 + TCP header length), but also less

	 * than (0x10000 - inner_network_header).  Otherwise the TCP

	 * checksum calculation will be broken for encapsulated packets.

	 * We fill in ip->tot_len with 0xff30, which should satisfy the

	 * first requirement unless the MSS is ridiculously large (which

	 * should be impossible as the driver max MTU is 9216); it is

	 * guaranteed to satisfy the second as we only attempt TSO if

	 * inner_network_header <= 208.

	/* Only attempt to enable TX timestamping if we have the license for it,

	 * otherwise TXQ init will fail

 Disable sync events on this channel. */

	/* TSOv2 is a limited resource that can only be configured on a limited

	 * number of queues. TSO without checksum offload is not really a thing,

	 * so we only enable it for those queues.

	 * TSOv2 cannot be used with Hardware timestamping, and is never needed

	 * for XDP tx.

	/* A previous user of this TX queue might have set us up the

	 * bomb by writing a descriptor to the TX push collector but

	 * not the doorbell.  (Each collector belongs to a port, not a

	 * queue or function, so cannot easily be reset.)  We must

	 * attempt to push a no-op descriptor in its place.

 This writes to the TX_DESC_WPTR; write pointer for TX descriptor ring */

		/* If we need to break across multiple descriptors we should

		 * stop at a page boundary. This assumes the length limit is

		 * greater than the page size.

 Create TX descriptor ring entry */

 PIO descriptor */

 Ensure descriptors are written before they are fetched */

		/* GET_WORKAROUNDS was implemented before this workaround,

		 * thus it must be unavailable in this firmware.

				/* With MCFW v4.6.x and earlier, the

				 * boot count will have incremented,

				 * so re-read the warm_boot_count

				 * value now to ensure this function

				 * doesn't think it has changed next

				 * time it checks.

 This creates an entry in the RX descriptor queue */

 Firmware requires that RX_DESC_WPTR be a multiple of 8 */

	/* MCDI_SET_QWORD is not appropriate here since EFX_POPULATE_* has

	 * already swapped the data to little-endian order.

 nothing to do */

 partially received RX was aborted. clean up. */

 No error bits were recognised */

 Basic packet information */

 detect rx abort */

		/* Check that RX completion merging is valid, i.e.

		 * the current firmware supports it and this is a

		 * non-scattered packet.

 Merged completion for multiple non-scattered packets */

 VxLAN or GENEVE */

 outer UDP csum */

 inner L4 */

 Handle received packet(s) */

 Get the transmit queue */

 Transmit completion */

	/* Transmit timestamps are only available for 8XXX series. They result

	 * in up to three events per packet. These occur in order, and are:

	 *  - the normal completion event (may be omitted)

	 *  - the low part of the timestamp

	 *  - the high part of the timestamp

	 *

	 * It's possible for multiple completion events to appear before the

	 * corresponding timestamps. So we can for example get:

	 *  COMP N

	 *  COMP N+1

	 *  TS_LO N

	 *  TS_HI N

	 *  TS_LO N+1

	 *  TS_HI N+1

	 *

	 * In addition it's also possible for the adjacent completions to be

	 * merged, so we may not see COMP N above. As such, the completion

	 * events are not very useful here.

	 *

	 * Each part of the timestamp is itself split across two 16 bit

	 * fields in the event.

 Ignore this event - see above. */

 event queue init complete. ok. */

		/* The queue must be empty, so we won't receive any rx

		 * events, so efx_process_channel() won't refill the

		 * queue. Refill it here

				/* XXX can we split a merged event to

				 * avoid going over-quota?

	/* MCDI_SET_QWORD is not appropriate here since EFX_POPULATE_* has

	 * already swapped the data to little-endian order.

 Only reconfigure a PF-created vport */

 Failed to add original MAC, so clear vport_mac */

 Switch to PF and change MAC address on vport */

			/* MAC address successfully changed by VF (with MAC

			 * spoofing) so update the parent PF if possible.

		/* If the active MCFW does not support MC_CMD_VADAPTOR_SET_MAC

		 * fall-back to the method of changing the MAC address on the

		 * vport.  This only applies to PFs because such versions of

		 * MCFW do not support VFs.

/* MC BISTs follow a different poll mechanism to phy BISTs.

 * The BIST is done in the poll handler on the MC, and the MCDI command

 * will block until the BIST is done.

 Hide protected partitions that don't provide defaults. */

 Protected partitions are read only. */

	/* If we've already exposed a partition of this type, hide this

	 * duplicate.  All operations on MTDs are keyed by the type anyway,

	 * so we can't act on the duplicate.

 sfc_status is read-only */

 CONFIG_SFC_MTD */

 if TX timestamping is still requested then leave PTP on */

/* We rely on the MCDI wiping out our TX rings if it made any changes to the

 * ports table, ensuring that any TSO descriptors that were made on a now-

 * removed tunnel port will be blown away and won't break things when we try

 * to transmit them using the new ports table.

		/* Most likely the MC rebooted due to another function also

		 * setting its tunnel port list. Mark the tunnel port list as

		 * dirty, so it will be pushed upon coming up from the reboot.

 expected not available on unprivileged functions */

			/* Delay for the MC reset to complete. This will make

			 * unloading other functions a bit smoother. This is a

			 * race, but the other unload will work whichever way

			 * it goes, this just avoids an unnecessary error

			 * message.

		/* The caller will have detached, relying on the MC reset to

		 * trigger a re-attach.  Since there won't be an MC reset, we

		 * have to do the attach ourselves.

		/* Make sure all TX are stopped while we modify the table, else

		 * we might race against an efx_features_check().

	/* Make sure all TX are stopped while we add to the table, else we

	 * might race against an efx_features_check().

/* Called under the TX lock with the TX queue running, hence no-one can be

 * in the middle of updating the UDP tunnels table.  However, they could

 * have tried and failed the MCDI, in which case they'll have set the dirty

 * flag before dropping their locks.

		/* SW table may not match HW state, so just assume we can't

		 * use any UDP tunnel offloads.

	/* Make sure all TX are stopped while we remove from the table, else we

	 * might race against an efx_features_check().

/* EF10 may have multiple datapath firmware variants within a

 * single version.  Report which variants are running.

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2008-2013 Solarflare Communications Inc.

/**************************************************************************

 *

 * Management-Controller-to-Driver Interface

 *

 **************************************************************************

/* A reboot/assertion causes the MCDI status word to be set after the

 * command word is set or a REBOOT event is sent. If we notice a reboot

 * via these mechanisms then wait 250ms for the status word to be set.

 followed by request/response buffer */

 consuming code assumes buffer is page-sized */

 Recover from a failed assertion before probing */

	/* Let the MC (and BMC, if this is a LOM) know that the driver

	 * is loaded. We should do this before we reset the NIC.

 Not a fatal error */

 Relinquish the device (back to the BMC, if this is a LOM) */

 page-sized */

 Serialise with efx_mcdi_ev_cpl() and efx_mcdi_ev_death() */

 MCDI v1 */

 MCDI v2 */

		/* Lengths should always be a whole number of dwords, so scream

		 * if they're not.

		/* We own the logging buffer, as only one MCDI can be in

		 * progress on a NIC at any one time.  So no need for locking.

 page-sized */

		/* MCDI_DECLARE_BUF ensures that underlying buffer is padded

		 * to dword size, and the MCDI buffer is always dword size

		/* We own the logging buffer, as only one MCDI can be in

		 * progress on a NIC at any one time.  So no need for locking.

 Check for a reboot atomically with respect to efx_mcdi_copyout() */

	/* Poll for completion. Poll quickly (once a us) for the 1st jiffy,

	 * because generally mcdi responses are fast. After that, back off

	 * and poll once a jiffy (approximately)

 Return rc=0 like wait_event_timeout() */

/* Test and clear MC-rebooted flag for this port/function; reset

 * software state as necessary.

	/* Wait until the interface becomes QUIESCENT and we win the race

	 * to mark it RUNNING_SYNC.

	/* Check if efx_mcdi_set_mode() switched us back to polled completions.

	 * In which case, poll for completions directly. If efx_mcdi_ev_cpl()

	 * completed the request first, then we'll just end up completing the

	 * request again, which is safe.

	 *

	 * We need an smp_rmb() to synchronise with efx_mcdi_mode_poll(), which

	 * wait_event_timeout() implicitly provides.

/* If the interface is RUNNING_SYNC, switch to COMPLETED and wake the

 * requester.  Return whether this was done.  Does not take any locks.

 Process the asynchronous request queue */

/* If the interface is RUNNING_ASYNC, switch to COMPLETED, call the

 * asynchronous completion function, and release the interface.

 * Return whether this was done.  Must be called in bh-disabled

 * context.  Will take iface_lock and async_lock.

		/* Ensure that if the completion event arrives later,

		 * the seqno check in efx_mcdi_ev_cpl() will fail

	/* Stop the timer.  In case the timer function is running, we

	 * must wait for it to return so that there is no possibility

	 * of it aborting the next request.

 The request has been cancelled */

 MCDI v2 responses don't fit in an event */

		/* If the interface isn't RUNNING_ASYNC or

		 * RUNNING_SYNC then we've received a duplicate

		 * completion after we've already transitioned back to

		 * QUIESCENT. [A subsequent invocation would increment

		 * seqno, so would have failed the seqno check].

		/* Close the race with efx_mcdi_ev_cpl() executing just too late

		 * and completing a request we've just cancelled, by ensuring

		 * that the seqno check therein fails.

		/* At the very least we need a memory barrier here to ensure

		 * we pick up changes from efx_mcdi_ev_cpl(). Protect against

		 * a spurious efx_mcdi_ev_cpl() running concurrently by

 Don't reset if MC_CMD_REBOOT returns EIO */

 Interrupt the proxy wait. */

	/* Ensure the status is written before we update the handle, since the

	 * latter is used to check if we've finished.

 Wait for a proxy event, or timeout. */

 Zero is an invalid proxy handle. */

 The input buffer can't be aliased with the output. */

		/* Handle proxy authorisation. This allows approval of MCDI

		 * operations to be delegated to the admin function, allowing

		 * fine control over (eg) multicast subscriptions.

 We now retry the original request. */

		/* If the EVB port isn't available within a VF this may

		 * mean the PF is still bringing the switch up. We should

		 * retry our request shortly.

/**

 * efx_mcdi_rpc - Issue an MCDI command and wait for completion

 * @efx: NIC through which to issue the command

 * @cmd: Command type number

 * @inbuf: Command parameters

 * @inlen: Length of command parameters, in bytes.  Must be a multiple

 *	of 4 and no greater than %MCDI_CTL_SDU_LEN_MAX_V1.

 * @outbuf: Response buffer.  May be %NULL if @outlen is 0.

 * @outlen: Length of response buffer, in bytes.  If the actual

 *	response is longer than @outlen & ~3, it will be truncated

 *	to that length.

 * @outlen_actual: Pointer through which to return the actual response

 *	length.  May be %NULL if this is not needed.

 *

 * This function may sleep and therefore must be called in an appropriate

 * context.

 *

 * Return: A negative error code, or zero if successful.  The error

 *	code may come from the MCDI response or may indicate a failure

 *	to communicate with the MC.  In the former case, the response

 *	will still be copied to @outbuf and *@outlen_actual will be

 *	set accordingly.  In the latter case, *@outlen_actual will be

 *	set to zero.

/* Normally, on receiving an error code in the MCDI response,

 * efx_mcdi_rpc will log an error message containing (among other

 * things) the raw error code, by means of efx_mcdi_display_error.

 * This _quiet version suppresses that; if the caller wishes to log

 * the error conditionally on the return code, it should call this

 * function and is then responsible for calling efx_mcdi_display_error

 * as needed.

		/* If this is at the front of the queue, try to start it

		 * immediately

/**

 * efx_mcdi_rpc_async - Schedule an MCDI command to run asynchronously

 * @efx: NIC through which to issue the command

 * @cmd: Command type number

 * @inbuf: Command parameters

 * @inlen: Length of command parameters, in bytes

 * @outlen: Length to allocate for response buffer, in bytes

 * @complete: Function to be called on completion or cancellation.

 * @cookie: Arbitrary value to be passed to @complete.

 *

 * This function does not sleep and therefore may be called in atomic

 * context.  It will fail if event queues are disabled or if MCDI

 * event completions have been disabled due to an error.

 *

 * If it succeeds, the @complete function will be called exactly once

 * in atomic context, when one of the following occurs:

 * (a) the completion event is received (in NAPI context)

 * (b) event queues are disabled (in the process that disables them)

 * (c) the request times-out (in timer context)

/* Switch to polled MCDI completions.  This can be called in various

 * error conditions with various locks held, so it must be lockless.

 * Caller is responsible for flushing asynchronous requests later.

	/* If already in polling mode, nothing to do.

	 * If in fail-fast state, don't switch to polled completion.

	 * FLR recovery will do that later.

	/* We can switch from event completion to polled completion, because

	 * mcdi requests are always completed in shared memory. We do this by

	 * switching the mode to POLL'd then completing the request.

	 * efx_mcdi_await_completion() will then call efx_mcdi_poll().

	 *

	 * We need an smp_wmb() to synchronise with efx_mcdi_await_completion(),

	 * which efx_mcdi_complete_sync() provides for us.

/* Flush any running or queued asynchronous requests, after event processing

 * is stopped

 We must be in poll or fail mode so no more requests can be queued */

	/* If a request is still running, make sure we give the MC

	 * time to complete it so that the response won't overwrite our

	 * next request.

	/* Nothing else will access the async list now, so it is safe

	 * to walk it without holding async_lock.  If we hold it while

	 * calling a completer then lockdep may warn that we have

	 * acquired locks in the wrong order.

	/* If already in event completion mode, nothing to do.

	 * If in fail-fast state, don't switch to event completion.  FLR

	 * recovery will do that later.

	/* We can't switch from polled to event completion in the middle of a

	 * request, because the completion method is specified in the request.

	 * So acquire the interface to serialise the requestors. We don't need

	 * to acquire the iface_lock to change the mode here, but we do need a

	 * write memory barrier ensure that efx_mcdi_rpc() sees it, which

	 * efx_mcdi_acquire() provides.

	/* If there is an outstanding MCDI request, it has been terminated

	 * either by a BADASSERT or REBOOT event. If the mcdi interface is

	 * in polled mode, then do nothing because the MC reboot handler will

	 * set the header correctly. However, if the mcdi interface is waiting

	 * for a CMDDONE event it won't receive it [and since all MCDI events

	 * are sent to the same queue, we can't be racing with

	 * efx_mcdi_ev_cpl()]

	 *

	 * If there is an outstanding asynchronous request, we can't

	 * complete it now (efx_mcdi_complete() would deadlock).  The

	 * reset process will take care of this.

	 *

	 * There's a race here with efx_mcdi_send_request(), because

	 * we might receive a REBOOT event *before* the request has

	 * been copied out. In polled mode (during startup) this is

	 * irrelevant, because efx_mcdi_complete_sync() is ignored. In

	 * event mode, this condition is just an edge-case of

	 * receiving a REBOOT event after posting the MCDI

	 * request. Did the mc reboot before or after the copyout? The

	 * best we can do always is just return failure.

	 *

	 * If there is an outstanding proxy response expected it is not going

	 * to arrive. We should thus abort it.

 Consume the status word since efx_mcdi_rpc_finish() won't */

		/* On EF10, a CODE_MC_REBOOT event can be received without the

		 * reboot detection in efx_mcdi_poll_reboot() being triggered.

		 * If zero was returned from the final call to

		 * efx_mcdi_poll_reboot(), the MC reboot wasn't noticed but the

		 * MC has definitely rebooted so prepare for the reset.

 Nobody was waiting for an MCDI request, so trigger a reset */

/* The MC is going down in to BIST mode. set the BIST flag to block

 * new MCDI, cancel any outstanding MCDI and and schedule a BIST-type reset

 * (which doesn't actually execute a reset, it waits for the controlling

 * function to reset it).

/* MCDI timeouts seen, so make all MCDI calls fail-fast and issue an FLR to try

 * to recover.

 it had already been done */

 Called from efx_farch_ev_process and efx_ef10_ev_process for MCDI events */

 MAC stats are gather lazily.  We can ignore this. */

		/* Two flush events will be sent: one to the same event

		 * queue as completions, and one to event queue 0.

		 * In the latter case the {RX,TX}_FLUSH_TO_DRIVER

		 * flag will be set, and we should ignore the event

		 * because we want to wait for all completions.

/**************************************************************************

 *

 * Specific request functions

 *

 **************************************************************************

	/* It's theoretically possible for the string to exceed 31

	 * characters, though in practice the first three version

	 * components are short enough that this doesn't happen.

	/* If we're not the primary PF, trying to ATTACH with a FIRMWARE_ID

	 * specified will fail with EPERM, and we have to tell the MC we don't

	 * care what firmware we get.

 Synthesise flags for Siena */

	/* We currently assume we have control of the external link

	 * and are completely trusted by firmware.  Abort probing

	 * if that's not true for this function.

 we need __aligned(2) for ether_addr_copy */

 This function finds types using the new NVRAM_PARTITIONS mcdi. */

 This function tests nvram partitions using the new mcdi partition lookup scheme */

 Require at least one check */

/* Returns 1 if an assertion was read, 0 if no assertion had fired,

 * negative on error.

	/* Attempt to read any stored assertion state before we reboot

	 * the mcfw out of the assertion handler. Retry twice, once

	 * because a boot-time assertion might cause this command to fail

	 * with EINTR. And once again because GET_ASSERTS can race with

 Print out any recorded assertion state */

 Print out the registers */

	/* If the MC is running debug firmware, it might now be

	 * waiting for a debugger to attach, but we just want it to

	 * reboot.  We set a flag that makes the command a no-op if it

	 * has already done so.

	 * The MCDI will thus return either 0 or -EIO.

 White is black, and up is down */

 If MCDI is down, we can't handle_assertion */

 Re-enable polled MCDI completion */

 Recover from a failed assertion pre-reset */

	/* Older firmware lacks GET_WORKAROUNDS and this isn't especially

	 * terrifying.  The call site will have to deal with it though.

 Always set this flag. Old firmware ignores it */

	/* The MCDI interface can in fact do multiple erase blocks at once;

	 * but erasing may be slow, so we make multiple calls here to avoid

 CONFIG_SFC_MTD */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2005-2015 Solarflare Communications Inc.

/* Efx legacy TCP segmentation acceleration.

 *

 * Utilises firmware support to go faster than GSO (but not as fast as TSOv2).

 *

 * Requires TX checksum offload support.

/**

 * struct tso_state - TSO state for an SKB

 * @out_len: Remaining length in current segment

 * @seqnum: Current sequence number

 * @ipv4_id: Current IPv4 ID, host endian

 * @packet_space: Remaining space in current packet

 * @dma_addr: DMA address of current position

 * @in_len: Remaining length in current SKB fragment

 * @unmap_len: Length of SKB fragment

 * @unmap_addr: DMA address of SKB fragment

 * @protocol: Network protocol (after any VLAN header)

 * @ip_off: Offset of IP header

 * @tcp_off: Offset of TCP header

 * @header_len: Number of bytes of header

 * @ip_base_len: IPv4 tot_len or IPv6 payload_len, before TCP payload

 * @header_dma_addr: Header DMA address

 * @header_unmap_len: Header DMA mapped length

 *

 * The state used during segmentation.  It is put into this data structure

 * just to make it easy to pass into inline functions.

 Output position */

 Input position */

/**

 * efx_tx_queue_insert - push descriptors onto the TX queue

 * @tx_queue:		Efx TX queue

 * @dma_addr:		DMA address of fragment

 * @len:		Length of fragment

 * @final_buffer:	The final buffer inserted into the queue

 *

 * Push descriptors onto the TX queue.

 If there's space for everything this is our last buffer. */

/*

 * Verify that our various assumptions about sk_buffs and the conditions

 * under which TSO will be attempted hold true.  Return the protocol number.

 Parse the SKB header and initialise state. */

/**

 * tso_fill_packet_with_fragment - form descriptors for the current fragment

 * @tx_queue:		Efx TX queue

 * @skb:		Socket buffer

 * @st:			TSO state

 *

 * Form descriptors for the current fragment, until we reach the end

 * of fragment or end-of-packet.

 Transfer ownership of the skb */

 Transfer ownership of the DMA mapping */

/**

 * tso_start_new_packet - generate a new header and prepare for the new packet

 * @tx_queue:		Efx TX queue

 * @skb:		Socket buffer

 * @st:			TSO state

 *

 * Generate a new header and prepare for the new packet.  Return 0 on

 * success, or -%ENOMEM if failed to alloc header, or other negative error.

 mask out FIN and PSH */

	/* Send the original headers with a TSO option descriptor

	 * in front

	/* We mapped the headers in tso_start().  Unmap them

	 * when the last segment is completed.

		/* Ensure we only unmap them once in case of a

		 * later DMA mapping error and rollback

 Linux leaves suitable gaps in the IP ID space for us to fill. */

/**

 * efx_enqueue_skb_tso - segment and transmit a TSO socket buffer

 * @tx_queue:		Efx TX queue

 * @skb:		Socket buffer

 * @data_mapped:        Did we map the data? Always set to true

 *                      by this on success.

 *

 * Context: You must hold netif_tx_lock() to call this function.

 *

 * Add socket buffer @skb to @tx_queue, doing TSO or return != 0 if

 * @skb was not enqueued.  @skb is consumed unless return value is

 * %EINVAL.

 Find the packet protocol and sanity-check it */

 Grab the first payload fragment. */

 Payload starts in the header area. */

 Move onto the next fragment? */

 End of payload reached. */

 Start at new packet? */

 Free the DMA mapping we were in the process of writing out */

 Free the header DMA mapping */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2006-2013 Solarflare Communications Inc.

 Hardware control for SFC9000 family including SFL9021 (aka Siena). */

	/* Reset the chip immediately so that it is completely

	 * quiescent regardless of what any VF driver does.

/**************************************************************************

 *

 * PTP

 *

 **************************************************************************

 if TX timestamping is still requested then leave PTP on */

		/* bug 33070 - old versions of the firmware do not support the

		 * improved UUID filtering option. Similarly old versions of the

		 * application do not expect it to be enabled. If the firmware

		 * does not accept the enhanced mode, fall back to the standard

/**************************************************************************

 *

 * Device reset

 *

 **************************************************************************

 no invisible reset implemented */

/* When a PCI device is isolated from the bus, a subsequent MMIO read is

 * required for the kernel EEH mechanisms to notice. As the Solarflare driver

 * was written to minimise MMIO read (for latency) then a periodic call to check

 * the EEH status of the device is required so that device recovery can happen

 * in a timely fashion.

 768 cycles */

	/* Each port has a small block of internal SRAM dedicated to

	 * the buffer table and descriptor caches.  In theory we can

	 * map both blocks to one port, but we don't.

/* On all Falcon-architecture NICs, PFs use BAR 0 for I/O space and BAR 2(&3)

 * for memory.

 Allocate storage for hardware specific data */

 Now we can reset the NIC */

 Allocate memory for INT_KER */

 Read in the non-volatile configuration */

	/* Read from IPv6 RSS key as that's longer (the IPv4 key is just the

	 * first 128 bits of the same key, assuming it's been set by

	 * siena_rx_push_rss_config, below)

 Set hash key for IPv4 */

 Enable IPv6 RSS */

/* This call performs hardware-specific global initialisation, such as

 * defining the descriptor cache sizes and number of RSS channels.

 * It does not set up any buffers, descriptor rings or event queues.

 Recover from a failed assertion post-reset */

 Squash TX of packets of 16 bytes or less */

	/* Do not enable TX_NO_EOP_DISC_EN, since it limits packets to 16

	 * descriptors (which is bad).

	/* Enable hash insertion. This is broken for the 'Falcon' hash

	 * if IPv6 hashing is also enabled, so also select Toeplitz

 indicates RSS is active */

 Enable event logging */

 Set destination of both TX and RX Flush events */

 Tear down the private nic state */

 Update derived statistics */

	/* If we're unlucky enough to read statistics wduring the DMA, wait

/**************************************************************************

 *

 * Wake on LAN

 *

 **************************************************************************

		/* If it failed, attempt to get into a synchronised

/**************************************************************************

 *

 * MCDI

 *

 **************************************************************************

 Ensure the request is written out before the doorbell */

 ring the doorbell with a distinctive value */

	/* All 1's indicates that shared memory is in reset (and is

	 * not a valid hdr). Wait for it to come out reset before

	 * completing the command

	/* MAC statistics have been cleared on the NIC; clear the local

	 * copies that we update with efx_update_diff_stat().

/**************************************************************************

 *

 * MTD

 *

 **************************************************************************

 hide it */

 CONFIG_SFC_MTD */

 Siena did not support MC_CMD_GET_CAPABILITIES */

/**************************************************************************

 *

 * Revision-dependent attributes used by efx.c and nic.c

 *

 **************************************************************************

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2015 Solarflare Communications Inc.

 Quietly try to allocate 2 VLAN tags */

 If 2 VLAN tags is too many, revert to trying with 1 VLAN tags */

 If VF is assigned, do not free the vport  */

/* On top of the default firmware vswitch setup, create a VEB vswitch and

 * expansion vport for use by this function.

 vswitch not needed as we have no VFs */

 No vswitch was ever created */

 Only free the vswitch if no VFs are assigned */

/* Disable SRIOV and remove VFs

 * If some VFs are attached to a guest (using Xen, only) nothing is

 * done if force=false, and vports are freed if force=true (for the non

 * attachedc ones, only) but SRIOV is not disabled and VFs are not

 * removed in either case.

		/* Remove any un-assigned orphaned VFs. This can happen if the PF driver

		 * was unloaded while any VF was assigned to a guest (using Xen, only).

 Disable SRIOV and remove any VFs in the host */

 VF cannot use the vport_id that the PF created */

 Do the actual vlan change */

 Restore everything in reverse order */

 Get privilege mask */

 Set privilege mask */

 Can't enable spoofchk if firmware doesn't support it. */

 don't care what old mode was */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2011-2013 Solarflare Communications Inc.

/* Theory of operation:

 *

 * PTP support is assisted by firmware running on the MC, which provides

 * the hardware timestamping capabilities.  Both transmitted and received

 * PTP event packets are queued onto internal queues for subsequent processing;

 * this is because the MC operations are relatively long and would block

 * block NAPI/interrupt operation.

 *

 * Receive event processing:

 *	The event contains the packet's UUID and sequence number, together

 *	with the hardware timestamp.  The PTP receive packet queue is searched

 *	for this UUID/sequence number and, if found, put on a pending queue.

 *	Packets not matching are delivered without timestamps (MCDI events will

 *	always arrive after the actual packet).

 *	It is important for the operation of the PTP protocol that the ordering

 *	of packets between the event and general port is maintained.

 *

 * Work queue processing:

 *	If work waiting, synchronise host/hardware time

 *

 *	Transmit: send packet through MC, which returns the transmission time

 *	that is converted to an appropriate timestamp.

 *

 *	Receive: the packet's reception time is converted to an appropriate

 *	timestamp.

 indirectly includes ptp.h */

 Maximum number of events expected to make up a PTP event */

 Maximum delay, ms, to begin synchronisation */

 How long, at most, to spend synchronising */

 How often to update the shared memory time */

 Minimum permitted length of a (corrected) synchronisation time */

 Maximum permitted length of a (corrected) synchronisation time */

 How many (MC) receive events that can be queued */

 Length of (modified) moving average. */

 How long an unmatched event or packet can be held */

/* Offsets into PTP packet for identification.  These offsets are from the

 * start of the IP header, not the MAC header.  Note that neither PTP V1 nor

 * PTP V2 permit the use of IPV4 options.

/* The minimum length of a PTP V1 packet for offsets, etc. to be valid:

 * includes IP header.

/* Although PTP V2 UUIDs are comprised a ClockIdentity (8) and PortNumber (2),

 * the MC only captures the last six bytes of the clock identity. These values

 * reflect those, not the ones used in the standard.  The standard permits

 * mapping of V1 UUIDs to V2 UUIDs with these same values.

/* The minimum length of a PTP V2 packet for offsets, etc. to be valid:

 * includes IP header.

 224.0.1.129 */

/* Annoyingly the format of the version numbers are different between

 * versions 1 and 2 so it isn't possible to simply look for 1 or 2.

/* NIC synchronised with single word of time only comprising

 * partial seconds and full nanoseconds: 10^9 ~ 2^30 so 2 bits for seconds.

 Maximum parts-per-billion adjustment that is acceptable */

 Precalculate scale word to avoid long long division at runtime */

 This is equivalent to 2^66 / 10^9. */

 How much to shift down after scaling to convert to FP40 */

 ... and FP44. */

/**

 * struct efx_ptp_match - Matching structure, stored in sk_buff's cb area.

 * @words: UUID and (partial) sequence number

 * @expiry: Time after which the packet should be delivered irrespective of

 *            event arrival.

 * @state: The state of the packet - whether it is ready for processing or

 *         whether that is of no interest.

/**

 * struct efx_ptp_event_rx - A PTP receive event (from MC)

 * @link: list of events

 * @seq0: First part of (PTP) UUID

 * @seq1: Second part of (PTP) UUID and sequence number

 * @hwtimestamp: Event timestamp

 * @expiry: Time which the packet arrived

/**

 * struct efx_ptp_timeset - Synchronisation between host and MC

 * @host_start: Host time immediately before hardware timestamp taken

 * @major: Hardware timestamp, major

 * @minor: Hardware timestamp, minor

 * @host_end: Host time immediately after hardware timestamp taken

 * @wait: Number of NIC clock ticks between hardware timestamp being read and

 *          host end time being seen

 * @window: Difference of host_end and host_start

 * @valid: Whether this timeset is valid

 Derived: end - start, allowing for wrap */

/**

 * struct efx_ptp_data - Precision Time Protocol (PTP) state

 * @efx: The NIC context

 * @channel: The PTP channel (Siena only)

 * @rx_ts_inline: Flag for whether RX timestamps are inline (else they are

 *	separate events)

 * @rxq: Receive SKB queue (awaiting timestamps)

 * @txq: Transmit SKB queue

 * @evt_list: List of MC receive events awaiting packets

 * @evt_free_list: List of free events

 * @evt_lock: Lock for manipulating evt_list and evt_free_list

 * @rx_evts: Instantiated events (on evt_list and evt_free_list)

 * @workwq: Work queue for processing pending PTP operations

 * @work: Work task

 * @reset_required: A serious error has occurred and the PTP task needs to be

 *                  reset (disable, enable).

 * @rxfilter_event: Receive filter when operating

 * @rxfilter_general: Receive filter when operating

 * @rxfilter_installed: Receive filter installed

 * @config: Current timestamp configuration

 * @enabled: PTP operation enabled

 * @mode: Mode in which PTP operating (PTP version)

 * @ns_to_nic_time: Function to convert from scalar nanoseconds to NIC time

 * @nic_to_kernel_time: Function to convert from NIC to kernel time

 * @nic_time: contains time details

 * @nic_time.minor_max: Wrap point for NIC minor times

 * @nic_time.sync_event_diff_min: Minimum acceptable difference between time

 * in packet prefix and last MCDI time sync event i.e. how much earlier than

 * the last sync event time a packet timestamp can be.

 * @nic_time.sync_event_diff_max: Maximum acceptable difference between time

 * in packet prefix and last MCDI time sync event i.e. how much later than

 * the last sync event time a packet timestamp can be.

 * @nic_time.sync_event_minor_shift: Shift required to make minor time from

 * field in MCDI time sync event.

 * @min_synchronisation_ns: Minimum acceptable corrected sync window

 * @capabilities: Capabilities flags from the NIC

 * @ts_corrections: contains corrections details

 * @ts_corrections.ptp_tx: Required driver correction of PTP packet transmit

 *                         timestamps

 * @ts_corrections.ptp_rx: Required driver correction of PTP packet receive

 *                         timestamps

 * @ts_corrections.pps_out: PPS output error (information only)

 * @ts_corrections.pps_in: Required driver correction of PPS input timestamps

 * @ts_corrections.general_tx: Required driver correction of general packet

 *                             transmit timestamps

 * @ts_corrections.general_rx: Required driver correction of general packet

 *                             receive timestamps

 * @evt_frags: Partly assembled PTP events

 * @evt_frag_idx: Current fragment number

 * @evt_code: Last event code

 * @start: Address at which MC indicates ready for synchronisation

 * @host_time_pps: Host time at last PPS

 * @adjfreq_ppb_shift: Shift required to convert scaled parts-per-billion

 * frequency adjustment into a fixed point fractional nanosecond format.

 * @current_adjfreq: Current ppb adjustment.

 * @phc_clock: Pointer to registered phc device (if primary function)

 * @phc_clock_info: Registration structure for phc device

 * @pps_work: pps work task for handling pps events

 * @pps_workwq: pps work queue

 * @nic_ts_enabled: Flag indicating if NIC generated TS events are handled

 * @txbuf: Buffer for use when transmitting (PTP) packets to MC (avoids

 *         allocations in main data path).

 * @good_syncs: Number of successful synchronisations.

 * @fast_syncs: Number of synchronisations requiring short delay

 * @bad_syncs: Number of failed synchronisations.

 * @sync_timeouts: Number of synchronisation timeouts

 * @no_time_syncs: Number of synchronisations with no good times.

 * @invalid_sync_windows: Number of sync windows with bad durations.

 * @undersize_sync_windows: Number of corrected sync windows that are too small

 * @oversize_sync_windows: Number of corrected sync windows that are too large

 * @rx_no_timestamp: Number of packets received without a timestamp.

 * @timeset: Last set of synchronisation statistics.

 * @xmit_skb: Transmit SKB function.

/* PTP 'extra' channel is still a traffic channel, but we only create TX queues

 * if PTP uses MAC TX timestamps, not if PTP uses the MC directly to transmit.

 Copy software statistics */

	/* Fetch MC statistics.  We *must* fill in all statistics or

	 * risk leaking kernel memory to userland, so if the MCDI

	 * request fails we pretend we got zeroes.

 For Siena platforms NIC time is s and ns */

/* To convert from s27 format to ns we multiply then divide by a power of 2.

 * For the conversion from ns to s27, the operation is also converted to a

 * multiply and shift.

/* For Huntington platforms NIC time is in seconds and fractions of a second

 * where the minor register only uses 27 bits in units of 2^-27s.

	/* The conversion can result in the minor value exceeding the maximum.

	 * In this case, round up to the next second.

 Apply the correction and deal with carry */

 For Medford2 platforms the time is in seconds and quarter nanoseconds. */

/* The 8000 series and later can provide the time from the MAC, which is only

 * 48 bits long and provides meta-information in the top 2 bits.

		/* Medford provides 48 bits of timestamp, so we must get the top

		 * 16 bits from the timesync event state.

		 *

		 * We only have the lower 16 bits of the time now, but we do

		 * have a full resolution timestamp at some point in past. As

		 * long as the difference between the (real) now and the sync

		 * is less than 2^15, then we can reconstruct the difference

		 * between those two numbers using only the lower 16 bits of

		 * each.

		 *

		 * Put another way

		 *

		 * a - b = ((a mod k) - b) mod k

		 *

		 * when -k/2 < (a-b) < k/2. In our case k is 2^16. We know

		 * (a mod k) and b, so can calculate the delta, a - b.

		 *

		/* Because delta is s16 this does an implicit mask down to

		 * 16 bits which is what we need, assuming

		 * MEDFORD_TX_SECS_EVENT_BITS is 16. delta is signed so that

		 * we can deal with the (unlikely) case of sync timestamps

		 * arriving from the future.

		/* Recover the fully specified time now, by applying the offset

		 * to the (fully specified) sync time.

 Get PTP attributes and set up time conversions */

	/* Get the PTP attributes. If the NIC doesn't support the operation we

	 * use the default format for compatibility with older NICs i.e.

	 * seconds and nanoseconds.

	/* Precalculate acceptable difference between the minor time in the

	 * packet prefix and the last MCDI time sync event. We expect the

	 * packet prefix timestamp to be after of sync event by up to one

	 * sync event interval (0.25s) but we allow it to exceed this by a

	 * fuzz factor of (0.1s)

	/* MC_CMD_PTP_OP_GET_ATTRIBUTES has been extended twice from an older

	 * operation MC_CMD_PTP_OP_GET_TIME_FORMAT. The function now may return

	 * a value to use for the minimum acceptable corrected synchronization

	 * window and may return further capabilities.

	 * If we have the extra information store it. For older firmware that

	 * does not implement the extended command use the default value.

	/* Set up the shift for conversion between frequency

	 * adjustments in parts-per-billion and the fixed-point

	 * fractional ns format that the adapter uses.

 Get PTP timestamp corrections */

	/* Get the timestamp corrections from the NIC. If this operation is

	 * not supported (older NICs) then no correction is required.

 Enable MCDI PTP support. */

/* Disable MCDI PTP support.

 *

 * Note that this function should never rely on the presence of ptp_data -

 * may be called before that exists.

	/* If we get ENOSYS, the NIC doesn't support PTP, and thus this function

	 * should only have been called during probe.

/* Repeatedly send the host time to the MC which will capture the hardware

 * time.

 Write host time for specified period or until MC is done */

 Don't update continuously to avoid saturating the PCIe bus */

 Synchronise NIC with single word of time only */

 Update host time in NIC memory */

 Read a timeset from the MC's results and partial process. */

 Ignore seconds */

 Allow for rollover */

 Determine duration of operation */

/* Process times received from MC.

 *

 * Extract times from returned results, and establish the minimum value

 * seen.  The minimum value represents the "best" possible time and events

 * too much greater than this are rejected - the machine is, perhaps, too

 * busy. A number of readings are taken so that, hopefully, at least one good

 * synchronisation will be seen in the results.

	/* Read the set of results and find the last good host-MC

	 * synchronization result. The MC times when it finishes reading the

	 * host time so the corrected window time should be fairly constant

	 * for a given platform. Increment stats for any results that appear

	 * to be erroneous.

		/* We expect the uncorrected synchronization window to be at

		 * least as large as the interval between host start and end

		 * times. If it is smaller than this then this is mostly likely

		 * to be a consequence of the host's time being adjusted.

		 * Check that the corrected sync window is in a reasonable

		 * range. If it is out of range it is likely to be because an

		 * interrupt or other delay occurred between reading the system

		 * time and writing it to MC memory.

	/* Calculate delay from last good sync (host time) to last_time.

	 * It is possible that the seconds rolled over between taking

	 * the start reading and the last value written by the host.  The

	 * timescales are such that a gap of more than one second is never

	 * expected.  delta is *not* normalised.

	/* Convert the NIC time at last good sync into kernel time.

	 * No correction is required - this time is the output of a

	 * firmware process.

 Calculate delay from NIC top of second to last_time */

 Set PPS timestamp to match NIC top of second */

 Synchronize times between the host and the MC */

 Clear flag that signals MC ready */

 Wait for start from MCDI (or timeout) */

 Usually start MCDI execution quickly */

 Collect results */

	/* Increment the bad syncs counter if the synchronize fails, whatever

	 * the reason.

 Transmit a PTP packet via the dedicated hardware timestamped queue. */

 Transmit a PTP packet, via the MCDI interface, to the wire. */

 Drop time-expired events */

 Look for a matching timestamp in the event queue */

 Match - add in hardware timestamp */

/* Process any queued receive events and corresponding packets

 *

 * q is returned with all the packets that are ready for delivery.

 Replace unprocessed entry and stop */

 Complete processing of a received packet */

	/* Must filter on both event and general ports to ensure

	 * that there is no packet re-ordering.

 Make sure RX packets are really delivered */

 Drop any pending receive events */

 Initialise PTP state. */

 Request sync events on this channel. */

 Get the NIC PTP attributes and set up time conversions */

 Get the timestamp corrections */

/* Initialise PTP channel.

 *

 * Setting core_index to zero causes the queue to be initialised and doesn't

 * overlap with 'rxq0' because ptp.c doesn't use skb_record_rx_queue.

	/* Failure to probe PTP is not fatal; this channel will just not be

	 * used for anything.

	 * In the case of EPERM, efx_ptp_probe will print its own message (in

	 * efx_ptp_get_attributes()), so we don't need to.

/* Determine whether this packet should be processed by the PTP module

 * or transmitted conventionally.

/* Receive a PTP packet.  Packets are queued until the arrival of

 * the receive timestamp from the MC - this will probably occur after the

 * packet arrival because of the processing in the MC.

 Correct version? */

		/* PTP V1 uses all six bytes of the UUID to match the packet

		 * to the timestamp

		/* The original V2 implementation uses bytes 2-7 of

		 * the UUID to match the packet to the timestamp. This

		 * discards two of the bytes of the MAC address used

		 * to create the UUID (SF bug 33070).  The PTP V2

		 * enhanced mode fixes this issue and uses bytes 0-2

		 * and byte 5-7 of the UUID.

 Does this packet require timestamping? */

		/* We expect the sequence number to be in the same position in

		 * the packet for PTP V1 and V2

 Extract UUID/Sequence information */

/* Transmit a PTP packet.  This has to be transmitted by the MC

 * itself, through an MCDI call.  MCDI calls aren't permitted

 * in the transmit path so defer the actual transmission to a suitable worker.

 Change of mode requires disable */

			/* Set new operating mode and establish

			 * baseline synchronisation, which must

			 * succeed.

	/* Check licensed features.  If we don't have the license for TX

	 * timestamps, the NIC will not support them.

 Not a PTP enabled port */

/* Process a completed receive event.  Put it on the event queue and

 * start worker thread.  This is required because event and their

 * correspoding packets may come in either order.

 Log a rate-limited warning message. */

 Process resulting event */

	/* When extracting the sync timestamp minor value, we should discard

	 * the least significant two bits. These are not required in order

	 * to reconstruct full-range timestamps and they are optionally used

	 * to report status depending on the options supplied when subscribing

	 * for sync events.

	/* if sync events have been disabled then we want to silently ignore

	 * this event, so throw away result.

	/* get the difference between the packet and sync timestamps,

	 * modulo one second

 do we roll over a second boundary and need to carry the one? */

		/* packet is ahead of the sync event by a quarter of a second or

		 * less (allowing for fuzz)

		/* packet is behind the sync event but within the fuzz factor.

		 * This means the RX packet and sync event crossed as they were

		 * placed on the event queue, which can sometimes happen.

		/* it's outside tolerance in both directions. this might be

		 * indicative of us missing sync events for some reason, so

		 * we'll call it an error rather than risk giving a bogus

		 * timestamp.

 attach the timestamps to the skb */

 Convert ppb to fixed point ns taking care to round correctly. */

	/* Get the current NIC time, efx_phc_gettime.

	 * Subtract from the desired time to get the offset

	 * call efx_phc_adjtime with the offset

 no copy operation; there is no need to reallocate this channel */

	/* Check whether PTP is implemented on this NIC.  The DISABLE

	 * operation will succeed if and only if it is implemented.

 re-enable timestamping if it was previously enabled */

 temporarily disable timestamping */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2018 Solarflare Communications Inc.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License version 2 as published

 * by the Free Software Foundation, incorporated herein by reference.

/* This is the time (in jiffies) between invocations of the hardware

 * monitor.

 * On Falcon-based NICs, this will:

 * - Check the on-board hardware monitor;

 * - Poll the link state and reconfigure the hardware as necessary.

 * On Siena-based NICs for power systems with EEH support, this will give EEH a

 * chance to start.

/* How often and how many times to poll for a reset while waiting for a

 * BIST that another function started to complete.

 Default stats update time */

 Loopback mode names (see LOOPBACK_MODE()) */

/* Reset workqueue. If any NIC has a hardware failure then a reset will be

 * queued onto this work queue. This is not a per-nic work queue, because

 * efx_reset_work() acquires the rtnl lock, so resets are naturally serialised.

/* We assume that efx->type->reconfigure_mac will always try to sync RX

 * filters and therefore needs to read-lock the filter table against freeing

/* Asynchronous work item for changing MAC promiscuity and multicast

 * hash.  Avoid a drain/rx_ingress enable by reconfiguring the current

 * MAC directly.

 save old address */

 Reconfigure the MAC */

 Context: netif_addr_lock held, BHs disabled. */

 Otherwise efx_start_port() will do this */

 If disabling RX n-tuple filtering, clear existing filters */

	/* If Rx VLAN filter is changed, update filters via mac_reconfigure.

	 * If rx-fcs is changed, mac_reconfigure updates that too.

		/* efx_set_rx_mode() will schedule MAC work to update filters

		 * when a new features are finally set in net_dev.

/* This ensures that the kernel is kept informed (via

 * netif_carrier_on/off) of the link status, and also maintains the

 * link status's stop on the port's TX queue.

	/* SFC Bug 5356: A net_dev notifier is registered, so we must ensure

	 * that no events are triggered between unregister_netdev() and the

	 * driver unloading. A more general condition is that NETDEV_CHANGE

	 * can only be generated between NETDEV_UP and NETDEV_DOWN

 Status message for kernel log */

	/* The maximum MTU that we can fit in a single page, allowing for

	 * framing, overhead and XDP headroom + tailroom.

 Context: process, rtnl_lock() held. */

/**************************************************************************

 *

 * Hardware monitor

 *

 Run periodically off the general workqueue */

	/* If the mac_lock is already held then it is likely a port

	 * reconfiguration is already in place, which will likely do

	 * most of the work of monitor() anyway.

/**************************************************************************

 *

 * Event queue processing

 *

/* Channels are shutdown and reinitialised whilst the NIC is running

 * to propagate configuration changes (mtu, checksum offload), or

 * to clear hardware error conditions

	/* Calculate the rx buffer allocation parameters required to

	 * support the current MTU, including padding for header

	 * alignment and overruns.

	/* Restore previously fixed features in hw_features and remove

	 * features which are fixed now

 RX filters may also have scatter-enabled flags */

	/* We must keep at least one descriptor in a TX ring empty.

	 * We could avoid this when the queue size does not exactly

	 * match the hardware ring size, but it's not that important.

	 * Therefore we stop the queue when one more skb might fill

	 * the ring completely.  We wake it when half way back to

	 * empty.

 Initialise the channels */

/**************************************************************************

 *

 * Port handling

 *

/* Equivalent to efx_link_set_advertising with all-zeroes, except does not

 * force the Autoneg bit on.

 Ensure MAC ingress/egress is enabled */

/* Cancel work for MAC reconfiguration, periodic hardware monitoring

 * and the async self-test, wait for them to finish and prevent them

 * being scheduled again.  This doesn't cover online resets, which

 * should only be cancelled when removing the device.

 Serialise against efx_set_multicast_list() */

/* If the interface is supposed to be running but is not, start

 * the hardware and software data path, regular activity for the port

 * (MAC statistics, link polling, etc.) and schedule the port to be

 * reconfigured.  Interrupts must already be enabled.  This function

 * is safe to call multiple times, so long as the NIC is not disabled.

 * Requires the RTNL lock.

	/* Check that it is appropriate to restart the interface. All

	 * of these flags are safe to read under just the rtnl lock

 Start the hardware monitor if there is one */

	/* Link state detection is normally event-driven; we have

	 * to poll now because we could have missed a change

/* Quiesce the hardware and software data path, and regular activity

 * for the port without bringing the link down.  Safe to call multiple

 * times with the NIC in almost any state, but interrupts should be

 * enabled.  Requires the RTNL lock.

 port_enabled can be read safely under the rtnl lock */

		/* update stats before we go down so we can accurately count

		 * rx_nodesc_drops

	/* Stop the kernel transmit interface.  This is only valid if

	 * the device is stopped or detached; otherwise the watchdog

	 * may fire immediately.

 Context: process, dev_base_lock or RTNL held, non-blocking. */

/* Push loopback/power/transmit disable settings to the PHY, and reconfigure

 * the MAC appropriately. All other PHY configuration changes are pushed

 * through phy_op->set_settings(), and pushed asynchronously to the MAC

 * through efx_monitor().

 *

 * Callers must hold the mac_lock

 Disable PHY transmit in mac level loopbacks */

/* Reinitialise the MAC to pick up new PHY settings, even if the port is

 * disabled.

/**************************************************************************

 *

 * Device reset and suspend

 *

	/* Either way unset the BIST flag. If we found no reboot we probably

	 * won't recover, but we should try.

/* Try recovery mechanisms.

 * For now only EEH is supported.

 * Returns 0 if the recovery mechanisms are unsuccessful.

 * Returns a non-zero value otherwise.

	/* A PCI error can occur and not be seen by EEH because nothing

	 * happens on the PCI bus. In this case the driver may fail and

	 * schedule a 'recover or reset', leading to this recovery handler.

	 * Manually call the eeh failure check function.

		/* The EEH mechanisms will handle the error and reset the

		 * device if necessary.

/* Tears down the entire software state and most of the hardware state

 * before reset.

 Context: netif_tx_lock held, BHs disabled. */

/* This function will always ensure that the locks acquired in

 * efx_reset_down() are released. A failure return code indicates

 * that we were unable to reinitialise the hardware, and the

 * driver should be disabled. If ok is false, then the rx and tx

 * engines are not restarted, pending a RESET_DISABLE.

 Ensure that SRAM is initialised even if we're disabling the device */

 not fatal; the PF will still work fine */

/* Reset the NIC using the specified method.  Note that the reset may

 * fail, in which case the card will be left in an unusable state.

 *

 * Caller must hold the rtnl_lock.

	/* efx_reset_down() grabs locks that prevent recovery on EF100.

	 * EF100 reset is handled in the efx_nic_type callback below.

	/* Clear flags for the scopes we covered.  We assume the NIC and

	 * driver are now quiescent so that there is no race here.

 it doesn't fit into the well-ordered scope hierarchy */

	/* Reinitialise bus-mastering, which may have been turned off before

	 * the reset was scheduled. This is still appropriate, even in the

	 * RESET_TYPE_DISABLE since this driver generally assumes the hardware

	 * can respond to requests.

 Leave device stopped if necessary */

/* The worker thread exists so that code that cannot sleep can

 * schedule a reset for later.

	/* We checked the state in efx_schedule_reset() but it may

	 * have changed by now.  Now that we have the RTNL lock,

	 * it cannot change again.

 ensure we change reset_pending before checking state */

	/* If we're not READY then just leave the flags set as the cue

	 * to abort probing or reschedule the reset later.

	/* efx_process_channel() will no longer read events once a

	 * reset is scheduled. So switch back to poll'd MCDI completions.

/**************************************************************************

 *

 * Dummy NIC operations

 *

 * Can be used for some unimplemented operations

 * Needed so all function pointers are valid and do not have to be tested

 * before use

 *

/**************************************************************************

 *

 * Data housekeeping

 *

/* This zeroes out and then fills in the invariants in a struct

 * efx_nic (including all sub-structures).

 Initialise common structures */

 Failure to allocate is not fatal, but may degrade ARFS performance */

 Would be good to use the net_dev name, but we're too early */

 This configures the PCI device to enable I/O and DMA. */

 Don't disable bus-mastering if VFs are assigned */

/* A PCI error affecting this device was detected.

 * At this point MMIO and DMA may be disabled.

 * Stop the software path and request a slot reset.

		/* If the interface is disabled we don't want to do anything

		 * with it.

 Fake a successful reset, which will be performed later in efx_io_resume. */

 Perform the actual reset and resume I/O operations. */

/* For simplicity and reliability, we always require a slot reset and try to

 * reset the hardware when a pci error affecting the device is detected.

 * We leave both the link_reset and mmio_enabled callback unimplemented:

 * with our request for slot reset the mmio_enabled callback will never be

 * called, and the link_reset callback is not used by AER or EEH mechanisms.

/* Determine whether the NIC will be able to handle TX offloads for a given

 * encapsulated packet.

	/* Does the NIC support encap offloads?

	 * If not, we should never get here, because we shouldn't have

	 * advertised encap offload feature flags in the first place.

 Determine encapsulation protocol in use */

		/* If there are extension headers, this will cause us to

		 * think we can't offload something that we maybe could have.

 Not IP, so can't offload it */

		/* We support NVGRE but not IP over GRE or random gretaps.

		 * Specifically, the NIC will accept GRE as encapsulated if

		 * the inner protocol is Ethernet, but only handle it

		 * correctly if the GRE header is 8 bytes long.  Moreover,

		 * it will not update the Checksum or Sequence Number fields

		 * if they are present.  (The Routing Present flag,

		 * GRE_ROUTING, cannot be set else the header would be more

		 * than 8 bytes long; so we don't have to worry about it.)

		/* If the port is registered for a UDP tunnel, we assume the

		 * packet is for that tunnel, and the NIC will handle it as

		 * such.  If not, the NIC won't know what to do with it.

			/* Hardware can only do TSO with at most 208 bytes

			 * of headers.

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2018 Solarflare Communications Inc.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License version 2 as published

 * by the Free Software Foundation, incorporated herein by reference.

 TODO: Advertise the capabilities supported by this PHY */

 This is not a link mode */

/* The semantics of the ethtool FEC mode bitmask are not well defined,

 * particularly the meaning of combinations of bits.  Which means we get to

 * define our own semantics, as follows:

 * OFF overrides any other bits, and means "disable all FEC" (with the

 * exception of 25G KR4/CR4, where it is not possible to reject it if AN

 * partner requests it).

 * AUTO on its own means use cable requirements and link partner autoneg with

 * fw-default preferences for the cable type.

 * AUTO and either RS or BASER means use the specified FEC type if cable and

 * link partner support it, otherwise autoneg/fw-default.

 * RS or BASER alone means use the specified FEC type if cable and link partner

 * support it and either requests it, otherwise no FEC.

 * Both RS and BASER (whether AUTO or not) means use FEC if cable and link

 * partner support it, preferring RS to BASER.

/* Invert ethtool_fec_caps_to_mcdi.  There are two combinations that function

 * can never produce, (baser xor rs) and neither req; the implementation below

 * maps both of those to AUTO.  This should never matter, and it's not clear

 * what a better mapping would be anyway.

/* Verify that the forced flow control settings (!EFX_FC_AUTO) are

 * supported by the link partner. Warn the user if this isn't the case

	/* The link partner capabilities are only relevant if the

	 * link supports flow control autonegotiation

 If flow control autoneg is supported and enabled, then fine */

 Initialise and populate phy_data */

 Read initial link advertisement */

 Fill out nic state */

 Assert that we can map efx -> mcdi loopback modes */

	/* The MC indicates that LOOPBACK_NONE is a valid loopback mode,

	 * but by convention we don't

 Set the initial link mode */

	/* Record the initial FEC configuration (or nearest approximation

	 * representable in the ethtool configuration space)

 Default to Autonegotiated flow control if the PHY supports it */

 MCDI format */

 behaviour for 25G/50G links depends on 25G BASER bit */

 BASER is never supported on 100G */

		/* We don't know what firmware has picked.  AUTO is as good a

		 * "can't happen" value as any other.

/* Basic validation to ensure that the caps we are going to attempt to set are

 * in fact supported by the adapter.  Note that 'no FEC' is always supported.

	/* Work out what efx_mcdi_phy_set_link_ksettings() would produce from

	 * saved advertising bits

 Record the new FEC setting for subsequent set_link calls */

 Wait up to 10s for BIST to finish */

 SFT9001 specific cable diagnostics output */

	/* If we support both LONG and SHORT, then run each in response to

	 * break or not. Otherwise, run the one we support

/** efx_mcdi_phy_get_module_eeprom_page() - Get a single page of module eeprom

 * @efx:	NIC context

 * @page:	EEPROM page number

 * @data:	Destination data pointer

 * @offset:	Offset in page to copy from in to data

 * @space:	Space available in data

 *

 * Return:

 *   >=0 - amount of data copied

 *   <0  - error

 Page zero of the EEPROM includes the diagnostic type at byte 92. */

 Page zero of the EEPROM includes the DMT level at byte 94. */

	/* A QSFP+ NIC may actually have an SFP+ module attached.

	 * The ID is page 0, byte 0.

 We obtain the lower page by asking for -1. */

 Ignore missing pages after page 0. */

 If we can't read the diagnostics level we have none. */

		/* Check if this module requires the (unsupported) address

		 * change operation.

 This has no effect on EF10 */

 Set simple MAC filter for Siena */

 Expect ENOENT if DMA queues have not been set up */

 Allocate buffer for stats */

 Get physical port number (EF10 only; on Siena it is same as PF number) */

	/* efx->link_state is only modified by efx_mcdi_phy_get_link(),

	 * which is only run after flushing the event queues. Therefore, it

	 * is safe to modify the link state outside of the mac_lock here.

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2006-2013 Solarflare Communications Inc.

 Falcon-architecture (SFC9000-family) support */

/**************************************************************************

 *

 * Configurable values

 *

 **************************************************************************

/* This is set to 16 for a good reason.  In summary, if larger than

 * 16, the descriptor cache holds more than a default socket

 * buffer's worth of packets (for UDP we can only have at most one

 * socket buffer's worth outstanding).  This combined with the fact

 * that we only get 1 TX event per descriptor cache means the NIC

 * goes idle.

/* If EFX_MAX_INT_ERRORS internal errors occur within

 * EFX_INT_ERROR_EXPIRE seconds, we consider the NIC broken and

 * disable it.

 Depth of RX flush request fifo */

 Driver generated events */

/**************************************************************************

 *

 * Hardware access

 *

 bit sweep on and off */

 Test this testable bit can be set in isolation */

 Test this testable bit can be cleared in isolation */

/**************************************************************************

 *

 * Special buffer handling

 * Special buffers are used for event queues and the TX and RX

 * descriptor rings.

 *

/*

 * Initialise a special buffer

 *

 * This will define a buffer (previously allocated via

 * efx_alloc_special_buffer()) in the buffer table, allowing

 * it to be used for event queues, descriptor rings etc.

 Write buffer descriptors to NIC */

 Unmaps a buffer and clears the buffer table entries */

/*

 * Allocate a new special buffer

 *

 * This allocates memory for a new buffer, clears it and allocates a

 * new buffer ID range.  It does not write into the buffer table.

 *

 * This call will allocate 4KB buffers, since 8KB buffers can't be

 * used for event queues and descriptor rings.

 Select new buffer ID */

/**************************************************************************

 *

 * TX path

 *

 This writes to the TX_DESC_WPTR; write pointer for TX descriptor ring */

 Write pointer and first descriptor for TX descriptor ring */

/* For each entry inserted into the software descriptor ring, create a

 * descriptor in the hardware TX descriptor ring (in host memory), and

 * write a doorbell.

 Create TX descriptor ring entry */

 Ensure descriptors are written before they are fetched */

 Don't cross 4K boundaries with descriptors. */

 Allocate hardware resources for a TX queue */

 Pin TX descriptor ring */

 Push TX descriptor ring to card */

 Remove TX descriptor ring from card */

 Unpin TX descriptor ring */

 Free buffers backing TX queue */

/**************************************************************************

 *

 * RX path

 *

 This creates an entry in the RX descriptor queue */

/* This writes to the RX_DESC_WPTR register for the specified receive

 * descriptor ring.

 For kernel-mode queues in Siena, the JUMBO flag enables scatter. */

 Pin RX descriptor ring */

 Push RX descriptor ring to card */

 kernel queue */ ,

 Remove RX descriptor ring from card */

 Unpin RX descriptor ring */

 Free buffers backing RX queue */

/**************************************************************************

 *

 * Flush handling

 *

/* efx_farch_flush_queues() must be woken up when all flushes are completed,

 * or more RX flushes can be kicked off.

 Ensure that all updates are visible to efx_farch_flush_queues() */

				/* The flush is complete, but we didn't

				 * receive a flush completion event

				/* Don't need to increment active_queues as it

				 * has already been incremented for the queues

				 * which did not drain

/* Flush all the transmit queues, and continue flushing receive queues until

 * they're all flushed. Wait for the DRAIN events to be received so that there

 5s for all flushes and drains */

		/* If SRIOV is enabled, then offload receive queue flushing to

		 * the firmware (though we will still have to poll for

		 * completion). If that fails, fall back to the old scheme.

		/* The hardware supports four concurrent rx flushes, each of

		 * which may need to be retried if there is an outstanding

		 * descriptor fetch

 Do not attempt to write to the NIC during EEH recovery */

 Only perform flush if DMA is enabled */

/* Reset queue and flush accounting after FLR

 *

 * One possible cause of FLR recovery is that DMA may be failing (eg. if bus

 * mastering was disabled), in which case we don't receive (RXQ) flush

 * completion events.  This means that efx->rxq_flush_outstanding remained at 4

 * after the FLR; also, efx->active_queues was non-zero (as no flush completion

 * events were received, and we didn't go through efx_check_tx_flush_complete())

 * If we don't fix this up, on the next call to efx_realloc_channels() we won't

 * flush any RX queues because efx->rxq_flush_outstanding is at the limit of 4

 * for batched flush requests; and the efx->active_queues gets messed up because

 * we keep incrementing for the newly initialised queues, but it never went to

 * zero previously.  Then we get a timeout every time we try to restart the

 * queues, as it doesn't go back to zero when we should be flushing the queues.

/**************************************************************************

 *

 * Event queue processing

 * Event queues are processed by per-channel tasklets.

 *

/* Update a channel's event queue's read pointer (RPTR) register

 *

 * This writes the EVQ_RPTR_REG register for the specified channel's

 * event queue.

	/* For Falcon A1, EVQ_RPTR_KER is documented as having a step size

	 * of 4 bytes, but it is really 16 bytes just like later revisions.

 Use HW to insert a SW defined event */

/* Handle a transmit completion event

 *

 * The NIC batches TX completion events; the message we receive is of

 * the form "complete all TX events up to this index".

 Transmit completion */

 Rewrite the FIFO write pointer */

 Detect errors included in the rx_evt_pkt_ok bit. */

 Every error apart from tobe_disc and pause_frm */

	/* Count errors that are not in MAC stats.  Ignore expected

	/* TOBE_DISC is expected on unicast mismatches; don't print out an

	 * error message.  FRM_TRUNC indicates RXDP dropped the packet due

	 * to a FIFO overflow.

 don't discard frame for CRC error */

 The frame must be discarded if any of these are true. */

/* Handle receive events that are not in-order. Return true if this

 * can be handled as a partial packet discard, false if it's more

 * serious.

/* Handle a packet received event

 *

 * The NIC gives a "discard" flag if it's a unicast packet with the

 * wrong destination address

 * Also "is multicast" and "matches multicast filter" flags can be used to

 * discard non-matching multicast packets.

 Check for partial drops and other errors */

 Discard all pending fragments */

 Return if there is no new fragment */

 Discard new fragment if not SOP */

		/* If packet is marked as OK then we can rely on the

		 * hardware checksum and classification.

 Detect multicast packets that didn't match the filter */

 Handle received packet */

/* If this flush done event corresponds to a &struct efx_tx_queue, then

 * send an %EFX_CHANNEL_MAGIC_TX_DRAIN event to drain the event queue

 * of all transmit completions.

/* If this flush done event corresponds to a &struct efx_rx_queue: If the flush

 * was successful then send an %EFX_CHANNEL_MAGIC_RX_DRAIN, otherwise add

 * the RX queue back to the mask of RX queues in need of flushing.

		/* The queue must be empty, so we won't receive any rx

		 * events, so efx_process_channel() won't refill the

 End of events */

 Clear this event by marking it all ones */

 Allocate buffer table entries for event queue */

 Pin event queue buffer */

 Fill event queue with all ones (i.e. empty events) */

 Push event queue to card */

 Remove event queue from card */

 Unpin event queue */

 Free buffers backing event queue */

/**************************************************************************

 *

 * Hardware interrupts

 * The hardware interrupt handler does very little work; all the event

 * queue processing is carried out by per-channel tasklets.

 *

 Enable/disable/generate interrupts */

 Ensure interrupt vector is clear before interrupts enabled */

 Disable interrupts */

/* Generate a test interrupt

 * Interrupt must already have been enabled, otherwise nasty things

 * may happen.

/* Process a fatal interrupt

 * Disable bus mastering ASAP and schedule a reset

 If this is a memory parity error dump which blocks are offending */

 Disable both devices */

 Count errors and reset or disable the NIC accordingly */

/* Handle a legacy interrupt

 * Acknowledges the interrupt and schedule event queue processing.

 Read the ISR which also ACKs the interrupts */

	/* Legacy interrupts are disabled too late by the EEH kernel

	 * code. Disable them earlier.

	 * If an EEH error occurred, the read will have returned all ones.

 Handle non-event-queue sources */

 Schedule processing of any interrupting queues */

 Legacy ISR read can return zero once (SF bug 15783) */

		/* We can't return IRQ_HANDLED more than once on seeing ISR=0

 Ensure we schedule or rearm all event queues */

/* Handle an MSI interrupt

 *

 * Handle an MSI hardware interrupt.  This routine schedules event

 * queue processing.  No interrupt acknowledgement cycle is necessary.

 * Also, we never need to check that the interrupt is for us, since

 * MSI interrupts cannot be shared.

 Handle non-event-queue sources */

 Schedule processing of the channel */

/* Setup RSS indirection table.

 * This maps from the hash value of the packet to RXQ

/* Looks at available SRAM resources and works out how many queues we

 * can support, and where things like descriptor caches should live.

 *

 * SRAM is split up as follows:

 * 0                          buftbl entries for channels

 * efx->vf_buftbl_base        buftbl entries for SR-IOV

 * efx->rx_dc_base            RX descriptor caches

 * efx->tx_dc_base            TX descriptor caches

	/* Account for the buffer table entries backing the datapath channels

	 * and the descriptor caches for those channels.

 Set positions of descriptor caches in SRAM. */

 Set TX descriptor cache size. */

	/* Set RX descriptor cache size.  Set low watermark to size-8, as

	 * this allows most efficient prefetching.

 Program INT_KER address */

 Use an interrupt level unused by event queues */

 Use a valid MSI-X vector */

	/* Enable all the genuinely fatal interrupts.  (They are still

	 * masked by the overall interrupt mask, controlled by

	 * falcon_interrupts()).

	 *

	 * Note: All other fatal interrupts are enabled

	/* Disable the ugly timer-based TX DMA backoff and allow TX DMA to be

	 * controlled by the RX FIFO fill level. Set arbitration to one pkt/Q.

 Enable SW_EV to inherit in char driver - assume harmless here */

 Prefetch threshold 2 => fetch when descriptor cache half empty */

 Disable hardware watchdog which can misfire */

 Squash TX of packets of 16 bytes or less */

 Default values */

 Allow large pace values in the fast bin. */

/**************************************************************************

 *

 * Filter tables

 *

 **************************************************************************

/* "Fudge factors" - difference between programmed value and actual depth.

 * Due to pipelined implementation we need to program H/W with a value that

 * is larger than the hop limit we want.

/* Hard maximum search limit.  Hardware will time-out beyond 200-something.

 * We also need to avoid infinite loops in efx_farch_filter_search() when the

 * table is full.

/* Don't try very hard to find space for performance hints, as this is

 number of specific types */

 address of table relative to BAR */

 number of entries */

 step between entries */

 number currently used */

 Protects table contents */

/* The filter hash function is LFSR polynomial x^16 + x^3 + 1 of a 32-bit

 First 16 rounds */

 Last 16 rounds */

/* To allow for hash collisions, filter search continues at these

		/* There is a single bit to enable RX scatter for all

		 * unmatched packets.  Only set it if scatter is

		 * enabled in both filter specs.

		/* We don't expose 'default' filters because unmatched

		 * packets always go to the queue number found in the

		 * RSS table.  But we still need to set the RX scatter

		 * bit here.

		/* Filter is constructed in terms of source and destination,

		 * with the odd wrinkle that the ports are swapped in a UDP

		 * wildcard filter.  We need to convert from local and remote

		 * (= zero for wildcard) addresses.

 ensure equality */

	/* *gen_spec should be completely initialised, to be consistent

	 * with efx_filter_init_{rx,tx}() and in case we want to copy

	 * it back to userland.

	/* If there's only one channel then disable RSS for non VF

	 * traffic, thereby allowing VFs to use RSS when the PF can't.

 Build a filter entry and return its n-tuple key. */

/*

 * Construct/deconstruct external filter IDs.  At least the RX filter

 * IDs must be ordered by matching priority, for RX NFC semantics.

 *

 * Deconstruction needs to be robust against invalid IDs so that

 * efx_filter_remove_id_safe() and efx_filter_get_filter_safe() can

 * accept user-provided IDs.

 RX match pri 0 */

 RX match pri 4 */

 TX match pri 0 */

 TX match pri 1 */

 invalid */

 One filter spec per type */

		/* Search concurrently for

		 * (1) a filter to be replaced (rep_index): any filter

		 *     with the same match values, up to the current

		 *     search depth for this type, and

		 * (2) the insertion point (ins_index): (1) or any

		 *     free slot before it or up to the maximum search

		 *     depth for this priority

		 * We fail if we cannot find (2).

		 *

		 * We can stop once either

		 * (a) we find (1), in which case we have definitely

		 *     found (2) as well; or

		 * (b) we have searched exhaustively for (1), and have

		 *     either found (2) or searched exhaustively for it

 Case (a) */

 Case (b) */

	/* If we found a filter to be replaced, check whether we

	 * should do so

 Insert the filter */

		/* If we were able to replace a filter by inserting

		 * at a lower depth, clear the replaced filter

 can't clear MAC default filters */

	/* If this filter required a greater search depth than

	 * any other, the search limit for its type can now be

	 * decreased.  However, it is hard to determine that

	 * unless the table has become completely empty - in

	 * which case, all its search limits can be set to 0.

 Restore filter stater after reset */

 Check whether this is a regular register table */

 RX default filters must always exist */

 Update scatter enable flags for filters pointing to our own RX queues */

 Pushed by efx_farch_filter_push_rx_config() */

			/* In the absence of the table, we always returned 0 to

			 * ARFS, so use the same to query it.

 ARFS table doesn't know of this filter, remove it */

 CONFIG_RFS_ACCEL */

 Build multicast hash table */

		/* Broadcast packets go through the multicast hash filter.

		 * ether_crc_le() of the broadcast address is 0xbe2612ff

		 * so we always add bit 0xff to the mask.

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2005-2013 Solarflare Communications Inc.

 Preferred number of descriptors to fill at once */

 Maximum rx prefix used by any architecture. */

 Size of buffer allocated for skb header area. */

 Each packet can consume up to ceil(max_frame_len / buffer_size) buffers */

	/* The packet must be discarded, but this is only a fatal error

	 * if the caller indicated it was

 Allocate and construct an SKB around page fragments */

 Allocate an SKB to store the headers */

 Append the remaining page(s) onto the frag list */

 Move past the ethernet header */

 Validate the number of fragments and completed length */

		/* If this isn't an explicit discard request, either

		 * the hardware or the driver is broken.

	/* Discard packet, if instructed to do so.  Process the

	 * previous receive first.

	/* Release and/or sync the DMA mapping - assumes all RX buffers

	 * consumed in-order per RX queue.

	/* Prefetch nice and early so data will (hopefully) be in cache by

	 * the time we look at it.

		/* Release/sync DMA mapping for additional fragments.

		 * Fix length for last fragment.

 All fragments have been DMA-synced, so recycle pages. */

	/* Pipeline receives so that we give time for packet headers to be

	 * prefetched into cache.

 Set the SKB flags */

 Pass the packet up */

 Add to list, will pass up later */

 No list, so pass it up now */

/** efx_do_xdp: perform XDP processing on a received packet

 *

 * Returns true if packet should still be delivered.

 We can't do XDP on fragmented packets - drop. */

 Save the rx prefix. */

 No support yet for XDP metadata */

 Fix up rx prefix. */

 Buffer ownership passes to tx on success. */

 Handle a received packet.  Second half: Touches packet payload. */

	/* Read length from the prefix if necessary.  This already

	 * excludes the length of the prefix itself.

	/* If we're in loopback test, then pass the packet directly to the

	 * loopback layer, and free the rx_buf here

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2006-2013 Solarflare Communications Inc.

 MTD interface */

 Add to list in order - efx_mtd_remove() depends on this */

 Failure is unlikely here, but probably means we're out of memory */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2018 Solarflare Communications Inc.

 * Copyright 2019-2020 Xilinx Inc.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License version 2 as published

 * by the Free Software Foundation, incorporated herein by reference.

 Allocate an extra descriptor for the QMDA status completion entry */

 must be the inverse of lookup in efx_get_tx_channel */

	/* This value is purely documentational; as EF100 never passes through

	 * the switch statement in tx.c:__efx_enqueue_skb(), that switch does

	 * not handle case 3.  EF100's TSOv3 descriptors are generated by

	 * ef100_make_tso_desc().

	 * Meanwhile, all efx_mcdi_tx_init() cares about is that it's not 2.

 net_dev->gso_max_segs should've caught this */

 net_dev->gso_max_size should've caught this */

	/* Reserve an empty buffer for the TSO V3 descriptor.

	 * Convey the length of the header since we already know it.

 The write pointer goes into the high word */

	/* skb->csum_start has the offset from head, but we need the offset

	 * from data.

 TX send descriptor */

 We use 1 for the TSO descriptor and 1 for the header */

 subtract TCP payload length from inner checksum */

 if it's a raw write (such as XDP) then always SEND single frames */

 Create TX descriptor ring entry */

 TX TSO descriptor */

 TX segment descriptor */

 if it's a raw write (such as XDP) then always SEND */

 Ensure descriptors are written before they are fetched */

	/* The write_count above must be updated before reading

	 * channel->holdoff_doorbell to avoid a race with the

	 * completion path, so ensure these operations are not

	 * re-ordered.  This also flushes the update of write_count

	 * back into the cache.

/* Add a socket buffer to a TX queue

 *

 * You must hold netif_tx_lock() to call this function.

 *

 * Returns 0 on success, error code otherwise. In case of an error this

 * function will free the SKB.

 Don't use TSO/GSO for a single segment. */

 Map for DMA and create descriptors */

		/* Re-read after a memory barrier in case we've raced with

		 * the completion path. Otherwise there's a danger we'll never

		 * restart the queue if all completions have just happened.

	/* If xmit_more then we don't need to push the doorbell, unless there

	 * are 256 descriptors already queued in which case we have to push to

	 * ensure we never push more than 256 at once.

	/* If we're not expecting another transmit and we had something to push

	 * on this queue then we need to push here to get the previous packets

	 * out.  We only enter this branch from before the xmit_more handling

	 * above, so xmit_pending still refers to the old state.

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2005-2013 Solarflare Communications Inc.

/**************************************************************************

 *

 * Configurable values

 *

/*

 * Use separate channels for TX and RX events

 *

 * Set this to 1 to use separate channels for TX and RX. It allows us

 * to control interrupt affinity separately for TX and RX.

 *

 * This is only used in MSI-X interrupt mode

/* Initial interrupt moderation settings.  They can be modified after

 * module load with ethtool.

 *

 * The default for RX should strike a balance between increasing the

 * round-trip latency and reducing overhead.

/* Initial interrupt moderation settings.  They can be modified after

 * module load with ethtool.

 *

 * This default is chosen to ensure that a 10G link does not go idle

 * while a TX queue is stopped after it has become full.  A queue is

 * restarted when it drops below half full.  The time this takes (assuming

 * worst case 3 descriptors per packet and 1024 descriptors) is

 *   512 / 3 * 1.2 = 205 usec.

/**************************************************************************

 *

 * Utility functions and prototypes

 *

/**************************************************************************

 *

 * Port handling

 *

 Connect up MAC/PHY operations table */

 Initialise MAC address to permanent address */

 Ensure the PHY advertises the correct flow control settings */

/**************************************************************************

 *

 * NIC handling

 *

 Adding primary function; look for secondaries */

 Adding secondary function; look for primary */

 Carry out hardware-type specific initialisation */

		/* Determine the number of channels and queues by trying

		 * to hook in MSI-X interrupts.

 dimension_resources can fail with EAGAIN */

 try again with new max_channels */

 Initialise the interrupt moderation settings */

/**************************************************************************

 *

 * NIC startup/shutdown

 *

 not fatal; the PF will still work fine */

/**************************************************************************

 *

 * Interrupt moderation

 *

 never round down to 0 */

	/* We must round up when converting ticks to microseconds

	 * because we round down when converting the other way.

 Set interrupt moderation parameters */

	/* If channels are shared between RX and TX, so is IRQ

	 * moderation.  Otherwise, IRQ moderation is the same for all

	 * TX channels and is not adaptive.

/**************************************************************************

 *

 * ioctls

 *

/* Net device ioctl

 * Context: process, rtnl_lock() held.

 Convert phy_id from older PRTAD/DEVAD format */

/**************************************************************************

 *

 * Kernel net device interface

 *

 Context: process, rtnl_lock() held. */

	/* Notify the kernel of the link state polled during driver load,

/* Context: process, rtnl_lock() held.

 * Note that the kernel will ignore our return code; this method

 * should really be a void.

 Stop the device and flush all the channels */

 Release the reference that was originally passed by the caller. */

 Context: process, rtnl_lock() held. */

	/* Enable resets to be scheduled and check whether any were

	 * already requested.  If so, the NIC is probably hosed so we

	 * abort.

 ensure we change state before checking reset_pending */

 Always start with carrier off; PHY events will detect the link */

/**************************************************************************

 *

 * List of NICs we support

 *

 PCI device ID table */

 SFC9020 */

 SFL9021 */

 SFC9120 PF */

 SFC9120 VF */

 SFC9140 PF */

 SFC9140 VF */

 SFC9220 PF */

 SFC9220 VF */

 SFC9250 PF */

 SFC9250 VF */

 end of list */

/**************************************************************************

 *

 * Data housekeeping

 *

/**************************************************************************

 *

 * PCI interface

 *

/* Main body of final NIC shutdown code

 * This is called only at module unload (or hotplug removal).

	/* Flush reset_work. It can no longer be scheduled since we

	 * are not READY.

/* Final NIC shutdown

 * This is called only at module unload (or hotplug removal).  A PF can call

 * this on its VFs to ensure they are unbound first.

 Mark the NIC as fini, then stop the interface */

/* NIC VPD information

 * Called during probe to display the part number of the

 * installed NIC.

/* Main body of NIC initialisation

 * This is called at module load (or hotplug insertion, theoretically).

 Do start-of-day initialisation */

 Determine netdevice features */

 Check whether device supports TSO */

 Mask for features that also apply to VLAN devices */

 Disable receiving frames with bad FCS, by default. */

	/* Disable VLAN filtering by default.  It may be enforced if

	 * the feature is fixed (i.e. VLAN filters are required to

	 * receive VLAN tagged packets due to vPort restrictions).

/* NIC initialisation

 *

 * This is called at module load (or hotplug insertion,

 * theoretically).  It sets up PCI mappings, resets the NIC,

 * sets up and registers the network devices with the kernel and hooks

 * the interrupt service routine.  It does not prepare the device for

 * transmission; this is left to the first time one of the network

 * interfaces is brought up (i.e. efx_net_open).

 Allocate and initialise a struct net_device and struct efx_nic */

 Set up basic I/O (BAR mappings etc) */

		/* On failure, retry once immediately.

		 * If we aborted probe due to a scheduled reset, dismiss it.

			/* On another failure, retry once more

			 * after a 50-305ms delay.

 Try to create MTDs, but allow this to fail */

/* efx_pci_sriov_configure returns the actual number of Virtual Functions

 * enabled on success

 Reschedule any quenched resets scheduled during efx_pm_freeze() */

 Used for both resume and restore */

/**************************************************************************

 *

 * Kernel module interface

 *

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2006-2013 Solarflare Communications Inc.

/**************************************************************************

 *

 * Ethtool operations

 *

 **************************************************************************

 Identify device by flashing LEDs */

 cycle on/off once per second */

/*

 * Each channel has a single IRQ and moderation timer, started by any

 * completion (or other event).  Unless the module parameter

 * separate_tx_channels is set, IRQs and moderation are therefore

 * shared between RX and TX completions.  In this case, when RX IRQ

 * moderation is explicitly changed then TX IRQ moderation is

 * automatically changed too, but otherwise we fail if the two values

 * are requested to be different.

 *

 * The hardware does not support a limit on the number of completions

 * before an IRQ, so we do not use the max_frames fields.  We should

 * report and require that max_frames == (usecs != 0), but this would

 * invalidate existing user documentation.

 *

 * The hardware does not have distinct settings for interrupt

 * moderation while the previous IRQ is being handled, so we should

 * not use the 'irq' fields.  However, an earlier developer

 * misunderstood the meaning of the 'irq' fields and the driver did

 * not support the standard fields.  To avoid invalidating existing

 * user documentation, we report and accept changes through either the

 * standard or 'irq' fields.  If both are changed at the same time, we

 * prefer the standard field.

 *

 * We implement adaptive IRQ moderation, but use a different algorithm

 * from that assumed in the definition of struct ethtool_coalesce.

 * Therefore we do not use any of the adaptive moderation parameters

 * in it.

	/* If channels are shared, TX IRQ moderation can be quietly

	 * overridden unless it is changed from its old value.

 Software capabilities */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2014-2015 Solarflare Communications Inc.

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2009-2013 Solarflare Communications Inc.

/*

 * Driver for PHY related operations via MCDI.

 Set up MDIO structure for PHY */

 Fill out MDIO structure, loopback modes, and initial link state */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2019 Solarflare Communications Inc.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License version 2 as published

 * by the Free Software Foundation, incorporated herein by reference.

 Get the value of a field in the RX prefix */

 Everything is ok */

 no support for special channels yet, so just discard */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2018 Solarflare Communications Inc.

 * Copyright 2019-2020 Xilinx Inc.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License version 2 as published

 * by the Free Software Foundation, incorporated herein by reference.

/*	MCDI

	/* The hardware provides 'low' and 'high' (doorbell) registers

	 * for passing the 64-bit address of an MCDI request to

	 * firmware.  However the dwords are swapped by firmware.  The

	 * least significant bits of the doorbell are then 0 for all

	 * MCDI requests due to alignment.

		/* The firmware is presumably in the process of

		 * rebooting.  However, we are supposed to report each

		 * reboot just once, so we must only do that once we

		 * can read and store the updated warm boot count.

/*	MCDI calls

		/* EF100 HW can only offload outer checksums if they are UDP,

		 * so for GRE_CSUM we have to use GSO_PARTIAL.

/*	Event handling

 Allocate an extra descriptor for the QMDA status completion entry */

 initial phase is 0 */

 Note test interrupts */

 Schedule processing of the channel */

 Probe for the PHY */

 Populate driver and ethtool settings */

 Default to Autonegotiated flow control if the PHY supports it */

	/* Push settings to the PHY. Failure is not fatal, the user can try to

	 * fix it using ethtool.

/*	Other

 Only perform a RESET_TYPE_ALL because we don't support MC_REBOOTs */

 Leave the device closed */

	/* MCDI_SET_QWORD is not appropriate here since EFX_POPULATE_* has

	 * already swapped the data to little-endian order.

/*	NIC level access functions

	/* Per-type bar/size configuration not used on ef100. Location of

	 * registers is defined by extended capabilities.

 Clear ready to read in a new entry */

 We only handle TLVs that fit in a u64 */

 len may be zero, implying a value of zero */

 state machine error, can't happen */

 padding, skip it */

 Driver doesn't support timestamping yet, so we don't care */

		/* Driver doesn't support unsolicited-event credits yet, so

		 * we don't care

 Driver doesn't manage the NMMU (so we don't care) */

		/* Driver uses CHECKSUM_COMPLETE, so we don't care about

		 * protocol checksum validation

 We always put HDR_NUM_SEGS=1 in our TSO descriptors */

		/* Our TXQ and RXQ sizes are always power-of-two and thus divisible by

		 * EFX_MIN_DMAQ_SIZE, so we just need to check that

		 * EFX_MIN_DMAQ_SIZE is divisible by GRANULARITY.

		 * This is very unlikely to fail.

 Driver doesn't use mem2mem transfers */

 Driver doesn't currently use EVQ_TIMER */

 Driver doesn't manage the NMMU (so we don't care) */

		/* We never try to set the VI stride, and we don't rely on

		 * being able to find VIs past VI 0 until after we've learned

		 * the current stride from MC_CMD_GET_CAPABILITIES.

		 * So the value of this shouldn't matter.

		/* Driver doesn't look at L2_STATUS:LEN_ERR bit, so we don't

		 * care whether it indicates runt or overlength for any given

		 * packet, so we don't care about this parameter.

		/* Host interface says "Drivers should ignore design parameters

		 * that they do not recognise."

 Got a complete value? */

	/* Check we didn't end halfway through a TLV entry, which could either

	 * mean that the TLV stream is truncated or just that it's corrupted

	 * and our state machine is out of sync.

/*	NIC probe and remove

 Populate design-parameter defaults */

 Read design parameters */

 we assume later that we can copy from this buffer in dwords */

 MCDI buffers must be 256 byte aligned. */

	/* Get the MC's warm boot count.  In case it's rebooting right

	 * now, be prepared to retry.

	/* In case we're recovering from a crash (kexec), we want to

	 * cancel any outstanding request by the previous user of this

	 * function.  We send a special message using the least

	 * significant bits of the 'high' (doorbell) register.

 Post-IO section. */

 Reset (most) configuration for this function */

 Enable event logging */

 Don't fail init if RSS setup doesn't work. */

 Assign MAC address */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2010-2012 Solarflare Communications Inc.

 Number of longs required to track all the VIs in a VF */

 Maximum number of RX queues supported */

/**

 * enum efx_vf_tx_filter_mode - TX MAC filtering behaviour

 * @VF_TX_FILTER_OFF: Disabled

 * @VF_TX_FILTER_AUTO: Enabled if MAC address assigned to VF and only

 *	2 TX queues allowed per VF.

 * @VF_TX_FILTER_ON: Enabled

/**

 * struct siena_vf - Back-end resource and protocol state for a PCI VF

 * @efx: The Efx NIC owning this VF

 * @pci_rid: The PCI requester ID for this VF

 * @pci_name: The PCI name (formatted address) of this VF

 * @index: Index of VF within its port and PF.

 * @req: VFDI incoming request work item. Incoming USR_EV events are received

 *	by the NAPI handler, but must be handled by executing MCDI requests

 *	inside a work item.

 * @req_addr: VFDI incoming request DMA address (in VF's PCI address space).

 * @req_type: Expected next incoming (from VF) %VFDI_EV_TYPE member.

 * @req_seqno: Expected next incoming (from VF) %VFDI_EV_SEQ member.

 * @msg_seqno: Next %VFDI_EV_SEQ member to reply to VF. Protected by

 *	@status_lock

 * @busy: VFDI request queued to be processed or being processed. Receiving

 *	a VFDI request when @busy is set is an error condition.

 * @buf: Incoming VFDI requests are DMA from the VF into this buffer.

 * @buftbl_base: Buffer table entries for this VF start at this index.

 * @rx_filtering: Receive filtering has been requested by the VF driver.

 * @rx_filter_flags: The flags sent in the %VFDI_OP_INSERT_FILTER request.

 * @rx_filter_qid: VF relative qid for RX filter requested by VF.

 * @rx_filter_id: Receive MAC filter ID. Only one filter per VF is supported.

 * @tx_filter_mode: Transmit MAC filtering mode.

 * @tx_filter_id: Transmit MAC filter ID.

 * @addr: The MAC address and outer vlan tag of the VF.

 * @status_addr: VF DMA address of page for &struct vfdi_status updates.

 * @status_lock: Mutex protecting @msg_seqno, @status_addr, @addr,

 *	@peer_page_addrs and @peer_page_count from simultaneous

 *	updates by the VM and consumption by

 *	efx_siena_sriov_update_vf_addr()

 * @peer_page_addrs: Pointer to an array of guest pages for local addresses.

 * @peer_page_count: Number of entries in @peer_page_count.

 * @evq0_addrs: Array of guest pages backing evq0.

 * @evq0_count: Number of entries in @evq0_addrs.

 * @flush_waitq: wait queue used by %VFDI_OP_FINI_ALL_QUEUES handler

 *	to wait for flush completions.

 * @txq_lock: Mutex for TX queue allocation.

 * @txq_mask: Mask of initialized transmit queues.

 * @txq_count: Number of initialized transmit queues.

 * @rxq_mask: Mask of initialized receive queues.

 * @rxq_count: Number of initialized receive queues.

 * @rxq_retry_mask: Mask or receive queues that need to be flushed again

 *	due to flush failure.

 * @rxq_retry_count: Number of receive queues in @rxq_retry_mask.

 * @reset_work: Work item to schedule a VF reset.

 dddd:bb:dd.f */

/**

 * struct efx_local_addr - A MAC address on the vswitch without a VF.

 *

 * Siena does not have a switch, so VFs can't transmit data to each

 * other. Instead the VFs must be made aware of the local addresses

 * on the vswitch, so that they can arrange for an alternative

 * software datapath to be used.

 *

 * @link: List head for insertion into efx->local_addr_list.

 * @addr: Ethernet address

/**

 * struct efx_endpoint_page - Page of vfdi_endpoint structures

 *

 * @link: List head for insertion into efx->local_page_list.

 * @ptr: Pointer to page.

 * @addr: DMA address of page.

 Buffer table entries are reserved txq0,rxq0,evq0,txq1,rxq1,evq1 */

 VFs can only use this many transmit channels */

/* Workqueue used by VFDI communication.  We can't use the global

 * workqueue because it may be running the VF driver's probe()

 * routine, which will be blocked there waiting for a VFDI response.

 Finish writing source/reading dest before DMA starts */

 Don't write source/read dest before DMA is complete */

/* The TX filter is entirely controlled by this driver, and is modified

 * underneath the feet of the VF

	/* Turn on TX filtering automatically if not explicitly

	 * enabled or disabled.

 The RX filter is managed here on behalf of the VF driver */

/* Push the peer list to this VF. The caller must hold status_lock to interlock

 * with VFDI requests, and they must be serialised against manipulation of

 * local_page_list, either by acquiring local_lock or by running from

 * efx_siena_sriov_peer_work()

 Write generation_start */

	/* DMA the rest of the structure (excluding the generations). This

	 * assumes that the non-generation portion of vfdi_status is in

	 * one chunk starting at the version member.

 Copy the peer pages */

			/* The VF driver will know they need to provide more

			 * pages because peer_addr_count is too large.

 Write generation_end */

 Notify the guest */

/* Check that VI specified by per-port index belongs to a VF.

 * Optionally set VF index and VI index within the VF.

 Returns true when efx_vfdi_fini_all_queues should wake */

 Ensure that all updates are visible to efx_vfdi_fini_all_queues() */

 Flush all the initialized queues */

 Irrespective of success/failure, fini the queues */

 Copy this page into the local address space */

 If we can't get the request, we can't reply to the caller */

 Allow subsequent VF requests */

 Respond to the request */

/* After a reset the event queues inside the guests no longer exist. Fill the

 * event ring in guest memory with VFDI reset events, then (re-initialise) the

 * event queue to raise an interrupt. The guest driver will then recover.

 Reinitialise, arm and trigger evq0 */

 no copy operation; channel must not be reallocated */

 efx_nic_dimension_resources() will reduce vf_count as appopriate */

/* Copy the list of individual addresses into the vfdi_status.peers

 * array and auxiliary pages, protected by %local_lock. Drop that lock

 * and then broadcast the address list to every VF.

 Move the existing peer pages off %local_page_list */

	/* Populate the VF addresses starting from entry 1 (entry 0 is

	 * the PF address)

 Fill the remaining addresses */

 Free any now unused endpoint pages */

 Finally, push the pages */

 Reserve buffer entries */

 Ensure there's room for vf_channel */

 Ensure that VI_BASE is aligned on VI_SCALE */

 At this point we must be ready to accept VFDI requests */

 Disable all interfaces to reconfiguration */

 Flush all reconfiguration work */

 Tear down back-end state */

 USR_EV_REG_VALUE is dword0, so access the VFDI_EV fields directly */

 Resynchronise */

 Reset the request and sequence number */

 Ignore flush completions triggered by an FLR */

 Called from napi. Schedule the reset work item */

 Reset all VFs */

	/* A single threaded workqueue is sufficient. efx_siena_sriov_vfdi() and

	 * efx_siena_sriov_peer_work() spend almost all their time sleeping for

	 * MCDI to complete anyway

 This cannot be changed while TX queues are running */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2011-2013 Solarflare Communications Inc.

 temperature */

 cooling device, probably a heatsink */

 voltage */

 current */

 power */

 though nonsense for a heatsink */

	/* Deal gracefully with the board having more drivers than we

 Use cached value if last update was < 1 s ago */

 Copy out the requested entry */

 Convert temperature from degrees to milli-degrees Celsius */

 Convert power from watts to microwatts */

 No conversion needed */

 Convert temperature from degrees to milli-degrees Celsius */

 Convert power from watts to microwatts */

 No conversion needed */

 Find out how many sensors are present */

 Don't create a device if there are none */

	/* Allocate space for the maximum possible number of

	 * attributes for this set of sensors:

	 * value, min, max, crit, alarm and label for each sensor.

 Find next sensor type or exit if there is none */

 Check again for short response */

 Skip sensors specific to a different port */

 1-based */

			/* This is likely to be a heatsink, but there

			 * is no convention for representing cooling

			 * devices other than fans.

 1-based */

 0-based */

 1-based */

 1-based */

				/* Assume max2 is critical value.

				 * But we have no good way to expose min2.

 CONFIG_SFC_MCDI_MON */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2018 Solarflare Communications Inc.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License version 2 as published

 * by the Free Software Foundation, incorporated herein by reference.

/* This is the percentage fill level below which new RX descriptors

 * will be added to the RX descriptor ring.

/* Number of RX buffers to recycle pages for.  When creating the RX page recycle

 * ring, this number is divided by the number of buffers per page to calculate

 * the number of pages to store in the RX page recycle ring.

/* RX maximum head room required.

 *

 * This must be at least 1 to prevent overflow, plus one packet-worth

 * to allow pipelined receives.

 Check the RX page recycle ring for a page that can be reused. */

 page_remove cannot exceed page_add. */

 If page_count is 1 then we hold the only reference to this page. */

/* Attempt to recycle the page if there is an RX recycle ring; the page can

 * only be added if this is the final RX buffer, to prevent pages being used in

 * the descriptor ring and appearing in the recycle ring simultaneously.

 Only recycle the page after processing the final buffer. */

		/* The next slot in the recycle ring is available, but

		 * increment page_remove if the read pointer currently

		 * points here.

 Recycle the pages that are used by buffers that have just been received. */

 Set the RX recycle ring size */

 CONFIG_PPC64 */

 Unmap and release the pages in the recycle ring. Remove the ring. */

 Release the page reference we hold for the buffer. */

 If this is the last buffer in a page, unmap and free it. */

 Create the smallest power-of-two aligned ring */

 Allocate RX buffers */

 Initialise ptr fields */

 Initialise limit fields */

 Initialise XDP queue information */

 Set up RX descriptor ring */

 Release RX buffers from the current read ptr to the write ptr */

/* Unmap a DMA-mapped page.  This function is only called for the final RX

 * buffer in a page.

 Post an event to cause NAPI to run and refill the queue */

/* efx_init_rx_buffers - create EFX_RX_BATCH page-based RX buffers

 *

 * @rx_queue:		Efx RX queue

 *

 * This allocates a batch of pages, maps them for DMA, and populates

 * struct efx_rx_buffers for each one. Return a negative error code or

 * 0 on success. If a single page can be used for multiple buffers,

 * then the page will either be inserted fully, or not at all.

/* efx_fast_push_rx_descriptors - push new RX descriptors quickly

 * @rx_queue:		RX descriptor queue

 *

 * This will aim to fill the RX descriptor queue up to

 * @rx_queue->@max_fill. If there is insufficient atomic

 * memory to do so, a slow fill will be scheduled.

 *

 * The caller must provide serialisation (none is used here). In practise,

 * this means this function must run from the NAPI handler, or be called

 * when NAPI is disabled.

 Calculate current fill level, and exit if we don't need to fill */

 Record minimum fill level */

 Ensure that we don't leave the rx queue empty */

/* Pass a received packet up through GRO.  GRO can handle pages

 * regardless of checksum state and skbs with a good checksum.

/* RSS contexts.  We're using linked lists and crappy O(n) algorithms, because

 * (a) this is an infrequent control-plane operation and (b) n is small (max 64)

 Don't use zero, that refers to the master RSS context */

 Search for first gap in the numbering */

		/* Check for wrap.  If this happens, we have nearly 2^32

		 * allocated RSS contexts, which seems unlikely.

 Create the new entry */

 Insert the new entry into the gap */

/**

 * efx_filter_is_mc_recipient - test whether spec is a multicast recipient

 * @spec: Specification to test

 *

 * Return: %true if the specification is a non-drop RX filter that

 * matches a local MAC address I/G bit value of 1 or matches a local

 * IPv4 or IPv6 address value in the respective multicast address

 * range.  Otherwise %false.

 ARFS is currently updating this entry, leave it */

		/* ARFS tried and failed to update this, so it's probably out

		 * of date.  Remove the filter and the ARFS rule entry.

 can't happen */

		/* ARFS has moved on, so old filter is not needed.  Since we did

		 * not mark the rule with EFX_ARFS_FILTER_ID_REMOVING, it will

		 * not be removed by efx_rps_hash_del() subsequently.

 Remove it iff ARFS wants to. */

			/* Someone already reused the entry.  We know that if

			 * this check doesn't fire (i.e. filter_id == REMOVING)

			 * then the REMOVING mark was put there by our caller,

			 * because caller is holding a lock on filter table and

			 * only holders of that lock set REMOVING.

 We didn't find it. */

 Discard 'priority' part of EF10+ filter ID (mcdi_filters) */

		/* The rule might have already gone, if someone else's request

		 * for the same spec was already worked and then expired before

		 * we got around to our work.  In that case we have nothing

		 * tying us to an arfs_id, meaning that as soon as the filter

		 * is considered for expiry it will be removed.

		/* Remember this so we can check whether to expire the filter

		 * later.

		/* We're overloading the NIC's filter tables, so let's do a

		 * chunk of extra expiry work.

 Release references */

 find a free slot */

 Add it to ARFS hash table */

 Skip if existing or pending filter already does the right thing */

		/* Without an ARFS hash table, we just use arfs_id 0 for all

		 * filters.  This means if multiple flows hash to the same

		 * flow_id, all but the most recently touched will be eligible

		 * for expiry.

 Queue the request */

		/* If we were called with a quota that exceeds the total number

		 * of filters in the table (which shouldn't happen, but could

		 * if two callers race), ensure that we don't loop forever -

		 * stop when we've examined every row of the table.

 CONFIG_RFS_ACCEL */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2018 Solarflare Communications Inc.

 * Copyright 2019-2020 Xilinx Inc.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License version 2 as published

 * by the Free Software Foundation, incorporated herein by reference.

/* Number of bytes at start of vendor specified extended capability that indicate

 * that the capability is vendor specified. i.e. offset from value returned by

 * pci_find_next_ext_capability() to beginning of vendor specified capability

 * header.

 Expected size of a Xilinx continuation address table entry. */

 Number of bytes to offset when reading bit position x with dword accessors. */

/* Parse a Xilinx capabilities table entry describing a continuation to a new

 * sub-table.

 Temporarily map new BAR. */

 Put old BAR back. */

/* Iterate over the Xilinx capabilities table in the currently mapped BAR and

 * call ef100_pci_parse_ef100_entry() on any EF100 entries and

 * ef100_pci_parse_continue_entry() on any table continuations.

 Ignore unknown table entries. */

/* Call ef100_pci_walk_xilinx_table() for the Xilinx capabilities table pointed

 * to by this PCI_EXT_CAP_ID_VNDR.

 Get optional extension to 64bit offset. */

 Temporarily map BAR. */

 Unmap temporarily mapped BAR. */

/* Call ef100_pci_parse_ef100_entry() for each Xilinx PCI_EXT_CAP_ID_VNDR

 * capability.

 Get length of whole capability - i.e. starting at cap */

/* Final NIC shutdown

 * This is called only at module unload (or hotplug removal).  A PF can call

 * this on its VFs to ensure they are unbound first.

	/* Unregistering our netdev notifier triggers unbinding of TC indirect

	 * blocks, so we have to do it before PCI removal.

 Allocate and initialise a struct net_device and struct efx_nic */

 Extended capability not found - use defaults. */

 Set up basic I/O (BAR mappings etc) */

 PCI device ID table */

 Riverhead PF */

 Riverhead VF */

 end of list */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2018 Solarflare Communications Inc.

 * Copyright 2019-2020 Xilinx Inc.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License version 2 as published

 * by the Free Software Foundation, incorporated herein by reference.

 This is the maximum number of descriptor rings supported by the QDMA */

/*	Ethtool options available

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2019 Solarflare Communications Inc.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License version 2 as published

 * by the Free Software Foundation, incorporated herein by reference.

 -EALREADY means nothing to free, so ignore */

 Fill event queue with all ones (i.e. empty events) */

 INIT_EVQ expects index in vector table, not absolute */

		/* Use the new generic approach to specifying event queue

		 * configuration, requesting lower latency or higher throughput.

		 * The options that actually get used appear in the output.

		/* TSOv2 implies IP header checksum offload for TSO frames,

		 * so we can safely disable IP header checksum offload for

		 * everything else.  If we don't have TSOv2, then we have to

		 * enable IP header checksum offload, which is strictly

		 * incorrect but better than breaking TSO.

				/* This flag was removed from mcdi_pcol.h for

				 * the non-_EXT version of INIT_TXQ.  However,

				 * firmware still honours it.

 Retry without TSOv2 if we're short on contexts. */

	/* If the MC has just rebooted, the TX/RX queues will have already been

	 * torn down, but efx->active_queues needs to be set to zero.

 Do not attempt to write to the NIC during EEH recovery */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2018 Solarflare Communications Inc.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License version 2 as published

 * by the Free Software Foundation, incorporated herein by reference.

/* This is the first interrupt mode to try out of:

 * 0 => MSI-X

 * 1 => MSI

 * 2 => legacy

/* This is the requested number of CPUs to use for Receive-Side Scaling (RSS),

 * i.e. the number of CPUs among which we may distribute simultaneous

 * interrupt handling.

 *

 * Cards without MSI-X will only target one CPU via legacy or MSI interrupt.

 * The default (0) means to assign an interrupt to each core.

/* This is the weight assigned to each of the (per-channel) virtual

 * NAPI devices.

/***************

 * Housekeeping

/*************

 * INTERRUPTS

	/* If RSS is requested for the PF *and* VFs then we can't write RSS

	 * table entries that are inaccessible to VFs

	/* To allow XDP transmit to happen from arbitrary NAPI contexts

	 * we allocate a TX queue per CPU. We share event queues across

	 * multiple tx queues, assuming tx and ev queues are both

	 * maximum size.

	/* Check resources.

	 * We need a channel per event queue, plus a VI per tx queue.

	 * This may be more pessimistic than it needs to be.

 Ignore XDP tx channels when creating rx channels. */

/* Probe the number and type of interrupts we are able to obtain, and

 * the resulting numbers of channels and RX queues.

 Fall back to single channel MSI */

 Try single interrupt MSI */

 Assume legacy interrupts */

 Assign extra channels if possible, before XDP channels */

 RSS might be usable on VFs even if it is disabled on the PF */

 CONFIG_SMP */

 Remove MSI/MSI-X interrupts */

 Remove legacy interrupt */

/***************

 * EVENT QUEUES

/* Create event queue

 * Event queue memory allocations are done only once.  If the channel

 * is reset, the memory buffer will be reused; this guards against

 * errors during channel reset and also simplifies interrupt handling.

	/* Build an event queue with room for one event per tx and rx buffer,

	 * plus some extra for link state events and MCDI completions.

 Prepare channel's event queue */

 Enable event queue processing and NAPI */

 Make sure the NAPI handler sees the enabled flag set */

 Disable event queue processing and NAPI */

/**************************************************************************

 *

 * Channel handling

 *

 Ensure we do more work eventually even if NAPI poll is not happening */

 Allocate and initialise a channel structure. */

 Higher numbered interrupt modes are less capable! */

/* Allocate and initialise a channel structure, copying parameters

 * (but not resources) from an old channel structure.

 Restart special buffer allocation */

	/* Probe channels in reverse, so that any 'extra' channels

	 * use the start of the buffer table. This allows the traffic

	 * channels to be resized without moving them or wasting the

	 * entries before them.

	/* Not all channels should be reallocated. We must avoid

	 * reallocating their buffer table entries.

 Clone channels (where possible) */

 Swap entry counts and channel pointers */

 Restart buffer table allocation */

 Destroy unused channel structures */

 Swap back */

 Allocate array for XDP TX queue lookup. */

	/* We need to mark which channels really have RX and TX

	 * queues, and adjust the TX queue numbers if we have separate

	 * RX-only and TX-only channels.

				/* If XDP is borrowing queues from net stack, it must use the queue

				 * with no csum offload, which is the first one of the channel

				 * (note: channel->tx_queue_by_type is not initialized yet)

	/* If we have more CPUs than assigned XDP TX queues, assign the already

	 * existing queues to the exceeding CPUs

/*************

 * START/STOP

 Flush the asynchronous MCDI request queue */

 TODO: Is this really a bug? */

 Stop RX refill */

		/* RX packet processing is pipelined, so wait for the

		 * NAPI handler to complete.  At least event queue 0

		 * might be kept active by non-data events, so don't

		 * use napi_synchronize() but actually disable NAPI

		 * temporarily.

/**************************************************************************

 *

 * NAPI interface

 *

/* Process channel's event queue

 *

 * This function is responsible for processing the event queue of a

 * single channel.  The caller must guarantee that this function will

 * never be concurrently called more than once on the same channel,

 * though different channels may be being processed concurrently.

 Prepare the batch receive list */

 Update BQL */

 Receive any packets we queued up */

/* NAPI poll handler

 *

 * NAPI guarantees serialisation of polls of the same device, which

 * provides the guarantee required by efx_process_channel().

 Perhaps expire some ARFS filters */

 Would our quota be >= 20? */

		/* There is no race here; although napi_disable() will

		 * only wait for napi_complete(), this isn't a problem

		 * since efx_nic_eventq_read_ack() will have no effect if

		 * interrupts have already been disabled.

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2018 Solarflare Communications Inc.

 * Copyright 2019-2020 Xilinx Inc.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License version 2 as published

 * by the Free Software Foundation, incorporated herein by reference.

	/* EF100 uses a single TXQ per channel, as all checksum offloading

	 * is configured in the TX descriptor, and there is no TX Pacer for

	 * HIGHPRI queues.

	/* Currently don't handle resource starvation and only accept

	 * our maximum needs and no less.

 Extend the original UC mapping of the memory BAR */

/* Context: process, rtnl_lock() held.

 * Note that the kernel will ignore our return code; this method

 * should really be a void.

 Context: process, rtnl_lock() held. */

	/* in case the MC rebooted while we were stopped, consume the change

	 * to the warm reboot count

	/* Link state detection is normally event-driven; we have

	 * to poll now because we could have missed a change

/* Initiate a packet transmission.  We use one channel per CPU

 * (sharing when we have more CPUs than channels).

 *

 * Context: non-blocking.

 * Note that returning anything other than NETDEV_TX_OK will cause the

 * OS to free the skb.

 Lookout */

/*	Netdev registration

 Always start with carrier off; PHY events will detect the link */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2019 Solarflare Communications Inc.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License version 2 as published

 * by the Free Software Foundation, incorporated herein by reference.

 Reader function */

 Initialiser for a struct efx_sw_stat_desc with type-checking */

 We need rx buffers and interrupts. */

 Hook for Falcon bug 11482 workaround */

	/* Reconfigure the MAC. The PHY *may* generate a link state change event

	 * if the user just changed the advertised capabilities, but there's no

/**

 * efx_fill_test - fill in an individual self-test entry

 * @test_index:		Index of the test

 * @strings:		Ethtool strings, or %NULL

 * @data:		Ethtool test results, or %NULL

 * @test:		Pointer to test result (used only if data != %NULL)

 * @unit_format:	Unit name format (e.g. "chan\%d")

 * @unit_id:		Unit id (e.g. 0 for "chan0")

 * @test_format:	Test name format (e.g. "loopback.\%s.tx.sent")

 * @test_id:		Test id (e.g. "PHYXS" for "loopback.PHYXS.tx_sent")

 *

 * Fill in an individual self-test entry.

 Fill data value, if applicable */

 Fill string, if applicable */

/**

 * efx_fill_loopback_test - fill in a block of loopback self-test entries

 * @efx:		Efx NIC

 * @lb_tests:		Efx loopback self-test results structure

 * @mode:		Loopback test mode

 * @test_index:		Starting index of the test

 * @strings:		Ethtool strings, or %NULL

 * @data:		Ethtool test results, or %NULL

 *

 * Fill in a block of loopback self-test entries.  Return new test

 * index.

/**

 * efx_ethtool_fill_self_tests - get self-test details

 * @efx:		Efx NIC

 * @tests:		Efx self-test results structure, or %NULL

 * @strings:		Ethtool strings, or %NULL

 * @data:		Ethtool test results, or %NULL

 *

 * Get self-test number of strings, strings, and/or test results.

 * Return number of strings (== number of test results).

 *

 * The reason for merging these three functions is to make sure that

 * they can never be inconsistent.

 Event queues */

 Loopback tests */

 No other string sets */

 Get NIC statistics */

 Get software statistics */

 This must be called with rtnl_lock held. */

 Both MACs support pause frames (bidirectional and respond-only) */

 This must be called with rtnl_lock held. */

 GMAC does not support 1000Mbps HD */

 MAC address mask including only I/G bit */

 The above should handle all filters that we insert */

 No RSS */

 Check that user wants us to choose the location */

 Range-check ring_cookie */

 Check for unsupported extensions */

 Hash function is Toeplitz, cannot be changed */

 Hash function is Toeplitz, cannot be changed */

 alloc + delete == Nothing to do */

 Initialise indir table and key to defaults */

 delete this context */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2006-2012 Solarflare Communications Inc.

/* IRQ latency can be enormous because:

 * - All IRQs may be disabled on a CPU for a *long* time by e.g. a

 *   slow serial console or an old IDE driver doing error recovery

 * - The PREEMPT_RT patches mostly deal with this, but also allow a

 *   tasklet or normal task to be given higher priority than our IRQ

 *   threads

 * Try to avoid blaming the hardware for this.

/*

 * Loopback test packet structure

 *

 * The self-test should stress every RSS vector, and unfortunately

 * Falcon only performs RSS on TCP/UDP packets.

 Loopback test source MAC address */

 Interrupt mode names */

/**

 * struct efx_loopback_state - persistent state during a loopback selftest

 * @flush:		Drop all packets in efx_loopback_rx_packet

 * @packet_count:	Number of packets being used in this test

 * @skbs:		An array of skbs transmitted

 * @offload_csum:	Checksums are being offloaded

 * @rx_good:		RX good packet count

 * @rx_bad:		RX bad packet count

 * @payload:		Payload used in tests

 How long to wait for all the packets to arrive (in ms) */

/**************************************************************************

 *

 * MII, NVRAM and register tests

 *

/**************************************************************************

 *

 * Interrupt and event queue testing

 *

 Test generation and receipt of interrupts */

 Wait for arrival of test interrupt. */

 Test generation and receipt of interrupting events */

	/* Wait for arrival of interrupts.  NAPI processing may or may

	 * not complete in time, but we can cope in any case.

			/* Report failure and whether either interrupt or DMA

			 * worked

/**************************************************************************

 *

 * Loopback testing

 * NB Only one loopback test can be executing concurrently.

 *

/* Loopback test RX callback

 * This is called for each received packet during loopback testing.

 If we are just flushing, then drop the packet */

 Check that header exists */

 Check that the ethernet header exists */

 Check packet length */

 Check that IP header matches */

 Check that msg and padding matches */

 Check that iteration matches */

 Increase correct RX count */

 Initialise an efx_selftest_state for a new iteration */

 Initialise the layerII header */

 saddr set later and used as incrementing count */

 Initialise udp header */

 checksum ignored */

 Fill out payload */

 Fill out remaining state members */

 Transmit N copies of buffer */

		/* Allocate an skb, holding an extra reference for

		/* Copy the payload in, incrementing the source address to

		/* Ensure everything we've written is visible to the

 Defer cleaning up the other skbs for the caller */

	/* Count the number of tx completions, and decrement the refcnt. Any

 Check TX completion and received packet counts */

		/* Don't free the skbs; they will be picked up on TX

		 * overflow or channel teardown.

 Allow to fall through so we see the RX errors as well */

 We may always be up to a flush away from our desired packet total */

 Fall through */

 Update loopback test structure */

 Determine how many packets to send */

		/* This will normally complete very quickly, but be

			/* Wait a while to ensure there are no packets

/* Wait for link up. On Falcon, we would prefer to rely on efx_monitor, but

 * any contention on the mac lock (via e.g. efx_mac_mcast_work) causes it

 * to delay and retry. Therefore, it's safer to just poll directly. Wait

	/* Set the port loopback_selftest member. From this point on

	 * all received packets will be dropped. Mark the state as

 Test all supported loopback modes */

 Move the port into the specified loopback mode. */

 Test all enabled types of TX queue */

 Remove the flush. The caller will remove the loopback setting */

/**************************************************************************

 *

 * Entry point

 *

	/* Online (i.e. non-disruptive) testing

	/* Offline (i.e. disruptive) testing

	/* Detach the device so the kernel doesn't transmit during the

	 * loopback test and the watchdog timeout doesn't fire.

	/* Ensure that the phy is powered and out of loopback

 restore the PHY to the previous state */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2018 Solarflare Communications Inc.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License version 2 as published

 * by the Free Software Foundation, incorporated herein by reference.

 Create the smallest power-of-two aligned ring */

 Allocate software ring */

 Allocate hardware ring, determine TXQ type */

 Set up TX descriptor ring */

 Free any buffers left in the ring */

/* Remove packets from the TX queue

 *

 * This removes packets from the TX queue, up to and including the

 * specified index.

 Ensure that read_count is flushed. */

	/* See if we need to restart the netif queue.  This memory

	 * barrier ensures that we write read_count (inside

	 * efx_dequeue_buffers()) before reading the queue status.

/* Remove buffers put into a tx_queue for the current packet.

 * None of the buffers must have an skb attached.

 Work backwards until we hit the original insert pointer value */

 Map the fragment taking account of NIC-dependent DMA limits. */

 Map all data from an SKB for DMA and create descriptors on the queue. */

 Map header data. */

		/* For TSO we need to put the header in to a separate

		 * descriptor. Map this separately if necessary.

 Add descriptors for each fragment. */

		/* The final descriptor for a fragment is responsible for

		 * unmapping the whole fragment.

			/* Store SKB details with the final buffer for

			 * the completion.

 Move on to the next fragment. */

	/* Header and payload descriptor for each output segment, plus

	 * one for every input fragment boundary within a segment

 Possibly one more per segment for option descriptors */

 Possibly more for PCIe page boundaries within input fragments */

/*

 * Fallback to software TSO.

 *

 * This is used if we are unable to send a GSO packet through hardware TSO.

 * This should only ever happen due to per-queue restrictions - unsupported

 * packets should first be filtered by the feature flags.

 *

 * Returns 0 on success, error code otherwise.

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2005-2013 Solarflare Communications Inc.

 EFX_USE_PIO */

 We need to consider all queues that the net core sees as one */

	/* We used the stale old_read_count above, which gives us a

	 * pessimistic estimate of the fill level (which may even

	 * validly be >= efx->txq_entries).  Now try again using

	 * read_count (more likely to be a cache miss).

	 *

	 * If we read read_count and then conditionally stop the

	 * queue, it is possible for the completion path to race with

	 * us and complete all outstanding descriptors in the middle,

	 * after which there will be no more completions to wake it.

	 * Therefore we stop the queue first, then read read_count

	 * (with a memory barrier to ensure the ordering), then

	 * restart the queue if the fill level turns out to be low

	 * enough.

/* Copy to PIO, respecting that writes to PIO buffers must be dword aligned.

 * Advances piobuf pointer. Leaves additional data in the copy buffer.

/* Copy to PIO, respecting dword alignment, popping data from copy buffer first.

 * Advances piobuf pointer. Leaves additional data in the copy buffer.

 if the copy buffer is partially full, fill it up and write */

 if we didn't fill it up then we're done for now */

 if there's anything in it, write the whole buffer, including junk */

/* Traverse skb structure and copy fragments in to PIO buffer.

 * Advances piobuf pointer.

	/* Copy to PIO buffer. Ensure the writes are padded to the end

	 * of a cache line, as this is required for write-combining to be

	 * effective on at least x86.

		/* The size of the copy buffer will ensure all writes

		 * are the size of a cache line.

		/* Pad the write to the size of a cache line.

		 * We can do this because we know the skb_shared_info struct is

		 * after the source, and the destination buffer is big enough.

/* Decide whether we can use TX PIO, ie. write packet data directly into

 * a buffer on the device.  This can reduce latency at the expense of

 * throughput, so we only do this if both hardware and software TX rings

 * are empty, including all queues for the channel.  This also ensures that

 * only one packet at a time can be using the PIO buffer. If the xmit_more

 * flag is set then we don't use this - there'll be another packet along

 * shortly and we want to hold off the doorbell.

 EFX_USE_PIO */

/* Send any pending traffic for a channel. xmit_more is shared across all

 * queues for a channel, so we must check all of them.

/*

 * Add a socket buffer to a TX queue

 *

 * This maps all fragments of a socket buffer for DMA and adds them to

 * the TX queue.  The queue's insert pointer will be incremented by

 * the number of fragments in the socket buffer.

 *

 * If any DMA mapping fails, any mapped fragments will be unmapped,

 * the queue's insert pointer will be restored to its original value.

 *

 * This function is split out from efx_hard_start_xmit to allow the

 * loopback test to direct packets via specific TX queues.

 *

 * Returns NETDEV_TX_OK.

 * You must hold netif_tx_lock() to call this function.

 Don't use TSO for a single segment. */

	/* Handle TSO first - it's *possible* (although unlikely) that we might

	 * be passed a packet to segment that's smaller than the copybreak/PIO

	 * size limit.

 No TSO on this queue, SW fallback needed */

 Use PIO for short packets with an empty queue. */

 Pad short packets or coalesce short fragmented packets. */

 Map for DMA and create descriptors if we haven't done so already. */

 Pass off to hardware */

	/* If we're not expecting another transmit and we had something to push

	 * on this queue or a partner queue then we need to push here to get the

	 * previous packets out.

/* Transmit a packet from an XDP buffer

 *

 * Returns number of packets sent on success, error code otherwise.

 * Runs in NAPI context, either in our poll (for XDP TX) or a different NIC

 * (for XDP redirect).

	/* If we're borrowing net stack queues we have to handle stop-restart

	 * or we might block the queue and it will be considered as frozen

	/* Check for available space. We should never need multiple

	 * descriptors per frame.

 We'll want a descriptor for this tx. */

 Map for DMA. */

  Create descriptor and set up for unmapping DMA. */

 Pass mapped frames to hardware. */

/* Initiate a packet transmission.  We use one channel per CPU

 * (sharing when we have more CPUs than channels).

 *

 * Context: non-blocking.

 * Should always return NETDEV_TX_OK and consume the skb.

 PTP "event" packet */

		/* There may be existing transmits on the channel that are

		 * waiting for this packet to trigger the doorbell write.

		 * We need to send the packets at this point.

		/* We don't have a TXQ of the right type.

		 * This should never happen, as we don't advertise offload

		 * features unless we can support them.

		/* If we're not expecting another transmit and we had something to push

		 * on this queue or a partner queue then we need to push here to get the

		 * previous packets out.

 Need to check the flag before dequeueing. */

 Must be inverse of queue lookup in efx_hard_start_xmit() */

 Only Siena supported highpri queues */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2018 Solarflare Communications Inc.

 * Copyright 2019-2020 Xilinx Inc.

 *

 * This program is free software; you can redistribute it and/or modify it

 * under the terms of the GNU General Public License version 2 as published

 * by the Free Software Foundation, incorporated herein by reference.

 The maximum size of a shared RSS context */

 TODO: this should really be from the mcdi protocol export */

 An arbitrary search limit for the software hash table */

/*

 * Decide whether a filter should be exclusive or else should allow

 * delivery to additional recipients.  Currently we decide that

 * filters for specific local unicast MAC and IP addresses are

 * exclusive.

	/*

	 * Convert match flags and values.  Unlike almost

	 * everything else in MCDI, these fields are in

	 * network byte order.

	/*

	 * Handle encap filters first.  They will always be mismatch

	 * (unknown UC or MC) filters

		/*

		 * ether_type and outer_ip_proto need to be variables

		 * because COPY_VALUE wants to memcpy them

			/*

			 * We always need to set the type field, even

			 * though we're not matching on the TNI.

 If RSS filter, caller better have given us an RSS context */

		/*

		 * We don't have the ability to return an error, so we'll just

		 * log a warning and disable RSS for the filter.

 to match efx_farch_filter_insert() */

 inner or outer based on encap type */

 always outer */

 special handling for encap type, and mismatch */

 Did we map them all? */

 For now, only support RX filters */

	/* Find any existing filters with the same match tuple or

	 * else a free slot to insert at.

 This is the only one */

	/* Once we reach the maximum search depth, use the first suitable

	 * slot, or return -EBUSY if there was none

 Create a software table entry if necessary. */

 Just make sure it won't be removed */

 Actually insert the filter on the HW */

		/* The MC rebooted under us, causing it to reject our filter

		 * insertion as pointing to an invalid VI (spec->dmaq_id).

 Finalise the software table entry */

 Update the fields that may differ */

		/* We failed to replace, so the old filter is still present.

		 * Roll back the software table to reflect this.  In fact the

		 * efx_mcdi_filter_set_entry() call below will do the right

		 * thing, so nothing extra is needed here.

	/* Remove and finalise entries for lower-priority multicast

	 * recipients

 If successful, return the inserted filter ID */

/*

 * Remove a filter.

 * If !by_index, remove by ID

 * If by_index, remove by index

 * Filter ID may come from userland and must be range-checked.

 * Caller must hold efx->filter_sem for read, and efx->filter_state->lock

 * for write.

 Just remove flags */

 Reset to an automatic filter */

 Really remove the filter */

 Filter removed OK or didn't actually exist */

 Remove filters that weren't renewed. */

 Caller must hold efx->filter_sem for read */

 Insert/renew filters */

 Fall back to promiscuous */

 keep invalid ID, and carry on */

 Also need an Ethernet broadcast filter */

 Fall back to promiscuous */

			/*

			 * don't insert encap filters on non-supporting

			 * platforms. ID will be left as INVALID.

		/*

		 * unprivileged functions can't insert mismatch filters

		 * for encapsulated or unicast traffic, so downgrade

		 * those warnings to debug.

 mapping from encap types to default filter IDs (multicast) */

 quick bounds check (BCAST result impossible) */

 then follow map */

 Also need an Ethernet broadcast filter */

 Roll back the mc_def filter */

 mapping from encap types to default filter IDs (unicast) */

 quick bounds check (BCAST result impossible) */

 then follow map */

/*

 * Caller must hold efx->filter_sem for read if race against

 * efx_mcdi_filter_table_remove() is possible

	/*

	 * Do not install unspecified VID if VLAN filtering is enabled.

	 * Do not install all specified VIDs if VLAN filtering is disabled.

 Insert/renew unicast filters */

		/*

		 * If any of the filters failed to insert, fall back to

		 * promiscuous mode - add in the uc_def filter.  But keep

		 * our individual unicast filters.

	/*

	 * Insert/renew multicast filters

	 *

	 * If changing promiscuous state with cascaded multicast filters, remove

	 * old filters first, so that packets are dropped rather than duplicated

			/*

			 * If we failed to insert promiscuous filters, rollback

			 * and fall back to individual multicast filters

 Changing promisc state, so remove old filters */

			/*

			 * If we failed to insert promiscuous filters, don't

			 * rollback.  Regardless, also insert the mc_list,

			 * unless it's incomplete due to overflow

		/*

		 * If any filters failed to insert, rollback and fall back to

		 * promiscuous mode - mc_def filter and maybe broadcast.  If

		 * that fails, roll back again and insert as many of our

		 * individual multicast filters as we can.

 Changing promisc state, so remove old filters */

 encap filters must specify encap type */

 and imply ethertype and ip proto */

 VLAN tags refer to the outer packet */

 everything else refers to the inner packet */

 Did we map them all? */

 Find out which RX filter types are supported, and their priorities */

 already probed */

/*

 * Caller must hold efx->filter_sem for read if race against

 * efx_mcdi_filter_table_remove() is possible

	/*

	 * This can happen validly if the MC's capabilities have changed, so

	 * is not an error.

	/*

	 * If we were called without locking, then it's not safe to free

	 * the table as others might be using it.  So we just WARN, leak

	 * the memory, and potentially get an inconsistent filter table

	 * state.

	 * This should never actually happen.

 Mark old per-VLAN filters that may need to be removed */

/*

 * Mark old filters that may need to be removed.

 * Caller must hold efx->filter_sem for read if race against

 * efx_mcdi_filter_table_remove() is possible

 See comment in efx_mcdi_filter_table_remove() */

 See comment in efx_mcdi_filter_table_remove() */

 See comment in efx_mcdi_filter_table_remove() */

/*

 * Caller must hold efx->filter_sem for read if race against

 * efx_mcdi_filter_table_remove() is possible

	/*

	 * Copy/convert the address lists; add the primary station

	 * address and broadcast address

	/*

	 * If VLAN filtering changes, all old filters are finally removed.

	 * Do it in advance to avoid conflicts for unicast untagged and

	 * VLAN 0 tagged filters.

 In the absence of the table, we always return 0 to ARFS. */

 ARFS table doesn't know of this filter, so remove it */

 remove operation will kfree spec */

	/*

	 * At this point (since we dropped the lock), another thread might queue

	 * up a fresh insertion request (but the actual insertion will be held

	 * up by our possession of the filter table lock).  In that case, it

	 * will set rule->filter_id to EFX_ARFS_FILTER_ID_PENDING, meaning that

	 * the rule is not removed by efx_rps_hash_del() below.

	/*

	 * While we can't safely dereference rule (we dropped the lock), we can

	 * still test it for NULL.

 Expiring, so remove entry from ARFS table */

 CONFIG_RFS_ACCEL */

	/*

	 * Firmware had a bug (sfc bug 61952) where it would not actually

	 * fill in the flags field in the response to MC_CMD_RSS_CONTEXT_GET_FLAGS.

	 * This meant that it would always contain whatever was previously

	 * in the MCDI buffer.  Fortunately, all firmware versions with

	 * this bug have the same default flags value for a newly-allocated

	 * RSS context, and the only time we want to get the flags is just

	 * after allocating.  Moreover, the response has a 32-bit hole

	 * where the context ID would be in the request, so we can use an

	 * overlength buffer in the request and pre-fill the flags field

	 * with what we believe the default to be.  Thus if the firmware

	 * has the bug, it will leave our pre-filled value in the flags

	 * field of the response, and we will get the right answer.

	 *

	 * However, this does mean that this function should NOT be used if

	 * the RSS context flags might not be their defaults - it is ONLY

	 * reliably correct for a newly-allocated RSS context.

 Check we have a hole for the context ID */

/*

 * Attempt to enable 4-tuple UDP hashing on the specified RSS context.

 * If we fail, we just leave the RSS context at its default hash settings,

 * which is safe but may slightly reduce performance.

 * Defaults are 4-tuple for TCP and 2-tuple for UDP and other-IP, so we

 * just need to set the UDP ports flags (for both IP versions).

 Succeeded, so UDP 4-tuple is now enabled */

	/* This iterates over the length of efx->rss_context.rx_indir_table, but

	 * copies bytes from rx_indir_table.  That's because the latter is a

	 * pointer rather than an array, but should have the same length.

	 * The efx->rss_context.rx_hash_key loop below is similar.

 Delete this context */

 previous NIC RSS context is gone */

 so try to allocate a new one */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2006-2013 Solarflare Communications Inc.

/**************************************************************************

 *

 * Generic buffer handling

 * These buffers are used for interrupt status, MAC stats, etc.

 *

/* Check whether an event is present in the eventq at the current

 * read pointer.  Only useful for self-test.

/* Hook interrupt handler(s)

 * Try MSI and then legacy interrupts.

 Hook MSI or MSI-X interrupt */

 Not shared */

 Disable MSI/MSI-X interrupts */

 Disable legacy interrupt */

 Register dump */

 last Falcon arch revision */

 latest EF10 revision */

 INT_ACK_KER is WO */

 INT_ISR0 is RC */

 EE_VPD_SW_CNTL and EE_VPD_SW_DATA are not used */

 PMBX_DBG_IADDR and PBMX_DBG_IDATA are indirect */

 PCIE_CORE_INDIRECT is indirect */

 FATAL_INTR_KER and FATAL_INTR_CHAR are partly RC */

 DEBUG_DATA_OUT is not used */

 DRV_EV is WO */

 BUF_TBL_UPD is WO */

 RX_FLUSH_DESCQ is WO */

 RX_NODESC_DROP is RC */

 RX_DEBUG, RX_PUSH_DROP are not used */

 TX_FLUSH_DESCQ is WO */

 TX_PUSH_DROP is not used */

 TX_PACE_DROP_QID is RC */

 MD_STAT is RC */

 GM_IPG and GM_HD are not used */

 GM_TEST is not used */

 XM_MGT_INT_MSK (note no 'A') is RC */

 XX_PRBS_CTL, XX_PRBS_CHK and XX_PRBS_ERR are not used */

 XX_CORE_STAT is partly RC */

 DRIVER is not used */

 EVQ_RPTR, TIMER_COMMAND, USR_EV and {RX,TX}_DESC_UPD are WO */

	/* We can't reasonably read all of the buffer table (up to 8MB!).

	 * However this driver will only use a few entries.  Reading

	 * 1K entries allows for some expansion of queue count and

 TX_FILTER_TBL0 is huge and not used by this driver */

 MSIX_PBA_TABLE is not mapped */

 SRM_DBG is not mapped (and is redundant with BUF_FLL_TBL) */

 32-bit SRAM */

 64-bit SRAM */

 128-bit-readable register */

 128-bit register, interleaved */

/**

 * efx_nic_describe_stats - Describe supported statistics for ethtool

 * @desc: Array of &struct efx_hw_stat_desc describing the statistics

 * @count: Length of the @desc array

 * @mask: Bitmask of which elements of @desc are enabled

 * @names: Buffer to copy names to, or %NULL.  The names are copied

 *	starting at intervals of %ETH_GSTRING_LEN bytes.

 *

 * Returns the number of visible statistics, i.e. the number of set

 * bits in the first @count bits of @mask for which a name is defined.

/**

 * efx_nic_copy_stats - Copy stats from the DMA buffer in to an

 *	intermediate buffer. This is used to get a consistent

 *	set of stats while the DMA buffer can be written at any time

 *	by the NIC.

 * @efx: The associated NIC.

 * @dest: Destination buffer. Must be the same size as the DMA buffer.

	/* If we're unlucky enough to read statistics during the DMA, wait

	 * up to 10ms for it to finish (typically takes <500us)

 return good data */

/**

 * efx_nic_update_stats - Convert statistics DMA buffer to array of u64

 * @desc: Array of &struct efx_hw_stat_desc describing the DMA buffer

 *	layout.  DMA widths of 0, 16, 32 and 64 are supported; where

 *	the width is specified as 0 the corresponding element of

 *	@stats is not updated.

 * @count: Length of the @desc array

 * @mask: Bitmask of which elements of @desc are enabled

 * @stats: Buffer to update with the converted statistics.  The length

 *	of this array must be at least @count.

 * @dma_buf: DMA buffer containing hardware statistics

 * @accumulate: If set, the converted values will be added rather than

 *	directly stored to the corresponding elements of @stats

 if down, or this is the first update after coming up */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2006-2013 Solarflare Communications Inc.

 Hardware control for SFC4000 (aka Falcon). */

/**************************************************************************

 *

 * NIC stats

 *

 **************************************************************************

 48-bit stats are zero-padded to 64 on DMA */		\

/**************************************************************************

 *

 * Basic SPI command set and bit definitions

 *

 Write status register */

 Write data to memory array */

 Read data from memory array */

 Reset write enable latch */

 Read status register */

 Set write enable latch */

 SST: Enable write to status register */

 Write-protect pin enabled */

 Block protection bit 2 */

 Block protection bit 1 */

 Block protection bit 0 */

 State of the write enable latch */

 Device busy flag */

/**************************************************************************

 *

 * Non-volatile memory layout

 *

 **************************************************************************

/* SFC4000 flash is partitioned into:

 *     0-0x400       chip and board config (see struct falcon_nvconfig)

 *     0x400-0x8000  unused (or may contain VPD if EEPROM not present)

 *     0x8000-end    boot code (mapped to PCI expansion ROM)

 * SFC4000 small EEPROM (size < 0x400) is used for VPD only.

 * SFC4000 large EEPROM (size >= 0x400) is partitioned into:

 *     0-0x400       chip and board config

 *     configurable  VPD

 *     0x800-0x1800  boot config

 * Aside from the chip and board config, all of these are optional and may

 * be absent or truncated depending on the devices used.

 Board configuration v2 (v1 is obsolete; later versions are compatible) */

 Board configuration v3 extra information */

 Bit numbers for spi_device_type */

 0x300 */

 0x310 */

 0x320 */

 0x330 */

 0x340 */

 0x350 */

 0x360 */

 0x370 */

 0x380 */

 0x390 */

 0x3A0 */

 0x3B0 */

 0x3C0 */

************************************************************************/

/* "Large" EEPROM device: Atmel AT25640 or similar

/* Default flash device: Atmel AT25F1024

/**************************************************************************

 *

 * I2C bus - this is a bit-bashing interface using GPIO pins

 * Note that it uses the output enables to tristate the outputs

 * SDA is the data pin and SCL is the clock

 *

 **************************************************************************

 Wait up to 50 ms for slave to let us pull SCL high */

 Set timer register */

	/* Wait for the tx and rx fifo's to get to the next packet boundary

	 * (~1ms without back-pressure), then to drain the remainder of the

/* Acknowledge a legacy interrupt from Falcon

 *

 * This acknowledges a legacy (not MSI) interrupt via INT_ACK_KER_REG.

 *

 * Due to SFC bug 3706 (silicon revision <=A1) reads can be duplicated in the

 * BIU. Interrupt acknowledge is read sensitive so must write instead

 * (then read to ensure the BIU collector is flushed)

 *

 * NB most hardware supports MSI interrupts

	/* Check to see if this is our interrupt.  If it isn't, we

	 * exit without having touched the hardware.

 Check to see if we have a serious error condition */

	/* Determine interrupting queues, clear interrupt status

	 * register and acknowledge the device interrupt.

 Ensure the vector is cleared before interrupt ack */

/**************************************************************************

 *

 * RSS

 *

 **************************************************************************

 Set hash key for IPv4 */

/**************************************************************************

 *

 * EEPROM/flash

 *

 **************************************************************************

 Wait for SPI command completion */

	/* Most commands will finish quickly, so we start polling at

	 * very short intervals.  Sometimes the command may have to

	 * wait for VPD or expansion ROM access outside of our

 Input validation */

 Check that previous command is not still running */

 Program address register, if we have an address */

 Program data register, if we have data */

 Issue read/write command */

 Wait for read/write to complete */

 Read data */

 Avoid locking up the system */

 Wait up to 10 ms for buffered write completion */

 Avoid locking up the system */

 Wait up to 4s for flash/EEPROM to finish a slow operation. */

 already unlocked */

 Verify the entire region has been wiped */

 Avoid locking up the system */

 Allocate space for maximum number of partitions */

 CONFIG_SFC_FALCON_MTD */

/**************************************************************************

 *

 * XMAC operations

 *

 **************************************************************************

 Configure the XAUI driver that is an output from Falcon */

	/* Move the XAUI into low power, unless there is no PHY, in

 Don't fetch MAC statistics over an XMAC reset */

 Start reset sequence */

 Wait up to 10 ms for completion, then reinitialise */

 We expect xgmii faults if the wireside link is down */

	/* We can only use this interrupt to signal the negative edge of

 Read link status */

 Clear link status ready for next read */

	/*

	 * Check MAC's XGXS link status except when using XGMII loopback

	 * which bypasses the XGXS block.

	 * If possible, check PHY's XGXS link status except when using

	 * MAC loopback.

 Configure MAC  - cut-thru mode is hard wired on */

 Configure TX */

 Configure RX */

 Set frame length */

 MAX PAUSE TIME */

 Set MAC address */

	/* XGXS block is flaky and will need to be reset if moving

 The PHY driver may have turned XAUI off */

 Try to bring up the Falcon side of the Falcon-Phy XAUI link */

 XAUI link is expected to be down */

 We expect xgmii faults if the wireside link is down */

/**************************************************************************

 *

 * MAC wrapper

 *

 **************************************************************************

		/* It's not safe to use GLB_CTL_REG to reset the

		 * macs, so instead use the internal MAC resets

 Mac stats will fail whist the TX fifo is draining */

	/* Ensure the correct MAC is selected before statistics

 There is no point in draining more than once */

 Isolate the MAC -> RX */

 Isolate TX -> MAC */

	/* MAC_LINK_STATUS controls MAC backpressure but doesn't work

	 * as advertised.  Disable to ensure packets are not

	 * indefinitely held and TX queue can be flushed at any point

 max pause time */,

 always set */

	/* On B0, MAC backpressure can be disabled and packets get

 Restore the multicast hash registers. */

	/* Enable XOFF signal from RX FIFO (we enabled it during NIC

 Unisolate the MAC -> RX */

 ensure done flag is clear */

 Initiate DMA transfer of stats */

 read the done flag before the stats */

	/* Poll the PHY link state *before* reconfiguring it. This means we

	 * will pick up the correct speed (in loopback) to select the correct

	 * MAC.

 Synchronise efx->link_state with the kernel */

/* TX flow control may automatically turn itself off if the link

 * partner (intermittently) stops responding to pause frames. There

 * isn't any indication that this has happened, so the best we do is

 * leave it up to the user to spot this and fix it by cycling transmit

 * flow control on this end.

 Schedule a reset to recover */

 Recover by resetting the EM block */

/**************************************************************************

 *

 * PHY access via GMII

 *

 **************************************************************************

 Wait for GMII access to complete */

 wait up to 50ms - taken max from datasheet */

 Write an MDIO register of a PHY connected to Falcon. */

 Check MDIO not currently being accessed */

 Write the address/ID register */

 Write data */

 Wait for data to be written */

 Abort the write operation */

 Read an MDIO register of a PHY connected to Falcon. */

 Check MDIO not currently being accessed */

 Request data to be read */

 Wait for data to become available */

 Abort the read operation */

 This call is responsible for hooking in the MAC and PHY operations */

 Fill out MDIO structure and loopback modes */

 Initial assumption */

 Hardware flow ctrl. FalconA RX FIFO too small for pause generation */

 Allocate buffer for stats */

 Global events are basically PHY events */

 Ignored */

/**************************************************************************

 *

 * Falcon test code

 *

		/* We need the 312 clock from the PHY to test the XMAC

/**************************************************************************

 *

 * Device reset

 *

 **************************************************************************

		/* These can occasionally occur due to hardware bugs.

		 * We try to reset without disrupting the link.

/* Resets NIC to known state.  This routine must be called in process

 Initiate device reset */

 exclude PHY from "invisible" reset */

 exclude EEPROM/flash and PCIe */

 Restore PCI configuration if needed */

 Assert that reset complete */

 pci_save_state() and pci_restore_state() MUST be called in pairs */

/* Zeroes out the SRAM contents.  This routine must be called in

 * process context and is allowed to sleep.

 Set the SRAM wake/sleep GPIO appropriately. */

 Initiate SRAM reset */

 Wait for SRAM reset to complete */

 SRAM reset is slow; expect around 16ms */

 Check for reset complete */

 wait up to 0.4 sec */

 Extract non-volatile configuration */

 Read the MAC addresses */

 Probe all SPI devices on the NIC */

		/* Disable VPD and set clock dividers to safe

 125 MHz / 7 ~= 20 MHz */

 125 MHz / 63 ~= 2 MHz */

	/* Map everything up to and including the RSS indirection table.

	 * The PCI core takes care of mapping the MSI-X tables.

 only one usable function per controller */

 Allocate storage for hardware specific data */

 Now we can reset the NIC */

 Allocate memory for INT_KER */

 Read in the non-volatile configuration */

 621 cycles */

 Initialise I2C adapter */

 RX control FIFO thresholds (32 entries) */

		/* Data FIFO size is 5.5K.  The RX DMA engine only

		 * supports scattering for user-mode queues, but will

		 * split DMA writes at intervals of RX_USR_BUF_SIZE

		 * (32-byte units) even for kernel-mode queues.  We

		 * set it to be so large that that never happens.

 Data FIFO size is 80K; register fields moved */

 Send XON and XOFF at ~3 * max MTU away from empty/full */

		/* Enable hash insertion. This is broken for the

		 * 'Falcon' hash so also select Toeplitz TCP/IPv4 and

	/* Always enable XOFF signal from RX FIFO.  We enable

/* This call performs hardware-specific global initialisation, such as

 * defining the descriptor cache sizes and number of RSS channels.

 * It does not set up any buffers, descriptor rings or event queues.

 Use on-chip SRAM */

	/* Clear the parity enables on the TX data fifos as

	 * they produce false parity errors because of timing issues

 XXX This is documented only for Falcon A0/A1 */

	/* Setup RX.  Wait for descriptor is broken and must

	 * be disabled.  RXDP recovery shouldn't be needed, but is.

	/* Do not enable TX_NO_EOP_DISC_EN, since it limits packets to 16

	 * descriptors (which is bad).

 Set destination of both TX and RX Flush events */

 Remove I2C adapter and clear it in preparation for a retry */

 Release the second function after the reset */

 Tear down the private nic state */

 read the done flag before the stats */

 Update derived statistic */

/* We don't acutally pull stats on falcon. Wait 10ms so that

 * they arrive when we call this just after start_stats

	/* Wait enough time for the most recent transfer to

/**************************************************************************

 *

 * Wake on LAN

 *

 **************************************************************************

/**************************************************************************

 *

 * Revision-dependent attributes used by efx.c and nic.c

 *

 **************************************************************************

	/* We don't expose the filter table on Falcon A1 as it is not

	 * mapped into function 0, but these implementations still

	 * work with a degenerate case of all tables set to size 0.

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2006-2013 Solarflare Communications Inc.

 Falcon-architecture (SFC4000) support */

/**************************************************************************

 *

 * Configurable values

 *

 **************************************************************************

/* This is set to 16 for a good reason.  In summary, if larger than

 * 16, the descriptor cache holds more than a default socket

 * buffer's worth of packets (for UDP we can only have at most one

 * socket buffer's worth outstanding).  This combined with the fact

 * that we only get 1 TX event per descriptor cache means the NIC

 * goes idle.

/* If EF4_MAX_INT_ERRORS internal errors occur within

 * EF4_INT_ERROR_EXPIRE seconds, we consider the NIC broken and

 * disable it.

 Depth of RX flush request fifo */

 Driver generated events */

/**************************************************************************

 *

 * Hardware access

 *

 bit sweep on and off */

 Test this testable bit can be set in isolation */

 Test this testable bit can be cleared in isolation */

/**************************************************************************

 *

 * Special buffer handling

 * Special buffers are used for event queues and the TX and RX

 * descriptor rings.

 *

/*

 * Initialise a special buffer

 *

 * This will define a buffer (previously allocated via

 * ef4_alloc_special_buffer()) in the buffer table, allowing

 * it to be used for event queues, descriptor rings etc.

 Write buffer descriptors to NIC */

 Unmaps a buffer and clears the buffer table entries */

/*

 * Allocate a new special buffer

 *

 * This allocates memory for a new buffer, clears it and allocates a

 * new buffer ID range.  It does not write into the buffer table.

 *

 * This call will allocate 4KB buffers, since 8KB buffers can't be

 * used for event queues and descriptor rings.

 Select new buffer ID */

/**************************************************************************

 *

 * TX path

 *

 This writes to the TX_DESC_WPTR; write pointer for TX descriptor ring */

 Write pointer and first descriptor for TX descriptor ring */

/* For each entry inserted into the software descriptor ring, create a

 * descriptor in the hardware TX descriptor ring (in host memory), and

 * write a doorbell.

 Create TX descriptor ring entry */

 Ensure descriptors are written before they are fetched */

 Don't cross 4K boundaries with descriptors. */

 Allocate hardware resources for a TX queue */

 Pin TX descriptor ring */

 Push TX descriptor ring to card */

 Only 128 bits in this register */

 Remove TX descriptor ring from card */

 Unpin TX descriptor ring */

 Free buffers backing TX queue */

/**************************************************************************

 *

 * RX path

 *

 This creates an entry in the RX descriptor queue */

/* This writes to the RX_DESC_WPTR register for the specified receive

 * descriptor ring.

	/* For kernel-mode queues in Falcon A1, the JUMBO flag enables

	 * DMA to continue after a PCIe page boundary (and scattering

	 * is not possible).  In Falcon B0 and Siena, it enables

	 * scatter.

 Pin RX descriptor ring */

 Push RX descriptor ring to card */

 kernel queue */ ,

 Remove RX descriptor ring from card */

 Unpin RX descriptor ring */

 Free buffers backing RX queue */

/**************************************************************************

 *

 * Flush handling

 *

/* ef4_farch_flush_queues() must be woken up when all flushes are completed,

 * or more RX flushes can be kicked off.

 Ensure that all updates are visible to ef4_farch_flush_queues() */

				/* The flush is complete, but we didn't

				 * receive a flush completion event

				/* Don't need to increment active_queues as it

				 * has already been incremented for the queues

				 * which did not drain

/* Flush all the transmit queues, and continue flushing receive queues until

 * they're all flushed. Wait for the DRAIN events to be received so that there

 5s for all flushes and drains */

		/* The hardware supports four concurrent rx flushes, each of

		 * which may need to be retried if there is an outstanding

		 * descriptor fetch

 Do not attempt to write to the NIC during EEH recovery */

 Only perform flush if DMA is enabled */

/* Reset queue and flush accounting after FLR

 *

 * One possible cause of FLR recovery is that DMA may be failing (eg. if bus

 * mastering was disabled), in which case we don't receive (RXQ) flush

 * completion events.  This means that efx->rxq_flush_outstanding remained at 4

 * after the FLR; also, efx->active_queues was non-zero (as no flush completion

 * events were received, and we didn't go through ef4_check_tx_flush_complete())

 * If we don't fix this up, on the next call to ef4_realloc_channels() we won't

 * flush any RX queues because efx->rxq_flush_outstanding is at the limit of 4

 * for batched flush requests; and the efx->active_queues gets messed up because

 * we keep incrementing for the newly initialised queues, but it never went to

 * zero previously.  Then we get a timeout every time we try to restart the

 * queues, as it doesn't go back to zero when we should be flushing the queues.

/**************************************************************************

 *

 * Event queue processing

 * Event queues are processed by per-channel tasklets.

 *

/* Update a channel's event queue's read pointer (RPTR) register

 *

 * This writes the EVQ_RPTR_REG register for the specified channel's

 * event queue.

	/* For Falcon A1, EVQ_RPTR_KER is documented as having a step size

	 * of 4 bytes, but it is really 16 bytes just like later revisions.

 Use HW to insert a SW defined event */

/* Handle a transmit completion event

 *

 * The NIC batches TX completion events; the message we receive is of

 * the form "complete all TX events up to this index".

 Transmit completion */

 Rewrite the FIFO write pointer */

 Detect errors included in the rx_evt_pkt_ok bit. */

	/* Count errors that are not in MAC stats.  Ignore expected

	/* TOBE_DISC is expected on unicast mismatches; don't print out an

	 * error message.  FRM_TRUNC indicates RXDP dropped the packet due

	 * to a FIFO overflow.

 Every error apart from tobe_disc and pause_frm */

 The frame must be discarded if any of these are true. */

/* Handle receive events that are not in-order. Return true if this

 * can be handled as a partial packet discard, false if it's more

 * serious.

/* Handle a packet received event

 *

 * The NIC gives a "discard" flag if it's a unicast packet with the

 * wrong destination address

 * Also "is multicast" and "matches multicast filter" flags can be used to

 * discard non-matching multicast packets.

 Check for partial drops and other errors */

 Discard all pending fragments */

 Return if there is no new fragment */

 Discard new fragment if not SOP */

		/* If packet is marked as OK then we can rely on the

		 * hardware checksum and classification.

 Detect multicast packets that didn't match the filter */

 Handle received packet */

/* If this flush done event corresponds to a &struct ef4_tx_queue, then

 * send an %EF4_CHANNEL_MAGIC_TX_DRAIN event to drain the event queue

 * of all transmit completions.

/* If this flush done event corresponds to a &struct ef4_rx_queue: If the flush

 * was successful then send an %EF4_CHANNEL_MAGIC_RX_DRAIN, otherwise add

 * the RX queue back to the mask of RX queues in need of flushing.

		/* The queue must be empty, so we won't receive any rx

		 * events, so ef4_process_channel() won't refill the

 End of events */

 Clear this event by marking it all ones */

 Allocate buffer table entries for event queue */

 Pin event queue buffer */

 Fill event queue with all ones (i.e. empty events) */

 Push event queue to card */

 Remove event queue from card */

 Unpin event queue */

 Free buffers backing event queue */

/**************************************************************************

 *

 * Hardware interrupts

 * The hardware interrupt handler does very little work; all the event

 * queue processing is carried out by per-channel tasklets.

 *

 Enable/disable/generate interrupts */

 Ensure interrupt vector is clear before interrupts enabled */

 Disable interrupts */

/* Generate a test interrupt

 * Interrupt must already have been enabled, otherwise nasty things

 * may happen.

/* Process a fatal interrupt

 * Disable bus mastering ASAP and schedule a reset

 If this is a memory parity error dump which blocks are offending */

 Disable both devices */

 Count errors and reset or disable the NIC accordingly */

/* Handle a legacy interrupt

 * Acknowledges the interrupt and schedule event queue processing.

 Read the ISR which also ACKs the interrupts */

	/* Legacy interrupts are disabled too late by the EEH kernel

	 * code. Disable them earlier.

	 * If an EEH error occurred, the read will have returned all ones.

 Handle non-event-queue sources */

 Schedule processing of any interrupting queues */

 Legacy ISR read can return zero once (SF bug 15783) */

		/* We can't return IRQ_HANDLED more than once on seeing ISR=0

 Ensure we schedule or rearm all event queues */

/* Handle an MSI interrupt

 *

 * Handle an MSI hardware interrupt.  This routine schedules event

 * queue processing.  No interrupt acknowledgement cycle is necessary.

 * Also, we never need to check that the interrupt is for us, since

 * MSI interrupts cannot be shared.

 Handle non-event-queue sources */

 Schedule processing of the channel */

/* Setup RSS indirection table.

 * This maps from the hash value of the packet to RXQ

/* Looks at available SRAM resources and works out how many queues we

 * can support, and where things like descriptor caches should live.

 *

 * SRAM is split up as follows:

 * 0                          buftbl entries for channels

 * efx->vf_buftbl_base        buftbl entries for SR-IOV

 * efx->rx_dc_base            RX descriptor caches

 * efx->tx_dc_base            TX descriptor caches

	/* Account for the buffer table entries backing the datapath channels

	 * and the descriptor caches for those channels.

 Set positions of descriptor caches in SRAM. */

 Set TX descriptor cache size. */

	/* Set RX descriptor cache size.  Set low watermark to size-8, as

	 * this allows most efficient prefetching.

 Program INT_KER address */

 Use a valid MSI-X vector */

	/* Enable all the genuinely fatal interrupts.  (They are still

	 * masked by the overall interrupt mask, controlled by

	 * falcon_interrupts()).

	 *

	 * Note: All other fatal interrupts are enabled

	/* Disable the ugly timer-based TX DMA backoff and allow TX DMA to be

	 * controlled by the RX FIFO fill level. Set arbitration to one pkt/Q.

 Enable SW_EV to inherit in char driver - assume harmless here */

 Prefetch threshold 2 => fetch when descriptor cache half empty */

 Disable hardware watchdog which can misfire */

 Squash TX of packets of 16 bytes or less */

 Default values */

				     /* Allow large pace values in the

/**************************************************************************

 *

 * Filter tables

 *

 **************************************************************************

/* "Fudge factors" - difference between programmed value and actual depth.

 * Due to pipelined implementation we need to program H/W with a value that

 * is larger than the hop limit we want.

/* Hard maximum search limit.  Hardware will time-out beyond 200-something.

 * We also need to avoid infinite loops in ef4_farch_filter_search() when the

 * table is full.

/* Don't try very hard to find space for performance hints, as this is

 number of specific types */

 address of table relative to BAR */

 number of entries */

 step between entries */

 number currently used */

/* The filter hash function is LFSR polynomial x^16 + x^3 + 1 of a 32-bit

 First 16 rounds */

 Last 16 rounds */

/* To allow for hash collisions, filter search continues at these

		/* There is a single bit to enable RX scatter for all

		 * unmatched packets.  Only set it if scatter is

		 * enabled in both filter specs.

		/* We don't expose 'default' filters because unmatched

		 * packets always go to the queue number found in the

		 * RSS table.  But we still need to set the RX scatter

		 * bit here.

		/* Filter is constructed in terms of source and destination,

		 * with the odd wrinkle that the ports are swapped in a UDP

		 * wildcard filter.  We need to convert from local and remote

		 * (= zero for wildcard) addresses.

 ensure equality */

	/* *gen_spec should be completely initialised, to be consistent

	 * with ef4_filter_init_{rx,tx}() and in case we want to copy

	 * it back to userland.

	/* If there's only one channel then disable RSS for non VF

	 * traffic, thereby allowing VFs to use RSS when the PF can't.

 Build a filter entry and return its n-tuple key. */

/*

 * Construct/deconstruct external filter IDs.  At least the RX filter

 * IDs must be ordered by matching priority, for RX NFC semantics.

 *

 * Deconstruction needs to be robust against invalid IDs so that

 * ef4_filter_remove_id_safe() and ef4_filter_get_filter_safe() can

 * accept user-provided IDs.

 RX match pri 0 */

 RX match pri 4 */

 TX match pri 0 */

 TX match pri 1 */

 invalid */

 One filter spec per type */

		/* Search concurrently for

		 * (1) a filter to be replaced (rep_index): any filter

		 *     with the same match values, up to the current

		 *     search depth for this type, and

		 * (2) the insertion point (ins_index): (1) or any

		 *     free slot before it or up to the maximum search

		 *     depth for this priority

		 * We fail if we cannot find (2).

		 *

		 * We can stop once either

		 * (a) we find (1), in which case we have definitely

		 *     found (2) as well; or

		 * (b) we have searched exhaustively for (1), and have

		 *     either found (2) or searched exhaustively for it

 Case (a) */

 Case (b) */

	/* If we found a filter to be replaced, check whether we

	 * should do so

 Insert the filter */

		/* If we were able to replace a filter by inserting

		 * at a lower depth, clear the replaced filter

 can't clear MAC default filters */

	/* If this filter required a greater search depth than

	 * any other, the search limit for its type can now be

	 * decreased.  However, it is hard to determine that

	 * unless the table has become completely empty - in

	 * which case, all its search limits can be set to 0.

 Restore filter stater after reset */

 Check whether this is a regular register table */

 RX default filters must always exist */

 Update scatter enable flags for filters pointing to our own RX queues */

 Pushed by ef4_farch_filter_push_rx_config() */

 CONFIG_RFS_ACCEL */

 Build multicast hash table */

		/* Broadcast packets go through the multicast hash filter.

		 * ether_crc_le() of the broadcast address is 0xbe2612ff

		 * so we always add bit 0xff to the mask.

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2006-2012 Solarflare Communications Inc.

/*

 * Driver for AMCC QT202x SFP+ and XFP adapters; see www.amcc.com for details

***************************************************************************/

 Quake-specific MDIO registers */

 QT2025C only */

 Wait for firmware heartbeat to start */

			/* Some cables have EEPROMs that conflict with the

 Wait for firmware status to look good */

 Restart microcontroller execution of firmware from RAM */

		/* Bug 17689: occasionally heartbeat starts but firmware status

		 * code never progresses beyond 0x00.  Try again, once, after

	/* The PHY can get stuck in a state where it reports PHY_XS and PMA/PMD

	 * layers up, but PCS down (no block_lock).  If we notice this state

	 * persisting for a couple of seconds, we switch PMA/PMD loopback

	 * briefly on and then off again, which is normally sufficient to

	 * recover it.

	/* Only 2.0.1.0+ PHY firmware supports the more optimal SFP+

	 * Self-Configure mode.  Don't attempt any switching if we encounter

	/* In general we will get optimal behaviour in "SFP+ Self-Configure"

	 * mode; however, that powers down most of the PHY when no module is

	 * present, so we must use a different mode (any fixed mode will do)

 Only change mode if really necessary */

	/* This sequence replicates the register writes configured in the boot

	 * EEPROM (including the differences between board revisions), except

	 * that the operating mode is changed, and the PHY is prevented from

	/* (Note: this portion of the boot EEPROM sequence, which bit-bashes 9

	 * STOPs onto the firmware/module I2C bus to reset it, varies across

	 * board revisions, as the bus is connected to different GPIO/LED

	/* This additional write is not present in the boot EEPROM.  It

	 * prevents the PHY's internal boot ROM doing another pointless (and

	 * slow) reload of the firmware image (the microcontroller's code

	/* PMA/PMD loopback sets RXIN to inverse polarity and the firmware

 Restart microcontroller execution of firmware from RAM */

 Wait for the microcontroller to be ready again */

		/* Wait for the reset triggered by falcon_reset_hw()

		/* Reset the PHYXS MMD. This is documented as doing

 Wait 250ms for the PHY to complete bootup */

		/* There are several different register bits which can

		 * disable TX (and save power) on direct-attach cables

		 * or optical transceivers, varying somewhat between

		 * firmware versions.  Only 'static mode' appears to

 Reset the PHY when moving from tx off to tx on */

 Free the context block */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2005-2013 Solarflare Communications Inc.

 Preferred number of descriptors to fill at once */

/* Number of RX buffers to recycle pages for.  When creating the RX page recycle

 * ring, this number is divided by the number of buffers per page to calculate

 * the number of pages to store in the RX page recycle ring.

 Size of buffer allocated for skb header area. */

/* This is the percentage fill level below which new RX descriptors

 * will be added to the RX descriptor ring.

 Each packet can consume up to ceil(max_frame_len / buffer_size) buffers */

/*

 * RX maximum head room required.

 *

 * This must be at least 1 to prevent overflow, plus one packet-worth

 * to allow pipelined receives.

 Check the RX page recycle ring for a page that can be reused. */

 page_remove cannot exceed page_add. */

 If page_count is 1 then we hold the only reference to this page. */

/**

 * ef4_init_rx_buffers - create EF4_RX_BATCH page-based RX buffers

 *

 * @rx_queue:		Efx RX queue

 * @atomic:		control memory allocation flags

 *

 * This allocates a batch of pages, maps them for DMA, and populates

 * struct ef4_rx_buffers for each one. Return a negative error code or

 * 0 on success. If a single page can be used for multiple buffers,

 * then the page will either be inserted fully, or not at all.

/* Unmap a DMA-mapped page.  This function is only called for the final RX

 * buffer in a page.

/* Attempt to recycle the page if there is an RX recycle ring; the page can

 * only be added if this is the final RX buffer, to prevent pages being used in

 * the descriptor ring and appearing in the recycle ring simultaneously.

 Only recycle the page after processing the final buffer. */

		/* The next slot in the recycle ring is available, but

		 * increment page_remove if the read pointer currently

		 * points here.

 Release the page reference we hold for the buffer. */

 If this is the last buffer in a page, unmap and free it. */

 Recycle the pages that are used by buffers that have just been received. */

/**

 * ef4_fast_push_rx_descriptors - push new RX descriptors quickly

 * @rx_queue:		RX descriptor queue

 *

 * This will aim to fill the RX descriptor queue up to

 * @rx_queue->@max_fill. If there is insufficient atomic

 * memory to do so, a slow fill will be scheduled.

 * @atomic: control memory allocation flags

 *

 * The caller must provide serialisation (none is used here). In practise,

 * this means this function must run from the NAPI handler, or be called

 * when NAPI is disabled.

 Calculate current fill level, and exit if we don't need to fill */

 Record minimum fill level */

 Ensure that we don't leave the rx queue empty */

 Post an event to cause NAPI to run and refill the queue */

	/* The packet must be discarded, but this is only a fatal error

	 * if the caller indicated it was

/* Pass a received packet up through GRO.  GRO can handle pages

 * regardless of checksum state and skbs with a good checksum.

 Allocate and construct an SKB around page fragments */

 Allocate an SKB to store the headers */

 Append the remaining page(s) onto the frag list */

 Move past the ethernet header */

 Validate the number of fragments and completed length */

		/* If this isn't an explicit discard request, either

		 * the hardware or the driver is broken.

	/* Discard packet, if instructed to do so.  Process the

	 * previous receive first.

	/* Release and/or sync the DMA mapping - assumes all RX buffers

	 * consumed in-order per RX queue.

	/* Prefetch nice and early so data will (hopefully) be in cache by

	 * the time we look at it.

		/* Release/sync DMA mapping for additional fragments.

		 * Fix length for last fragment.

 All fragments have been DMA-synced, so recycle pages. */

	/* Pipeline receives so that we give time for packet headers to be

	 * prefetched into cache.

 Set the SKB flags */

 Pass the packet up */

 Handle a received packet.  Second half: Touches packet payload. */

	/* Read length from the prefix if necessary.  This already

	 * excludes the length of the prefix itself.

	/* If we're in loopback test, then pass the packet directly to the

	 * loopback layer, and free the rx_buf here

 Create the smallest power-of-two aligned ring */

 Allocate RX buffers */

 Set the RX recycle ring size */

 CONFIG_PPC64 */

 Initialise ptr fields */

 Initialise limit fields */

 Set up RX descriptor ring */

 Release RX buffers from the current read ptr to the write ptr */

 Unmap and release the pages in the recycle ring. Remove the ring. */

 Remember this so we can check whether to expire the filter later */

 CONFIG_RFS_ACCEL */

/**

 * ef4_filter_is_mc_recipient - test whether spec is a multicast recipient

 * @spec: Specification to test

 *

 * Return: %true if the specification is a non-drop RX filter that

 * matches a local MAC address I/G bit value of 1 or matches a local

 * IPv4 or IPv6 address value in the respective multicast address

 * range.  Otherwise %false.

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2006-2013 Solarflare Communications Inc.

 MTD interface */

 Add to list in order - ef4_mtd_remove() depends on this */

 Failure is unlikely here, but probably means we're out of memory */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2005-2013 Solarflare Communications Inc.

/**************************************************************************

 *

 * Type name strings

 *

 **************************************************************************

 Loopback mode names (see LOOPBACK_MODE()) */

/* Reset workqueue. If any NIC has a hardware failure then a reset will be

 * queued onto this work queue. This is not a per-nic work queue, because

 * ef4_reset_work() acquires the rtnl lock, so resets are naturally serialised.

/* How often and how many times to poll for a reset while waiting for a

 * BIST that another function started to complete.

/**************************************************************************

 *

 * Configurable values

 *

/*

 * Use separate channels for TX and RX events

 *

 * Set this to 1 to use separate channels for TX and RX. It allows us

 * to control interrupt affinity separately for TX and RX.

 *

 * This is only used in MSI-X interrupt mode

/* This is the weight assigned to each of the (per-channel) virtual

 * NAPI devices.

/* This is the time (in jiffies) between invocations of the hardware

 * monitor.

 * On Falcon-based NICs, this will:

 * - Check the on-board hardware monitor;

 * - Poll the link state and reconfigure the hardware as necessary.

 * On Siena-based NICs for power systems with EEH support, this will give EEH a

 * chance to start.

/* Initial interrupt moderation settings.  They can be modified after

 * module load with ethtool.

 *

 * The default for RX should strike a balance between increasing the

 * round-trip latency and reducing overhead.

/* Initial interrupt moderation settings.  They can be modified after

 * module load with ethtool.

 *

 * This default is chosen to ensure that a 10G link does not go idle

 * while a TX queue is stopped after it has become full.  A queue is

 * restarted when it drops below half full.  The time this takes (assuming

 * worst case 3 descriptors per packet and 1024 descriptors) is

 *   512 / 3 * 1.2 = 205 usec.

/* This is the first interrupt mode to try out of:

 * 0 => MSI-X

 * 1 => MSI

 * 2 => legacy

/* This is the requested number of CPUs to use for Receive-Side Scaling (RSS),

 * i.e. the number of CPUs among which we may distribute simultaneous

 * interrupt handling.

 *

 * Cards without MSI-X will only target one CPU via legacy or MSI interrupt.

 * The default (0) means to assign an interrupt to each core.

/**************************************************************************

 *

 * Utility functions and prototypes

 *

/**************************************************************************

 *

 * Event queue processing

 *

/* Process channel's event queue

 *

 * This function is responsible for processing the event queue of a

 * single channel.  The caller must guarantee that this function will

 * never be concurrently called more than once on the same channel,

 * though different channels may be being processed concurrently.

 Update BQL */

/* NAPI poll handler

 *

 * NAPI guarantees serialisation of polls of the same device, which

 * provides the guarantee required by ef4_process_channel().

		/* There is no race here; although napi_disable() will

		 * only wait for napi_complete(), this isn't a problem

		 * since ef4_nic_eventq_read_ack() will have no effect if

		 * interrupts have already been disabled.

/* Create event queue

 * Event queue memory allocations are done only once.  If the channel

 * is reset, the memory buffer will be reused; this guards against

 * errors during channel reset and also simplifies interrupt handling.

	/* Build an event queue with room for one event per tx and rx buffer,

 Prepare channel's event queue */

 Enable event queue processing and NAPI */

 Make sure the NAPI handler sees the enabled flag set */

 Disable event queue processing and NAPI */

/**************************************************************************

 *

 * Channel handling

 *

 Allocate and initialise a channel structure. */

/* Allocate and initialise a channel structure, copying parameters

 * (but not resources) from an old channel structure.

 Restart special buffer allocation */

	/* Probe channels in reverse, so that any 'extra' channels

	 * use the start of the buffer table. This allows the traffic

	 * channels to be resized without moving them or wasting the

	 * entries before them.

/* Channels are shutdown and reinitialised whilst the NIC is running

 * to propagate configuration changes (mtu, checksum offload), or

 * to clear hardware error conditions

	/* Calculate the rx buffer allocation parameters required to

	 * support the current MTU, including padding for header

	 * alignment and overruns.

	/* Restore previously fixed features in hw_features and remove

	 * features which are fixed now

 RX filters may also have scatter-enabled flags */

	/* We must keep at least one descriptor in a TX ring empty.

	 * We could avoid this when the queue size does not exactly

	 * match the hardware ring size, but it's not that important.

	 * Therefore we stop the queue when one more skb might fill

	 * the ring completely.  We wake it when half way back to

	 * empty.

 Initialise the channels */

 Stop RX refill */

		/* RX packet processing is pipelined, so wait for the

		 * NAPI handler to complete.  At least event queue 0

		 * might be kept active by non-data events, so don't

		 * use napi_synchronize() but actually disable NAPI

		 * temporarily.

		/* Schedule a reset to recover from the flush failure. The

		 * descriptor caches reference memory we're about to free,

		 * but falcon_reconfigure_mac_wrapper() won't reconnect

		 * the MACs because of the pending reset.

	/* Not all channels should be reallocated. We must avoid

	 * reallocating their buffer table entries.

 Clone channels (where possible) */

 Swap entry counts and channel pointers */

 Restart buffer table allocation */

 Destroy unused channel structures */

 Swap back */

/**************************************************************************

 *

 * Port handling

 *

/* This ensures that the kernel is kept informed (via

 * netif_carrier_on/off) of the link status, and also maintains the

 * link status's stop on the port's TX queue.

	/* SFC Bug 5356: A net_dev notifier is registered, so we must ensure

	 * that no events are triggered between unregister_netdev() and the

	 * driver unloading. A more general condition is that NETDEV_CHANGE

 Status message for kernel log */

/* We assume that efx->type->reconfigure_mac will always try to sync RX

 * filters and therefore needs to read-lock the filter table against freeing

/* Push loopback/power/transmit disable settings to the PHY, and reconfigure

 * the MAC appropriately. All other PHY configuration changes are pushed

 * through phy_op->set_link_ksettings(), and pushed asynchronously to the MAC

 * through ef4_monitor().

 *

 * Callers must hold the mac_lock

 Disable PHY transmit in mac level loopbacks */

/* Reinitialise the MAC to pick up new PHY settings, even if the port is

/* Asynchronous work item for changing MAC promiscuity and multicast

 * hash.  Avoid a drain/rx_ingress enable by reconfiguring the current

 Connect up MAC/PHY operations table */

 Initialise MAC address to permanent address */

	/* Reconfigure the MAC before creating dma queues (required for

 Ensure the PHY advertises the correct flow control settings */

 Ensure MAC ingress/egress is enabled */

/* Cancel work for MAC reconfiguration, periodic hardware monitoring

 * and the async self-test, wait for them to finish and prevent them

 * being scheduled again.  This doesn't cover online resets, which

 * should only be cancelled when removing the device.

 Serialise against ef4_set_multicast_list() */

/**************************************************************************

 *

 * NIC handling

 *

 Adding primary function; look for secondaries */

 Adding secondary function; look for primary */

 This configures the PCI device to enable I/O and DMA. */

	/* Set the PCI DMA mask.  Try all possibilities from our genuine mask

	 * down to 32 bits, because some architectures will allow 40 bit

	 * masks event though they reject 46 bit masks.

 Don't disable bus-mastering if VFs are assigned */

/* Probe the number and type of interrupts we are able to obtain, and

 * the resulting numbers of channels and RX queues.

 Fall back to single channel MSI */

 Try single interrupt MSI */

 Assume legacy interrupts */

 Assign extra channels if possible */

 Remove MSI/MSI-X interrupts */

 Remove legacy interrupt */

	/* We need to mark which channels really have RX and TX

	 * queues, and adjust the TX queue numbers if we have separate

	 * RX-only and TX-only channels.

 Carry out hardware-type specific initialisation */

		/* Determine the number of channels and queues by trying

		 * to hook in MSI-X interrupts.

 dimension_resources can fail with EAGAIN */

 try again with new max_channels */

 Initialise the interrupt moderation settings */

/**************************************************************************

 *

 * NIC startup/shutdown

 *

/* If the interface is supposed to be running but is not, start

 * the hardware and software data path, regular activity for the port

 * (MAC statistics, link polling, etc.) and schedule the port to be

 * reconfigured.  Interrupts must already be enabled.  This function

 * is safe to call multiple times, so long as the NIC is not disabled.

 * Requires the RTNL lock.

	/* Check that it is appropriate to restart the interface. All

 Start the hardware monitor if there is one */

/* Quiesce the hardware and software data path, and regular activity

 * for the port without bringing the link down.  Safe to call multiple

 * times with the NIC in almost any state, but interrupts should be

 * enabled.  Requires the RTNL lock.

 port_enabled can be read safely under the rtnl lock */

	/* update stats before we go down so we can accurately count

	 * rx_nodesc_drops

	/* Stop the kernel transmit interface.  This is only valid if

	 * the device is stopped or detached; otherwise the watchdog

	 * may fire immediately.

/**************************************************************************

 *

 * Interrupt moderation

 *

 never round down to 0 */

	/* We must round up when converting ticks to microseconds

	 * because we round down when converting the other way.

 Set interrupt moderation parameters */

	/* If channels are shared between RX and TX, so is IRQ

	 * moderation.  Otherwise, IRQ moderation is the same for all

	 * TX channels and is not adaptive.

/**************************************************************************

 *

 * Hardware monitor

 *

 Run periodically off the general workqueue */

	/* If the mac_lock is already held then it is likely a port

	 * reconfiguration is already in place, which will likely do

/**************************************************************************

 *

 * ioctls

 *

/* Net device ioctl

 * Context: process, rtnl_lock() held.

 Convert phy_id from older PRTAD/DEVAD format */

/**************************************************************************

 *

 * NAPI interface

 *

/**************************************************************************

 *

 * Kernel net device interface

 *

 Context: process, rtnl_lock() held. */

	/* Notify the kernel of the link state polled during driver load,

/* Context: process, rtnl_lock() held.

 * Note that the kernel will ignore our return code; this method

 * should really be a void.

 Stop the device and flush all the channels */

 Context: process, dev_base_lock or RTNL held, non-blocking. */

 Context: netif_tx_lock held, BHs disabled. */

 Context: process, rtnl_lock() held. */

 save old address */

 Reconfigure the MAC */

 Context: netif_addr_lock held, BHs disabled. */

 Otherwise ef4_start_port() will do this */

 If disabling RX n-tuple filtering, clear existing filters */

 If Rx VLAN filter is changed, update filters via mac_reconfigure */

		/* ef4_set_rx_mode() will schedule MAC work to update filters

		 * when a new features are finally set in net_dev.

	/* Enable resets to be scheduled and check whether any were

	 * already requested.  If so, the NIC is probably hosed so we

	 * abort.

 ensure we change state before checking reset_pending */

 Always start with carrier off; PHY events will detect the link */

/**************************************************************************

 *

 * Device reset and suspend

 *

/* Tears down the entire software state and most of the hardware state

/* This function will always ensure that the locks acquired in

 * ef4_reset_down() are released. A failure return code indicates

 * that we were unable to reinitialise the hardware, and the

 * driver should be disabled. If ok is false, then the rx and tx

 Ensure that SRAM is initialised even if we're disabling the device */

/* Reset the NIC using the specified method.  Note that the reset may

 * fail, in which case the card will be left in an unusable state.

 *

 * Caller must hold the rtnl_lock.

	/* Clear flags for the scopes we covered.  We assume the NIC and

	 * driver are now quiescent so that there is no race here.

 it doesn't fit into the well-ordered scope hierarchy */

	/* Reinitialise bus-mastering, which may have been turned off before

	 * the reset was scheduled. This is still appropriate, even in the

	 * RESET_TYPE_DISABLE since this driver generally assumes the hardware

 Leave device stopped if necessary */

/* Try recovery mechanisms.

 * For now only EEH is supported.

 * Returns 0 if the recovery mechanisms are unsuccessful.

 * Returns a non-zero value otherwise.

	/* A PCI error can occur and not be seen by EEH because nothing

	 * happens on the PCI bus. In this case the driver may fail and

	 * schedule a 'recover or reset', leading to this recovery handler.

	 * Manually call the eeh failure check function.

		/* The EEH mechanisms will handle the error and reset the

		 * device if necessary.

/* The worker thread exists so that code that cannot sleep can

 * schedule a reset for later.

	/* We checked the state in ef4_schedule_reset() but it may

	 * have changed by now.  Now that we have the RTNL lock,

	 * it cannot change again.

 ensure we change reset_pending before checking state */

	/* If we're not READY then just leave the flags set as the cue

	 * to abort probing or reschedule the reset later.

/**************************************************************************

 *

 * List of NICs we support

 *

 PCI device ID table */

 end of list */

/**************************************************************************

 *

 * Dummy PHY/MAC operations

 *

 * Can be used for some unimplemented operations

 * Needed so all function pointers are valid and do not have to be tested

 * before use

 *

/**************************************************************************

 *

 * Data housekeeping

 *

/* This zeroes out and then fills in the invariants in a struct

 * ef4_nic (including all sub-structures).

 Initialise common structures */

 Higher numbered interrupt modes are less capable! */

 Would be good to use the net_dev name, but we're too early */

/**************************************************************************

 *

 * PCI interface

 *

/* Main body of final NIC shutdown code

 * This is called only at module unload (or hotplug removal).

	/* Flush reset_work. It can no longer be scheduled since we

	 * are not READY.

/* Final NIC shutdown

 * This is called only at module unload (or hotplug removal).  A PF can call

 * this on its VFs to ensure they are unbound first.

 Mark the NIC as fini, then stop the interface */

/* NIC VPD information

 * Called during probe to display the part number of the installed NIC.

/* Main body of NIC initialisation

 * This is called at module load (or hotplug insertion, theoretically).

 Do start-of-day initialisation */

/* NIC initialisation

 *

 * This is called at module load (or hotplug insertion,

 * theoretically).  It sets up PCI mappings, resets the NIC,

 * sets up and registers the network devices with the kernel and hooks

 * the interrupt service routine.  It does not prepare the device for

 * transmission; this is left to the first time one of the network

 * interfaces is brought up (i.e. ef4_net_open).

 Allocate and initialise a struct net_device and struct ef4_nic */

 Set up basic I/O (BAR mappings etc) */

 Mask for features that also apply to VLAN devices */

	/* Disable VLAN filtering by default.  It may be enforced if

	 * the feature is fixed (i.e. VLAN filters are required to

	 * receive VLAN tagged packets due to vPort restrictions).

 Try to create MTDs, but allow this to fail */

 Reschedule any quenched resets scheduled during ef4_pm_freeze() */

 Used for both resume and restore */

/* A PCI error affecting this device was detected.

 * At this point MMIO and DMA may be disabled.

 * Stop the software path and request a slot reset.

		/* If the interface is disabled we don't want to do anything

		 * with it.

 Fake a successful reset, which will be performed later in ef4_io_resume. */

 Perform the actual reset and resume I/O operations. */

/* For simplicity and reliability, we always require a slot reset and try to

 * reset the hardware when a pci error affecting the device is detected.

 * We leave both the link_reset and mmio_enabled callback unimplemented:

 * with our request for slot reset the mmio_enabled callback will never be

 * called, and the link_reset callback is not used by AER or EEH mechanisms.

/**************************************************************************

 *

 * Kernel module interface

 *

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2006-2013 Solarflare Communications Inc.

 Reader function */

 Initialiser for a struct ef4_sw_stat_desc with type-checking */

/**************************************************************************

 *

 * Ethtool operations

 *

 **************************************************************************

 Identify device by flashing LEDs */

 cycle on/off once per second */

 This must be called with rtnl_lock held. */

 Both MACs support pause frames (bidirectional and respond-only) */

 This must be called with rtnl_lock held. */

 GMAC does not support 1000Mbps HD */

/**

 * ef4_fill_test - fill in an individual self-test entry

 * @test_index:		Index of the test

 * @strings:		Ethtool strings, or %NULL

 * @data:		Ethtool test results, or %NULL

 * @test:		Pointer to test result (used only if data != %NULL)

 * @unit_format:	Unit name format (e.g. "chan\%d")

 * @unit_id:		Unit id (e.g. 0 for "chan0")

 * @test_format:	Test name format (e.g. "loopback.\%s.tx.sent")

 * @test_id:		Test id (e.g. "PHYXS" for "loopback.PHYXS.tx_sent")

 *

 * Fill in an individual self-test entry.

 Fill data value, if applicable */

 Fill string, if applicable */

/**

 * ef4_fill_loopback_test - fill in a block of loopback self-test entries

 * @efx:		Efx NIC

 * @lb_tests:		Efx loopback self-test results structure

 * @mode:		Loopback test mode

 * @test_index:		Starting index of the test

 * @strings:		Ethtool strings, or %NULL

 * @data:		Ethtool test results, or %NULL

 *

 * Fill in a block of loopback self-test entries.  Return new test

 * index.

/**

 * ef4_ethtool_fill_self_tests - get self-test details

 * @efx:		Efx NIC

 * @tests:		Efx self-test results structure, or %NULL

 * @strings:		Ethtool strings, or %NULL

 * @data:		Ethtool test results, or %NULL

 *

 * Get self-test number of strings, strings, and/or test results.

 * Return number of strings (== number of test results).

 *

 * The reason for merging these three functions is to make sure that

 * they can never be inconsistent.

 Event queues */

 Loopback tests */

 No other string sets */

 Get NIC statistics */

 Get software statistics */

 We need rx buffers and interrupts. */

 Restart autonegotiation */

/*

 * Each channel has a single IRQ and moderation timer, started by any

 * completion (or other event).  Unless the module parameter

 * separate_tx_channels is set, IRQs and moderation are therefore

 * shared between RX and TX completions.  In this case, when RX IRQ

 * moderation is explicitly changed then TX IRQ moderation is

 * automatically changed too, but otherwise we fail if the two values

 * are requested to be different.

 *

 * The hardware does not support a limit on the number of completions

 * before an IRQ, so we do not use the max_frames fields.  We should

 * report and require that max_frames == (usecs != 0), but this would

 * invalidate existing user documentation.

 *

 * The hardware does not have distinct settings for interrupt

 * moderation while the previous IRQ is being handled, so we should

 * not use the 'irq' fields.  However, an earlier developer

 * misunderstood the meaning of the 'irq' fields and the driver did

 * not support the standard fields.  To avoid invalidating existing

 * user documentation, we report and accept changes through either the

 * standard or 'irq' fields.  If both are changed at the same time, we

 * prefer the standard field.

 *

 * We implement adaptive IRQ moderation, but use a different algorithm

 * from that assumed in the definition of struct ethtool_coalesce.

 * Therefore we do not use any of the adaptive moderation parameters

 * in it.

	/* If channels are shared, TX IRQ moderation can be quietly

	 * overridden unless it is changed from its old value.

 Hook for Falcon bug 11482 workaround */

	/* Reconfigure the MAC. The PHY *may* generate a link state change event

	 * if the user just changed the advertised capabilities, but there's no

 MAC address mask including only I/G bit */

 The above should handle all filters that we insert */

 Check that user wants us to choose the location */

 Range-check ring_cookie */

 Check for unsupported extensions */

 We do not allow change in unsupported parameters */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2007-2012 Solarflare Communications Inc.

 Macros for unpacking the board revision */

 The revision info is in host byte order. */

 Board types */

/* Board temperature is about 15°C above ambient when air flow is

 * limited.  The maximum acceptable ambient temperature varies

 * depending on the PHY specifications but the critical temperature

/* SFC4000 datasheet says: 'The maximum permitted junction temperature

 * is 125°C; the thermal design of the environment for the SFC4000

/*****************************************************************************

 * Support for LM87 sensor chip used on several boards

 Read-to-clear alarm/interrupt status */

 If link is up then do not monitor temperature */

 !CONFIG_SENSORS_LM87 */

 CONFIG_SENSORS_LM87 */

/*****************************************************************************

 * Support for the SFE4001 NIC.

 *

 * The SFE4001 does not power-up fully at reset due to its high power

 * consumption.  We control its power via a PCA9539 I/O expander.

 * It also has a MAX6647 temperature monitor which we expose to

 * the lm90 driver.

 *

 * This also provides minimal support for reflashing the PHY, which is

 * initiated by resetting it with the FLASH_CFG_1 pin pulled down.

 * On SFE4001 rev A2 and later this is connected to the 3V3X output of

 * the IO-expander.

 * We represent reflash mode as PHY_MODE_SPECIAL and make it mutually

 * exclusive with the network device being open.

/**************************************************************************

 * Support for I2C IO Expander device on SFE4001

 Temperature Sensor */

 Turn off all power rails and disable outputs */

 Clear any over-temperature alert */

 Clear any previous over-temperature alert */

 Enable port 0 and port 1 outputs on IO expander */

	/* If PHY power is on, turn it all off and wait 1 second to

	 * ensure a full reset.

 Turn on 1.2V, 2.5V, 3.3V and 5V power rails */

 Turn on 1V power rail */

		/* In flash config mode, DSP does not turn on AFE, so

		 * just wait 1 second.

 Check DSP has asserted AFE power line */

		/* Reset the PHY, reconfigure the MAC and enable/disable

 If XAUI link is up then do not monitor */

	/* Check the powered status of the PHY. Lack of power implies that

	 * the MAX6647 has shut down power to it, probably due to a temp.

	 * alarm. Reading the power status rather than the MAX6647 status

	 * directly because the later is read-to-clear and would thus

	 * start to power up the PHY again when polled, causing us to blip

	 * the power undesirably.

	 * We know we can read from the IO expander because we did

 Use board power control, not PHY power control */

/* This board uses an I2C expander to provider power to the PHY, which needs to

 * be turned on before the PHY can be used.

 * Context: Process context, rtnl lock held

 Raise board/PHY high limit from 85 to 90 degrees Celsius */

		/* PHY won't generate a 156.25 MHz clock and MAC stats fetch

/*****************************************************************************

 * Support for the SFE4002

 *

 use AIN not FAN inputs */

 2.5V:  1.8V +/- 10% */

 Vccp1: 1.2V +/- 10% */

 3.3V:  3.3V +/- 10% */

 5V:    5.0V +/- 10% */

 12V:   10.8-14V */

 Vccp2: 1.0V +/- 10% */

 AIN1:  1.66V +/- 10% */

 AIN2:  1.5V +/- 10% */

***************************************************************************/

/* LED allocations. Note that on rev A0 boards the schematic and the reality

 * differ: red and green are swapped. Below is the fixed (A1) layout (there

 * are only 3 A0 boards in existence, so no real reason to make this

 * conditional).

 Red */

 Green */

 Amber */

	/* Set the TX and RX LEDs to reflect status and activity, and the

	/* A0 board rev. 4002s report a temperature fault the whole time

/*****************************************************************************

 * Support for the SFN4112F

 *

 use AIN not FAN inputs */

 2.5V:  1.8V +/- 10% */

 Vccp1: 1.2V +/- 10% */

 3.3V:  3.3V +/- 10% */

 12V:   10.8-14V */

 Vccp2: 1.0V +/- 10% */

 AIN2:  1.5V +/- 10% */

 Mask out unused sensors */

/*****************************************************************************

 * Support for the SFE4003

 *

 use AIN not FAN inputs */

 2.5V:  1.5V +/- 10% */

 Vccp1: 1.2V +/- 10% */

 3.3V:  3.3V +/- 10% */

 12V:   10.8-14V */

 Vccp2: 1.0V +/- 10% */

 Board-specific LED info. */

 The LEDs were not wired to GPIOs before A3 */

 The LEDs were not wired to GPIOs before A3 */

	/* A0/A1/A2 board rev. 4003s  report a temperature fault the whole time

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2006-2011 Solarflare Communications Inc.

/*

 * Useful functions for working with MDIO clause 45 PHYs

	/* The bits of the OUI are designated a..x, with a=0 and b variable.

	 * In the id register c is the MSB but the OUI is conventionally

 Catch callers passing values in the wrong units (or just silly) */

 Wait for the reset bit to clear. */

 Read MMD STATUS2 to check it is responding. */

 This ought to be ridiculous overkill. We expect it to fail rarely */

 ms */

	/* Historically we have probed the PHYXS to find out what devices are

	 * present,but that doesn't work so well if the PHYXS isn't expected

 Check all the expected MMDs are present */

 Check all required MMDs are responding and happy. */

	/* If the port is in loopback, then we should only consider a subset

/**

 * ef4_mdio_set_link_ksettings - Set (some of) the PHY settings over MDIO.

 * @efx:		Efx NIC

 * @cmd:		New settings

 We can only change these settings for -T PHYs */

 Check that PHY supports these settings */

/**

 * ef4_mdio_an_reconfigure - Push advertising flags and restart autonegotiation

 * @efx:		Efx NIC

 Set up the base page */

 Set up the (extended) next page */

 Enable and restart AN */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2007-2011 Solarflare Communications Inc.

 We expect these MMDs to be in the package. */

/* We complain if we fail to see the link partner as 10G capable this many

 * times in a row (must be > 1 as sampling the autoneg. registers is racy)

 Extended control register */

 extended status register */

 LED control register */

 LED function override register */

 Bit positions for different LEDs (there are more but not wired on SFE4001)*/

 Override settings */

 H/W control */

 All LEDs under hardware control */

 Green and Amber under hardware control, Red off */

 Misc register defines */

 PRM 10.5.8 */

 PHYXS registers */

 Boot status register */

 100M/1G PHY registers */

/* Time to wait between powering down the LNPGA and turning off the power

 Enable 312.5 MHz clock */

 Set the LEDs up as: Green = Link, Amber = Link/Act, Red = Off */

 Allocate phy private storage */

 Reinitialise flow control settings */

 200ms */

 Let XGXS and SerDes out of reset */

/* Perform a "special software reset" on the PHY. The caller is

 * responsible for saving and restoring the PHY hardware registers

	/* The XGMAC clock is driven from the SFX7101 312MHz clock, so

	 * a special software reset can glitch the XGMAC sufficiently for stats

 Initiate reset */

 Wait for the blocks to come out of reset */

 Try and reconfigure the device */

 Wait for the XGXS state machine to churn */

 Check that AN has started but not completed. */

 LP status is unknown */

 Nothing to do if all is well and was previously so. */

	/* Use the RX (red) LED as an error indicator once we've seen AN

 Poll for link state changes */

 Power down the LNPGA */

	/* Waiting here ensures that the board fini, which can turn

	 * off the power to the PHY, won't get run until the LNPGA

 200 ms */

 Override the RX, TX and link LEDs */

 BIST is automatically run after a special software reset */

	/* In loopback, the PHY automatically brings up the correct interface,

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2006-2012 Solarflare Communications Inc.

/* IRQ latency can be enormous because:

 * - All IRQs may be disabled on a CPU for a *long* time by e.g. a

 *   slow serial console or an old IDE driver doing error recovery

 * - The PREEMPT_RT patches mostly deal with this, but also allow a

 *   tasklet or normal task to be given higher priority than our IRQ

 *   threads

 * Try to avoid blaming the hardware for this.

/*

 * Loopback test packet structure

 *

 * The self-test should stress every RSS vector, and unfortunately

 * Falcon only performs RSS on TCP/UDP packets.

 Loopback test source MAC address */

 Interrupt mode names */

/**

 * struct ef4_loopback_state - persistent state during a loopback selftest

 * @flush:		Drop all packets in ef4_loopback_rx_packet

 * @packet_count:	Number of packets being used in this test

 * @skbs:		An array of skbs transmitted

 * @offload_csum:	Checksums are being offloaded

 * @rx_good:		RX good packet count

 * @rx_bad:		RX bad packet count

 * @payload:		Payload used in tests

 How long to wait for all the packets to arrive (in ms) */

/**************************************************************************

 *

 * MII, NVRAM and register tests

 *

/**************************************************************************

 *

 * Interrupt and event queue testing

 *

 Test generation and receipt of interrupts */

 Wait for arrival of test interrupt. */

 Test generation and receipt of interrupting events */

	/* Wait for arrival of interrupts.  NAPI processing may or may

	 * not complete in time, but we can cope in any case.

			/* Report failure and whether either interrupt or DMA

			 * worked

/**************************************************************************

 *

 * Loopback testing

 * NB Only one loopback test can be executing concurrently.

 *

/* Loopback test RX callback

 * This is called for each received packet during loopback testing.

 If we are just flushing, then drop the packet */

 Check that header exists */

 Check that the ethernet header exists */

 Check packet length */

 Check that IP header matches */

 Check that msg and padding matches */

 Check that iteration matches */

 Increase correct RX count */

 Initialise an ef4_selftest_state for a new iteration */

 Initialise the layerII header */

 saddr set later and used as incrementing count */

 Initialise udp header */

 checksum ignored */

 Fill out payload */

 Fill out remaining state members */

 Transmit N copies of buffer */

		/* Allocate an skb, holding an extra reference for

		/* Copy the payload in, incrementing the source address to

		/* Ensure everything we've written is visible to the

 Defer cleaning up the other skbs for the caller */

	/* Count the number of tx completions, and decrement the refcnt. Any

 Check TX completion and received packet counts */

		/* Don't free the skbs; they will be picked up on TX

		 * overflow or channel teardown.

 Allow to fall through so we see the RX errors as well */

 We may always be up to a flush away from our desired packet total */

 Fall through */

 Update loopback test structure */

 Determine how many packets to send */

		/* This will normally complete very quickly, but be

			/* Wait a while to ensure there are no packets

/* Wait for link up. On Falcon, we would prefer to rely on ef4_monitor, but

 * any contention on the mac lock (via e.g. ef4_mac_mcast_work) causes it

 * to delay and retry. Therefore, it's safer to just poll directly. Wait

	/* Set the port loopback_selftest member. From this point on

	 * all received packets will be dropped. Mark the state as

 Test all supported loopback modes */

 Move the port into the specified loopback mode. */

 Test all enabled types of TX queue */

 Remove the flush. The caller will remove the loopback setting */

/**************************************************************************

 *

 * Entry point

 *

	/* Online (i.e. non-disruptive) testing

	/* Offline (i.e. disruptive) testing

	/* Detach the device so the kernel doesn't transmit during the

	 * loopback test and the watchdog timeout doesn't fire.

	/* Ensure that the phy is powered and out of loopback

 restore the PHY to the previous state */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2006-2011 Solarflare Communications Inc.

/*

 * Driver for Transwitch/Mysticom CX4 retimer

 * see www.transwitch.com, part is TXC-43128

 We expect these MMDs to be in the package */

/**************************************************************************

 *

 * Compile-time config

 *

 **************************************************************************

 Total length of time we'll wait for the PHY to come out of reset (ms) */

 Interval between checks (ms) */

 How long to run BIST (us) */

/**************************************************************************

 *

 * Register definitions

 *

 **************************************************************************

 Command register */

 Useful bits in command register */

 Lane power-down */

/* Limited SW reset: preserves configuration but

 Signal Quality Control */

 Enable bit */

 Lane selection */

 Analog TX control */

 Lane power-down */

 Amplitude on lanes 0, 1 */

 Amplitude on lanes 2, 3 */

 Bit position of value for lane 0 (or 2) */

 Bit position of value for lane 1 (or 3) */

 From databook */

 Preemphasis on lanes 0, 1 */

 Preemphasis on lanes 2, 3 */

 From databook */

 Lane power-down */

 Main control */

 Bits in main control */

 Self clear */

 1 to show align status */

 1 to show align status */

 GPIO output */

 Vendor-specific BIST registers */

 BIST type (controls bit patter in test) */

 TranSwitch Deterministic */

 CRPAT standard */

 CJPAT standard */

 TranSwitch pseudo-random */

 Set this to 1 for 10 bit and 0 for 8 bit */

 Enable BIST (write 0 to disable) */

 Stop BIST (self-clears when stop complete) */

 Start BIST (cleared by writing 1 to STOP) */

 Mt. Diablo test configuration */

/* The PHY sometimes needs a reset to bring the link back up.  So long as

 * it reports link down, we reset it every 5 seconds.

 Perform a reset that doesn't clear configuration changes */

 Set the output value of a gpio */

 Set up the GPIO direction register */

/* Reset the PMA/PMD MMD. The documentation is explicit that this does a

 Check that all the MMDs we expect are present and responding. */

 Run a single BIST on one MMD */

 Set PMA to test into loopback using Mt Diablo reg as per app note */

 The BIST app. note lists these  as 3 distinct steps. */

 Set the BIST type */

 Set the BSTEN bit in the BIST Control register to enable */

 Set the BSTRT bit in the BIST Control register */

 Wait. */

 Set the BSTOP bit in the BIST Control register */

 The STOP bit should go off when things have stopped */

	/* Check all the error counts are 0 and all the frame counts are

 Disable BIST */

 Turn off loopback */

/* Push the non-configurable defaults into the PHY. This must be

	/* Turn amplitude down and preemphasis off on the host side

	 * (PHY<->MAC) as this is believed less likely to upset Falcon

	 * and no adverse effects have been noted. It probably also

 Turn off preemphasis */

 Turn down the amplitude */

	/* Set the line side amplitude and preemphasis to the databook

	 * defaults as an erratum causes them to be 0 on at least some

 Set up the LEDs  */

 Set the Green and Red LEDs to their default modes */

 Databook recommends doing this after configuration changes */

 Allocate phy private storage */

 Initialisation entry point for this PHY driver */

 Set the lane power down state in the global registers */

 Set the lane power down state in the analog control registers */

 According to the data book, all the MMDs can do low power */

	/* Global register bank is in PCS, PHY XS. These control the host

 Analog register bank in PMA/PMD, PHY XS */

/* Perform a logic reset. This preserves the configuration registers

	/* The data sheet claims we can do the logic reset on either the

	 * PCS or the PHYXS and the result is a reset of both host- and

	/* The data sheet claims this is required after every reconfiguration

	 * (note at end of 7.1), but we mustn't do it when nothing changes as

	 * it glitches the link, and reconfigure gets called on link change,

 Disable link events */

/* Periodic callback: this exists mainly to poll link status as we

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2005-2013 Solarflare Communications Inc.

	/* This is probably too much since we don't have any TSO support;

	 * it's a left-over from when we had Software TSO.  But it's safer

	 * to leave it as-is than try to determine a new bound.

	/* Header and payload descriptor for each output segment, plus

	 * one for every input fragment boundary within a segment

	/* Possibly one more per segment for the alignment workaround,

	 * or for option descriptors

 Possibly more for PCIe page boundaries within input fragments */

 We need to consider both queues that the net core sees as one */

	/* We used the stale old_read_count above, which gives us a

	 * pessimistic estimate of the fill level (which may even

	 * validly be >= efx->txq_entries).  Now try again using

	 * read_count (more likely to be a cache miss).

	 *

	 * If we read read_count and then conditionally stop the

	 * queue, it is possible for the completion path to race with

	 * us and complete all outstanding descriptors in the middle,

	 * after which there will be no more completions to wake it.

	 * Therefore we stop the queue first, then read read_count

	 * (with a memory barrier to ensure the ordering), then

	 * restart the queue if the fill level turns out to be low

	 * enough.

 Map the fragment taking account of NIC-dependent DMA limits. */

/* Map all data from an SKB for DMA and create descriptors on the queue.

 Map header data. */

 Add descriptors for each fragment. */

		/* The final descriptor for a fragment is responsible for

		 * unmapping the whole fragment.

			/* Store SKB details with the final buffer for

			 * the completion.

 Move on to the next fragment. */

/* Remove buffers put into a tx_queue.  None of the buffers must have

 * an skb attached.

 Work backwards until we hit the original insert pointer value */

/*

 * Add a socket buffer to a TX queue

 *

 * This maps all fragments of a socket buffer for DMA and adds them to

 * the TX queue.  The queue's insert pointer will be incremented by

 * the number of fragments in the socket buffer.

 *

 * If any DMA mapping fails, any mapped fragments will be unmapped,

 * the queue's insert pointer will be restored to its original value.

 *

 * This function is split out from ef4_hard_start_xmit to allow the

 * loopback test to direct packets via specific TX queues.

 *

 * Returns NETDEV_TX_OK.

 * You must hold netif_tx_lock() to call this function.

 Pad short packets or coalesce short fragmented packets. */

 Map for DMA and create descriptors if we haven't done so already. */

 Update BQL */

 Pass off to hardware */

		/* There could be packets left on the partner queue if those

		 * SKBs had skb->xmit_more set. If we do not push those they

		 * could be left for a long time and cause a netdev watchdog.

/* Remove packets from the TX queue

 *

 * This removes packets from the TX queue, up to and including the

 * specified index.

/* Initiate a packet transmission.  We use one channel per CPU

 * (sharing when we have more CPUs than channels).  On Falcon, the TX

 * completion events will be directed back to the CPU that transmitted

 * the packet, which should be cache-efficient.

 *

 * Context: non-blocking.

 * Note that returning anything other than NETDEV_TX_OK will cause the

 * OS to free the skb.

 Must be inverse of queue lookup in ef4_hard_start_xmit() */

 Initialise high-priority queues as necessary */

 Reduce number of classes before number of queues */

	/* Do not destroy high-priority queues when they become

	 * unused.  We would have to flush them first, and it is

	 * fairly difficult to flush a subset of TX queues.  Leave

	 * it to ef4_fini_channels().

	/* See if we need to restart the netif queue.  This memory

	 * barrier ensures that we write read_count (inside

	 * ef4_dequeue_buffers()) before reading the queue status.

 Check whether the hardware queue is now empty */

 Create the smallest power-of-two aligned ring */

 Allocate software ring */

 Allocate hardware ring */

 Some older hardware requires Tx writes larger than 32. */

 Set up TX descriptor ring */

 Free any buffers left in the ring */

 SPDX-License-Identifier: GPL-2.0-only

/****************************************************************************

 * Driver for Solarflare network controllers and boards

 * Copyright 2005-2006 Fen Systems Ltd.

 * Copyright 2006-2013 Solarflare Communications Inc.

/**************************************************************************

 *

 * Generic buffer handling

 * These buffers are used for interrupt status, MAC stats, etc.

 *

/* Check whether an event is present in the eventq at the current

 * read pointer.  Only useful for self-test.

/* Hook interrupt handler(s)

 * Try MSI and then legacy interrupts.

 Hook MSI or MSI-X interrupt */

 Not shared */

 Disable MSI/MSI-X interrupts */

 Disable legacy interrupt */

 Register dump */

 last Falcon arch revision */

 latest EF10 revision */

 INT_ACK_KER is WO */

 INT_ISR0 is RC */

 EE_VPD_SW_CNTL and EE_VPD_SW_DATA are not used */

 PMBX_DBG_IADDR and PBMX_DBG_IDATA are indirect */

 PCIE_CORE_INDIRECT is indirect */

 FATAL_INTR_KER and FATAL_INTR_CHAR are partly RC */

 DEBUG_DATA_OUT is not used */

 DRV_EV is WO */

 BUF_TBL_UPD is WO */

 RX_FLUSH_DESCQ is WO */

 RX_NODESC_DROP is RC */

 RX_DEBUG, RX_PUSH_DROP are not used */

 TX_FLUSH_DESCQ is WO */

 TX_PUSH_DROP is not used */

 TX_PACE_DROP_QID is RC */

 MD_STAT is RC */

 GM_IPG and GM_HD are not used */

 GM_TEST is not used */

 XM_MGT_INT_MSK (note no 'A') is RC */

 XX_PRBS_CTL, XX_PRBS_CHK and XX_PRBS_ERR are not used */

 XX_CORE_STAT is partly RC */

 DRIVER is not used */

 EVQ_RPTR, TIMER_COMMAND, USR_EV and {RX,TX}_DESC_UPD are WO */

	/* We can't reasonably read all of the buffer table (up to 8MB!).

	 * However this driver will only use a few entries.  Reading

	 * 1K entries allows for some expansion of queue count and

 TX_FILTER_TBL0 is huge and not used by this driver */

 MSIX_PBA_TABLE is not mapped */

 SRM_DBG is not mapped (and is redundant with BUF_FLL_TBL) */

 32-bit SRAM */

 64-bit SRAM */

 128-bit-readable register */

 128-bit register, interleaved */

/**

 * ef4_nic_describe_stats - Describe supported statistics for ethtool

 * @desc: Array of &struct ef4_hw_stat_desc describing the statistics

 * @count: Length of the @desc array

 * @mask: Bitmask of which elements of @desc are enabled

 * @names: Buffer to copy names to, or %NULL.  The names are copied

 *	starting at intervals of %ETH_GSTRING_LEN bytes.

 *

 * Returns the number of visible statistics, i.e. the number of set

 * bits in the first @count bits of @mask for which a name is defined.

/**

 * ef4_nic_update_stats - Convert statistics DMA buffer to array of u64

 * @desc: Array of &struct ef4_hw_stat_desc describing the DMA buffer

 *	layout.  DMA widths of 0, 16, 32 and 64 are supported; where

 *	the width is specified as 0 the corresponding element of

 *	@stats is not updated.

 * @count: Length of the @desc array

 * @mask: Bitmask of which elements of @desc are enabled

 * @stats: Buffer to update with the converted statistics.  The length

 *	of this array must be at least @count.

 * @dma_buf: DMA buffer containing hardware statistics

 * @accumulate: If set, the converted values will be added rather than

 *	directly stored to the corresponding elements of @stats

 if down, or this is the first update after coming up */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright(c) 2015 EZchip Technologies.

 Empty Rx FIFO buffer by reading all words */

 In case dst is not aligned we need an intermediate buffer */

 !dst_is_aligned */

 copy last bytes (if any) */

 Check if we got RX */

 If we got here there is a work for us */

 Check Rx error */

 Check Rx CRC error */

 Check Frame length Min 64b */

 Skb allocation */

 Copy frame from Rx fifo into the skb */

 Clean Rx fifo */

 Ack Rx ctrl register */

 Check if we got TX */

 Ack Tx ctrl register */

 Check Tx transmit error */

/**

 * nps_enet_poll - NAPI poll handler.

 * @napi:       Pointer to napi_struct structure.

 * @budget:     How many frames to process on one call.

 *

 * returns:     Number of processed frames

 set tx_done and rx_rdy bits */

		/* in case we will get a tx interrupt while interrupts

		 * are masked, we will lose it since the tx is edge interrupt.

		 * specifically, while executing the code section above,

		 * between nps_enet_tx_handler and the interrupts enable, all

		 * tx requests will be stuck until we will get an rx interrupt.

		 * the two code lines below will solve this situation by

		 * re-adding ourselves to the poll list.

/**

 * nps_enet_irq_handler - Global interrupt handler for ENET.

 * @irq:                irq number.

 * @dev_instance:       device instance.

 *

 * returns: IRQ_HANDLED for all cases.

 *

 * EZchip ENET has 2 interrupt causes, and depending on bits raised in

 * CTRL registers we may tell what is a reason for interrupt to fire up.

 * We got one for RX and the other for TX (completion).

 set MAC address in HW */

/**

 * nps_enet_hw_reset - Reset the network device.

 * @ndev:       Pointer to the network device.

 *

 * This function reset the PCS and TX fifo.

 * The programming model is to set the relevant reset bits

 * wait for some time for this to propagate and then unset

 * the reset bits. This way we ensure that reset procedure

 * is done successfully by device.

 Pcs reset sequence*/

 Tx fifo reset sequence */

 Enable Rx and Tx statistics */

 Discard packets with different MAC address */

 Discard multicast packets */

 Discard Packets bigger than max frame length */

 Enable interrupts */

 Write device MAC address to HW */

 Rx and Tx HW features */

 IFG configuration */

 preamble configuration */

 enable flow control frames */

 Enable Rx and Tx */

 Disable interrupts */

 Disable Rx and Tx */

 In case src is not aligned we need an intermediate buffer */

 !src_is_aligned */

 Write the length of the Frame */

 Send Frame */

/**

 * nps_enet_set_mac_address - Set the MAC address for this device.

 * @ndev:       Pointer to net_device structure.

 * @p:          6 byte Address to be written as MAC address.

 *

 * This function copies the HW address from the sockaddr structure to the

 * net_device structure and updates the address in HW.

 *

 * returns:     -EBUSY if the net device is busy or 0 if the address is set

 *              successfully.

/**

 * nps_enet_set_rx_mode - Change the receive filtering mode.

 * @ndev:       Pointer to the network device.

 *

 * This function enables/disables promiscuous mode

/**

 * nps_enet_open - Open the network device.

 * @ndev:       Pointer to the network device.

 *

 * returns: 0, on success or non-zero error value on failure.

 *

 * This function sets the MAC address, requests and enables an IRQ

 * for the ENET device and starts the Tx queue.

 Reset private variables */

 ge_mac_cfg_3 default values */

 Disable HW device */

 irq Rx allocation */

 Enable HW device */

/**

 * nps_enet_stop - Close the network device.

 * @ndev:       Pointer to the network device.

 *

 * This function stops the Tx queue, disables interrupts for the ENET device.

/**

 * nps_enet_start_xmit - Starts the data transmission.

 * @skb:        sk_buff pointer that contains data to be Transmitted.

 * @ndev:       Pointer to net_device structure.

 *

 * returns: NETDEV_TX_OK, on success

 *              NETDEV_TX_BUSY, if any of the descriptors are not free.

 *

 * This function is invoked from upper layers to initiate transmission.

 This driver handles one frame at a time  */

	/* make sure tx_skb is actually written to the memory

	 * before the HW is informed and the IRQ is fired.

 The EZ NET specific entries in the device structure. */

 FIXME :: no multicast support yet */

 set kernel MAC address to dev */

 Get IRQ number */

 Register the driver. Should be the last thing in probe */

 Sentinel */ }

/************************************************************************

 * s2io.c: A Linux PCI-X Ethernet driver for Neterion 10GbE Server NIC

 * Copyright(c) 2002-2010 Exar Corp.

 *

 * This software may be used and distributed according to the terms of

 * the GNU General Public License (GPL), incorporated herein by reference.

 * Drivers based on or derived from this code fall under the GPL and must

 * retain the authorship, copyright and license notice.  This file is not

 * a complete program and may only be used when the entire operating

 * system is licensed under the GPL.

 * See the file COPYING in this distribution for more information.

 *

 * Credits:

 * Jeff Garzik		: For pointing out the improper error condition

 *			  check in the s2io_xmit routine and also some

 *			  issues in the Tx watch dog function. Also for

 *			  patiently answering all those innumerable

 *			  questions regaring the 2.6 porting issues.

 * Stephen Hemminger	: Providing proper 2.6 porting mechanism for some

 *			  macros available only in 2.6 Kernel.

 * Francois Romieu	: For pointing out all code part that were

 *			  deprecated and also styling related comments.

 * Grant Grundler	: For helping me get rid of some Architecture

 *			  dependent code.

 * Christopher Hellwig	: Some more 2.6 specific issues in the driver.

 *

 * The module loadable parameters that are supported by the driver and a brief

 * explanation of all the variables.

 *

 * rx_ring_num : This can be used to program the number of receive rings used

 * in the driver.

 * rx_ring_sz: This defines the number of receive blocks each ring can have.

 *     This is also an array of size 8.

 * rx_ring_mode: This defines the operation mode of all 8 rings. The valid

 *		values are 1, 2.

 * tx_fifo_num: This defines the number of Tx FIFOs thats used int the driver.

 * tx_fifo_len: This too is an array of 8. Each element defines the number of

 * Tx descriptors that can be associated with each corresponding FIFO.

 * intr_type: This defines the type of interrupt. The values can be 0(INTA),

 *     2(MSI_X). Default value is '2(MSI_X)'

 * lro_max_pkts: This parameter defines maximum number of packets can be

 *     aggregated as a single large packet

 * napi: This parameter used to enable/disable NAPI (polling Rx)

 *     Possible values '1' for enable and '0' for disable. Default is '1'

 * vlan_tag_strip: This can be used to enable or disable vlan stripping.

 *                 Possible values '1' for enable , '0' for disable.

 *                 Default is '2' - which means disable in promisc mode

 *                 and enable in non-promiscuous mode.

 * multiq: This parameter used to enable/disable MULTIQUEUE support.

 *      Possible values '1' for enable and '0' for disable. Default is '0'

 local include */

 S2io Driver name & version. */

/*

 * Cards with following subsystem_id have a link state indication

 * problem, 600B, 600C, 600D, 640B, 640C and 640D.

 * macro below identifies these cards given the subsystem_id.

 Ethtool related variables and Macros. */

 copy mac addr to def_mac_addr array */

/*

 * Constants to be programmed into the Xena's registers, to configure

 * the XAUI.

 Set address */

 Write data */

 Set address */

 Write data */

 Set address */

 Write data */

 Set address */

 Write data */

 Done */

 Set address */

 Write data */

 Set address */

 Write data */

 Set address */

 Write data */

/*

 * Constants for Fixing the MacAddress problem seen mostly on

 * Alpha machines.

 Module Loadable parameters. */

 0 is no steering, 1 is Priority steering, 2 is Default steering */

 Frequency of Rx desc syncs expressed as power of 2 */

 Interrupt type. Values can be 0(INTA), 2(MSI_X) */

 Large receive offload feature */

/* Max pkts to be aggregated by LRO at one time. If not specified,

 * aggregation happens until we hit max IP pkt size(64K)

/*

 * S2IO device table.

 * This table lists all the devices that this driver supports.

 A simplifier macro used both by init and free shared_mem Fns(). */

 netqueue manipulation helper functions */

/**

 * init_shared_mem - Allocation and Initialization of Memory

 * @nic: Device private variable.

 * Description: The function allocates all the memory areas shared

 * between the NIC and the driver. This includes Tx descriptors,

 * Rx descriptors and the statistics block.

 Allocation and initialization of TXDLs in FIFOs */

		/*

		 * Legal values are from 2 to 8192

			/* If we got a zero DMA address(can happen on

			 * certain platforms like PPC), reallocate.

			 * Store virtual address of page we don't want,

			 * to be freed later.

 Allocation and initialization of RXDs in Rings */

  Allocating all the Rx blocks */

 size is always page size */

				/*

				 * In case of failure, free_shared_mem()

				 * is called, which should free any

				 * memory that was alloced till the

				 * failure happened.

 Interlinking all Rx Blocks */

		/*

		 * Allocation of Storages for buffer addresses in 2BUFF mode

		 * and the buffers as well.

 Allocation and initialization of Statistics block */

		/*

		 * In case of failure, free_shared_mem() is called, which

		 * should free any memory that was alloced till the

		 * failure happened.

/**

 * free_shared_mem - Free the allocated Memory

 * @nic:  Device private variable.

 * Description: This function is to free all memory locations allocated by

 * the init_shared_mem() function and return it to the kernel.

		/* If we got a zero DMA address during allocation,

		 * free the page now

 Freeing buffer storage addresses in 2BUFF mode. */

/*

 * s2io_verify_pci_mode -

 Unknown PCI mode */

/*

 * s2io_print_pci_mode -

 Unknown PCI mode */

/**

 *  init_tti - Initialization transmit traffic interrupt scheme

 *  @nic: device private variable

 *  @link: link status (UP/DOWN) used to enable/disable continuous

 *  transmit interrupts

 *  @may_sleep: parameter indicates if sleeping when waiting for

 *  command complete

 *  Description: The function configures transmit traffic interrupts

 *  Return Value:  SUCCESS on success and

 *  '-1' on failure

		/*

		 * TTI Initialization. Default Tx timer gets us about

		 * 250 interrupts per sec. Continuous interrupts are enabled

		 * by default.

/**

 *  init_nic - Initialization of hardware

 *  @nic: device private variable

 *  Description: The function sequentially configures every block

 *  of the H/W from their reset values.

 *  Return Value:  SUCCESS on success and

 *  '-1' on failure (endian settings incorrect).

 to set the swapper controle on the card */

	/*

	 * Herc requires EOI to be removed from reset before XGXS, so..

 Remove XGXS from reset state */

	/* Ensure that it's safe to access registers by checking

	 * RIC_RUNNING bit is reset. Check is valid only for XframeII.

  Enable Receiving broadcasts */

 Read registers in all blocks */

  Set MTU */

 Necessary!! */

  Tx DMA Initialization */

	/*

	 * Disable 4 PCCs for Xena1, 2 and 3 as per H/W bug

	 * SXE-008 TRANSMIT DMA ARBITRATION ISSUE.

	/*

	 * Initialization of Tx_PA_CONFIG register to ignore packet

	 * integrity checking.

 Rx DMA initialization. */

	/*

	 * Allocating equal share of memory to all the

	 * configured Rings.

	/*

	 * Filling Tx round robin registers

	 * as per the number of FIFOs for equal scheduling priority

 Enable all configured Tx FIFO partitions */

	/* Filling the Rx round robin registers as per the

	 * number of Rings and steering based on QoS with

	 * equal priority.

 UDP Fix */

 Set the default rts frame length for the rings configured */

	/* Set the frame length for the configured rings

	 * desired by the user

		/* If rts_frm_len[i] == 0 then it is assumed that user not

		 * specified frame length steering.

		 * If the user provides the frame length then program

		 * the rts_frm_len register for those values or else

		 * leave it as it is.

 Disable differentiated services steering logic */

 Program statistics memory */

	/*

	 * Initializing the sampling rate for the device to calculate the

	 * bandwidth utilization.

	/*

	 * Initializing the Transmit and Receive Traffic Interrupt

	 * Scheme.

 Initialize TTI */

 RTI Initialization */

		/*

		 * Programmed to generate Apprx 500 Intrs per

		 * second

		/*

		 * Once the operation completes, the Strobe bit of the

		 * command register will be reset. We poll for this

		 * particular condition. We wait for a maximum of 500ms

		 * for the operation to complete, if it's not complete

		 * by then we return error.

	/*

	 * Initializing proper values as Pause threshold into all

	 * the 8 Queues on Rx side.

 Disable RMAC PAD STRIPPING */

 Enable FCS stripping by adapter */

	/*

	 * Set the time value to be inserted in the pause frame

	 * generated by xena.

	/*

	 * Set the Threshold Limit for Generating the pause frame

	 * If the amount of data in any Queue exceeds ratio of

	 * (mac_control.mc_pause_threshold_q0q3 or q4q7)/256

	 * pause frame is generated

	/*

	 * TxDMA will stop Read request if the number of read split has

	 * exceeded the limit pointed by shared_splits

	/*

	 * Programming the Herc to split every write transaction

	 * that does not start on an ADB to reduce disconnects.

/**

 *  do_s2io_write_bits -  update alarm bits in alarm register

 *  @value: alarm bits

 *  @flag: interrupt status

 *  @addr: address value

 *  Description: update alarm bits in alarm register

 *  Return Value:

 *  NONE.

 Remove this line when alarm interrupts are enabled */

/**

 *  en_dis_able_nic_intrs - Enable or Disable the interrupts

 *  @nic: device private variable,

 *  @mask: A mask indicating which Intr block must be modified and,

 *  @flag: A flag indicating whether to enable or disable the Intrs.

 *  Description: This function will either disable or enable the interrupts

 *  depending on the flag argument. The mask argument can be used to

 *  enable/disable any Intr block.

 *  Return Value: NONE.

  Top level interrupt classification */

  PIC Interrupts */

  Enable PIC Intrs in the general intr mask register */

			/*

			 * If Hercules adapter enable GPIO otherwise

			 * disable all PCIX, Flash, MDIO, IIC and GPIO

			 * interrupts for now.

			 * TODO

			/*

			 * Disable PIC Intrs in the general

			 * intr mask register

  Tx traffic interrupts */

			/*

			 * Enable all the Tx side interrupts

			 * writing 0 Enables all 64 TX interrupt levels

			/*

			 * Disable Tx Traffic Intrs in the general intr mask

			 * register.

  Rx traffic interrupts */

 writing 0 Enables all 8 RX interrupt levels */

			/*

			 * Disable Rx Traffic Intrs in the general intr mask

			 * register.

/**

 *  verify_pcc_quiescent- Checks for PCC quiescent state

 *  @sp : private member of the device structure, which is a pointer to the

 *  s2io_nic structure.

 *  @flag: boolean controlling function path

 *  Return: 1 If PCC is quiescence

 *          0 If PCC is not quiescence

/**

 *  verify_xena_quiescence - Checks whether the H/W is ready

 *  @sp : private member of the device structure, which is a pointer to the

 *  s2io_nic structure.

 *  Description: Returns whether the H/W is ready to go or not. Depending

 *  on whether adapter enable bit was written or not the comparison

 *  differs and the calling function passes the input argument flag to

 *  indicate this.

 *  Return: 1 If xena is quiescence

 *          0 If Xena is not quiescence

	/*

	 * In PCI 33 mode, the P_PLL is not used, and therefore,

	 * the the P_PLL_LOCK bit in the adapter_status register will

	 * not be asserted.

/**

 * fix_mac_address -  Fix for Mac addr problem on Alpha platforms

 * @sp: Pointer to device specifc structure

 * Description :

 * New procedure to clear mac address reading  problems on Alpha platforms

 *

/**

 *  start_nic - Turns the device on

 *  @nic : device private variable.

 *  Description:

 *  This function actually turns the device on. Before this  function is

 *  called,all Registers are configured from their reset states

 *  and shared memory is allocated but the NIC is still quiescent. On

 *  calling this function, the device interrupts are cleared and the NIC is

 *  literally switched on by writing into the adapter control register.

 *  Return Value:

 *  SUCCESS on success and -1 on failure.

  PRC Initialization and configuration */

 Enabling 2 buffer mode by writing into Rx_pa_cfg reg. */

	/*

	 * Enabling MC-RLDRAM. After enabling the device, we timeout

	 * for around 100ms, which is approximately the time required

	 * for the device to be ready for operation.

 Delay by around 100 ms. */

 Enabling ECC Protection. */

	/*

	 * Verify if the device is ready to be enabled, if so enable

	 * it.

	/*

	 * With some switches, link might be already up at this point.

	 * Because of this weird behavior, when we enable laser,

	 * we may not get link. We need to handle this. We cannot

	 * figure out which switch is misbehaving. So we are forced to

	 * make a global change.

 Enabling Laser. */

		/*

		 * Dont see link state interrupts initially on some switches,

		 * so directly scheduling the link state task here.

 SXE-002: Initialize link and activity LED */

/**

 * s2io_txdl_getskb - Get the skb from txdl, unmap and return skb

 * @fifo_data: fifo data pointer

 * @txdlp: descriptor

 * @get_off: unused

/**

 *  free_tx_buffers - Free all queued Tx buffers

 *  @nic : device private variable.

 *  Description:

 *  Free all queued Tx buffers.

 *  Return Value: void

/**

 *   stop_nic -  To stop the nic

 *   @nic : device private variable.

 *   Description:

 *   This function does exactly the opposite of what the start_nic()

 *   function does. This function is called to stop the device.

 *   Return Value:

 *   void.

  Disable all interrupts */

 Clearing Adapter_En bit of ADAPTER_CONTROL Register */

/**

 *  fill_rx_buffers - Allocates the Rx side skbs

 *  @nic : device private variable.

 *  @ring: per ring structure

 *  @from_card_up: If this is true, we will map the buffer to get

 *     the dma address for buf0 and buf1 to give it to the card.

 *     Else we will sync the already mapped buffer to give it to the card.

 *  Description:

 *  The function allocates Rx side skbs and puts the physical

 *  address of these buffers into the RxD buffer pointers, so that the NIC

 *  can DMA the received frame into these locations.

 *  The NIC supports 3 receive modes, viz

 *  1. single buffer,

 *  2. three buffer and

 *  3. Five buffer modes.

 *  Each mode defines how many fragments the received frame will be split

 *  up into by the NIC. The frame is split into L3 header, L4 Header,

 *  L4 payload in three buffer mode and in 5 buffer mode, L4 payload itself

 *  is split into 3 fragments. As of now only single buffer mode is

 *  supported.

 *   Return Value:

 *  SUCCESS on success or an appropriate -ve value on failure.

 calculate size of skb based on ring mode */

 allocate skb */

 1 buffer mode - normal operation mode */

			/*

			 * 2 buffer mode -

			 * 2 buffer mode provides 128

			 * byte aligned receive buffers.

 save buffer pointers to avoid frequent dma mapping */

 restore the buffer pointers for dma sync*/

 Two buffer mode */

				/*

				 * Buffer2 will have L3/L4 header plus

				 * L4 payload

	/* Transfer ownership of first descriptor to adapter just before

	 * exiting. Before that, use memory barrier so that ownership

	 * and other fields are seen by adapter correctly.

/**

 *  free_rx_buffers - Frees all Rx buffers

 *  @sp: device private variable.

 *  Description:

 *  This function will free all Rx buffers allocated by host.

 *  Return Value:

 *  NONE.

/**

 * s2io_poll_msix - Rx interrupt handler for NAPI support

 * @napi : pointer to the napi structure.

 * @budget : The number of packets that were budgeted to be processed

 * during  one pass through the 'Poll" function.

 * Description:

 * Comes into picture only if NAPI support has been incorporated. It does

 * the same thing that rx_intr_handler does, but not in a interrupt context

 * also It will process only a given number of packets.

 * Return value:

 * 0 on success and 1 if there are No Rx packets to be processed.

Re Enable MSI-Rx Vector*/

 Re enable the Rx interrupts for the ring */

/**

 * s2io_netpoll - netpoll event handler entry point

 * @dev : pointer to the device structure.

 * Description:

 * 	This function will be called by upper layer to check for events on the

 * interface in situations where interrupts are disabled. It is used for

 * specific in-kernel networking tasks, such as remote consoles and kernel

 * debugging over the network (example netdump in RedHat).

	/* we need to free up the transmitted skbufs or else netpoll will

	 * run out of skbs and will fail and eventually netpoll application such

	 * as netdump will fail.

 check for received packet and indicate up to network */

/**

 *  rx_intr_handler - Rx interrupt handler

 *  @ring_data: per ring structure.

 *  @budget: budget for napi processing.

 *  Description:

 *  If the interrupt is because of a received frame or if the

 *  receive ring contains fresh as yet un-processed frames,this function is

 *  called. It picks out the RxD at which place the last Rx processing had

 *  stopped and sends the skb to the OSM's Rx handler and then increments

 *  the offset.

 *  Return Value:

 *  No. of napi packets processed.

		/*

		 * If your are next to put index then it's

		 * FIFO full condition

 Clear all LRO sessions before exiting */

/**

 *  tx_intr_handler - Transmit interrupt handler

 *  @fifo_data : fifo data pointer

 *  Description:

 *  If an interrupt was raised to indicate DMA complete of the

 *  Tx packet, this function is called. It identifies the last TxD

 *  whose buffer was freed and frees all skbs whose data have already

 *  DMA'ed into the NICs internal memory.

 *  Return Value:

 *  NONE

 Check for TxD errors */

 update t_code statistics */

 Updating the statistics block */

/**

 *  s2io_mdio_write - Function to write in to MDIO registers

 *  @mmd_type : MMD type value (PMA/PMD/WIS/PCS/PHYXS)

 *  @addr     : address value

 *  @value    : data value

 *  @dev      : pointer to net_device structure

 *  Description:

 *  This function is used to write values to the MDIO registers

 *  NONE

 address transaction */

 Data transaction */

/**

 *  s2io_mdio_read - Function to write in to MDIO registers

 *  @mmd_type : MMD type value (PMA/PMD/WIS/PCS/PHYXS)

 *  @addr     : address value

 *  @dev      : pointer to net_device structure

 *  Description:

 *  This function is used to read values to the MDIO registers

 *  NONE

 address transaction */

 Data transaction */

 Read the value from regs */

/**

 *  s2io_chk_xpak_counter - Function to check the status of the xpak counters

 *  @counter      : counter value to be updated

 *  @regs_stat    : registers status

 *  @index        : index

 *  @flag         : flag to indicate the status

 *  @type         : counter type

 *  Description:

 *  This function is to check the status of the xpak counters value

 *  NONE

/**

 *  s2io_updt_xpak_counter - Function to update the xpak counters

 *  @dev         : pointer to net_device struct

 *  Description:

 *  This function is to upate the status of the xpak counters value

 *  NONE

 Check the communication with the MDIO slave */

 Check for the expected value of control reg 1 */

 Loading the DOM register to MDIO register */

 Reading the Alarm flags */

 Reading the Warning flags */

/**

 *  wait_for_cmd_complete - waits for a command to complete.

 *  @addr: address

 *  @busy_bit: bit to check for busy

 *  @bit_state: state to check

 *  @may_sleep: parameter indicates if sleeping when waiting for

 *  command complete

 *  Description: Function that waits for a command to Write into RMAC

 *  ADDR DATA registers to be completed and returns either success or

 *  error depending on whether the command was complete or not.

 *  Return value:

 *   SUCCESS on success and FAILURE on failure.

/**

 * check_pci_device_id - Checks if the device id is supported

 * @id : device id

 * Description: Function to check if the pci device id is supported by driver.

 * Return value: Actual device id if supported else PCI_ANY_ID

/**

 *  s2io_reset - Resets the card.

 *  @sp : private member of the device structure.

 *  Description: Function to Reset the card. This function then also

 *  restores the previously saved PCI configuration space registers as

 *  the card reset also resets the configuration space.

 *  Return value:

 *  void.

 Back up  the PCI-X CMD reg, dont want to lose MMRBC, OST settings */

 Restore the PCI state saved during initialization. */

 Set swapper to enable I/O register access */

 restore mac_addr entries */

 Restore the MSIX table entries from local variables */

 Clear certain PCI/PCI-X fields after reset */

 Clear "detected parity error" bit */

 Clearing PCIX Ecc status register */

 Clearing PCI_STATUS error reflected here */

 Reset device statistics maintained by OS */

 save link up/down time/cnt, reset/memory/watchdog cnt */

 restore link up/down time/cnt, reset/memory/watchdog cnt */

 SXE-002: Configure link and activity LED to turn it off */

	/*

	 * Clear spurious ECC interrupts that would have occurred on

	 * XFRAME II cards after reset.

/**

 *  s2io_set_swapper - to set the swapper controle on the card

 *  @sp : private member of the device structure,

 *  pointer to the s2io_nic structure.

 *  Description: Function to set the swapper control on the card

 *  correctly depending on the 'endianness' of the system.

 *  Return value:

 *  SUCCESS on success and FAILURE on failure.

	/*

	 * Set proper endian settings and verify the same by reading

	 * the PIF Feed-back register.

 FE=1, SE=1 */

 FE=1, SE=0 */

 FE=0, SE=1 */

 FE=0, SE=0 */

 FE=1, SE=1 */

 FE=1, SE=0 */

 FE=0, SE=1 */

 FE=0, SE=0 */

	/*

	 * The device by default set to a big endian format, so a

	 * big endian driver need not set anything.

	/*

	 * Initially we enable all bits to make it accessible by the

	 * driver, then we selectively enable only those bits that

	 * we want to set.

	/*

	 * Verifying if endian settings are accurate by reading a

	 * feedback register.

 Endian settings are incorrect, calls for another dekko. */

 Store and display */

 Temp variable */

 We fail init if error or we get less vectors than min required */

	/*

	 * To enable MSI-X, MSI also needs to be enabled, due to a bug

	 * in the herc NIC. (Temp change, needs to be removed later)

 Enable MSI */

 Handle software interrupt used during MSI(X) test */

 Test interrupt path by forcing a a software IRQ */

 MSI(X) test failed, go back to INTx mode */

 Disable MSI */

/* ********************************************************* *

 * Functions defined below concern the OS part of the driver *

/**

 *  s2io_open - open entry point of the driver

 *  @dev : pointer to the device structure.

 *  Description:

 *  This function is the open entry point of the driver. It mainly calls a

 *  function to allocate Rx buffers and inserts them into the buffer

 *  descriptors and then enables the Rx part of the NIC.

 *  Return value:

 *  0 on success and an appropriate (-)ve integer as defined in errno.h

 *   file on failure.

	/*

	 * Make sure you have link off by default every time

	 * Nic is initialized

 Initialize H/W and enable interrupts */

/**

 *  s2io_close -close entry point of the driver

 *  @dev : device pointer.

 *  Description:

 *  This is the stop entry point of the driver. It needs to undo exactly

 *  whatever was done by the open entry point,thus it's usually referred to

 *  as the close function.Among other things this function mainly stops the

 *  Rx side of the NIC and frees all the Rx buffers in the Rx rings.

 *  Return value:

 *  0 on success and an appropriate (-)ve integer as defined in errno.h

 *  file on failure.

	/* Return if the device is already closed               *

	 *  Can happen when s2io_card_up failed in change_mtu    *

 delete all populated mac entries */

/**

 *  s2io_xmit - Tx entry point of te driver

 *  @skb : the socket buffer containing the Tx data.

 *  @dev : device pointer.

 *  Description :

 *  This function is the Tx entry point of the driver. S2IO NIC supports

 *  certain protocol assist features on Tx side, namely  CSO, S/G, LSO.

 *  NOTE: when device can't queue the pkt,just the trans_start variable will

 *  not be upadted.

 *  Return value:

 *  0 on success & 1 on failure.

 get fifo number based on skb->priority value */

 Avoid "put" pointer going beyond "get" pointer */

 For fragmented SKB. */

 A '0' length fragment will be ignored */

 Avoid "put" pointer going beyond "get" pointer */

 Nothing much can be done. Get out */

 The interrupt was not raised by us */

			/*

			 * This is unstable state so clear both up/down

			 * interrupt and adapter to re-evaluate the link state.

 Enable Adapter */

			/*

			 * unmask link down interrupt and mask link-up

			 * intr

 Link is down so unmaks link up interrupt */

 turn off LED */

/**

 *  do_s2io_chk_alarm_bit - Check for alarm and incrment the counter

 *  @value: alarm bits

 *  @addr: address value

 *  @cnt: counter variable

 *  Description: Check for alarm and increment the counter

 *  Return Value:

 *  1 - if alarm bit set

 *  0 - if alarm bit is not set

/**

 *  s2io_handle_errors - Xframe error indication handler

 *  @dev_id: opaque handle to dev

 *  Description: Handle alarms such as loss of link, single or

 *  double ECC errors, critical and serious errors.

 *  Return Value:

 *  NONE

 Handling the XPAK counters update */

 waiting for an hour */

 reset the count to zero */

 Handling link status change error Intr */

 In case of a serious error, the device will be Reset. */

 Check for data parity error */

 Check for ring full counter */

check for pfc_err*/

check for tda_err*/

check for pcc_err*/

check for tti_err*/

check for lso_err*/

check for tpa_err*/

check for sm_err*/

 Handling Ecc errors */

					/*

					 * Reset XframeI only if critical error

/**

 *  s2io_isr - ISR handler of the device .

 *  @irq: the irq of the device.

 *  @dev_id: a void pointer to the dev structure of the NIC.

 *  Description:  This function is the ISR handler of the device. It

 *  identifies the reason for the interrupt and calls the relevant

 *  service routines. As a contongency measure, this ISR allocates the

 *  recv buffers, if their numbers are below the panic value which is

 *  presently set to 25% of the original number of rcv buffers allocated.

 *  Return value:

 *   IRQ_HANDLED: will be returned if IRQ was handled by this routine

 *   IRQ_NONE: will be returned if interrupt is not from our device

 Pretend we handled any irq's from a disconnected card */

	/*

	 * Identify the cause for interrupt and call the appropriate

	 * interrupt handler. Causes for the interrupt could be;

	 * 1. Rx of packet.

	 * 2. Tx complete.

	 * 3. Link down.

 Nothing much can be done. Get out */

			/*

			 * rx_traffic_int reg is an R1 register, writing all 1's

			 * will ensure that the actual interrupt causing bit

			 * get's cleared and hence a read can be avoided.

		/*

		 * tx_traffic_int reg is an R1 register, writing all 1's

		 * will ensure that the actual interrupt causing bit get's

		 * cleared and hence a read can be avoided.

		/*

		 * Reallocate the buffers from the interrupt handler itself.

 The interrupt was not raised by us */

/*

 * s2io_updt_stats -

 Apprx 30us on a 133 MHz bus */

 Updt failed */

/**

 *  s2io_get_stats - Updates the device statistics structure.

 *  @dev : pointer to the device structure.

 *  Description:

 *  This function updates the device statistics structure in the s2io_nic

 *  structure and returns a pointer to the same.

 *  Return value:

 *  pointer to the updated net_device_stats structure.

 Configure Stats for immediate updt */

	/* A device reset will cause the on-adapter statistics to be zero'ed.

	 * This can be done while running by changing the MTU.  To prevent the

	 * system from having the stats zero'ed, the driver keeps a copy of the

	 * last update to the system (which is also zero'ed on reset).  This

	 * enables the driver to accurately know the delta between the last

	 * update and the current update.

	/* The adapter MAC interprets pause frames as multicast packets, but

	 * does not pass them up.  This erroneously increases the multicast

	 * packet count and needs to be deducted when the multicast frame count

	 * is queried.

/**

 *  s2io_set_multicast - entry point for multicast address enable/disable.

 *  @dev : pointer to the device structure

 *  @may_sleep: parameter indicates if sleeping when waiting for command

 *  complete

 *  Description:

 *  This function is a driver entry point which gets called by the kernel

 *  whenever multicast addresses must be enabled/disabled. This also gets

 *  called to set/reset promiscuous mode. Depending on the deivce flag, we

 *  determine, if multicast address must be enabled or if promiscuous mode

 *  is to be disabled etc.

 *  Return value:

 *  void.

  Enable all Multicast addresses */

 Wait till command completes */

  Disable all Multicast addresses */

 Wait till command completes */

  Put the NIC into promiscuous mode */

  Remove the NIC from promiscuous mode */

  Update individual M_CAST address list */

 Clear out the previous list of Mc in the H/W. */

 Wait for command completes */

 Create the new Rx filter list and update the same in H/W. */

 Wait for command completes */

 NDO wrapper for s2io_set_multicast */

/* read from CAM unicast & multicast addresses and store it in

 * def_mac_addr structure

 store unicast & multicast mac addresses */

 if read fails disable the entry */

 restore unicast & multicast MAC to CAM from def_mac_addr structure */

 restore unicast mac address */

 restore multicast mac address */

 add a multicast MAC address to CAM */

 check if the multicast mac already preset in CAM */

 CAM entry is empty */

 Update the internal structure with this new mac address */

 add MAC address to CAM */

 Wait till command completes */

 deletes a specified unicast/multicast mac entry from CAM */

 disable the entry by writing  0xffffffffffffULL */

 store the new mac list from CAM */

 read mac entries from CAM */

 read mac addr */

 Wait till command completes */

/*

 * s2io_set_mac_addr - driver entry point

 store the MAC address in CAM */

/**

 *  do_s2io_prog_unicast - Programs the Xframe mac address

 *  @dev : pointer to the device structure.

 *  @addr: a uchar pointer to the new mac address which is to be set.

 *  Description : This procedure will program the Xframe to receive

 *  frames with new Mac Address

 *  Return value: SUCCESS on success and an appropriate (-)ve integer

 *  as defined in errno.h file on failure.

	/*

	 * Set the new MAC address as the new unicast filter and reflect this

	 * change on the device address registered with the OS. It will be

	 * at offset 0.

 check if the dev_addr is different than perm_addr */

 check if the mac already preset in CAM */

 CAM entry is empty */

 Update the internal structure with this new mac address */

/**

 * s2io_ethtool_set_link_ksettings - Sets different link parameters.

 * @dev : pointer to netdev

 * @cmd: pointer to the structure with parameters given by ethtool to set

 * link information.

 * Description:

 * The function sets different link parameters provided by the user onto

 * the NIC.

 * Return value:

 * 0 on success.

/**

 * s2io_ethtool_get_link_ksettings - Return link specific information.

 * @dev: pointer to netdev

 * @cmd : pointer to the structure with parameters given by ethtool

 * to return link information.

 * Description:

 * Returns link specific information like speed, duplex etc.. to ethtool.

 * Return value :

 * return 0 on success.

/**

 * s2io_ethtool_gdrvinfo - Returns driver specific information.

 * @dev: pointer to netdev

 * @info : pointer to the structure with parameters given by ethtool to

 * return driver information.

 * Description:

 * Returns driver specefic information like name, version etc.. to ethtool.

 * Return value:

 *  void

/**

 *  s2io_ethtool_gregs - dumps the entire space of Xfame into the buffer.

 *  @dev: pointer to netdev

 *  @regs : pointer to the structure with parameters given by ethtool for

 *          dumping the registers.

 *  @space: The input argument into which all the registers are dumped.

 *  Description:

 *  Dumps the entire register space of xFrame NIC into the user given

 *  buffer area.

 * Return value :

 * void .

/*

 *  s2io_set_led - control NIC led

/**

 * s2io_ethtool_set_led - To physically identify the nic on the system.

 * @dev : network device

 * @state: led setting

 *

 * Description: Used to physically identify the NIC on the system.

 * The Link LED will blink for a time specified by the user for

 * identification.

 * NOTE: The Link has to be Up to be able to blink the LED. Hence

 * identification is possible only if it's link is up.

 cycle on/off once per second */

/**

 * s2io_ethtool_getpause_data -Pause frame frame generation and reception.

 * @dev: pointer to netdev

 * @ep : pointer to the structure with pause parameters given by ethtool.

 * Description:

 * Returns the Pause frame generation and reception capability of the NIC.

 * Return value:

 *  void

/**

 * s2io_ethtool_setpause_data -  set/reset pause frame generation.

 * @dev: pointer to netdev

 * @ep : pointer to the structure with pause parameters given by ethtool.

 * Description:

 * It can be used to set or reset Pause frame generation or reception

 * support of the NIC.

 * Return value:

 * int, returns 0 on Success

/**

 * read_eeprom - reads 4 bytes of data from user given offset.

 * @sp : private member of the device structure, which is a pointer to the

 *      s2io_nic structure.

 * @off : offset at which the data must be written

 * @data : Its an output parameter where the data read at the given

 *	offset is stored.

 * Description:

 * Will read 4 bytes of data from the user given offset and return the

 * read data.

 * NOTE: Will allow to read only part of the EEPROM visible through the

 *   I2C bus.

 * Return value:

 *  -1 on failure and 0 on success.

/**

 *  write_eeprom - actually writes the relevant part of the data value.

 *  @sp : private member of the device structure, which is a pointer to the

 *       s2io_nic structure.

 *  @off : offset at which the data must be written

 *  @data : The data that is to be written

 *  @cnt : Number of bytes of the data that are actually to be written into

 *  the Eeprom. (max of 3)

 * Description:

 *  Actually writes the relevant part of the data value into the Eeprom

 *  through the I2C bus.

 * Return value:

 *  0 on success, -1 on failure.

 read serial number of adapter */

/**

 *  s2io_ethtool_geeprom  - reads the value stored in the Eeprom.

 *  @dev: pointer to netdev

 *  @eeprom : pointer to the user level structure provided by ethtool,

 *  containing all relevant information.

 *  @data_buf : user defined value to be written into Eeprom.

 *  Description: Reads the values stored in the Eeprom at given offset

 *  for a given length. Stores these values int the input argument data

 *  buffer 'data_buf' and returns these to the caller (ethtool.)

 *  Return value:

 *  int  0 on success

/**

 *  s2io_ethtool_seeprom - tries to write the user provided value in Eeprom

 *  @dev: pointer to netdev

 *  @eeprom : pointer to the user level structure provided by ethtool,

 *  containing all relevant information.

 *  @data_buf : user defined value to be written into Eeprom.

 *  Description:

 *  Tries to write the user provided value in the Eeprom, at the offset

 *  given by the user.

 *  Return value:

 *  0 on success, -EFAULT on failure.

/**

 * s2io_register_test - reads and writes into all clock domains.

 * @sp : private member of the device structure, which is a pointer to the

 * s2io_nic structure.

 * @data : variable that returns the result of each of the test conducted b

 * by the driver.

 * Description:

 * Read and write into all clock domains. The NIC has 3 clock domains,

 * see that registers in all the three regions are accessible.

 * Return value:

 * 0 on success.

/**

 * s2io_eeprom_test - to verify that EEprom in the xena can be programmed.

 * @sp : private member of the device structure, which is a pointer to the

 * s2io_nic structure.

 * @data:variable that returns the result of each of the test conducted by

 * the driver.

 * Description:

 * Verify that EEPROM in the xena can be programmed using I2C_CONTROL

 * register.

 * Return value:

 * 0 on success.

 Test Write Error at offset 0 */

	/* Note that SPI interface allows write access to all areas

	 * of EEPROM. Hence doing all negative testing only for Xframe I.

 Save current values at offsets 0x4F0 and 0x7F0 */

 Test Write at offset 4f0 */

 Reset the EEPROM data go FFFF */

 Test Write Request Error at offset 0x7c */

 Test Write Request at offset 0x7f0 */

 Reset the EEPROM data go FFFF */

 Test Write Error at offset 0x80 */

 Test Write Error at offset 0xfc */

 Test Write Error at offset 0x100 */

 Test Write Error at offset 4ec */

 Restore values at offsets 0x4F0 and 0x7F0 */

/**

 * s2io_bist_test - invokes the MemBist test of the card .

 * @sp : private member of the device structure, which is a pointer to the

 * s2io_nic structure.

 * @data:variable that returns the result of each of the test conducted by

 * the driver.

 * Description:

 * This invokes the MemBist test of the card. We give around

 * 2 secs time for the Test to complete. If it's still not complete

 * within this peiod, we consider that the test failed.

 * Return value:

 * 0 on success and -1 on failure.

/**

 * s2io_link_test - verifies the link state of the nic

 * @sp: private member of the device structure, which is a pointer to the

 * s2io_nic structure.

 * @data: variable that returns the result of each of the test conducted by

 * the driver.

 * Description:

 * The function verifies the link state of the NIC and updates the input

 * argument 'data' appropriately.

 * Return value:

 * 0 on success.

/**

 * s2io_rldram_test - offline test for access to the RldRam chip on the NIC

 * @sp: private member of the device structure, which is a pointer to the

 * s2io_nic structure.

 * @data: variable that returns the result of each of the test

 * conducted by the driver.

 * Description:

 *  This is one of the offline test that tests the read and write

 *  access to the RldRam chip on the NIC.

 * Return value:

 *  0 on success.

 Bring the adapter out of test mode */

/**

 *  s2io_ethtool_test - conducts 6 tsets to determine the health of card.

 *  @dev: pointer to netdev

 *  @ethtest : pointer to a ethtool command specific structure that will be

 *  returned to the user.

 *  @data : variable that returns the result of each of the test

 * conducted by the driver.

 * Description:

 *  This function conducts 6 tests ( 4 offline and 2 online) to determine

 *  the health of the card.

 * Return value:

 *  void

 Offline Tests. */

 Online Tests. */

 Enhanced statistics exist only for Hercules */

		/*

		 * Since 64-bit divide does not work on all platforms,

		 * do repeated subtraction.

/**

 *  s2io_ioctl - Entry point for the Ioctl

 *  @dev :  Device pointer.

 *  @rq :  An IOCTL specefic structure, that can contain a pointer to

 *  a proprietary structure used to pass information to the driver.

 *  @cmd :  This is used to distinguish between the different commands that

 *  can be passed to the IOCTL functions.

 *  Description:

 *  Currently there are no special functionality supported in IOCTL, hence

 *  function always return EOPNOTSUPPORTED

/**

 *  s2io_change_mtu - entry point to change MTU size for the device.

 *   @dev : device pointer.

 *   @new_mtu : the new MTU size for the device.

 *   Description: A driver entry point to change MTU size for the device.

 *   Before changing the MTU the device must be stopped.

 *  Return value:

 *   0 on success and an appropriate (-)ve integer as defined in errno.h

 *   file on failure.

 Device is down */

/**

 * s2io_set_link - Set the LInk status

 * @work: work struct containing a pointer to device private structure

 * Description: Sets the link status for the adapter

 The card is being reset, no point doing anything */

		/*

		 * Allow a small delay for the NICs self initiated

		 * cleanup to complete.

 turn off LED */

 allocate skb */

			/*

			 * As Rx frame are not going to be processed,

			 * using same mapped address for the Rxd

			 * buffer pointer

			/* storing the mapped addr in a temp variable

			 * such it will be used for next rxd whose

			 * Host Control is NULL

 Two buffer Mode */

 Buffer-1 will be dummy buffer not used */

 Calculate the size based on ring mode */

 flip the Ownership bit to Hardware */

	/*

	 * Store the values of the MSIX table in

	 * the struct s2io_nic structure

 After proper initialization of H/W, register ISR */

 if either data or addr is zero print it. */

 If s2io_set_link task is executing, wait till it completes. */

 Disable napi */

 disable Tx and Rx traffic on the NIC */

 stop the tx queue, indicate link down */

 Check if the device is Quiescent and then Reset the NIC */

		/* As per the HW requirement we need to replenish the

		 * receive buffer to avoid the ring bump. Since there is

		 * no intention of processing the Rx frame at this pointwe are

		 * just setting the ownership bit of rxd in Each Rx

		 * ring to HW and set the appropriate buffer size

		 * based on the ring mode

 Free all Tx buffers */

 Free all Rx buffers */

 Initialize the H/W I/O registers */

	/*

	 * Initializing the Rx buffers. For now we are considering only 1

	 * Rx ring and initializing buffers into 30 Rx blocks

 Initialise napi */

 Maintain the state prior to the open */

 Setting its receive mode */

 Initialize max aggregatable pkts per session based on MTU */

 Check if we can use (if specified) user provided value */

 Enable Rx Traffic and interrupts on the NIC */

 Add interrupt service routine */

  Enable select interrupts */

/**

 * s2io_restart_nic - Resets the NIC.

 * @work : work struct containing a pointer to the device private structure

 * Description:

 * This function is scheduled to be run by the s2io_tx_watchdog

 * function after 0.5 secs to reset the NIC. The idea is to reduce

 * the run time of the watch dog routine which is run holding a

 * spin lock.

/**

 *  s2io_tx_watchdog - Watchdog for transmit side.

 *  @dev : Pointer to net device structure

 *  @txqueue: index of the hanging queue

 *  Description:

 *  This function is triggered if the Tx Queue is stopped

 *  for a pre-defined amount of time when the Interface is still up.

 *  If the Interface is jammed in such a situation, the hardware is

 *  reset (by s2io_close) and restarted again (by s2io_open) to

 *  overcome any problem that might have been caused in the hardware.

 *  Return value:

 *  void

/**

 *   rx_osm_handler - To perform some OS related operations on SKB.

 *   @ring_data : the ring from which this RxD was extracted.

 *   @rxdp: descriptor

 *   Description:

 *   This function is called by the Rx interrupt serivce routine to perform

 *   some OS related operations on the SKB before passing it to the upper

 *   layers. It mainly checks if the checksum is OK, if so adds it to the

 *   SKBs cksum variable, increments the Rx packet count and passes the SKB

 *   to the upper layer. If the checksum is wrong, it increments the Rx

 *   packet error count, frees the SKB and returns error.

 *   Return value:

 *   SUCCESS on success and -1 on failure.

 Check for parity error */

		/*

		 * Drop the packet if bad transfer code. Exception being

		 * 0x5, which could be due to unsupported IPv6 extension header.

		 * In this case, we let stack handle the packet.

		 * Note that in this case, since checksum will be incorrect,

		 * stack will validate the same.

			/*

			 * NIC verifies if the Checksum of the received

			 * frame is Ok or not and accordingly returns

			 * a flag in the RxD.

 Begin anew */

 Aggregate */

 Flush session */

 Flush both */

 sessions exceeded */

 non-TCP or not L2 aggregatable */

				case 5: /*

					 * First pkt in session not

					 * L3/L4 aggregatable

			/*

			 * Packet with erroneous checksum, let the

			 * upper layers deal with it.

/**

 *  s2io_link - stops/starts the Tx queue.

 *  @sp : private member of the device structure, which is a pointer to the

 *  s2io_nic structure.

 *  @link : inidicates whether link is UP/DOWN.

 *  Description:

 *  This function stops/starts the Tx queue depending on whether the link

 *  status of the NIC is is down or up. This is called by the Alarm

 *  interrupt handler whenever a link change interrupt comes up.

 *  Return value:

 *  void.

/**

 *  s2io_init_pci -Initialization of PCI and PCI-X configuration registers .

 *  @sp : private member of the device structure, which is a pointer to the

 *  s2io_nic structure.

 *  Description:

 *  This function initializes a few of the PCI and PCI-X configuration registers

 *  with recommended values.

 *  Return value:

 *  void

 Enable Data Parity Error Recovery in PCI-X command register. */

 Set the PErr Response bit in PCI command register. */

/**

 * rts_ds_steer - Receive traffic steering based on IPv4 or IPv6 TOS or Traffic class respectively.

 * @nic: device private variable

 * @ds_codepoint: data

 * @ring: ring index

 * Description: The function configures the receive steering to

 * desired receive ring.

 * Return Value:  SUCCESS on success and

 * '-1' on failure (endian settings incorrect).

/**

 *  s2io_init_nic - Initialization of the adapter .

 *  @pdev : structure containing the PCI related information of the device.

 *  @pre: List of PCI devices supported by the driver listed in s2io_tbl.

 *  Description:

 *  The function initializes an adapter identified by the pci_dec structure.

 *  All OS related initialization including memory and device structure and

 *  initlaization of the device private variable is done. Also the swapper

 *  control register is initialized to enable read and write into the I/O

 *  registers of the device.

 *  Return value:

 *  returns 0 on success and negative on failure.

  Private member variable initialized to s2io NIC structure */

 Initialize some PCI/PCI-X fields of the NIC. */

	/*

	 * Setting the device configuration parameters.

	 * Most of these parameters can be specified by the user during

	 * module insertion as they are module loadable parameters. If

	 * these parameters are not not specified during load time, they

	 * are initialized with default values.

 Tx side parameters. */

 Initialize the fifos used for tx steering */

 mapping the QoS priority to the configured fifos */

 map the hashing selector table to the configured fifos */

 + 2 because one Txd for skb->data and one Txd for UFO */

 Rx side parameters. */

  Setting Mac Control parameters */

  initialize the shared memory used by the NIC and the host */

 Initializing the BAR1 address as the start of the FIFO pointer. */

  Driver entry points */

 Setting swapper control on the NIC, for proper reset operation */

 Verify if the Herc works on the slot its placed into */

 rollback MSI-X, will re-enable during add_isr() */

 Not needed for Herc */

		/*

		 * Fix for all "FFs" MAC address problems observed on

		 * Alpha platforms

	/*

	 * MAC address initialization.

	 * For now only one mac address will be read and used.

  Set the factory defined MAC address initially   */

 initialize number of multicast & unicast MAC entries variables */

 MTU range: 46 - 9600 */

 store mac addresses from CAM to s2io_nic structure */

 Configure MSIX vector for number of rings configured plus one */

 Store the values of the MSIX table in the s2io_nic structure */

 reset Nic and bring it to known state */

	/*

	 * Initialize link state flags

	 * and the card state parameter

 Initialize spinlocks */

	/*

	 * SXE-002: Configure link and activity LED to init state

	 * on driver load.

 Rx chksum verify enabled by default */

 Initialize device name */

	/*

	 * Make Link state as off at this point, when the Link change

	 * interrupt comes the state will be automatically changed to

	 * the right state.

/**

 * s2io_rem_nic - Free the PCI device

 * @pdev: structure containing the PCI related information of the device.

 * Description: This function is called by the Pci subsystem to release a

 * PCI device and free up all resource held up by the device. This could

 * be in response to a Hot plug event or when the driver is to be removed

 * from memory.

 Checking for DIX type or DIX type with VLAN */

		/*

		 * If vlan stripping is disabled and the frame is VLAN tagged,

		 * shift the offset by the VLAN header size bytes.

 LLC, SNAP etc are considered non-mergeable */

	/*

	 * Check if we saw TCP timestamp.

	 * Other consistency checks have already been done.

 Update L3 header */

 Update L4 header */

 Update tsecr field if this session has timestamps enabled */

	/* Update counters required for calculation of

	 * average no. of packets aggregated.

 Update ack seq no. and window ad(from this pkt) in LRO object */

 Update tsecr and tsval from this packet */

 Runt frame or a pure ack */

 IP has options */

 If we see CE codepoint in IP header, packet is not mergeable */

 If we see ECE or CWR flags in TCP header, packet is not mergeable */

		/*

		 * Currently recognize only the ack control word and

		 * any other control field being set would result in

		 * flushing the LRO session

	/*

	 * Allow only one TCP timestamp option. Don't aggregate if

	 * any other options are detected.

 Ensure timestamp value increases monotonically */

 timestamp echo reply should be non-zero */

 Sock pair matched */

 Aggregate */

 Flush both */

		/* Before searching for available LRO objects,

		 * check if the pkt is L3/L4 aggregatable. If not

		 * don't create new LRO session. Just send this

		 * packet up.

 Begin anew */

 sessions exceeded */

 Flush the LRO */

/**

 * s2io_io_error_detected - called when PCI error is detected

 * @pdev: Pointer to PCI device

 * @state: The current pci connection state

 *

 * This function is called after a PCI bus error affecting

 * this device has been detected.

 Bring down the card, while avoiding PCI I/O */

/**

 * s2io_io_slot_reset - called after the pci bus has been reset.

 * @pdev: Pointer to PCI device

 *

 * Restart the card from scratch, as if from a cold-boot.

 * At this point, the card has exprienced a hard reset,

 * followed by fixups by BIOS, and has its config space

 * set up identically to what it was at cold boot.

/**

 * s2io_io_resume - called when traffic can start flowing again.

 * @pdev: Pointer to PCI device

 *

 * This callback is called when the error recovery driver tells

 * us that its OK to resume normal operation.

/******************************************************************************

 * This software may be used and distributed according to the terms of

 * the GNU General Public License (GPL), incorporated herein by reference.

 * Drivers based on or derived from this code fall under the GPL and must

 * retain the authorship, copyright and license notice.  This file is not

 * a complete program and may only be used when the entire operating

 * system is licensed under the GPL.

 * See the file COPYING in this distribution for more information.

 *

 * vxge-traffic.c: Driver for Exar Corp's X3100 Series 10GbE PCIe I/O

 *                 Virtualized Server Adapter.

 * Copyright(c) 2002-2010 Exar Corp.

/*

 * vxge_hw_vpath_intr_enable - Enable vpath interrupts.

 * @vp: Virtual Path handle.

 *

 * Enable vpath interrupts. The function is to be executed the last in

 * vpath initialization sequence.

 *

 * See also: vxge_hw_vpath_intr_disable()

 Mask unwanted interrupts */

 Unmask the individual interrupts */

/*

 * vxge_hw_vpath_intr_disable - Disable vpath interrupts.

 * @vp: Virtual Path handle.

 *

 * Disable vpath interrupts. The function is to be executed the last in

 * vpath initialization sequence.

 *

 * See also: vxge_hw_vpath_intr_enable()

	/* tti_cfg3_saved is not updated again because it is

	 * initialized at one place only - init time.

	/* rti_cfg3_saved is not updated again because it is

	 * initialized at one place only - init time.

/**

 * vxge_hw_channel_msix_mask - Mask MSIX Vector.

 * @channel: Channel for rx or tx handle

 * @msix_id:  MSIX ID

 *

 * The function masks the msix interrupt for the given msix_id

 *

 * Returns: 0

/**

 * vxge_hw_channel_msix_unmask - Unmask the MSIX Vector.

 * @channel: Channel for rx or tx handle

 * @msix_id:  MSI ID

 *

 * The function unmasks the msix interrupt for the given msix_id

 *

 * Returns: 0

/**

 * vxge_hw_channel_msix_clear - Unmask the MSIX Vector.

 * @channel: Channel for rx or tx handle

 * @msix_id:  MSI ID

 *

 * The function unmasks the msix interrupt for the given msix_id

 * if configured in MSIX oneshot mode

 *

 * Returns: 0

/**

 * vxge_hw_device_set_intr_type - Updates the configuration

 *		with new interrupt type.

 * @hldev: HW device handle.

 * @intr_mode: New interrupt type

/**

 * vxge_hw_device_intr_enable - Enable interrupts.

 * @hldev: HW device handle.

 *

 * Enable Titan interrupts. The function is to be executed the last in

 * Titan initialization sequence.

 *

 * See also: vxge_hw_device_intr_disable()

/**

 * vxge_hw_device_intr_disable - Disable Titan interrupts.

 * @hldev: HW device handle.

 *

 * Disable Titan interrupts.

 *

 * See also: vxge_hw_device_intr_enable()

 mask all the tim interrupts */

/**

 * vxge_hw_device_mask_all - Mask all device interrupts.

 * @hldev: HW device handle.

 *

 * Mask	all device interrupts.

 *

 * See also: vxge_hw_device_unmask_all()

/**

 * vxge_hw_device_unmask_all - Unmask all device interrupts.

 * @hldev: HW device handle.

 *

 * Unmask all device interrupts.

 *

 * See also: vxge_hw_device_mask_all()

/**

 * vxge_hw_device_flush_io - Flush io writes.

 * @hldev: HW device handle.

 *

 * The function	performs a read operation to flush io writes.

 *

 * Returns: void

/**

 * __vxge_hw_device_handle_error - Handle error

 * @hldev: HW device

 * @vp_id: Vpath Id

 * @type: Error type. Please see enum vxge_hw_event{}

 *

 * Handle error.

 notify driver */

/*

 * __vxge_hw_device_handle_link_down_ind

 * @hldev: HW device handle.

 *

 * Link down indication handler. The function is invoked by HW when

 * Titan indicates that the link is down.

	/*

	 * If the previous link state is not down, return.

 notify driver */

/*

 * __vxge_hw_device_handle_link_up_ind

 * @hldev: HW device handle.

 *

 * Link up indication handler. The function is invoked by HW when

 * Titan indicates that the link is up for programmable amount of time.

	/*

	 * If the previous link state is not down, return.

 notify driver */

/*

 * __vxge_hw_vpath_alarm_process - Process Alarms.

 * @vpath: Virtual Path.

 * @skip_alarms: Do not clear the alarms

 *

 * Process vpath alarms.

 *

/**

 * vxge_hw_device_begin_irq - Begin IRQ processing.

 * @hldev: HW device handle.

 * @skip_alarms: Do not clear the alarms

 * @reason: "Reason" for the interrupt, the value of Titan's

 *	general_int_status register.

 *

 * The function	performs two actions, It first checks whether (shared IRQ) the

 * interrupt was raised	by the device. Next, it	masks the device interrupts.

 *

 * Note:

 * vxge_hw_device_begin_irq() does not flush MMIO writes through the

 * bridge. Therefore, two back-to-back interrupts are potentially possible.

 *

 * Returns: 0, if the interrupt	is not "ours" (note that in this case the

 * device remain enabled).

 * Otherwise, vxge_hw_device_begin_irq() returns 64bit general adapter

 * status.

 not Titan interrupt	*/

/**

 * vxge_hw_device_clear_tx_rx - Acknowledge (that is, clear) the

 * condition that has caused the Tx and RX interrupt.

 * @hldev: HW device.

 *

 * Acknowledge (that is, clear) the condition that has caused

 * the Tx and Rx interrupt.

 * See also: vxge_hw_device_begin_irq(),

 * vxge_hw_device_mask_tx_rx(), vxge_hw_device_unmask_tx_rx().

/*

 * vxge_hw_channel_dtr_alloc - Allocate a dtr from the channel

 * @channel: Channel

 * @dtrh: Buffer to return the DTR pointer

 *

 * Allocates a dtr from the reserve array. If the reserve array is empty,

 * it swaps the reserve and free arrays.

 *

 switch between empty	and full arrays	*/

	/* the idea behind such	a design is that by having free	and reserved

	 * arrays separated we basically separated irq and non-irq parts.

/*

 * vxge_hw_channel_dtr_post - Post a dtr to the channel

 * @channelh: Channel

 * @dtrh: DTR pointer

 *

 * Posts a dtr to work array.

 *

 wrap-around */

/*

 * vxge_hw_channel_dtr_try_complete - Returns next completed dtr

 * @channel: Channel

 * @dtr: Buffer to return the next completed DTR pointer

 *

 * Returns the next completed dtr with out removing it from work array

 *

/*

 * vxge_hw_channel_dtr_complete - Removes next completed dtr from the work array

 * @channel: Channel handle

 *

 * Removes the next completed dtr from work array

 *

 wrap-around */

/*

 * vxge_hw_channel_dtr_free - Frees a dtr

 * @channel: Channel handle

 * @dtr:  DTR pointer

 *

 * Returns the dtr to free array

 *

/*

 * vxge_hw_channel_dtr_count

 * @channel: Channel handle. Obtained via vxge_hw_channel_open().

 *

 * Retrieve number of DTRs available. This function can not be called

 * from data path. ring_initial_replenishi() is the only user.

/**

 * vxge_hw_ring_rxd_reserve	- Reserve ring descriptor.

 * @ring: Handle to the ring object used for receive

 * @rxdh: Reserved descriptor. On success HW fills this "out" parameter

 * with a valid handle.

 *

 * Reserve Rx descriptor for the subsequent filling-in driver

 * and posting on the corresponding channel (@channelh)

 * via vxge_hw_ring_rxd_post().

 *

 * Returns: VXGE_HW_OK - success.

 * VXGE_HW_INF_OUT_OF_DESCRIPTORS - Currently no descriptors available.

 *

/**

 * vxge_hw_ring_rxd_free - Free descriptor.

 * @ring: Handle to the ring object used for receive

 * @rxdh: Descriptor handle.

 *

 * Free	the reserved descriptor. This operation is "symmetrical" to

 * vxge_hw_ring_rxd_reserve. The "free-ing" completes the descriptor's

 * lifecycle.

 *

 * After free-ing (see vxge_hw_ring_rxd_free()) the descriptor again can

 * be:

 *

 * - reserved (vxge_hw_ring_rxd_reserve);

 *

 * - posted	(vxge_hw_ring_rxd_post);

 *

 * - completed (vxge_hw_ring_rxd_next_completed);

 *

 * - and recycled again	(vxge_hw_ring_rxd_free).

 *

 * For alternative state transitions and more details please refer to

 * the design doc.

 *

/**

 * vxge_hw_ring_rxd_pre_post - Prepare rxd and post

 * @ring: Handle to the ring object used for receive

 * @rxdh: Descriptor handle.

 *

 * This routine prepares a rxd and posts

/**

 * vxge_hw_ring_rxd_post_post - Process rxd after post.

 * @ring: Handle to the ring object used for receive

 * @rxdh: Descriptor handle.

 *

 * Processes rxd after post

/**

 * vxge_hw_ring_rxd_post - Post descriptor on the ring.

 * @ring: Handle to the ring object used for receive

 * @rxdh: Descriptor obtained via vxge_hw_ring_rxd_reserve().

 *

 * Post	descriptor on the ring.

 * Prior to posting the	descriptor should be filled in accordance with

 * Host/Titan interface specification for a given service (LL, etc.).

 *

/**

 * vxge_hw_ring_rxd_post_post_wmb - Process rxd after post with memory barrier.

 * @ring: Handle to the ring object used for receive

 * @rxdh: Descriptor handle.

 *

 * Processes rxd after post with memory barrier.

/**

 * vxge_hw_ring_rxd_next_completed - Get the _next_ completed descriptor.

 * @ring: Handle to the ring object used for receive

 * @rxdh: Descriptor handle. Returned by HW.

 * @t_code:	Transfer code, as per Titan User Guide,

 *	 Receive Descriptor Format. Returned by HW.

 *

 * Retrieve the	_next_ completed descriptor.

 * HW uses ring callback (*vxge_hw_ring_callback_f) to notifiy

 * driver of new completed descriptors. After that

 * the driver can use vxge_hw_ring_rxd_next_completed to retrieve the rest

 * completions (the very first completion is passed by HW via

 * vxge_hw_ring_callback_f).

 *

 * Implementation-wise, the driver is free to call

 * vxge_hw_ring_rxd_next_completed either immediately from inside the

 * ring callback, or in a deferred fashion and separate (from HW)

 * context.

 *

 * Non-zero @t_code means failure to fill-in receive buffer(s)

 * of the descriptor.

 * For instance, parity	error detected during the data transfer.

 * In this case	Titan will complete the descriptor and indicate

 * for the host	that the received data is not to be used.

 * For details please refer to Titan User Guide.

 *

 * Returns: VXGE_HW_OK - success.

 * VXGE_HW_INF_NO_MORE_COMPLETED_DESCRIPTORS - No completed descriptors

 * are currently available for processing.

 *

 * See also: vxge_hw_ring_callback_f{},

 * vxge_hw_fifo_rxd_next_completed(), enum vxge_hw_status{}.

 check whether it is not the end */

	/* reset it. since we don't want to return

/**

 * vxge_hw_ring_handle_tcode - Handle transfer code.

 * @ring: Handle to the ring object used for receive

 * @rxdh: Descriptor handle.

 * @t_code: One of the enumerated (and documented in the Titan user guide)

 * "transfer codes".

 *

 * Handle descriptor's transfer code. The latter comes with each completed

 * descriptor.

 *

 * Returns: one of the enum vxge_hw_status{} enumerated types.

 * VXGE_HW_OK			- for success.

 * VXGE_HW_ERR_CRITICAL         - when encounters critical error.

	/* If the t_code is not supported and if the

	 * t_code is other than 0x5 (unparseable packet

	 * such as unknown UPV6 header), Drop it !!!

/**

 * __vxge_hw_non_offload_db_post - Post non offload doorbell

 *

 * @fifo: fifohandle

 * @txdl_ptr: The starting location of the TxDL in host memory

 * @num_txds: The highest TxD in this TxDL (0 to 255 means 1 to 256)

 * @no_snoop: No snoop flags

 *

 * This function posts a non-offload doorbell to doorbell FIFO

 *

/**

 * vxge_hw_fifo_free_txdl_count_get - returns the number of txdls available in

 * the fifo

 * @fifoh: Handle to the fifo object used for non offload send

/**

 * vxge_hw_fifo_txdl_reserve - Reserve fifo descriptor.

 * @fifo: Handle to the fifo object used for non offload send

 * @txdlh: Reserved descriptor. On success HW fills this "out" parameter

 *        with a valid handle.

 * @txdl_priv: Buffer to return the pointer to per txdl space

 *

 * Reserve a single TxDL (that is, fifo descriptor)

 * for the subsequent filling-in by driver)

 * and posting on the corresponding channel (@channelh)

 * via vxge_hw_fifo_txdl_post().

 *

 * Note: it is the responsibility of driver to reserve multiple descriptors

 * for lengthy (e.g., LSO) transmit operation. A single fifo descriptor

 * carries up to configured number (fifo.max_frags) of contiguous buffers.

 *

 * Returns: VXGE_HW_OK - success;

 * VXGE_HW_INF_OUT_OF_DESCRIPTORS - Currently no descriptors available

 *

 reset the TxDL's private */

/**

 * vxge_hw_fifo_txdl_buffer_set - Set transmit buffer pointer in the

 * descriptor.

 * @fifo: Handle to the fifo object used for non offload send

 * @txdlh: Descriptor handle.

 * @frag_idx: Index of the data buffer in the caller's scatter-gather list

 *            (of buffers).

 * @dma_pointer: DMA address of the data buffer referenced by @frag_idx.

 * @size: Size of the data buffer (in bytes).

 *

 * This API is part of the preparation of the transmit descriptor for posting

 * (via vxge_hw_fifo_txdl_post()). The related "preparation" APIs include

 * vxge_hw_fifo_txdl_mss_set() and vxge_hw_fifo_txdl_cksum_set_bits().

 * All three APIs fill in the fields of the fifo descriptor,

 * in accordance with the Titan specification.

 *

/**

 * vxge_hw_fifo_txdl_post - Post descriptor on the fifo channel.

 * @fifo: Handle to the fifo object used for non offload send

 * @txdlh: Descriptor obtained via vxge_hw_fifo_txdl_reserve()

 *

 * Post descriptor on the 'fifo' type channel for transmission.

 * Prior to posting the descriptor should be filled in accordance with

 * Host/Titan interface specification for a given service (LL, etc.).

 *

/**

 * vxge_hw_fifo_txdl_next_completed - Retrieve next completed descriptor.

 * @fifo: Handle to the fifo object used for non offload send

 * @txdlh: Descriptor handle. Returned by HW.

 * @t_code: Transfer code, as per Titan User Guide,

 *          Transmit Descriptor Format.

 *          Returned by HW.

 *

 * Retrieve the _next_ completed descriptor.

 * HW uses channel callback (*vxge_hw_channel_callback_f) to notifiy

 * driver of new completed descriptors. After that

 * the driver can use vxge_hw_fifo_txdl_next_completed to retrieve the rest

 * completions (the very first completion is passed by HW via

 * vxge_hw_channel_callback_f).

 *

 * Implementation-wise, the driver is free to call

 * vxge_hw_fifo_txdl_next_completed either immediately from inside the

 * channel callback, or in a deferred fashion and separate (from HW)

 * context.

 *

 * Non-zero @t_code means failure to process the descriptor.

 * The failure could happen, for instance, when the link is

 * down, in which case Titan completes the descriptor because it

 * is not able to send the data out.

 *

 * For details please refer to Titan User Guide.

 *

 * Returns: VXGE_HW_OK - success.

 * VXGE_HW_INF_NO_MORE_COMPLETED_DESCRIPTORS - No completed descriptors

 * are currently available for processing.

 *

 check whether host owns it */

 no more completions */

/**

 * vxge_hw_fifo_handle_tcode - Handle transfer code.

 * @fifo: Handle to the fifo object used for non offload send

 * @txdlh: Descriptor handle.

 * @t_code: One of the enumerated (and documented in the Titan user guide)

 *          "transfer codes".

 *

 * Handle descriptor's transfer code. The latter comes with each completed

 * descriptor.

 *

 * Returns: one of the enum vxge_hw_status{} enumerated types.

 * VXGE_HW_OK - for success.

 * VXGE_HW_ERR_CRITICAL - when encounters critical error.

/**

 * vxge_hw_fifo_txdl_free - Free descriptor.

 * @fifo: Handle to the fifo object used for non offload send

 * @txdlh: Descriptor handle.

 *

 * Free the reserved descriptor. This operation is "symmetrical" to

 * vxge_hw_fifo_txdl_reserve. The "free-ing" completes the descriptor's

 * lifecycle.

 *

 * After free-ing (see vxge_hw_fifo_txdl_free()) the descriptor again can

 * be:

 *

 * - reserved (vxge_hw_fifo_txdl_reserve);

 *

 * - posted (vxge_hw_fifo_txdl_post);

 *

 * - completed (vxge_hw_fifo_txdl_next_completed);

 *

 * - and recycled again (vxge_hw_fifo_txdl_free).

 *

 * For alternative state transitions and more details please refer to

 * the design doc.

 *

/**

 * vxge_hw_vpath_mac_addr_add - Add the mac address entry for this vpath to MAC address table.

 * @vp: Vpath handle.

 * @macaddr: MAC address to be added for this vpath into the list

 * @macaddr_mask: MAC address mask for macaddr

 * @duplicate_mode: Duplicate MAC address add mode. Please see

 *             enum vxge_hw_vpath_mac_addr_add_mode{}

 *

 * Adds the given mac address and mac address mask into the list for this

 * vpath.

 * see also: vxge_hw_vpath_mac_addr_delete, vxge_hw_vpath_mac_addr_get and

 * vxge_hw_vpath_mac_addr_get_next

 *

/**

 * vxge_hw_vpath_mac_addr_get - Get the first mac address entry

 * @vp: Vpath handle.

 * @macaddr: First MAC address entry for this vpath in the list

 * @macaddr_mask: MAC address mask for macaddr

 *

 * Get the first mac address entry for this vpath from MAC address table.

 * Return: the first mac address and mac address mask in the list for this

 * vpath.

 * see also: vxge_hw_vpath_mac_addr_get_next

 *

/**

 * vxge_hw_vpath_mac_addr_get_next - Get the next mac address entry

 * @vp: Vpath handle.

 * @macaddr: Next MAC address entry for this vpath in the list

 * @macaddr_mask: MAC address mask for macaddr

 *

 * Get the next mac address entry for this vpath from MAC address table.

 * Return: the next mac address and mac address mask in the list for this

 * vpath.

 * see also: vxge_hw_vpath_mac_addr_get

 *

/**

 * vxge_hw_vpath_mac_addr_delete - Delete the mac address entry for this vpath to MAC address table.

 * @vp: Vpath handle.

 * @macaddr: MAC address to be added for this vpath into the list

 * @macaddr_mask: MAC address mask for macaddr

 *

 * Delete the given mac address and mac address mask into the list for this

 * vpath.

 * see also: vxge_hw_vpath_mac_addr_add, vxge_hw_vpath_mac_addr_get and

 * vxge_hw_vpath_mac_addr_get_next

 *

/**

 * vxge_hw_vpath_vid_add - Add the vlan id entry for this vpath to vlan id table.

 * @vp: Vpath handle.

 * @vid: vlan id to be added for this vpath into the list

 *

 * Adds the given vlan id into the list for this  vpath.

 * see also: vxge_hw_vpath_vid_delete

 *

/**

 * vxge_hw_vpath_vid_delete - Delete the vlan id entry for this vpath

 *               to vlan id table.

 * @vp: Vpath handle.

 * @vid: vlan id to be added for this vpath into the list

 *

 * Adds the given vlan id into the list for this  vpath.

 * see also: vxge_hw_vpath_vid_add

 *

/**

 * vxge_hw_vpath_promisc_enable - Enable promiscuous mode.

 * @vp: Vpath handle.

 *

 * Enable promiscuous mode of Titan-e operation.

 *

 * See also: vxge_hw_vpath_promisc_disable().

 Enable promiscuous mode for function 0 only */

/**

 * vxge_hw_vpath_promisc_disable - Disable promiscuous mode.

 * @vp: Vpath handle.

 *

 * Disable promiscuous mode of Titan-e operation.

 *

 * See also: vxge_hw_vpath_promisc_enable().

/*

 * vxge_hw_vpath_bcast_enable - Enable broadcast

 * @vp: Vpath handle.

 *

 * Enable receiving broadcasts.

/**

 * vxge_hw_vpath_mcast_enable - Enable multicast addresses.

 * @vp: Vpath handle.

 *

 * Enable Titan-e multicast addresses.

 * Returns: VXGE_HW_OK on success.

 *

/**

 * vxge_hw_vpath_mcast_disable - Disable  multicast addresses.

 * @vp: Vpath handle.

 *

 * Disable Titan-e multicast addresses.

 * Returns: VXGE_HW_OK - success.

 * VXGE_HW_ERR_INVALID_HANDLE - Invalid handle

 *

/*

 * vxge_hw_vpath_alarm_process - Process Alarms.

 * @vpath: Virtual Path.

 * @skip_alarms: Do not clear the alarms

 *

 * Process vpath alarms.

 *

/**

 * vxge_hw_vpath_msix_set - Associate MSIX vectors with TIM interrupts and

 *                            alrms

 * @vp: Virtual Path handle.

 * @tim_msix_id: MSIX vectors associated with VXGE_HW_MAX_INTR_PER_VP number of

 *             interrupts(Can be repeated). If fifo or ring are not enabled

 *             the MSIX vector for that should be set to 0

 * @alarm_msix_id: MSIX vector for alarm.

 *

 * This API will associate a given MSIX vector numbers with the four TIM

 * interrupts and alarm interrupt.

/**

 * vxge_hw_vpath_msix_mask - Mask MSIX Vector.

 * @vp: Virtual Path handle.

 * @msix_id:  MSIX ID

 *

 * The function masks the msix interrupt for the given msix_id

 *

 * Returns: 0,

 * Otherwise, VXGE_HW_ERR_WRONG_IRQ if the msix index is out of range

 * status.

 * See also:

/**

 * vxge_hw_vpath_msix_clear - Clear MSIX Vector.

 * @vp: Virtual Path handle.

 * @msix_id:  MSI ID

 *

 * The function clears the msix interrupt for the given msix_id

 *

 * Returns: 0,

 * Otherwise, VXGE_HW_ERR_WRONG_IRQ if the msix index is out of range

 * status.

 * See also:

/**

 * vxge_hw_vpath_msix_unmask - Unmask the MSIX Vector.

 * @vp: Virtual Path handle.

 * @msix_id:  MSI ID

 *

 * The function unmasks the msix interrupt for the given msix_id

 *

 * Returns: 0,

 * Otherwise, VXGE_HW_ERR_WRONG_IRQ if the msix index is out of range

 * status.

 * See also:

/**

 * vxge_hw_vpath_inta_mask_tx_rx - Mask Tx and Rx interrupts.

 * @vp: Virtual Path handle.

 *

 * Mask Tx and Rx vpath interrupts.

 *

 * See also: vxge_hw_vpath_inta_mask_tx_rx()

/**

 * vxge_hw_vpath_inta_unmask_tx_rx - Unmask Tx and Rx interrupts.

 * @vp: Virtual Path handle.

 *

 * Unmask Tx and Rx vpath interrupts.

 *

 * See also: vxge_hw_vpath_inta_mask_tx_rx()

/**

 * vxge_hw_vpath_poll_rx - Poll Rx Virtual Path for completed

 * descriptors and process the same.

 * @ring: Handle to the ring object used for receive

 *

 * The function	polls the Rx for the completed	descriptors and	calls

 * the driver via supplied completion	callback.

 *

 * Returns: VXGE_HW_OK, if the polling is completed successful.

 * VXGE_HW_COMPLETIONS_REMAIN: There are still more completed

 * descriptors available which are yet to be processed.

 *

 * See also: vxge_hw_vpath_poll_rx()

			/*

			 * Each RxD is of 4 qwords, update the number of

			 * qwords replenished

 For each block add 4 more qwords */

 Reset total count */

/**

 * vxge_hw_vpath_poll_tx - Poll Tx for completed descriptors and process the same.

 * @fifo: Handle to the fifo object used for non offload send

 * @skb_ptr: pointer to skb

 * @nr_skb: number of skbs

 * @more: more is coming

 *

 * The function polls the Tx for the completed descriptors and calls

 * the driver via supplied completion callback.

 *

 * Returns: VXGE_HW_OK, if the polling is completed successful.

 * VXGE_HW_COMPLETIONS_REMAIN: There are still more completed

 * descriptors available which are yet to be processed.

/******************************************************************************

 * This software may be used and distributed according to the terms of

 * the GNU General Public License (GPL), incorporated herein by reference.

 * Drivers based on or derived from this code fall under the GPL and must

 * retain the authorship, copyright and license notice.  This file is not

 * a complete program and may only be used when the entire operating

 * system is licensed under the GPL.

 * See the file COPYING in this distribution for more information.

 *

 * vxge-ethtool.c: Driver for Exar Corp's X3100 Series 10GbE PCIe I/O

 *                 Virtualized Server Adapter.

 * Copyright(c) 2002-2010 Exar Corp.

/**

 * vxge_ethtool_set_link_ksettings - Sets different link parameters.

 * @dev: device pointer.

 * @cmd: pointer to the structure with parameters given by ethtool to set

 * link information.

 *

 * The function sets different link parameters provided by the user onto

 * the NIC.

 * Return value:

 * 0 on success.

 We currently only support 10Gb/FULL */

/**

 * vxge_ethtool_get_link_ksettings - Return link specific information.

 * @dev: device pointer.

 * @cmd: pointer to the structure with parameters given by ethtool

 * to return link information.

 *

 * Returns link specific information like speed, duplex etc.. to ethtool.

 * Return value :

 * return 0 on success.

/**

 * vxge_ethtool_gdrvinfo - Returns driver specific information.

 * @dev: device pointer.

 * @info: pointer to the structure with parameters given by ethtool to

 * return driver information.

 *

 * Returns driver specefic information like name, version etc.. to ethtool.

/**

 * vxge_ethtool_gregs - dumps the entire space of Titan into the buffer.

 * @dev: device pointer.

 * @regs: pointer to the structure with parameters given by ethtool for

 * dumping the registers.

 * @space: The input argument into which all the registers are dumped.

 *

 * Dumps the vpath register space of Titan NIC into the user given

 * buffer area.

/**

 * vxge_ethtool_idnic - To physically identify the nic on the system.

 * @dev : device pointer.

 * @state : requested LED state

 *

 * Used to physically identify the NIC on the system.

 * 0 on success

/**

 * vxge_ethtool_getpause_data - Pause frame frame generation and reception.

 * @dev : device pointer.

 * @ep : pointer to the structure with pause parameters given by ethtool.

 * Description:

 * Returns the Pause frame generation and reception capability of the NIC.

 * Return value:

 *  void

/**

 * vxge_ethtool_setpause_data -  set/reset pause frame generation.

 * @dev : device pointer.

 * @ep : pointer to the structure with pause parameters given by ethtool.

 * Description:

 * It can be used to set or reset Pause frame generation or reception

 * support of the NIC.

 * Return value:

 * int, returns 0 on Success

/******************************************************************************

 * This software may be used and distributed according to the terms of

 * the GNU General Public License (GPL), incorporated herein by reference.

 * Drivers based on or derived from this code fall under the GPL and must

 * retain the authorship, copyright and license notice.  This file is not

 * a complete program and may only be used when the entire operating

 * system is licensed under the GPL.

 * See the file COPYING in this distribution for more information.

 *

 * vxge-config.c: Driver for Exar Corp's X3100 Series 10GbE PCIe I/O

 *                Virtualized Server Adapter.

 * Copyright(c) 2002-2010 Exar Corp.

/*

 * vxge_hw_vpath_wait_receive_idle - Wait for Rx to become idle

	/* Check that the ring controller for this vpath has enough free RxDs

	 * to send frames to the host.  This is done by reading the

	 * PRC_RXD_DOORBELL_VPn register and comparing the read value to the

	 * RXD_SPAT value for the vpath.

	/* Use a factor of 2 when comparing rxd_count against rxd_spat for some

	 * leg room.

		/* Check that the ring controller for this vpath does

		 * not have any frame in its pipeline.

/* vxge_hw_device_wait_receive_idle - This function waits until all frames

 * stored in the frame buffer for each vpath assigned to the given

 * function (hldev) have been sent to the host.

/*

 * __vxge_hw_device_register_poll

 * Will poll certain register for specified amount of time.

 * Will poll until masked bit is not cleared.

	/* The __vxge_hw_device_register_poll can udelay for a significant

	 * amount of time, blocking other process from the CPU.  If it delays

	 * for ~5secs, a NMI error can occur.  A way around this is to give up

	 * the processor via msleep, but this is not allowed is under lock.

	 * So, only allow it to sleep for ~4secs if open.  Otherwise, delay for

	 * 1sec and sleep for 10ms until the firmware operation has completed

	 * or timed-out.

 send upgrade start command */

 Transfer fw image to adapter 16 bytes at a time */

 The next 128bits of fwdata to be loaded onto the adapter */

 All OK, send next 16 bytes. */

 skip bytes in the stream */

 point to next 16 bytes */

/*

 * __vxge_hw_channel_free - Free memory allocated for channel

 * This function deallocates memory from the channel and various arrays

 * in the channel

/*

 * __vxge_hw_channel_initialize - Initialize a channel

 * This function initializes a channel by properly setting the

 * various references

/*

 * __vxge_hw_channel_reset - Resets a channel

 * This function resets a channel by properly setting the various references

/*

 * __vxge_hw_device_pci_e_init

 * Initialize certain PCI/PCI-X configuration registers

 * with recommended values. Save config space for future hw resets.

 Set the PErr Repconse bit and SERR in PCI command register. */

/* __vxge_hw_device_vpath_reset_in_prog_check - Check if vpath reset

 * in progress

 * This routine checks the vpath reset in progress register is turned zero

/*

 * _hw_legacy_swapper_set - Set the swapper bits for the legacy secion.

 * Set the swapper bits appropriately for the lagacy section.

/*

 * __vxge_hw_device_toc_get

 * This routine sets the swapper and reads the toc pointer and returns the

 * memory mapped address of the toc

/*

 * __vxge_hw_device_reg_addr_get

 * This routine sets the swapper and reads the toc pointer and initializes the

 * register location pointers in the device object. It waits until the ric is

 * completed initializing registers.

/*

 * __vxge_hw_device_access_rights_get: Get Access Rights of the driver

 * This routine returns the Access Rights of the driver

/*

 * __vxge_hw_device_is_privilaged

 * This routine checks if the device function is privilaged or not

/*

 * __vxge_hw_vpath_func_id_get - Get the function id of the vpath.

 * Returns the function number of the vpath.

/*

 * __vxge_hw_device_host_info_get

 * This routine returns the host type assignments

/*

 * __vxge_hw_verify_pci_e_info - Validate the pci-e link parameters such as

 * link width and signalling rate.

 Get the negotiated link width and speed from PCI config space */

/*

 * __vxge_hw_device_initialize

 * Initialize Titan-V hardware.

 Validate the pci-e link width and speed */

/*

 * __vxge_hw_vpath_fw_ver_get - Get the fw version

 * Returns FW Version

/*

 * __vxge_hw_vpath_card_info_get - Get the serial numbers,

 * part number and product description.

/*

 * __vxge_hw_vpath_pci_func_mode_get - Get the pci mode

 * Returns pci function mode

/*

 * __vxge_hw_vpath_addr_get - Get the hw address entry for this vpath

 *               from MAC address table.

/**

 * vxge_hw_device_hw_info_get - Get the hw information

 * @bar0: the bar

 * @hw_info: the hw_info struct

 *

 * Returns the vpath mask that has the bits set for each vpath allocated

 * for the driver, FW version information, and the first mac address for

 * each vpath

/*

 * __vxge_hw_blockpool_destroy - Deallocates the block pool

/*

 * __vxge_hw_blockpool_create - Create block pool

/*

 * __vxge_hw_device_fifo_config_check - Check fifo configuration.

 * Check the fifo configuration

/*

 * __vxge_hw_device_vpath_config_check - Check vpath configuration.

 * Check the vpath configuration

/*

 * __vxge_hw_device_config_check - Check device configuration.

 * Check the device configuration

/*

 * vxge_hw_device_initialize - Initialize Titan device.

 * Initialize Titan device. Note that all the arguments of this public API

 * are 'IN', including @hldev. Driver cooperates with

 * OS to find new Titan device, locate its PCI and memory spaces.

 *

 * When done, the driver allocates sizeof(struct __vxge_hw_device) bytes for HW

 * to enable the latter to perform Titan hardware initialization.

 apply config */

 Incrementing for stats blocks */

/*

 * vxge_hw_device_terminate - Terminate Titan device.

 * Terminate HW device.

/*

 * __vxge_hw_vpath_stats_access - Get the statistics from the given location

 *                           and offset and perform an operation

/*

 * __vxge_hw_vpath_xmac_tx_stats_get - Get the TX Statistics of a vpath

/*

 * __vxge_hw_vpath_xmac_rx_stats_get - Get the RX Statistics of a vpath

/*

 * __vxge_hw_vpath_stats_get - Get the vpath hw statistics.

/*

 * vxge_hw_device_stats_get - Get the device hw statistics.

 * Returns the vpath h/w stats for the device.

/*

 * vxge_hw_driver_stats_get - Get the device sw statistics.

 * Returns the vpath s/w stats for the device.

/*

 * vxge_hw_mrpcim_stats_access - Access the statistics from the given location

 *                           and offset and perform an operation

 * Get the statistics from the given location and offset.

/*

 * vxge_hw_device_xmac_aggr_stats_get - Get the Statistics on aggregate port

 * Get the Statistics on aggregate port

/*

 * vxge_hw_device_xmac_port_stats_get - Get the Statistics on a port

 * Get the Statistics on port

/*

 * vxge_hw_device_xmac_stats_get - Get the XMAC Statistics

 * Get the XMAC Statistics

/*

 * vxge_hw_device_debug_set - Set the debug module, level and timestamp

 * This routine is used to dynamically change the debug output

/*

 * vxge_hw_device_error_level_get - Get the error level

 * This routine returns the current error level set

/*

 * vxge_hw_device_trace_level_get - Get the trace level

 * This routine returns the current trace level set

/*

 * vxge_hw_getpause_data -Pause frame frame generation and reception.

 * Returns the Pause frame generation and reception capability of the NIC.

/*

 * vxge_hw_device_setpause_data -  set/reset pause frame generation.

 * It can be used to set or reset Pause frame generation or reception

 * support of the NIC.

/*

 * __vxge_hw_ring_block_memblock_idx - Return the memblock index

 * This function returns the index of memory block

/*

 * __vxge_hw_ring_block_memblock_idx_set - Sets the memblock index

 * This function sets index to a memory block

/*

 * __vxge_hw_ring_block_next_pointer_set - Sets the next block pointer

 * in RxD block

 * Sets the next block pointer in RxD block

/*

 * __vxge_hw_ring_first_block_address_get - Returns the dma address of the

 *             first block

 * Returns the dma address of the first RxD block

/*

 * __vxge_hw_ring_item_dma_addr - Return the dma address of an item

 * This function returns the dma address of a given item

 get owner memblock index */

 get owner memblock by memblock index */

 get memblock DMA object by memblock index */

 calculate offset in the memblock of this item */

/*

 * __vxge_hw_ring_rxdblock_link - Link the RxD blocks

 * This function returns the dma address of a given item

 get "from" RxD block */

 get "to" RxD block */

 return address of the beginning of previous RxD block */

	/* set next pointer for this RxD block to point on

/*

 * __vxge_hw_ring_mempool_item_alloc - Allocate List blocks for RxD

 * block callback

 * This function is callback passed to __vxge_hw_mempool_create to create memory

 * pool for RxD block

 format rxds array */

		/* Note: memblock_item_idx is index of the item within

		 *       the memblock. For instance, in case of three RxD-blocks

 pre-format Host_Control */

 link last one with first one */

 link this RxD block with previous one */

/*

 * __vxge_hw_ring_replenish - Initial replenish of RxDs

 * This function replenishes the RxDs from reserve array to work array

/*

 * __vxge_hw_channel_allocate - Allocate memory for channel

 * This function allocates required memory for the channel and various arrays

 * in the channel

/*

 * vxge_hw_blockpool_block_add - callback for vxge_os_dma_malloc_async

 * Adds a block to block pool

/*

 * __vxge_hw_blockpool_blocks_add - Request additional blocks

/*

 * __vxge_hw_blockpool_malloc - Allocate a memory block from pool

 * Allocates a block of memory of given size, either from block pool

 * or by calling vxge_os_dma_malloc()

/*

 * __vxge_hw_blockpool_blocks_remove - Free additional blocks

/*

 * __vxge_hw_blockpool_free - Frees the memory allcoated with

 *				__vxge_hw_blockpool_malloc

/*

 * vxge_hw_mempool_destroy

 to skip last partially filled(if any) memblock */

/*

 * __vxge_hw_mempool_grow

 * Will resize mempool up to %num_allocate value.

		/* allocate memblock's private part. Each DMA memblock

		 * has a space allocated for item's private usage upon

		 * mempool's user request. Each time mempool grows, it will

		 * allocate new memblock and its private part at once.

 allocate DMA-capable memblock */

 fill the items hash array */

 let caller to do more job on each item */

/*

 * vxge_hw_mempool_create

 * This function will create memory pool object. Pool may grow but will

 * never shrink. Pool consists of number of dynamically allocated blocks

 * with size enough to hold %items_initial number of items. Memory is

 * DMA-able but client must map/unmap before interoperating with the device.

 allocate array of memblocks */

 allocate array of private parts of items per memblocks */

 allocate array of memblocks DMA objects */

 allocate hash array of items */

 calculate initial number of memblocks */

 pre-allocate the mempool */

/*

 * __vxge_hw_ring_abort - Returns the RxD

 * This function terminates the RxDs of ring

/*

 * __vxge_hw_ring_reset - Resets the ring

 * This function resets the ring during vpath reset operation

/*

 * __vxge_hw_ring_delete - Removes the ring

 * This function freeup the memory pool and removes the ring

/*

 * __vxge_hw_ring_create - Create a Ring

 * This function creates Ring and initializes it.

	/* how many RxDs can fit into one block. Depends on configured

 calculate actual RxD block private size */

	/* Note:

	 * Specifying rxd_init callback means two things:

	 * 1) rxds need to be initialized by driver at channel-open time;

	 * 2) rxds need to be posted at channel-open time

	 *    (that's what the initial_replenish() below does)

	 * Currently we don't have a case when the 1) is done without the 2).

	/* initial replenish will increment the counter in its post() routine,

/*

 * vxge_hw_device_config_default_get - Initialize device config with defaults.

 * Initialize Titan device config with default values.

/*

 * __vxge_hw_vpath_swapper_set - Set the swapper bits for the vpath.

 * Set the swapper bits appropriately for the vpath.

/*

 * __vxge_hw_kdfc_swapper_set - Set the swapper bits for the kdfc.

 * Set the swapper bits appropriately for the vpath.

/*

 * vxge_hw_mgmt_reg_read - Read Titan register.

/*

 * vxge_hw_vpath_strip_fcs_check - Check for FCS strip.

/*

 * vxge_hw_mgmt_reg_Write - Write Titan register.

/*

 * __vxge_hw_fifo_abort - Returns the TxD

 * This function terminates the TxDs of fifo

/*

 * __vxge_hw_fifo_reset - Resets the fifo

 * This function resets the fifo during vpath reset operation

/*

 * __vxge_hw_fifo_delete - Removes the FIFO

 * This function freeup the memory pool and removes the FIFO

/*

 * __vxge_hw_fifo_mempool_item_alloc - Allocate List blocks for TxD

 * list callback

 * This function is callback passed to __vxge_hw_mempool_create to create memory

 * pool for TxD list

 pre-format HW's TxDL's private */

/*

 * __vxge_hw_fifo_create - Create a FIFO

 * This function creates FIFO and initializes it.

 apply "interrupts per txdl" attribute */

	/*

	 * FIFO memory management strategy:

	 *

	 * TxDL split into three independent parts:

	 *	- set of TxD's

	 *	- TxD HW private part

	 *	- driver private part

	 *

	 * Adaptative memory allocation used. i.e. Memory allocated on

	 * demand with the size which will fit into one memory block.

	 * One memory block may contain more than one TxDL.

	 *

	 * During "reserve" operations more memory can be allocated on demand

	 * for example due to FIFO full condition.

	 *

	 * Pool of memory memblocks never shrinks except in __vxge_hw_fifo_close

	 * routine which will essentially stop the channel and free resources.

 TxDL common private size == TxDL private  +  driver private */

 recompute txdl size to be cacheline aligned */

/*

 * __vxge_hw_vpath_pci_read - Read the content of given address

 *                          in pci config space.

 * Read from the vpath pci config space.

/**

 * vxge_hw_device_flick_link_led - Flick (blink) link LED.

 * @hldev: HW device.

 * @on_off: TRUE if flickering to be on, FALSE to be off

 *

 * Flicker the link LED.

/*

 * __vxge_hw_vpath_rts_table_get - Get the entries from RTS access tables

/*

 * __vxge_hw_vpath_rts_table_set - Set the entries of RTS access tables

/*

 * vxge_hw_vpath_rts_rth_set - Set/configure RTS hashing.

/*

 * vxge_hw_vpath_rts_rth_itable_set - Set/configure indirection table (IT).

/**

 * vxge_hw_vpath_check_leak - Check for memory leak

 * @ring: Handle to the ring object used for receive

 *

 * If PRC_RXD_DOORBELL_VPn.NEW_QW_CNT is larger or equal to

 * PRC_CFG6_VPn.RXD_SPAT then a leak has occurred.

 * Returns: VXGE_HW_FAIL, if leak has occurred.

 *

/*

 * __vxge_hw_vpath_mgmt_read

 * This routine reads the vpath_mgmt registers

/*

 * __vxge_hw_vpath_reset_check - Check if resetting the vpath completed

 * This routine checks the vpath_rst_in_prog register to see if

 * adapter completed the reset process for the vpath

/*

 * __vxge_hw_vpath_reset

 * This routine resets the vpath on the device

/*

 * __vxge_hw_vpath_sw_reset

 * This routine resets the vpath structures

/*

 * __vxge_hw_vpath_prc_configure

 * This routine configures the prc registers of virtual path using the config

 * passed

/*

 * __vxge_hw_vpath_kdfc_configure

 * This routine configures the kdfc registers of virtual path using the

 * config passed

/*

 * __vxge_hw_vpath_mac_configure

 * This routine configures the mac of virtual path using the config passed

/*

 * __vxge_hw_vpath_tim_configure

 * This routine configures the tim registers of virtual path using the config

 * passed

/*

 * __vxge_hw_vpath_initialize

 * This routine is the final phase of init which initializes the

 * registers of the vpath using the configuration passed.

 Get MRRS value from device control */

/*

 * __vxge_hw_vp_terminate - Terminate Virtual Path structure

 * This routine closes all channels it opened and freeup memory

	/* If the whole struct __vxge_hw_virtualpath is zeroed, nothing will

	 * work after the interface is brought down.

/*

 * __vxge_hw_vp_initialize - Initialize Virtual Path structure

 * This routine is the initial phase of init which resets the vpath and

 * initializes the software support structures.

/*

 * vxge_hw_vpath_mtu_set - Set MTU.

 * Set new MTU value. Example, to use jumbo frames:

 * vxge_hw_vpath_mtu_set(my_device, 9600);

/*

 * vxge_hw_vpath_stats_enable - Enable vpath h/wstatistics.

 * Enable the DMA vpath statistics. The function is to be called to re-enable

 * the adapter to update stats into the host memory

/*

 * __vxge_hw_blockpool_block_allocate - Allocates a block from block pool

 * This function allocates a block from block pool or from the system

/*

 * vxge_hw_vpath_open - Open a virtual path on a given adapter

 * This function is used to open access to virtual path of an

 * adapter for offload, GRO operations. This function returns

 * synchronously.

/**

 * vxge_hw_vpath_rx_doorbell_init - Close the handle got from previous vpath

 * (vpath) open

 * @vp: Handle got from previous vpath open

 *

 * This function is used to close access to virtual path opened

 * earlier.

	/*

	 * Each RxD is of 4 qwords

/*

 * __vxge_hw_blockpool_block_free - Frees a block from block pool

 * @devh: Hal device

 * @entry: Entry of block to be freed

 *

 * This function frees a block from block pool

/*

 * vxge_hw_vpath_close - Close the handle got from previous vpath (vpath) open

 * This function is used to close access to virtual path opened

 * earlier.

/*

 * vxge_hw_vpath_reset - Resets vpath

 * This function is used to request a reset of vpath

/*

 * vxge_hw_vpath_recover_from_reset - Poll for reset complete and re-initialize.

 * This function poll's for the vpath reset completion and re initializes

 * the vpath.

/*

 * vxge_hw_vpath_enable - Enable vpath.

 * This routine clears the vpath reset thereby enabling a vpath

 * to start forwarding frames and generating interrupts.

/******************************************************************************

* This software may be used and distributed according to the terms of

* the GNU General Public License (GPL), incorporated herein by reference.

* Drivers based on or derived from this code fall under the GPL and must

* retain the authorship, copyright and license notice.  This file is not

* a complete program and may only be used when the entire operating

* system is licensed under the GPL.

* See the file COPYING in this distribution for more information.

*

* vxge-main.c: Driver for Exar Corp's X3100 Series 10GbE PCIe I/O

*              Virtualized Server Adapter.

* Copyright(c) 2002-2010 Exar Corp.

*

* The module loadable parameters that are supported by the driver and a brief

* explanation of all the variables:

* vlan_tag_strip:

*	Strip VLAN Tag enable/disable. Instructs the device to remove

*	the VLAN tag from all received tagged frames that are not

*	replicated at the internal L2 switch.

*		0 - Do not strip the VLAN tag.

*		1 - Strip the VLAN tag.

*

* addr_learn_en:

*	Enable learning the mac address of the guest OS interface in

*	a virtualization environment.

*		0 - DISABLE

*		1 - ENABLE

*

* max_config_port:

*	Maximum number of port to be supported.

*		MIN -1 and MAX - 2

*

* max_config_vpath:

*	This configures the maximum no of VPATH configures for each

* 	device function.

*		MIN - 1 and MAX - 17

*

* max_config_dev:

*	This configures maximum no of Device function to be enabled.

*		MIN - 1 and MAX - 17

*

 free SKBs */

 Complete all transmits */

 Complete all receives*/

/*

 * vxge_callback_link_up

 *

 * This function is called during interrupt context to notify link up state

 * change.

/*

 * vxge_callback_link_down

 *

 * This function is called during interrupt context to notify link down state

 * change.

/*

 * vxge_rx_alloc

 *

 * Allocate SKB.

 try to allocate skb first. this one may fail */

/*

 * vxge_rx_map

/*

 * vxge_rx_initial_replenish

 * Allocation of RxD as an initial replenish procedure.

/*

 * vxge_rx_1b_compl

 *

 * If the interrupt is because of a received frame or if the receive ring

 * contains fresh as yet un-processed frames, this function is called.

 check skb validity */

				/* If the t_code is not supported and if the

				 * t_code is other than 0x5 (unparseable packet

				 * such as unknown UPV6 header), Drop it !!!

 will netif_rx small SKB instead */

 Offload Rx side CSUM */

		/* rth_hash_type and rth_it_hit are non-zero regardless of

		 * whether rss is enabled.  Only the rth_value is zero/non-zero

		 * if rss is disabled/enabled, so key off of that.

/*

 * vxge_xmit_compl

 *

 * If an interrupt was raised to indicate DMA complete of the Tx packet,

 * this function is called. It identifies the last TxD whose buffer was

 * freed and frees all skbs whose data have already DMA'ed into the NICs

 * internal memory.

 check skb validity */

  for unfragmented skb */

 Updating the statistics block */

 select a vpath to transmit the packet */

 Copy the new mac address to the list */

 Add a mac address to DA table */

 Is this mac address already in the list? */

 Any vpath has room to add mac address to its da table? */

 Add this mac address to this vpath */

 Is the first vpath already selected as catch-basin ? */

 Add this mac address to this vpath */

 Select first vpath as catch-basin */

/**

 * vxge_xmit

 * @skb : the socket buffer containing the Tx data.

 * @dev : device pointer.

 *

 * This function is the Tx entry point of the driver. Neterion NIC supports

 * certain protocol assist features on Tx side, namely  CSO, S/G, LSO.

 A buffer with no data will be dropped */

	/* Last TXD?  Stop tx queue to avoid dropping packets.  TX

	 * completion will resume the queue.

 ignore 0 length fragment */

/*

 * vxge_rx_term

 *

 * Function will be called by hw function to abort all outstanding receive

 * descriptors.

/*

 * vxge_tx_term

 *

 * Function will be called to abort all outstanding tx descriptors

 check skb validity */

  for unfragmented skb */

 Copy the mac address to delete from the list */

 delete a mac address from DA table */

/**

 * vxge_set_multicast

 * @dev: pointer to the device structure

 *

 * Entry point for multicast address enable/disable

 * This function is a driver entry point which gets called by the kernel

 * whenever multicast addresses must be enabled/disabled. This also gets

 * called to set/reset promiscuous mode. Depending on the deivce flag, we

 * determine, if multicast address must be enabled or if promiscuous mode

 * is to be disabled etc.

 Update individual M_CAST address list */

 Delete previous MC's */

 Copy the mac address to delete */

 Add new ones */

 Delete previous MC's */

 Copy the mac address to delete */

 Enable all multicast */

/**

 * vxge_set_mac_addr

 * @dev: pointer to the device structure

 * @p: socket info

 *

 * Update entry "0" (default MAC addr)

 Get the old address */

 Copy the new address */

	/* First delete the old mac address from all the vpaths

			/* This can happen when this interface is added/removed

			to the bonding interface. Delete this station address

			/* Add this new address to the linked list

 Delete the station address */

 Set this mac address to all the vpaths */

/*

 * vxge_vpath_intr_enable

 * @vdev: pointer to vdev

 * @vp_id: vpath for which to enable the interrupts

 *

 * Enables the interrupts for the vpath

 enable the alarm vector */

/*

 * vxge_vpath_intr_disable

 * @vdev: pointer to vdev

 * @vp_id: vpath for which to disable the interrupts

 *

 * Disables the interrupts for the vpath

 disable the alarm vector */

 list all mac addresses from DA table */

 Store all mac addresses from the list to the DA table */

 does this mac address already exist in da table? */

 Add this mac address to the DA table */

 Store all vlan ids from the list to the vid table */

/*

 * vxge_reset_vpath

 * @vdev: pointer to vdev

 * @vp_id: vpath to reset

 *

 * Resets the vpath

 check if device is down already */

 is device reset already scheduled */

 Enable all broadcast */

 Enable all multicast */

 Enable the interrupts */

 Enable the flow of traffic through the vpath */

 Vpath reset done */

 Start the vpath queue */

 Configure CI */

 Enable CI for RTI */

 Enable CI for TTI */

		/*

		 * For Inta (with or without napi), Set CI ON for only one

		 * vpath. (Have only one free running timer).

 check if device is down already */

 is reset already scheduled */

 wait for all the vpath reset to complete */

 if execution mode is set to debug, don't reset the adapter */

 SOP or device reset required */

 This event is not currently used */

 Reprogram the DA table with populated mac addresses */

 enable vpath interrupts */

 Indicate card up */

 Get the traffic to flow through the vpaths */

 configure CI */

 Indicate reset done */

/*

 * vxge_reset

 * @vdev: pointer to ll device

 *

 * driver may reset the chip on events of serr, eccerr, etc

/**

 * vxge_poll_msix - Receive handler when Receive Polling is used.

 * @napi: pointer to the napi structure.

 * @budget: Number of packets budgeted to be processed in this iteration.

 *

 * This function comes into picture only if Receive side is being handled

 * through polling (called NAPI in linux). It mostly does what the normal

 * Rx interrupt handler does in terms of descriptor and packet processing

 * but not in an interrupt context. Also it will process a specified number

 * of packets at most in one iteration. This value is passed down by the

 * kernel as the function argument 'budget'.

 Re enable the Rx interrupts for the vpath */

	/* We are copying and returning the local variable, in case if after

	 * clearing the msix interrupt above, if the interrupt fires right

 Re enable the Rx interrupts for the ring */

/**

 * vxge_netpoll - netpoll event handler entry point

 * @dev : pointer to the device structure.

 * Description:

 *      This function will be called by upper layer to check for events on the

 * interface in situations where interrupts are disabled. It is used for

 * specific in-kernel networking tasks, such as remote consoles and kernel

 * debugging over the network (example netdump in RedHat).

 RTH configuration */

 indirection table */

 CPU to vpath mapping  */

	/*

	 * Filling

	 * 	- itable with bucket numbers

	 * 	- mtable with bucket-to-vpath mapping

 set indirection table, bucket-to-vpath mapping */

 Fill RTH hash types */

	/*

	 * Because the itable_set() method uses the active_table field

	 * for the target virtual path the RTH config should be updated

	 * for all VPATHs. The h/w only uses the lowest numbered VPATH

	 * when steering frames.

 reset vpaths */

 close vpaths */

 open vpaths */

/**

 *  adaptive_coalesce_tx_interrupts - Changes the interrupt coalescing

 *  if the interrupts are not within a range

 *  @fifo: pointer to transmit fifo structure

 *  Description: The function changes boundary timer and restriction timer

 *  value depends on the traffic

 *  Return Value: None

/**

 *  adaptive_coalesce_rx_interrupts - Changes the interrupt coalescing

 *  if the interrupts are not within a range

 *  @ring: pointer to receive ring structure

 *  Description: The function increases of decreases the packet counts within

 *  the ranges of traffic utilization, if the interrupts due to this ring are

 *  not within a fixed range.

 *  Return Value: Nothing

/*

 *  vxge_isr_napi

 *  @irq: the irq of the device.

 *  @dev_id: a void pointer to the hldev structure of the Titan device

 *  @ptregs: pointer to the registers pushed on the stack.

 *

 *  This function is the ISR handler of the device when napi is enabled. It

 *  identifies the reason for the interrupt and calls the relevant service

 *  routines.

		/* Reduce the chance of losing alarm interrupts by masking

		 * the vector. A pending bit will be set if an alarm is

		 * generated and on unmask the interrupt will be fired.

 Tx/Rx MSIX Vectors count */

 Alarm MSIX Vectors count */

 Initialize the fifo vector */

 Initialize the ring vector */

 Initialize the alarm vector */

 Try with less no of vector by reducing no of vpaths count */

 0 - Tx, 1 - Rx  */

 allocate msix vectors */

			/* If fifo or ring are not enabled, the MSIX vector for

			 * it should be set to 0.

 We requested for this msix interrupt */

 Point to next vpath handler */

 For Alarm interrupts */

 Truncated to machine word size number of frames */

 Did this vpath received any packets */

 Did it received any packets last time */

 schedule vpath reset */

 disable interrupts for this vpath */

 stop the queue for this vpath */

 Check every 1 milli second */

	/* Enabling RTH requires some of the logic in vxge_device_register and a

	 * vpath reset.  Due to these restrictions, only allow modification

	 * while the interface is down.

 !netif_running() ensured by vxge_fix_features() */

/**

 * vxge_open

 * @dev: pointer to the device structure.

 *

 * This function is the open entry point of the driver. It mainly calls a

 * function to allocate Rx buffers and inserts them into the buffer

 * descriptors and then enables the Rx part of the NIC.

 * Return value: '0' on success and an appropriate (-)ve integer as

 * defined in errno.h file on failure.

	/* make sure you have link off by default every time Nic is

 Open VPATHs */

 configure RTH */

 set initial mtu before enabling the device */

	/* Restore the DA, VID table and also multicast and promiscuous mode

	 * states

	/* Enable vpath to sniff all unicast/multicast traffic that not

	 * addressed to them. We allow promiscuous mode for PF only

 Enabling Bcast and mcast for all vpath */

 There is no need to check for RxD leak and RxD lookup on Titan1A */

 configure CI */

 Disable napi */

 Loop through the mac address list and delete all the entries */

	/* If vxge_handle_crit_err task is executing,

 Put the vpath back in normal mode */

 Remove the function 0 from promiscuous mode */

 Disable napi */

 Note that at this point xmit() is stopped by upper layer */

/**

 * vxge_close

 * @dev: device pointer.

 *

 * This is the stop entry point of the driver. It needs to undo exactly

 * whatever was done by the open entry point, thus it's usually referred to

 * as the close function.Among other things this function mainly stops the

 * Rx side of the NIC and frees all the Rx buffers in the Rx rings.

 * Return value: '0' on success and an appropriate (-)ve integer as

 * defined in errno.h file on failure.

/**

 * vxge_change_mtu

 * @dev: net device pointer.

 * @new_mtu :the new MTU size for the device.

 *

 * A driver entry point to change MTU size for the device. Before changing

 * the MTU the device must be stopped.

 check if device is down already */

 just store new value, will use later on open() */

/**

 * vxge_get_stats64

 * @dev: pointer to the device structure

 * @net_stats: pointer to struct rtnl_link_stats64

 *

 net_stats already zeroed by caller */

	/* Timestamp is passed to the driver via the FCS, therefore we

	 * must disable the FCS stripping by the adapter.  Since this is

	 * required for the driver to load (due to a hardware bug),

	 * there is no need to do anything special here.

 reserved for future extensions */

 Transmit HW Timestamp not supported */

/**

 * vxge_ioctl

 * @dev: Device pointer.

 * @rq: An IOCTL specific structure, that can contain a pointer to

 *       a proprietary structure used to pass information to the driver.

 * @cmd: This is used to distinguish between the different commands that

 *       can be passed to the IOCTL functions.

 *

 * Entry point for the Ioctl.

/**

 * vxge_tx_watchdog

 * @dev: pointer to net device structure

 * @txqueue: index of the hanging queue

 *

 * Watchdog for transmit side.

 * This function is triggered if the Tx Queue is stopped

 * for a pre-defined amount of time when the Interface is still up.

/**

 * vxge_vlan_rx_add_vid

 * @dev: net device pointer.

 * @proto: vlan protocol

 * @vid: vid

 *

 * Add the vlan id to the devices vlan id table

 Add these vlan to the vid table */

/**

 * vxge_vlan_rx_kill_vid

 * @dev: net device pointer.

 * @proto: vlan protocol

 * @vid: vid

 *

 * Remove the vlan id from the device's vlan id table

 Delete this vlan from the vid table */

 Allocate memory for vpath */

 MTU range: 68 - 9600 */

  Set the factory defined MAC address initially */

	/* Make Link state as off at this point, when the Link change

	 * interrupt comes the state will be automatically changed to

	 * the right state.

 Resetting the Device stats */

/*

 * vxge_device_unregister

 *

 * This function will unregister and free network device

 in 2.6 will call stop() if device is up */

 we are safe to free it now */

/*

 * vxge_callback_crit_err

 *

 * This function is called by the alarm handler in interrupt context.

 * Driver must analyze it based on the event type.

	/* Note: This event type should be used for device wide

	 * indications only - Serious errors, Slot freeze and critical errors

 check if this vpath is already set for reset */

 disable interrupts for this vpath */

 stop the queue for this vpath */

 1. If user enters 0 for some fifo, give equal priority to all */

 2. If sum exceeds 100, give equal priority to all */

 Is all the bandwidth consumed? */

 Split rest of bw equally among next VPs*/

 min of 2% */

/*

 * Vpath configuration

 No more CPU. Return vpath number as zero.*/

 configure bandwidth */

 Configure Tx fifo's */

 Configure tti properties */

		/* For msi-x with napi (each vector has a handler of its own) -

		 * Set CI to OFF for all vpaths

 Configure Rx rings */

 Configure rti properties */

 initialize device configuratrions */

 Used for CQRQ/SRQ. */

 Configure whether MSI-X or IRQL. */

 Timer period between device poll */

 Configure mac based steering. */

 Configure Vpaths */

/**

 * vxge_pm_suspend - vxge power management suspend entry point

 * @dev_d: device pointer

 *

/**

 * vxge_pm_resume - vxge power management resume entry point

 * @dev_d: device pointer

 *

/**

 * vxge_io_error_detected - called when PCI error is detected

 * @pdev: Pointer to PCI device

 * @state: The current pci connection state

 *

 * This function is called after a PCI bus error affecting

 * this device has been detected.

 Bring down the card, while avoiding PCI I/O */

/**

 * vxge_io_slot_reset - called after the pci bus has been reset.

 * @pdev: Pointer to PCI device

 *

 * Restart the card from scratch, as if from a cold-boot.

 * At this point, the card has exprienced a hard reset,

 * followed by fixups by BIOS, and has its config space

 * set up identically to what it was at cold boot.

/**

 * vxge_io_resume - called when traffic can start flowing again.

 * @pdev: Pointer to PCI device

 *

 * This callback is called when the error recovery driver tells

 * us that its OK to resume normal operation.

 TODO */

 Load the new firmware onto the adapter */

 Read the version of the new firmware */

	/* It's possible the version in /lib/firmware is not the latest version.

	 * If so, we could get into a loop of trying to upgrade to the latest

	 * and flashing the older version.

 Flash the adapter with the new firmware */

	/* Ignore the build number when determining if the current firmware is

	 * "too new" to load the driver

	/* Firmware 1.4.4 and older cannot be upgraded, and is too ancient to

	 * work with this driver.

 If file not specified, determine gPXE or not */

	/* -EINVAL and -ENOENT are not fatal errors for flashing firmware on

	 * probe, so ignore them

/**

 * vxge_probe

 * @pdev : structure containing the PCI related information of the device.

 * @pre: List of PCI devices supported by the driver listed in vxge_id_table.

 * Description:

 * This function is called when a new PCI device gets detected and initializes

 * it.

 * Return value:

 * returns 0 on success and negative on failure.

 *

	/* In SRIOV-17 mode, functions of the same adapter

	 * can be deployed on different buses

	/* Now making the CPU based no of vpath calculation

	 * applicable for individual functions as well.

 get the default configuration parameters */

 initialize configuration parameters */

 Check how many vpaths are available */

 Enable SRIOV mode, if firmware has SRIOV support and if it is a PF */

 No need to fail out, as an error here is non-fatal */

	/*

	 * Configure vpaths and get driver configured number of vpaths

	 * which is less than or equal to the maximum vpaths per function.

 Setting driver callbacks */

 This is a non-fatal error, continue */

 if FCS stripping is not disabled in MAC fail driver load */

	/* Always enable HWTS.  This will always cause the FCS to be invalid,

	 * due to the fact that HWTS is using the FCS as the location of the

	 * timestamp.  The HW FCS checking will still correctly determine if

	 * there is a valid checksum, and the FCS is being removed by the driver

	 * anyway.  So no functionality is being lost.  Since it is always

	 * enabled, we now simply use the ioctl call to set whether or not the

	 * driver should be paying attention to the HWTS.

 set private device info */

 set private HW device info */

 Virtual Path count */

 Initialize the mac address list header */

 map the hashing selector table to the configured vpaths */

 Store the fw version for ethttool option */

 Copy the station mac address to the list */

	/*

	 * INTA is shared in multi-function mode. This is unlike the INTA

	 * implementation in MR mode, where each VH has its own INTA message.

	 * - INTA is masked (disabled) as long as at least one function sets

	 * its TITAN_MASK_ALL_INT.ALARM bit.

	 * - INTA is unmasked (enabled) when all enabled functions have cleared

	 * their own TITAN_MASK_ALL_INT.ALARM bit.

	 * The TITAN_MASK_ALL_INT ALARM & TRAFFIC bits are cleared on power up.

	 * Though this driver leaves the top level interrupts unmasked while

	 * leaving the required module interrupt bits masked on exit, there

	 * could be a rougue driver around that does not follow this procedure

	 * resulting in a failure to generate interrupts. The following code is

	 * present to prevent such a failure.

/**

 * vxge_remove - Free the PCI device

 * @pdev: structure containing the PCI related information of the device.

 * Description: This function is called by the Pci subsystem to release a

 * PCI device and free up all resource held up by the device.

 Do not call pci_disable_sriov here, as it will break child devices */

 SPDX-License-Identifier: GPL-2.0

/*

 * jazzsonic.c

 *

 * (C) 2005 Finn Thain

 *

 * Converted to DMA API, and (from the mac68k project) introduced

 * dhd's support for 16-bit cards.

 *

 * (C) 1996,1998 by Thomas Bogendoerfer (tsbogend@alpha.franken.de)

 *

 * This driver is based on work from Andreas Busse, but most of

 * the code is rewritten.

 *

 * (C) 1995 by Andreas Busse (andy@waldorf-gmbh.de)

 *

 * A driver for the onboard Sonic ethernet controller on Mips Jazz

 * systems (Acer Pica-61, Mips Magnum 4000, Olivetti M700 and

 * perhaps others, too)

/*

 * Macros to access SONIC registers

/*

 * We cannot use station (ethernet) address prefixes to detect the

 * sonic controller since these are board manufacturer depended.

 * So we check for known Silicon Revision IDs instead.

 Mips Magnum 4000 */

 end of list */

	/*

	 * get the Silicon Revision ID. If this is one of the known

	 * one assume that we found a SONIC ethernet controller at

	 * the expected location.

	/*

	 * Put the sonic into software reset, then

	 * retrieve and print the ethernet address.

	/*

	 * clear tally counter

/*

 * Probe for a SONIC ethernet controller on a Mips Jazz board.

 * Actually probing is superfluous but we're paranoid.

 natsemi.c: A Linux PCI Ethernet driver for the NatSemi DP8381x series. */

/*

	Written/copyright 1999-2001 by Donald Becker.

	Portions copyright (c) 2001,2002 Sun Microsystems (thockin@sun.com)

	Portions copyright 2001,2002 Manfred Spraul (manfred@colorfullife.com)

	Portions copyright 2004 Harald Welte <laforge@gnumonks.org>



	This software may be used and distributed according to the terms of

	the GNU General Public License (GPL), incorporated herein by reference.

	Drivers based on or derived from this code fall under the GPL and must

	retain the authorship, copyright and license notice.  This file is not

	a complete program and may only be used when the entire operating

	system is licensed under the GPL.  License for under other terms may be

	available.  Contact the original author for details.



	The original author may be reached as becker@scyld.com, or at

	Scyld Computing Corporation

	410 Severn Ave., Suite 210

	Annapolis MD 21403



	Support information and updates available at

	http://www.scyld.com/network/netsemi.html

	[link no longer provides useful info -jgarzik]





	TODO:

	* big endian support with CFG:BEM instead of cpu_to_le32

 Processor type for cache alignment. */

 Updated to recommendations in pci-skeleton v2.03. */

/* The user-configurable values.

/* Maximum number of multicast addresses to filter (vs. rx-all-multicast).

/* Set the copy breakpoint for the copy-only-tiny-frames scheme.

/* Used to pass the media type, etc.

   Both 'options[]' and 'full_duplex[]' should exist for driver

   interoperability.

   The media type is usually passed in 'options[]'.

 More are supported, limit only on options */

 Operational parameters that are set at compile time. */

/* Keep the ring sizes a power of two for compile efficiency.

   The compiler will convert <unsigned>'%'<2^N> into a bit mask.

   Making the Tx ring too large decreases the effectiveness of channel

   bonding and packet priority.

 Limit ring entries actually used, min 4. */

 Operational parameters that usually are not changed. */

 Time in jiffies before concluding the transmitter is hung. */

 v1 added RFDR registers */

/* Buffer sizes:

 * The nic writes 32-bit values, even if the upper bytes of

 * a 32-bit value are beyond the end of the buffer.

 2*mac,type,vlan,crc */

 2 bytes should be sufficient */

 limit for normal packets */

 maximum supported by hardware */

 These identify the driver base version and may not be removed. */

/*

				Theory of Operation



I. Board Compatibility



This driver is designed for National Semiconductor DP83815 PCI Ethernet NIC.

It also works with other chips in in the DP83810 series.



II. Board-specific settings



This driver requires the PCI interrupt line to be valid.

It honors the EEPROM-set values.



III. Driver operation



IIIa. Ring buffers



This driver uses two statically allocated fixed-size descriptor lists

formed into rings by a branch from the final descriptor to the beginning of

the list.  The ring sizes are set at compile time by RX/TX_RING_SIZE.

The NatSemi design uses a 'next descriptor' pointer that the driver forms

into a list.



IIIb/c. Transmit/Receive Structure



This driver uses a zero-copy receive and transmit scheme.

The driver allocates full frame size skbuffs for the Rx ring buffers at

open() time and passes the skb->data field to the chip as receive data

buffers.  When an incoming frame is less than RX_COPYBREAK bytes long,

a fresh skbuff is allocated and the frame is copied to the new skbuff.

When the incoming frame is larger, the skbuff is passed directly up the

protocol stack.  Buffers consumed this way are replaced by newly allocated

skbuffs in a later phase of receives.



The RX_COPYBREAK value is chosen to trade-off the memory wasted by

using a full-sized skbuff for small frames vs. the copying costs of larger

frames.  New boards are typically used in generously configured machines

and the underfilled buffers have negligible impact compared to the benefit of

a single allocation size, so the default value of zero results in never

copying packets.  When copying is done, the cost is usually mitigated by using

a combined copy/checksum routine.  Copying also preloads the cache, which is

most useful with small frames.



A subtle aspect of the operation is that unaligned buffers are not permitted

by the hardware.  Thus the IP header at offset 14 in an ethernet frame isn't

longword aligned for further processing.  On copies frames are put into the

skbuff at an offset of "+2", 16-byte aligning the IP header.



IIId. Synchronization



Most operations are synchronized on the np->lock irq spinlock, except the

receive and transmit paths which are synchronised using a combination of

hardware descriptor ownership, disabling interrupts and NAPI poll scheduling.



IVb. References



http://www.scyld.com/expert/100mbps.html

http://www.scyld.com/expert/NWay.html

Datasheet is available from:

http://www.national.com/pf/DP/DP83815.html



IVc. Errata



None characterised.

/*

 * Support for fibre connections on Am79C874:

 * This phy needs a special setup when connected to a fibre cable.

 * http://www.amd.com/files/connectivitysolutions/networking/archivednetworking/22235.pdf

 mode control register */

 100BASE-FX (fiber) */

 enable scrambler (tp) */

 array of board data directly indexed by pci_tbl[x].driver_data */

 terminate list */

/* Offsets to the device registers.

   Unlike software-only systems, device drivers interact with complex hardware.

   It's not useful to define symbolic names for every register bit in the

   device.

 DP83816 only */

	/* These are from the spec, around page 78... on a separate table.

 the values for the 'magic' registers above (PGSEL=1) */

 enable preferred adaptation circuitry */

 set voltage thresholds for Signal Detect */

 coefficient lock bit in DSPCFG */

 see coefficient (in TSTDAT) bit in DSPCFG */

 magic number for bad coefficients */

 misc PCI space registers */

 Bits in the interrupt status/mask registers. */

/*

 * Default Interrupts:

 * Rx OK, Rx Packet Error, Rx Overrun,

 * Tx OK, Tx Packet Error, Tx Underrun,

 * MIB Service, Phy Interrupt, High Bits,

 * Rx Status FIFO overrun,

 * Received Target Abort, Received Master Abort,

 * Signalled System Error, Received Parity Error

/*

 * Tx Configuration:

 * - 256 byte DMA burst length

 * - fill threshold 512 bytes (i.e. restart DMA when 512 bytes are free)

 * - 64 bytes initial drain threshold (i.e. begin actual transmission

 *   when 64 byte are in the fifo)

 * - on tx underruns, increase drain threshold by 64.

 * - at most use a drain threshold of 1472 bytes: The sum of the fill

 *   threshold and the drain threshold must be less than 2016 bytes.

 *

 values we might find in the silicon revision register */

 The Rx and Tx buffer descriptors. */

/* Note that using only 32 bit fields simplifies conversion to big-endian

 Bits in network_desc.status */

 Descriptor rings first for alignment */

 The addresses of receive-in-place skbuffs */

 address of a sent-in-place packet/buffer, for later free() */

 Media monitoring timer */

 Frequently used values: keep some adjacent for cache effect */

 Producer/consumer ring indices */

 Based on MTU+slack. */

 Interrupt status */

 Do not touch the nic registers */

 Don't pay attention to the reported link state. */

 external phy that is used: only valid if dev->if_port != PORT_TP */

 Rx filter */

 FIFO and PCI burst thresholds */

 original contents of ClkRun register */

 silicon revision */

 expected DSPCFG value */

 parms saved in ethtool format */

 The forced speed, 10Mb, 100Mb, gigabit */

 Duplex, half or full */

 Autonegotiation enabled */

 MII transceiver section */

 EEPROM data */

 Find out the new setting */

	/*

	 * The internal phy is visible on the external mii bus. Therefore we must

	 * move it away before we can send commands to an external phy.

	 * There are two addresses we must avoid:

	 * - the address on the external phy that is used for transmission.

	 * - the address that we want to access. User space can access phys

	 *   on the mii bus with SIOCGMIIREG/SIOCSMIIREG, independent from the

	 *   phy that is used for transmission.

 get the initial settings from hardware */

 PCI base address register */

 when built into the kernel, we only print version if device is found */

	/* natsemi has a non-standard PM control register

	 * in PCI config space.  Some boards apparently need

	 * to be brought to D0 in this manner.

 D0 state, disable PME assertion */

 Work around the dropped serial bit. */

	/* Initial port:

	 * - If configured to ignore the PHY set up for external.

	 * - If the nic was configured to use an external phy and if find_mii

	 *   finds a phy: use external port, first phy that replies.

	 * - Otherwise: internal port.

	 * Note that the phy address for the internal phy doesn't matter:

	 * The address would be used to access a phy over the mii bus, but

	 * the internal phy is accessed through mapped registers.

 Reset the chip to erase previous misconfiguration. */

		/* If we're ignoring the PHY it doesn't matter if we can't

 The lower four bits are the media type. */

 MTU range: 64 - 2024 */

 save the silicon revision for later querying */

/* Read the EEPROM and MII Management Data I/O (MDIO) interfaces.

/* Delay between EEPROM clock transitions.

   No extra delay is needed with 33Mhz PCI, but future 66Mhz access may need

   a delay.  Note that pre-2.0.34 kernels had a cache-alignment bug that

   made udelay() unreliable.

   The old method of using an ISA access as a delay, __SLOW_DOWN_IO__, is

   deprecated.

 The EEPROM commands include the alway-set leading bit. */

 Shift the read command bits out. */

 Terminate the EEPROM access. */

/* MII transceiver control section.

 * The 83815 series has an internal transceiver, and we present the

 * internal management registers as if they were MII connected.

 * External Phy registers are referenced through the MII interface.

/* clock transitions >= 20ns (25MHz)

 * One readl should be good to PCI @ 100MHz

 Ensure sync */

 ST(2), OP(2), ADDR(5), REG#(5), TA(2), Data(16) total 32 bits */

 ST,OP = 0110'b for read operation */

 Turnaround */

 Read data */

 End cycle */

 Ensure sync */

 ST(2), OP(2), ADDR(5), REG#(5), TA(2), Data(16) total 32 bits */

 ST,OP,AAAAA,RRRRR,TA = 0101xxxxxxxxxx10'b = 0x5002 for write */

 End cycle */

	/* The 83815 series has two ports:

	 * - an internal transceiver

	 * - an external mii bus

 The 83815 series has an internal transceiver; handle separately */

 restore stuff lost when power was out */

 renegotiate if something changed */

 turn on autonegotiation and force negotiation */

 turn off auto negotiation, set speed and duplexity */

		/*

		 * Note: there is no good way to inform the link partner

		 * that our capabilities changed. The user has to unplug

		 * and replug the network cable after some changes, e.g.

		 * after switching from 10HD, autoneg off to 100 HD,

		 * autoneg off.

 find out what phy this is */

 handle external phys here */

 phy specific configuration for fibre/tp operation */

	/* On page 78 of the spec, they recommend some settings for "optimum

	   performance" to be done in sequence.  These settings optimize some

	   of the 100Mbit autodetection circuitry.  They say we only want to

	   do this for rev C of the chip, but engineers at NSC (Bradley

	   Kennedy) recommends always setting them.  If you don't, you get

	   errors on some autonegotiations that make the device unusable.



	   It seems that the DSP needs a few usec to reinitialize after

	   the start of the phy. Just retry writing these values until they

	   stick.

	/*

	 * Enable PHY Specific event based interrupts.  Link state change

	 * and Auto-Negotiation Completion are among the affected.

	 * Read the intr status to clear it (needed for wake events).

 1) switch back to external phy */

 2) reset the external phy: */

	/* resetting the external PHY has been known to cause a hub supplying

	 * power over Ethernet to kill the power.  We don't want to kill

	 * power to this computer, so we avoid resetting the phy.

 3) reinit the phy fixup, it got lost during power down. */

 1) switch back to internal phy: */

 2) reset the internal phy: */

 3) reinit the phy fixup, it got lost during power down. */

/* Scan for a PHY on the external mii bus.

 * There are two tricky points:

 * - Do not scan while the internal phy is enabled. The internal phy will

 *   crash: e.g. reads from the DSPCFG register will return odd values and

 *   the nasty random phy reset code will reset the nic every few seconds.

 * - The internal phy must be moved around, an external phy could

 *   have the same address as the internal phy.

 Switch to external phy */

	/* Scan the possible phy addresses:

	 *

	 * PHY address 0 means that the phy is in isolate mode. Not yet

	 * supported due to lack of test hardware. User space should

	 * handle it through ethtool.

 found something! */

 And switch back to internal phy: */

 CFG bits [13:16] [18:23] */

 WCSR bits [0:4] [9:10] */

 RFCR bits [20] [22] [27:31] */

	/*

	 * Resetting the chip causes some registers to be lost.

	 * Natsemi suggests NOT reloading the EEPROM while live, so instead

	 * we save the state that would have been loaded from EEPROM

	 * on a normal power-up (see the spec EEPROM map).  This assumes

	 * whoever calls this will follow up with init_registers() eventually.

 CFG */

 WCSR */

 RFCR */

 PMATCH */

 SOPAS */

 now whack the chip */

 restore CFG */

 turn on external phy if it was selected */

 restore WCSR */

 read RFCR */

 restore PMATCH */

 restore RFCR */

 Reset the chip, just in case. */

 now set the MAC address according to dev->dev_addr */

 Set the timer to check for link beat. */

	/*

	 * 100 MBit links with short cables can trip an issue with the chip.

	 * The problem manifests as lots of CRC errors and/or flickering

	 * activity LED while idle.  This process is based on instructions

	 * from engineers at National.

		/*

		 * coefficient visibility should already be enabled via

		 * DSPCFG | 0x1000

		/*

		 * the value must be negative, and within certain values

		 * (these values all come from National)

 the bug has been triggered - fix the coefficient */

 lock the value */

 make sure the lock bit is clear */

 If we are ignoring the PHY then don't try reading it. */

	/* The link status field is latched: it remains low after a temporary

	 * link failure until it's read. We need the current link status,

	 * thus read twice.

 if duplex is set then bit 28 must be set, too */

 clear any interrupts that are pending, such as wake events */

	/* Initialize other registers.

	 * Configure the PCI bus bursts and FIFO thresholds.

	 * Configure for standard, in-spec Ethernet.

	 * Start with half-duplex. check_link will update

	 * to the correct settings.

	/* DRTH: 2: start tx if 64 bytes are in the fifo

	 * FLTH: 0x10: refill with next packet if 512 bytes are free

	 * MXDMA: 0: up to 256 byte bursts.

	 * 	MXDMA must be <= FLTH

	 * ECRETRY=1

	 * ATP=1

	/* DRTH 0x10: start copying to memory if 128 bytes are in the fifo

	 * MXDMA 0: up to 256 byte bursts

 if receive ring now has bigger buffers than normal, enable jumbo */

	/* Disable PME:

	 * The PME bit is initialized from the EEPROM contents.

	 * PCI cards probably have PME disabled, but motherboard

	 * implementations may have PME set to enable WakeOnLan.

	 * With PME set the chip will scan incoming packets but

 Enable interrupts by setting the interrupt mask. */

 Clear Stats */

/*

 * netdev_timer:

 * Purpose:

 * 1) check for link changes. Usually they are handled by the MII interrupt

 *    but it doesn't hurt to check twice.

 * 2) check for sudden death of the NIC:

 *    It seems that a reference set for this chip went out with incorrect info,

 *    and there exist boards that aren't quite right.  An unexpected voltage

 *    drop can cause the PHY to get itself in a weird state (basically reset).

 *    NOTE: this only seems to affect revC chips.  The user can disable

 *    this check via dspcfg_workaround sysfs option.

 * 3) check of death of the RX path due to OOM

		/* DO NOT read the IntrStatus register,

		 * a read clears any pending interrupts.

 check for a nasty random phy-reset - use dspcfg as a flag */

 hurry back */

 init_registers() calls check_link() for the above case */

 prevent tx timeout */

 Refill the Rx ring buffers. */

 Better luck next round. */

 Better luck next round. */

 Initialize the Rx and Tx rings, along with various 'dev' bits. */

 1) TX ring */

 2) RX ring */

	/* Please be careful before changing this loop - at least gcc-2.95.1

	 * miscompiles it otherwise.

 Initialize all Rx descriptors. */

 Free all the skbuffs in the Rx queue. */

 An invalid address. */

 RX Ring */

 Initialize all Rx descriptors. */

 drain TX ring */

	/* Note: Ordering is important here, set the field with the

 Calculate the next Tx descriptor entry. */

		/* StrongARM: Explicitly cache flush np->tx_ring and

 Wake the potentially-idle transmit channel. */

 Various Tx errors */

 Free the original skb. */

 The ring is no longer full, wake queue. */

/* The interrupt handler doesn't actually handle interrupts itself, it

	/* Reading IntrStatus automatically acknowledges so don't do

	 * that while interrupts are disabled, (for example, while a

 Disable interrupts and register for poll */

/* This is the NAPI poll routine.  As well as the standard RX handling

 * it also handles all other interrupts that the chip might raise.

		/* netdev_rx() may read IntrStatus again if the RX state

 Abnormal error summary/uncommon events handlers. */

	/* Reenable interrupts providing nothing is trying to shut

/* This routine is logically part of the interrupt handler, but separated

 If the driver owns the next entry it's a new packet. Send it up. */

 e.g. & DescOwn */

				/* The RX state machine has probably

				 * locked up beneath us.  Follow the

				 * reset procedure documented in

				/* We'll enable RX on exit from this

 There was an error. */

			/* if this is the tail of a double buffer

			 * packet, we've already counted the error

			 * on the first part.  Ignore the second half.

 Omit CRC size. */

			/* Check if the packet is long enough to accept

 16 byte align the IP header */

 Restart Rx engine if stopped. */

 read MII int status to clear the flag */

 Hmmmmm, it's not clear how to recover from PCI faults. */

 The chip only need report frame silently dropped. */

 The chip only need report frame silently dropped. */

 Multicast hash filter */

 Set promiscuous. */

 synchronized against open : rtnl_lock() held by caller */

 stop engines */

 drain rx queue */

 change buffers */

 restart engines */

 if autoneg is off, it's an error */

 LSTATUS is latched low until a read - so read twice */

 translate to bitmasks this chip understands */

 SOPASS works on revD and higher */

 translate from chip bitmasks */

 this can be on in revC, but it's broken */

 enable writing to these registers by disabling the RX filter */

 write the three words to (undocumented) RFCR vals 0xa, 0xc, 0xe */

 re-enable the RX filter */

 read the three words from (undocumented) RFCR vals 0xa, 0xc, 0xe */

	/*

	 * We intentionally report the phy address of the external

	 * phy, even if the internal phy is used. This is necessary

	 * to work around a deficiency of the ethtool interface:

	 * It's only possible to query the settings of the active

	 * port. Therefore

	 * # ethtool -s ethX port mii

	 * actually sends an ioctl to switch to port mii with the

	 * settings that are used for the current active port.

	 * If we would report a different phy address in this

	 * command, then

	 * # ethtool -s ethX port tp;ethtool -s ethX port mii

	 * would unintentionally change the phy address.

	 *

	 * Fortunately the phy address doesn't matter with the

	 * internal phy...

 set information based on active port type */

 if autonegotiation is on, try to return the active speed/duplex */

 ignore maxtxpkt, maxrxpkt for now */

	/*

	 * If we're ignoring the PHY then autoneg and the internal

	 * transceiver are really not going to work so don't let the

	 * user select them.

	/*

	 * maxtxpkt, maxrxpkt: ignored for now.

	 *

	 * transceiver:

	 * PORT_TP is always XCVR_INTERNAL, PORT_MII and PORT_FIBRE are always

	 * XCVR_EXTERNAL. The implementation thus ignores ecmd->transceiver and

	 * selects based on ecmd->port.

	 *

	 * Actually PORT_FIBRE is nearly identical to PORT_MII: it's for fibre

	 * phys that are connected to the mii bus. It's used to apply fibre

	 * specific updates.

 WHEW! now lets bang some bits */

 save the parms */

 advertise only what has been requested */

 user overriding the initial full duplex parm? */

 get the right phy enabled */

 set parms and see how this affected our link status */

 read non-mii page 0 of registers */

 read current mii registers */

 read only the 'magic' registers from page 1 */

 read RFCR indexed registers */

 the interrupt status is clear-on-read - see if we missed any */

 eeprom_read reads 16 bits, and indexes by 16 bits */

		/* The EEPROM itself stores data bit-swapped, but eeprom_read

		 * reads it back "sanely". So we swap it back here in order to

 Get address of MII PHY in use. */

 Read MII PHY register. */

		/* The phy_id is not enough to uniquely identify

		 * the intended target. Therefore the command is sent to

		 * the given mii on the current port.

 Write MII PHY register. */

	/* For WOL we must restart the rx process in silent mode.

	 * Write NULL to the RxRingPtr. Only possible if

	 * rx process is stopped

 read WoL status to clear */

 PME on, clear status */

 and restart the rx process */

		/* enable the WOL interrupt.

		 * Could be used to send a netlink message.

	/*

	 * FIXME: what if someone tries to close a device

	 * that is suspended?

	 * Should we reenable the nic to switch to

	 * the final WOL settings?

	/* Interrupt disabled, interrupt handler released,

	 * queue stopped, timer deleted, rtnl_lock held

	 * All async codepaths that access the driver are disabled.

 Freeze Stats */

 Stop the chip's Tx and Rx processes. */

 clear the carrier last - an interrupt could reenable it otherwise */

			/* restart the NIC in WOL mode.

			 * The nic must be stopped for this.

 Restore PME enable bit unmolested */

/*

 * The ns83815 chip doesn't have explicit RxStop bits.

 * Kicking the Rx or Tx process for a new packet reenables the Rx process

 * of the nic, thus this function must be very careful:

 *

 * suspend/resume synchronization:

 * entry points:

 *   netdev_open, netdev_close, netdev_ioctl, set_rx_mode, intr_handler,

 *   start_tx, ns_tx_timeout

 *

 * No function accesses the hardware without checking np->hands_off.

 *	the check occurs under spin_lock_irq(&np->lock);

 * exceptions:

 *	* netdev_ioctl: noncritical access.

 *	* netdev_open: cannot happen due to the device_detach

 *	* netdev_close: doesn't hurt.

 *	* netdev_timer: timer stopped by natsemi_suspend.

 *	* intr_handler: doesn't acquire the spinlock. suspend calls

 *		disable_irq() to enforce synchronization.

 *      * natsemi_poll: checks before reenabling interrupts.  suspend

 *              sets hands_off, disables interrupts and then waits with

 *              napi_disable().

 *

 * Interrupts must be disabled, otherwise hands_off can cause irq storms.

 Update the error counts. */

 pci_power_off(pdev, -1); */

 Restore PME enable bit */

				/* restart the NIC in WOL mode.

				 * The nic must be stopped for this.

				 * FIXME: use the WOL interrupt

 Restore PME enable bit unmolested */

	pci_power_on(pdev); */

 when a module, this is printed whether or not devices are found in probe */

 SPDX-License-Identifier: GPL-2.0

/*

 * xtsonic.c

 *

 * (C) 2001 - 2007 Tensilica Inc.

 *	Kevin Chea <kchea@yahoo.com>

 *	Marc Gauthier <marc@linux-xtensa.org>

 *	Chris Zankel <chris@zankel.net>

 *

 * (C) 1996,1998 by Thomas Bogendoerfer (tsbogend@alpha.franken.de)

 *

 * This driver is based on work from Andreas Busse, but most of

 * the code is rewritten.

 *

 * (C) 1995 by Andreas Busse (andy@waldorf-gmbh.de)

 *

 * A driver for the onboard Sonic ethernet controller on the XT2000.

/*

 * According to the documentation for the Sonic ethernet controller,

 * EOBC should be 760 words (1520 bytes) for 32-bit applications, and,

 * as such, 2 words less than the buffer size. The value for RBSIZE

 * defined in sonic.h, however is only 1520.

 *

 * (Note that in 16-bit configurations, EOBC is 759 words (1518 bytes) and

 * RBSIZE 1520 bytes)

/*

 * The chip provides 256 byte register space.

/*

 * Macros to access SONIC registers

/*

 * We cannot use station (ethernet) address prefixes to detect the

 * sonic controller since these are board manufacturer depended.

 * So we check for known Silicon Revision IDs instead.

 SONIC 83934 */

 end of list */

	/*

	 * get the Silicon Revision ID. If this is one of the known

	 * one assume that we found a SONIC ethernet controller at

	 * the expected location.

	/*

	 * Put the sonic into software reset, then retrieve ethernet address.

	 * Note: we are assuming that the boot-loader has initialized the cam.

	/*

	 * clear tally counter

/*

 * Probe for a SONIC ethernet controller on an XT2000 board.

 * Actually probing is superfluous but we're paranoid.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * sonic.c

 *

 * (C) 2005 Finn Thain

 *

 * Converted to DMA API, added zero-copy buffer handling, and

 * (from the mac68k project) introduced dhd's support for 16-bit cards.

 *

 * (C) 1996,1998 by Thomas Bogendoerfer (tsbogend@alpha.franken.de)

 *

 * This driver is based on work from Andreas Busse, but most of

 * the code is rewritten.

 *

 * (C) 1995 by Andreas Busse (andy@waldorf-gmbh.de)

 *

 *    Core code included by system sonic drivers

 *

 * And... partially rewritten again by David Huggins-Daines in order

 * to cope with screwed up Macintosh NICs that may or may not use

 * 16-bit DMA.

 *

 * (C) 1999 David Huggins-Daines <dhd@debian.org>

 *

/*

 * Sources: Olivetti M700-10 Risc Personal Computer hardware handbook,

 * National Semiconductors data sheet for the DP83932B Sonic Ethernet

 * controller, and the files "8390.c" and "skeleton.c" in this directory.

 *

 * Additional sources: Nat Semi data sheet for the DP83932C and Nat Semi

 * Application Note AN-746, the files "lance.c" and "ibmlana.c". See also

 * the NetBSD file "sys/arch/mac68k/dev/if_sn.c".

	/* Allocate a chunk of memory for the descriptors. Note that this

	 * must not cross a 64K boundary. It is smaller than one page which

	 * means that page alignment is a sufficient condition.

/*

 * Open/initialize the SONIC controller.

 *

 * This routine should set everything up anew at each open, even

 *  registers that "should" only need to be set once at boot, so that

 *  there is non-reboot way to recover if something goes wrong.

 free any that were allocated successfully */

 align IP header unless DMA requires otherwise */

 free any that were mapped successfully */

	/*

	 * Initialize the SONIC

 Wait for the SONIC to become idle. */

/*

 * Close the SONIC device

	/*

	 * stop the SONIC, disable interrupts

 unmap and free skbs that haven't been transmitted */

 unmap and free the receive buffers */

	/*

	 * put the Sonic into software-reset mode and

	 * disable all interrupts before releasing DMA buffers

 We could resend the original skbs. Easier to re-initialise. */

 Try to restart the adaptor. */

 prevent tx timeout */

/*

 * transmit packet

 *

 * Appends new TD during transmission thus avoiding any TX interrupts

 * until we run out of TDs.

 * This routine interacts closely with the ISR in that it may,

 *   set tx_skb[i]

 *   reset the status flags of the new TD

 *   set and reset EOL flags

 *   stop the tx queue

 * The ISR interacts with this routine in various ways. It may,

 *   reset tx_skb[i]

 *   test the EOL and status flags of the TDs

 *   wake the tx queue

 * Concurrently with all of this, the SONIC is potentially writing to

 * the status flags of the TDs.

	/*

	 * Map the packet data into the logical DMA address space

 clear status */

 single fragment */

 length of packet */

 The ring is full, the ISR has yet to process the next TD. */

 after this packet, wait for ISR to free up some TDAs */

/*

 * The typical workload of the driver:

 * Handle the network interface interrupts.

	/* The lock has two purposes. Firstly, it synchronizes sonic_interrupt()

	 * with sonic_send_packet() so that the two functions can share state.

	 * Secondly, it makes sonic_interrupt() re-entrant, as that is required

	 * by macsonic which must use two IRQs with different priority levels.

 clear the interrupt(s) */

 got packet(s) */

			/* The state of a Transmit Descriptor may be inferred

			 * from { tx_skb[entry], td_status } as follows.

			 * { clear, clear } => the TD has never been used

			 * { set,   clear } => the TD was handed to SONIC

			 * { set,   set   } => the TD was handed back

			 * { clear, set   } => the TD is available for re-use

 We must free the original skb */

 and unmap DMA buffer */

 The ring is no longer full */

		/*

		 * check error conditions

 counter overruns; all counters are 16bit wide */

 transmit error */

 Aborted transmission. Try again. */

 bus retry */

 ... to help debug DMA problems causing endless interrupts. */

 Bounce the eth interface to turn on the interrupt again. */

 Return the array index corresponding to a given Receive Buffer pointer. */

 Allocate and map a new skb to be used as a receive buffer. */

 Place a new receive resource in the Receive Resource Area and update RWP. */

	/* The resources in the range [RRP, RWP) belong to the SONIC. This loop

	 * scans the other resources in the RRA, those in the range [RWP, RRP).

/*

 * We have a good packet(s), pass it/them up the network stack.

 If the RD has LPKT set, the chip has finished with the RB */

 Pass the used buffer up the stack */

 Failed to obtain a new buffer so re-use it */

			/* If RBE is already asserted when RWP advances then

			 * it's safe to clear RBE after processing this packet.

		/*

		 * give back the descriptor

 Advance the EOL flag to put descriptors back into service */

/*

 * Get the current statistics.

 * This may be called with the device open or closed.

 read the tally counter from the SONIC and reset them */

/*

 * Set or clear the multicast filter for this adaptor.

 accept broadcast packets */

 set promiscuous mode */

 always enable our own address */

 LCAM and TXP commands can't be used simultaneously */

/*

 * Initialize the SONIC ethernet controller.

	/*

	 * put the Sonic into software-reset mode and

	 * disable all interrupts

 While in reset mode, clear CAM Enable register */

	/*

	 * clear software reset flag, disable receiver, clear and

	 * enable interrupts, then completely initialize the SONIC

	/*

	 * initialize the receive resource area

 initialize all RRA registers */

 load the resource pointers */

	/*

	 * Initialize the receive descriptors so that they

	 * become a circular linked list, ie. let the last

	 * descriptor point to the first again.

 fix last descriptor */

	/*

	 * initialize transmit descriptors

 fix last descriptor */

	/*

	 * put our own address to CAM desc[0]

	/*

	 * initialize CAM registers

	/*

	 * load the CAM

	/*

	 * enable receiver, disable loopback

	 * and enable all interrupts

 SPDX-License-Identifier: GPL-2.0

/*

 * macsonic.c

 *

 * (C) 2005 Finn Thain

 *

 * Converted to DMA API, converted to unified driver model, made it work as

 * a module again, and from the mac68k project, introduced more 32-bit cards

 * and dhd's support for 16-bit cards.

 *

 * (C) 1998 Alan Cox

 *

 * Debugging Andreas Ehliar, Michael Schmitz

 *

 * Based on code

 * (C) 1996 by Thomas Bogendoerfer (tsbogend@bigbug.franken.de)

 *

 * This driver is based on work from Andreas Busse, but most of

 * the code is rewritten.

 *

 * (C) 1995 by Andreas Busse (andy@waldorf-gmbh.de)

 *

 * A driver for the Mac onboard Sonic ethernet chip.

 *

 * 98/12/21 MSch: judged from tests on Q800, it's basically working,

 *		  but eating up both receive and transmit resources

 *		  and duplicating packets. Needs more testing.

 *

 * 99/01/03 MSch: upgraded to version 0.92 of the core driver, fixed.

 *

 * 00/10/31 sammy@oh.verio.com: Updated driver for 2.4 kernels, fixed problems

 *          on centris.

/* These should basically be bus-size and endian independent (since

   the SONIC is at least smart enough that it uses the same endianness

 For onboard SONIC */

 For the built-in SONIC in the Duo Dock */

 For Apple-style NuBus SONIC */

 Daynalink LC SONIC */

 For Dayna-style NuBus SONIC (haven't seen one yet) */

/* This is what OpenBSD says.  However, this is definitely in NuBus

   ROM space so we should be able to get it by walking the NuBus

/*

 * For reversing the PROM address

	/* Under the A/UX interrupt scheme, the onboard SONIC interrupt gets

	 * moved from level 2 to level 3. Unfortunately we still get some

	 * level 2 interrupts so register the handler for both.

	/*

	 * clear tally counter

	/*

	 * On NuBus boards we can sometimes look in the ROM resources.

	 * No such luck for comm-slot/onboard.

	 * On the PowerBook 520, the PROM base address is a mystery.

		/*

		 * Most of the time, the address is bit-reversed. The NetBSD

		 * source has a rather long and detailed historical account of

		 * why this is so.

		/*

		 * If we still have what seems to be a bogus address, we'll

		 * look in the CAM. The top entry should be ours.

 This only works if MacOS has already initialized the card. */

 Still nonsense ... messed up someplace! */

	/* Bogus probing, on the models which may or may not have

	   Ethernet (BTW, the Ethernet *is* always at the same

	   address, and nothing else lives there, at least if Apple's

	/* Danger!  My arms are flailing wildly!  You *must* set lp->reg_offset

 The PowerBook's SONIC is 16 bit always. */

		/* Some of the comm-slot cards are 16 bit.  But some

		   of them are not.  The 32-bit cards use offset 2 and

		   have known revisions, we try reading the revision

		   register at offset 2, if we don't get a known revision

 83932 is 0x0004 or 0x0006, 83934 is 0x0100 or 0x0101 */

 All onboard cards are at offset 2 with 32 bit DMA. */

 This is sometimes useful to find out how MacOS configured the card */

 Software reset, then initialize control registers. */

	/* This *must* be written back to in order to restore the

	 * extended programmable output bits, as it may not have been

 Clear *and* disable interrupts to be on the safe side */

 Now look for the MAC address. */

 Shared init code */

 Some of the addresses are bit-reversed */

 There has to be a better way to do this... */

 huh? */

	/* Danger!  My arms are flailing wildly!  You *must* set lp->reg_offset

 This is sometimes useful to find out how MacOS configured the card */

 Software reset, then initialize control registers. */

	/* This *must* be written back to in order to restore the

	 * extended programmable output bits, since it may not have been

 Clear *and* disable interrupts to be on the safe side */

 Now look for the MAC address. */

 Shared init code */

	/* The platform driver will handle a PDS or Comm Slot card (even if

	 * it has a pseudoslot declaration ROM).

 SPDX-License-Identifier: GPL-2.0-or-later

/* ns83820.c by Benjamin LaHaise with contributions.

 *

 * Questions/comments/discussion to linux-ns83820@kvack.org.

 *

 * $Revision: 1.34.2.23 $

 *

 * Copyright 2001 Benjamin LaHaise.

 * Copyright 2001, 2002 Red Hat.

 *

 * Mmmm, chocolate vanilla mocha...

 *

 * ChangeLog

 * =========

 *	20010414	0.1 - created

 *	20010622	0.2 - basic rx and tx.

 *	20010711	0.3 - added duplex and link state detection support.

 *	20010713	0.4 - zero copy, no hangs.

 *			0.5 - 64 bit dma support (davem will hate me for this)

 *			    - disable jumbo frames to avoid tx hangs

 *			    - work around tx deadlocks on my 1.02 card via

 *			      fiddling with TXCFG

 *	20010810	0.6 - use pci dma api for ringbuffers, work on ia64

 *	20010816	0.7 - misc cleanups

 *	20010826	0.8 - fix critical zero copy bugs

 *			0.9 - internal experiment

 *	20010827	0.10 - fix ia64 unaligned access.

 *	20010906	0.11 - accept all packets with checksum errors as

 *			       otherwise fragments get lost

 *			     - fix >> 32 bugs

 *			0.12 - add statistics counters

 *			     - add allmulti/promisc support

 *	20011009	0.13 - hotplug support, other smaller pci api cleanups

 *	20011204	0.13a - optical transceiver support added

 *				by Michael Clark <michael@metaparadigm.com>

 *	20011205	0.13b - call register_netdev earlier in initialization

 *				suppress duplicate link status messages

 *	20011117 	0.14 - ethtool GDRVINFO, GLINK support from jgarzik

 *	20011204 	0.15	get ppc (big endian) working

 *	20011218	0.16	various cleanups

 *	20020310	0.17	speedups

 *	20020610	0.18 -	actually use the pci dma api for highmem

 *			     -	remove pci latency register fiddling

 *			0.19 -	better bist support

 *			     -	add ihr and reset_phy parameters

 *			     -	gmii bus probing

 *			     -	fix missed txok introduced during performance

 *				tuning

 *			0.20 -	fix stupid RFEN thinko.  i am such a smurf.

 *	20040828	0.21 -	add hardware vlan accleration

 *				by Neil Horman <nhorman@redhat.com>

 *	20050406	0.22 -	improved DAC ifdefs from Andi Kleen

 *			     -	removal of dead code from Adrian Bunk

 *			     -	fix half duplex collision behaviour

 * Driver Overview

 * ===============

 *

 * This driver was originally written for the National Semiconductor

 * 83820 chip, a 10/100/1000 Mbps 64 bit PCI ethernet NIC.  Hopefully

 * this code will turn out to be a) clean, b) correct, and c) fast.

 * With that in mind, I'm aiming to split the code up as much as

 * reasonably possible.  At present there are X major sections that

 * break down into a) packet receive, b) packet transmit, c) link

 * management, d) initialization and configuration.  Where possible,

 * these code paths are designed to run in parallel.

 *

 * This driver has been tested and found to work with the following

 * cards (in no particular order):

 *

 *	Cameo		SOHO-GA2000T	SOHO-GA2500T

 *	D-Link		DGE-500T

 *	PureData	PDP8023Z-TG

 *	SMC		SMC9452TX	SMC9462TX

 *	Netgear		GA621

 *

 * Special thanks to SMC for providing hardware to test this driver on.

 *

 * Reports of success or failure would be greatly appreciated.

#define dprintk		printk

 for iph */

 for IPPROTO_... */

 Global parameters.  See module_param near the bottom. */

 CFG_LNKSTS bit polarity */

 Dprintk is used for more interesting debug events */

 tunables */

 8192 */

 Must not exceed ~65000. */

 not tunable */

 rx/tx mac addr + type */

 register defines */

/* Ramit : Here's a tip, don't do a RXD immediately followed by an RXE

 * The Receive engine skips one descriptor and moves

/* Ramit : Dont' ever use AUTO_1000, it never works and is buggy.

 Should be cache line sized */

 protects everything below.  irqsave when using. */

 idx of free desc chain */

free = (tx_done_idx + NR_TX_DESC-2 - free_idx) % NR_TX_DESC

/* Packet Receiver

 *

 * The hardware supports linked lists of receive descriptors for

 * which ownership is transferred back and forth by means of an

 * ownership bit.  While the hardware does support the use of a

 * ring for receive descriptors, we only make use of a chain in

 * an attempt to reduce bus traffic under heavy load scenarios.

 * This will also make bugs a bit more obvious.  The current code

 * only makes use of a single rx chain; I hope to implement

 * priority based rx for version 1.0.  Goal: even under overload

 * conditions, still route realtime traffic with as low jitter as

 * possible.

 don't overrun last rx marker */

 update link of previous rx */

 extra 16 bytes for alignment */

 REFILL */

 we have an optical transceiver */

 both of us are full duplex */

 Light up full duplex LED */

 one or both of us are half duplex */

 Turn off full duplex LED */

 1000F */

 we have a copper transceiver */

 prevent the interrupt handler from stomping on us */

 Okay, let it rip */

dev->IMR_cache |= ISR_RXERR;

dev->IMR_cache |= ISR_RXOK;

 disable receive interrupts */

 synchronize with the interrupt handler and kill it */

 touch the pci bus... */

 assumes the transmitter is already disabled and reset */

if (nr_rx_empty(dev) >= NR_RX_DESC/4)*/ {

/* rx_irq

 *

		/* NH: As was mentioned below, this chip is kinda

		 * brain dead about vlan tag stripping.  Frames

		 * that are 64 bytes with a vlan header appended

		 * like arp frames, or pings, are flagged as Runts

		 * when the tag is stripped and hardware.  This

		 * also means that the OK bit in the descriptor

		 * is cleared when the frame comes in so we have

		 * to do a specific length check here to make sure

		 * the frame would have been ok, had we not stripped

		 * the tag.

/* Packet Transmit code

/* No spinlock needed on the transmit irq path as the interrupt handler is

 * serialized.

	/* Allow network stack to resume queueing packets after we've

	 * finished transmitting at least 1/4 of the packets in the queue.

/* transmit routine.  This code relies on the network layer serializing

 * its calls in, but will run happily in parallel with the interrupt

 * handler.  This code currently has provisions for fragmenting tx buffers

 * while trying to track down a bug in either the zero copy code or

 * the tx fifo (hence the MAX_FRAG_LEN).

 Check again: we may have raced with a tx done irq */

		/* fetch the vlan tag info out of the

		 * ancillary data if the vlan code

		 * is using hw vlan acceleration

 Check again: we may have raced with a tx done irq */

 the DP83820 will freeze counters, so we need to read all of them */

ndev->stats.rx_symbol_errors +=*/ readl(base + 0x70);

ndev->stats.rx_badopcode_errors += */ readl(base + 0x7c);

ndev->stats.rx_pause_count += */  readl(base + 0x80);

ndev->stats.tx_pause_count += */  readl(base + 0x84);

 somewhat overkill */

 Let ethtool retrieve info */

	/*

	 * Here's the list of available ethtool commands from other drivers:

	 *	cmd->advertising =

	 *	ethtool_cmd_speed_set(cmd, ...)

	 *	cmd->duplex =

	 *	cmd->port = 0;

	 *	cmd->phy_address =

	 *	cmd->transceiver = 0;

	 *	cmd->autoneg =

	 *	cmd->maxtxpkt = 0;

	 *	cmd->maxrxpkt = 0;

 read current configuration */

 we have optical interface */

 we have copper */

 Let ethool change settings*/

 read current configuration */

 we have optical */

 we have copper */

 Set duplex */

set full duplex*/

 force full duplex */

 Light up full duplex LED */

TODO: set half duplex */

we have copper*/

 TODO: Set duplex for copper cards */

 Set autonegotiation */

 restart auto negotiation */

 disable auto negotiation */

 end ethtool get/set support -df */

 this function is called in irq context from the ISR */

rx_irq(ndev);

writel(4, dev->base + IHR);

printk("overrun: rxsovr\n");

printk("overrun: rxorn\n");

		/* The may have been a race between a pci originated read

		 * and the descriptor update from the cpu.  Just in case,

		 * kick the transmitter if the hardware thinks it is on a

		 * different descriptor than we are.

	/* Defer tx ring processing until more than a minimum amount of

	 * work has accumulated

		/* Disable TxOk if there are no outstanding tx packets.

	/* The TxIdle interrupt can come in before the transmit has

	 * completed.  Normally we reap packets off of the combination

	 * of TxDesc and TxIdle and leave TxOk disabled (since it

	 * occurs on every packet), but when no further irqs of this

	 * nature are expected, we must enable TxOk.

 MIB interrupt: one of the statistics counters is about to overflow */

 PHY: Link up/down/negotiation state change */

 Still working on the interrupt mitigation strategy */

 FIXME: protect against interrupt handler? */

 FIXME: wait for phy to come up */

		/* Read from the perfect match memory: this is loaded by

		 * the chip from the EEPROM via the EELOAD self test.

 Ramit : RFCR Write Fix doc says RFEN must be 0 modify other bits */

 drive MDC low */

 enable output, set bit */

 set the output bit */

 Wait.  Max clock rate is 2.5MHz, this way we come in under 1MHz */

 drive MDC high causing the data bit to be latched */

 Wait again... */

 drive MDC low, disable output */

 Wait.  Max clock rate is 2.5MHz, this way we come in under 1MHz */

 drive MDC high causing the data bit to be latched */

 Wait again... */

 read some garbage so that we eventually sync up */

 start */

 opcode read */

 write out the phy address: 5 bits, msb first */

 write out the register address, 5 bits, msb first */

 turn around cycles */

 read in the register data, 16 bits msb first */

 read some garbage so that we eventually sync up */

 start */

 opcode read */

 write out the phy address: 5 bits, msb first */

 write out the register address, 5 bits, msb first */

 turn around cycles */

 read in the register data, 16 bits msb first */

 read firmware version: memory addr is 0x8402 and 0x8403 */

 See if we can set the dma mask early on; failure is fatal. */

	/*

	 * FIXME: we are holding rtnl_lock() over obscenely long area only

	 * because some of the setup code uses dev->name.  It's Wrong(tm) -

	 * we should be using driver-specific names for all that stuff.

	 * For now that will do, but we really need to come back and kill

	 * most of the dev_alloc_name() users later.

 Must reset the ram bist before running it */

 I love config registers */

dev->CFG_cache |= CFG_DATA64_EN;*/

	/* When compiled with 64 bit addressing, we must always enable

	 * the 64 bit descriptor format.

 Big endian mode does not seem to do what the docs suggest */

 setup optical transceiver if we have one */

 setup auto negotiation feature advertisement */

 start auto negotiation */

#if 0	/* Huh?  This sets the PCI latency register.  Should be done via

	 * the PCI layer.  FIXME.

	/* Note!  The DMA burst size interacts with packet

	 * transmission, such that the largest packet that

	 * can be transmitted is 8192 - FLTH - burst size.

	 * If only the transmit fifo was larger...

	/* Ramit : 1024 DMA is not a good idea, it ends up banging

 Flush the interrupt holdoff timer */

	/* Set Rx to full duplex, don't accept runt, errored, long or length

	 * range errored packets.  Use 512 byte DMA.

	/* Ramit : 1024 DMA is not a good idea, it ends up banging

	 * some DELL and COMPAQ SMP systems

| RXCFG_ALP

 Disable priority queueing */

	/* Enable IP checksum validation and detetion of VLAN headers.

	 * Note: do not set the reject options as at least the 0x102

	 * revision of the chip does not properly accept IP fragments

	 * at least for UDP.

	/* Ramit : Be sure to turn on RXCFG_ARP if VLAN's are enabled, since

	 * the MAC it calculates the packetsize AFTER stripping the VLAN

	 * header, and if a VLAN Tagged packet of 64 bytes is received (like

	 * a ping with a VLAN header) then the card, strips the 4 byte VLAN

	 * tag and then checks the packet size, so if RXCFG_ARP is not enabled,

	 * it discrards it!.  These guys......

	 * also turn on tag stripping if hardware acceleration is enabled

	/* Enable per-packet TCP/UDP/IP checksumming

	 * and per packet vlan tag insertion if

	 * vlan hardware acceleration is enabled

 Ramit : Enable async and sync pause frames */

 writel(0, dev->base + PCR); */

 Disable Wake On Lan */

 Yes, we support dumb IP checksum on transmit */

 We also support hardware vlan acceleration */

 paranoia */

 ok even if NULL */

 paranoia */

 paranoia */

 FIXME: implement */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Copyright (C) 2001,2002,2003,2004 Broadcom Corporation

 * Copyright (c) 2006, 2007  Maciej W. Rozycki

 *

 * This driver is designed for the Broadcom SiByte SOC built-in

 * Ethernet controllers. Written by Mitch Lichtenberg at Broadcom Corp.

 *

 * Updated to the driver model and the PHY abstraction layer

 * by Maciej W. Rozycki.

 Processor type for cache alignment. */

 Operational parameters that usually are not changed. */

 Time in jiffies before concluding the transmitter is hung. */

/* A few user-configurable values which may be modified when a driver

 1 normal messages, 0 quiet .. 7 verbose. */

/**********************************************************************

 *  Simple types

/**********************************************************************

 *  Macros

#define ENET_PACKET_SIZE	9216 */

/**********************************************************************

 *  DMA Descriptor structure

/**********************************************************************

 *  DMA Controller structure

	/*

	 * This stuff is used to identify the channel and the registers

	 * associated with it.

	struct sbmac_softc	*sbdma_eth;	/* back pointer to associated

 channel number */

 direction (1=transmit) */

	int			sbdma_maxdescr;	/* total # of descriptors

						/* # descriptors rx/tx

 # usec rx/tx interrupt */

 DMA config register 0 */

 DMA config register 1 */

 descriptor base address */

 descriptor count register */

	void __iomem		*sbdma_curdscr;	/* current descriptor

 pkt drop (rx only) */

	/*

	 * This stuff is for maintenance of the ring

 base of descriptor table */

 end of descriptor table */

						/* context table, one

 and also the phys addr */

 next dscr for sw to add */

	struct sbdmadscr	*sbdma_remptr;	/* next dscr for sw

/**********************************************************************

 *  Ethernet softc structure

	/*

	 * Linux-specific things

 pointer to linux device */

 the associated PHY device */

 the MII bus */

 spin lock */

 current device flags */

	/*

	 * Controller-specific things

 MAC's base address */

 current state */

 MAC Enable Register */

 MAC Config Register */

 FIFO Config Register */

 Frame Config Register */

 Receive Filter Register */

 Interrupt Status Register */

 Interrupt Mask Register */

 MDIO Register */

 current speed */

 current duplex */

 cur. flow control setting */

 current pause setting */

 current link state */

 only channel 0 for now */

/**********************************************************************

 *  Externs

/**********************************************************************

 *  Prototypes

/**********************************************************************

 *  Globals

/**********************************************************************

 *  MDIO constants

 for clarity */

/**********************************************************************

 *  SBMAC_MII_SYNC(sbm_mdio)

 *

 *  Synchronize with the MII - send a pattern of bits to the MII

 *  that will guarantee that it is ready to accept a command.

 *

 *  Input parameters:

 *  	   sbm_mdio - address of the MAC's MDIO register

 *

 *  Return value:

 *  	   nothing

/**********************************************************************

 *  SBMAC_MII_SENDDATA(sbm_mdio, data, bitcnt)

 *

 *  Send some bits to the MII.  The bits to be sent are right-

 *  justified in the 'data' parameter.

 *

 *  Input parameters:

 *  	   sbm_mdio - address of the MAC's MDIO register

 *  	   data     - data to send

 *  	   bitcnt   - number of bits to send

/**********************************************************************

 *  SBMAC_MII_READ(bus, phyaddr, regidx)

 *  Read a PHY register.

 *

 *  Input parameters:

 *  	   bus     - MDIO bus handle

 *  	   phyaddr - PHY's address

 *  	   regnum  - index of register to read

 *

 *  Return value:

 *  	   value read, or 0xffff if an error occurred.

	/*

	 * Synchronize ourselves so that the PHY knows the next

	 * thing coming down is a command

	/*

	 * Send the data to the PHY.  The sequence is

	 * a "start" command (2 bits)

	 * a "read" command (2 bits)

	 * the PHY addr (5 bits)

	 * the register index (5 bits)

	/*

	 * Switch the port around without a clock transition.

	/*

	 * Send out a clock pulse to signal we want the status

	/*

	 * If an error occurred, the PHY will signal '1' back

	/*

	 * Issue an 'idle' clock pulse, but keep the direction

	 * the same.

 Switch back to output */

/**********************************************************************

 *  SBMAC_MII_WRITE(bus, phyaddr, regidx, regval)

 *

 *  Write a value to a PHY register.

 *

 *  Input parameters:

 *  	   bus     - MDIO bus handle

 *  	   phyaddr - PHY to use

 *  	   regidx  - register within the PHY

 *  	   regval  - data to write to register

 *

 *  Return value:

 *  	   0 for success

/**********************************************************************

 *  SBDMA_INITCTX(d,s,chan,txrx,maxdescr)

 *

 *  Initialize a DMA channel context.  Since there are potentially

 *  eight DMA channels per MAC, it's nice to do this in a standard

 *  way.

 *

 *  Input parameters:

 *  	   d - struct sbmacdma (DMA channel context)

 *  	   s - struct sbmac_softc (pointer to a MAC)

 *  	   chan - channel number (0..1 right now)

 *  	   txrx - Identifies DMA_TX or DMA_RX for channel direction

 *      maxdescr - number of descriptors

 *

 *  Return value:

 *  	   nothing

	/*

	 * Save away interesting stuff in the structure

 RMON clearing */

	/*

	 * initialize register pointers

	/*

	 * Allocate memory for the ring

	/*

	 * The descriptor table must be aligned to at least 16 bytes or the

	 * MAC will corrupt it.

	/*

	 * And context table

	/*

	 * Setup Rx/Tx DMA coalescing defaults

/**********************************************************************

 *  SBDMA_CHANNEL_START(d)

 *

 *  Initialize the hardware registers for a DMA channel.

 *

 *  Input parameters:

 *  	   d - DMA channel to init (context must be previously init'd

 *         rxtx - DMA_RX or DMA_TX depending on what type of channel

 *

 *  Return value:

 *  	   nothing

	/*

	 * Turn on the DMA channel

	/*

	 * Initialize ring pointers

/**********************************************************************

 *  SBDMA_CHANNEL_STOP(d)

 *

 *  Initialize the hardware registers for a DMA channel.

 *

 *  Input parameters:

 *  	   d - DMA channel to init (context must be previously init'd

 *

 *  Return value:

 *  	   nothing

	/*

	 * Turn off the DMA channel

	/*

	 * Zero ring pointers

/**********************************************************************

 *  SBDMA_ADD_RCVBUFFER(d,sb)

 *

 *  Add a buffer to the specified DMA channel.   For receive channels,

 *  this queues a buffer for inbound packets.

 *

 *  Input parameters:

 *	   sc - softc structure

 *  	    d - DMA channel descriptor

 * 	   sb - sk_buff to add, or NULL if we should allocate one

 *

 *  Return value:

 *  	   0 if buffer could not be added (ring is full)

 *  	   1 if buffer added successfully

 get pointer to our current place in the ring */

	/*

	 * figure out if the ring is full - if the next descriptor

	 * is the same as the one that we're going to remove from

	 * the ring, the ring is full

	/*

	 * Allocate a sk_buff if we don't already have one.

	 * If we do have an sk_buff, reset it so that it's empty.

	 *

	 * Note: sk_buffs don't seem to be guaranteed to have any sort

	 * of alignment when they are allocated.  Therefore, allocate enough

	 * extra space to make sure that:

	 *

	 *    1. the data does not start in the middle of a cache line.

	 *    2. The data does not end in the middle of a cache line

	 *    3. The buffer can be aligned such that the IP addresses are

	 *       naturally aligned.

	 *

	 *  Remember, the SOCs MAC writes whole cache lines at a time,

	 *  without reading the old contents first.  So, if the sk_buff's

	 *  data portion starts in the middle of a cache line, the SOC

	 *  DMA will trash the beginning (and ending) portions.

		/*

		 * nothing special to reinit buffer, it's already aligned

		 * and sb->data already points to a good place.

	/*

	 * fill in the descriptor

	/*

	 * Do not interrupt per DMA transfer.

 receiving: no options */

	/*

	 * fill in the context

	/*

	 * point at next packet

	/*

	 * Give the buffer to the DMA engine.

 we did it */

/**********************************************************************

 *  SBDMA_ADD_TXBUFFER(d,sb)

 *

 *  Add a transmit buffer to the specified DMA channel, causing a

 *  transmit to start.

 *

 *  Input parameters:

 *  	   d - DMA channel descriptor

 * 	   sb - sk_buff to add

 *

 *  Return value:

 *  	   0 transmit queued successfully

 *  	   otherwise error code

 get pointer to our current place in the ring */

	/*

	 * figure out if the ring is full - if the next descriptor

	 * is the same as the one that we're going to remove from

	 * the ring, the ring is full

	/*

	 * Under Linux, it's not necessary to copy/coalesce buffers

	 * like it is on NetBSD.  We think they're all contiguous,

	 * but that may not be true for GBE.

	/*

	 * fill in the descriptor.  Note that the number of cache

	 * blocks in the descriptor is the number of blocks

	 * *spanned*, so we need to add in the offset (if any)

	 * while doing the calculation.

 transmitting: set outbound options and length */

	/*

	 * fill in the context

	/*

	 * point at next packet

	/*

	 * Give the buffer to the DMA engine.

 we did it */

/**********************************************************************

 *  SBDMA_EMPTYRING(d)

 *

 *  Free all allocated sk_buffs on the specified DMA channel;

 *

 *  Input parameters:

 *  	   d  - DMA channel

 *

 *  Return value:

 *  	   nothing

/**********************************************************************

 *  SBDMA_FILLRING(d)

 *

 *  Fill the specified DMA channel (must be receive channel)

 *  with sk_buffs

 *

 *  Input parameters:

 *	   sc - softc structure

 *  	    d - DMA channel

 *

 *  Return value:

 *  	   nothing

/**********************************************************************

 *  SBDMA_RX_PROCESS(sc,d,work_to_do,poll)

 *

 *  Process "completed" receive buffers on the specified DMA channel.

 *

 *  Input parameters:

 *            sc - softc structure

 *  	       d - DMA channel context

 *    work_to_do - no. of packets to process before enabling interrupt

 *                 again (for NAPI)

 *          poll - 1: using polling (for NAPI)

 *

 *  Return value:

 *  	   nothing

 Check if the HW dropped any frames */

		/*

		 * figure out where we are (as an index) and where

		 * the hardware is (also as an index)

		 *

		 * This could be done faster if (for example) the

		 * descriptor table was page-aligned and contiguous in

		 * both virtual and physical memory -- you could then

		 * just compare the low-order bits of the virtual address

		 * (sbdma_remptr) and the physical address (sbdma_curdscr CSR)

		/*

		 * If they're the same, that means we've processed all

		 * of the descriptors up to (but not including) the one that

		 * the hardware is working on right now.

		/*

		 * Otherwise, get the packet's sk_buff ptr back

		/*

		 * Check packet status.  If good, process it.

		 * If not, silently drop it and put it back on the

		 * receive ring.

			/*

			 * Add a new buffer to replace the old one.  If we fail

			 * to allocate a buffer, we're going to drop this

			 * packet and put it right back on the receive ring.

 Re-add old buffer */

 No point in continuing at the moment */

				/*

				 * Set length into the packet

				/*

				 * Buffer has been replaced on the

				 * receive ring.  Pass the buffer to

				 * the kernel

 Check hw IPv4/TCP checksum if supported */

 don't need to set sb->csum */

			/*

			 * Packet was mangled somehow.  Just drop it and

			 * put it back on the receive ring.

		/*

		 * .. and advance to the next buffer.

 collect fifo drop statistics again */

/**********************************************************************

 *  SBDMA_TX_PROCESS(sc,d)

 *

 *  Process "completed" transmit buffers on the specified DMA channel.

 *  This is normally called within the interrupt service routine.

 *  Note that this isn't really ideal for priority channels, since

 *  it processes all of the packets on a given channel before

 *  returning.

 *

 *  Input parameters:

 *      sc - softc structure

 *  	 d - DMA channel context

 *    poll - 1: using polling (for NAPI)

 *

 *  Return value:

 *  	   nothing

		/*

		 * figure out where we are (as an index) and where

		 * the hardware is (also as an index)

		 *

		 * This could be done faster if (for example) the

		 * descriptor table was page-aligned and contiguous in

		 * both virtual and physical memory -- you could then

		 * just compare the low-order bits of the virtual address

		 * (sbdma_remptr) and the physical address (sbdma_curdscr CSR)

		/*

		 * If they're the same, that means we've processed all

		 * of the descriptors up to (but not including) the one that

		 * the hardware is working on right now.

		/*

		 * Otherwise, get the packet's sk_buff ptr back

		/*

		 * Stats

		/*

		 * for transmits, we just free buffers.

		/*

		 * .. and advance to the next buffer.

	/*

	 * Decide if we should wake up the protocol or not.

	 * Other drivers seem to do this when we reach a low

	 * watermark on the transmit queue.

/**********************************************************************

 *  SBMAC_INITCTX(s)

 *

 *  Initialize an Ethernet context structure - this is called

 *  once per MAC on the 1250.  Memory is allocated here, so don't

 *  call it again from inside the ioctl routines that bring the

 *  interface up/down

 *

 *  Input parameters:

 *  	   s - sbmac context structure

 *

 *  Return value:

 *  	   0

	/*

	 * figure out the addresses of some ports

	/*

	 * Initialize the DMA channels.  Right now, only one per MAC is used

	 * Note: Only do this _once_, as it allocates memory from the kernel!

	/*

	 * initial state is OFF

/**********************************************************************

 *  SBMAC_CHANNEL_START(s)

 *

 *  Start packet processing on this MAC.

 *

 *  Input parameters:

 *  	   s - sbmac structure

 *

 *  Return value:

 *  	   nothing

	/*

	 * Don't do this if running

	/*

	 * Bring the controller out of reset, but leave it off.

	/*

	 * Ignore all received packets

	/*

	 * Calculate values for various control registers.

	/*

	 * Be sure that RD_THRSH+WR_THRSH <= 32 for pass1 pars

	 * and make sure that RD_THRSH + WR_THRSH <=128 for pass2 and above

	 * Use a larger RD_THRSH for gigabit

 Must be '4' or '8' */

 Must be '4' */

	/*

	 * Clear out the hash address map

	/*

	 * Clear out the exact-match table

	/*

	 * Clear out the DMA Channel mapping table registers

	/*

	 * Program the hardware address.  It goes into the hardware-address

	 * register as well as the first filter register.

	/*

	 * Set the receive filter for no packets, and write values

	 * to the various config registers

	/*

	 * Initialize DMA channels (rings should be ok now)

	/*

	 * Configure the speed, duplex, and flow control

	/*

	 * Fill the receive ring

	/*

	 * Turn on the rest of the bits in the enable register

	/*

	 * Enable receiving unicasts and broadcasts

	/*

	 * we're running now.

	/*

	 * Program multicast addresses

	/*

	 * If channel was in promiscuous mode before, turn that on

/**********************************************************************

 *  SBMAC_CHANNEL_STOP(s)

 *

 *  Stop packet processing on this MAC.

 *

 *  Input parameters:

 *  	   s - sbmac structure

 *

 *  Return value:

 *  	   nothing

 don't do this if already stopped */

 don't accept any packets, disable all interrupts */

 Turn off ticker */

 XXX */

 turn off receiver and transmitter */

 We're stopped now. */

	/*

	 * Stop DMA channels (rings should be ok now)

 Empty the receive and transmit rings */

/**********************************************************************

 *  SBMAC_SET_CHANNEL_STATE(state)

 *

 *  Set the channel's state ON or OFF

 *

 *  Input parameters:

 *  	   state - new state

 *

 *  Return value:

 *  	   old state

	/*

	 * If same as previous state, return

	/*

	 * If new state is ON, turn channel on

	/*

	 * Return previous state

/**********************************************************************

 *  SBMAC_PROMISCUOUS_MODE(sc,onoff)

 *

 *  Turn on or off promiscuous mode

 *

 *  Input parameters:

 *  	   sc - softc

 *      onoff - 1 to turn on, 0 to turn off

 *

 *  Return value:

 *  	   nothing

/**********************************************************************

 *  SBMAC_SETIPHDR_OFFSET(sc,onoff)

 *

 *  Set the iphdr offset as 15 assuming ethernet encapsulation

 *

 *  Input parameters:

 *  	   sc - softc

 *

 *  Return value:

 *  	   nothing

 Hard code the off set to 15 for now */

	/* BCM1250 pass1 didn't have hardware checksum.  Everything

/**********************************************************************

 *  SBMAC_ADDR2REG(ptr)

 *

 *  Convert six bytes into the 64-bit register value that

 *  we typically write into the SBMAC's address/mcast registers

 *

 *  Input parameters:

 *  	   ptr - pointer to 6 bytes

 *

 *  Return value:

 *  	   register value

/**********************************************************************

 *  SBMAC_SET_SPEED(s,speed)

 *

 *  Configure LAN speed for the specified MAC.

 *  Warning: must be called when MAC is off!

 *

 *  Input parameters:

 *  	   s - sbmac structure

 *  	   speed - speed to set MAC to (see enum sbmac_speed)

 *

 *  Return value:

 *  	   1 if successful

 *      0 indicates invalid parameters

	/*

	 * Save new current values

 save for next restart */

	/*

	 * Read current register values

	/*

	 * Mask out the stuff we want to change

	/*

	 * Now add in the new bits

	/*

	 * Send the bits back to the hardware

/**********************************************************************

 *  SBMAC_SET_DUPLEX(s,duplex,fc)

 *

 *  Set Ethernet duplex and flow control options for this MAC

 *  Warning: must be called when MAC is off!

 *

 *  Input parameters:

 *  	   s - sbmac structure

 *  	   duplex - duplex setting (see enum sbmac_duplex)

 *  	   fc - flow control setting (see enum sbmac_fc)

 *

 *  Return value:

 *  	   1 if ok

 *  	   0 if an invalid parameter combination was specified

	/*

	 * Save new current values

 save for next restart */

	/*

	 * Read current register values

	/*

	 * Mask off the stuff we're about to change

 not valid in half duplex */

 invalid selection */

 not valid in full duplex */

 not valid in full duplex */

	/*

	 * Send the bits back to the hardware

/**********************************************************************

 *  SBMAC_INTR()

 *

 *  Interrupt handler for MAC interrupts

 *

 *  Input parameters:

 *  	   MAC structure

 *

 *  Return value:

 *  	   nothing

	/*

	 * Read the ISR (this clears the bits in the real

	 * register, except for counter addr)

	/*

	 * Transmits on channel 0

 Depend on the exit from poll to reenable intr */

 may leave some packets behind */

/**********************************************************************

 *  SBMAC_START_TX(skb,dev)

 *

 *  Start output on the specified interface.  Basically, we

 *  queue as many buffers as we can until the ring fills up, or

 *  we run off the end of the queue, whichever comes first.

 *

 *  Input parameters:

 *

 *

 *  Return value:

 *  	   nothing

 lock eth irq */

	/*

	 * Put the buffer on the transmit ring.  If we

	 * don't have room, stop the queue.

 XXX save skb that we could not send */

/**********************************************************************

 *  SBMAC_SETMULTI(sc)

 *

 *  Reprogram the multicast table into the hardware, given

 *  the list of multicasts associated with the interface

 *  structure.

 *

 *  Input parameters:

 *  	   sc - softc

 *

 *  Return value:

 *  	   nothing

	/*

	 * Clear out entire multicast table.  We do this by nuking

	 * the entire hash table and all the direct matches except

	 * the first one, which is used for our station address

	/*

	 * Clear the filter to say we don't want any multicasts.

		/*

		 * Enable ALL multicasts.  Do this by inverting the

		 * multicast enable bit.

	/*

	 * Progam new multicast entries.  For now, only use the

	 * perfect filter.  In the future we'll need to use the

	 * hash filter if the perfect filter overflows

	/* XXX only using perfect filter for now, need to use hash

 skip station address */

	/*

	 * Enable the "accept multicast bits" if we programmed at least one

	 * multicast.

/**********************************************************************

 *  SBMAC_INIT(dev)

 *

 *  Attach routine - init hardware and hook ourselves into linux

 *

 *  Input parameters:

 *  	   dev - net_device structure

 *

 *  Return value:

 *  	   status

	/*

	 * Read the ethernet address.  The firmware left this programmed

	 * for us in the ethernet address register for each mac.

	/*

	 * Initialize context (get pointers to registers and stuff), then

	 * allocate the memory for the descriptor tables.

	/*

	 * Set up Linux device callins

 This is needed for PASS2 for Rx H/W checksum feature */

	/*

	 * Probe PHY address

	/*

	 * Display Ethernet address (this is called during the config

	 * process so we need to finish off the config message that

	 * was being displayed)

	/*

	 * map/route interrupt (clear status first, in case something

	 * weird is pending; we haven't initialized the mac registers

	 * yet)

	/*

	 * Attach to the PHY

	/*

	 * Turn on the channel

 Remove any features not supported by the controller */

 Hmmm... */

		/*

		 * something changed, restart the channel

 prevent tx timeout */

		/*

		 * Promiscuous changed.

	/*

	 * Program the multicasts.  Do this every time.

	/*

	 * The R_MAC_ETHERNET_ADDR register will be set to some nonzero

	 * value for us by the firmware if we're going to use this MAC.

	 * If we find a zero, skip this MAC.

	/*

	 * Okay, cool.  Initialize this MAC.

/*

 * Copyright (C) 2016 Broadcom

 *

 * This program is free software; you can redistribute it and/or

 * modify it under the terms of the GNU General Public License as

 * published by the Free Software Foundation version 2.

 *

 * This program is distributed "as is" WITHOUT ANY WARRANTY of any

 * kind, whether express or implied; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the

 * GNU General Public License for more details.

	/* The Reset Control register only contains a single bit to show if the

	 * controller is currently in reset.  Do a sanity check here, just in

	 * case the bootloader happened to leave the device in reset.

 Some bits of BCMA_IOCTL set by HW/ATF and should not change */

 This shouldn't be encountered */

 This shouldn't be encountered */

 This shouldn't be encountered */

 SET RGMII IO CONFIG */

 Set the features of the 4707 family */

 CONFIG_PM */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Broadcom BCM7xxx System Port Ethernet MAC driver

 *

 * Copyright (C) 2014 Broadcom Corporation

 I/O accessors register helpers */

/* On SYSTEMPORT Lite, any register after RDMA_STATUS has the exact

 * same layout, except it has been moved by 4 bytes up, *sigh*

/* L2-interrupt masking/unmasking helpers, does automatic saving of the applied

 * mask in a software copy to avoid CPU_MASK_STATUS reads in hot-paths.

/* Register accesses to GISB/RBUS registers are expensive (few hundred

 * nanoseconds), so keep the check for 64-bits explicit here to save

 * one register write per-packet on 32-bits platforms.

 Ethtool operations */

	/* Clear L2 header checks, which would prevent BPDUs

	 * from being received.

	/* If UniMAC forwards CRC, we need to skip over it to get

	 * a valid CHK bit to be set in the per-packet status word

	/* If Broadcom tags are enabled (e.g: using a switch), make

	 * sure we tell the RXCHK hardware to expect a 4-bytes Broadcom

	 * tag after the Ethernet MAC Source Address.

	/* Hardware transmit checksum requires us to enable the Transmit status

	 * block prepended to the packet contents

	/* Indicating that software inserts Broadcom tags is needed for the TX

	 * checksum to be computed correctly when using VLAN HW acceleration,

	 * else it has no effect, so it can always be turned on.

 Default TPID is ETH_P_8021AD, change to ETH_P_8021Q */

 Read CRC forward */

/* Hardware counters must be kept in sync because the order/offset

 * is important here (order in structure declaration = order in hardware)

 general stats */

 UniMAC RSV counters */

 UniMAC TSV counters */

 UniMAC RUNT counters */

 RXCHK misc statistics */

 RBUF misc statistics */

 Per TX-queue statistics are dynamically appended */

 Include per-queue statistics */

	/* For SYSTEMPORT Lite since we have holes in our statistics, j would

	 * be equal to BCM_SYSPORT_STATS_LEN at the end of the loop, but it

	 * needs to point to how many total statistics we have minus the

	 * number of per TX queue statistics

 Flag the device and relevant IRQ as wakeup capable */

 Avoid unbalanced disable_irq_wake calls */

	/* Base system clock is 125Mhz, DMA timeout is this reference clock

	 * divided by 1024, which yield roughly 8.192 us, our maximum value has

	 * to fit in the RING_TIMEOUT_MASK (16 bits).

 Apply desired coalescing parameters */

 Allocate a new SKB for a new packet */

 Grab the current SKB on the ring */

 Put the new SKB on the ring */

 Return the current SKB to the caller */

 Poll the hardware for up to budget packets to process */

 Clear status before servicing to reduce spurious interrupts */

	/* Determine how much we should process since last call, SYSTEMPORT Lite

	 * groups the producer and consumer indexes into the same 32-bit

	 * which we access using RDMA_CONS_INDEX

		/* We do not have a backing SKB, so we do not a corresponding

		 * DMA mapping for this incoming packet since

		 * bcm_sysport_rx_refill always either has both skb and mapping

		 * or none.

 Extract the Receive Status Block prepended */

 Hardware validated our checksum */

		/* Hardware pre-pends packets with 2bytes before Ethernet

		 * header plus we have the Receive Status Block, strip off all

		 * of this from the SKB.

 UniMAC may forward CRC */

 SKB fragment */

 Reclaim queued SKBs for transmission completion, lockless version */

 Clear status before servicing to reduce spurious interrupts */

 Compute how many descriptors have been processed since last call */

 Locked version of the per-ring TX reclaim routine */

 Locked version of the per-ring TX reclaim, but does not wake the queue */

 re-enable TX interrupt */

	/* SYSTEMPORT Lite groups the producer/consumer index, producer is

	 * maintained by HW, but writes to it will be ignore while RDMA

	 * is active

 re-enable RX interrupts */

 Disable RXCHK, active filters and Broadcom tag matching */

	/* Make sure we restore correct CID index in case HW lost

	 * its context during deep idle state

 Clear the MagicPacket detection logic */

 RX and misc interrupt routine */

 disable RX interrupts */

	/* TX ring is full, perform a full reclaim since we do not know

	 * which one would trigger this interrupt

 TX interrupt service routine */

 Re-allocate SKB if needed */

 Zero-out TSB by default */

 Get the checksum offset and the L4 (transport) offset */

 Account for the HW inserted VLAN tag */

 lock against tx reclaim in BH context and TX ring full interrupt */

 Insert TSB and checksum infos */

 Remember the SKB for future freeing */

 Ports are latched, so write upper address first */

 Check ring space and update SW control flow */

 phylib adjust link callback */

 If DIM was enabled, re-apply default parameters */

 Simple descriptors partitioning for now */

 Initialize SW view of the ring */

 Initialize HW ring */

 Configure QID and port mapping */

	/* Adjust the packet size calculations if SYSTEMPORT is responsible

	 * for HW insertion of VLAN tags

 Enable ACB algorithm 2 */

	/* Do not use tdma_control_bit() here because TSB_SWAP1 collides

	 * with the original definition of ACB_ALGO

 Set a correct TSB format based on host endian */

	/* Program the number of descriptors as MAX_THRESHOLD and half of

	 * its size for the hysteresis trigger

 Enable the ring queue in the arbiter */

 Caller should stop the TDMA engine */

	/* ring->cbs is the last part in bcm_sysport_init_tx_ring which could

	 * fail, so by checking this pointer we know whether the TX ring was

	 * fully initialized or not.

 RDMA helper */

 Poll for RMDA disabling completion */

 TDMA helper */

 Poll for TMDA disabling completion */

 Initialize SW view of the RX ring */

 Initialize HW, ensure RDMA is disabled */

 Operate the queue in ring mode */

 Caller should ensure RDMA is disabled */

 No support for ALLMULTI */

	/* UniMAC stops on a packet boundary, wait for a full-sized packet

	 * to be processed (1 msec).

	/* interface is disabled, changes to MAC will be reflected on next

	 * open call

 Enable NAPI */

 Enable RX interrupt and TX ring full interrupt */

 Enable TX interrupts for the TXQs */

 Set a correct RSB format on SYSTEMPORT Lite */

 Set a correct RSB format based on host endian */

 Include Broadcom tag in pad extension and fix up IPG_LENGTH */

 Reset UniMAC */

 Flush TX and RX FIFOs at TOPCTRL level */

 Disable the UniMAC RX/TX */

 Enable RBUF 2bytes alignment and Receive Status Block */

 Set maximum frame length */

	/* Apply features again in case we changed them while interface was

	 * down

 Set MAC address */

 Reset house keeping link status */

 mask all interrupts and request them */

 Initialize both hardware and software ring */

 Initialize linked-list */

 Initialize RX ring */

 Turn on RDMA */

 Turn on TDMA */

 Turn on UniMAC TX/RX */

 stop all software from updating hardware */

 mask all interrupts */

 Disable UniMAC RX */

 Wait for a maximum packet size to be drained */

 Disable UniMAC TX */

 Free RX/TX rings SW structures */

 Disconnect from PHY */

 This is not a rule that we know about */

	/* We cannot match locations greater than what the classification ID

	 * permits (256 entries)

 We cannot support flows that are not destined for a wake-up */

 All filters are already in use, we cannot match more rules */

	/* Location is the classification ID, and index is the position

	 * within one of our 8 possible filters to be programmed

 This is not a rule that we know about */

	/* No need to disable this filter if it was enabled, this will

	 * be taken care of during suspend time by bcm_sysport_suspend_to_wol

 DSA tagging layer will have configured the correct queue */

	/* We can't be setting up queue inspection for non directly attached

	 * switches

	/* On SYSTEMPORT Lite we have twice as less queues, so we cannot do a

	 * 1:1 mapping, we can only do a 2:1 mapping. By reducing the number of

	 * per-port (slave_dev) network devices queue, we achieve just that.

	 * This need to happen now before any slave network device is used such

	 * it accurately reflects the number of real TX queues.

		/* Just remember the mapping actual programming done

		 * during bcm_sysport_init_tx_ring

 sentinel */ }

 Fairly quickly we need to know the type of adapter we have */

 Read the Transmit/Receive Queue properties */

 Sanity check the number of transmit queues */

 Initialize private members */

 Allocate number of TX rings */

 Default to GMII interface mode */

	/* In the case of a fixed PHY, the DT node associated

	 * to the PHY is the Ethernet MAC DT node.

 Initialize netdevice members */

 Request the WOL interrupt and advertise suspend if available */

 Set the needed headroom once and for all */

 libphy will adjust the link state accordingly */

	/* Not much to do, ndo_close has been called

	 * and we use managed allocations

 Program the SecureOn password */

 Turn on ACPI matching to steal packets from RBUF */

 Enable RXCHK, active filters and Broadcom tag matching */

 Make sure RBUF entered WoL mode as result */

 Do not leave the UniMAC RBUF matching only MPD packets */

 UniMAC receive needs to be turned on */

 Disable UniMAC RX */

 Disable RXCHK if enabled */

 Flush RX pipe */

 Wait for a packet boundary */

 Free RX/TX rings SW structures */

 Get prepared for Wake-on-LAN */

 Disable the UniMAC RX/TX */

	/* We may have been suspended and never received a WOL event that

	 * would turn off MPD detection, take care of that now

 Initialize both hardware and software ring */

 Initialize linked-list */

 Initialize RX ring */

 RX pipe enable */

 Restore enabled features */

 Set maximum frame length */

 Set MAC address */

 TX pipe enable */

/*

 * tg3.c: Broadcom Tigon3 ethernet driver.

 *

 * Copyright (C) 2001, 2002, 2003, 2004 David S. Miller (davem@redhat.com)

 * Copyright (C) 2001, 2002, 2003 Jeff Garzik (jgarzik@pobox.com)

 * Copyright (C) 2004 Sun Microsystems Inc.

 * Copyright (C) 2005-2016 Broadcom Corporation.

 * Copyright (C) 2016-2017 Broadcom Limited.

 * Copyright (C) 2018 Broadcom. All Rights Reserved. The term "Broadcom"

 * refers to Broadcom Inc. and/or its subsidiaries.

 *

 * Firmware is:

 *	Derived from proprietary unpublished source code,

 *	Copyright (C) 2000-2016 Broadcom Corporation.

 *	Copyright (C) 2016-2017 Broadcom Ltd.

 *	Copyright (C) 2018 Broadcom. All Rights Reserved. The term "Broadcom"

 *	refers to Broadcom Inc. and/or its subsidiaries.

 *

 *	Permission is hereby granted for the distribution of this firmware

 *	data in hexadecimal or equivalent format, provided this copyright

 *	notice is accompanying it.

 Functions & macros to verify TG3_FLAGS types */

 DO NOT UPDATE TG3_*_NUM defines */

/* length of time before we decide the hardware is borked,

 * and dev->tx_timeout() should be called to fix the problem

 hardware minimum and maximum for a single frame's data payload */

/* These numbers seem to be hard coded in the NIC firmware somehow.

 * You can't change the ring sizes, but you can change where you place

 * them in the NIC onboard memory.

/* Do not place this n-ring entries value into the tp struct itself,

 * we really want to expose these constants to GCC so that modulo et

 * al.  operations are done with shifts and masks instead of with

 * hw multiply/modulo instructions.  Another solution would be to

 * replace things like '% foo' with '& (foo - 1)'.

/* Due to a hardware bug, the 5701 can only DMA to memory addresses

 * that are at least dword aligned when used in PCIX mode.  The driver

 * works around this bug by double copying the packet.  This workaround

 * is built into the normal double copy length check for efficiency.

 *

 * However, the double copy is only necessary on those architectures

 * where unaligned memory accesses are inefficient.  For those architectures

 * where unaligned memory accesses incur little penalty, we can reintegrate

 * the 5701 in the normal rx path.  Doing so saves a device structure

 * dereference by hardcoding the double copy threshold in place.

 minimum number of free TX descriptors required to wake up TX process */

 -1 == use TG3_DEF_MSG_ENABLE as value */

 Fujitsu 1000base-SX with BCM5703SKHB */

	/* In indirect mode when disabling interrupts, we also need

	 * to clear the interrupt bit in the GRC local ctrl register.

/* usec_wait specifies the wait time in usec when writing to certain registers

 * where it is unsafe to read back the register without some delay.

 * GRC_LOCAL_CTRL is one example if the GPIOs are toggled to switch power.

 * TG3PCI_CLOCK_CTRL is another example if the clock frequencies are changed.

 Non-posted methods */

 Posted method */

	/* Wait again after the read for the posted method to guarantee that

	 * the wait time is met.

 Always leave this as zero. */

 Always leave this as zero. */

 Always leave this as zero. */

 Always leave this as zero. */

 Make sure the driver hasn't any stale locks. */

 Wait for up to 1 millisecond to acquire lock. */

 Revoke the lock request. */

 Cap xfer sizes to scratchpad limits. */

 Wait for up to 1 msec for APE to service previous event. */

 Wait for up to 20 millisecond for APE to service previous event. */

 Check if hb interval has exceeded */

 Force an initial interrupt */

 check for phy events */

 check for TX work to do */

 check for RX work to do */

/* tg3_int_reenable

 *  similar to tg3_enable_ints, but it accurately determines whether there

 *  is new work pending and can return without flushing the PIO write

 *  which reenables interrupts

	/* When doing tagged status, this work check is unnecessary.

	 * The last_tag we write above tells the chip which piece of

	 * work we've completed.

	/* OK, reset it, and poll the BMCR_RESET bit until it

	 * clears or we time out.

	/* The bus registration will look for all the PHYs on the mdio bus.

	 * Unfortunately, it does not ensure the PHY is powered up before

	 * accessing the PHY ID registers.  A chip reset is the

	 * quickest way to bring the device back to an operational state..

 tp->lock is held. */

 tp->lock is held. */

 If enough time has passed, no wait is necessary. */

 Check if we can shorten the wait time. */

 tp->lock is held. */

 tp->lock is held. */

 tp->lock is held. */

 Wait for RX cpu to ACK the previous event. */

 Wait for RX cpu to ACK this event. */

 tp->lock is held. */

 tp->lock is held. */

 tp->lock is held. */

 We don't use firmware. */

 Wait up to 20ms for init done. */

 Wait for firmware initialization to complete. */

	/* Chip might not be fitted with firmware.  Some Sun onboard

	 * parts are configured like that.  So don't signal the timeout

	 * of the above loop as an error, but do report the lack of

	 * running firmware once.

		/* The 57765 A0 needs a little more

		 * time to do some important work.

 Bring the PHY back to a known state. */

 Attach the MAC to the PHY. */

 Mask with MAC supported features. */

 Cannot do read-modify-write on 5401 */

 Pull eee_active */

 Pull lp advertised settings */

 Pull advertised and eee_enabled settings */

 Pull tx_lpi_enabled */

 Pull lpi timer value */

 Disable transmitter and interrupt.  */

 Set full-duplex, 1000 mbps.  */

 Set to master mode.  */

 Block the PHY control access.  */

/* This will reset the tigon3 PHY if there is no valid

 * link unless the FORCE argument is non-zero.

 Set Extended packet length bit (bit 14) on all chips that */

 support jumbo frames */

 Cannot do read-modify-write on 5401 */

 Set bit 14 with read-modify-write to preserve other bits */

	/* Set phy register 0x10 bit 0 to high fifo elasticity to support

	 * jumbo frames transmission.

 adjust output voltage */

 The 5761 non-e device swaps GPIO 0 and GPIO 2. */

 Workaround to prevent overdrawing Amps. */

 On 5753 and variants, GPIO2 cannot be used. */

 Serialize power state transitions */

 The GPIOs do something completely different on 57765. */

 remove_one() may have been run on the peer. */

	/* The PHY should not be powered down on some chips because

	 * of bugs.

 tp->lock is held. */

 tp->lock is held. */

 tp->lock is held. */

 tp->lock is held. */

	/*

	 * The data will always be opposite the native endian

	 * format.  Perform a blind byteswap to compensate.

/* NOTE: Data read in from NVRAM is byteswapped according to

 * the byteswapping settings for all other register accesses.

 * tg3 devices are BE devices, so on a BE machine, the data

 * returned will be exactly as it is seen in NVRAM.  On a LE

 * machine, the 32-bit value will be byteswapped.

 Ensures NVRAM data is in bytestream format. */

		/*

		 * The SEEPROM interface expects the data to always be opposite

		 * the native endian format.  We accomplish this by reversing

		 * all the operations that would have been performed on the

		 * data from a call to tg3_nvram_read_be32().

 offset and length are dword aligned */

		/*

		 * Before we can erase the flash page, we need

		 * to issue a special "write enable" command.

 Erase the target page */

 Issue another write enable to start the write. */

 offset and length are dword aligned */

 We always do complete word writes to eeprom. */

 offset and length are dword aligned */

 tp->lock is held. */

 tp->lock is held. */

 tp->lock is held. */

 tp->lock is held. */

 tp->lock is held. */

 tp->lock is held. */

		/*

		 * There is only an Rx CPU for the 5750 derivative in the

		 * BCM4785.

 Clear firmware's nvram arbitration. */

	/* Non fragmented firmware have one firmware header followed by a

	 * contiguous chunk of data to be written. The length field in that

	 * header is not the length of data to be written but the complete

	 * length of the bss. The data length is determined based on

	 * tp->fw->size minus headers.

	 *

	 * Fragmented firmware have a main header followed by multiple

	 * fragments. Each fragment is identical to non fragmented firmware

	 * with a firmware header followed by a contiguous chunk of data. In

	 * the main header, the length field is unused and set to 0xffffffff.

	 * In each fragment header the length is the entire size of that

	 * fragment i.e. fragment data + header length. Data length is

	 * therefore length field in the header minus TG3_FW_HDR_LEN.

 tp->lock is held. */

		/* It is possible that bootcode is still loading at this point.

		 * Get the nvram lock first before halting the cpu.

		/* Subtract additional main header for fragmented firmware and

		 * advance to the first fragment

 Advance to next fragment */

 tp->lock is held. */

 tp->lock is held. */

	/* Firmware blob starts with version numbers, followed by

	   start address and length. We are setting complete length.

	   length = end_address_of_bss - start_address_of_text.

	   Remainder is the blob to be loaded contiguously

 Now startup only the RX cpu. */

	/* Wait for boot code to complete initialization and enter service

	 * loop. It is then safe to download service patches

 tp->lock is held. */

	/* This firmware blob has a different format than older firmware

	 * releases as given below. The main difference is we have fragmented

	 * data to be written to non-contiguous locations.

	 *

	 * In the beginning we have a firmware header identical to other

	 * firmware which consists of version, base addr and length. The length

	 * here is unused and set to 0xffffffff.

	 *

	 * This is followed by a series of firmware fragments which are

	 * individually identical to previous firmware. i.e. they have the

	 * firmware header and followed by data for that fragment. The version

	 * field of the individual fragment header is unused.

 tg3_load_firmware_cpu() will always succeed for the 57766 */

 tp->lock is held. */

	/* Firmware blob starts with version numbers, followed by

	   start address and length. We are setting complete length.

	   length = end_address_of_bss - start_address_of_text.

	   Remainder is the blob to be loaded contiguously

 Now startup the cpu. */

 tp->lock is held. */

 tp->lock is held. */

	/*

	 * Make sure register accesses (indirect or otherwise) will function

	 * correctly.

 Switch out of Vaux if it is a NIC */

 Restore the CLKREQ setting. */

 do nothing */

 Workaround for unstable PLL clock */

 Advertise 100-BaseTX EEE ability */

 Advertise 1000-BaseT EEE ability */

 If we advertised any eee advertisements above... */

			/* Normally during power down we want to autonegotiate

			 * the lowest possible speed for WOL. However, to avoid

			 * link flap, we leave it untouched.

			/* With autoneg disabled, 5715 only links up when the

			 * advertisement register has the configured speed

			 * enabled.

 Turn off tap power management. */

 Set Extended packet length bit */

 EEE is disabled but we're advertising */

	/* Some third-party PHYs need to be reset on link going

	 * down.

 5701 {A0,B0} CRC bug workaround */

 Clear pending interrupts... */

			/* EEE settings changes take effect only after a phy

			 * reset.  If we have skipped a reset due to Link Flap

			 * Avoidance being enabled, do it now.

 FIXME: when BCM5325 switch is used use 100 MBit/s */

	/* In order for the 5750 core in BCM4785 chip to work properly

	 * in RGMII mode, the Led Control Register must be set up.

	/* ??? Without this setting Netgear GA302T PHY does not

	 * ??? send/receive packets...

 Polled via timer. */

 Prevent send BD corruption. */

 XXX another gem from the Broadcom driver :( */

 ??? unimplemented */

 ??? unimplemented */

 Reset when initting first time or we have a link. */

 Set PLL lock range. */

 SW reset */

 Wait for reset to complete. */

 XXX schedule_timeout() ... */

 Config mode; select PMA/Ch 1 regs. */

 Enable auto-lock and comdet, select txclk for tx. */

 Assert and deassert POR. */

 Wait for signal to stabilize */

 XXX schedule_timeout() ... */

	/* Deselect the channel register so we can read the PHYID

	 * later.

 preserve bits 0-11,13,14 for signal pre-emphasis */

 preserve bits 20-23 for voltage regulator */

 Want auto-negotiation.  */

 Link parallel detection - link is up */

 only if we have PCS_SYNC and not */

 receiving config code words */

 Forcing 1000FD link up. */

 Enable link change event even when serdes polling.  */

 do nothing, just check for link up at the end */

			/* BMCR_SPEED1000 is a reserved bit that needs

			 * to be set on write.

 Force a linkdown */

 Link is up via parallel detect */

 Give autoneg time to complete. */

 Select shadow register 0x1f */

 Select expansion interrupt status register */

				/* We have signal detect and not receiving

				 * config code words, link is up by parallel

				 * detection.

 Select expansion interrupt status register */

 Config code words received, turn on autoneg. */

 tp->lock must be held */

 tp->lock must be held */

	/* Frequency adjustment is performed using hardware with a 24 bit

	 * accumulator and a programmable correction value. On each clk, the

	 * correction value gets added to the accumulator and when it

	 * overflows, the time counter is incremented/decremented.

	 *

	 * So conversion from ppb to correction value is

	 *		ppb * (1 << 24) / 1000000000

 Reject requests with unsupported flags */

 tp->lock must be held */

 Initialize the hardware clock to the system time. */

 tp->lock must be held */

 Read up to but not including private PCI registers */

 SW status block */

/* This is called whenever we suspect that the system chipset is re-

 * ordering the sequence of MMIO to the tx send mailbox. The symptom

 * is bogus tx completions. We try to recover by setting the

 * TG3_FLAG_MBOX_WRITE_REORDER flag and resetting the chip later

 * in the workqueue.

 Tell compiler to fetch tx indices from memory. */

/* Tigon3 never reports partial packet sends.  So we do not

 * need special logic to handle SKBs that have not had all

 * of their frags sent yet, like SunGEM does.

	/* Need to make the tx_cons update visible to tg3_start_xmit()

	 * before checking for netif_queue_stopped().  Without the

	 * memory barrier, there is a small possibility that tg3_start_xmit()

	 * will miss it and cause the queue to be stopped forever.

/* Returns size of skb allocated or < 0 on error.

 *

 * We only need to fill in the address because the other members

 * of the RX descriptor are invariant, see tg3_init_rings.

 *

 * Note the purposeful assymetry of cpu vs. chip accesses.  For

 * posting buffers we only dirty the first cache line of the RX

 * descriptor (containing the address).  Whereas for the RX status

 * buffers the cpu only reads the last cacheline of the RX descriptor

 * (to fetch the error flags, vlan tag, checksum, and opaque cookie).

	/* Do not overwrite any of the map or rp information

	 * until we are sure we can commit to a new buffer.

	 *

	 * Callers depend upon this behavior and assume that

	 * we leave everything unchanged if we fail.

/* We only need to move over in the address because the other

 * members of the RX descriptor are invariant.  See notes above

 * tg3_alloc_rx_data for full details.

	/* Ensure that the update to the skb happens after the physical

	 * addresses have been transferred to the new BD location.

/* The RX ring scheme is composed of multiple rings which post fresh

 * buffers to the chip, and one special ring the chip uses to report

 * status back to the host.

 *

 * The special ring reports the status of received packets to the

 * host.  The chip does not write into the original descriptor the

 * RX buffer was obtained from.  The chip simply takes the original

 * descriptor as provided by the host, updates the status and length

 * field, then writes this into the next status ring entry.

 *

 * Each ring the host uses to post buffers to the chip is described

 * by a TG3_BDINFO entry in the chips SRAM area.  When a packet arrives,

 * it is first placed into the on-chip ram.  When the packet's length

 * is known, it walks down the TG3_BDINFO entries to select the ring.

 * Each TG3_BDINFO specifies a MAXLEN field and the first TG3_BDINFO

 * which is within the range of the new packet's length is chosen.

 *

 * The "separate ring for rx status" scheme may sound queer, but it makes

 * sense from a cache coherency perspective.  If only the host writes

 * to the buffer post rings, and only the chip writes to the rx status

 * rings, then cache lines never move beyond shared-modified state.

 * If both the host and chip were to write into the same ring, cache line

 * eviction could occur since both entities want it in an exclusive state.

	/*

	 * We need to order the read of hw_idx and the read of

	 * the opaque cookie.

 Other statistics kept track of by card. */

			/* Ensure that the update to the data happens

			 * after the usage of the old DMA mapping.

 Refresh hw_idx to see if there is new work */

 ACK the status ring. */

 Refill RX ring(s). */

 Sync BD data before updating mailbox */

		/* rx_std_buffers[] and rx_jmb_buffers[] entries must be

		 * updated before the producer indices can be updated.

 handle link change and other phy events */

		/* Make sure updates to the rx_std_buffers[] entries and the

		 * standard producer index are seen in the correct order.

		/* Ensure that updates to the rx_std_buffers ring and the

		 * shadowed hardware producer ring from tg3_recycle_skb() are

		 * ordered correctly WRT the skb check above.

		/* Make sure updates to the rx_jmb_buffers[] entries and

		 * the jumbo producer index are seen in the correct order.

		/* Ensure that updates to the rx_jmb_buffers ring and the

		 * shadowed hardware producer ring from tg3_recycle_skb() are

		 * ordered correctly WRT the skb check above.

 run TX completion thread */

	/* run RX thread, within the bounds set by NAPI.

	 * All RX "locking" is done by ensuring outside

	 * code synchronizes with tg3->napi.poll()

		/* tp->last_tag is used in tg3_int_reenable() below

		 * to tell the hw how much work has been processed,

		 * so we must read it before checking for more work.

 check for RX/TX work to do */

			/* This test here is not race free, but will reduce

			 * the number of interrupts by looping again.

 Reenable interrupts. */

			/* This test here is synchronized by napi_schedule()

			 * and napi_complete() to close the race condition.

 work_done is guaranteed to be less than budget. */

 Check Flow Attention register */

			/* tp->last_tag is used in tg3_int_reenable() below

			 * to tell the hw how much work has been processed,

			 * so we must read it before checking for more work.

 work_done is guaranteed to be less than budget. */

 prevent tx timeout */

 tp->lock must be held */

	/* NOTE: unconditional netif_tx_wake_all_queues is only

	 * appropriate so long as all callers are assured to

	 * have free tx slots (such as after tg3_init_hw)

/* Fully shutdown all tg3 driver activity elsewhere in the system.

 * If irq_sync is non-zero, then the IRQ handler must be synchronized

 * with as well.  Most of the time, this is not necessary except when

 * shutting down the device.

/* One-shot MSI handler - Chip automatically disables interrupt

 * after sending MSI so driver doesn't have to do it.

/* MSI ISR - No need to check for interrupt sharing and no need to

 * flush status block and interrupt mailbox. PCI ordering rules

 * guarantee that MSI will arrive after the status block.

	/*

	 * Writing any value to intr-mbox-0 clears PCI INTA# and

	 * chip-internal interrupt pending events.

	 * Writing non-zero to intr-mbox-0 additional tells the

	 * NIC to stop sending us irqs, engaging "in-intr-handler"

	 * event coalescing.

	/* In INTx mode, it is possible for the interrupt to arrive at

	 * the CPU before the status block posted prior to the interrupt.

	 * Reading the PCI State register will confirm whether the

	 * interrupt is ours and will flush the status block.

	/*

	 * Writing any value to intr-mbox-0 clears PCI INTA# and

	 * chip-internal interrupt pending events.

	 * Writing non-zero to intr-mbox-0 additional tells the

	 * NIC to stop sending us irqs, engaging "in-intr-handler"

	 * event coalescing.

	 *

	 * Flush the mailbox to de-assert the IRQ immediately to prevent

	 * spurious interrupts.  The flush impacts performance but

	 * excessive spurious interrupts can be worse in some cases.

		/* No work, shared interrupt perhaps?  re-enable

		 * interrupts, and flush that PCI write

	/* In INTx mode, it is possible for the interrupt to arrive at

	 * the CPU before the status block posted prior to the interrupt.

	 * Reading the PCI State register will confirm whether the

	 * interrupt is ours and will flush the status block.

	/*

	 * writing any value to intr-mbox-0 clears PCI INTA# and

	 * chip-internal interrupt pending events.

	 * writing non-zero to intr-mbox-0 additional tells the

	 * NIC to stop sending us irqs, engaging "in-intr-handler"

	 * event coalescing.

	 *

	 * Flush the mailbox to de-assert the IRQ immediately to prevent

	 * spurious interrupts.  The flush impacts performance but

	 * excessive spurious interrupts can be worse in some cases.

	/*

	 * In a shared interrupt configuration, sometimes other devices'

	 * interrupts will scream.  We record the current status tag here

	 * so that the above check can report that the screaming interrupts

	 * are unhandled.  Eventually they will be silenced.

 ISR for interrupt test */

 Test for DMA buffers crossing any 4GB boundaries: 4G, 8G, etc */

/* Test for TSO DMA buffers that cross into regions which are within MSS bytes

 * of any 4GB boundaries: 4G, 8G, etc

 Test for DMA addresses > 40-bit */

 Avoid the 8byte DMA problem */

 Workaround 4GB and 40-bit hardware DMA bugs. */

 New SKB is guaranteed to be linear. */

 Make sure the mapping succeeded */

	/* Check if we will never have enough descriptors,

	 * as gso_segs can be more than current ring size

/* Use GSO to workaround all TSO packets that meet HW bug conditions

 * indicated in tg3_tx_frag_set()

 Estimate the number of fragments in the worst case */

		/* netif_tx_stop_queue() must be done before checking

		 * checking tx index in tg3_tx_avail() below, because in

		 * tg3_tx(), we update tx index before checking for

		 * netif_tx_queue_stopped().

 hard_start_xmit for all devices */

	/* We are running in BH disabled context with netif_tx_lock

	 * and TX reclaim runs via tp->napi.poll inside of a software

	 * interrupt.  Furthermore, IRQ processing runs lockless so we have

	 * no IRQ context deadlocks to worry about either.  Rejoice!

 This is a hard error, log it. */

		/* HW/FW can not correctly segment packets that have been

		 * vlan encapsulated.

		/* HW/FW can not correctly checksum packets that have been

		 * vlan encapsulated.

		/* Now loop through additional data

		 * fragments, and queue them.

			/* If it's a TSO packet, do GSO instead of

			 * allocating and copying to a large linear SKB

		/* If the workaround fails due to memory/mapping

		 * failure, silently drop this packet.

 Sync BD data before updating mailbox */

		/* netif_tx_stop_queue() must be done before checking

		 * checking tx index in tg3_tx_avail() below, because in

		 * tg3_tx(), we update tx index before checking for

		 * netif_tx_queue_stopped().

 Packets are ready, update Tx producer idx on card. */

 The write needs to be flushed for the FETs */

 The write needs to be flushed for the AC131 */

 Reset to prevent losing 1st rx packet intermittently */

 Force link status check */

/* Initialize rx rings for packet processing.

 *

 * The chip has been shut down and the driver detached from

 * the networking, so no interrupts or new tx packets will

 * end up in the driver.  tp->{tx,}lock are held and thus

 * we may not sleep.

 Zero out all descriptors. */

	/* Initialize invariants of the rings, we only set this

	 * stuff once.  This works because the card does not

	 * write into the rx buffer posting rings.

 Now allocate fresh SKBs for each rx ring. */

/* Free up pending packets in all rx/tx rings.

 *

 * The chip has been shut down and the driver detached from

 * the networking, so no interrupts or new tx packets will

 * end up in the driver.  tp->{tx,}lock is not held and we are not

 * in an interrupt context and thus may sleep.

/* Initialize tx/rx rings for packet processing.

 *

 * The chip has been shut down and the driver detached from

 * the networking, so no interrupts or new tx packets will

 * end up in the driver.  tp->{tx,}lock are held and thus

 * we may not sleep.

 Free up all the SKBs. */

	/* If multivector TSS is enabled, vector 0 does not handle

	 * tx interrupts.  Don't allocate any resources for it.

	/* If RSS is enabled, we need a (dummy) producer ring

	 * set on vector zero.  This is the true hw prodring.

		/* If multivector RSS is enabled, vector 0

		 * does not handle rx or tx interrupts.

		 * Don't allocate any resources for it.

/*

 * Must not be invoked with interrupt sources disabled and

 * the hardware shutdown down.

	/* tp->hw_stats can be referenced safely:

	 *     1. under rtnl_lock

	 *     2. or under tp->lock if TG3_FLAG_INIT_COMPLETE is set.

/*

 * Must not be invoked with interrupt sources disabled and

 * the hardware shutdown down.  Can sleep.

			/*

			 * When RSS is enabled, the status block format changes

			 * slightly.  The "rx_jumbo_consumer", "reserved",

			 * and "rx_mini_consumer" members get mapped to the

			 * other three rx return ring producer indexes.

/* To stop a block, clear the enable bit and poll till it

 * clears.  tp->lock is held.

			/* We can't enable/disable these bits of the

			 * 5705/5750, just say success.

 tp->lock is held. */

 Save PCI command register before chip reset */

 Restore PCI state after chip reset */

 Re-enable indirect register accesses. */

 Set MAX PCI retry to zero. */

 Allow reads and writes to the APE register and memory space. */

 Make sure PCI-X relaxed ordering bit is clear. */

		/* Chip reset on 5780 will reset MSI enable bit,

		 * so need to restore it.

 tp->lock is held. */

	/* No matching tg3_nvram_unlock() after this because

	 * chip reset below will undo the nvram lock.

	/* GRC_MISC_CFG core clock reset will clear the memory

	 * enable bit in PCI register 4 and the MSI enable bit

	 * on some chips, so we save relevant registers here.

	/*

	 * We must avoid the readl() that normally takes place.

	 * It locks machines, causes machine checks, and other

	 * fun things.  So, temporarily disable the 5701

	 * hardware workaround, while we do the reset.

	/* Prevent the irq handler from reading or writing PCI registers

	 * during chip reset when the memory enable bit in the PCI command

	 * register may be cleared.  The chip does not generate interrupt

	 * at this time, but the irq handler may still be called due to irq

	 * sharing or irqpoll.

 do the reset */

 Force PCIe 1.0a mode */

	/* Set the clock to the highest frequency to avoid timeouts. With link

	 * aware mode, the clock speed could be slow and bootcode does not

	 * complete within the expected time. Override the clock to allow the

	 * bootcode to finish sooner and then restore it.

 Manage gphy power for all CPMU absent PCIe devices. */

 restore 5701 hardware bug workaround write method */

	/* Unfortunately, we have to delay before the PCI read back.

	 * Some 575X chips even will not respond to a PCI cfg access

	 * when the reset command is given to the chip.

	 *

	 * How do these hardware designers expect things to work

	 * properly if the PCI write is posted for a long period

	 * of time?  It is always necessary to have some method by

	 * which a register read back can occur to push the write

	 * out which does the reset.

	 *

	 * For most tg3 variants the trick below was working.

	 * Ho hum...

	/* Flush PCI posted writes.  The normal MMIO registers

	 * are inaccessible at this time so this is the only

	 * way to make this reliably (actually, this is no longer

	 * the case, see above).  I tried to use indirect

	 * register read/write but this upset some 5701 variants.

 Wait for link training to complete.  */

 Clear the "no snoop" and "relaxed ordering" bits. */

		/*

		 * Older PCIe devices only support the 128 byte

		 * MPS setting.  Enforce the restriction.

 Clear error status */

		/*

		 * BCM4785: In order to avoid repercussions from using

		 * potentially defective internal ROM, stop the Rx RISC CPU,

		 * which is not required.

	/* Increase the core clock speed to fix tx timeout issue for 5762

	 * with 100Mbps link speed.

 Reprobe ASF enable state.  */

 tp->lock is held. */

 Save the stats across chip resets... */

 And make sure the next sample is new data */

 Skip MAC addr 1 if ASF is using it. */

 tp->lock is held. */

 tp->lock is held. */

 Disable all transmit rings but the first. */

 tp->lock is held. */

 tp->lock is held. */

 Disable all receive return rings but the first. */

 tp->lock is held. */

 tp->lock is held. */

 Disable interrupts */

 Zero mailbox registers. */

 Make sure the NIC-based send BD rings are disabled. */

 Clear status block in ram. */

 Set status block DMA address */

 Clear status block in ram. */

 accept or reject all multicast frames */

	/* When ASF is in use, we always keep the RX_MODE_KEEP_VLAN_TAG

	 * flag clear.

 Promiscuous mode. */

 Accept all multicast. */

 Reject all multicast. */

 Accept one or more multicast(s). */

 Add all entries into to the mac addr filter list */

 Validate table against current IRQ count */

 tp->lock is held. */

 Enable MAC control of LPI */

 Access the lower 1K of PL PCIE block registers. */

 Access the lower 1K of PL PCIE block registers. */

 Fix transmit hangs */

 Access the lower 1K of DL PCIE block registers. */

	/* This works around an issue with Athlon chipsets on

	 * B3 tigon3 silicon.  This bit has no effect on any

	 * other revision.  But do not set this on PCI Express

	 * chips and don't even touch the clocks if the CPMU is present.

		/* Allow reads and writes to the

		 * APE register and memory space.

 Enable some hw fixes.  */

	/* Descriptor ring init may make accesses to the

	 * NIC SRAM area to setup the TX descriptors, so we

	 * can only do this after the hardware has been

	 * successfully reset.

		/* This value is determined during the probe time DMA

		 * engine test, tg3_test_dma.

	/* Pseudo-header checksum is done by hardware logic and not

	 * the offload processers, so make the chip do the pseudo-

	 * header checksums on receive.  For transmit it is more

	 * convenient to do the pseudo-header checksum in software

	 * as Linux does that on transmit for us in all cases.

	/* On one of the AMD platform, MRRS is restricted to 4000 because of

	 * south bridge limitation. As a workaround, Driver is setting MRRS

	 * to 2048 instead of default 4096.

 Setup the timer prescalar register.  Clock is always 66Mhz. */

 Initialize MBUF/DESC pool. */

 Do nothing.  */

	/* Initialize TG3_BDINFO's at:

	 *  RCVDBDI_STD_BD:	standard eth size rx ring

	 *  RCVDBDI_JUMBO_BD:	jumbo frame rx ring

	 *  RCVDBDI_MINI_BD:	small frame rx ring (??? does not work)

	 *

	 * like so:

	 *  TG3_BDINFO_HOST_ADDR:	high/low parts of DMA address of ring

	 *  TG3_BDINFO_MAXLEN_FLAGS:	(rx max buffer size << 16) |

	 *                              ring attribute flags

	 *  TG3_BDINFO_NIC_ADDR:	location of descriptors in nic SRAM

	 *

	 * Standard receive ring @ NIC_SRAM_RX_BUFFER_DESC, 512 entries.

	 * Jumbo receive ring @ NIC_SRAM_RX_JUMBO_BUFFER_DESC, 256 entries.

	 *

	 * The size of each ring is fixed in the firmware, but the location is

	 * configurable.

 Disable the mini ring */

	/* Program the jumbo buffer descriptor ring control

	 * blocks on those devices that have them.

 Initialize MAC address and backoff seed. */

 MTU + ethernet header + FCS + optional VLAN tag */

	/* The slot time is changed by tg3_setup_phy if we

	 * run at gigabit with half duplex.

 Receive rules. */

	/* Calculate RDMAC_MODE setting early, we need it to determine

	 * the RCVLPC_STATE_ENABLE mask.

 Receive/send statistics. */

 Setup host coalescing engine. */

		/* Status/statistics block address.  See tg3_timer,

		 * the tg3_periodic_fetch_stats call there, and

		 * tg3_get_stats to see how this works for 5705/5750 chips.

 Clear statistics and status block memory areas */

 reset to prevent losing 1st rx packet intermittently */

	/* tp->grc_local_ctrl is partially set up during tg3_get_invariants().

	 * If TG3_FLAG_IS_NIC is zero, we should read the

	 * register to preserve the GPIO settings for LOMs. The GPIOs,

	 * whether used as inputs or outputs, are set by boot code after

	 * reset.

 GPIO1 must be driven high for eeprom write protect */

 nothing */

 Enable host coalescing bug fix */

		/* Ignore any errors for the firmware download. If download

		 * fails, the device will operate with EEE disabled

 Set drive transmission level to 1.2V  */

 only if the signal pre-emphasis bit is not set  */

	/* Prevent chip from dropping frames when flow control

	 * is enabled.

 Use hardware link auto-negotiation */

 Clear CRC stats. */

 Initialize receive rules. */

 tw32(MAC_RCV_RULE_3,  0); tw32(MAC_RCV_VALUE_3,  0); */

 tw32(MAC_RCV_RULE_2,  0); tw32(MAC_RCV_VALUE_2,  0); */

 Write our heartbeat update interval to APE. */

/* Called at device open time to get the chip ready for

 * packet processing.  Invoked with tp->lock held.

	/* Chip may have been just powered on. If so, the boot code may still

	 * be running initialization. Wait for it to finish to avoid races in

	 * accessing the hardware.

 sysfs attributes for hwmon */

 CONFIG_TIGON3_HWMON */

 BCM4785: Flush posted writes from GbE to host memory. */

		/* All of this garbage is because when using non-tagged

		 * IRQ status the mailbox/status_block protocol the chip

		 * uses with the cpu is race prone.

 This part only runs once per second. */

	/* Heartbeat is only sent once every 2 seconds.

	 *

	 * The heartbeat is to tell the ASF firmware that the host

	 * driver is still alive.  In the event that the OS crashes,

	 * ASF needs to reset the hardware to free up the FIFO space

	 * that may be filled with rx packets destined for the host.

	 * If the FIFO is full, ASF will no longer function properly.

	 *

	 * Unintended resets have been reported on real time kernels

	 * where the timer doesn't run on time.  Netpoll will also have

	 * same problem.

	 *

	 * The new FWCMD_NICDRV_ALIVE3 command tells the ASF firmware

	 * to check the ring condition when the heartbeat is expiring

	 * before doing the reset.  This will prevent most unintended

	 * resets.

 Update the APE heartbeat every 5 seconds.*/

/* Restart hardware after configuration changes, self-test, etc.

 * Invoked with tp->lock held.

		/* Clear this flag so that tg3_reset_task_cancel() will not

		 * call cancel_work_sync() and wait forever.

	/*

	 * Turn off MSI one shot mode.  Otherwise this test has no

	 * observable way to know whether the interrupt was delivered.

 Reenable MSI one shot mode. */

/* Returns 0 if MSI test succeeds or MSI test fails and INTx mode is

 * successfully restored

	/* Turn off SERR reporting in case MSI terminates with Master

	 * Abort.

 other failures */

 MSI test failed, go back to INTx mode */

	/* Need to reset the chip because the MSI cycle may have terminated

	 * with Master Abort.

	/* Firmware blob starts with version numbers, followed by

	 * start address and _full_ length including BSS sections

	 * (which must be longer than the actual data, of course

 includes bss */

 We no longer need firmware; we have it. */

		/* We want as many rx rings enabled as there are cpus.

		 * In multiqueue MSI-X mode, the first MSI-X vector

		 * only deals with link interrupts, etc, so we add

		 * one to the number of vectors we are requesting.

	/* Disable multiple TX rings by default.  Simple round-robin hardware

	 * scheduling of the TX rings can cause starvation of rings with

	 * small packets when other rings have TSO or jumbo packets.

		/* All MSI supporting chips should support tagged

		 * status.  Assert that this is the case.

	/*

	 * Setup interrupts first so we know how

	 * many NAPI resources to allocate

	/* The placement of this call is tied

	 * to the setup and use of Host TX descriptors.

	/*

	 * Reset loopback feature if it was turned on while the device was down

	 * make sure that it's installed properly now.

 Override clock, link aware and link idle modes */

 adjustments to start on required 4 byte boundary */

 i.e. offset=1 len=2 */

 read bytes up to the last 4 byte boundary */

 read last bytes not ending on 4 byte boundary */

 Restore clock, link aware and link idle modes */

 adjustments to start on required 4 byte boundary */

 adjustments to end on required 4 byte boundary */

 Reset PHY to avoid PHY lock up */

				/* phy_set_asym_pause() will

				 * renegotiate the link to inform our

				 * link partner of our flow control

				 * settings, even if the flow control

				 * is forced.  Let tg3_adjust_link()

				 * do the final flow control setup.

 Reset PHY to avoid PHY lock up */

	/* We require at least one supported parameter to be changed and no

	 * change in any of the unsupported parameters

	/* It is legal to write the indirection

	 * table while the device is running.

 we need a WARN() */

 cycle on/off once per second */

			/* The data is in little-endian format in NVRAM.

			 * Use the big-endian read routines to preserve

			 * the byte order as it exists in NVRAM.

 Selfboot format */

 For rev 2, the csum doesn't include the MBA. */

 Separate the parity bits and the data bytes.  */

 Bootstrap checksum at offset 0x10 */

 Manufacturing block starts at offset 0x74, checksum at 0xfc */

 go on if no checksum found */

 Only test the commonly used registers */

 MAC Control Registers */

 Receive Data and Receive BD Initiator Control Registers. */

 Receive BD Initiator Control Registers. */

 Host Coalescing Control Registers. */

 Buffer Manager Control Registers. */

 Mailbox Registers */

 Save the original register content */

 Determine the read-only value. */

		/* Write zero to the register, then make sure the read-only bits

		 * are not changed and the read/write bits are all zeros.

 Test the read-only and read/write bits. */

		/* Write ones to all the bits defined by RdMask and WrMask, then

		 * make sure the read-only bits are not changed and the

		 * read/write bits are all ones.

 Test the read-only bits. */

 Test the read/write bits. */

 Set the total length field in the IP header */

 Sync BD data before updating mailbox */

 350 usec to allow enough time on some 10/100 Mbps devices.  */

 tg3_free_rings will unmap and free the rx_data */

 Reroute all rx packets to the 1st queue */

	/* HW errata - mac loopback fails in some cases on 5780.

	 * Normal traffic and PHY loopback are not affected by

	 * errata.  Also, the MAC loopback test is deprecated for

	 * all newer ASIC revisions.

 Wait for link */

			/* All link indications report up, but the hardware

			 * isn't really ready for about 20 msec.  Double it

			 * to be sure.

 Re-enable gphy autopowerdown. */

 We have no PHY */

 We have no PHY */

 do nothing */

 Only copy relevant parameters, ignore all others. */

		/* We'll just catch it later when the

		 * device is up'd.

	/* Reset PHY, otherwise the read DMA engine will be in a mode that

	 * breaks all requests to 256 bytes.

	/*

	 * Size the chip by reading offsets at increasing powers of two.

	 * When we encounter our validation signature, we know the addressing

	 * has wrapped around, and thus have our chip size.

 Selfboot format */

			/* This is confusing.  We want to operate on the

			 * 16-bit value at offset 0xf2.  The tg3_nvram_read()

			 * call will read from NVRAM and byteswap the data

			 * according to the byteswapping settings for all

			 * other register accesses.  This ensures the data we

			 * want will always reside in the lower 16-bits.

			 * However, the data in NVRAM is in LE format, which

			 * means the data from the NVRAM read will always be

			 * opposite the endianness of the CPU.  The 16-bit

			 * byteswap then brings the data to CPU endianness.

 NVRAM protection for TPM */

 For eeprom, set pagesize to maximum eeprom size */

 NVRAM protection for TPM */

 NVRAM protection for TPM */

 Detect size with tg3_nvram_get_size() */

 Detect size with tg3_nvram_get_size() */

			/* This pinstrap supports multiple sizes, so force it

			 * to read the actual size from location 0xf0.

 Chips other than 5700/5701 use the NVRAM for fetching info. */

 No NVRAM and EEPROM on the SSB Broadcom GigE core. */

 Enable seeprom accesses. */

 Broadcom boards. */

 3com boards. */

 DELL boards. */

 Compaq boards. */

 IBM boards. */

 Assume an onboard device and WOL capable by default.  */

			/* Default to PHY_1_MODE if 0 (MAC_MODE) is

			 * read on some older 5700/5701 bootcode.

 serdes signal pre-emphasis in register 0x590 set by */

 bootcode if bit 18 is set */

 Wait for up to 1 ms for command to execute. */

/* Read the gphy configuration from the OTP region of the chip.  The gphy

 * configuration is a 32-bit value that straddles the alignment boundary.

 * We do two 32-bit reads and then shift and merge the results.

 flow control autonegotiation is default behavior */

	/* Reading the PHY ID register can conflict with ASF

	 * firmware access to the PHY hardware.

		/* Now read the physical PHY_ID from the chip and verify

		 * that it is sane.  If it doesn't look good, we fall back

		 * to either the hard-coded table based PHY_ID and failing

		 * that the value found in the eeprom area.

			/* Do nothing, phy ID already set up in

			 * tg3_get_eeprom_hw_cfg().

			/* No eeprom signature?  Try the hardcoded

			 * subsys device table.

				/* For now we saw the IDs 0xbc050cd0,

				 * 0xbc050f80 and 0xbc050c30 on devices

				 * connected to an BCM4785 and there are

				 * probably more. Just assume that the phy is

				 * supported when it is connected to a SSB core

				 * for now.

 Use native endian representation */

	/* 5704 can be configured in single-port mode, set peer to

	 * tp->pdev in that case.

	/*

	 * We don't need to keep the refcount elevated; there's no way

	 * to remove one half of this device without removing the other

		/* All devices that use the alternate

		 * ASIC REV location have a CPMU.

	/* Wrong chip ID in 5752 A0. This code can be removed later

	 * as A0 is not in production.

 Intentionally exclude ASIC_REV_5906 */

	/* Force memory write invalidate off.  If we leave it on,

	 * then on 5700_BX chips we have to enable a workaround.

	 * The workaround is to set the TG3PCI_DMA_RW_CTRL boundary

	 * to match the cacheline size.  The Broadcom driver have this

	 * workaround but turns MWI off all the times so never uses

	 * it.  This seems to suggest that the workaround is insufficient.

	/* Important! -- Make sure register accesses are byteswapped

	 * correctly.  Also, for those chips that require it, make

	 * sure that indirect register accesses are enabled before

	 * the first operation.

	/* If we have 5702/03 A1 or A2 on certain ICH chipsets,

	 * we need to disable memory and use config. cycles

	 * only to access all registers. The 5702/03 chips

	 * can mistakenly decode the special cycles from the

	 * ICH chipsets as memory write cycles, causing corruption

	 * of register and memory space. Only certain ICH bridges

	 * will drive special cycles with non-zero data during the

	 * address phase which can fall within the 5703's address

	 * range. This is not an ICH bug as the PCI spec allows

	 * non-zero address during special cycles. However, only

	 * these ICH bridges are known to drive non-zero addresses

	 * during special cycles.

	 *

	 * Since special cycles do not cross PCI bridges, we only

	 * enable this workaround if the 5703 is on the secondary

	 * bus of these ICH bridges.

	/* The EPB bridge inside 5714, 5715, and 5780 cannot support

	 * DMA addresses > 40-bit. This bridge may have other additional

	 * 57xx devices behind it in some 4-port NIC designs for example.

	 * Any tg3 device found behind the bridge will also need the 40-bit

	 * DMA workaround.

 Determine TSO capabilities */

 Do nothing. HW bug. */

 Selectively allow TSO based on operating conditions */

		/* For firmware TSO, assume ASF is disabled.

		 * We'll disable TSO later if we discover ASF

		 * is enabled in tg3_get_eeprom_hw_cfg().

		/* BCM5785 devices are effectively PCIe devices, and should

		 * follow PCIe codepaths, but do not have a PCIe capabilities

		 * section.

	/* If we have an AMD 762 or VIA K8T800 chipset, write

	 * reordering to the mailbox registers done by the host

	 * controller can cause major troubles.  We read back from

	 * every mailbox register write to force the writes to be

	 * posted to the chip in order.

	/* Important! -- It is critical that the PCI-X hw workaround

	 * situation is decided before the first MMIO register access.

		/* 5700 BX chips need to have their TX producer index

		 * mailboxes written twice to workaround a bug.

		/* If we are in PCI-X mode, enable register write workaround.

		 *

		 * The workaround is to use indirect register accesses

		 * for all chip writes not to mailbox registers.

			/* The chip can have it's power management PCI config

			 * space registers clobbered due to this bug.

			 * So explicitly force the chip into D0 here.

 D0 */;

 Also, force SERR#/PERR# in PCI command. */

 Chip-specific fixup from Broadcom driver */

 Default fast path register access methods */

 Various workaround register access methods */

		/*

		 * Back to back register writes can cause problems on these

		 * chips, the workaround is to read back all reg writes

		 * except those to mailbox regs.

		 *

		 * See tg3_write_indirect_reg32().

	/* The memory arbiter has to be enabled in order for SRAM accesses

	 * to succeed.  Normally on powerup the tg3 chip firmware will make

	 * sure it is enabled, but other entities such as system netboot

	 * code might disable it.

	/* Get eeprom hw config before calling tg3_set_power_state().

	 * In particular, the TG3_FLAG_IS_NIC flag must be

	 * determined before calling tg3_set_power_state() so that

	 * we know whether or not to switch out of Vaux power.

	 * When the flag is set, it means that GPIO1 is used for eeprom

	 * write protect and also implies that it is a LOM where GPIOs

	 * are not used to switch power.

		/* Allow reads and writes to the

		 * APE register and memory space.

	/* Set up tp->grc_local_ctrl before calling

	 * tg3_pwrsrc_switch_to_vmain().  GPIO1 driven high

	 * will bring 5700's external PHY out of reset.

	 * It is also used as eeprom write protect on LOMs.

	/* Unused GPIO3 must be driven as output on 5752 because there

	 * are no pull-up resistors on unused GPIO pins.

 Turn off the debug UART. */

 Keep VMain power. */

 Switch out of Vaux if it is a NIC */

	/* Derive initial jumbo mode from MTU assigned in

	 * ether_setup() via the alloc_etherdev() call

 Determine WakeOnLan speed to use. */

 A few boards don't want Ethernet@WireSpeed phy feature */

 Set these bits to enable statistics workaround. */

 Initialize data/descriptor byte/word swapping. */

 Clear this out for sanity. */

 Clear TG3PCI_REG_BASE_ADDR to prevent hangs. */

			/* Write some dummy words into the SRAM status block

			 * area, see if it reads back correctly.  If the return

			 * value is bad, force enable the PCIX workaround.

 If the device has an NVRAM, no need to load patch firmware */

 Preserve the APE MAC_MODE bits */

 ... but do not return immediately ... */

	/* 5700 {AX,BX} chips have a broken status block link

	 * change bit implementation, so we must use the

	 * status register in those cases.

	/* The led_ctrl is set during tg3_phy_probe, here we might

	 * have to force the link status polling mechanism based

	 * upon subsystem IDs.

 For all SERDES we poll the MAC status register. */

	/* Increment the rx prod index on the rx std ring by at most

	 * 8 for these chips to workaround hw errata.

 First try to get it from MAC address mailbox. */

 Some old bootcode may report a 0 MAC address in SRAM */

 Next, try NVRAM. */

 Finally just fetch it out of the MAC control regs. */

	/* On 5703 and later chips, the boundary bits have no

	 * effect.

	/* PCI controllers on most RISC systems tend to disconnect

	 * when a device tries to burst across a cache-line boundary.

	 * Therefore, letting tg3 do so just wastes PCI bandwidth.

	 *

	 * Unfortunately, for PCI-E there are only limited

	 * write-side controls for this, and thus for reads

	 * we will still get the disconnects.  We'll also waste

	 * these PCI cycles for both read and write for chips

	 * other than 5700 and 5701 which do not implement the

	 * boundary bits.

	/*

	 * HP ZX1 was seeing test failures for 5701 cards running at 33Mhz

	 * the *second* time the tg3 driver was getting loaded after an

	 * initial scan.

	 *

	 * Broadcom tells me:

	 *   ...the DMA engine is connected to the GRC block and a DMA

	 *   reset may affect the GRC block in some unpredictable way...

	 *   The behavior of resets to individual blocks has not been tested.

	 *

	 * Broadcom noted the GRC reset will also reset all sub-components.

 DMA read watermark not used on PCIE */

			/* If the 5704 is behind the EPB bridge, we can

			 * do the less restrictive ONE_DMA workaround for

			 * better performance.

 Set bit 23 to enable PCIX hw bug fix */

 5780 always in PCIX mode */

 5714 always in PCIX mode */

 Remove this if it causes problems for some boards. */

		/* On 5700/5701 chips, we need to set this bit.

		 * Otherwise the chip will issue cacheline transactions

		 * to streamable DMA memory with not all the byte

		 * enables turned on.  This is an error on several

		 * RISC PCI controllers, in particular sparc64.

		 *

		 * On 5703/5704 chips, this bit has been reassigned

		 * a different meaning.  In particular, it is used

		 * on those chips to enable a PCI-X workaround.

	/* It is best to perform DMA test with maximum write burst size

	 * to expose the 5700/5701 write DMA bug.

 Send the buffer to the chip. */

 Now read it back. */

 Verify it. */

 Success. */

		/* DMA test passed without adjusting DMA boundary,

		 * now look for chipsets that are known to expose the

		 * DMA bug without failing the test.

 Safe to use the calculated DMA boundary. */

	/* The word/byte swap controls here control register access byte

	 * swapping.  DMA data byte swapping is controlled in the GRC_MODE

	 * setting below.

	/* The NONFRM (non-frame) byte/word swap controls take effect

	 * on descriptor entries, anything which isn't packet data.

	 *

	 * The StrongARM chips on the board (one for tx, one for rx)

	 * are running in big-endian mode.

	/* The EPB bridge inside 5714, 5715, and 5780 and any

	 * device behind the EPB cannot support DMA addresses > 40-bit.

	 * On 64-bit systems with IOMMU, use 40-bit dma_mask.

	 * On 64-bit systems without IOMMU, use 64-bit dma_mask and

	 * do DMA address check in tg3_start_xmit().

 Configure DMA attributes. */

	/* 5700 B0 chips do not support checksumming correctly due

	 * to hardware bugs.

	/* TSO is on by default on chips that support hardware TSO.

	 * Firmware TSO on older chips gives lower performance, so it

	 * is off by default, but can be enabled using ethtool.

	/*

	 * Add loopback capability only for a subset of devices that support

	 * MAC-LOOPBACK. Eventually this need to be enhanced to allow INT-PHY

	 * loopback for the remaining devices.

 Add the loopback capability */

 MTU range: 60 - 9000 or 1500, depending on hardware */

		/*

		 * If we support MSIX, we'll be using RSS.  If we're using

		 * RSS, the first vector only handles link interrupts and the

		 * remaining vectors handle rx and tx interrupts.  Reuse the

		 * mailbox values for the next iteration.  The values we setup

		 * above are still useful for the single vectored mode.

	/*

	 * Reset chip in case UNDI or EFI driver did not shutdown

	 * DMA self test will enable WDMAC and we'll see (spurious)

	 * pending DMA on the PCI bus at that point.

 CONFIG_PM_SLEEP */

/**

 * tg3_io_error_detected - called when PCI error is detected

 * @pdev: Pointer to PCI device

 * @state: The current pci connection state

 *

 * This function is called after a PCI bus error affecting

 * this device has been detected.

 Could be second call or maybe we don't have netdev yet */

 We needn't recover from permanent error */

 Want to make sure that the reset task doesn't run */

 Clean up software state, even if MMIO is blocked */

/**

 * tg3_io_slot_reset - called after the pci bus has been reset.

 * @pdev: Pointer to PCI device

 *

 * Restart the card from scratch, as if from a cold-boot.

 * At this point, the card has exprienced a hard reset,

 * followed by fixups by BIOS, and has its config space

 * set up identically to what it was at cold boot.

/**

 * tg3_io_resume - called when traffic can start flowing again.

 * @pdev: Pointer to PCI device

 *

 * This callback is called when the error recovery driver tells

 * us that its OK to resume normal operation.

/*

 * Driver for (BCM4706)? GBit MAC core on BCMA bus.

 *

 * Copyright (C) 2012 Rafał Miłecki <zajec5@gmail.com>

 *

 * Licensed under the GNU/GPL. See COPYING for details.

/**************************************************

 * PHY ops

bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphywr */

bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphyinit */

	/* For some legacy hardware we do chipset-based PHY initialization here

	 * without even detecting PHY ID. It's hacky and should be cleaned as

	 * soon as someone can test it.

 For all other hw do initialization using PHY subsystem. */

bcm-v4.sipsolutions.net/mac-gbit/gmac/chipphyreset */

/**************************************************

 * MII

/* b44.c: Broadcom 44xx/47xx Fast Ethernet device driver.

 *

 * Copyright (C) 2002 David S. Miller (davem@redhat.com)

 * Copyright (C) 2004 Pekka Pietikainen (pp@ee.oulu.fi)

 * Copyright (C) 2004 Florian Schirmer (jolt@tuxbox.org)

 * Copyright (C) 2006 Felix Fietkau (nbd@openwrt.org)

 * Copyright (C) 2006 Broadcom Corporation.

 * Copyright (C) 2007 Michael Buesch <m@bues.ch>

 * Copyright (C) 2013 Hauke Mehrtens <hauke@hauke-m.de>

 *

 * Distribute under GPL.

/* length of time before we decide the hardware is borked,

 * and dev->tx_timeout() should be called to fix the problem

 hardware minimum and maximum for a single frame's data payload */

 minimum number of free TX descriptors required to wake up TX process */

 b44 internal pattern match filter info */

 -1 == use B44_DEF_MSG_ENABLE as value */

 terminate list with empty entry */

 CONFIG_B44_PCI */

 Flush posted writes. */

 miilib interface */

	/* The driver supports only rx pause by default because

	   the b44 mac tx pause mechanism generates excessive

	   pause frames.

	   Use ethtool to turn on b44 tx pause if necessary.

	/*

	 * workaround for bad hardware design in Linksys WAP54G v1.0

	 * see https://dev.openwrt.org/ticket/146

	 * check and reset bit "isolate"

		/* Since we will not be negotiating there is no safe way

		 * to determine if the link partner supports flow control

		 * or not.  So just disable it completely in this case.

 Link now up */

 Link now down */

 XXX needs updating when NETIF_F_SG is supported */

/* Works like this.  This chip writes a 'struct rx_header" 30 bytes

 * before the DMA address you give it.  So we allocate 30 more bytes

 * for the RX buffer, DMA map all of it, skb_reserve the 30 bytes, then

 * point the chip at 30 bytes past where the rx_header will go.

	/* Hardware bug work-around, the chip is unable to do PCI DMA

 Sigh... */

 Omit CRC. */

 Leave out rx_header */

 DMA sync done above, copy just the actual packet */

 spin_lock(&bp->tx_lock); */

 spin_unlock(&bp->tx_lock); */

 fast recovery, in ~20msec */

 resets ISTAT_RFO */

	/* The interrupt mask register controls which interrupt bits

	 * will actually raise an interrupt to the CPU when set by hw/firmware,

	 * but doesn't mask off the bits.

			/* NOTE: These writes are posted by the readback of

			 *       the ISTAT register below.

 This is a hard error, log it. */

 Chip can't handle DMA to/from >1GB, use bounce buffer */

		/* We'll just catch it later when the

		 * device is up'd.

/* Free up pending packets in all rx/tx rings.

 *

 * The chip has been shut down and the driver detached from

 * the networking, so no interrupts or new tx packets will

 * end up in the driver.  bp->lock is not held and we are not

 * in an interrupt context and thus may sleep.

 XXX needs changes once NETIF_F_SG is set... */

/* Initialize tx/rx rings for packet processing.

 *

 * The chip has been shut down and the driver detached from

 * the networking, so no interrupts or new tx packets will

 * end up in the driver.

/*

 * Must not be invoked with interrupt sources disabled and

 * the hardware shutdown down.

/*

 * Must not be invoked with interrupt sources disabled and

 * the hardware shutdown down.  Can sleep.

		/* Allocation may have failed due to dma_alloc_coherent

		   insisting on use of GFP_DMA, which is more restrictive

		/* Allocation may have failed due to ssb_dma_alloc_consistent

		   insisting on use of GFP_DMA, which is more restrictive

 bp->lock is held. */

 bp->lock is held. */

	/*

	 * Don't enable PHY if we are doing a partial reset

	 * we are probably going to power down

 A device with this bus does not exist. */

 bp->lock is held. */

 reset PHY */

 power down PHY */

	/* now reset the chip, but without enabling the MAC&PHY

 bp->lock is held. */

/* Called at device open time to get the chip ready for

 * packet processing.  Invoked with bp->lock held.

 Enable CRC32, set proper LED modes and power on PHY */

 This sets the MAC address too.  */

 MTU + eth header + possible VLAN tag + struct rx_header */

 XXX magic */

/*

 * Polling receive - used by netconsole and other diagnostic tools

 * to allow network i/o with interrupts disabled.

/* Setup magic packet patterns in the b44 WOL

 * pattern matching filter.

 Ipv4 magic packet pattern - pattern 0.*/

 Raw ethernet II magic packet pattern - pattern 1 */

 Ipv6 magic packet pattern - pattern 2 */

 set these pattern's lengths: one less than each real length */

 enable wakeup pattern matching */

 CONFIG_B44_PCI */

 Convert HW stats into rtnl_link_stats64 stats. */

 Carrier lost counter seems to be broken for some devices */

 A device with this bus does not exist. */

 We do not support gigabit. */

 XXX ethtool lacks a tx_max_pending, oops... */

	/* Some ROMs have buggy PHY addresses with the high

	 * bits set (sign extension?). Truncate them to a

	/* XXX - really required?

	   bp->flags |= B44_FLAG_BUGGY_TXPTR;

 reflect duplex change */

 mask with MAC supported features */

 No interesting netdevice features in this card... */

 By default, advertise all speed/duplex settings. */

 By default, auto-negotiate PAUSE. */

	/* Chip reset provides power to the b44 MAC & PCI cores, which

	 * is necessary for MAC register access.

 do a phy reset to test if there is an active phy */

	/*

	 * As a shared interrupt, the handler can be called immediately. To be

	 * able to check the interrupt status the hardware must already be

	 * powered back on (b44_init_hw).

 Setup paramaters for syncing RX/TX DMA descriptors */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2021 Rafał Miłecki <rafal@milecki.pl>

 in 64 bit words */

 Is it possible to support 2044? */

 32 */

/***

 * R/W ops

/***

 * Helpers

/***

 * DMA ring ops

/***

 * DMA

 Disable the DMA controller and channel */

 Reset channels state */

 We support only 1 main channel (with TX and RX) */

 Reset the DMA channel */

/***

 * Ethernet driver

 Free transmitted skbs */

 Don't use the last empty buf descriptor */

 Hardware removes OWN bit after sending data */

 Provide new buffer before unpinning the old one */

 Hardware could disable ring if it run out of descriptors */

/* bnx2.c: QLogic bnx2 network driver.

 *

 * Copyright (c) 2004-2014 Broadcom Corporation

 * Copyright (c) 2014-2015 QLogic Corporation

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 *

 * Written by: Michael Chan  (mchan@broadcom.com)

 Time in jiffies before concluding the transmitter is hung. */

 indexed by board_t, above */

 Slow EEPROM */

 Expansion entry 0001 */

 Saifun SA25F010 (non-buffered flash) */

 strap, cfg1, & write1 need updates */

 Saifun SA25F020 (non-buffered flash) */

 strap, cfg1, & write1 need updates */

 Expansion entry 0100 */

 Entry 0101: ST M45PE10 (non-buffered flash, TetonII B0) */

 Entry 0110: ST M45PE20 (non-buffered flash)*/

 Saifun SA25F005 (non-buffered flash) */

 strap, cfg1, & write1 need updates */

 Fast EEPROM */

 Expansion entry 1001 */

 Expansion entry 1010 */

 ATMEL AT45DB011B (buffered flash) */

 Expansion entry 1100 */

 Expansion entry 1101 */

 Ateml Expansion entry 1110 */

 ATMEL AT45DB021B (buffered flash) */

	/* The ring uses 256 indices for 255 entries, one of them

	 * needs to be skipped.

 prevent tx timeout */

 Combine status and statistics blocks into one allocation. */

 See Table 28B-3 of 802.3ab-1999 spec. */

 Configure the EMAC mode register. */

 Set the MAC to operate in the appropriate duplex mode. */

 Enable/disable rx PAUSE. */

 Enable/disable tx PAUSE. */

 Acknowledge the interrupt. */

 Force a link down visible on the other side */

 Force a link down visible on the other side */

		/* Speed up link-up time when the link partner

		 * does not autonegotiate which is very common

		 * in blade servers. Some blade servers use

		 * IPMI for kerboard input and it's important

		 * to minimize link disruptions. Autoneg. involves

		 * exchanging base pages plus 3 next pages and

		 * normally completes in about 120 msec.

 Flow ctrl may have changed from auto to forced */

 or vice-versa. */

 advertise nothing when forcing speed */

 Force link down */

		/* Normally, the new speed is setup after the link has

		 * gone down and up again. In some cases, link will not go

		 * down so we need to set up the new speed here.

 increase tx signal amplitude */

 Set extended packet length bit */

 Set extended packet length bit */

 ethernet@wirespeed */

 auto-mdix */

 wait for an acknowledgement. */

 If we timed out, inform the firmware that this is the case. */

 Zero out the context. */

 Allocate a bunch of mbufs and save the good ones in an array. */

 The addresses with Bit 9 set are bad memory blocks. */

	/* Free the good ones back to the mbuf pool thus discarding

 prefetch skb_end_pointer() to speedup skb_shinfo(skb) */

 partial BD completions possible with TSO packets */

	/* Need to make the tx_cons update visible to bnx2_start_xmit()

	 * before checking for netif_tx_queue_stopped().  Without the

	 * memory barrier, there is a small possibility that bnx2_start_xmit()

	 * will miss it and cause the queue to be stopped forever.

	/* The caller was unable to allocate a new page to replace the

	 * last one in the frags array, so we need to recycle that page

	 * and then free the skb.

			/* Don't unmap yet.  If we're unable to allocate a new

			 * page, we need to recycle the page and the DMA addr.

	/* Memory barrier necessary as speculative reads of the rx

	 * buffer can be ahead of the index in the status block

 aligned copy */

 Refresh hw_cons to see if there is new work */

/* MSI ISR - The only difference between this and the INTx ISR

 * is that the MSI interrupt is always serviced.

 Return here if interrupt is disabled. */

 Return here if interrupt is disabled. */

	/* When using INTx, it is possible for the interrupt to arrive

	 * at the CPU before the status block posted prior to the

	 * interrupt. Reading a register will flush the status block.

	 * When using MSI, the MSI message will always complete after

	 * the status block write.

	/* Read back to deassert IRQ immediately to avoid too many

	 * spurious interrupts.

 Return here if interrupt is shared and is disabled. */

		/* This is needed to take care of transient status

		 * during link changes.

 status idx must be read before checking for more work. */

		/* bnapi->last_status_idx is used below to tell the hw how

		 * much work has been processed, so we must read it before

		 * checking for more work.

/* Called with rtnl_lock from vlan functions and also netif_tx_lock

 * from set_multicast.

 Promiscuous mode. */

 Accept one or more multicast(s). */

 Add all entries into to the match filter list */

 Reset the processor, un-stall is done later. */

 Halt the CPU. */

 Load the Text area. */

 Load the Data area. */

 Load the Read-Only area. */

 Clear the pre-fetch instruction. */

 Start the CPU. */

 Initialize the RV2P processor. */

 Initialize the RX Processor. */

 Initialize the TX Processor. */

 Initialize the TX Patch-up Processor. */

 Initialize the Completion Processor. */

 Initialize the Command Processor. */

 Enable port mode. */

 receive all multicast */

 Need to enable EMAC and RPM for WOL. */

		/* Tell firmware not to power down the PHY yet, otherwise

		 * the chip will take a long time to respond to MMIO reads.

			/* Tell firmware not to power down the PHY yet,

			 * otherwise the other port may not respond to

			 * MMIO reads.

		/* No more memory access after this point until

		 * device is brought back to D0.

 Request access to the flash interface. */

 Relinquish nvram interface. */

 Enable both bits, even on read. */

 Disable both bits, even after read. */

 Buffered flash, no erase needed */

 Build an erase command */

 Need to clear DONE bit separately. */

 Address of the NVRAM to read from. */

 Issue an erase command. */

 Wait for completion. */

 Build the command word. */

 Calculate an offset of a buffered flash, not needed for 5709. */

 Need to clear DONE bit separately. */

 Address of the NVRAM to read from. */

 Issue a read command. */

 Wait for completion. */

 Build the command word. */

 Calculate an offset of a buffered flash, not needed for 5709. */

 Need to clear DONE bit separately. */

 Write the data. */

 Address of the NVRAM to write to. */

 Issue the write command. */

 Wait for completion. */

 Determine the selected interface. */

 Flash interface has been reconfigured */

 Not yet been reconfigured */

 Request access to the flash interface. */

 Enable access to flash interface */

 Reconfigure the flash interface */

 Disable access to flash interface */

 if (val & 0x40000000) */

 Request access to the flash interface. */

 Enable access to flash interface */

 Read the first word. */

 Advance to the next dword. */

 Advance to the next dword. */

 Disable access to flash interface */

 Find the page_start addr */

 Find the page_end addr */

 Find the data_start addr */

 Find the data_end addr */

 Request access to the flash interface. */

 Enable access to flash interface */

			/* Read the whole page into the buffer

 Enable writes to flash interface (unlock write-protect) */

		/* Loop to write back the buffer data from page_start to

 Erase the page */

 Re-enable the write again for the actual write */

 Loop to write the new data from data_start to data_end */

		/* Loop to write back the buffer data from data_end

 Disable writes to flash interface (lock write-protect) */

 Disable access to flash interface */

 Increment written */

	/*

	 * Wait for the current PCI transaction to complete before

	 * issuing a reset.

 5709 */

	/* Wait for the current PCI transaction to complete before

 Wait for the firmware to tell us it is ok to issue a reset. */

	/* Deposit a driver reset signature so the firmware knows that

	/* Do a dummy read to force the chip to complete all current transaction

 Chip reset. */

		/* Reading back any register after chip reset will hang the

		 * bus on 5706 A0 and A1.  The msleep below provides plenty

		 * of margin for write posting.

 Reset takes approximate 30 usec */

 Make sure byte swapping is properly configured. */

 Wait for the firmware to finish its initialization. */

		/* Adjust the voltage regular to two steps lower.  The default

 Remove bad rbuf memory from the free pool. */

 Prevent MSIX table reads and write from timing out */

 Make sure the interrupt is not active. */

	/* Initialize context mapping and zero out the quick contexts.  The

 Configure page size. */

 Program the MTU.  Also include 4 bytes for CRC32. */

 Set up how to generate a link change interrupt. */

 3ms */

 Clear internal stats counters. */

 Initialize the receive filter. */

 round to next power of 2 */

 8 for CRC and VLAN */

 hw alignment + build_skb() overhead*/

 This register is not touched during run-time. */

 Determining link for parallel detection. */

 receiving CONFIG */

 workaround occasional corrupted counters */

	/*  Need to flush the previous three writes to ensure MSI-X

 Called with rtnl_lock */

		/* Test MSI to make sure it is working

		 * If MSI test fails, go back to INTx mode

 in case PCI block has reset */

 This allows the netif to be shutdown gracefully before resetting */

/* Called with netif_tx_lock.

 * bnx2_tx_int() runs without netif_tx_lock unless it needs to call

 * netif_wake_queue().

  Determine which tx ring we will be placed on */

 Sync BD data before updating TX mailbox */

		/* netif_tx_stop_queue() must be done before checking

		 * tx index in bnx2_tx_avail() below, because in

		 * bnx2_tx_int(), we update tx index before checking for

		 * netif_tx_queue_stopped().

 save value of frag that failed */

 start back at beginning and unmap skb */

 unmap remaining mapped pages */

 Called with rtnl_lock */

 The 1st 10 counters are 64-bit counters */

 All ethtool functions called with rtnl_lock */

	/* If device is down, we can store the settings only if the user

	 * is setting the currently active port.

	/* If device is down, the new settings will be picked up when it is

	 * brought up.

 Force a link down visible on the other side */

 parameters already validated in ethtool_get_eeprom */

 parameters already validated in ethtool_set_eeprom */

 Reset will erase chipset stats; save them */

 Let cnic know about the new status block. */

/* stat_IfHCInBadOctets and stat_Dot3StatsCarrierSenseErrors are

 * skipped because of errata.

 wait for link up */

 skip this counter */

 4-byte counter */

 8-byte counter */

 cycle on/off once per second */

 TSO with VLAN tag won't work with current firmware */

 Called with rtnl_lock */

 do nothing */

 Called with rtnl_lock */

 Called with rtnl_lock */

 enable device (incl. PCI PM wakeup), and bus-mastering */

	/* Configure byte swap and enable write to the reg_window registers.

	 * Rely on CPU to do target byte swapping on big endian systems

	 * The chip's target access swapping will not swap all accesses

 AER (Advanced Error Reporting) hooks */

 5708 cannot support DMA addresses > 40-bit.  */

 Configure DMA attributes. */

 5706A0 may falsely detect SERR and PERR. */

	/* Get the permanent MAC address.  First we need to make sure the

	 * firmware is actually running.

 allocate stats_blk */

 Disable WOL support if we are running on a SERDES chip. */

			/* Don't do parallel detect on this board because of

			 * some board problems.  The link will not go down

			 * if we do parallel detect.

	/* Disable MSI on 5706 if AMD 8132 bridge is found.

	 *

	 * MSI is defined to be 32-bit write.  The 5706 does 64-bit MSI writes

	 * with byte enables disabled on the unused 32-bit word.  This is legal

	 * but causes problems on the AMD 8132 which will eventually stop

	 * responding after a while.

	 *

	 * AMD believes this incompatibility is unique to the 5706, and

	 * prefers to locally disable MSI rather than globally disabling it.

 dev zeroed in init_etherdev */

	/*

	 * In-flight DMA from 1st kernel could continue going in kdump kernel.

	 * New io-page table has been created before bnx2 does reset at open stage.

	 * We have to wait for the in-flight DMA to complete to avoid it look up

	 * into the newly created io-page table.

 CONFIG_PM_SLEEP */

/**

 * bnx2_io_error_detected - called when PCI error is detected

 * @pdev: Pointer to PCI device

 * @state: The current pci connection state

 *

 * This function is called after a PCI bus error affecting

 * this device has been detected.

 Request a slot slot reset. */

/**

 * bnx2_io_slot_reset - called after the pci bus has been reset.

 * @pdev: Pointer to PCI device

 *

 * Restart the card from scratch, as if from a cold-boot.

/**

 * bnx2_io_resume - called when traffic can start flowing again.

 * @pdev: Pointer to PCI device

 *

 * This callback is called when the error recovery driver tells us that

 * its OK to resume normal operation.

/* cnic.c: QLogic CNIC core network driver.

 *

 * Copyright (c) 2006-2014 Broadcom Corporation

 * Copyright (c) 2014-2015 QLogic Corporation

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 *

 * Original skeleton written by: John(Zongxi) Chen (zongxi@broadcom.com)

 * Previously modified and maintained by: Michael Chan <mchan@broadcom.com>

 * Maintained By: Dept-HSGLinuxNICDev@qlogic.com

 cnic_dev_list modifications are protected by both rtnl and cnic_dev_lock */

 helper function, assuming cnic_lock is held */

 Prevent race conditions with netdev_event */

 Returns -1 if not successful */

 Each entry needs to be in big endian format. */

 Each entry needs to be in little endian format. */

 bnx2 is down */

 init Tstorm RAM */

 init Ustorm RAM */

 init Xstorm RAM */

 init Cstorm RAM */

 TSTORM requires the base address of RQ DB & not PTE */

	/* CSTORM and USTORM initialization is different, CSTORM requires

 bnx2 is down */

			/* Possibly bnx2x parity error, send completion

			 * to ulp drivers with error code to speed up

			 * cleanup and reset recovery.

 bnx2 is down */

			/* Possibly bnx2x parity error, send completion

			 * to ulp drivers with error code to speed up

			 * cleanup and reset recovery.

 bnx2x is down */

 status block index must be read before reading other fields */

 Tell compiler that status_blk fields can change. */

 status block index must be read first */

 status block index must be read before reading the KCQ */

 Tell compiler that sblk fields can change. */

 status block index must be read before reading the KCQ */

	/* Getting here means that we haven't started connect, or

	 * connect was not successful, or it has been reset by the target.

 Wait for remote reset sequence to complete */

 Wait for remote reset sequence to complete */

 Possible PG kcqe status:  SUCCESS, OFFLOADED_PG, or CTX_ALLOC_FAIL */

 after we already sent CLOSE_REQ */

 Unsolicited RESET_COMP or RESET_RECEIVED */

	/* 1. If event opcode matches the expected event in csk->state

	 * 2. If the expected event is CLOSE_COMP or RESET_COMP, we accept any

	 *    event

	 * 3. If the expected event is 0, meaning the connection was never

	 *    never established, we accept the opcode from cm_abort.

 Initialize the kernel work queue context. */

 Initialize the kernel complete queue context. */

	/* Enable Commnad Scheduler notification when we write to the

	/* Enable Command Scheduler notification when we write to either

	 * the Send Queue or Receive Queue producer indexes of the kernel

 Notify COM when the driver post an application buffer. */

	/* Set the CP and COM doorbells.  These two processors polls the

	 * doorbell for a non zero value before running.  This must be done

 clear and set */

 Other ramrod params */

 reset xstorm per client statistics */

 General data */

 Other ramrod params */

 Only 1 EQ */

	/* Read iSCSI config again.  On some bnx2x device, iSCSI config

	 * can change after firmware is downloaded.

		/* Need to wait for the ring shutdown event to complete

		 * before clearing the CNIC_UP flag.

 bnx2x is down */

 netdev event handler */

 Check for the hot-plug device */

 make non-zero */

/*

 * Driver for (BCM4706)? GBit MAC core on BCMA bus.

 *

 * Copyright (C) 2012 Rafał Miłecki <zajec5@gmail.com>

 *

 * Licensed under the GNU/GPL. See COPYING for details.

/**************************************************

 * DMA

	/* Suspend DMA TX ring first.

	 * bgmac_wait_value doesn't support waiting for any of few values, so

	 * implement whole loop here.

 Remove SUSPEND bit */

	/* ring->end - ring->start will return the number of valid slots,

	 * even when ring->end overflows

	/* Increase ring->end to point empty slot. We tell hardware the first

	 * slot it should *not* read.

 Free transmitted packets */

 The last slot that hardware didn't consume yet */

 Unmap no longer used buffer */

 Free memory! :) */

 preserve ONLY bits 16-17 from current hardware value */

 Alloc skb */

 Poison - if everything goes fine, hardware will overwrite it */

 Map skb for the DMA */

 Update the slot */

 Is there any BGMAC device that requires extension? */

	/* ctl1 |= (addrext << B43_DMA64_DCTL1_ADDREXT_SHIFT) &

	 * B43_DMA64_DCTL1_ADDREXT_MASK;

 Prepare new skb as replacement */

 Unmap buffer to make it accessible to the CPU */

 Get info from the header */

 Check for poison and drop or pass the packet */

 Omit CRC. */

 Should never be greater */

 Does ring support unaligned addressing? */

 Free ring of descriptors */

 ring size: different for Tx and Rx */

 Alloc ring of descriptors */

 No need to alloc TX slots yet */

 Alloc ring of descriptors */

 Points the slot that should *not* be read */

/**************************************************

 * Chip ops

/* TODO: can we just drop @force? Can we don't reset MAC at all if there is

 * nothing to change? Try if after stabilizng driver.

 We don't use that regs yet */

 TODO: what else? how to handle BCM4706? Specs are needed */

bcm-v4.sipsolutions.net/mac-gbit/gmac/gmac_speed */

 3GMAC: for BCM4707 & BCM47094, only do core reset at bgmac_probe() */

bcm-v4.sipsolutions.net/mac-gbit/gmac/chipreset */

 bgmac_chip_stats_update(bgmac); */

 TODO: Clear software multicast filter list */

 Request Misc PLL for corerev > 2 */

	/* http://bcm-v4.sipsolutions.net/mac-gbit/gmac/gmac_reset

	 * Specs don't say about using UMAC_CMD_SR, but in this routine

	 * UMAC_CMD is read _after_ putting chip in a reset. So it has to

	 * be keps until taking MAC out of the reset.

bcm-v4.sipsolutions.net/mac-gbit/gmac/gmac_enable */

bcm-v4.sipsolutions.net/mac-gbit/gmac/chipinit */

 Clear any erroneously pending interrupts */

 1 interrupt per received frame */

 Enable 802.3x tx flow control (honor received PAUSE frames) */

 Disable new interrupts until handling existing ones */

 Ack */

 Poll again if more events arrived in the meantime */

/**************************************************

 * net_device_ops

 Specs say about reclaiming rings here, but we do that in DMA init */

 No QOS support yet */

/**************************************************

 * ethtool_ops

/**************************************************

 * MII

 Allocation and references */

	/* This (reset &) enable is not preset in specs or reference driver but

	 * Broadcom does it in arch PCI code when enabling fake PCI device.

 This seems to be fixing IRQ by assigning OOB #6 to the core */

 Omit FCS from max MTU size */

/*

 * Driver for (BCM4706)? GBit MAC core on BCMA bus.

 *

 * Copyright (C) 2012 Rafał Miłecki <zajec5@gmail.com>

 *

 * Licensed under the GNU/GPL. See COPYING for details.

/**************************************************

 * BCMA bus ops

 DT info should be the most accurate */

 Connect to the PHY */

 Assume a fixed link to the switch port */

bcm-v4.sipsolutions.net/mac-gbit/gmac/chipattach */

 If no MAC address assigned via device tree, check SPROM */

 On BCM4706 we need common core to access PHY */

 Feature Flags */

 BCM 471X/535X family */

 bcm4707_family */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Driver for BCM963xx builtin Ethernet mac

 *

 * Copyright (C) 2008 Maxime Bizon <mbizon@freebox.fr>

 io registers memory shared between all devices */

/*

 * io helpers to access mac registers

/*

 * io helpers to access switch registers

 io helpers to access shared registers */

/*

 * write given data into mii register and wait for transfer to end

 * with timeout (average measured transfer time is 25us)

 make sure mii interrupt status is cleared */

 busy wait on mii interrupt bit, with timeout */

/*

 * MII internal read callback

/*

 * MII internal write callback

/*

 * MII read callback from phylib

/*

 * MII write callback from phylib

/*

 * MII read callback from mii core

/*

 * MII write callback from mii core

/*

 * refill rx queue

 tell dma engine we allocated one buffer */

	/* If rx ring is still empty, set a timer to try allocating

/*

 * timer callback to defer refill rx queue in case we're OOM

/*

 * extract packet from rx queue

	/* don't scan ring further than number of refilled

		/* make sure we actually read the descriptor status at

 break if dma ownership belongs to hw */

		/* if the packet does not have start of packet _and_

 recycle packet if it's marked as bad */

 valid packet */

 don't include FCS */

 forget packet, just rearm desc */

 kick rx dma */

/*

 * try to or force reclaim of transmitted buffers

		/* We run in a bh and fight against start_xmit, which

		/* ensure other field of the descriptor were not read

/*

 * poll func, called by network core

 ack interrupts */

 reclaim sent skb */

 rx queue is not yet empty/clean */

	/* no more packet in rx/tx queue, remove device from poll

 restore rx/tx interrupt */

/*

 * mac interrupt handler

 clear & mask interrupt */

 read mib registers in workqueue */

/*

 * rx/tx dma interrupt handler

 mask rx/tx interrupts */

/*

 * tx request callback

 lock against tx reclaim */

	/* make sure  the tx hw queue  is not full,  should not happen

 pad small packets sent on a switch device */

 point to the next available desc */

 fill descriptor */

	/* dma might be already polling, make sure we update desc

 kick tx dma */

 stop queue if no more desc available */

/*

 * Change the interface's mac address.

 use perfect match register 0 to store my mac address */

/*

 * Change rx mode (promiscuous/allmulti) and update multicast list

	/* only 3 perfect match registers left, first one is used for

	/* no need to set perfect match registers if we catch all

 update perfect match registers */

/*

 * set mac duplex parameters

/*

 * set mac flow control parameters

 rx flow control (pause frame handling) */

 tx flow control (pause frame generation) */

/*

 * link changed callback (from phylib)

 reflect duplex change in mac configuration */

	/* enable flow control if remote advertise it (trust phylib to

 pause was advertised by lpa and us */

 pause setting overridden by user */

/*

 * link changed callback (if phylib is not used)

/*

 * open callback, allocate dma rings & buffers and start rx operation

 connect to PHY */

 mask with MAC supported features */

 mask all interrupts and request them */

 initialize perfect match registers */

 write device mac address */

 allocate rx dma ring */

 allocate tx dma ring */

 init & fill rx ring with buffers */

 initialize flow control buffer allocation */

 write rx & tx ring addresses */

 clear remaining state ram for rx & tx channel */

 set max rx/tx length */

 set dma maximum burst len */

 set correct transmit fifo watermark */

 set flow control low/high threshold to 1/3 / 2/3 */

	/* all set, enable mac and interrupts, start dma engine and

 watch "mib counters about to overflow" interrupt */

 watch "packet transferred" interrupt in rx and tx */

 make sure we enable napi before rx interrupt  */

/*

 * disable mac

/*

 * disable dma in given channel

/*

 * stop callback

 mask all interrupts */

 make sure no mib update is scheduled */

 disable dma & mac */

 force reclaim of all tx buffers */

 free the rx buffer ring */

 free remaining allocated memory */

 release phy */

 reset BQL after forced tx reclaim to prevent kernel panic */

/*

 * ethtool callbacks

	/* also empty unused mib counters to make sure mib counter

 reenable mib interrupt */

 rx/tx ring is actually only limited by memory */

			/* asymetric pause mode not supported,

			 * actually possible but integrated PHY has RO

 no pause autoneg on direct mii connection */

/*

 * adjust mtu, can't be called while device is running

 add ethernet header + vlan tag size */

	/*

	 * setup maximum size before we get overflow mark in

	 * descriptor, note that this will not prevent reception of

	 * big frames, they will be split into multiple buffers

	 * anyway

	/*

	 * align rx buffer size to dma burst len, account FCS since

	 * it's appended

/*

 * preinit hardware to allow mii operation while device is down

 make sure mac is disabled */

 soft reset mac */

 select correct mii interface */

 turn on mdc clock */

 set mib counters to self-clear when read */

/*

 * allocate netdevice, request register memory and register device.

 initialize default and fetch platform data */

 using internal PHY, enable clock */

 do minimal hardware init to be able to probe mii bus */

 MII bus registration */

		/* only probe bus where we think the PHY is, because

		 * the mdio read operation return 0 instead of 0xffff

 run platform code to initialize PHY device */

 init rx timeout (used for oom) */

 init the mib update lock&work */

 zero mib counters */

 register netdevice */

 MTU range: 46 - 2028 */

 turn off mdc clock */

/*

 * exit func, stops hardware and unregisters netdevice

 stop netdevice */

 turn off mdc clock */

 disable hw block clocks */

/*

 * switch mii access callbacks

/*

 * enet sw PHY polling

 dummy read to clear */

 link changed */

 figure out media and duplex from advertise and LPA values */

/*

 * open callback, allocate dma rings & buffers and start rx operation

 mask all interrupts and request them */

 allocate rx dma ring */

 allocate tx dma ring */

 init & fill rx ring with buffers */

 disable all ports */

 reset mib */

 force CPU port state */

 enable switch forward engine */

 enable jumbo on all ports */

 initialize flow control buffer allocation */

 write rx & tx ring addresses */

 clear remaining state ram for rx & tx channel */

 set dma maximum burst len */

 set flow control low/high threshold to 1/3 / 2/3 */

	/* all set, enable mac and interrupts, start dma engine and

	 * kick rx dma channel

 watch "packet transferred" interrupt in rx and tx */

 make sure we enable napi before rx interrupt  */

 apply override config for bypass_link ports here. */

 start phy polling timer */

 stop callback */

 mask all interrupts */

 disable dma & mac */

 force reclaim of all tx buffers */

 free the rx buffer ring */

 free remaining allocated memory */

 reset BQL after forced tx reclaim to prevent kernel panic */

/* try to sort out phy external status by walking the used_port field

 * in the bcm_enet_priv structure. in case the phy address is not

 * assigned to any physical port on the switch, assume it is external

 * (and yell at the user).

/* can't use bcmenet_sw_mdio_read directly as we need to sort out

 * external/internal status of the given phy_id first.

/* can't use bcmenet_sw_mdio_write directly as we need to sort out

 * external/internal status of the given phy_id first.

 rx/tx ring is actually only limited by memory */

 allocate netdevice, request register memory and register device. */

 initialize default and fetch platform data */

 init rx timeout (used for oom) */

 register netdevice */

 exit func, stops hardware and unregisters netdevice */

 stop netdevice */

 reserve & remap memory space shared between all macs */

/* this "shared" driver is needed because both macs share a single

 * address space

 entry point */

/* Broadcom NetXtreme-C/E network driver.

 *

 * Copyright (c) 2016-2018 Broadcom Limited

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 don't care */);

 Read max_async_event_id first before testing the bitmap. */

 Make sure bnxt_ulp_async_events() sees this order */

/* Broadcom NetXtreme-C/E network driver.

 *

 * Copyright (c) 2014-2016 Broadcom Corporation

 * Copyright (c) 2016-2018 Broadcom Limited

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 broadcast this async event to all VFs */

	/*TODO: if the driver supports VLAN filter on guest VLAN,

	 * the spoof check should also include vlan anti-spoofing

	/* reject bc or mc mac addr, zero mac addr means allow

	 * VF to use its own mac addr

	/* TODO: needed to implement proper handling of user priority,

	 * currently fail the command if there is valid priority

 Max 128 VF's */

/* Only called by PF to reserve resources for VFs, returns actual number of

 * VFs configured, or < 0 on error.

/* Only called by PF to reserve resources for VFs, returns actual number of

 * VFs configured, or < 0 on error.

 Remaining rings are distributed equally amongs VF's for now */

 FIXME spec currently uses 1 bit for stats ctx */

 Register buffers for VFs */

 Reserve resources for VFs */

	/* Check if we can enable requested num of vf's. At a mininum

	 * we require 1 RX 1 TX rings for each VF. In this minimum conf

	 * features like TPA will not be available.

 Free the resources reserved for various VF's */

 synchronize VF and VF-rep create and destroy */

 Free the HW resources reserved for various VF's */

 Reclaim all resources for the PF. */

 Check if enabled VFs is same as requested */

 if there are previous existing VFs, clean them up */

 Set the new target id */

 Set the new target id */

 Set the new target id */

	/* Allow VF to set a valid MAC address, if trust is set to on or

	 * if the PF assigned MAC address is zero

	/* Allow VF to set a valid MAC address, if trust is set to on.

	 * Or VF MAC address must first match MAC address in PF's context.

	 * Otherwise, it must match the VF MAC address if firmware spec >=

	 * 1.2.2

		/* There are two cases:

		 * 1.If firmware spec < 0x10202,VF MAC address is not forwarded

		 *   to the PF and so it doesn't have to match

		 * 2.Allow VF to modify it's own MAC when PF has not assigned a

		 *   valid MAC address and firmware spec >= 0x10202

 real link */

 if physical link is down, force link up on VF */

 force link down */

		/* TODO Validate if VF is allowed to change mac address,

		 * mtu, num of rings etc

 Scan through VF's and process commands */

	/* Store MAC address from the firmware.  There are 2 cases:

	 * 1. MAC address is valid.  It is assigned from the PF and we

	 *    need to override the current VF MAC address with it.

	 * 2. MAC address is zero.  The VF will use a random MAC address by

	 *    default but the stored zero MAC will allow the VF user to change

	 *    the random MAC address using ndo_set_mac_address() if he wants.

		/* This means we are now using our own MAC address, let

		 * the PF know about this MAC address.

 overwrite netdev dev_addr with admin VF MAC */

/* Broadcom NetXtreme-C/E network driver.

 *

 * Copyright (c) 2014-2016 Broadcom Corporation

 * Copyright (c) 2016-2019 Broadcom Limited

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 indexed by enum board_idx */

	/* netif_tx_stop_queue() must be done before checking

	 * tx index in bnxt_tx_avail() below, because in

	 * bnxt_tx_int(), we update tx index before checking for

	 * netif_tx_queue_stopped().

 We must have raced with NAPI cleanup */

		/* Currently supports 8021Q, 8021AD vlan offloads

		 * QINQ1, QINQ2, QINQ3 vlan headers are deprecated

 Set COAL_NOW to be ready quickly for the next push */

 Sync is_push and byte queue before pushing data */

 SKB already freed. */

 Sync BD data before updating doorbell */

 start back at beginning and unmap skb */

 unmap remaining mapped pages */

	/* Need to make the tx_cons update visible to bnxt_start_xmit()

	 * before checking for netif_tx_queue_stopped().  Without the

	 * memory barrier, there is a small possibility that bnxt_start_xmit()

	 * will miss it and cause the queue to be stopped forever.

		/* It is possible for sw_prod to be equal to cons, so

		 * set cons_rx_buf->page to NULL first.

		/* It is possible for bnxt_alloc_rx_page() to allocate

		 * a sw_prod index that equals the cons index, so we

		 * need to clear the cons entry now.

			/* Update prod since possibly some pages have been

			 * allocated already.

	/* Store cfa_code in tpa_info to use in tpa_end

	 * completion processing.

 RSS profiles 1 and 3 with extract code 0 for inner 4-tuple */

	/* If the packet is an internal loopback packet, the offsets will

	 * have an extra 4 bytes.

		/* We only support inner iPv4/ipv6.  If we don't see the

		 * correct protocol ID, it must be a loopback packet where

		 * the offsets are off by 4.

 internal loopback packet, subtract all offsets by 4 */

 tunnel */

 tunnel */

 tunnel */

/* Given the cfa_code of a received packet determine which

 * netdev (vf-rep or PF) the packet is destined to.

 if vf-rep dev is NULL, the must belongs to the PF */

 Page reuse already handled by bnxt_rx_pages(). */

 this packet belongs to a vf-rep */

/* returns the following:

 * 1       - 1 packet successfully received

 * 0       - successful TPA_START, packet not completed yet

 * -EBUSY  - completion ring does not have all the agg buffers yet

 * -ENOMEM - packet aborted due to out of memory

 * -EIO    - packet aborted due to hw error indicated in BD

	/* The valid test of the entry must be done first before

	 * reading any further.

 0xffff is forced error, don't print it */

 RSS profiles 1 and 3 with extract code 0 for inner 4-tuple */

/* In netpoll mode, if we are using a combined completion ring, we need to

 * discard the rx packets and recycle the buffers.

	/* The valid test of the entry must be done first before

	 * reading any further.

 TODO CHIMP_FW: Define event id's for link change, error etc */

 print unsupported speed warning in forced speed mode only */

			/* Make sure tmr_counter is set and visible to

			 * bnxt_health_check() before setting enabled to true.

 return if erroneous interrupt */

 disable ring IRQ */

 Return here if interrupt is shared and is disabled. */

		/* The valid test of the entry must be done first before

		 * reading any further.

 return full budget so NAPI will complete. */

			/* Increment rx_pkts when rc is -ENOMEM to count towards

			 * the NAPI budget.  Otherwise, we may potentially loop

			 * here forever if we consistently cannot allocate

			 * buffers.

 partial completion */

 Sync BD data before updating doorbell */

	/* ACK completion ring before freeing tx ring and producing new

	 * buffers in rx/agg rings to prevent overflowing the completion

	 * ring.

		/* The valid test of the entry must be done first before

		 * reading any further.

 force an error to recycle the buffer */

 partial completion */

		/* The valid test of the entry must be done first before

		 * reading any further.

			/* One pre-allocated DMA buffer to backup

			 * TX push operation

/* bp->rx_ring_size, bp->tx_ring_size, dev->mtu, BNXT_FLAG_{G|L}RO flags must

 * be set on entry.

 8 for CRC and VLAN */

	/* MAX TPA needs to be added because TPA_START completions are

	 * immediately recycled, so the TPA completions are not bound by

	 * the RX ring size.

 RX and TPA completions are 32-byte, all others are 16-byte */

/* Changing allocation mode of RX rings.

 * TODO: Update when extending xdp_rxq_info to support allocation modes.

 Disable LRO or GRO_HW */

 Allocate rss table and hash key */

 Display extended statistics only if FW supports it */

 Extended stats are optional */

 Extended stats are optional */

	/* Under rtnl_lock and all our NAPIs have been disabled.  It's

	 * safe to delete the hash table.

		/* Allocate bnapi mem pointer array and mem block for

		 * all queues

 only vnic 0 supported */

 Any associated ntuple filters will also be cleared by firmware. */

		/* Number of segs are log2 units, and first packet is not

		 * included as part of this units.

 Fill the RSS indirection table with ring group ids */

 thresholds not implemented in firmware yet */

 Only RSS support for now TBD: COS & LB */

 map ring groups to this vnic */

		/* Older P5 fw before EXT_HW_STATS support did not set

		 * VLAN_STRIP_CAP properly.

 Page size is in log2 units */

 Association of ring index with doorbell index and MSIX number */

 Association of transmit ring with completion ring */

 Association of rx ring with stats context */

 Association of agg ring with rx ring */

 Association of cp ring with nq */

 If we have agg rings, post agg buffers first. */

	/* The completion rings are about to be freed.  After that the

	 * IRQ doorbell will not work anymore.  So we need to disable

	 * IRQ here.

/* Check if a default RSS map needs to be setup.  This function is only

 * used on older firmware that does not require reserving RX rings.

 The RSS map is valid for RX rings set to resv_rx_rings */

	/* Old firmware does not need RX ring reservations but we still

	 * need to setup a default RSS map when needed.  With new firmware

	 * we go through RX ring reservations first and then set up the

	 * RSS map for the successfully reserved RX rings when needed.

	/* If we cannot reserve all the RX rings, reset the RSS map only

	 * if absolutely necessary

 min timer set to 1/2 of interrupt timer */

 buf timer set to 1/4 of interrupt timer */

	/* Tick values in micro seconds.

	 * 1 coal_buf x bufs_per_record = 1 completion record.

	/* 128K extra is needed to accommodate static AH context

	 * allocation by f/w.

 Only pre-map the monitoring GRC registers using window 3 */

 Chip bug.  Counter intermittently becomes 0. */

 Per port queue IDs start from 0, 10, 20, etc */

 clear all RSS setting before free vnic ctx */

 before free the vnic, undo the vnic tpa settings */

 allocate context for vnic */

 configure default vnic, ring grp */

 Enable RSS hashing on vnic */

 Allow PF, trusted VFs and VFs with default VLAN to be in promiscuous mode */

 default vnic 0 */

 Filter for default vnic 0 */

 Trim rings based upon num of vectors allocated */

 fallback to INTA */

	/* We called __netif_napi_del(), we need

	 * to respect an RCU grace period before freeing napi structures.

 Make sure napi polls see @dev_state change */

 Drop carrier first to prevent TX timeout */

 Stop all TX queues */

 Make sure napi polls see @dev_state change */

 Phy re-enabled, reprobe the speeds */

 Pull initial EEE config */

 TODO: need to add more logic to report VF link */

 alwasy link down if not require to update link state */

	/* Check if any advertised speeds are no longer supported. The caller

	 * holds the link_lock mutex, so we can modify link_info settings.

 tell chimp that the setting takes effect immediately */

		/* since changing of pause setting doesn't trigger any link

		 * change event, the driver needs to update the current pause

		 * result upon successfully return of the phy_cfg command

 no resource reservations required */

 display millidegree */

	/* The last close may have shutdown the link, so need to call

	 * PHY_CFG to bring it back up.

/* Common routine to pre-map certain register block to different GRC window.

 * A PF has 16 4K windows and a VF has 4 4K windows. However, only 15 windows

 * in PF and 3 windows in VF that can be customized to map in different

 * register blocks.

 CAG registers map to GRC window #4 */

 Reserve rings now if none were reserved at driver probe. */

 disable RFS if falling back to INTA */

 Enable TX queues */

 Poll link status and check for SFP+ module status */

 VF-reps may need to be re-opened after the PF is re-opened */

 rtnl_lock held */

/* rtnl_lock held, open the NIC half way by allocating all resources, but

 * NAPI, IRQ, and TX are not enabled.  This is mainly used for offline

 * self tests.

/* rtnl_lock held, this call can only be made after a previous successful

 * call to bnxt_half_open_nic().

 Close the VF-reps before closing PF */

 Change device state to avoid TX queue wake up's */

 Flush rings and and disable interrupts */

 TODO CHIMP_FW: Link/PHY related cleanup if (link_re_init) */

 Save ring stats before shutdown */

		/* If we get here, it means firmware reset is in progress

		 * while we are trying to close.  We can safely proceed with

		 * the close because we are holding rtnl_lock().  Some firmware

		 * messages may fail as we proceed to close.  We set the

		 * ABORT_ERR flag here so that the FW reset thread will later

		 * abort when it gets the rtnl_lock() and sees the flag.

 rtnl_lock held */

 do nothing */

	/* Make sure bnxt_close_nic() sees that we are reading stats before

	 * we check the BNXT_STATE_OPEN flag.

		/* No minimum rings were provisioned by the PF.  Don't

		 * reserve rings by default when device is down.

 If the chip and firmware supports RFS */

 212 firmware is broken for aRFS */

 If runtime conditions support RFS */

 RSS contexts not a limiting factor */

	/* Both CTAG and STAG VLAN accelaration on the RX side have to be

	 * turned on or off together.

	/* Check that there are at most 2 IPv6 extension headers, no

	 * fragment header, and each is <= 64 bytes.

 Caller will check inner protocol */

 Only support TCP/UDP for non-tunneled ipv6 and inner ipv6 */

 For UDP, we can only handle 1 Vxlan port and 1 Geneve port. */

 Check ext headers of inner ipv6 */

 Make sure it is enabled before checking the tmr_counter. */

CONFIG_RFS_ACCEL*/

	/* We are called from bnxt_sp_task which has BNXT_STATE_IN_SP_TASK

	 * set.  If the device is being closed, bnxt_close() may be holding

	 * rtnl() and waiting for BNXT_STATE_IN_SP_TASK to clear.  So we

	 * must clear BNXT_STATE_IN_SP_TASK before holding rtnl().

 Only called from bnxt_sp_task() */

 Only called from bnxt_sp_task() */

 Disable and flush TPA before resetting the RX ring */

	/* When firmware is in fatal state, quiesce device and disable

	 * bus master to prevent any potential bad DMAs before freeing

	 * kernel memory.

 rtnl_lock is acquired before calling this function */

/* Returns the number of registered VFs, or 1 if VF configuration is pending, or

 * < 0 on error.

	/* These functions below will clear BNXT_STATE_IN_SP_TASK.  They

	 * must be the last functions to be called before exiting.

 Under rtnl_lock */

	/* Tick values in micro seconds.

	 * 1 coal_buf x bufs_per_record = 1 completion record.

 NAPI budget */

 Get the MAX capabilities for this function */

	/* In case fw capabilities have changed, destroy the unneeded

	 * reporters and create newly capable ones.

 firmware will enforce if unknown */

 Make sure fw_reset_state is 0 before clearing the flag */

 enable device (incl. PCI PM wakeup), and bus-mastering */

	/* Doorbell BAR bp->bar1 is mapped after bnxt_fw_init_one_p2()

	 * determines the BAR size.

 rtnl_lock held */

 rtnl_lock held */

 Needs to close the device and do hw resource re-allocations */

 CONFIG_RFS_ACCEL */

 The PF and it's VF-reps only support the switchdev framework */

 Flush any pending tasks */

	/* Older firmware does not have supported_auto_speeds, so assume

	 * that all supported speeds can be autonegotiated.

 On P5 chips, max_cp output param should be available NQs */

 Not enough rings, try disabling agg rings. */

 set BNXT_FLAG_AGG_RINGS back for consistency */

 Reserve minimum resources for RoCE */

/* In initial default shared ring setting, each shared ring must have a

 * RX/TX ring pair.

	/* Reduce default rings on multi-port cards so that total default

	 * rings do not exceed CPU count.

 Rings may have been trimmed, re-reserve the trimmed rings. */

 overwrite netdev dev_addr with admin VF MAC */

			/* Older PF driver or firmware may not approve this

			 * correctly.

	/* Clear any pending DMA transactions from crash kernel

	 * while loading driver in capture kernel.

 Read the adapter's DSN to use as the eswitch switch_id */

 MTU range: 60 - FW defined max */

	/* No TC has been set yet and rings may have been trimmed due to

	 * limited MSIX, so we re-initialize the TX rings per TC.

 CONFIG_PM_SLEEP */

/**

 * bnxt_io_error_detected - called when PCI error is detected

 * @pdev: Pointer to PCI device

 * @state: The current pci connection state

 *

 * This function is called after a PCI bus error affecting

 * this device has been detected.

 Request a slot slot reset. */

/**

 * bnxt_io_slot_reset - called after the pci bus has been reset.

 * @pdev: Pointer to PCI device

 *

 * Restart the card from scratch, as if from a cold-boot.

 * At this point, the card has exprienced a hard reset,

 * followed by fixups by BIOS, and has its config space

 * set up identically to what it was at cold boot.

		/* Upon fatal error, our device internal logic that latches to

		 * BAR value is getting reset and will restore only upon

		 * rewritting the BARs.

		 *

		 * As pci_restore_state() does not re-write the BARs if the

		 * value is same as saved value earlier, driver needs to

		 * write the BARs to 0 to force restore, in case of fatal error.

/**

 * bnxt_io_resume - called when traffic can start flowing again.

 * @pdev: Pointer to PCI device

 *

 * This callback is called when the error recovery driver tells

 * us that its OK to resume normal operation.

/* Broadcom NetXtreme-C/E network driver.

 *

 * Copyright (c) 2017-2018 Broadcom Limited

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

/* Broadcom NetXtreme-C/E network driver.

 *

 * Copyright (c) 2020 Broadcom Limited

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

/**

 * __hwrm_req_init() - Initialize an HWRM request.

 * @bp: The driver context.

 * @req: A pointer to the request pointer to initialize.

 * @req_type: The request type. This will be converted to the little endian

 *	before being written to the req_type field of the returned request.

 * @req_len: The length of the request to be allocated.

 *

 * Allocate DMA resources and initialize a new HWRM request object of the

 * given type. The response address field in the request is configured with

 * the DMA bus address that has been mapped for the response and the passed

 * request is pointed to kernel virtual memory mapped for the request (such

 * that short_input indirection can be accomplished without copying). The

 * request’s target and completion ring are initialized to default values and

 * can be overridden by writing to the returned request object directly.

 *

 * The initialized request can be further customized by writing to its fields

 * directly, taking care to covert such fields to little endian. The request

 * object will be consumed (and all its associated resources release) upon

 * passing it to hwrm_req_send() unless ownership of the request has been

 * claimed by the caller via a call to hwrm_req_hold(). If the request is not

 * consumed, either because it is never sent or because ownership has been

 * claimed, then it must be released by a call to hwrm_req_drop().

 *

 * Return: zero on success, negative error code otherwise:

 *	E2BIG: the type of request pointer is too large to fit.

 *	ENOMEM: an allocation failure occurred.

 safety first, sentinel used to check for invalid requests */

 __GFP_ZERO, but be explicit regarding ownership */

 initialize common request fields */

 can only be due to software bug, be loud */

 HWRM API has no type safety, verify sentinel to validate address */

 can only be due to software bug, be loud */

/**

 * hwrm_req_timeout() - Set the completion timeout for the request.

 * @bp: The driver context.

 * @req: The request to set the timeout.

 * @timeout: The timeout in milliseconds.

 *

 * Set the timeout associated with the request for subsequent calls to

 * hwrm_req_send(). Some requests are long running and require a different

 * timeout than the default.

/**

 * hwrm_req_alloc_flags() - Sets GFP allocation flags for slices.

 * @bp: The driver context.

 * @req: The request for which calls to hwrm_req_dma_slice() will have altered

 *	allocation flags.

 * @gfp: A bitmask of GFP flags. These flags are passed to dma_alloc_coherent()

 *	whenever it is used to allocate backing memory for slices. Note that

 *	calls to hwrm_req_dma_slice() will not always result in new allocations,

 *	however, memory suballocated from the request buffer is already

 *	__GFP_ZERO.

 *

 * Sets the GFP allocation flags associated with the request for subsequent

 * calls to hwrm_req_dma_slice(). This can be useful for specifying __GFP_ZERO

 * for slice allocations.

/**

 * hwrm_req_replace() - Replace request data.

 * @bp: The driver context.

 * @req: The request to modify. A call to hwrm_req_replace() is conceptually

 *	an assignment of new_req to req. Subsequent calls to HWRM API functions,

 *	such as hwrm_req_send(), should thus use req and not new_req (in fact,

 *	calls to HWRM API functions will fail if non-managed request objects

 *	are passed).

 * @len: The length of new_req.

 * @new_req: The pre-built request to copy or reference.

 *

 * Replaces the request data in req with that of new_req. This is useful in

 * scenarios where a request object has already been constructed by a third

 * party prior to creating a resource managed request using hwrm_req_init().

 * Depending on the length, hwrm_req_replace() will either copy the new

 * request data into the DMA memory allocated for req, or it will simply

 * reference the new request and use it in lieu of req during subsequent

 * calls to hwrm_req_send(). The resource management is associated with

 * req and is independent of and does not apply to new_req. The caller must

 * ensure that the lifetime of new_req is least as long as req. Any slices

 * that may have been associated with the original request are released.

 *

 * Return: zero on success, negative error code otherwise:

 *     E2BIG: Request is too large.

 *     EINVAL: Invalid request to modify.

 free any existing slices */

 update sentinel for potentially new request type */

/**

 * hwrm_req_flags() - Set non internal flags of the ctx

 * @bp: The driver context.

 * @req: The request containing the HWRM command

 * @flags: ctx flags that don't have BNXT_HWRM_INTERNAL_FLAG set

 *

 * ctx flags can be used by the callers to instruct how the subsequent

 * hwrm_req_send() should behave. Example: callers can use hwrm_req_flags

 * with BNXT_HWRM_CTX_SILENT to omit kernel prints of errors of hwrm_req_send()

 * or with BNXT_HWRM_FULL_WAIT enforce hwrm_req_send() to wait for full timeout

 * even if FW is not responding.

 * This generic function can be used to set any flag that is not an internal flag

 * of the HWRM module.

/**

 * hwrm_req_hold() - Claim ownership of the request's resources.

 * @bp: The driver context.

 * @req: A pointer to the request to own. The request will no longer be

 *	consumed by calls to hwrm_req_send().

 *

 * Take ownership of the request. Ownership places responsibility on the

 * caller to free the resources associated with the request via a call to

 * hwrm_req_drop(). The caller taking ownership implies that a subsequent

 * call to hwrm_req_send() will not consume the request (ie. sending will

 * not free the associated resources if the request is owned by the caller).

 * Taking ownership returns a reference to the response. Retaining and

 * accessing the response data is the most common reason to take ownership

 * of the request. Ownership can also be acquired in order to reuse the same

 * request object across multiple invocations of hwrm_req_send().

 *

 * Return: A pointer to the response object.

 *

 * The resources associated with the response will remain available to the

 * caller until ownership of the request is relinquished via a call to

 * hwrm_req_drop(). It is not possible for hwrm_req_hold() to return NULL if

 * a valid request is provided. A returned NULL value would imply a driver

 * bug and the implementation will complain loudly in the logs to aid in

 * detection. It should not be necessary to check the result for NULL.

 can only be due to software bug, be loud */

 save before invalidate */

 unmap any auxiliary DMA slice */

 invalidate, ensure ownership, sentinel and dma_handle are cleared */

 return the buffer to the DMA pool */

/**

 * hwrm_req_drop() - Release all resources associated with the request.

 * @bp: The driver context.

 * @req: The request to consume, releasing the associated resources. The

 *	request object, any slices, and its associated response are no

 *	longer valid.

 *

 * It is legal to call hwrm_req_drop() on an unowned request, provided it

 * has not already been consumed by hwrm_req_send() (for example, to release

 * an aborted request). A given request should not be dropped more than once,

 * nor should it be dropped after having been consumed by hwrm_req_send(). To

 * do so is an error (the context will not be found and a stack trace will be

 * rendered in the kernel log).

 Ensure any associated DMA buffers are written before doorbell */

 Write request msg to hwrm channel */

 Ring channel doorbell */

 Limit timeout to an upper limit */

 convert timeout to usec */

	/* Short timeout for the first few iterations:

	 * number of loops = number of loops for short timeout +

	 * number of loops for standard timeout.

 Wait until hwrm response cmpl interrupt is processed */

			/* Abort the wait for completion if the FW health

			 * check has failed.

 on first few passes, just barely sleep */

 will never see */

 Check if response len is updated */

			/* Abort the wait for completion if the FW health

			 * check has failed.

 on first few passes, just barely sleep */

 Last byte of resp contains valid bit */

 make sure we read from updated DMA memory */

	/* Zero valid bit for compatibility.  Valid bit in an older spec

	 * may become a new field in a newer spec.  We must make sure that

	 * a new field not implemented by old spec will read zero.

/**

 * hwrm_req_send() - Execute an HWRM command.

 * @bp: The driver context.

 * @req: A pointer to the request to send. The DMA resources associated with

 *	the request will be released (ie. the request will be consumed) unless

 *	ownership of the request has been assumed by the caller via a call to

 *	hwrm_req_hold().

 *

 * Send an HWRM request to the device and wait for a response. The request is

 * consumed if it is not owned by the caller. This function will block until

 * the request has either completed or times out due to an error.

 *

 * Return: A result code.

 *

 * The result is zero on success, otherwise the negative error code indicates

 * one of the following errors:

 *	E2BIG: The request was too large.

 *	EBUSY: The firmware is in a fatal state or the request timed out

 *	EACCESS: HWRM access denied.

 *	ENOSPC: HWRM resource allocation error.

 *	EINVAL: Request parameters are invalid.

 *	ENOMEM: HWRM has no buffers.

 *	EAGAIN: HWRM busy or reset in progress.

 *	EOPNOTSUPP: Invalid request type.

 *	EIO: Any other error.

 * Error handling is orthogonal to request ownership. An unowned request will

 * still be consumed on error. If the caller owns the request, then the caller

 * is responsible for releasing the resources. Otherwise, hwrm_req_send() will

 * always consume the request.

/**

 * hwrm_req_send_silent() - A silent version of hwrm_req_send().

 * @bp: The driver context.

 * @req: The request to send without logging.

 *

 * The same as hwrm_req_send(), except that the request is silenced using

 * hwrm_req_silence() prior the call. This version of the function is

 * provided solely to preserve the legacy API’s flavor for this functionality.

 *

 * Return: A result code, see hwrm_req_send().

/**

 * hwrm_req_dma_slice() - Allocate a slice of DMA mapped memory.

 * @bp: The driver context.

 * @req: The request for which indirect data will be associated.

 * @size: The size of the allocation.

 * @dma_handle: The bus address associated with the allocation. The HWRM API has

 *	no knowledge about the type of the request and so cannot infer how the

 *	caller intends to use the indirect data. Thus, the caller is

 *	responsible for configuring the request object appropriately to

 *	point to the associated indirect memory. Note, DMA handle has the

 *	same definition as it does in dma_alloc_coherent(), the caller is

 *	responsible for endian conversions via cpu_to_le64() before assigning

 *	this address.

 *

 * Allocates DMA mapped memory for indirect data related to a request. The

 * lifetime of the DMA resources will be bound to that of the request (ie.

 * they will be automatically released when the request is either consumed by

 * hwrm_req_send() or dropped by hwrm_req_drop()). Small allocations are

 * efficiently suballocated out of the request buffer space, hence the name

 * slice, while larger requests are satisfied via an underlying call to

 * dma_alloc_coherent(). Multiple suballocations are supported, however, only

 * one externally mapped region is.

 *

 * Return: The kernel virtual address of the DMA mapping.

 could not suballocate from ctx buffer, try create a new mapping */

 if one exists, can only be due to software bug, be loud */

/* Broadcom NetXtreme-C/E network driver.

 *

 * Copyright (c) 2021 Broadcom Limited

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

		/* For hwrm_ver_get response Component id = 2

		 * and Segment id = 0

 First segment should be hwrm_ver_get response */

 Write segment data into the buffer */

 Write segment header into the buffer */

		/* Driver adds coredump header and "HWRM_VER_GET response"

		 * segment additionally to coredump.

/* Broadcom NetXtreme-C/E network driver.

 *

 * Copyright (c) 2017 Broadcom Limited

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 TODO: no firmware dump support in devlink_health_report() context */

 CONFIG_BNXT_SRIOV */

 earlier devices present as an array of raw bytes */

 array of 3 version components */

 copy whole word */

 Get/Set NVM CFG parameter is supported only on PFs */

 keep REMOTE_DEV_RESET last, it is excluded based on caps */

 Add switchdev eswitch mode setting, if SRIOV supported */

/* Broadcom NetXtreme-C/E network driver.

 *

 * Copyright (c) 2017 Broadcom Limited

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

/* Return the dst fid of the func for flow forwarding

 * For PFs: src_fid is the fid of the PF

 * For VF-reps: src_fid the fid of the VF

 check if dev belongs to the same switch */

 Is dev a VF-rep? */

/* Key & Mask from the stack comes unaligned in multiple iterations of 4 bytes

 * each(u32).

 * This routine consolidates such multiple unaligned values into one

 * field each for Key & Mask (for src and dst macs separately)

 * For example,

 *			Mask/Key	Offset	Iteration

 *			==========	======	=========

 *	dst mac		0xffffffff	0	1

 *	dst mac		0x0000ffff	4	2

 *

 *	src mac		0xffff0000	4	1

 *	src mac		0xffffffff	8	2

 *

 * The above combination coming from the stack will be consolidated as

 *			Mask/Key

 *			==============

 *	src mac:	0xffffffffffff

 *	dst mac:	0xffffffffffff

 FW expects dmac to be in u16 array format */

 FW expects smac to be in u16 array format */

			/* 16 byte IPv6 address comes in 4 iterations of

			 * 4byte chunks each

 First 4bytes will be copied to idx 0 and so on */

		/* HW does not support L4 rewrite alone without L3

		 * rewrite

	/* Used to store the L2 rewrite mask for dmac (6 bytes) followed by

	 * smac (6 bytes) if rewrite of both is specified, otherwise either

	 * dmac or smac

	/* Used to store the L2 rewrite key for dmac (6 bytes) followed by

	 * smac (6 bytes) if rewrite of both is specified, otherwise either

	 * dmac or smac

 don't bother with other actions */

 Packet edit: L2 rewrite, NAT, NAPT */

 dst_fid is PF's fid */

 find the FID from dst_dev */

 KEY_CONTROL and KEY_BASIC are needed for forming a meaningful key */

	/* VLAN priority must be either exactly zero or fully wildcarded and

	 * VLAN id must be exact match.

 L3 source rewrite */

 L4 source port */

 L3 destination rewrite */

 L4 destination port */

 L3 source rewrite */

 L4 source port */

 L3 destination rewrite */

 L4 destination port */

		/* FW expects the inner_vlan_tci value to be set

		 * in outer_vlan_tci when num_vlans is 1 (which is

		 * always the case in TC.)

 If all IP and L4 fields are wildcarded then this is an L2 flow */

 l4 ports serve as type/code when ip_proto is ICMP */

 Rewrite config with tpid = 0 implies vlan pop */

		/* CFA_FLOW_ALLOC response interpretation:

		 *		    fw with	     fw with

		 *		    16-bit	     64-bit

		 *		    flow handle      flow handle

		 *		    ===========	     ===========

		 * flow_handle      flow handle      flow context id

		 * ext_flow_handle  INVALID	     flow handle

		 * flow_id	    INVALID	     flow counter id

 tunnel_id is wrongly defined in hsi defn. as __le32 */

	/* Eventhough the decap_handle returned by hwrm_cfa_decap_filter_alloc

	 * is defined as __le32, l2_ctxt_ref_id is defined in HSI as __le16.

 remove flow_node from the L2 shared flow list */

/* Get the ref_flow_handle for a flow by checking if there are any other

 * flows that share the same L2 key as this flow.

	/* If any other flow is using this l2_node, use it's flow_handle

	 * as the ref_flow_handle

	/* Insert the l2_node into the flow_node so that subsequent flows

	 * with a matching l2 key can use the flow_handle of this flow

	 * as their ref_flow_handle

/* After the flow parsing is done, this routine is used for checking

 * if there are any aspects of the flow that prevent it from being

 * offloaded.

 If L4 ports are specified then ip_proto must be TCP or UDP */

 Currently source/dest MAC cannot be partial wildcard  */

 Currently VLAN fields cannot be partial wildcard */

 Currently Ethertype must be set */

/* Returns the final refcount of the node on success

 * or a -ve error code on failure

/* Get (or add) either encap or decap tunnel node from/to the supplied

 * hash table.

	/* If any other flow is using this decap_l2_node, use it's decap_handle

	 * as the ref_decap_handle

	/* Insert the l2_node into the flow_node so that subsequent flows

	 * with a matching decap l2 key can use the decap_filter_handle of

	 * this flow as their ref_decap_handle

 remove flow_node from the decap L2 sharing flow list */

	/* The route must either point to the real_dst_dev or a dst_dev that

	 * uses the real_dst_dev.

	/* Check if there's another flow using the same tunnel decap.

	 * If not, add this tunnel to the table and resolve the other

	 * tunnel header fileds. Ignore src_port in the tunnel_key,

	 * since it is not required for decap filters.

	/* Resolve the L2 fields for tunnel decap

	 * Resolve the route for remote vtep (saddr) of the decap key

	 * Find it's next-hop mac addrs

 decap smac is wildcarded */

	/* For getting a decap_filter_handle we first need to check if

	 * there are any other decap flows that share the same tunnel L2

	 * key and if so, pass that flow's decap_filter_handle as the

	 * ref_decap_handle for this flow.

 Issue the hwrm cmd to allocate a decap filter handle */

/* Lookup the tunnel encap table and check if there's an encap_handle

 * alloc'd already.

 * If not, query L2 info via a route lookup and issue an encap_record_alloc

 * cmd to FW.

	/* Check if there's another flow using the same tunnel encap.

	 * If not, add this tunnel to the table and resolve the other

	 * tunnel header fileds

 Allocate a new tunnel encap record */

 send HWRM cmd to free the flow-id */

 release references to any tunnel encap/decap nodes */

 release reference to l2 node */

/* Add a new flow or replace an existing flow.

 * Notes on locking:

 * There are essentially two critical sections here.

 * 1. while adding a new flow

 *    a) lookup l2-key

 *    b) issue HWRM cmd and get flow_handle

 *    c) link l2-key with flow

 * 2. while deleting a flow

 *    a) unlinking l2-key from flow

 * A lock is needed to protect these two critical sections.

 *

 * The hash-tables are already protected by the rhashtable API.

 allocate memory for the new flow and it's node */

 If a flow exists with the same cookie, delete it */

	/* Check if the L2 part of the flow has been offloaded already.

	 * If so, bump up it's refcnt and get it's reference handle.

 If the flow involves tunnel encap/decap, get tunnel_handle */

 send HWRM cmd to alloc the flow */

 add new flow to flow-table */

		/* If flow_id is used to fetch flow stats then:

		 * 1. lower 12 bits of flow_handle must be set to all 1s.

		 * 2. 15th bit of flow_handle must specify the flow

		 *    direction (TX/RX).

/* Add val to accum while handling a possible wraparound

 * of val. Eventhough val is of type u64, its actual width

 * is denoted by mask and will wrap-around beyond that width.

/* The HW counters' width is much less than 64bits.

 * Handle possible wrap-around while updating the stat counters

 No more flows */

 convert counter width in bits to a mask */

 Counter widths are programmed by FW */

 init indirect block notifications */

/* Broadcom NetXtreme-C/E network driver.

 *

 * Copyright (c) 2014-2016 Broadcom Corporation

 * Copyright (c) 2016-2017 Broadcom Limited

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

			/* older firmware requires min_bw to be set to the

			 * same weight value in percent.

 Assign lossless TCs first */

 append */

 not found, nothing to delete */

 dropping get request and associated slice */

 cache result */

 initialize PRI2TC mappings to invalid value */

 All firmware DCBX settings are set in NVRAM */

 only support IEEE */

/* Broadcom NetXtreme-C/E network driver.

 *

 * Copyright (c) 2016-2017 Broadcom Limited

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 Enable link and TX only if the parent PF is open. */

	/* as only PORT_PARENT_ID is supported currently use common code

	 * between PF and VF-rep for now.

/* Called when the parent PF interface is closed:

 * As the mode transition from SWITCHDEV to LEGACY

 * happens under the rtnl_lock() this routine is safe

 * under the rtnl_lock()

/* Called when the parent PF interface is opened (re-opened):

 * As the mode transition from SWITCHDEV to LEGACY

 * happen under the rtnl_lock() this routine is safe

 * under the rtnl_lock()

 Open the VF-Rep only if it is allocated in the FW */

				/* if register_netdev failed, then netdev_ops

				 * would have been set to NULL

	/* Ensure that parent PF's and VF-reps' RX/TX has been quiesced

	 * before proceeding with VF-rep cleanup.

 un-publish cfa_code_map so that RX path can't see it anymore */

	/* Need to call vf_reps_destroy() outside of rntl_lock

	 * as unregister_netdev takes rtnl_lock

/* Free the VF-Reps in firmware, during firmware hot-reset processing.

 * Note that the VF-Rep netdevs are still active (not unregistered) during

 * this process. As the mode transition from SWITCHDEV to LEGACY happens

 * under the rtnl_lock() this routine is safe under the rtnl_lock().

 get cfa handles from FW */

 only cfa_action is needed to mux a packet while TXing */

/* Allocate the VF-Reps in firmware, during firmware hot-reset processing.

 * Note that the VF-Rep netdevs are still active (not unregistered) during

 * this process. As the mode transition from SWITCHDEV to LEGACY happens

 * under the rtnl_lock() this routine is safe under the rtnl_lock().

/* Use the OUI of the PF's perm addr and report the same mac addr

 * for the same VF-rep each time

	/* Just inherit all the featues of the parent PF as the VF-R

	 * uses the RX/TX rings of the parent PF

 Set VF-Rep's max-mtu to the corresponding VF's max-mtu */

 storage for cfa_code to vf-idx mapping */

 no need for unregister_netdev in cleanup */

 publish cfa_code_map only after all VF-reps have been initialized */

 Devlink related routines */

/* Broadcom NetXtreme-C/E network driver.

 *

 * Copyright (c) 2016-2017 Broadcom Limited

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

/* returns the following:

 * true    - packet consumed by XDP and new buffer is allocated.

 * false   - packet should be passed to the stack.

 BNXT_RX_PAGE_MODE(bp) when XDP enabled */

	/* If the tx ring is not full, we must not update the rx producer yet

	 * because we may still be transmitting on some BDs.

		/* if we are calling this here then we know that the

		 * redirect is coming from a frame received by the

		 * bnxt_en driver.

 if we are unable to allocate a new buffer, abort and reuse */

 Sync BD data before updating doorbell */

 Under rtnl_lock */

/* Broadcom NetXtreme-C/E network driver.

 *

 * Copyright (c) 2017-2018 Broadcom Limited

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 create files for each rx ring */

/* Broadcom NetXtreme-C/E network driver.

 *

 * Copyright (c) 2014-2016 Broadcom Corporation

 * Copyright (c) 2016-2017 Broadcom Limited

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 NVRAM content constant and structure defs */

 Firmware hdr constant and structure defs */

 Allow 0, which means disable. */

 Get the most up-to-date max_tx_sch_inputs. */

			/* TODO CHIMP_FW: Send message to all VF's

			 * before PF unload

 After changing number of rx channels, update NTUPLE feature. */

			/* TODO CHIMP_FW: Send message to all VF's

			 * to renable

 TODO CHIMP_FW: eeprom dump details */

 TODO CHIMP FW: reg dump details */

 hold on to slice */

 TODO: support 25GB, 40GB, 50GB with different cable type */

 set the advertised speeds */

 only support autoneg at speed 100, 1000, and 10000 */

		/* any change to autoneg will cause link change, therefore the

		 * driver should put back the original pause setting in autoneg

 update current settings */

		/* when transition from auto pause to force pause,

		 * force a link change

 TODO: handle MF, VF, driver close case */

 TODO: Address self-reset of APE/KONG/BONO/TANG or ungraceful reset */

       (e.g. when firmware isn't already running) */

 Self-reset ChiMP upon next PCIe reset: */

 Self-reset APE upon next PCIe reset: */

 Confirm the CRC32 checksum of the file: */

 Firmware update successful */

 Confirm the CRC32 checksum of the file: */

	/* Try allocating a large DMA buffer first.  Older fw will

	 * cause excessive NVRAM erases when using small blocks.

			/* We have tried to defragment already in the previous

			 * iteration. Return with the result for INSTALL_UPDATE

				/* FW has cleared NVM area, driver will create

				 * UPDATE directory and try the flash again

	/* The -1 return value allows the entire 32-bit range of offsets to be

	 * passed via the ethtool command-line utility.

 Insert 2 bytes of directory info (count and size of entries) */

 hold the slice */

 hold the slice */

 null-terminate the log data (removing last '\n'): */

 special offset value to get directory */

 special value for directory operations */

 erase */

 Create or re-write an NVM item: */

		/* Preserve tx_lpi_timer so that the last value will be used

		 * by default when it is re-enabled.

	/* No point in going further if phy status indicates

	 * module is not inserted or if it is powered down or

	 * if it is of type 10GBase-T

 This feature is not supported in older firmware versions */

 Read A0 portion of the EEPROM */

 Read A2 portion of the EEPROM */

 prevent bnxt_disable_an_for_lpbk() from consuming the request */

		/* The valid test of the entry must be done first before

		 * reading any further.

 Sync BD data before updating doorbell */

 This feature is not supported in older firmware versions */

 only request, fail hard */

 This feature is not supported in older firmware versions */

 only request, fail hard */

/* Broadcom NetXtreme-C/E network driver.

 *

 * Copyright (c) 2021 Broadcom Inc.

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 Caller holds ptp_lock */

 Configure an External PPS IN */

 Configure a Periodic PPS OUT */

 Configure PHC PPS IN */

 Allow only PPS pin function configuration */

 Query current/default PIN CFG */

 Report the TSIO capability to kernel */

 Only 1 each of ext_ts and per_out pins is available in HW */

 SPDX-License-Identifier: GPL-2.0

 statistics and error reporting */

 masks for all chip types */

 struct for the argument list for a predicate in the self test databasei */

 value read from first register */

 value read from second register, if applicable */

 1st value in predicate condition, left-to-right */

 2nd value in predicate condition, left-to-right */

 3rd value in predicate condition, left-to-right */

 4th value in predicate condition, left-to-right */

 struct representing self test record - a single test */

 predicates for self test */

 struct holding the database of self test checks (registers and predicates) */

 lines start from 2 since line 1 is heading in csv */

line 2*/{(0x3), 1, 0x2114,

line 3*/{(0x3), 1, 0x2114,

line 4*/{(0x3), 1, 0x2120,

line 5*/{(0x3), 1, 0x2814,

line 6*/{(0x2), 1, 0x281c,

line 7*/{(0x2), 1, 0x2820,

line 8*/{(0x3), 1, PXP2_REG_PGL_EXP_ROM2,

line 9*/{(0x3), 2, 0x212c,

line 10*/{(0x1C), 1, 0x2104,

line 11*/{(0x1C), 1, 0x2104,

line 12*/{(0x1C), 1, 0x2104,

line 13*/{(0x1C), 1, 0x2110,

line 14*/{(0x1C), 1, 0x2814,

line 15*/{(0x1C), 1, 0x2814,

line 16*/{(0x1C), 1, 0x2854,

line 17*/{(0x1C), 1, 0x285c,

line 18*/{(0x18), 1, 0x3040,

line 19*/{(0x1C), 1, PXP2_REG_PGL_EXP_ROM2,

line 20*/{(0x1C), 2, 0x211c,

line 21*/{(0x1C), 1, PGLUE_B_REG_INCORRECT_RCV_DETAILS,

line 22*/{(0x1C), 1, PGLUE_B_REG_WAS_ERROR_VF_31_0,

line 23*/{(0x1C), 1, PGLUE_B_REG_WAS_ERROR_VF_63_32,

line 24*/{(0x1C), 1, PGLUE_B_REG_WAS_ERROR_VF_95_64,

line 25*/{(0x1C), 1, PGLUE_B_REG_WAS_ERROR_VF_127_96,

line 26*/{(0x1C), 1, PGLUE_B_REG_WAS_ERROR_PF_7_0,

line 27*/{(0x1C), 1, PGLUE_B_REG_RX_ERR_DETAILS,

line 28*/{(0x1C), 1, PGLUE_B_REG_RX_TCPL_ERR_DETAILS,

line 29*/{(0x1C), 1, PGLUE_B_REG_TX_ERR_WR_ADD_31_0,

line 30*/{(0x1C), 1, PGLUE_B_REG_TX_ERR_WR_ADD_63_32,

line 31*/{(0x1C), 1, PGLUE_B_REG_TX_ERR_WR_DETAILS,

line 32*/{(0x1C), 1, PGLUE_B_REG_TX_ERR_WR_DETAILS2,

line 33*/{(0x1C), 1, PGLUE_B_REG_TX_ERR_RD_ADD_31_0,

line 34*/{(0x1C), 1, PGLUE_B_REG_TX_ERR_RD_ADD_63_32,

line 35*/{(0x1C), 1, PGLUE_B_REG_TX_ERR_RD_DETAILS,

line 36*/{(0x1C), 1, PGLUE_B_REG_TX_ERR_RD_DETAILS2,

line 37*/{(0x1C), 1, PGLUE_B_REG_VF_LENGTH_VIOLATION_DETAILS,

line 38*/{(0x1C), 1, PGLUE_B_REG_VF_GRC_SPACE_VIOLATION_DETAILS,

line 39*/{(0x1C), 1, PGLUE_B_REG_TAGS_63_32,

line 40*/{(0x1C), 3, PXP_REG_HST_VF_DISABLED_ERROR_VALID,

line 41*/{(0x1C), 1, PXP_REG_HST_PER_VIOLATION_VALID,

line 42*/{(0x1C), 1, PXP_REG_HST_INCORRECT_ACCESS_VALID,

line 43*/{(0x1C), 1, PXP2_REG_RD_CPL_ERR_DETAILS,

line 44*/{(0x1C), 1, PXP2_REG_RD_CPL_ERR_DETAILS2,

line 45*/{(0x1F), 1, PXP2_REG_RQ_VQ0_ENTRY_CNT,

line 46*/{(0x1F), 1, PXP2_REG_RQ_VQ1_ENTRY_CNT,

line 47*/{(0x1F), 1, PXP2_REG_RQ_VQ2_ENTRY_CNT,

line 48*/{(0x1F), 1, PXP2_REG_RQ_VQ3_ENTRY_CNT,

line 49*/{(0x1F), 1, PXP2_REG_RQ_VQ4_ENTRY_CNT,

line 50*/{(0x1F), 1, PXP2_REG_RQ_VQ5_ENTRY_CNT,

line 51*/{(0x1F), 1, PXP2_REG_RQ_VQ6_ENTRY_CNT,

line 52*/{(0x1F), 1, PXP2_REG_RQ_VQ7_ENTRY_CNT,

line 53*/{(0x1F), 1, PXP2_REG_RQ_VQ8_ENTRY_CNT,

line 54*/{(0x1F), 1, PXP2_REG_RQ_VQ9_ENTRY_CNT,

line 55*/{(0x1F), 1, PXP2_REG_RQ_VQ10_ENTRY_CNT,

line 56*/{(0x1F), 1, PXP2_REG_RQ_VQ11_ENTRY_CNT,

line 57*/{(0x1F), 1, PXP2_REG_RQ_VQ12_ENTRY_CNT,

line 58*/{(0x1F), 1, PXP2_REG_RQ_VQ13_ENTRY_CNT,

line 59*/{(0x1F), 1, PXP2_REG_RQ_VQ14_ENTRY_CNT,

line 60*/{(0x1F), 1, PXP2_REG_RQ_VQ15_ENTRY_CNT,

line 61*/{(0x1F), 1, PXP2_REG_RQ_VQ16_ENTRY_CNT,

line 62*/{(0x1F), 1, PXP2_REG_RQ_VQ17_ENTRY_CNT,

line 63*/{(0x1F), 1, PXP2_REG_RQ_VQ18_ENTRY_CNT,

line 64*/{(0x1F), 1, PXP2_REG_RQ_VQ19_ENTRY_CNT,

line 65*/{(0x1F), 1, PXP2_REG_RQ_VQ20_ENTRY_CNT,

line 66*/{(0x1F), 1, PXP2_REG_RQ_VQ21_ENTRY_CNT,

line 67*/{(0x1F), 1, PXP2_REG_RQ_VQ22_ENTRY_CNT,

line 68*/{(0x1F), 1, PXP2_REG_RQ_VQ23_ENTRY_CNT,

line 69*/{(0x1F), 1, PXP2_REG_RQ_VQ24_ENTRY_CNT,

line 70*/{(0x1F), 1, PXP2_REG_RQ_VQ25_ENTRY_CNT,

line 71*/{(0x1F), 1, PXP2_REG_RQ_VQ26_ENTRY_CNT,

line 72*/{(0x1F), 1, PXP2_REG_RQ_VQ27_ENTRY_CNT,

line 73*/{(0x1F), 1, PXP2_REG_RQ_VQ28_ENTRY_CNT,

line 74*/{(0x1F), 1, PXP2_REG_RQ_VQ29_ENTRY_CNT,

line 75*/{(0x1F), 1, PXP2_REG_RQ_VQ30_ENTRY_CNT,

line 76*/{(0x1F), 1, PXP2_REG_RQ_VQ31_ENTRY_CNT,

line 77*/{(0x1F), 1, PXP2_REG_RQ_UFIFO_NUM_OF_ENTRY,

line 78*/{(0x1F), 1, PXP2_REG_RQ_RBC_DONE,

line 79*/{(0x1F), 1, PXP2_REG_RQ_CFG_DONE,

line 80*/{(0x3), 1, PXP2_REG_PSWRQ_BW_CREDIT,

line 81*/{(0x1F), 1, PXP2_REG_RD_START_INIT,

line 82*/{(0x1F), 1, PXP2_REG_RD_INIT_DONE,

line 83*/{(0x1F), 3, PXP2_REG_RD_SR_CNT,

line 84*/{(0x1F), 3, PXP2_REG_RD_BLK_CNT,

line 85*/{(0x1F), 3, PXP2_REG_RD_SR_CNT,

line 86*/{(0x1F), 3, PXP2_REG_RD_BLK_CNT,

line 87*/{(0x1F), 1, PXP2_REG_RD_PORT_IS_IDLE_0,

line 88*/{(0x1F), 1, PXP2_REG_RD_PORT_IS_IDLE_1,

line 89*/{(0x1F), 2, PXP2_REG_RD_ALMOST_FULL_0,

line 90*/{(0x1F), 1, PXP2_REG_RD_DISABLE_INPUTS,

line 91*/{(0x1F), 1, PXP2_REG_HST_HEADER_FIFO_STATUS,

line 92*/{(0x1F), 1, PXP2_REG_HST_DATA_FIFO_STATUS,

line 93*/{(0x3), 1, PXP2_REG_PGL_WRITE_BLOCKED,

line 94*/{(0x3), 1, PXP2_REG_PGL_READ_BLOCKED,

line 95*/{(0x1C), 1, PXP2_REG_PGL_WRITE_BLOCKED,

line 96*/{(0x1C), 1, PXP2_REG_PGL_READ_BLOCKED,

line 97*/{(0x1F), 1, PXP2_REG_PGL_TXW_CDTS,

line 98*/{(0x1F), 1, PXP_REG_HST_ARB_IS_IDLE,

line 99*/{(0x1F), 1, PXP_REG_HST_CLIENTS_WAITING_TO_ARB,

line 100*/{(0x1E), 1, PXP_REG_HST_DISCARD_INTERNAL_WRITES_STATUS,

line 101*/{(0x1E), 1, PXP_REG_HST_DISCARD_DOORBELLS_STATUS,

line 102*/{(0x1C), 1, PXP2_REG_RQ_GARB,

line 103*/{(0x1F), 1, DMAE_REG_GO_C0,

line 104*/{(0x1F), 1, DMAE_REG_GO_C1,

line 105*/{(0x1F), 1, DMAE_REG_GO_C2,

line 106*/{(0x1F), 1, DMAE_REG_GO_C3,

line 107*/{(0x1F), 1, DMAE_REG_GO_C4,

line 108*/{(0x1F), 1, DMAE_REG_GO_C5,

line 109*/{(0x1F), 1, DMAE_REG_GO_C6,

line 110*/{(0x1F), 1, DMAE_REG_GO_C7,

line 111*/{(0x1F), 1, DMAE_REG_GO_C8,

line 112*/{(0x1F), 1, DMAE_REG_GO_C9,

line 113*/{(0x1F), 1, DMAE_REG_GO_C10,

line 114*/{(0x1F), 1, DMAE_REG_GO_C11,

line 115*/{(0x1F), 1, DMAE_REG_GO_C12,

line 116*/{(0x1F), 1, DMAE_REG_GO_C13,

line 117*/{(0x1F), 1, DMAE_REG_GO_C14,

line 118*/{(0x1F), 1, DMAE_REG_GO_C15,

line 119*/{(0x1F), 1, CFC_REG_ERROR_VECTOR,

line 120*/{(0x1F), 1, CFC_REG_NUM_LCIDS_ARRIVING,

line 121*/{(0x1F), 1, CFC_REG_NUM_LCIDS_ALLOC,

line 122*/{(0x1F), 1, CFC_REG_NUM_LCIDS_LEAVING,

line 123*/{(0x1F), 7, CFC_REG_INFO_RAM,

line 124*/{(0x1F), 7, CFC_REG_INFO_RAM,

line 125*/{(0x1F), 7, CFC_REG_INFO_RAM,

line 126*/{(0x1F), 7, CFC_REG_INFO_RAM,

line 127*/{(0x1F), 2, QM_REG_QTASKCTR_0,

line 128*/{(0xF), 3, QM_REG_VOQCREDIT_0,

line 129*/{(0xF), 3, QM_REG_VOQCREDIT_1,

line 130*/{(0xF), 3, QM_REG_VOQCREDIT_4,

line 131*/{(0x3), 3, QM_REG_PORT0BYTECRD,

line 132*/{(0x3), 3, QM_REG_PORT1BYTECRD,

line 133*/{(0x1F), 1, CCM_REG_CAM_OCCUP,

line 134*/{(0x1F), 1, TCM_REG_CAM_OCCUP,

line 135*/{(0x1F), 1, UCM_REG_CAM_OCCUP,

line 136*/{(0x1F), 1, XCM_REG_CAM_OCCUP,

line 137*/{(0x1F), 1, BRB1_REG_NUM_OF_FULL_BLOCKS,

line 138*/{(0x1F), 1, CSEM_REG_SLEEP_THREADS_VALID,

line 139*/{(0x1F), 1, TSEM_REG_SLEEP_THREADS_VALID,

line 140*/{(0x1F), 1, USEM_REG_SLEEP_THREADS_VALID,

line 141*/{(0x1F), 1, XSEM_REG_SLEEP_THREADS_VALID,

line 142*/{(0x1F), 1, CSEM_REG_SLOW_EXT_STORE_EMPTY,

line 143*/{(0x1F), 1, TSEM_REG_SLOW_EXT_STORE_EMPTY,

line 144*/{(0x1F), 1, USEM_REG_SLOW_EXT_STORE_EMPTY,

line 145*/{(0x1F), 1, XSEM_REG_SLOW_EXT_STORE_EMPTY,

line 146*/{(0x1F), 1, CSDM_REG_SYNC_PARSER_EMPTY,

line 147*/{(0x1F), 1, TSDM_REG_SYNC_PARSER_EMPTY,

line 148*/{(0x1F), 1, USDM_REG_SYNC_PARSER_EMPTY,

line 149*/{(0x1F), 1, XSDM_REG_SYNC_PARSER_EMPTY,

line 150*/{(0x1F), 1, CSDM_REG_SYNC_SYNC_EMPTY,

line 151*/{(0x1F), 1, TSDM_REG_SYNC_SYNC_EMPTY,

line 152*/{(0x1F), 1, USDM_REG_SYNC_SYNC_EMPTY,

line 153*/{(0x1F), 1, XSDM_REG_SYNC_SYNC_EMPTY,

line 154*/{(0x1F), 1, CSDM_REG_RSP_PXP_CTRL_RDATA_EMPTY,

line 155*/{(0x1F), 1, TSDM_REG_RSP_PXP_CTRL_RDATA_EMPTY,

line 156*/{(0x1F), 1, USDM_REG_RSP_PXP_CTRL_RDATA_EMPTY,

line 157*/{(0x1F), 1, XSDM_REG_RSP_PXP_CTRL_RDATA_EMPTY,

line 158*/{(0x1F), 1, DORQ_REG_DQ_FILL_LVLF,

line 159*/{(0x1F), 1, CFC_REG_CFC_INT_STS,

line 160*/{(0x1F), 1, CDU_REG_CDU_INT_STS,

line 161*/{(0x1F), 1, CCM_REG_CCM_INT_STS,

line 162*/{(0x1F), 1, TCM_REG_TCM_INT_STS,

line 163*/{(0x1F), 1, UCM_REG_UCM_INT_STS,

line 164*/{(0x1F), 1, XCM_REG_XCM_INT_STS,

line 165*/{(0xF), 1, PBF_REG_PBF_INT_STS,

line 166*/{(0x1F), 1, TM_REG_TM_INT_STS,

line 167*/{(0x1F), 1, DORQ_REG_DORQ_INT_STS,

line 168*/{(0x1F), 1, SRC_REG_SRC_INT_STS,

line 169*/{(0x1F), 1, PRS_REG_PRS_INT_STS,

line 170*/{(0x1F), 1, BRB1_REG_BRB1_INT_STS,

line 171*/{(0x1F), 1, GRCBASE_XPB + PB_REG_PB_INT_STS,

line 172*/{(0x1F), 1, GRCBASE_UPB + PB_REG_PB_INT_STS,

line 173*/{(0x1), 1, PXP2_REG_PXP2_INT_STS,

line 174*/{(0x1E), 1, PXP2_REG_PXP2_INT_STS_0,

line 175*/{(0x1E), 1, PXP2_REG_PXP2_INT_STS_1,

line 176*/{(0x1F), 1, QM_REG_QM_INT_STS,

line 177*/{(0x1F), 1, PXP_REG_PXP_INT_STS_0,

line 178*/{(0x1F), 1, PXP_REG_PXP_INT_STS_1,

line 179*/{(0x1C), 1, PGLUE_B_REG_PGLUE_B_INT_STS,

line 180*/{(0x1F), 1, DORQ_REG_RSPA_CRD_CNT,

line 181*/{(0x1F), 1, DORQ_REG_RSPB_CRD_CNT,

line 182*/{(0x3), 1, QM_REG_VOQCRDERRREG,

line 183*/{(0x1F), 1, DORQ_REG_DQ_FULL_ST,

line 184*/{(0x1F), 1, MISC_REG_AEU_AFTER_INVERT_1_FUNC_0,

line 185*/{(0x1F), 1, MISC_REG_AEU_AFTER_INVERT_2_FUNC_0,

line 186*/{(0x1F), 1, MISC_REG_AEU_AFTER_INVERT_3_FUNC_0,

line 187*/{(0x1F), 1, MISC_REG_AEU_AFTER_INVERT_4_FUNC_0,

line 188*/{(0x3), 1, MISC_REG_AEU_AFTER_INVERT_1_FUNC_1,

line 189*/{(0x3), 1, MISC_REG_AEU_AFTER_INVERT_2_FUNC_1,

line 190*/{(0x3), 1, MISC_REG_AEU_AFTER_INVERT_3_FUNC_1,

line 191*/{(0x3), 1, MISC_REG_AEU_AFTER_INVERT_4_FUNC_1,

line 192*/{(0x1F), 1, MISC_REG_AEU_AFTER_INVERT_1_MCP,

line 193*/{(0x1F), 1, MISC_REG_AEU_AFTER_INVERT_2_MCP,

line 194*/{(0x1F), 1, MISC_REG_AEU_AFTER_INVERT_3_MCP,

line 195*/{(0x1F), 1, MISC_REG_AEU_AFTER_INVERT_4_MCP,

line 196*/{(0xF), 5, PBF_REG_P0_CREDIT,

line 197*/{(0xF), 5, PBF_REG_P1_CREDIT,

line 198*/{(0xF), 3, PBF_REG_P4_CREDIT,

line 199*/{(0x10), 5, PBF_REG_CREDIT_Q0,

line 200*/{(0x10), 5, PBF_REG_CREDIT_Q1,

line 201*/{(0x10), 5, PBF_REG_CREDIT_Q2,

line 202*/{(0x10), 5, PBF_REG_CREDIT_Q3,

line 203*/{(0x10), 5, PBF_REG_CREDIT_Q4,

line 204*/{(0x10), 5, PBF_REG_CREDIT_Q5,

line 205*/{(0x10), 3, PBF_REG_CREDIT_LB_Q,

line 206*/{(0xF), 1, PBF_REG_P0_TASK_CNT,

line 207*/{(0xF), 1, PBF_REG_P1_TASK_CNT,

line 208*/{(0xF), 1, PBF_REG_P4_TASK_CNT,

line 209*/{(0x10), 1, PBF_REG_TASK_CNT_Q0,

line 210*/{(0x10), 1, PBF_REG_TASK_CNT_Q1,

line 211*/{(0x10), 1, PBF_REG_TASK_CNT_Q2,

line 212*/{(0x10), 1, PBF_REG_TASK_CNT_Q3,

line 213*/{(0x10), 1, PBF_REG_TASK_CNT_Q4,

line 214*/{(0x10), 1, PBF_REG_TASK_CNT_Q5,

line 215*/{(0x10), 1, PBF_REG_TASK_CNT_LB_Q,

line 216*/{(0x1F), 1, XCM_REG_CFC_INIT_CRD,

line 217*/{(0x1F), 1, UCM_REG_CFC_INIT_CRD,

line 218*/{(0x1F), 1, TCM_REG_CFC_INIT_CRD,

line 219*/{(0x1F), 1, CCM_REG_CFC_INIT_CRD,

line 220*/{(0x1F), 1, XCM_REG_XQM_INIT_CRD,

line 221*/{(0x1F), 1, UCM_REG_UQM_INIT_CRD,

line 222*/{(0x1F), 1, TCM_REG_TQM_INIT_CRD,

line 223*/{(0x1F), 1, CCM_REG_CQM_INIT_CRD,

line 224*/{(0x1F), 1, XCM_REG_TM_INIT_CRD,

line 225*/{(0x1F), 1, UCM_REG_TM_INIT_CRD,

line 226*/{(0x1F), 1, XCM_REG_FIC0_INIT_CRD,

line 227*/{(0x1F), 1, UCM_REG_FIC0_INIT_CRD,

line 228*/{(0x1F), 1, TCM_REG_FIC0_INIT_CRD,

line 229*/{(0x1F), 1, CCM_REG_FIC0_INIT_CRD,

line 230*/{(0x1F), 1, XCM_REG_FIC1_INIT_CRD,

line 231*/{(0x1F), 1, UCM_REG_FIC1_INIT_CRD,

line 232*/{(0x1F), 1, TCM_REG_FIC1_INIT_CRD,

line 233*/{(0x1F), 1, CCM_REG_FIC1_INIT_CRD,

line 234*/{(0x1), 1, XCM_REG_XX_FREE,

line 235*/{(0x1E), 1, XCM_REG_XX_FREE,

line 236*/{(0x1F), 1, UCM_REG_XX_FREE,

line 237*/{(0x7), 1, TCM_REG_XX_FREE,

line 238*/{(0x18), 1, TCM_REG_XX_FREE,

line 239*/{(0x1F), 1, CCM_REG_XX_FREE,

line 240*/{(0x1F), 1, XSEM_REG_FAST_MEMORY + 0x18000,

line 241*/{(0x1F), 1, XSEM_REG_FAST_MEMORY + 0x18040,

line 242*/{(0x1F), 1, XSEM_REG_FAST_MEMORY + 0x18080,

line 243*/{(0x1F), 1, USEM_REG_FAST_MEMORY + 0x18000,

line 244*/{(0x1F), 1, USEM_REG_FAST_MEMORY + 0x18040,

line 245*/{(0x1F), 1, USEM_REG_FAST_MEMORY + 0x18080,

line 246*/{(0x1F), 1, USEM_REG_FAST_MEMORY + 0x180C0,

line 247*/{(0x1F), 1, TSEM_REG_FAST_MEMORY + 0x18000,

line 248*/{(0x1F), 1, TSEM_REG_FAST_MEMORY + 0x18040,

line 249*/{(0x1F), 1, TSEM_REG_FAST_MEMORY + 0x18080,

line 250*/{(0x1F), 1, TSEM_REG_FAST_MEMORY + 0x180C0,

line 251*/{(0x1F), 1, CSEM_REG_FAST_MEMORY + 0x18000,

line 252*/{(0x1F), 1, CSEM_REG_FAST_MEMORY + 0x18040,

line 253*/{(0x1F), 1, CSEM_REG_FAST_MEMORY + 0x18080,

line 254*/{(0x1F), 1, CSEM_REG_FAST_MEMORY + 0x180C0,

line 255*/{(0x1F), 1, PRS_REG_TSDM_CURRENT_CREDIT,

line 256*/{(0x1F), 1, PRS_REG_TCM_CURRENT_CREDIT,

line 257*/{(0x1F), 1, PRS_REG_CFC_LD_CURRENT_CREDIT,

line 258*/{(0x1F), 1, PRS_REG_CFC_SEARCH_CURRENT_CREDIT,

line 259*/{(0x1F), 1, PRS_REG_SRC_CURRENT_CREDIT,

line 260*/{(0x1F), 1, PRS_REG_PENDING_BRB_PRS_RQ,

line 261*/{(0x1F), 2, PRS_REG_PENDING_BRB_CAC0_RQ,

line 262*/{(0x1F), 1, PRS_REG_SERIAL_NUM_STATUS_LSB,

line 263*/{(0x1F), 1, PRS_REG_SERIAL_NUM_STATUS_MSB,

line 264*/{(0x1F), 1, CDU_REG_ERROR_DATA,

line 265*/{(0x1F), 1, CCM_REG_STORM_LENGTH_MIS,

line 266*/{(0x1F), 1, CCM_REG_CSDM_LENGTH_MIS,

line 267*/{(0x1F), 1, CCM_REG_TSEM_LENGTH_MIS,

line 268*/{(0x1F), 1, CCM_REG_XSEM_LENGTH_MIS,

line 269*/{(0x1F), 1, CCM_REG_USEM_LENGTH_MIS,

line 270*/{(0x1F), 1, CCM_REG_PBF_LENGTH_MIS,

line 271*/{(0x1F), 1, TCM_REG_STORM_LENGTH_MIS,

line 272*/{(0x1F), 1, TCM_REG_TSDM_LENGTH_MIS,

line 273*/{(0x1F), 1, TCM_REG_PRS_LENGTH_MIS,

line 274*/{(0x1F), 1, TCM_REG_PBF_LENGTH_MIS,

line 275*/{(0x1F), 1, TCM_REG_USEM_LENGTH_MIS,

line 276*/{(0x1F), 1, TCM_REG_CSEM_LENGTH_MIS,

line 277*/{(0x1F), 1, UCM_REG_STORM_LENGTH_MIS,

line 278*/{(0x1F), 1, UCM_REG_USDM_LENGTH_MIS,

line 279*/{(0x1F), 1, UCM_REG_TSEM_LENGTH_MIS,

line 280*/{(0x1F), 1, UCM_REG_CSEM_LENGTH_MIS,

line 281*/{(0x1F), 1, UCM_REG_XSEM_LENGTH_MIS,

line 282*/{(0x1F), 1, UCM_REG_DORQ_LENGTH_MIS,

line 283*/{(0x1F), 1, XCM_REG_STORM_LENGTH_MIS,

line 284*/{(0x1F), 1, XCM_REG_XSDM_LENGTH_MIS,

line 285*/{(0x1F), 1, XCM_REG_TSEM_LENGTH_MIS,

line 286*/{(0x1F), 1, XCM_REG_CSEM_LENGTH_MIS,

line 287*/{(0x1F), 1, XCM_REG_USEM_LENGTH_MIS,

line 288*/{(0x1F), 1, XCM_REG_DORQ_LENGTH_MIS,

line 289*/{(0x1F), 1, XCM_REG_PBF_LENGTH_MIS,

line 290*/{(0x1F), 1, XCM_REG_NIG0_LENGTH_MIS,

line 291*/{(0x1F), 1, XCM_REG_NIG1_LENGTH_MIS,

line 292*/{(0x1F), 1, QM_REG_XQM_WRC_FIFOLVL,

line 293*/{(0x1F), 1, QM_REG_UQM_WRC_FIFOLVL,

line 294*/{(0x1F), 1, QM_REG_TQM_WRC_FIFOLVL,

line 295*/{(0x1F), 1, QM_REG_CQM_WRC_FIFOLVL,

line 296*/{(0x1F), 1, QM_REG_QSTATUS_LOW,

line 297*/{(0x1F), 1, QM_REG_QSTATUS_HIGH,

line 298*/{(0x1F), 1, QM_REG_PAUSESTATE0,

line 299*/{(0x1F), 1, QM_REG_PAUSESTATE1,

line 300*/{(0x1F), 1, QM_REG_OVFQNUM,

line 301*/{(0x1F), 1, QM_REG_OVFERROR,

line 302*/{(0x1F), 6, QM_REG_PTRTBL,

line 303*/{(0x1F), 1, BRB1_REG_BRB1_PRTY_STS,

line 304*/{(0x1F), 1, CDU_REG_CDU_PRTY_STS,

line 305*/{(0x1F), 1, CFC_REG_CFC_PRTY_STS,

line 306*/{(0x1F), 1, CSDM_REG_CSDM_PRTY_STS,

line 307*/{(0x3), 1, DBG_REG_DBG_PRTY_STS,

line 308*/{(0x1F), 1, DMAE_REG_DMAE_PRTY_STS,

line 309*/{(0x1F), 1, DORQ_REG_DORQ_PRTY_STS,

line 310*/{(0x1), 1, TCM_REG_TCM_PRTY_STS,

line 311*/{(0x1E), 1, TCM_REG_TCM_PRTY_STS,

line 312*/{(0x1), 1, CCM_REG_CCM_PRTY_STS,

line 313*/{(0x1E), 1, CCM_REG_CCM_PRTY_STS,

line 314*/{(0x1), 1, UCM_REG_UCM_PRTY_STS,

line 315*/{(0x1E), 1, UCM_REG_UCM_PRTY_STS,

line 316*/{(0x1), 1, XCM_REG_XCM_PRTY_STS,

line 317*/{(0x1E), 1, XCM_REG_XCM_PRTY_STS,

line 318*/{(0x1), 1, HC_REG_HC_PRTY_STS,

line 319*/{(0x1), 1, MISC_REG_MISC_PRTY_STS,

line 320*/{(0x1F), 1, PRS_REG_PRS_PRTY_STS,

line 321*/{(0x1F), 1, PXP_REG_PXP_PRTY_STS,

line 322*/{(0x1F), 1, QM_REG_QM_PRTY_STS,

line 323*/{(0x1), 1, SRC_REG_SRC_PRTY_STS,

line 324*/{(0x1F), 1, TSDM_REG_TSDM_PRTY_STS,

line 325*/{(0x1F), 1, USDM_REG_USDM_PRTY_STS,

line 326*/{(0x1F), 1, XSDM_REG_XSDM_PRTY_STS,

line 327*/{(0x1F), 1, GRCBASE_XPB + PB_REG_PB_PRTY_STS,

line 328*/{(0x1F), 1, GRCBASE_UPB + PB_REG_PB_PRTY_STS,

line 329*/{(0x1F), 1, CSEM_REG_CSEM_PRTY_STS_0,

line 330*/{(0x1), 1, PXP2_REG_PXP2_PRTY_STS_0,

line 331*/{(0x1E), 1, PXP2_REG_PXP2_PRTY_STS_0,

line 332*/{(0x1F), 1, TSEM_REG_TSEM_PRTY_STS_0,

line 333*/{(0x1F), 1, USEM_REG_USEM_PRTY_STS_0,

line 334*/{(0x1F), 1, XSEM_REG_XSEM_PRTY_STS_0,

line 335*/{(0x1F), 1, CSEM_REG_CSEM_PRTY_STS_1,

line 336*/{(0x1), 1, PXP2_REG_PXP2_PRTY_STS_1,

line 337*/{(0x1E), 1, PXP2_REG_PXP2_PRTY_STS_1,

line 338*/{(0x1F), 1, TSEM_REG_TSEM_PRTY_STS_1,

line 339*/{(0x1F), 1, USEM_REG_USEM_PRTY_STS_1,

line 340*/{(0x1F), 1, XSEM_REG_XSEM_PRTY_STS_1,

line 341*/{(0x1C), 1, PGLUE_B_REG_PGLUE_B_PRTY_STS,

line 342*/{(0x2), 2, QM_REG_QTASKCTR_EXT_A_0,

line 343*/{(0x2), 1, QM_REG_QSTATUS_LOW_EXT_A,

line 344*/{(0x2), 1, QM_REG_QSTATUS_HIGH_EXT_A,

line 345*/{(0x1E), 1, QM_REG_PAUSESTATE2,

line 346*/{(0x1E), 1, QM_REG_PAUSESTATE3,

line 347*/{(0x2), 1, QM_REG_PAUSESTATE4,

line 348*/{(0x2), 1, QM_REG_PAUSESTATE5,

line 349*/{(0x2), 1, QM_REG_PAUSESTATE6,

line 350*/{(0x2), 1, QM_REG_PAUSESTATE7,

line 351*/{(0x2), 6, QM_REG_PTRTBL_EXT_A,

line 352*/{(0x1E), 1, MISC_REG_AEU_SYS_KILL_OCCURRED,

line 353*/{(0x1E), 1, MISC_REG_AEU_SYS_KILL_STATUS_0,

line 354*/{(0x1E), 1, MISC_REG_AEU_SYS_KILL_STATUS_1,

line 355*/{(0x1E), 1, MISC_REG_AEU_SYS_KILL_STATUS_2,

line 356*/{(0x1E), 1, MISC_REG_AEU_SYS_KILL_STATUS_3,

line 357*/{(0x1E), 1, MISC_REG_PCIE_HOT_RESET,

line 358*/{(0x1F), 1, NIG_REG_NIG_INT_STS_0,

line 359*/{(0x1F), 1, NIG_REG_NIG_INT_STS_0,

line 360*/{(0x1F), 1, NIG_REG_NIG_INT_STS_1,

line 361*/{(0x1F), 1, NIG_REG_NIG_INT_STS_1,

line 362*/{(0x1F), 1, NIG_REG_NIG_INT_STS_1,

line 363*/{(0x2), 1, NIG_REG_NIG_PRTY_STS,

line 364*/{(0x1C), 1, NIG_REG_NIG_PRTY_STS_0,

line 365*/{(0x4), 1, NIG_REG_NIG_PRTY_STS_1,

line 366*/{(0x18), 1, NIG_REG_NIG_PRTY_STS_1,

line 367*/{(0x1F), 1, TSEM_REG_TSEM_INT_STS_0,

line 368*/{(0x1F), 1, TSEM_REG_TSEM_INT_STS_0,

line 369*/{(0x1F), 1, TSEM_REG_TSEM_INT_STS_1,

line 370*/{(0x1F), 1, CSEM_REG_CSEM_INT_STS_0,

line 371*/{(0x1F), 1, CSEM_REG_CSEM_INT_STS_0,

line 372*/{(0x1F), 1, CSEM_REG_CSEM_INT_STS_1,

line 373*/{(0x1F), 1, USEM_REG_USEM_INT_STS_0,

line 374*/{(0x1F), 1, USEM_REG_USEM_INT_STS_0,

line 375*/{(0x1F), 1, USEM_REG_USEM_INT_STS_1,

line 376*/{(0x1F), 1, XSEM_REG_XSEM_INT_STS_0,

line 377*/{(0x1F), 1, XSEM_REG_XSEM_INT_STS_0,

line 378*/{(0x1F), 1, XSEM_REG_XSEM_INT_STS_1,

line 379*/{(0x1F), 1, TSDM_REG_TSDM_INT_STS_0,

line 380*/{(0x1F), 1, TSDM_REG_TSDM_INT_STS_1,

line 381*/{(0x1F), 1, CSDM_REG_CSDM_INT_STS_0,

line 382*/{(0x1F), 1, CSDM_REG_CSDM_INT_STS_1,

line 383*/{(0x1F), 1, USDM_REG_USDM_INT_STS_0,

line 384*/{(0x1F), 1, USDM_REG_USDM_INT_STS_1,

line 385*/{(0x1F), 1, XSDM_REG_XSDM_INT_STS_0,

line 386*/{(0x1F), 1, XSDM_REG_XSDM_INT_STS_1,

line 387*/{(0x2), 1, HC_REG_HC_PRTY_STS,

line 388*/{(0x1E), 1, MISC_REG_MISC_PRTY_STS,

line 389*/{(0x1E), 1, SRC_REG_SRC_PRTY_STS,

line 390*/{(0xC), 3, QM_REG_BYTECRD0,

line 391*/{(0xC), 3, QM_REG_BYTECRD1,

line 392*/{(0xC), 3, QM_REG_BYTECRD2,

line 393*/{(0x1C), 1, QM_REG_VOQCRDERRREG,

line 394*/{(0x1C), 1, QM_REG_BYTECRDERRREG,

line 395*/{(0x1C), 1, PGLUE_B_REG_FLR_REQUEST_VF_31_0,

line 396*/{(0x1C), 1, PGLUE_B_REG_FLR_REQUEST_VF_63_32,

line 397*/{(0x1C), 1, PGLUE_B_REG_FLR_REQUEST_VF_95_64,

line 398*/{(0x1C), 1, PGLUE_B_REG_FLR_REQUEST_VF_127_96,

line 399*/{(0x1C), 1, PGLUE_B_REG_FLR_REQUEST_PF_7_0,

line 400*/{(0x1C), 1, PGLUE_B_REG_SR_IOV_DISABLED_REQUEST,

line 401*/{(0x1C), 1, PGLUE_B_REG_CFG_SPACE_A_REQUEST,

line 402*/{(0x1C), 1, PGLUE_B_REG_CFG_SPACE_B_REQUEST,

line 403*/{(0x1C), 1, IGU_REG_ERROR_HANDLING_DATA_VALID,

line 404*/{(0x1C), 1, IGU_REG_ATTN_WRITE_DONE_PENDING,

line 405*/{(0x1C), 1, IGU_REG_WRITE_DONE_PENDING,

line 406*/{(0x1C), 1, IGU_REG_IGU_PRTY_STS,

line 407*/{(0x1E), 3, MISC_REG_GRC_TIMEOUT_ATTN,

line 408*/{(0x1C), 3, MISC_REG_GRC_TIMEOUT_ATTN_FULL_FID,

line 409*/{(0x1E), 3, MISC_REG_GRC_TIMEOUT_ATTN,

line 410*/{(0x1C), 3, MISC_REG_GRC_TIMEOUT_ATTN_FULL_FID,

line 411*/{(0x1E), 3, MISC_REG_GRC_TIMEOUT_ATTN,

line 412*/{(0x1C), 3, MISC_REG_GRC_TIMEOUT_ATTN_FULL_FID,

line 413*/{(0x1C), 1, IGU_REG_SILENT_DROP,

line 414*/{(0x1C), 1, PXP2_REG_PSWRQ_BW_CREDIT,

line 415*/{(0x1C), 1, IGU_REG_SB_CTRL_FSM,

line 416*/{(0x1C), 1, IGU_REG_INT_HANDLE_FSM,

line 417*/{(0x1C), 1, IGU_REG_ATTN_FSM,

line 418*/{(0x1C), 1, IGU_REG_CTRL_FSM,

line 419*/{(0x1C), 1, IGU_REG_PXP_ARB_FSM,

line 420*/{(0x1C), 1, IGU_REG_PENDING_BITS_STATUS,

line 421*/{(0x10), 3, QM_REG_VOQCREDIT_0,

line 422*/{(0x10), 3, QM_REG_VOQCREDIT_1,

line 423*/{(0x10), 3, QM_REG_VOQCREDIT_2,

line 424*/{(0x10), 3, QM_REG_VOQCREDIT_3,

line 425*/{(0x10), 3, QM_REG_VOQCREDIT_4,

line 426*/{(0x10), 3, QM_REG_VOQCREDIT_5,

line 427*/{(0x10), 3, QM_REG_VOQCREDIT_6,

line 428*/{(0x10), 3, QM_REG_BYTECRD0,

line 429*/{(0x10), 3, QM_REG_BYTECRD1,

line 430*/{(0x10), 3, QM_REG_BYTECRD2,

line 431*/{(0x10), 3, QM_REG_BYTECRD3,

line 432*/{(0x10), 3, QM_REG_BYTECRD4,

line 433*/{(0x10), 3, QM_REG_BYTECRD5,

line 434*/{(0x10), 3, QM_REG_BYTECRD6,

line 435*/{(0x10), 1, QM_REG_FWVOQ0TOHWVOQ,

line 436*/{(0x10), 1, QM_REG_FWVOQ1TOHWVOQ,

line 437*/{(0x10), 1, QM_REG_FWVOQ2TOHWVOQ,

line 438*/{(0x10), 1, QM_REG_FWVOQ3TOHWVOQ,

line 439*/{(0x10), 1, QM_REG_FWVOQ4TOHWVOQ,

line 440*/{(0x10), 1, QM_REG_FWVOQ5TOHWVOQ,

line 441*/{(0x10), 1, QM_REG_FWVOQ6TOHWVOQ,

line 442*/{(0x10), 1, QM_REG_FWVOQ7TOHWVOQ,

line 443*/{(0x1F), 1, NIG_REG_INGRESS_EOP_PORT0_EMPTY,

line 444*/{(0x1F), 1, NIG_REG_INGRESS_EOP_PORT1_EMPTY,

line 445*/{(0x1F), 1, NIG_REG_INGRESS_EOP_LB_EMPTY,

line 446*/{(0x1F), 1, NIG_REG_INGRESS_RMP0_DSCR_EMPTY,

line 447*/{(0x1F), 1, NIG_REG_INGRESS_RMP1_DSCR_EMPTY,

line 448*/{(0x1F), 1, NIG_REG_INGRESS_LB_PBF_DELAY_EMPTY,

line 449*/{(0x1F), 1, NIG_REG_EGRESS_MNG0_FIFO_EMPTY,

line 450*/{(0x1F), 1, NIG_REG_EGRESS_MNG1_FIFO_EMPTY,

line 451*/{(0x1F), 1, NIG_REG_EGRESS_DEBUG_FIFO_EMPTY,

line 452*/{(0x1F), 1, NIG_REG_EGRESS_DELAY0_EMPTY,

line 453*/{(0x1F), 1, NIG_REG_EGRESS_DELAY1_EMPTY,

line 454*/{(0x1F), 1, NIG_REG_LLH0_FIFO_EMPTY,

line 455*/{(0x1F), 1, NIG_REG_LLH1_FIFO_EMPTY,

line 456*/{(0x1C), 1, NIG_REG_P0_TX_MNG_HOST_FIFO_EMPTY,

line 457*/{(0x1C), 1, NIG_REG_P1_TX_MNG_HOST_FIFO_EMPTY,

line 458*/{(0x1C), 1, NIG_REG_P0_TLLH_FIFO_EMPTY,

line 459*/{(0x1C), 1, NIG_REG_P1_TLLH_FIFO_EMPTY,

line 460*/{(0x1C), 1, NIG_REG_P0_HBUF_DSCR_EMPTY,

line 461*/{(0x1C), 1, NIG_REG_P1_HBUF_DSCR_EMPTY,

line 462*/{(0x18), 1, NIG_REG_P0_RX_MACFIFO_EMPTY,

line 463*/{(0x18), 1, NIG_REG_P1_RX_MACFIFO_EMPTY,

line 464*/{(0x18), 1, NIG_REG_P0_TX_MACFIFO_EMPTY,

line 465*/{(0x18), 1, NIG_REG_P1_TX_MACFIFO_EMPTY,

line 466*/{(0x10), 1, NIG_REG_EGRESS_DELAY2_EMPTY,

line 467*/{(0x10), 1, NIG_REG_EGRESS_DELAY3_EMPTY,

line 468*/{(0x10), 1, NIG_REG_EGRESS_DELAY4_EMPTY,

line 469*/{(0x10), 1, NIG_REG_EGRESS_DELAY5_EMPTY,

 handle self test fails according to severity and type */

 specific test for QM rd/wr pointers and rd/wr banks */

 read regs */

 calc read and write pointers */

 perfrom pointer test */

 calculate read and write banks */

 perform bank test */

 specific test for cfc info ram and cid cam */

 iterate through lcids */

 make sure cam entry is valid (bit 0) */

 get connection type (multiple reads due to widebus) */

 obtain connection type */

 E1 E1H (bits 4..7) */

 E2 E3A0 E3B0 (bits 26..29) */

 get activity counter value */

 validate ac value is legal for con_type at idle state */

/* self test procedure

 * scan auto-generated database

 * for each line:

 * 1.	compare chip mask

 * 2.	determine type (according to maro number)

 * 3.	read registers

 * 4.	call predicate

 * 5.	collate results and statistics

 loop counter */

 self test database access index */

 current record variable */

 message to log */

init stats*/

create masks for all chip types*/

database main loop*/

check if test applies to chip*/

 identify macro */

 read single reg and call predicate */

			/* read repeatedly starting from reg1 and call

			 * predicate after each read

 read two regs and call predicate */

unused to-date*/

			/* compare two regs, pending

			 * the value of a condition reg

			/* compare read and write pointers

			 * and read and write banks in QM

 compare cfc info cam with cid cam */

 abort if interface is not running */

 return value accorindg to statistics */

/* bnx2x_sriov.c: QLogic Everest network driver.

 *

 * Copyright 2009-2013 Broadcom Corporation

 * Copyright 2014 QLogic Corporation

 * All rights reserved

 *

 * Unless you and QLogic execute a separate written software license

 * agreement governing use of this software, this software is licensed to you

 * under the terms of the GNU General Public License version 2, available

 * at http://www.gnu.org/licenses/old-licenses/gpl-2.0.html (the "GPL").

 *

 * Notwithstanding the above, under no circumstances may you combine this

 * software in any way with any other QLogic software provided under a

 * license other than the GPL, without QLogic's express prior written

 * consent.

 *

 * Maintained by: Ariel Elior <ariel.elior@qlogic.com>

 * Written by: Shmulik Ravid

 *	       Ariel Elior <ariel.elior@qlogic.com>

 *

 General service functions */

 acking a VF sb through the PF - use the GRC */

 VFOP operations states */

 INIT */

 Enable host coalescing in the transition to INIT state */

 FW SB ID */

 context */

 SETUP */

 Setup-op general parameters */

	/* Setup-op flags:

	 * collect statistics, zero statistics, local-switching, security,

	 * OV for Flex10, RSS and MCAST for leading

	/* for VFs, enable tx switching, bd coherency, and mac address

	 * anti-spoofing

 Setup-op rx parameters */

 Setup-op tx parameters */

 Prepare ramrod information */

 Run Queue 'construction' ramrods */

 enable interrupts */

 Prepare ramrod information */

 Run Queue 'destruction' ramrods */

 Clean Context */

 the first igu entry belonging to VFs of this PF */

 the first igu entry belonging to this VF */

 Prepare ramrod params */

 Start deleting */

 Prepare ramrod params */

 Add/Remove the filter */

 Prepare ramrod params */

 Rollback if needed */

 It's our responsibility to free the filters */

 Schedule the configuration of any pending vlan filters */

 If needed, clean the filtering data base */

 Terminate queue */

 Prepare Multicast command */

 add new mcasts */

 clear existing mcasts */

 Remove all classification configuration for leading queue */

 Remove filtering if feasible */

 Destroy queue */

/* VF enable primitives

 * when pretend is required the caller is responsible

 * for calling pretend prior to calling these routines

/* internal vf enable - until vf is enabled internally all transactions

 * are blocked. This routine should always be called last with pretend.

 clears vf error in all semi blocks */

 Set VF masks and configuration - pretend */

 iterate over all queues, clear sb consumer */

 zero prod memory */

 clear sb state machine */

 VF */);

 disable + update */

 set the VF-PF association in the FW */

 clear vf errors*/

 internal vf-enable - pretend */

 Reset vf in IGU  interrupts are still disabled */

 pretend to enable the vf with the PBF */

 Verify no pending pci transactions */

/* must be called after the number of PF queues and the number of VFs are

 * both known

 will be set only during VF-ACQUIRE */

 no real limitation */

 num_sbs already set */

 FLR routines: */

 reset the state variables */

 DQ usage counter */

 FW cleanup command - poll for the results */

 verify TX hw is flushed */

	/* the cleanup operations are valid if and only if the VF

	 * was first acquired.

 remove multicasts */

 dispatch final cleanup and wait for HW queues to flush */

 release VF resources */

 re-open the mailbox */

 VF should be RESET & in FLR cleanup states */

 lock the vf pf channel */

 invoke the VF FLR SM */

 mark the VF to be ACKED and continue */

	/* Acknowledge the handled VFs.

	 * we are acknowledge all the vfs which an flr was requested for, even

	 * if amongst them there are such that we never opened, since the mcp

	 * will interrupt us immediately again if we only ack some of the bits,

	 * resulting in an endless loop. This can happen for example in KVM

	 * where an 'all ones' flr request is sometimes given by hyper visor

	/* clear the acked bits - better yet if the MCP implemented

	 * write to clear semantics

 Read FLR'd VFs */

 set as reset and ready for cleanup */

 do the FLR cleanup for all marked VFs*/

 IOV global initialization routines  */

 Set the DQ such that the CID reflect the abs_vfid */

	/* Set VFs starting CID. If its > 0 the preceding CIDs are belong to

	 * the PF L2 queues

 The VF window size is the log2 of the max number of CIDs per VF */

	/* The VF doorbell size  0 - *B, 4 - 128B. We set it here to match

	 * the Pf doorbell size although the 2 are independent.

	/* No security checks for now -

	 * configure single rule (out of 16) mask = 0x1, value = 0x0,

	 * CID range 0 - 0x1ffff

	/* set the VF doorbell threshold. This threshold represents the amount

	 * of doorbells allowed in the main DORQ fifo for a specific VF.

 IGU in normal mode - read CAM */

	/* read the SRIOV capability structure

	 * The fields can be read via configuration read or

	 * directly from the device (starting at offset PCICFG_OFFSET)

 get the number of SRIOV bars */

 read the first_vfid */

 must be called after PF bars are mapped */

 verify is pf */

 verify sriov capability is present in configuration space */

 verify chip revision */

 check if SRIOV support is turned off */

 SRIOV assumes that num of PF CIDs < BNX2X_FIRST_VF_CID */

 SRIOV can be enabled only with MSIX */

 verify ari is enabled */

 verify igu is in normal mode */

 allocate the vfs database */

	/* get the sriov info - Linux already collected all the pertinent

	 * information, however the sriov structure is for the private use

	 * of the pci module. Also we want this information regardless

	 * of the hyper-visor.

 SR-IOV capability was enabled but there are no VFs*/

 allocate the vf array */

 Initial VF init - index and abs_vfid - nr_virtfn must be set */

 enable spoofchk by default */

 re-read the IGU CAM for VFs - index and abs_vfid must be set */

 allocate the queue arrays for all VFs */

 Prepare the VFs event synchronization mechanism */

 if SRIOV is not enabled there's nothing to do */

 disable access to all VFs */

 free vf database */

 free vfs hw contexts */

 allocate vfs hw contexts */

 allocate vfs ramrods dma memory - client_init and set_mac */

 allocate mailboxes */

 allocate local bulletin boards */

 Queue State object */

 sp indication is set only when vlan/mac/etc. are initialized */

 assume lowest supported speed is 10G */

 sanity and init */

 Post update on VF's bulletin board */

 nothing todo */

 called by bnx2x_nic_load */

 let FLR complete ... */

 initialize vf database */

 init statically provisioned resources */

 queues are initialized during VF-ACQUIRE */

		/*  init mcast object - This object will be re-initialized

		 *  during VF-ACQUIRE with the proper cl_id and cid.

		 *  It needs to be initialized here so that it can be safely

		 *  handled by a subsequent FLR flow.

 set the mailbox message addresses */

 Enable vf mailbox */

 Final VF init */

 fill in the BDF and bars */

 called by bnx2x_chip_cleanup */

 release all the VFs */

 called by bnx2x_init_hw_func, returns the next ilt line */

 set vfs ilt lines */

 doesn't matter */

 Always push next commands out, don't wait here */

 If there are pending mcast commands - send them */

	/* first get the cid - the only events we handle here are cfc-delete

	 * and set-mac completion

 check if the cid is the VF range */

	/* extract vf and rxq index from vf_cid - relies on the following:

	 * 1. vfid on cid reflects the true abs_vfid

	 * 2. The max number of VFs (per path) is 64

 Do nothing for now */

	/* extract the vf from vf_cid - relies on the following:

	 * 1. vfid on cid reflects the true abs_vfid

	 * 2. The max number of VFs (per path) is 64

		/* extract queue index from vf_cid - relies on the following:

		 * 1. vfid on cid reflects the true abs_vfid

		 * 2. The max number of VFs (per path) is 64

 fcoe adds one global request and one queue request */

 collect stats fro active queues only */

 create stats query entry for this queue */

 all stats are coalesced to the leading queue */

 VF API helpers */

 clear the VF configuration - pretend */

 CORE VF API */

	/* if state is 'acquired' the VF was not released or FLR'd, in

	 * this case the returned resources match the acquired already

	 * acquired resources. Verify that the requested numbers do

	 * not exceed the already acquired numbers.

 Otherwise vf state must be 'free' or 'reset' */

	/* static allocation:

	 * the global maximum number are fixed per VF. Fail the request if

	 * requested number exceed these globals

 set the max resource in the vf */

 Set resources counters - 0 request means max available */

 Initialize the queues */

 init SP objects */

	/* the sb resources are initialized at this point, do the

	 * FW/HW initializations

 Sanity checks */

 let FLR complete ... */

 FLR cleanup epilogue */

 reset IGU VF statistics: MSIX */

 function setup */

 Enable the vf */

 queue protection table */

 update vf bulletin board */

 Close all queues */

 disable the interrupts */

 disable the VF */

	/* need to make sure there are no outstanding stats ramrods which may

	 * cause the device to access the VF's stats buffer which it will free

	 * as soon as we return from the close flow.

/* VF release can be called either: 1. The VF was acquired but

 * not enabled 2. the vf was enabled or in the process of being

 * enabled

 to release resources */

 Set ramrod params */

/* VF release ~ VF close + VF release-resources

 * Release is the ultimate SW shutdown and is called whenever an

 * irrecoverable error is encountered.

 we don't lock the channel for unsupported tlvs */

 lock the channel */

 record the locking op */

 log the lock */

 we don't unlock the channel for unsupported tlvs */

 record the locking op */

 lock the channel */

 log the unlock */

 Verify changes are needed and record current Tx switching state */

 Verify state enables the sending of queue ramrods */

 send q. update ramrod to configure Tx switching */

 send the ramrod on all the queues of the PF */

 Set the appropriate Queue object */

 Update the Queue state */

 HW channel is only operational when PF is up */

 we are always bound by the total_vfs in the configuration space */

 statically distribute vf sb pool between VFs */

 zero previous values learned from igu cam */

 prepare IGU cam */

 Reinitialize vf database according to igu cam */

 set local queue arrays */

	/* prepare msix vectors in VF configuration space - the value in the

	 * PCI configuration space should be the index of the last entry,

	 * namely one less than the actual size of the table

	/* enable sriov. This will probe all the VFs, and consequentially cause

	 * the "acquire" messages to appear on the VF PF channel.

 init members */

 sanity and init */

 always 10G. TBA take from link struct */

 mac and vlan are in vlan_mac objects */

 mac */

 mac configured by ndo so its in bulletin board */

 function has not been loaded yet. Show mac as 0s */

 vlan */

 vlan configured by ndo so its in bulletin board */

 function has not been loaded yet. Show vlans as 0s */

/* New mac for VF. Consider these cases:

 * 1. VF hasn't been acquired yet - save the mac in local bulletin board and

 *    supply at acquire.

 * 2. VF has already been acquired but has not yet initialized - store in local

 *    bulletin board. mac will be posted on VF bulletin board after VF init. VF

 *    will configure this mac when it is ready.

 * 3. VF has already initialized but has not yet setup a queue - post the new

 *    mac on VF's bulletin board right now. VF will configure this mac when it

 *    is ready.

 * 4. VF has already set a queue - delete any macs already configured for this

 *    queue and manually config the new mac.

 * In any event, once this function has been called refuse any attempts by the

 * VF to configure any mac for itself except for this mac. In case of a race

 * where the VF fails to see the new post on its bulletin board before sending a

 * mac configuration request, the PF will simply fail the request and VF can try

 * again after consulting its bulletin board.

 sanity and init */

	/* update PF's copy of the VF's bulletin. Will no longer accept mac

	 * configuration requests from vf unless match this mac

 Post update on VF's bulletin board */

 release lock before checking return code */

 configure the mac in device on this vf's queue */

 User should be able to see failure reason in system logs */

 must lock vfpf channel to protect against vf flows */

 remove existing eth macs */

 remove existing uc list macs */

 configure the new mac to device */

 need to remove/add the VF's accept_any_vlan bit */

 configure the new vlan to device */

 sanity and init */

	/* update PF's copy of the VF's bulletin. No point in posting the vlan

	 * to the VF since it doesn't have anything to do with it. But it useful

	 * to store it here in case the VF is not up yet and we can only

	 * configure the vlan later when it does. Treat vlan id 0 as remove the

	 * Host tag.

 Post update on VF's bulletin board */

 is vf initialized and queue set up? */

 User should be able to see error in system logs */

 must lock vfpf channel to protect against vf flows */

 remove existing vlans */

	/* clear accept_any_vlan when HV forces vlan, otherwise

	 * according to VF capabilities

	/* send queue update ramrods to configure default vlan and

	 * silent vlan removal

 validate the Q is UP */

			/* if vlan is 0 then we want to leave the VF traffic

			 * untagged, and leave the incoming traffic untouched

			 * (i.e. do not remove any vlan tags).

			/* configure default vlan to vf queue and set silent

			 * vlan removal (the vf remains unaware of this vlan).

 Update the Queue state */

 nothing to do */

 is vf initialized and queue set up? */

 User should be able to see error in system logs */

 send queue update ramrods to configure spoofchk */

 validate the Q is UP */

 Update the Queue state */

/* crc is the first field in the bulletin board. Compute the crc over the

 * entire bulletin board excluding the crc field itself. Use the length field

 * as the Bulletin Board was posted by a PF with possibly a different version

 * from the vf which will sample it. Therefore, the length is computed by the

 * PF and then used blindly by the VF.

 Check for new posts on the bulletin board */

	/* sampling structure in mid post may result with corrupted data

	 * validate crc to ensure coherency.

 sample the bulletin board */

 bulletin board hasn't changed since last sample */

 the mac address in bulletin board is valid and is new */

 update new mac to net device */

 Link is down */

 Full DUPLEX */

 Rx Flow Control is ON */

 Tx Flow Control is ON */

 copy new bulletin board to bp */

 if channel is down we need to self destruct */

 vf doorbells are embedded within the regview */

 allocate vf2pf mailbox for vf to pf channel */

 allocate pf 2 vf bulletin board */

		/* locate this VFs bulletin board and update the channel down

		 * bit

 update vf bulletin board */

/* bnx2x_vfpf.c: QLogic Everest network driver.

 *

 * Copyright 2009-2013 Broadcom Corporation

 * Copyright 2014 QLogic Corporation

 * All rights reserved

 *

 * Unless you and QLogic execute a separate written software license

 * agreement governing use of this software, this software is licensed to you

 * under the terms of the GNU General Public License version 2, available

 * at http://www.gnu.org/licenses/old-licenses/gpl-2.0.html (the "GPL").

 *

 * Notwithstanding the above, under no circumstances may you combine this

 * software in any way with any other QLogic software provided under a

 * license other than the GPL, without QLogic's express prior written

 * consent.

 *

 * Maintained by: Ariel Elior <ariel.elior@qlogic.com>

 * Written by: Shmulik Ravid

 *	       Ariel Elior <ariel.elior@qlogic.com>

 place a given tlv on the tlv buffer at a given offset */

 Clear the mailbox and init the header of the first tlv */

 Clear mailbox */

 init type and length */

 init first tlv header */

 releases the mailbox */

 Finds a TLV by type in a TLV buffer; If found, returns pointer to the TLV */

 list the types and lengths of the tlvs on the buffer */

 output tlv */

 advance to next tlv */

 cast general tlv list pointer to channel tlv header*/

 break condition for this loop */

 output last tlv */

 test whether we support a tlv type */

 wait for 10 seconds */

	/* if PF indicated channel is down avoid sending message. Return success

	 * so calling flow can continue

 Write message address */

 make sure the address is written before FW accesses it */

 Trigger the PF FW */

 Wait for PF to complete */

		/* progress indicator - HV can take its own sweet time in

		 * answering VFs...

 Wait for 1 sec */

 pxp traps vf read of doorbells and returns me reg value */

 clear mailbox and prep first tlv */

 pf 2 vf bulletin board address */

 Request physical port identifier */

 Bulletin support for bulletin board with length > legacy length */

 vlan filtering is supported */

 add list termination tlv */

 output tlvs list */

 send acquire request */

 PF timeout */

 copy acquire response from buffer to bp */

		/* test whether the PF accepted our request. If not, humble

		 * the request and try again.

 humble our request */

 Clear response buffer */

 Determine reason of PF failure of acquire process */

 Retrieve physical port id (if possible) */

	/* Old Hypevisors might not even support the FP_HSI_SUPPORT TLV.

	 * If that's the case, we need to make certain required FW was

	 * supported by such a hypervisor [i.e., v0-v2].

		/* Since acquire succeeded on the PF side, we need to send a

		 * release message in order to allow future probes.

 get HW info */

 clear mailbox and prep first tlv */

 add list termination tlv */

 output tlvs list */

 send release request */

 PF timeout */

 PF released us */

 PF reports error */

 Tell PF about SB addresses */

 clear mailbox and prep first tlv */

 status blocks */

 statistics - requests only supports single queue for now */

 add list termination tlv */

 output tlvs list */

 CLOSE VF - opposite to INIT_VF */

	/* If we haven't got a valid VF id, there is no sense to

	 * continue with sending messages

 Close the queues */

 remove mac */

 clear mailbox and prep first tlv */

 add list termination tlv */

 output tlvs list */

 Disable HW interrupts, NAPI */

 Delete all NAPI objects */

 Release IRQs */

 mac */

 vlan */

 vlan-mac */

 mcast */

 rss */

 ask the pf to open a queue for the vf */

 clear mailbox and prep first tlv */

 select tpa mode to request */

 calculate queue flags */

 Common */

 Rx */

 No stats at the moment */

 Tx */

 add list termination tlv */

 output tlvs list */

 clear mailbox and prep first tlv */

 add list termination tlv */

 output tlvs list */

 PF failed the transaction */

 request pf to add a mac for the vf */

 clear mailbox and prep first tlv */

 sample bulletin board for new mac */

 copy mac from device to request */

 add list termination tlv */

 output tlvs list */

 send message to pf */

 failure may mean PF was configured with a new mac for us */

 copy mac from bulletin to device */

 check if bulletin board was updated */

 copy mac from device to request */

 send message to pf */

 no new info in bulletin */

 request pf to config rss table for vf queues*/

 clear mailbox and prep first tlv */

 add list termination tlv */

 flags handled individually for backward/forward compatibility */

 output tlvs list */

 send message to pf */

		/* Since older drivers don't support this feature (and VF has

		 * no way of knowing other than failing this), don't propagate

		 * an error in this case.

 clear mailbox and prep first tlv */

 Get Rx mode requested */

 We support PFVF_MAX_MULTICAST_PER_VF mcast addresses tops */

 add list termination tlv */

 output tlvs list */

 request pf to add a vlan for the vf */

 clear mailbox and prep first tlv */

 sample bulletin board for hypervisor vlan */

 add list termination tlv */

 output tlvs list */

 send message to pf */

 clear mailbox and prep first tlv */

 Ignore everything accept MODE_NONE */

		/* Current PF driver will not look at the specific flags,

		 * but they are required when working with older drivers on hv.

 add list termination tlv */

 output tlvs list */

 General service functions */

 enable vf_pf mailbox (aka vf-pf-channel) */

 enable the mailbox in the FW */

 enable the VF access to the mailbox */

 this works only on !E1h */

 set opcode and fixed command fields */

 issue the command and wait for completion */

 prepare response */

 send response */

	/* Copy the response buffer. The first u64 is written afterwards, as

	 * the vf is sensitive to the header being written

 ack the FW */

	/* copy the response header including status-done field,

	 * must be last dmae, must be after FW is acked

 unlock channel mutex */

	/* Offset should continue representing the offset to the tail

	 * of TLV data (outside this function scope)

	/* Offset should continue representing the offset to the tail

	 * of TLV data (outside this function scope)

 fill in pfdev info */

		/* set resources numbers, if status equals NO_RESOURCE these

		 * are max possible numbers

 fill in the allocated resources */

 if a mac has been set for this vf, supply it */

 prepare response */

	/* Handle possible VF requests for physical port identifiers.

	 * 'length' should continue to indicate the offset of the first empty

	 * place in the buffer (i.e., where next TLV should be inserted)

	/* `New' vfs will want to know if fastpath HSI is supported, since

	 * if that's not the case they could print into system log the fact

	 * the driver version must be updated.

 send the response */

	/* Windows driver does one of three things:

	 * 1. Old driver doesn't have bulletin board address set.

	 * 2. 'Middle' driver sends mc_num == 32.

	 * 3. New driver sets the OS field.

	/* Linux drivers which correctly set the doorbell size also

	 * send a physical port request

 Issue does not exist in windows VMs */

 log vfdef info */

	/* Prevent VFs with old drivers from loading, since they calculate

	 * CIDs incorrectly requiring a VF-flr [VM reboot] in order to recover

	 * while being upgraded.

	/* Verify the VF fastpath HSI can be supported by the loaded FW.

	 * Linux vfs should be oblivious to changes between v0 and v2.

 acquire the resources */

 store address of vf's bulletin board */

 response */

 record ghost addresses from vf message */

 set VF multiqueue statistics collection mode */

 Update VF's view of link state */

 response */

 convert MBX queue-flags to standard SP queue-flags */

 outer vlan removal is set according to PF's multi function mode */

 verify vf_qid */

	/* tx queues must be setup alongside rx queues thus if the rx queue

	 * is not marked as valid there's nothing to do.

 re-init the VF operation context */

 activate immediately */

 save sb resource index */

 tx init */

 tx setup - flags */

 tx setup - general, nothing */

 tx setup - tx */

			/* Note: there is no support for different SBs

			 * for TX and RX

 rx init */

 rx setup - flags */

 rx setup - general */

 rx setup - rx */

 rx setup - multicast engine */

 complete the preparations */

 check for any mac/vlan changes */

 build vlan-mac list */

 set vlan-mac list */

 build mac list */

 set mac list */

 build vlan list */

 set vlan list */

 Ignore VF requested mode; instead set a regular mode */

		/* any_vlan is not configured if HV is forcing VLAN

		 * any_vlan is configured if

		 *   1. VF does not support vlan filtering

		 *   OR

		 *   2. VF supports vlan filtering and explicitly requested it

 set rx-mode */

 set mcasts */

	/* if a mac was already set for this VF via the set vf mac ndo, we only

	 * accept mac configurations of that mac. Why accept them at all?

	 * because PF may have been unable to configure the mac at the time

	 * since queue was not set up.

			/* once a mac was set by ndo can only accept

			 * a single mac...

 ...and only the mac set by the ndo */

 if vlan was set by hypervisor we don't allow guest to config vlan */

 search for vlan filters */

 verify vf_qid */

 print q_filter message */

 set vfop params according to rss tlv */

 flags handled individually for backward/forward compatibility */

 dispatch request */

		/* Just ack the FW and return if VFs are lost

		 * in case of parity error. VFs are supposed to be timedout

		 * on waiting for PF response.

 check if tlv type is known */

		/* Lock the per vf op mutex and note the locker's identity.

		 * The unlock will take place in mbx response.

 switch on the opcode */

		/* unknown TLV - this may belong to a VF driver from the future

		 * - a version written after this PF driver was written, which

		 * supports features unknown as of yet. Too bad since we don't

		 * support them. Or this may be because someone wrote a crappy

		 * VF driver and is sending garbage over the channel.

 can we respond to VF (do we have an address for it?) */

 notify the VF that we do not support this request */

		/* can't send a response since this VF is unknown to us

		 * just ack the FW to release the mailbox and unlock

		 * the channel.

 Firmware ack should be written before unlocking channel */

 Sanity checks consider removing later */

 check if the vf_id is valid */

 Update VFDB with current message and schedule its handling */

 handle new vf-pf messages */

 Handle VFs which have pending events */

 dmae to get the VF request */

 process the VF message header */

		/* Clean response buffer to refrain from falsely

		 * seeing chains.

 dispatch the request (will prepare the response) */

	/* Older VFs contain a bug where they can't check CRC for bulletin

	 * boards of length greater than legacy size.

 propagate local bulletin board to vf */

 can only update vf after init took place */

 increment bulletin board version and compute crc */

 propagate bulletin board via dmae to vm memory */

/* bnx2x_sp.c: Qlogic Everest network driver.

 *

 * Copyright 2011-2013 Broadcom Corporation

 * Copyright (c) 2014 QLogic Corporation

 * All rights reserved

 *

 * Unless you and Qlogic execute a separate written software license

 * agreement governing use of this software, this software is licensed to you

 * under the terms of the GNU General Public License version 2, available

 * at http://www.gnu.org/licenses/gpl-2.0.html (the "GPL").

 *

 * Notwithstanding the above, under no circumstances may you combine this

 * software in any way with any other Qlogic software provided under a

 * license other than the GPL, without Qlogic's express prior written

 * consent.

 *

 * Maintained by: Ariel Elior <ariel.elior@qlogic.com>

 * Written by: Vladislav Zolotarov

 *

*** Exe Queue interfaces ****/

/**

 * bnx2x_exe_queue_init - init the Exe Queue object

 *

 * @bp:		driver handle

 * @o:		pointer to the object

 * @exe_len:	length

 * @owner:	pointer to the owner

 * @validate:	validate function pointer

 * @remove:	remove function pointer

 * @optimize:	optimize function pointer

 * @exec:	execute function pointer

 * @get:	get function pointer

 Owner specific callbacks */

/**

 * bnx2x_exe_queue_add - add a new element to the execution queue

 *

 * @bp:		driver handle

 * @o:		queue

 * @elem:	new command to add

 * @restore:	true - do not optimize the command

 *

 * If the element is optimized or is illegal, frees it.

 Try to cancel this element queue */

 Check if this request is ok */

 If so, add it to the execution queue */

/**

 * bnx2x_exe_queue_step - execute one execution chunk atomically

 *

 * @bp:			driver handle

 * @o:			queue

 * @ramrod_flags:	flags

 *

 * (Should be called while holding the exe_queue->lock).

	/* Next step should not be performed until the current is finished,

	 * unless a DRV_CLEAR_ONLY bit is set. In this case we just want to

	 * properly clear object internals without sending any command to the FW

	 * which also implies there won't be any completion to clear the

	 * 'pending' list.

	/* Run through the pending commands list and create a next

	 * execution chunk.

			/* Prevent from both lists being empty when moving an

			 * element. This will allow the call of

			 * bnx2x_exe_queue_empty() without locking.

 Sanity check */

		/* In case of an error return the commands back to the queue

		 * and reset the pending_comp.

		/* If zero is returned, means there are no outstanding pending

		 * completions and we may dismiss the pending list.

 Don't reorder!!! */

*********************** raw_obj functions ***********************************/

/**

 * bnx2x_state_wait - wait until the given bit(state) is cleared

 *

 * @bp:		device handle

 * @state:	state which is to be cleared

 * @pstate:	state buffer

 *

 can take a while if any port is running */

 timeout! */

**************** Classification verbs: Set/Del MAC/VLAN/VLAN-MAC ************/

 credit handling callbacks */

/**

 * __bnx2x_vlan_mac_h_write_trylock - try getting the vlan mac writer lock

 *

 * @bp:		device handle

 * @o:		vlan_mac object

 *

 * Context: Non-blocking implementation; should be called under execution

 *          queue lock.

/**

 * __bnx2x_vlan_mac_h_exec_pending - execute step instead of a previous step

 *

 * @bp:		device handle

 * @o:		vlan_mac object

 *

 * details Should be called under execution queue lock; notice it might release

 *          and reclaim it during its run.

/**

 * __bnx2x_vlan_mac_h_pend - Pend an execution step which couldn't run

 *

 * @bp:			device handle

 * @o:			vlan_mac object

 * @ramrod_flags:	ramrod flags of missed execution

 *

 * Context: Should be called under execution queue lock.

/**

 * __bnx2x_vlan_mac_h_write_unlock - unlock the vlan mac head list writer lock

 *

 * @bp:			device handle

 * @o:			vlan_mac object

 *

 * Context: Should be called under execution queue lock. Notice if a pending

 *          execution exists, it would perform it - possibly releasing and

 *          reclaiming the execution queue lock.

	/* It's possible a new pending execution was added since this writer

	 * executed. If so, execute again. [Ad infinitum]

/**

 * __bnx2x_vlan_mac_h_read_lock - lock the vlan mac head list reader lock

 *

 * @bp:			device handle

 * @o:			vlan_mac object

 *

 * Context: Should be called under the execution queue lock. May sleep. May

 *          release and reclaim execution queue lock during its run.

 If we got here, we're holding lock --> no WRITER exists */

/**

 * bnx2x_vlan_mac_h_read_lock - lock the vlan mac head list reader lock

 *

 * @bp:			device handle

 * @o:			vlan_mac object

 *

 * Context: May sleep. Claims and releases execution queue lock during its run.

/**

 * __bnx2x_vlan_mac_h_read_unlock - unlock the vlan mac head list reader lock

 *

 * @bp:			device handle

 * @o:			vlan_mac object

 *

 * Context: Should be called under execution queue lock. Notice if a pending

 *          execution exists, it would be performed if this was the last

 *          reader. possibly releasing and reclaiming the execution queue lock.

	/* It's possible a new pending execution was added, and that this reader

	 * was last - if so we need to execute the command.

 Writer release will do the trick */

/**

 * bnx2x_vlan_mac_h_read_unlock - unlock the vlan mac head list reader lock

 *

 * @bp:			device handle

 * @o:			vlan_mac object

 *

 * Context: Notice if a pending execution exists, it would be performed if this

 *          was the last reader. Claims and releases the execution queue lock

 *          during its run.

 traverse list */

 check_add() callbacks */

 Check if a requested MAC already exists */

 check_del() callbacks */

 check_move() callback */

	/* Check if we can delete the requested configuration from the first

	 * object.

  check if configuration can be added */

	/* If this classification can not be added (is already set)

	 * or can't be deleted - return an error.

 LLH_FUNC_MEM is a u64 WB register */

/**

 * bnx2x_vlan_mac_set_cmd_hdr_e2 - set a header in a single classify ramrod

 *

 * @bp:		device handle

 * @o:		queue for which we want to configure this rule

 * @add:	if true the command is an ADD command, DEL otherwise

 * @opcode:	CLASSIFY_RULE_OPCODE_XXX

 * @hdr:	pointer to a header to setup

 *

 Rx or/and Tx (internal switching) configuration ? */

/**

 * bnx2x_vlan_mac_set_rdata_hdr_e2 - set the classify ramrod data header

 *

 * @cid:	connection id

 * @type:	BNX2X_FILTER_XXX_PENDING

 * @hdr:	pointer to header to setup

 * @rule_cnt:

 *

 * currently we always configure one rule and echo field to contain a CID and an

 * opcode type.

 hw_config() callbacks */

	/* Set LLH CAM entry: currently only iSCSI and ETH macs are

	 * relevant. In addition, current implementation is tuned for a

	 * single ETH MAC.

	 *

	 * When multiple unicast ETH MACs PF configuration in switch

	 * independent mode is required (NetQ, multiple netdev MACs,

	 * etc.), consider better utilisation of 8 per function MAC

	 * entries in the LLH register. There is also

	 * NIG_REG_P[01]_LLH_FUNC_MEM2 registers that complete the

	 * total number of CAM entries to 16.

	 *

	 * Currently we won't configure NIG for MACs other than a primary ETH

	 * MAC and iSCSI L2 MAC.

	 *

	 * If this MAC is moving from one Queue to another, no need to change

	 * NIG configuration.

 Reset the ramrod data buffer for the first rule */

 Setup a command header */

 Set a MAC itself */

 MOVE: Add a rule that will add this MAC to the target Queue */

 Setup ramrod data */

 Set a MAC itself */

 Set the ramrod data header */

	/* TODO: take this to the higher level in order to prevent multiple

/**

 * bnx2x_vlan_mac_set_rdata_hdr_e1x - set a header in a single classify ramrod

 *

 * @bp:		device handle

 * @o:		queue

 * @type:	the type of echo

 * @cam_offset:	offset in cam memory

 * @hdr:	pointer to a header to setup

 *

 * E1/E1H

 Set a MAC in a ramrod data */

/**

 * bnx2x_set_one_mac_e1x - fill a single MAC rule ramrod data

 *

 * @bp:		device handle

 * @o:		bnx2x_vlan_mac_obj

 * @elem:	bnx2x_exeq_elem

 * @rule_idx:	rule_idx

 * @cam_offset: cam_offset

	/* 57710 and 57711 do not support MOVE command,

	 * so it's either ADD or DEL

 Reset the ramrod data buffer */

 Reset the ramrod data buffer for the first rule */

 Set a rule header */

 Set a VLAN itself */

 MOVE: Add a rule that will add this MAC to the target Queue */

 Setup ramrod data */

 Set a VLAN itself */

 Set the ramrod data header */

	/* TODO: take this to the higher level in order to prevent multiple

 Reset the ramrod data buffer for the first rule */

 Set a rule header */

 Set VLAN and MAC themselves */

 MOVE: Add a rule that will add this MAC/VLAN to the target Queue */

 Setup ramrod data */

 Set a VLAN itself */

 Set the ramrod data header */

/**

 * bnx2x_set_one_vlan_mac_e1h -

 *

 * @bp:		device handle

 * @o:		bnx2x_vlan_mac_obj

 * @elem:	bnx2x_exeq_elem

 * @rule_idx:	rule_idx

 * @cam_offset:	cam_offset

	/* 57710 and 57711 do not support MOVE command,

	 * so it's either ADD or DEL

 Reset the ramrod data buffer */

/**

 * bnx2x_vlan_mac_restore - reconfigure next MAC/VLAN/VLAN-MAC element

 *

 * @bp:		device handle

 * @p:		command parameters

 * @ppos:	pointer to the cookie

 *

 * reconfigure next MAC/VLAN/VLAN-MAC element from the

 * previously configured elements list.

 *

 * from command parameters only RAMROD_COMP_WAIT bit in ramrod_flags is	taken

 * into an account

 *

 * pointer to the cookie  - that should be given back in the next call to make

 * function handle the next element. If *ppos is set to NULL it will restart the

 * iterator. If returned *ppos == NULL this means that the last element has been

 * handled.

 *

 If list is empty - there is nothing to do here */

 make a step... */

 If it's the last step - return NULL */

 Prepare a 'user_req' */

 Set the command */

 Set vlan_mac_flags */

 Set a restore bit */

/* bnx2x_exeq_get_mac/bnx2x_exeq_get_vlan/bnx2x_exeq_get_vlan_mac return a

 * pointer to an element with a specific criteria and NULL if such an element

 * hasn't been found.

 Check pending for execution commands */

 Check pending for execution commands */

 Check pending for execution commands */

/**

 * bnx2x_validate_vlan_mac_add - check if an ADD command can be executed

 *

 * @bp:		device handle

 * @qo:		bnx2x_qable_obj

 * @elem:	bnx2x_exeq_elem

 *

 * Checks that the requested configuration can be added. If yes and if

 * requested, consume CAM credit.

 *

 * The 'validate' is run after the 'optimize'.

 *

 Check the registry */

	/* Check if there is a pending ADD command for this

	 * MAC/VLAN/VLAN-MAC. Return an error if there is.

	/* TODO: Check the pending MOVE from other objects where this

	 * object is a destination object.

 Consume the credit if not requested not to */

/**

 * bnx2x_validate_vlan_mac_del - check if the DEL command can be executed

 *

 * @bp:		device handle

 * @qo:		quable object to check

 * @elem:	element that needs to be deleted

 *

 * Checks that the requested configuration can be deleted. If yes and if

 * requested, returns a CAM credit.

 *

 * The 'validate' is run after the 'optimize'.

	/* If this classification can not be deleted (doesn't exist)

	 * - return a BNX2X_EXIST.

	/* Check if there are pending DEL or MOVE commands for this

	 * MAC/VLAN/VLAN-MAC. Return an error if so.

 Check for MOVE commands */

 Check for DEL commands */

 Return the credit to the credit pool if not requested not to */

/**

 * bnx2x_validate_vlan_mac_move - check if the MOVE command can be executed

 *

 * @bp:		device handle

 * @qo:		quable object to check (source)

 * @elem:	element that needs to be moved

 *

 * Checks that the requested configuration can be moved. If yes and if

 * requested, returns a CAM credit.

 *

 * The 'validate' is run after the 'optimize'.

	/* Check if we can perform this operation based on the current registry

	 * state.

	/* Check if there is an already pending DEL or MOVE command for the

	 * source object or ADD command for a destination object. Return an

	 * error if so.

 Check DEL on source */

 Check MOVE on source */

 Check ADD on destination */

 Consume the credit if not requested not to */

 return the credit taken from dest... */

 If consumption wasn't required, nothing to do */

/**

 * bnx2x_wait_vlan_mac - passively wait for 5 seconds until all work completes.

 *

 * @bp:		device handle

 * @o:		bnx2x_vlan_mac_obj

 *

 Wait for the current command to complete */

 Wait until there are no pending commands */

		/* Calling function should not differentiate between this case

		 * and the case in which there is already a pending ramrod

/**

 * bnx2x_complete_vlan_mac - complete one VLAN-MAC ramrod

 *

 * @bp:		device handle

 * @o:		bnx2x_vlan_mac_obj

 * @cqe:	completion element

 * @ramrod_flags: if set schedule next execution chunk

 *

	/* Clearing the pending list & raw state should be made

	 * atomically (as execution flow assumes they represent the same).

 Reset pending list */

 Clear pending */

 If ramrod failed this is most likely a SW bug */

 Run the next bulk of pending commands if requested */

 If there is more work to do return PENDING */

/**

 * bnx2x_optimize_vlan_mac - optimize ADD and DEL commands.

 *

 * @bp:		device handle

 * @qo:		bnx2x_qable_obj

 * @elem:	bnx2x_exeq_elem

 Don't handle anything other than ADD or DEL */

 If we found the appropriate element - delete it */

 Return the credit of the optimized command */

 VLAN_MAC_DEL */

/**

 * bnx2x_vlan_mac_get_registry_elem - prepare a registry element

 *

 * @bp:	  device handle

 * @o:	vlan object

 * @elem: element

 * @restore: to restore or not

 * @re: registry

 *

 * prepare a registry element according to the current command request.

 Allocate a new registry element if needed. */

 Get a new CAM offset */

			/* This shall never happen, because we have checked the

			 * CAM availability in the 'validate'.

 Set a VLAN-MAC data */

 Copy the flags (needed for DEL and RESTORE flows) */

 DEL, RESTORE */

/**

 * bnx2x_execute_vlan_mac - execute vlan mac command

 *

 * @bp:			device handle

 * @qo:			bnx2x_qable_obj pointer

 * @exe_chunk:		chunk

 * @ramrod_flags:	flags

 *

 * go and send a ramrod!

	/* If DRIVER_ONLY execution is requested, cleanup a registry

	 * and exit. Otherwise send a ramrod to FW.

 Set pending */

 Fill the ramrod data */

			/* We will add to the target object in MOVE command, so

			 * change the object for a CAM search.

 Push a new entry into the registry */

 Configure a single command in a ramrod data buffer */

 MOVE command consumes 2 entries in the ramrod data */

		/* No need for an explicit memory barrier here as long we would

		 * need to ensure the ordering of writing to the SPQ element

		 * and updating of the SPQ producer which involves a memory

		 * read and we will have to put a full memory barrier there

		 * (inside bnx2x_sp_post()).

 Now, when we are done with the ramrod - clean up the registry */

 Cleanup a registry in case of a failure */

 Delete all newly added above entries */

 Allocate the execution queue element */

 Set the command 'length' */

 Fill the object specific info */

 Try to add a new command to the pending list */

/**

 * bnx2x_config_vlan_mac - configure VLAN/MAC/VLAN_MAC filtering rules.

 *

 * @bp:	  device handle

 * @p:

 *

	/*

	 * Add new elements to the execution list for commands that require it.

	/* If nothing will be executed further in this iteration we want to

	 * return PENDING if there are pending commands

 Execute commands if required */

	/* RAMROD_COMP_WAIT is a superset of RAMROD_EXEC. If it was set

	 * then user want to wait until the last command is done.

		/* Wait maximum for the current exe_queue length iterations plus

		 * one (for the current pending command).

 Wait for the current command to complete */

 Make a next step */

/**

 * bnx2x_vlan_mac_del_all - delete elements with given vlan_mac_flags spec

 *

 * @bp:			device handle

 * @o:			vlan object info

 * @vlan_mac_flags:	vlan flags

 * @ramrod_flags:	execution flags to be used for this deletion

 *

 * if the last operation has completed successfully and there are no

 * more elements left, positive value if the last operation has completed

 * successfully and there are more previously configured elements, negative

 * value is current operation has failed.

 Clear pending commands first */

 Prepare a command request */

	/* Add all but the last VLAN-MAC to the execution queue without actually

	 * execution anything.

 CAM credit pool handling */

 Exe Queue */

 Exe Queue */

 Exe Queue */

 CAM pool handling */

	/* CAM offset is relevant for 57710 and 57711 chips only which have a

	 * single CAM for both MACs and VLAN-MAC pairs. So the offset

	 * will be taken from MACs' pool object only.

 Exe Queue */

 Exe Queue */

 RX_MODE verbs: DROP_ALL/ACCEPT_ALL/ACCEPT_ALL_MULTI/ACCEPT_ALL_VLAN/NORMAL */

 update the bp MAC filter structure */

 initial setting is drop-all */

    /* In e1x there we only take into account rx accept flag since tx switching

 accept matched ucast */

 accept matched mcast */

 accept all mcast */

 accept all mcast */

 accept (all) bcast */

 accept unmatched unicasts */

 write the MAC filter structure*/

 The operation is completed */

 Setup ramrod data */

 start with 'drop-all' */

 Clear ACCEPT_ALL_XXX flags for FCoE L2 Queue */

 Reset the ramrod data buffer */

 Setup ramrod data */

 Tx (internal switching) */

 Rx */

	/* If FCoE Queue configuration has been requested configure the Rx and

	 * internal switching modes for this queue in separate rules.

	 *

	 * FCoE queue shell never be set to ACCEPT_ALL packets of any sort:

	 * MCAST_ALL, UCAST_ALL, BCAST_ALL and UNMATCHED.

  Tx (internal switching) */

 Rx */

	/* Set the ramrod header (most importantly - number of rules to

	 * configure).

	/* No need for an explicit memory barrier here as long as we

	 * ensure the ordering of writing to the SPQ element

	 * and updating of the SPQ producer which involves a memory

	 * read. If the memory read is removed we will have to put a

	 * full memory barrier there (inside bnx2x_sp_post()).

 Send a ramrod */

 Ramrod completion is pending */

 Do nothing */

 Configure the new classification in the chip */

 Wait for a ramrod completion if was requested */

******************** Multicast verbs: SET, CLEAR ****************************/

 For a natural alignment of the following buffer */

 BNX2X_MCAST_CMD_SET_{ADD, DEL} */

 BNX2X_MCAST_CMD_X */

 Needed for DEL command */

 Needed for RESTORE flow with aprox match */

	bool set_convert; /* in case type == BNX2X_MCAST_CMD_SET, this is set

			   * when macs_head had been converted to a list of

			   * bnx2x_mcast_bin_elem.

	bool done; /* set to true, when the command has been handled,

		    * practically used in 57712 handling only, where one pending

		    * command may be handled in a few operations. As long as for

		    * other chips every operation handling is completed in a

		    * single ramrod, there is no need to utilize this field.

 When adding MACs we'll need to store their values */

 If the command is empty ("handle pending commands only"), break */

 Add mcast is called under spin_lock, thus calling with GFP_ATOMIC */

		/* For a set command, we need to allocate sufficient memory for

		 * all the bins, since we can't analyze at this point how much

		 * memory would be required.

			/* Push the MACs of the current command into the pending

			 * command MACs list: FIFO

 Push the new pending command to the tail of the pending list: FIFO */

/**

 * bnx2x_mcast_get_next_bin - get the next set bin (index)

 *

 * @o:		multicast object info

 * @last:	index to start looking from (including)

 *

 * returns the next found (set) bin or a negative value if none is found.

 None found */

/**

 * bnx2x_mcast_clear_first_bin - find the first set bin and clear it

 *

 * @o:

 *

 * returns the index of the found bin or -1 if none is found

 Get a bin and update a bins' vector */

		/* If there were no more bins to clear

		 * (bnx2x_mcast_clear_first_bin() returns -1) then we would

		 * clear any (0xff) bin.

		 * See bnx2x_mcast_validate_e2() for explanation when it may

		 * happen.

/**

 * bnx2x_mcast_handle_restore_cmd_e2 - restore configuration from the registry

 *

 * @bp:		device handle

 * @o:		multicast object info

 * @start_bin:	index in the registry to start from (including)

 * @rdata_idx:	index in the ramrod data to start from

 *

 * returns last handled bin index or -1 if all bins have been handled

 go through the registry and configure the bins from it */

		/* Break if we reached the maximum number

		 * of rules.

		/* Break if we reached the maximum number

		 * of rules.

 if no more MACs to configure - we are done */

		/* Break if we reached the maximum

		 * number of rules.

 If we cleared all bins - we are done */

 If o->set_restore returned -1 we are done */

 Start from the next bin next time */

 Fill `current' with the required set of bins to configure */

	/* We no longer have use for the MACs; Need to re-use memory for

	 * a list that will be used to configure bins.

	/* We now definitely know how many commands are hiding here.

	 * Also need to correct the disruption we've added to guarantee this

	 * would be enqueued.

	/* This is actually a 2-part scheme - it starts by converting the MACs

	 * into a list of bins to be added/removed, and correcting the numbers

	 * on the object. this is now allowed, as we're now sure that all

	 * previous configured requests have already applied.

	 * The second part is actually adding rules for the newly introduced

	 * entries [like all the rest of the hdl_pending functions].

 Break if we reached the maximum number of rules. */

 if no more MACs to configure - we are done */

		/* If the command has been completed - remove it from the list

		 * and free the memory

 Break if we reached the maximum number of rules */

/**

 * bnx2x_mcast_handle_current_cmd - send command if room

 *

 * @bp:		device handle

 * @p:		ramrod mcast info

 * @cmd:	command

 * @start_cnt:	first line in the ramrod data that may be used

 *

 * This function is called iff there is enough place for the current command in

 * the ramrod data.

 * Returns number of lines filled in the ramrod data in total.

 The current command has been handled */

 DEL command deletes all currently configured MACs */

 RESTORE command will restore the entire multicast configuration */

		/* Here we set the approximate amount of work to do, which in

		 * fact may be only less as some MACs in postponed ADD

		 * command(s) scheduled before this command may fall into

		 * the same bin and the actual number of bins set in the

		 * registry would be less than we estimated here. See

		 * bnx2x_mcast_set_one_rule_e2() for further details.

		/* Here we assume that all new MACs will fall into new bins.

		 * However we will correct the real registry size after we

		 * handle all pending commands.

		/* We can only learn how many commands would actually be used

		 * when this is being configured. So for now, simply guarantee

		 * the command will be enqueued [to refrain from adding logic

		 * that handles this and THEN learns it needs several ramrods].

		 * Just like for ADD/Cont, the mcast_list_len might be an over

		 * estimation; or even more so, since we don't take into

		 * account the possibility of removal of existing bins.

 Increase the total number of MACs pending to be configured */

/**

 * bnx2x_mcast_set_rdata_hdr_e2 - sets a header values

 *

 * @bp:		device handle

 * @p:		ramrod parameters

 * @len:	number of rules to handle

/**

 * bnx2x_mcast_refresh_registry_e2 - recalculate the actual number of set bins

 *

 * @bp:		device handle

 * @o:

 *

 * Recalculate the actual number of set bins in the registry using Brian

 * Kernighan's algorithm: it's execution complexity is as a number of set bins.

 *

 * returns 0 for the compliance with bnx2x_mcast_refresh_registry_e1().

 Reset the ramrod data buffer */

 If there are no more pending commands - clear SCHEDULED state */

	/* The below may be true iff there was enough room in ramrod

	 * data for all pending commands and for the current

	 * command. Otherwise the current command would have been added

	 * to the pending commands and p->mcast_list_len would have been

	 * zeroed.

	/* We've pulled out some MACs - update the total number of

	 * outstanding.

 send a ramrod */

	/* Update a registry size if there are no more pending operations.

	 *

	 * We don't want to change the value of the registry size if there are

	 * pending operations because we want it to always be equal to the

	 * exact or the approximate number (see bnx2x_mcast_validate_e2()) of

	 * set bins after the last requested operation in order to properly

	 * evaluate the size of the next DEL/RESTORE operation.

	 *

	 * Note that we update the registry itself during command(s) handling

	 * - see bnx2x_mcast_set_one_rule_e2(). That's because for 57712 we

	 * aggregate multiple commands (ADD/DEL/RESTORE) into one ramrod but

	 * with a limited amount of update commands (per MAC/bin) and we don't

	 * know in this scope what the actual state of bins configuration is

	 * going to be after this ramrod.

	/* If CLEAR_ONLY was requested - don't send a ramrod and clear

	 * RAMROD_PENDING status immediately. due to the SET option, it's also

	 * possible that after evaluating the differences there's no need for

	 * a ramrod. In that case, we can skip it as well.

		/* No need for an explicit memory barrier here as long as we

		 * ensure the ordering of writing to the SPQ element

		 * and updating of the SPQ producer which involves a memory

		 * read. If the memory read is removed we will have to put a

		 * full memory barrier there (inside bnx2x_sp_post()).

 Send a ramrod */

 Ramrod completion is pending */

 Mark, that there is a work to do */

 Do nothing */

 bookkeeping... */

/* On 57711 we write the multicast MACs' approximate match

 * table by directly into the TSTORM's internal RAM. So we don't

 * really need to handle any tricks to make it work.

	/* If CLEAR_ONLY has been requested - clear the registry

	 * and clear a pending bit.

		/* Set the multicast filter bits before writing it into

		 * the internal memory.

 clear the registry */

 Set the mcast filter in the internal memory */

 clear the registry */

 We are done */

 DEL command deletes all currently configured MACs */

 RESTORE command will restore the entire multicast configuration */

		/* Multicast MACs on 57710 are configured as unicast MACs and

		 * there is only a limited number of CAM entries for that

		 * matter.

		/* Every configured MAC should be cleared if DEL command is

		 * called. Only the last ADD command is relevant as long as

		 * every ADD commands overrides the previous configuration.

	/* We want to ensure that commands are executed one by one for 57710.

	 * Therefore each none-empty command will consume o->max_cmd_len.

	/* If current command hasn't been handled yet and we are

	 * here means that it's meant to be dropped and we have to

	 * update the number of outstanding MACs accordingly.

 copy mac */

/**

 * bnx2x_mcast_set_rdata_hdr_e1  - set header values in mac_configuration_cmd

 *

 * @bp:		device handle

 * @p:		ramrod parameters

 * @len:	number of rules to handle

/**

 * bnx2x_mcast_handle_restore_cmd_e1 - restore command for 57710

 *

 * @bp:		device handle

 * @o:		multicast info

 * @start_idx:	index in the registry to start from

 * @rdata_idx:	index in the ramrod data to start from

 *

 * restore command for 57710 is like all other commands - always a stand alone

 * command - start_idx and rdata_idx will always be 0. This function will always

 * succeed.

 * returns -1 to comply with 57712 variant.

 go through the registry and configure the MACs from it. */

 If nothing to be done - return */

 Handle the first command */

/**

 * bnx2x_get_fw_mac_addr - revert the bnx2x_set_fw_mac_addr().

 *

 * @fw_hi: address

 * @fw_mid: address

 * @fw_lo: address

 * @mac: mac address

/**

 * bnx2x_mcast_refresh_registry_e1 -

 *

 * @bp:		device handle

 * @o:		multicast info

 *

 * Check the ramrod data first entry flag to see if it's a DELETE or ADD command

 * and update the registry correspondingly: if ADD - allocate a memory and add

 * the entries to the registry (list), if DELETE - clear the registry and free

 * the memory.

	/* If first entry contains a SET bit - the command was ADD,

	 * otherwise - DEL_ALL

 Break if it was a RESTORE command */

 Reset the ramrod data buffer */

 First set all entries as invalid */

 Handle pending commands first */

 If there are no more pending commands - clear SCHEDULED state */

 The below may be true iff there were no pending commands */

	/* For 57710 every command has o->max_cmd_len length to ensure that

	 * commands are done one at a time.

 send a ramrod */

 Set ramrod header (in particular, a number of entries to update) */

	/* update a registry: we need the registry contents to be always up

	 * to date in order to be able to execute a RESTORE opcode. Here

	 * we use the fact that for 57710 we sent one command at a time

	 * hence we may take the registry update out of the command handling

	 * and do it in a simpler way here.

	/* If CLEAR_ONLY was requested - don't send a ramrod and clear

	 * RAMROD_PENDING status immediately.

		/* No need for an explicit memory barrier here as long as we

		 * ensure the ordering of writing to the SPQ element

		 * and updating of the SPQ producer which involves a memory

		 * read. If the memory read is removed we will have to put a

		 * full memory barrier there (inside bnx2x_sp_post()).

 Send a ramrod */

 Ramrod completion is pending */

	/* This is needed to recover number of currently configured mcast macs

	 * in case of failure.

 Do some calculations and checks */

 Return if there is no work to do */

	/* Enqueue the current command to the pending list if we can't complete

	 * it in the current iteration

		/* As long as the current command is in a command list we

		 * don't need to handle it separately.

 Set 'pending' state */

 Configure the new classification in the chip */

 Wait for a ramrod completion if was requested */

		/* 57710 is the only chip that uses the exact match for mcast

		 * at the moment.

		/* 57711 doesn't send a ramrod, so it has unlimited credit

		 * for one command.

		/* TODO: There should be a proper HSI define for this number!!!

************************** Credit handling **********************************/

/**

 * __atomic_add_ifless - add if the result is less than a given value.

 *

 * @v:	pointer of type atomic_t

 * @a:	the amount to add to v...

 * @u:	...if (v + a) is less than u.

 *

 * returns true if (v + a) was less than u, and false otherwise.

 *

/**

 * __atomic_dec_ifmoe - dec if the result is more or equal than a given value.

 *

 * @v:	pointer of type atomic_t

 * @a:	the amount to dec from v...

 * @u:	...if (v - a) is more or equal than u.

 *

 * returns true if (v - a) was more or equal than u, and false

 * otherwise.

 Don't let to refill if credit + cnt > pool_sz */

 Find "internal cam-offset" then add to base for this object... */

 Skip the current vector if there are no free entries in it */

 If we've got here we are going to find a free entry */

 Got one!! */

 Return the entry to the pool */

/**

 * bnx2x_init_credit_pool - initialize credit pool internals.

 *

 * @p:		credit pool

 * @base:	Base entry in the CAM to use.

 * @credit:	pool size.

 *

 * If base is negative no CAM entries handling will be performed.

 * If credit is negative pool operations will always succeed (unlimited pool).

 *

 Zero the object first */

 Set the table to all 1s */

 Init a pool as full */

 The total poll size */

 Commit the change */

 if pool credit is negative - disable the checks */

 If base is negative - disable entries handling */

 TODO: this will be defined in consts as well... */

 In E1, Multicast is saved in cam... */

		/* CAM credit is equaly divided between all active functions

		 * on the PORT!.

 this should never happen! Block MAC operations. */

		/* CAM credit is equaly divided between all active functions

		 * on the PATH.

			/* No need for CAM entries handling for 57712 and

			 * newer.

 this should never happen! Block MAC operations. */

		/* There is no VLAN credit in HW on 57710 and 57711 only

		 * MAC / MAC-VLAN can be set

		/* CAM credit is equally divided between all active functions

		 * on the PATH.

unused for E2*/, credit);

 this should never happen! Block VLAN operations. */

***************** RSS Configuration ******************/

/**

 * bnx2x_debug_print_ind_table - prints the indirection table configuration.

 *

 * @bp:		driver handle

 * @p:		pointer to rss configuration

 *

 * Prints it when NETIF_MSG_IFUP debug level is configured.

 Print 4 bytes in a line */

/**

 * bnx2x_setup_rss - configure RSS

 *

 * @bp:		device handle

 * @p:		rss configuration

 *

 * sends on UPDATE ramrod for that matter.

 Set an echo field */

 RSS mode */

 RSS capabilities */

 RSS keys */

		/* Apparently, bnx2x reads this array in reverse order

		 * We need to byte swap rss_key to comply with Toeplitz specs.

 Hashing mask */

 RSS engine ID */

 Indirection table */

 Remember the last configuration */

 Print the indirection table */

	/* No need for an explicit memory barrier here as long as we

	 * ensure the ordering of writing to the SPQ element

	 * and updating of the SPQ producer which involves a memory

	 * read. If the memory read is removed we will have to put a

	 * full memory barrier there (inside bnx2x_sp_post()).

 Send a ramrod */

 Do nothing if only driver cleanup was requested */

********************* Queue state object ***********************************/

/**

 * bnx2x_queue_state_change - perform Queue state change transition

 *

 * @bp:		device handle

 * @params:	parameters to perform the transition

 *

 * returns 0 in case of successfully completed transition, negative error

 * code in case of failure, positive (EBUSY) value if there is a completion

 * to that is still pending (possible only if RAMROD_COMP_WAIT is

 * not set in params->ramrod_flags for asynchronous commands).

 *

 Check that the requested transition is legal */

 Set "pending" bit */

 Don't send a command if only driver cleanup was requested */

 Send a ramrod */

	/* ACTIVATE and DEACTIVATE commands are implemented on top of

	 * UPDATE command.

/**

 * bnx2x_queue_comp_cmd - complete the state change command.

 *

 * @bp:		device handle

 * @o:		queue info

 * @cmd:	command to exec

 *

 * Checks that the arrived completion is expected.

		/* >= because tx only must always be smaller than cos since the

		 * primary connection supports COS 0

 print num tx-only if any exist */

	/* It's important that o->state and o->next_state are

	 * updated before o->pending.

 Rx data */

 IPv6 TPA supported for E2 and above only */

 Don't configure any Tx switching mode during queue SETUP */

 flow control data */

 Always start in DROP_ALL mode */

 We don't set drop flags */

 silent vlan removal */

 initialize the general, tx and rx parts of a queue object */

 initialize the general and tx parts of a tx-only queue object */

/**

 * bnx2x_q_init - init HW/FW queue

 *

 * @bp:		device handle

 * @params:

 *

 * HW/FW initial Queue configuration:

 *      - HC: Rx and Tx

 *      - CDU context validation

 *

 Tx HC configuration */

 Rx HC configuration */

 Set CDU context validation values */

 As no ramrod is sent, complete the command immediately  */

 Clear the ramrod data */

 Fill the ramrod data */

	/* No need for an explicit memory barrier here as long as we

	 * ensure the ordering of writing to the SPQ element

	 * and updating of the SPQ producer which involves a memory

	 * read. If the memory read is removed we will have to put a

	 * full memory barrier there (inside bnx2x_sp_post()).

 Clear the ramrod data */

 Fill the ramrod data */

	/* No need for an explicit memory barrier here as long as we

	 * ensure the ordering of writing to the SPQ element

	 * and updating of the SPQ producer which involves a memory

	 * read. If the memory read is removed we will have to put a

	 * full memory barrier there (inside bnx2x_sp_post()).

 Clear the ramrod data */

 Fill the ramrod data */

	/* No need for an explicit memory barrier here as long as we

	 * ensure the ordering of writing to the SPQ element

	 * and updating of the SPQ producer which involves a memory

	 * read. If the memory read is removed we will have to put a

	 * full memory barrier there (inside bnx2x_sp_post()).

 Client ID of the client to update */

 Function ID of the client to update */

 Default VLAN value */

 Inner VLAN stripping */

 Outer VLAN stripping */

	/* Drop packets that have source MAC that doesn't belong to this

	 * Queue.

 Activate/Deactivate */

 Enable default VLAN */

 silent vlan removal */

 tx switching */

 PTP */

 Clear the ramrod data */

 Fill the ramrod data */

	/* No need for an explicit memory barrier here as long as we

	 * ensure the ordering of writing to the SPQ element

	 * and updating of the SPQ producer which involves a memory

	 * read. If the memory read is removed we will have to put a

	 * full memory barrier there (inside bnx2x_sp_post()).

/**

 * bnx2x_q_send_deactivate - send DEACTIVATE command

 *

 * @bp:		device handle

 * @params:

 *

 * implemented using the UPDATE command.

/**

 * bnx2x_q_send_activate - send ACTIVATE command

 *

 * @bp:		device handle

 * @params:

 *

 * implemented using the UPDATE command.

 Clear the ramrod data */

 Fill the ramrod data */

	/* Add the function id inside the type, so that sp post function

	 * doesn't automatically add the PF func-id, this is required

	 * for operations done by PFs on behalf of their VFs

	/* No need for an explicit memory barrier here as long as we

	 * ensure the ordering of writing to the SPQ element

	 * and updating of the SPQ producer which involves a memory

	 * read. If the memory read is removed we will have to put a

	 * full memory barrier there (inside bnx2x_sp_post()).

/**

 * bnx2x_queue_chk_transition - check state machine of a regular Queue

 *

 * @bp:		device handle

 * @o:		queue info

 * @params:	queue state

 *

 * (not Forwarding)

 * It both checks if the requested command is legal in a current

 * state and, if it's legal, sets a `next_state' in the object

 * that will be used in the completion flow to set the `state'

 * of the object.

 *

 * returns 0 if a requested command is a legal transition,

 *         -EINVAL otherwise.

	/* Forget all pending for completion commands if a driver only state

	 * transition has been requested.

	/* Don't allow a next state transition if we are in the middle of

	 * the previous one.

			/* If "active" state change is requested, update the

			 *  state accordingly.

			/* If "active" state change is requested, update the

			 *  state accordingly.

			/* If "active" state change is requested, update the

			 * state accordingly.

 tx only queues exist for this queue */

 Transition is assured */

 We support only BNX2X_MULTI_TX_COS Tx CoS at the moment */

 return a queue object's logical state*/

********************* Function state object *********************************/

 in the middle of transaction - return INVALID state */

	/* unsure the order of reading of o->pending and o->state

	 * o->pending should be read first

/**

 * bnx2x_func_state_change_comp - complete the state machine transition

 *

 * @bp:		device handle

 * @o:		function info

 * @cmd:	more info

 *

 * Called on state change transition. Completes the state

 * machine transition only - no HW interaction.

	/* It's important that o->state and o->next_state are

	 * updated before o->pending.

/**

 * bnx2x_func_comp_cmd - complete the state change command

 *

 * @bp:		device handle

 * @o:		function info

 * @cmd:	more info

 *

 * Checks that the arrived completion is expected.

	/* Complete the state machine part first, check if it's a

	 * legal completion.

/**

 * bnx2x_func_chk_transition - perform function state machine transition

 *

 * @bp:		device handle

 * @o:		function info

 * @params:	state parameters

 *

 * It both checks if the requested command is legal in a current

 * state and, if it's legal, sets a `next_state' in the object

 * that will be used in the completion flow to set the `state'

 * of the object.

 *

 * returns 0 if a requested command is a legal transition,

 *         -EINVAL otherwise.

	/* Forget all pending for completion commands if a driver only state

	 * transition has been requested.

	/* Don't allow a next state transition if we are in the middle of

	 * the previous one.

		/* afex ramrods can be sent only in started mode, and only

		 * if not pending for function_stop ramrod completion

		 * for these events - next state remained STARTED.

		/* Switch_update ramrod can be sent in either started or

		 * tx_stopped state, and it doesn't change the state.

 Transition is assured */

/**

 * bnx2x_func_init_func - performs HW init at function stage

 *

 * @bp:		device handle

 * @drv:

 *

 * Init HW when the current phase is

 * FW_MSG_CODE_DRV_LOAD_FUNCTION: initialize only FUNCTION-only

 * HW blocks.

/**

 * bnx2x_func_init_port - performs HW init at port stage

 *

 * @bp:		device handle

 * @drv:

 *

 * Init HW when the current phase is

 * FW_MSG_CODE_DRV_LOAD_PORT: initialize PORT-only and

 * FUNCTION-only HW blocks.

 *

/**

 * bnx2x_func_init_cmn_chip - performs HW init at chip-common stage

 *

 * @bp:		device handle

 * @drv:

 *

 * Init HW when the current phase is

 * FW_MSG_CODE_DRV_LOAD_COMMON_CHIP: initialize COMMON_CHIP,

 * PORT-only and FUNCTION-only HW blocks.

/**

 * bnx2x_func_init_cmn - performs HW init at common stage

 *

 * @bp:		device handle

 * @drv:

 *

 * Init HW when the current phase is

 * FW_MSG_CODE_DRV_LOAD_COMMON_CHIP: initialize COMMON,

 * PORT-only and FUNCTION-only HW blocks.

 Prepare buffers for unzipping the FW */

 Prepare FW */

 Handle the beginning of COMMON_XXX pases separately... */

	/* In case of success, complete the command immediately: no ramrods

	 * have been sent.

/**

 * bnx2x_func_reset_func - reset HW at function stage

 *

 * @bp:		device handle

 * @drv:

 *

 * Reset HW at FW_MSG_CODE_DRV_UNLOAD_FUNCTION stage: reset only

 * FUNCTION-only HW blocks.

/**

 * bnx2x_func_reset_port - reset HW at port stage

 *

 * @bp:		device handle

 * @drv:

 *

 * Reset HW at FW_MSG_CODE_DRV_UNLOAD_PORT stage: reset

 * FUNCTION-only and PORT-only HW blocks.

 *

 *                 !!!IMPORTANT!!!

 *

 * It's important to call reset_port before reset_func() as the last thing

 * reset_func does is pf_disable() thus disabling PGLUE_B, which

 * makes impossible any DMAE transactions.

/**

 * bnx2x_func_reset_cmn - reset HW at common stage

 *

 * @bp:		device handle

 * @drv:

 *

 * Reset HW at FW_MSG_CODE_DRV_UNLOAD_COMMON and

 * FW_MSG_CODE_DRV_UNLOAD_COMMON_CHIP stages: reset COMMON,

 * COMMON_CHIP, FUNCTION-only and PORT-only HW blocks.

 Complete the command immediately: no ramrods have been sent. */

 Fill the ramrod data with provided parameters */

	/* No need for an explicit memory barrier here as long we would

	 * need to ensure the ordering of writing to the SPQ element

	 * and updating of the SPQ producer which involves a memory

	 * read and we will have to put a full memory barrier there

	 * (inside bnx2x_sp_post()).

 Fill the ramrod data with provided parameters */

	/* No need for an explicit memory barrier here as long as we

	 * ensure the ordering of writing to the SPQ element

	 * and updating of the SPQ producer which involves a memory

	 * read. If the memory read is removed we will have to put a

	 * full memory barrier there (inside bnx2x_sp_post()).

 Fill the ramrod data with provided parameters */

	/* No need for an explicit memory barrier here as long as we

	 * ensure the ordering of writing to the SPQ element

	 * and updating of the SPQ producer which involves a memory

	 * read. If the memory read is removed we will have to put a

	 * full memory barrier there (inside bnx2x_sp_post()).

 Fill the ramrod data with provided parameters */

 send in echo type of sub command */

	/*  No need for an explicit memory barrier here as long we would

	 *  need to ensure the ordering of writing to the SPQ element

	 *  and updating of the SPQ producer which involves a memory

	 *  read and we will have to put a full memory barrier there

	 *  (inside bnx2x_sp_post()).

 this ramrod sends data directly and not through DMA mapping */

	/* No need for an explicit memory barrier here as long as we

	 * ensure the ordering of writing to the SPQ element

	 * and updating of the SPQ producer which involves a memory

	 * read. If the memory read is removed we will have to put a

	 * full memory barrier there (inside bnx2x_sp_post()).

 Fill the ramrod data with provided parameters */

/**

 * bnx2x_func_state_change - perform Function state change transition

 *

 * @bp:		device handle

 * @params:	parameters to perform the transaction

 *

 * returns 0 in case of successfully completed transition,

 *         negative error code in case of failure, positive

 *         (EBUSY) value if there is a completion to that is

 *         still pending (possible only if RAMROD_COMP_WAIT is

 *         not set in params->ramrod_flags for asynchronous

 *         commands).

 Check that the requested transition is legal */

 Set "pending" bit */

 Don't send a command if only driver cleanup was requested */

 Send a ramrod */

/* bnx2x_cmn.c: QLogic Everest network driver.

 *

 * Copyright (c) 2007-2013 Broadcom Corporation

 * Copyright (c) 2014 QLogic Corporation

 * All rights reserved

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 *

 * Maintained by: Ariel Elior <ariel.elior@qlogic.com>

 * Written by: Eliezer Tamir

 * Based on code from Michael Chan's bnx2 driver

 * UDP CSUM errata workaround by Arik Gendelman

 * Slowpath and fastpath rework by Vladislav Zolotarov

 * Statistics and Link management by Yitchak Gertner

 *

 Add NAPI objects */

 Add NAPI objects */

 Reduce memory usage in kdump environment by using only one queue */

/**

 * bnx2x_move_fp - move content of the fastpath structure.

 *

 * @bp:		driver handle

 * @from:	source FP index

 * @to:		destination FP index

 *

 * Makes sure the contents of the bp->fp[to].napi is kept

 * intact. This is done by first copying the napi struct from

 * the target to the source, and then mem copying the entire

 * source onto the target. Update txdata pointers and related

 * content.

 Copy the NAPI object as it has been already initialized */

 Move bnx2x_fastpath contents */

	/* Retain the tpa_info of the original `to' version as we don't want

	 * 2 FPs to contain the same tpa_info pointer.

 move sp_objs contents as well, as their indices match fp ones */

 move fp_stats contents as well, as their indices match fp ones */

	/* Update txdata pointers in fp and move txdata content accordingly:

	 * Each fp consumes 'max_cos' txdata structures, so the index should be

	 * decremented by max_cos x delta.

/**

 * bnx2x_fill_fw_str - Fill buffer with FW version string.

 *

 * @bp:        driver handle

 * @buf:       character buffer to fill with the fw name

 * @buf_len:   length of the above buffer

 *

/**

 * bnx2x_shrink_eth_fp - guarantees fastpath structures stay intact

 *

 * @bp:	driver handle

 * @delta:	number of eth queues which were not allocated

	/* Queue pointer cannot be re-set on an fp-basis, as moving pointer

	 * backward along the array could cause memory to be overridden

 per-path: 0-common, 1-port0, 2-port1 */

/* free skb in the packet ring at pos idx

 * return idx of last bd freed

 prefetch skb end pointer to speedup dev_kfree_skb() */

 Get the next bd */

 Skip a parse bd... */

 Skip second parse bd... */

 TSO headers+data bds share a common mapping. See bnx2x_tx_split() */

 unmap first bd */

 now free frags */

 release skb */

 Ensure subsequent loads occur after hw_cons */

	/* Need to make the tx_bd_cons update visible to start_xmit()

	 * before checking for netif_tx_queue_stopped().  Without the

	 * memory barrier, there is a small possibility that

	 * start_xmit() will miss it and cause the queue to be stopped

	 * forever.

	 * On the other hand we need an rmb() here to ensure the proper

	 * ordering of bit testing in the following

	 * netif_tx_queue_stopped(txq) call.

		/* Taking tx_lock() is needed to prevent re-enabling the queue

		 * while it's empty. This could have happen if rx_action() gets

		 * suspended in bnx2x_tx_int() after the condition before

		 * netif_tx_wake_queue(), while tx_action (bnx2x_start_xmit()):

		 *

		 * stops the queue->sees fresh tx_bd_cons->releases the queue->

		 * sends some packets consuming the whole queue again->

		 * stops the queue

 First mark all used pages */

 Here we assume that the last SGE index is the biggest */

 If ring is not full */

 Now update the prod */

 clear page-end entries */

/* Get Toeplitz hash value in the skb using the value from the

 * CQE (calculated by HW).

 Get Toeplitz hash from CQE */

 print error if current state != stop */

 Try to map an empty data buffer from the aggregation info  */

	/*

	 *  ...if it fails - move the skb from the consumer to the producer

	 *  and set the current aggregation state as ERROR to drop it

	 *  when TPA_STOP arrives.

 Move the BD from the consumer to the producer */

 move empty data from pool to prod */

 point prod_bd to new data */

 move partial skb from cons to pool (don't unmap yet) */

 mark bin state as START */

/* Timestamp option length allowed for TPA aggregation:

 *

 *		nop nop kind length echo val

/**

 * bnx2x_set_gro_params - compute GRO values

 *

 * @skb:		packet skb

 * @parsing_flags:	parsing flags from the START CQE

 * @len_on_bd:		total length of the first packet for the

 *			aggregation.

 * @pkt_len:		length of all segments

 * @num_of_coalesced_segs: count of segments

 *

 * Approximate value of the MSS for this aggregation calculated using

 * the first packet of it.

 * Compute number of aggregated segments, and gso_type.

	/* TPA aggregation won't have either IP options or TCP options

	 * other than timestamp or IPv6 extension headers.

	/* Check if there was a TCP timestamp, if there is it's will

	 * always be 12 bytes length: nop nop kind length echo val.

	 *

	 * Otherwise FW would close the aggregation.

	/* tcp_gro_complete() will copy NAPI_GRO_CB(skb)->count

	 * to skb_shinfo(skb)->gso_segs

 This is needed in order to enable forwarding support */

 Run through the SGL and compose the fragmented skb */

		/* FW gives the indices of the SGE as if the ring is an array

 LRO */

		/* If we fail to allocate a substitute page, we simply stop

 Add one frag and update the appropriate fields in the skb */

 GRO */

 GFP_KERNEL allocations are used only during initialization */

	/* If we there was an error during the handling of the TPA_START -

	 * drop this aggregation.

 Try to allocate the new data */

	/* Unmap skb in the pool anyway, as we are going to change

	   pool entry status to BNX2X_TPA_STOP even if new skb allocation

 put new data in bin */

 drop the packet and keep the buffer in the bin */

	/* Do nothing if no L4 csum validation was done.

	 * We do not check whether IP csum was validated. For IPv4 we assume

	 * that if the card got as far as validating the L4 csum, it also

	 * validated the IP csum. IPv6 has no IP csum.

 If L4 validation was done, check if an error was found. */

		/* A rmb() is required to ensure that the CQE is not read

		 * before it is written by the adapter DMA.  PCI ordering

		 * rules will make sure the other fields are written before

		 * the marker at the end of struct eth_fast_path_rx_cqe

		 * but without rmb() a weakly ordered processor can process

		 * stale data.  Without the barrier TPA state-machine might

		 * enter inconsistent state and kernel stack might be

		 * provided with incorrect packet description - these lead

		 * to various kernel crashed.

 is this a slowpath msg? */

 sanity check */

 non TPA */

 speedup eth_type_trans() */

 is this an error packet? */

		/* Since we don't have a jumbo ring

		 * copy small packets if mtu > 1500

 Set Toeplitz hash for a none-LRO skb */

 Check if this packet was timestamped */

 mark CQE as free */

 while */

 Update producers */

 Handle Rx and Tx according to MSI-X vector */

 HW Lock for shared dual port PHYs */

 calculates MF speed according to current linespeed and MF configuration */

		/* Calculate the current MAX line speed limit for the MF

		 * devices

 SD mode */

/**

 * bnx2x_fill_report_data - fill link report data to report

 *

 * @bp:		driver handle

 * @data:	link state to update

 *

 * It uses a none-atomic bit operations because is called under the mutex.

 Fill the report data: effective line speed */

 Link is down */

 Full DUPLEX */

 Rx Flow Control is ON */

 Tx Flow Control is ON */

 VF */

/**

 * bnx2x_link_report - report link status to OS.

 *

 * @bp:		driver handle

 *

 * Calls the __bnx2x_link_report() under the same locking scheme

 * as a link/PHY state managing code to ensure a consistent link

 * reporting.

/**

 * __bnx2x_link_report - report link status to OS.

 *

 * @bp:		driver handle

 *

 * None atomic implementation.

 * Should be called under the phy_lock.

 reread mf_cfg */

 Read the current link report info */

 Don't report link down or exactly the same link status twice */

	/* We are going to report a new link parameters now -

	 * remember the current data for the next time.

 propagate status to VFs */

		/* Handle the FC at the end so that only these flags would be

		 * possibly set. This way we may easily check if there is no FC

		 * enabled.

 Activate BD ring */

		/* Warning!

		 * this will generate an interrupt (to the TSTORM)

		 * must only be done after chip is initialized

 Allocate TPA resources */

 Fill the per-aggregation pool */

 "next page" elements initialization */

 set SGEs bit mask */

 Allocate SGEs and initialize the ring elements */

 Cleanup already allocated elements */

 Activate BD ring */

		/* Warning!

		 * this will generate an interrupt (to the TSTORM)

		 * must only be done after chip is initialized

 ring wasn't allocated */

 load old values */

 leave all but MAX value */

 set new MAX value */

/**

 * bnx2x_free_msix_irqs - free previously requested MSI-X IRQ vectors

 *

 * @bp:		driver handle

 * @nvecs:	number of vectors to be released

 VFs don't have a default SB */

 vfs don't have a default status block */

 VFs don't have a default status block */

 Cnic requires an msix vector for itself */

 We need separate vectors for ETH queues only (not FCoE) */

	/*

	 * reconfigure number of tx/rx queues according to available

	 * MSI-X vectors

 Get by with single vector */

 how less vectors we will have? */

		/*

		 * decrease number of queues by number of unallocated entries

 fall to INTx if not enough memory */

 no default status block for vf */

 Skip VLAN tag if present */

 If ethertype is FCoE or FIP - use FCoE ring */

 select a non-FCoE queue */

 RSS queues */

 override in STORAGE SD modes */

 Add special queues */

 For FCOE */

/**

 * bnx2x_set_real_num_queues - configure netdev->real_num_[tx,rx]_queues

 *

 * @bp:		Driver handle

 * @include_cnic: handle cnic case

 *

 * We currently support for at most 16 Tx queues for each CoS thus we will

 * allocate a multiple of 16 for ETH L2 rings according to the value of the

 * bp->max_cos.

 *

 * If there is an FCoE L2 queue the appropriate Tx queue will have the next

 * index after all ETH L2 indices.

 *

 * If the actual number of Tx queues (for each CoS) is less than 16 then there

 * will be the holes at the end of each group of 16 ETh L2 indices (0..15,

 * 16..31,...) with indices that are not coupled with any real Tx queue.

 *

 * The proper configuration of skb->queue_mapping is handled by

 * bnx2x_select_queue() and __skb_tx_hash().

 *

 * bnx2x_setup_tc() takes care of the proper TC mappings so that __skb_tx_hash()

 * will return a proper Tx index if TC is enabled (netdev->num_tc > 0).

 account for fcoe queue */

 Always use a mini-jumbo MTU for the FCoE L2 ring */

			/*

			 * Although there are no IP frames expected to arrive to

			 * this ring we still want to add an

			 * IP_HEADER_ALIGNMENT_PADDING to prevent a buffer

			 * overrun attack.

 Note : rx_buf_size doesn't take into account NET_SKB_PAD */

	/* Prepare the initial contents for the indirection table if RSS is

	 * enabled

	/*

	 * For 57710 and 57711 SEARCHER configuration (rss_keys) is

	 * per-port, so if explicit configuration is needed , do it only

	 * for a PMF.

	 *

	 * For 57712 and newer on the other hand it's a per-function

	 * configuration.

	/* Although RSS is meaningless when there is a single HW queue we

	 * still need it enabled in order to have HW Rx hash generated.

	 *

	 * if (!is_eth_multi(bp))

	 *      bp->multi_mode = ETH_RSS_MODE_DISABLED;

 RSS configuration */

 valid only for TUNN_MODE_VXLAN tunnel mode */

 valid only for TUNN_MODE_GRE tunnel mode */

 Hash bits */

 RSS keys */

 Prepare parameters for function state transitions */

/*

 * Cleans the object that have internal lists without sending

 * ramrods. Should be run when interrupts are disabled.

**************** Cleanup MACs' object first *************************/

 Wait for completion of requested */

 Perform a dry cleanup */

 Clean ETH primary MAC */

 Cleanup UC list */

**************** Now clean mcast object *****************************/

	/* Add a DEL command... - Since we're doing a driver cleanup only,

	 * we take a lock surrounding both the initial send and the CONTs,

	 * as we don't want a true completion to disrupt us in the middle.

 ...and wait until all pending commands are cleared */

BNX2X_STOP_ON_ERROR*/

BNX2X_STOP_ON_ERROR*/

 number of queues for statistics is number of eth queues + FCoE */

	/* Total number of FW statistics requests =

	 * 1 for port stats + 1 for PF stats + potential 2 for FCoE (fcoe proper

	 * and fcoe l2 queue) stats + num of queues (which includes another 1

	 * for fcoe l2 queue if applicable)

	/* vf stats appear in the request list, but their data is allocated by

	 * the VFs themselves. We don't include them in the bp->fw_stats_num as

	 * it is used to determine where to place the vf stats queries in the

	 * request struct

	/* Request is built from stats_query_header and an array of

	 * stats_query_cmd_group each of which contains

	 * STATS_QUERY_CMD_COUNT rules. The real number or requests is

	 * configured in the stats_query_header.

	/* Data for statistics requests + stats_counter

	 * stats_counter holds per-STORM counters that are incremented

	 * when STORM has finished with the current request.

	 * memory for FCoE offloaded statistics are counted anyway,

	 * even if they will not be sent.

	 * VF stats are not accounted for here as the data of VF stats is stored

	 * in memory allocated by the VF, not here.

 Set shortcuts */

 send load request to mcp and analyze response */

 init fw_seq */

 Get current FW pulse sequence */

 load request */

 if mcp fails to respond we must abort */

	/* If mcp refused (e.g. other port is in diagnostic mode) we

	 * must abort

/* check whether another PF has already loaded FW to chip. In

 * virtualized environments a pf from another VM may have already

 * initialized the device including loading FW

 is another pf loaded on this engine? */

 build my FW version dword */

 read loaded FW from chip */

 abort nic load if version mismatch */

 returns the "mcp load_code" according to global load_count array */

 mark PMF if applicable */

		/* We need the barrier to ensure the ordering between the

		 * writing to bp->port.pmf here and reading it from the

		 * bnx2x_periodic_task().

 Set AFEX default VLAN tag to an invalid value */

/**

 * bnx2x_bz_fp - zero content of the fastpath structure.

 *

 * @bp:		driver handle

 * @index:	fastpath index to be zeroed

 *

 * Makes sure the contents of the bp->fp[index].napi is kept

 * intact.

 bzero bnx2x_fastpath contents */

 Restore the NAPI object as it has been already initialized */

 Special queues support only one CoS */

 Init txdata pointers */

	/* set the tpa flag for each queue. The tpa flag determines the queue

	 * minimal size so it must be set prior to queue memory allocation

	/* We don't want TPA if it's disabled in bp

	 * or if this is an FCoE L2 ring.

 Update the number of queues with the cnic queues */

 Add all CNIC NAPI objects */

 Enable Timer scan */

 setup cnic queues */

 Initialize Rx filter. */

 re-read iscsi info */

 Disable Timer scan */

 Update the number of queues without the cnic queues */

 ! BNX2X_STOP_ON_ERROR */

 must be called with rtnl_lock */

 zero the structure w/o any lock, before SP handler is initialized */

 must be called before memory allocation and HW init */

	/*

	 * Zero fastpath structures preserving invariants like napi, which are

	 * allocated only once, fp index, max_cos, bp pointer.

	 * Also set fp->mode and txdata_ptr.

 Set the receive queues buffer size */

	/* need to be done after alloc mem, since it's self adjusting to amount

	 * of memory available for RSS queues

 Allocated memory for FW statistics  */

 request pf to initialize status blocks */

	/* As long as bnx2x_alloc_mem() may possibly update

	 * bp->num_queues, bnx2x_set_real_num_queues() should always

	 * come after it. At this stage cnic queues are not counted.

	/* configure multi cos mappings in kernel.

	 * this configuration may be overridden by a multi class queue

	 * discipline or by a dcbx negotiation result.

 Add all NAPI objects */

 set pf load just before approaching the MCP */

 if mcp exists send load request and analyze response */

 attempt to load pf */

 what did mcp say? */

 mark pmf if applicable */

 Init Function state controlling object */

 Initialize HW */

 Connect to IRQs */

 Init per-function objects */

 Setup NIC internals and enable interrupts */

 Set AFEX default VLAN tag to an invalid value */

 Send LOAD_DONE command to MCP */

 initialize FW coalescing state machines in RAM */

 setup the leading queue */

 set up the rest of the queues */

 VF */

 setup rss */

 Now when Clients are configured we are ready to work */

 Configure a ucast MAC */

 vf */

 Start fast path */

 Re-configure vlan filters */

 Initialize Rx filter. */

 Start Tx */

 Tx queue should be only re-enabled */

 start the timer */

 mark driver is loaded in shmem2 */

 Wait for all pending SP commands to complete */

 Update driver data for On-Chip MFW dump. */

 If PMF - send ADMIN DCBX msg to MFW to initiate DCBX FSM */

 Clean queueable objects */

 Free SKBs, SGEs, TPA pool and driver internals */

 Release IRQs */

 clear pf_load status, as it was already set */

 ! BNX2X_STOP_ON_ERROR */

 Wait until tx fastpath tasks complete */

 must be called with rtnl_lock */

 mark driver is unloaded in shmem2 */

		/* We can get here if the driver has been unloaded

		 * during parity error recovery and is either waiting for a

		 * leader to complete or for other functions to unload and

		 * then ifdown has been issued. In this case we want to

		 * unload and let other functions to complete a recovery

		 * process.

	/* Nothing to do during unload if previous bnx2x_nic_load()

	 * have not completed successfully - all resources are released.

	 *

	 * we can get here only after unsuccessful ndo_* callback, during which

	 * dev->IFF_UP flag is still on.

	/* It's important to set the bp->state to the value different from

	 * BNX2X_STATE_OPEN and only then stop the Tx. Otherwise bnx2x_tx_int()

	 * may restart the Tx from the NAPI context (see bnx2x_tx_int()).

 indicate to VFs that the PF is going down */

 Stop Tx */

 Set ALWAYS_ALIVE bit in shmem */

	/* wait till consumers catch up with producers in all queues.

	 * If we're recovering, FW can't write to host so no reason

	 * to wait for the queues to complete all Tx.

	/* if VF indicate to PF this function is going down (PF will delete sp

	 * elements and clear initializations

 if this is a normal/close unload need to clean up chip*/

 Send the UNLOAD_REQUEST to the MCP */

		/* Prevent transactions to host from the functions on the

		 * engine that doesn't reset global blocks in case of global

		 * attention once global blocks are reset and gates are opened

		 * (the engine which leader will perform the recovery

		 * last).

 Disable HW interrupts, NAPI */

 Delete all NAPI objects */

 Release IRQs */

 Report UNLOAD_DONE to MCP */

	/*

	 * At this stage no more interrupts will arrive so we may safely clean

	 * the queueable objects here in case they failed to get cleaned so far.

 There should be no more pending SP commands at this stage */

 clear pending work in rtnl task */

 Free SKBs, SGEs, TPA pool and driver internals */

 Clear driver version indication in shmem */

	/* Check if there are pending parity attentions. If there are - set

	 * RECOVERY_IN_PROGRESS.

 Set RESET_IS_GLOBAL if needed */

	/* The last driver must disable a "close the gate" if there is no

	 * parity attention or "process kill" pending.

 If there is no power capability, silently succeed */

 delay required during transition out of D3hot */

		/* If there are other clients above don't

 Don't shut down the power for emulation and FPGA */

		/* No more memory access after this point until

		* device is brought back to D0.

/*

 * net_device service functions

		/* No need to update SB for FCoE L2 ring as long as

		 * it's connected to the default SB and the SB

		 * has been updated when NAPI was scheduled.

			/* bnx2x_has_rx_work() reads the status block,

			 * thus we need to ensure that status block indices

			 * have been actually read (bnx2x_update_fpsb_idx)

			 * prior to this check (bnx2x_has_rx_work) so that

			 * we won't write the "newer" value of the status block

			 * to IGU (if there was a DMA right after

			 * bnx2x_has_rx_work and if there is no rmb, the memory

			 * reading (bnx2x_update_fpsb_idx) may be postponed

			 * to right before bnx2x_ack_sb). In this case there

			 * will never be another interrupt until there is

			 * another update of the status block, while there

			 * is still unhandled work.

 Re-enable interrupts */

/* we split the first BD into headers and data BDs

 * to ease the pain of our fellow microcode engineers

 * we use one mapping for both BDs

 first fix first BD */

	/* now get a new data BD

 this marks the BD as one that has no individual mapping */

 update tx_bd */

 VXLAN: 4 = 1 (for linear data BD) + 3 (2 for PBD and last BD) */

 Regular: 3 = 1 (for linear data BD) + 2 (for PBD and last BD) */

/* check if packet requires linearization (packet is too fragmented)

   no need to check fragmentation if page size > 8K (there will be no

 Number of windows to check */

 Headers length */

 Amount of data (w/o headers) on linear part of SKB*/

 Calculate the first sum - it's special */

 If there was data on linear skb data - check it */

			/* Others are easier: run through the frag list and

			/* in non-LSO too fragmented packet should always

/**

 * bnx2x_set_pbd_gso - update PBD in GSO case.

 *

 * @skb:	packet skb

 * @pbd:	parse BD

 * @xmit_type:	xmit flags

/**

 * bnx2x_set_pbd_csum_enc - update PBD with checksum and return header length

 *

 * @bp:			driver handle

 * @skb:		packet skb

 * @parsing_data:	data to be updated

 * @xmit_type:		xmit flags

 *

 * 57712/578xx related, when skb has encapsulation

	/* We support checksum offload for TCP and UDP only.

	 * No need to pass the UDP header length - it's a constant.

/**

 * bnx2x_set_pbd_csum_e2 - update PBD with checksum and return header length

 *

 * @bp:			driver handle

 * @skb:		packet skb

 * @parsing_data:	data to be updated

 * @xmit_type:		xmit flags

 *

 * 57712/578xx related

	/* We support checksum offload for TCP and UDP only.

	 * No need to pass the UDP header length - it's a constant.

 set FW indication according to inner or outer protocols if tunneled */

/**

 * bnx2x_set_pbd_csum - update PBD with checksum and return header length

 *

 * @bp:		driver handle

 * @skb:	packet skb

 * @pbd:	parse BD to be updated

 * @xmit_type:	xmit flags

 for now NS flag is not used in Linux */

 We support checksum offload for TCP and UDP only */

 signed! */

 HW bug: fixup the CSUM */

 from outer IP to transport */

 transport len */

 outer IP header info */

 inner IP header info */

 XMIT_GSO_V6 */

/* called with netif_tx_lock

 * bnx2x_tx_int() runs without netif_tx_lock unless it needs to call

 * netif_wake_queue()

	/* enable this debug print to view the transmission queue being used

	DP(NETIF_MSG_TX_QUEUED, "indices: txq %d, fp %d, txdata %d\n",

	/* enable this debug print to view the transmission details

	DP(NETIF_MSG_TX_QUEUED,

	   "transmitting packet cid %d fp index %d txdata_index %d tx_data ptr %p fp pointer %p\n",

 Handle special storage cases separately */

 set flag according to packet type (UNICAST_ADDRESS is default)*/

	/* First, check if we need to linearize the skb (due to FW

	   restrictions). No need to check fragmentation if page size > 8K

 Statistics of linearization */

 Map skb linear data for DMA */

	/*

	Please read carefully. First we use one BD which we mark as start,

	then we have a parsing info BD (used for TSO or xsum),

	and only then we have the rest of the TSO BDs.

	(don't forget to mark the last one as last,

	and to unmap only AFTER you write to the BD ...)

	And above all, all pdb sizes are in words - NOT DWORDS!

	/* get current pkt produced now - advance it just before sending packet

	 * since mapping of pages may fail and cause packet to be dropped

	/* get a tx_buf and first BD

	 * tx_start_bd may be changed during SPLIT,

	 * but first_bd will always stay first

 schedule check for Tx timestamp */

 header nbd: indirectly zero other flags! */

 remember the first BD of the packet */

		/* when transmitting in a vf, start bd must hold the ethertype

		 * for fw to enforce it

 Still need to consider inband vlan for enforced */

 used by FW for packet accounting */

 start_bd + pbd + frags (updated when pages are mapped) */

 turn on parsing and get a BD */

 Set PBD in enc checksum offload case */

 turn on 2nd parsing and get a BD */

 add addition parse BD indication to start BD */

 set encapsulation flag in start BD */

 Set PBD in checksum offload case w/o encapsulation */

		/* Add the macs to the parsing BD if this is a vf or if

		 * Tx Switching is enabled.

 override GRE parameters in BD */

			/* Enforce security is always set in Stop on Error -

			 * source mac should be present in the parsing BD

 Set PBD in checksum offload case */

 Setup the data pointer of the first BD of the packet */

	/* Set the PBD's parsing_data field if not zero

	 * (for the chips newer than 57711).

 Handle fragmented skb */

			/* we need unmap all buffers already mapped

			 * for this SKB;

			 * first_bd->nbd need to be properly updated

			 * before call to bnx2x_free_tx_pkt

 update with actual num BDs */

	/* now send a tx doorbell, counting the next BD

	 * if the packet contains or ends with it

	/* total_pkt_bytes should be set on the first data BD if

	 * it's not an LSO packet and there is more than one

	 * data BD. In this case pkt_size is limited by an MTU value.

	 * However we prefer to set it for an LSO packet (while we don't

	 * have to) in order to save some CPU cycles in a none-LSO

	 * case, when we much more care about them.

	/*

	 * Make sure that the BD data is updated before updating the producer

	 * since FW might read the BD right after the producer is updated.

	 * This is only applicable for weak-ordered memory model archs such

	 * as IA-64. The following barrier is also mandatory since FW will

	 * assumes packets must have BDs.

 make sure descriptor update is observed by HW */

		/* paired memory barrier is in bnx2x_tx_int(), we have to keep

		 * ordering of set_bit() in netif_tx_stop_queue() and read of

 If the shmem shouldn't affect configuration, reflect */

/**

 * bnx2x_setup_tc - routine to configure net_device for multi tc

 *

 * @dev: net device to configure

 * @num_tc: number of traffic classes to enable

 *

 * callback connected to the ndo_setup_tc function pointer

 setup tc must be called under rtnl lock */

 no traffic classes requested. Aborting */

 requested to support too many traffic classes */

 declare amount of supported traffic classes */

 configure priority to traffic class mapping */

	/* Use this configuration to differentiate tc0 from other COSes

	   This can be used for ets or pfc, and save the effort of setting

	   up a multio class queue disc or negotiating DCBX with a switch

	netdev_set_prio_tc_map(dev, 0, 0);

	DP(BNX2X_MSG_SP, "mapping priority %d to tc %d\n", 0, 0);

	for (prio = 1; prio < 16; prio++) {

		netdev_set_prio_tc_map(dev, prio, 1);

		DP(BNX2X_MSG_SP, "mapping priority %d to tc %d\n", prio, 1);

 configure traffic class to transmission queue mapping */

 called with rtnl_lock */

 Common */

 status blocks */

 Rx */

 fastpath rx rings: rx_buf rx_desc rx_comp */

 SGE ring */

 Tx */

 fastpath tx rings: tx_buf tx_desc */

 end of fastpath */

 Returns the number of actually allocated BDs */

	/* This routine is called only during fo init so

	 * fp->eth_q_stats.rx_skb_alloc_failed = 0

 Limit the CQE producer by the CQE ring size */

 Decrease ring size for 1G functions */

 allocate at least number of buffers required by FW */

 if rx_ring_size specified - use it */

 Common */

 status blocks */

	/* FCoE Queue uses Default SB and doesn't ACK the SB, thus no need to

	 * set shortcuts for it.

 Tx */

 fastpath tx rings: tx_buf tx_desc */

 Rx */

 fastpath rx rings: rx_buf rx_desc rx_comp */

 Seed all CQEs by 1s */

 SGE ring */

 RX BD ring */

 CQ ring */

 BDs */

 handles low memory cases */

	/* FW will drop all packets if queue is not big enough,

	 * In these cases we disable the queue

	 * Min size is different for OOO, TPA and non-TPA queues

 release memory allocated for this queue */

 FCoE */

			/* we will fail load process instead of mark

			 * NO_FCOE_FLAG

	/* 1. Allocate FP for leading - fatal if error

	 * 2. Allocate RSS - fix number of queues if error

 leading */

 RSS */

 handle memory failures */

			/* move non eth FPs next to last eth FP

			 * must be done in that order

			 * FCOE_IDX < FWD_IDX < OOO_IDX

 move FCoE fp even NO_FCOE_FLAG is on */

	/*

	 * The biggest MSI-X table we might need is as a maximum number of fast

	 * path IGU SBs plus default SB (for PF only).

 fp array: RSS plus CNIC related L2 queues */

 allocate sp objs */

 allocate fp_stats */

 Allocate memory for the transmission queues array */

 msix table */

 ilt */

 In case link is SERDES, check if the EXT_PHY2 is the one */

	/*

	 * The selected activated PHY is always after swapping (in case PHY

	 * swapping is enabled). So when swapping is enabled, we need to reverse

	 * the configuration

 called with rtnl_lock */

	/* This does not race with packet allocation

	 * because the actual alloc size is

	 * only updated as part of load

		/* Revert the requested changes in features if they

		 * would require internal reload of PF in bnx2x_set_features().

 TPA requires Rx CSUM offloading */

 VFs or non SRIOV PFs should be able to change loopback feature */

 Don't care about GRO changes */

 else: bnx2x_nic_load() will be called at end of recovery */

	/* We want the information of the dump logged,

	 * but calling bnx2x_panic() would kill all chances of recovery.

 This allows the netif to be shutdown gracefully before resetting */

 ustorm cxt validation */

 xcontext validation */

 clear and set */

/* Copyright 2008-2013 Broadcom Corporation

 * Copyright (c) 2014 QLogic Corporation

 * All rights reserved

 *

 * Unless you and QLogic execute a separate written software license

 * agreement governing use of this software, this software is licensed to you

 * under the terms of the GNU General Public License version 2, available

 * at http://www.gnu.org/licenses/gpl-2.0.html (the "GPL").

 *

 * Notwithstanding the above, under no circumstances may you combine this

 * software in any way with any other Qlogic software provided under a

 * license other than the GPL, without Qlogic's express prior written

 * consent.

 *

 * Written by Yaniv Rosner

 *

*******************************************************/

 LED Blink rate that will achieve ~15.9Hz */

**********************************************************/

			Shortcut definitions		   */

**********************************************************/

 ETS defines*/

*********************************************************/

                     INTERFACE                          */

*********************************************************/

/*

 * bnx2x_check_lfa - This function checks if link reinitialization is required,

 *                   or link flap can be avoided.

 *

 * @params:	link parameters

 * Returns 0 if Link Flap Avoidance conditions are met otherwise, the failed

 *         condition code.

	/* NOTE: must be first condition checked -

	* to verify DCC bit is cleared in any case!

 Verify that link is up */

	/* if loaded after BOOT from SAN, don't flap the link in any case and

	 * rely on link set by preboot driver

 Verify that loopback mode is not set */

 Verify that MFW supports LFA */

 Compare Duplex */

 Compare Flow Control */

 Compare Link Speed */

 LFA conditions are met */

*****************************************************************/

			EPIO/GPIO section			  */

*****************************************************************/

 Sanity check */

 Set this EPIO to output */

 Sanity check */

 Set this EPIO to output */

 Set the value for this EPIO */

*****************************************************************/

				ETS section			  */

*****************************************************************/

 ETS disabled configuration*/

	/* mapping between entry  priority to client number (0,1,2 -debug and

	 * management clients, 3 - COS0 client, 4 - COS client)(HIGHEST)

	 * 3bits client num.

	 *   PRI4    |    PRI3    |    PRI2    |    PRI1    |    PRI0

	 * cos1-100     cos0-011     dbg1-010     dbg0-001     MCP-000

	/* Bitmap of 5bits length. Each bit specifies whether the entry behaves

	 * as strict.  Bits 0,1,2 - debug and management entries, 3 -

	 * COS0 entry, 4 - COS1 entry.

	 * COS1 | COS0 | DEBUG1 | DEBUG0 | MGMT

	 * bit4   bit3	  bit2   bit1	  bit0

	 * MCP and debug are strict

 defines which entries (clients) are subjected to WFQ arbitration */

	/* For strict priority entries defines the number of consecutive

	 * slots for the highest priority.

	/* mapping between the CREDIT_WEIGHT registers and actual client

	 * numbers

 ETS mode disable */

	/* If ETS mode is enabled (there is no strict priority) defines a WFQ

	 * weight for COS0/COS1.

 Upper bound that COS0_WEIGHT can reach in the WFQ arbiter */

 Defines the number of consecutive slots for the strict priority */

/******************************************************************************

* Description:

*	Getting min_w_val will be set according to line speed .

*.

 Calculate min_w_val.*/

	/* If the link isn't up (static configuration for example ) The

	 * link will be according to 20GBPS.

/******************************************************************************

* Description:

*	Getting credit upper bound form min_w_val.

*.

/******************************************************************************

* Description:

*	Set credit upper bound for NIG.

*.

/******************************************************************************

* Description:

*	Will return the NIG ETS registers to init values.Except

*	credit_upper_bound.

*	That isn't used in this configuration (No WFQ is enabled) and will be

*	configured according to spec

*.

	/* Mapping between entry  priority to client number (0,1,2 -debug and

	 * management clients, 3 - COS0 client, 4 - COS1, ... 8 -

	 * COS5)(HIGHEST) 4bits client num.TODO_ETS - Should be done by

	 * reset value or init tool

	/* For strict priority entries defines the number of consecutive

	 * slots for the highest priority.

	/* Mapping between the CREDIT_WEIGHT registers and actual client

	 * numbers

Port 1 has 6 COS*/

Port 0 has 9 COS*/

	/* Bitmap of 5bits length. Each bit specifies whether the entry behaves

	 * as strict.  Bits 0,1,2 - debug and management entries, 3 -

	 * COS0 entry, 4 - COS1 entry.

	 * COS1 | COS0 | DEBUG1 | DEBUG0 | MGMT

	 * bit4   bit3	  bit2   bit1	  bit0

	 * MCP and debug are strict

 defines which entries (clients) are subjected to WFQ arbitration */

	/* Please notice the register address are note continuous and a

	 * for here is note appropriate.In 2 port mode port0 only COS0-5

	 * can be used. DEBUG1,DEBUG1,MGMT are never used for WFQ* In 4

	 * port mode port1 only COS0-2 can be used. DEBUG1,DEBUG1,MGMT

	 * are never used for WFQ

/******************************************************************************

* Description:

*	Set credit upper bound for PBF.

*.

	/* In 2 port mode port0 has COS0-5 that can be used for WFQ.In 4

	 * port mode port1 has COS0-2 that can be used for WFQ.

/******************************************************************************

* Description:

*	Will return the PBF ETS registers to init values.Except

*	credit_upper_bound.

*	That isn't used in this configuration (No WFQ is enabled) and will be

*	configured according to spec

*.

	/* Mapping between entry  priority to client number 0 - COS0

	 * client, 2 - COS1, ... 5 - COS5)(HIGHEST) 4bits client num.

	 * TODO_ETS - Should be done by reset value or init tool

  0x688 (|011|0 10|00 1|000) */

  (10 1|100 |011|0 10|00 1|000) */

 TODO_ETS - Should be done by reset value or init tool */

 0x688 (|011|0 10|00 1|000)*/

 0x2C688 (10 1|100 |011|0 10|00 1|000) */

	/* In 2 port mode port0 has COS0-5 that can be used for WFQ.

	 * In 4 port mode port1 has COS0-2 that can be used for WFQ.

/******************************************************************************

* Description:

*	E3B0 disable will return basically the values to init values.

*.

/******************************************************************************

* Description:

*	Disable will return basically the values to init values.

*

/******************************************************************************

* Description

*	Set the COS mappimg to SP and BW until this point all the COS are not

*	set as SP or BW.

/******************************************************************************

* Description:

*	This function is needed because NIG ARB_CREDIT_WEIGHT_X are

*	not continues and ARB_CREDIT_WEIGHT_0 + offset is suitable.

 Calculate and set BW for this COS - use 1 instead of 0 for BW */

/******************************************************************************

* Description:

*	Calculate the total BW.A value of 0 isn't legal.

*

 Calculate total BW requested */

				/* This is to prevent a state when ramrods

				 * can't be sent

 Check total BW is valid */

		/* We can handle a case whre the BW isn't 100 this can happen

		 * if the TC are joined.

/******************************************************************************

* Description:

*	Invalidate all the sp_pri_to_cos.

*

/******************************************************************************

* Description:

*	Calculate and set the SP (ARB_PRIORITY_CLIENT) NIG and PBF registers

*	according to sp_pri_to_cos.

*

/******************************************************************************

* Description:

*	Returns the correct value according to COS and priority in

*	the sp_pri_cli register.

*

/******************************************************************************

* Description:

*	Returns the correct value according to COS and priority in the

*	sp_pri_cli register for NIG.

*

 MCP Dbg0 and dbg1 are always with higher strict pri*/

/******************************************************************************

* Description:

*	Returns the correct value according to COS and priority in the

*	sp_pri_cli register for PBF.

*

/******************************************************************************

* Description:

*	Calculate and set the SP (ARB_PRIORITY_CLIENT) NIG and PBF registers

*	according to sp_pri_to_cos.(which COS has higher priority)

*

 MCP Dbg0 and dbg1 are always with higher strict pri*/

 Set all the strict priority first */

 COS is used remove it from bitmap.*/

 Set all the Non strict priority i= COS*/

 Check if COS was already used for SP */

 COS wasn't used for SP */

 COS is used remove it from bitmap.*/

 Only 6 usable clients*/

 Only 9 usable clients*/

/******************************************************************************

* Description:

*	Configure the COS to ETS according to BW and SP settings.

 Prepare sp strict priority parameters*/

 Prepare BW parameters*/

	/* Upper bound is set according to current link speed (min_w_val

	 * should be the same for upper bound and COS credit val).

			/* The function also sets the BW in HW(not the mappin

			 * yet)

 Set SP register (which COS has higher priority) */

 Set client mapping of BW and strict */

 ETS disabled configuration */

	/* Defines which entries (clients) are subjected to WFQ arbitration

	 * COS0 0x8

	 * COS1 0x10

	/* Mapping between the ARB_CREDIT_WEIGHT registers and actual

	 * client numbers (WEIGHT_0 does not actually have to represent

	 * client 0)

	 *    PRI4    |    PRI3    |    PRI2    |    PRI1    |    PRI0

	 *  cos1-001     cos0-000     dbg1-100     dbg0-011     MCP-010

 ETS mode enabled*/

 Defines the number of consecutive slots for the strict priority */

	/* Bitmap of 5bits length. Each bit specifies whether the entry behaves

	 * as strict.  Bits 0,1,2 - debug and management entries, 3 - COS0

	 * entry, 4 - COS1 entry.

	 * COS1 | COS0 | DEBUG21 | DEBUG0 | MGMT

	 * bit4   bit3	  bit2     bit1	   bit0

	 * MCP and debug are strict

 Upper bound that COS0_WEIGHT can reach in the WFQ arbiter.*/

 ETS disabled configuration*/

 ETS disabled configuration*/

	/* Bitmap of 5bits length. Each bit specifies whether the entry behaves

	 * as strict.  Bits 0,1,2 - debug and management entries,

	 * 3 - COS0 entry, 4 - COS1 entry.

	 *  COS1 | COS0 | DEBUG21 | DEBUG0 | MGMT

	 *  bit4   bit3	  bit2      bit1     bit0

	 * MCP and debug are strict

	/* For strict priority entries defines the number of consecutive slots

	 * for the highest priority.

 ETS mode disable */

 Defines the number of consecutive slots for the strict priority */

 Defines the number of consecutive slots for the strict priority */

	/* Mapping between entry  priority to client number (0,1,2 -debug and

	 * management clients, 3 - COS0 client, 4 - COS client)(HIGHEST)

	 * 3bits client num.

	 *   PRI4    |    PRI3    |    PRI2    |    PRI1    |    PRI0

	 * dbg0-010     dbg1-001     cos1-100     cos0-011     MCP-000

	 * dbg0-010     dbg1-001     cos0-011     cos1-100     MCP-000

*****************************************************************/

			PFC section				  */

*****************************************************************/

 XMAC base adrr */

 Initialize pause and pfc registers */

 No PFC support */

		/* RX flow control - Process pause frame in receive direction

 TX flow control - Send pause packet when buffer is full */

 PFC support */

 Write pause and PFC registers */

 Write pause and PFC registers */

 Set MAC address for source TX Pause/PFC frames */

*****************************************************************/

			MAC/PBF section				  */

*****************************************************************/

	/* Set clause 45 mode, slow down the MDIO clock to 2.5MHz

	 * (a value of 49==0x31) and make sure that the AUTO poll is off

 Set mdio clock per phy */

 Check 4-port override enabled */

 Return 4-port mode override value */

 Return 4-port mode from input pin */

 reset and unreset the emac core */

 init emac - use read-modify-write */

 self clear reset */

 Set mac address */

 Disable RX and TX */

 Reset UMAC */

 This register opens the gate for the UMAC despite its name */

 Configure UMAC for EEE */

 Set MAC address for source TX Pause/PFC frames (under SW reset) */

 Enable RX and TX */

 Remove SW Reset */

 Check loopback mode */

	/* Maximum Frame Length (RW). Defines a 14-Bit maximum frame

	 * length used by the MAC receive logic to check frames.

 Define the XMAC mode */

	/* In 4-port mode, need to set the mode only once, so if XMAC is

	 * already out of reset, it means the mode has already been set,

	 * and it must not* reset the XMAC again, since it controls both

	 * ports of the path

 Hard reset */

 Set the number of ports on the system side to up to 2 */

 Set the number of ports on the Warp Core to 10G */

 Set the number of ports on the system side to 1 */

 Set the number of ports on the Warp Core to 10G */

 Set the number of ports on the Warp Core to 20G */

 Soft reset */

		/* Send an indication to change the state in the NIG back to XON

		 * Clearing this bit enables the next set of this bit to get

		 * rising edge

	/* This register determines on which events the MAC will assert

	 * error on the i/f to the NIG along w/ EOP.

	/* This register tells the NIG whether to send traffic to UMAC

	 * or XMAC

	/* When XMAC is in XLGMII mode, disable sending idles for fault

	 * detection.

 Set Max packet size */

 CRC append for Tx packets */

 update PFC */

 Enable TX and RX */

 Set MAC in XLGMII mode for dual-mode */

 Check loopback mode */

 Disable BMAC */

 enable emac and not bmac */

 ASIC */

 select the master lanes (out of 0-3) */

 select XGXS */

 SerDes */

 select SerDes */

 pause enable/disable */

 KEEP_VLAN_TAG, promiscuous */

	/* Setting this bit causes MAC control frames (except for pause

	 * frames) to be passed on for processing. This setting has no

	 * affect on the operation of the pause frames. This bit effects

	 * all packets regardless of RX Parser packet sorting logic.

	 * Turn the PFC off to make sure we are in Xon state before

	 * enabling it.

 Enable PFC again */

 Set Loopback */

 Enable emac */

 Enable emac for jumbo packets */

 Strip CRC */

 Disable the NIG in/out to the bmac */

 Enable the NIG in/out to the emac */

 Enable BigMAC to react on received Pause packets */

 TX control */

	/* Set rx control: Strip CRC and enable BigMAC to relay

	 * control packets to the system as well

 Enable BigMAC to react on received Pause packets */

 Tx control */

 Enable PFC RX & TX & STATS and set 8 COS  */

 RX */

 TX */

 Force initial Xon */

 8 cos */

 STATS */

 Clear the force Xon */

 Disable PFC RX & TX & STATS and set 8 COS */

	/* Set Time (based unit is 512 bit time) between automatic

	 * re-sending of PP packets amd enable automatic re-send of

	 * Per-Priroity Packet as long as pp_gen is asserted and

	 * pp_disable is low.

 enable automatic re-send */

 mac control */

 Enable RX and TX */

 Local loopback */

 When PFC enabled, Pass pause frames towards the NIG. */

/******************************************************************************

* Description:

*  This function is needed because NIG ARB_CREDIT_WEIGHT_X are

*  not continues and ARB_CREDIT_WEIGHT_0 + offset is suitable.

	/* When NIG_LLH0_XCM_MASK_REG_LLHX_XCM_MASK_BCN bit is set

	 * MAC control frames (that are not pause packets)

	 * will be forwarded to the XCM.

	/* NIG params will override non PFC params, since it's possible to

	 * do transition from PFC to SAFC

 Default non PFC mode - PAUSE */

 Output enable for RX_XCM # IF */

 HW PFC TX enable */

	/* The PFC and pause are orthogonal to one another, meaning when

	 * PFC is enabled, the pause are disabled, and when PFC is

	 * disabled, pause are set according to the pause result.

 Update NIG params */

 XGXS control */

 TX MAC SA */

 MAC control */

 Set rx mtu */

 Set tx mtu */

 Set cnt max size */

 Configure SAFC */

 XGXS control: Reset phy HW, MDIO registers, PHY PLL and BMAC */

 TX MAC SA */

 Configure SAFC */

 Set RX MTU */

 Set TX MTU */

 Set cnt max size */

 Reset and unreset the BigMac */

 Enable access for bmac registers */

 Enable BMAC according to BMAC type*/

 Only if the bmac is out of reset */

 Clear Rx Enable bit in BMAC_CONTROL register */

 Disable port */

 Wait for init credit */

 Update threshold */

 Update init credit */

 (800-18-4) */

 Update threshold */

 Update init credit */

 Probe the credit changes */

 Enable port */

/**

 * bnx2x_get_emac_base - retrive emac base address

 *

 * @bp:			driver handle

 * @mdc_mdio_access:	access type

 * @port:		port id

 *

 * This function selects the MDC/MDIO access (through emac0 or

 * emac1) depend on the mdc_mdio_access, port, port swapped. Each

 * phy has a default access mode, which could also be overridden

 * by nvram configuration. This parameter, whether this is the

 * default phy configuration, or the nvram overrun

 * configuration, is passed here as mdc_mdio_access and selects

 * the emac_base for the CL45 read/writes operations

*****************************************************************/

			CL22 access functions			  */

*****************************************************************/

 Switch to CL22 */

 Address */

 Switch to CL22 */

 Address */

*****************************************************************/

			CL45 access functions			  */

*****************************************************************/

 Address */

 Data */

 Work around for E3 A0 */

 Address */

 Data */

 Work around for E3 A0 */

*****************************************************************/

			EEE section				   */

*****************************************************************/

 time value in eee_mode --> used directly*/

 hsi value in eee_mode --> time */

 hsi values in nvram --> time*/

 eee_idle in 1u --> eee_status in 16u */

 Propagate params' bits --> vars (for migration exposure) */

 Make Certain LPI is disabled */

 Mask events preventing LPI generation */

*****************************************************************/

			BSC access functions from E3	          */

*****************************************************************/

 Read I2C output PINs */

 Read I2C output value */

 Enable the engine */

 Program slave device ID */

 Start xfer with 0 byte to update the address pointer ???*/

 Poll for completion */

 Start xfer with read op */

 Poll for completion */

	/* Probe for the phy according to the given phy_addr, and execute

	 * the read request on it

	/* Probe for the phy according to the given phy_addr, and execute

	 * the write request on it

 Figure out path swap value */

 Figure out port swap value */

 Two port mode - no port swap */

 Figure out path swap value */

		/* In Dual-lane mode, two lanes are joined together,

		 * so in order to configure them, the AER broadcast method is

		 * used here.

		 * 0x200 is the broadcast address for lanes 0,1

		 * 0x201 is the broadcast address for lanes 2,3

*****************************************************************/

			Internal phy section			  */

*****************************************************************/

 Set Clause 22 */

 Set Clause 45 */

 Reset and unreset the SerDes/XGXS */

 Set correct devad */

 Reset and unreset the SerDes/XGXS */

	/* Resolve pause mode and advertisement Please refer to Table

	 * 28B-3 of the 802.3ab-1999 spec

 Read modify write pause advertizing */

 Please refer to Table 28B-3 of 802.3ab-1999 spec. */

  LD	    LP	 */

 ASYM P ASYM P */

   1  0   1  1 */

   1  1   1  0 */

   0  1   0  1 */

   0  1   1  1 */

   1  1   0  1 */

   1  1   1  1 */

		/* If the user selected to advertise RX ONLY,

		 * although we advertised both, need to enable

		 * RX only.

 local */

 link partner */

 Update the advertised flow-controled of LD/LP in AN */

 But set the flow-control result as the requested one */

*****************************************************************/

			Warpcore section			  */

*****************************************************************/

/* The init_internal_warpcore should mirror the xgxs,

 * i.e. reset the lane (if needed), set aer for the

 * init configuration, and set/clear SGMII flag. Internal

 * phy init is done purely in phy_init stage.

 Step 1 - Program the TX/RX alignment markers */

 Step 2 - Configure the NP registers */

 Start KR2 work-around timer which handles BCM8073 link-parner */

 Step 1 - Program the TX/RX alignment markers */

 Restart autoneg on the leading lane only */

 Restore AER */

 Disable Autoneg: re-enable it after adv is done. */

 Set to default registers that may be overriden by 10G force */

 Check adding advertisement for 1G KX */

 Enable CL37 1G Parallel Detect */

 Check adding advertisement for 10G KR */

 Enable 10G Parallel Detect */

 Set Transmit PMD settings */

 Configure the next lane if dual mode */

 Advertised speeds */

 Advertised and set FEC (Forward Error Correction) */

 Enable CL37 BAM */

 Advertise pause */

 Over 1G - AN local device user page 1 */

 Enable Auto-Detect to support 1G over CL37 as well */

		/* Force cl48 sync_status LOW to avoid getting stuck in CL73

		 * parallel-detect loop when CL73 and CL37 are enabled.

		/* Restore Polarity settings in case it was run over by

		 * previous link owner

 Enable Autoneg: only on the main lane */

 Disable Autoneg */

 Leave cl72 training enable, needed for KR */

 Global registers */

 Disable CL36 PCS Tx */

 Restore AER */

 Set speed via PMA/PMD register */

 Enable encoded forced speed */

 Turn TX scramble payload only the 64/66 scrambler */

 Turn RX scramble payload only the 64/66 scrambler */

 Set and clear loopback to cause a reset to 64/66 decoder */

 Hold rxSeqStart */

 Hold tx_fifo_reset */

 Disable CL73 AN */

 Disable 100FX Enable and Auto-Detect */

 Disable 100FX Idle detect */

 Set Block address to Remote PHY & Clear forced_speed[5] */

 Turn off auto-detect & fiber mode */

 Set filter_force_link, disable_false_link and parallel_detect */

 Set XFI / SFI */

 TAP values are controlled by nvram, if value there isn't 0 */

		/* If any of the IFIR/IPRE_DRIVER/POST@ is set, apply all

		 * configuration.

 Set Transmit PMD settings */

 Enable fiber mode, enable and invert sig_det */

 Set Block address to Remote PHY & Set forced_speed[5], 40bit mode */

 10G XFI Full Duplex */

 Release tx_fifo_reset */

 Release rxSeqStart */

 Set global registers, so set AER lane to 0 */

 Disable sequencer */

 Turn off CL73 */

 Set 20G KR2 force speed */

 Enable sequencer (over lane 0) */

 Rx0 anaRxControl1G */

 Rx2 anaRxControl1G */

 Serdes Digital Misc1 */

 Serdes Digital4 Misc3 */

 Set Transmit PMD settings */

 Clear XFI clock comp in non-10G single lane mode. */

 SGMII Autoneg */

 SGMII Slave mode and disable signal detect */

 Turn off parallel detect */

 Re-enable parallel detect */

 Enable autodet */

 Take lane out of reset after configuration is finished */

 Clear SFI/XFI link settings registers */

 Set XFI clock comp as default. */

		/* Should not happen. This function called upon interrupt

		 * triggered by GPIO ( since EPIO can only generate interrupts

		 * to MCP).

		 * So if this function was called and none of the GPIOs was set,

		 * it means the shit hit the fan.

 Call the handling function in case module is detected */

 Do we get link yet? */

 1G */

10G KR*/

 Reset the lane to see if link comes up.*/

 Restart Autoneg */

params->rx_tx_asic_rst*/

 Set the !tx_en since this pin is DISABLE_TX_LASER */

 For 20G, the expected pin to be used is 3 pins after the current */

 Enable KR Auto Neg */

			/* Issue Module detection if module is plugged, or

			 * enabled transmitter to avoid current leakage in case

			 * no module is connected

 Issue Module detection */

 Take lane out of reset after configuration is finished */

 Global register */

 Clear loopback settings (if any) */

 10G & 20G */

 Update those 1-copy registers */

 Enable 1G MDIO (1-copy) */

 Disable CL36 PCS Tx */

 Restore AER */

 10/100/1000/20G-KR2 */

 Update those 1-copy registers */

 Enable 1G MDIO (1-copy) */

 Set 1G loopback based on lane (1-copy) */

 Switch back to 4-copy registers */

 10G / 20G-DXGXS */

 Anything 10 and over uses the bmac */

 Link down */

 Indicate no mac active */

 Update PHY configuration */

 Force link UP in non LOOPBACK_EXT loopback mode(s) */

 Sync media type */

 Sync AEU offset */

 Sync PFC status */

 Set the master_ln for AN */

 Reset the unicore */

 Wait for the reset to self clear */

 The reset erased the previous bank value */

	/* Each two bits represents a lane number:

	 * No swap is 0123 => 0x1b no need to enable the swap

 Disable parallel detection of HiG */

 CL37 Autoneg */

 CL37 Autoneg Enabled */

 CL37 Autoneg Disabled */

 Enable/Disable Autodetection */

 Enable TetonII and BAM autoneg */

 Enable BAM aneg Mode and TetonII aneg Mode */

 TetonII and BAM Autoneg Disabled */

 Enable Cl73 FSM status bits */

 Enable BAM Station Manager*/

 Advertise CL73 link speeds */

 CL73 Autoneg Enabled */

 CL73 Autoneg Disabled */

 Program SerDes, forced speed */

 Program duplex, disable autoneg and sgmii*/

	/* Program speed

	 *  - needed only if the speed is greater than 1G (2.5G or 10G)

 Clearing the speed value before setting the right speed */

 Set extended capabilities */

 For AN, we are always publishing full duplex */

 Enable and restart BAM/CL37 aneg */

 In SGMII mode, the unicore is always slave */

 Set sgmii mode (and not fiber) */

 If forced speed */

 Set speed, disable autoneg */

 There is nothing to set for 10M */

 Invalid speed for SGMII */

 Setting the full duplex */

 AN mode */

 Enable and restart AN */

/* Link management

 local driver */

 link partner */

 Resolve from gp_status in case of AN complete and not sgmii */

 Update the advertised flow-controled of LD/LP in AN */

 But set the flow-control result as the requested one */

 Step 1: Make sure signal is detected */

 Step 2: Check CL73 state machine */

	/* Step 3: Check CL37 Message Pages received to indicate LP

	 * supports only CL37

	/* The combined cl37/cl73 fsm state information indicating that

	 * we are connected to a device which does not support cl73, but

	 * does support cl37 BAM. In this case we disable cl73 and

	 * restart cl37 auto-neg

 Disable CL73 */

 Restart CL37 autoneg */

 link_down */

 Read gp_status */

 Link_down */

 Check signal is detected */

 Read LP advertised speeds*/

 Read gp_status */

 Check for either KR, 1G, or AN up. */

 Check Autoneg complete */

 Check parallel detect used */

 In case of KR link down, start up the recovering procedure */

 Read precomp */

 Bits [10:7] at lp_up2, positioned at [15:12] */

 Replace tx_driver bits [15:12] */

 10G not valid for EMAC */

 Forced speed requested? */

 Disable autoneg */

 Program speed and duplex */

 AN_mode */

 AN enabled */

 Program duplex & pause advertisement (for aneg) */

 Enable autoneg */

 Enable and restart AN */

 SGMII mode */

 Reset the SerDes and wait for reset bit return low */

 Setting the masterLn_def again after the reset */

 Wait for soft reset to get cleared up to 1 sec */

 Setting the status to report on link up for either XGXS or SerDes */

 SerDes */

	/* Disable the MI INT ( external phy int ) by writing 1 to the

	 * status register. Link down indication is high-active-signal,

	 * so in this case we need to write the status to clear the XOR

 Read Latched signals */

 Handle only those with latched-signal=up.*/

 For all latched-signal=up : Re-Arm Latch signals */

 For all latched-signal=up,Write original_signal to status */

	/* First reset all status we assume only one line will be

	 * change at a time

				/* Disable the link interrupt by writing 1 to

				 * the relevant lane in the status register

 Need more than 10chars for this format */

 Need more than 10chars for this format */

 Extract first external phy*/

 Change the uni_phy_addr in the nig */

 Set aer mmd back */

 And md_devad */

 In case */

		/* For all other phys, OPER mode is same as ON, so in case

		 * link is down, do nothing

 This is a work-around for E2+8727 Configurations */

				/* Return here without enabling traffic

				 * LED blink and setting rate in ON mode.

				 * In oper mode, enabling LED blink

				 * and setting rate is needed.

			/* This is a work-around for HW issue found when link

			 * is up in CL73

			/* Break here; otherwise, it'll disable the

			 * intended override.

 Set blinking rate to ~15.9Hz */

 For speeds less than 10G LED scheme is different */

/* This function comes to reflect the actual link state read DIRECTLY from the

 * HW

 Check 20G link */

 Check 10G link and below*/

 Link is up only if both local phy and external phy are up */

 In XGXS loopback mode, do not check external PHY */

 No external PHY */

 Dual Media */

	/* In case of external phy existence, the line speed would be the

	 * line speed linked up by the external phy. In case it is direct

	 * only, then the line_speed during initialization will be

	 * equal to the req_line_speed

	/* Initialize the internal phy in case this is a direct board

	 * (no external phys), or this board has external phy which requires

	 * to first.

 init ext phy and enable link state int */

	/* Re-read this value in case it was changed inside config_init due to

	 * limitations of optic module

 Init external phy*/

			/* No need to initialize second phy in case of first

			 * phy only selection. In case of second phy, we do

			 * need to initialize the first phy, since they are

			 * connected.

 Reset the interrupt indication after phy was initialized */

 Reset the SerDes/XGXS */

 HW reset */

 Indicate no mac active */

 Update shared memory */

 Activate nig drain */

 Disable emac */

 Reset BigMac/Xmac */

 Prevent LPI Generation by chip */

 AN complete? */

 PBF - link up */

 Disable drain */

 Update shared memory */

 Check remote fault */

 Verify the link_change_count is supported by the MFW */

/* The bnx2x_link_update function should be called upon link

 * interrupt.

 * Link is considered up as follows:

 * - DIRECT_SINGLE_MEDIA - Only XGXS link (internal link) needs

 *   to be up

 * - SINGLE_MEDIA - The link between the 577xx and the external

 *   phy (XGXS) need to up as well as the external link of the

 *   phy (PHY_EXT1)

 * - DUAL_MEDIA - The link between the 577xx and the first

 *   external phy needs to be up, and at least one of the 2

 *   external phy link must be up.

 different consideration, since vars holds inner state */

 Disable emac */

	/* Step 1:

	 * Check external link change only for external phys, and apply

	 * priority selection between them in case the link on both phys

	 * is up. Note that instead of the common vars, a temporary

	 * vars argument is used since each phy may have different link/

	 * speed/duplex result

 Read link status and params of this ext phy */

			/* In this option, the first PHY makes sure to pass the

			 * traffic through itself only.

			 * It's not clear how to reset the link on the second

			 * phy.

			/* In this option, the first PHY makes sure to pass the

			 * traffic through the second PHY.

			/* Link indication on both PHYs with the following cases

			 * is invalid:

			 * - FIRST_PHY means that second phy wasn't initialized,

			 * hence its link is expected to be down

			 * - SECOND_PHY means that first phy should not be able

			 * to link up by itself (using configuration)

			 * - DEFAULT should be overridden during initialization

	/* Step 2:

	 * Read the status of the internal phy. In case of

	 * DIRECT_SINGLE_MEDIA board, this link is the external link,

	 * otherwise this is the link between the 577xx and the first

	 * external phy

	/* The INT_PHY flow control reside in the vars. This include the

	 * case where the speed or flow control are not set to AUTO.

	 * Otherwise, the active external phy flow control result is set

	 * to the vars. The ext_phy_line_speed is needed to check if the

	 * speed is different between the internal phy and external phy.

	 * This case may be result of intermediate link speed change.

		/* Link speed is taken from the XGXS. AN and FC result from

		 * the external phy.

		/* if active_external_phy is first PHY and link is up - disable

		 * disable TX on second external PHY

	/* Upon link speed change set the NIG into drain mode. Comes to

	 * deals with possible FIFO glitch due to clk change when speed

	 * is decreased without link down indicator

 Anything 10 and over uses the bmac */

	/* In case external phy link is up, and internal link is down

	 * (not initialized yet probably after link initialization, it

	 * needs to be initialized.

	 * Note that after link down-up as result of cable plug, the xgxs

	 * link would probably become up again without the need

	 * initialize it

	/* Link is up only if both local phy and external phy (in case of

	 * non-direct board) are up and no fault detected on active PHY.

 Update the PFC configuration in case it was changed */

 Update MCP link status was changed */

****************************************************************************/

			    External Phy section			     */

****************************************************************************/

*****************************************************************/

		common BCM8073/BCM8727 PHY SECTION		  */

*****************************************************************/

 local */

 link partner */

 Boot port from external ROM  */

 EDC grst */

 Ucode reboot and rst */

 Reset internal microprocessor */

 Release srst bit */

 Delay 100ms per the PHY specifications */

 8073 sometimes taking longer to download */

 Clear ser_boot_ctl bit */

*****************************************************************/

			BCM8073 PHY SECTION			  */

*****************************************************************/

 This is only required for 8073A1, version 102 only */

 Read 8073 HW revision*/

 No need to workaround in 8073 A1 */

 SNR should be applied only for version 0x102 */

 No need to workaround in 8073 A1 */

 XAUI workaround in 8073 A0: */

	/* After loading the boot ROM and restarting Autoneg, poll

	 * Dev1, Reg $C820:

		  /* If bit [14] = 0 or bit [13] = 0, continue on with

		   * system initialization (XAUI work-around not required, as

		   * these bits indicate 2.5G or 1G link up).

			/* If bit 15 is 0, then poll Dev1, Reg $C841 until it's

			 * MSB (bit15) goes to 1 (indicating that the XAUI

			 * workaround has completed), then continue on with

			 * system initialization.

 Force KR or KX */

 Please refer to Table 28B-3 of 802.3ab-1999 spec. */

 Enable LASI */

 Restore normal power mode*/

 Swap polarity if required - Must be done only in non-1G mode */

 Configure the 8073 to swap _P and _N of the KR lines */

 10G Rx/Tx and 1G Tx signal polarity swap */

 Enable CL37 BAM */

			/* Note that 2.5G works only when used with 1G

			 * advertisement

 Note that 2.5G works only when used with 1G advertisement */

 Allow 2.5G for A1 and above */

 Add support for CL37 (passive mode) II */

 Add support for CL37 (passive mode) III */

	/* The SNR will improve about 2db by changing BW and FEE main

	 * tap. Rest commands are executed after link is up

	 * Change FFE main cursor to 5 in EDC register

 Enable FEC (Forware Error Correction) Request in the AN */

 Restart autoneg */

 Clear the interrupt LASI status register */

 Clear MSG-OUT */

 Check the LASI */

 Check the link status */

 Check the link status on 1.1.2 */

		/* The SNR will improve about 2dbby changing the BW and FEE main

		 * tap. The 1st write to change FFE main tap is set before

		 * restart AN. Change PLL Bandwidth in EDC register

 Change CDR Bandwidth in EDC register */

 Bits 0..2 --> speed detected, bits 13..15--> link is down */

 Swap polarity if required */

 Configure the 8073 to swap P and N of the KR lines */

			/* Set bit 3 to invert Rx in 1G mode and clear this bit

			 * when it`s in 10G mode.

*****************************************************************/

			BCM8705 PHY SECTION			  */

*****************************************************************/

 Restore normal power mode*/

 HW reset */

 BCM8705 doesn't have microcode, hence the 0 */

*****************************************************************/

			SFP+ module Section			  */

*****************************************************************/

	/* Disable transmitter only for bootcodes which can enable it afterwards

	 * (for D3 link)

 Disable/Enable transmitter ( TX laser of the SFP+ module.)*/

 Set the read command byte count */

 Set the read command address */

 Activate read command */

 Wait up to 500us for command complete status */

 Read the buffer */

	/* Low ==> corresponding SFP+ module is powered

	 * high ==> the SFP+ module is powered down

 4 byte aligned address */

 Note that 100us are not enough here */

	/* Set 2-wire transfer rate of SFP+ module EEPROM

	 * to 100Khz since some DACs(direct attached cables) do

	 * not work at 400Khz.

 Need to read from 1.8000 to clear it */

 Set the read command byte count */

 Set the read command address */

 Set the destination address */

 Activate read command */

	/* Wait appropriate time for two-wire command to finish before

	 * polling the status register

 Wait up to 500us for command complete status */

 Read the buffer */

 First check for copper cable */

		/* Check if its active cable (includes SFP+ module)

		 * of passive cable

			/* Even in case PASSIVE_DAC indication is not set,

			 * treat it as a passive DAC cable, since some cables

			 * don't have this indication.

 Update media type for non-PMF sync */

/* This function read the relevant field from the module (SFP+), and verify it

 * is compliant with this board

 Use specific phy request */

 Use first phy request only in case of non-dual media*/

 No support in OPT MDL detection */

 Format the warning message */

	/* Initialization time after hot-plug may take up to 300ms for

	 * some phys type ( e.g. JDSU )

 Make sure GPIOs are not using for LED mode */

	/* In the GPIO register, bit 4 is use to determine if the GPIOs are

	 * operating as INPUT or as OUTPUT. Bit 1 is for input, and 0 for

	 * output

	 * Bits 0-1 determine the GPIOs value for OUTPUT in case bit 4 val is 0

	 * Bits 8-9 determine the GPIOs value for INPUT in case bit 4 val is 1

	 * where the 1st bit is the over-current(only input), and 2nd bit is

	 * for power( only output )

	 *

	 * In case of NOC feature is disabled and power is up, set GPIO control

	 *  as input to enable listening of over-current indication

		/* Set GPIO control to OUTPUT, and set the power bit

		 * to according to the is_power_up

 LRM mode ( default )*/

		/* Changing to LRM mode takes quite few seconds. So do it only

		 * if current mode is limiting (default is LRM)

 Keep the MSB 8-bits, and set the LSB 8-bits with the edc_mode */

 Make MOD_ABS give interrupt on change */

		/* Set 8727 GPIOs to input to allow reading from the 8727 GPIO0

		 * status which reflect SFP+ module over-current

 Reset bits 4-6 */

		/* Low ==> if SFP+ module is supported otherwise

		 * High ==> if SFP+ module is not on the approved vendor list

 Put Warpcore in low power mode */

 Put LCPLL in low power mode */

 This is a global register which controls all lanes */

 A must read */

 Restart microcode to re-read the new mode */

 Enabled transmitter by default */

 Power up module */

 Check SFP+ module compatibility */

 Turn on fault module-detected led */

 Check if need to power down the SFP+ module */

 Turn off fault module-detected led */

	/* Check and set limiting mode / LRM mode on 8726. On 8727 it

	 * is done automatically

	/* Disable transmit for this module if the module is not approved, and

	 * laser needs to be disabled.

 Always enable TX laser,will be disabled in case of fault */

 Set valid module led off */

 Get current gpio val reflecting module plugged in / out*/

 Call the handling function in case module is detected */

				/* In case WC is out of reset, reconfigure the

				 * link speed while taking into account 1G

				 * module limitation.

		/* Module was plugged out.

		 * Disable transmit for this module

*****************************************************************/

		Used by 8706 and 8727                             */

*****************************************************************/

 Mask or enable the fault event. */

*****************************************************************/

		common BCM8706/BCM8726 PHY SECTION		  */

*****************************************************************/

 Clear RX Alarm*/

 Clear LASI indication*/

	/* Link is up if both bit 0 of pmd_rx_sd and bit 0 of pcs_status

	 * are set, or if the autoneg bit 1 is set

 Capture 10G link fault. Read twice to clear stale value. */

*****************************************************************/

			BCM8706 PHY SECTION			  */

*****************************************************************/

 HW reset */

 Wait until fw is loaded */

 Clear first 3 bits of the control */

 Set control bits according to configuration */

 Force speed */

 Arm LASI for link and Tx fault. */

 Force 1Gbps using autoneg with 1G advertisement */

 Allow CL37 through CL73 */

 Enable Full-Duplex advertisement on CL37 */

 Enable CL37 AN */

 1G support */

 Enable clause 73 AN */

	/* If TX Laser is controlled by GPIO_0, do not let PHY go into low

	 * power mode, if TX Laser is disabled

*****************************************************************/

			BCM8726 PHY SECTION			  */

*****************************************************************/

 Need to wait 100ms after reset */

 Micro controller re-boot */

 Set soft reset */

 Wait for 150ms for microcode load */

 Disable serial boot control, tristates pins SS_N, SCK, MOSI, MISO */

	/* Need to call module detected on initialization since the module

	 * detection triggered by actual module insertion might occur before

	 * driver is loaded, and when driver is loaded, it reset all

	 * registers, including the transmitter

 Set Flow control */

		/* Enable RX-ALARM control to receive interrupt for 1G speed

		 * change

 Default 10G. Set only LASI control */

 Set TX PreEmphasis if needed */

 Set serial boot control for external load */

*****************************************************************/

			BCM8727 PHY SECTION			  */

*****************************************************************/

 Only NOC flavor requires to set the LED specifically */

	/* The PHY reset is controlled by GPIO 1. Fake the port number

	 * to cancel the swap done in set_gpio()

 Set option 1G speed */

		/* Power down the XAUI until link is up in case of dual-media

		 * and 1G

		/* Since the 8727 has only single reset pin, need to set the 10G

		 * registers although it is default

 Enable PMD link, MOD_ABS_FLT, and 1G link alarm */

	/* Initially configure MOD_ABS to interrupt when module is

	 * presence( bit 8)

	/* Set EDC off by setting OPTXLOS signal input to low (bit 9).

	 * When the EDC is off it locks onto a reference clock and avoids

	 * becoming 'lost'

 Enable/Disable PHY transmitter output */

 Set TX PreEmphasis if needed */

	/* If TX Laser is controlled by GPIO_0, do not let PHY go into low

	 * power mode, if TX Laser is disabled

 Module is absent */

		/* 1. Set mod_abs to detect next module

		 *    presence event

		 * 2. Set EDC off by setting OPTXLOS signal input to low

		 *    (bit 9).

		 *    When the EDC is off it locks onto a reference clock and

		 *    avoids becoming 'lost'.

		/* Clear RX alarm since it stays up as long as

		 * the mod_abs wasn't changed

 Module is present */

		/* First disable transmitter, and if the module is ok, the

		 * module_detection will enable it

		 * 1. Set mod_abs to detect next module absent event ( bit 8)

		 * 2. Restore the default polarity of the OPRXLOS signal and

		 * this signal will then correctly indicate the presence or

		 * absence of the Rx signal. (bit 9)

		/* Clear RX alarm since it stays up as long as the mod_abs

		 * wasn't changed. This is need to be done before calling the

		 * module detection, otherwise it will clear* the link update

		 * alarm

 Reconfigure link speed based on module type limitations */

 No need to check link status in case of module plugged in/out */

 If PHY is not initialized, do not check link status */

 Check the LASI on Rx */

 Clear MSG-OUT */

	/* If a module is present and there is need to check

	 * for over current

 Check over-current using 8727 GPIO0 input*/

 Disable all RX_ALARMs except for mod_abs */

 Wait for module_absent_event */

 Clear RX alarm */

 Over current check */

 When module absent bit is set, check module */

 Enable all mod_abs and link detection bits */

	/* Bits 0..2 --> speed detected,

	 * Bits 13..15--> link is down

 Capture 10G link fault. */

		/* In case of dual-media board and 1G, power up the XAUI side,

		 * otherwise power it down. For 10G it is done automatically

 Enable/Disable PHY transmitter output */

 Disable Transmitter */

 Clear LASI */

*****************************************************************/

		BCM8481/BCM84823/BCM84833 PHY SECTION	          */

*****************************************************************/

 For 32-bit registers in 848xx, access via MDIO2ARM i/f. */

 (1) set reg 0xc200_0014(SPI_BRIDGE_CTRL_2) to 0x03000000 */

 2) read register 0xc200_0000 (SPI_FW_STATUS) */

 lower 16 bits of the register SPI_FW_STATUS */

 upper 16 bits of register SPI_FW_STATUS */

 Set LED5 source */

 Set LED3 BLINK */

 PHYC_CTL_LED_CTL */

 LED5 ON based on source */

 stretch_en for LEDs */

 Save spirom version */

		/* This phy uses the NIG latch mechanism since link indication

		 * arrives through its LED4 and not via its LASI signal, so we

		 * get steady signal instead of clear on read

 set 1000 speed advertisement */

 Disable forced speed */

 Set 10/100 speed advertisement */

			/* Enable autoneg and restart autoneg for legacy speeds

			/* Enable autoneg and restart autoneg for legacy speeds

 Only 10/100 are allowed to work in FORCE mode */

 Enabled AUTO-MDIX when autoneg is disabled */

 The PHY needs this set even for forced link. */

 Enabled AUTO-MDIX when autoneg is disabled */

	/* Always write this if this is not 84833/4.

	 * For 84833/4, write it only when it's a forced speed.

 Restart autoneg for 10G*/

 Restore normal power mode*/

 HW reset */

	/* Step 1: Poll the STATUS register to see whether the previous command

	 * is in progress or the system is busy (CMD_IN_PROGRESS or

	 * SYSTEM_BUSY). If previous command is in progress or system is busy,

	 * check again until the previous command finishes execution and the

	 * system is available for taking command

	/* Step2: If any parameters are required for the function, write them

	 * to the required DATA registers

	/* Step3: When the firmware is ready for commands, write the 'Command

	 * code' to the CMD register

	/* Step4: Once the command has been written, poll the STATUS register

	 * to check whether the command has completed (CMD_COMPLETED_PASS/

	 * CMD_FOR_CMDS or CMD_COMPLETED_ERROR).

	/* Step5: Once the command has completed, read the specficied DATA

	 * registers for any saved results for the command, if applicable

 Gather returning data */

 Write CMD_OPEN_OVERRIDE to STATUS reg */

		/* if the status is CMD_COMPLETE_PASS or CMD_COMPLETE_ERROR

		 * clear the status to CMD_CLEAR_COMPLETE

 Prepare argument(s) */

 Gather returning data */

 Check for configuration. */

 Only the second argument is used for this command */

 Assume that these will be GPIOs, not EPIOs. */

 Map config param to register bit. */

 E2, look from diff place of shmem. */

 Work around for 84833 LED failure inside RESET status */

 Prevent Phy from working in EEE and advertising it */

 MDIO reset */

 Wait for GPHY to come out of reset */

		/* BCM84823 requires that XGXS links up first @ 10G for normal

		 * behavior.

 Check if this is actually BCM84858 */

 Set dual-media configuration according to configuration */

 Do nothing. Essentially this is like the priority copper */

 Do nothing here. The first PHY won't be initialized at all */

 Keep AutogrEEEn disabled. */

 84833 PHY has a better feature and doesn't need to support this. */

 Configure EEE support */

 Additional settings for jumbo packets in 1000BASE-T mode */

 Allow rx extended length */

 TX FIFO Elasticity LSB */

 TX FIFO Elasticity MSB */

 Enable expansion register 0x46 (Pattern Generator status) */

 Bring PHY out of super isolate mode as the final step. */

 Check 10G-BaseT link status */

 Check PMD signal ok */

 Check link 10G */

 Check Legacy speed link */

 Enable expansion register 0x42 (Operation mode status) */

 Get legacy speed operation status */

 Should not happen: Treat as link down */

 Check legacy speed AN resolution */

 Read LP advertised speeds */

 Determine if EEE was negotiated */

 Set LED masks */

 LED 1 OFF */

 LED 2 OFF */

 LED 3 OFF */

 Set LED masks */

				/* Disable MI_INT interrupt before setting LED4

				 * source to constant off.

 LED 2 OFF */

 LED 3 OFF */

 Set control reg */

 Set LED masks */

				/* Disable MI_INT interrupt before setting LED4

				 * source to constant on.

 Tell LED3 to constant on */

 A83B[8:6]= 2 */

 Set control reg */

 Set LED masks */

			/* EXTPHY2 LED mode indicate that the 100M/1G/10G LED

			 * sources are all wired through LED1, rather than only

			 * 10G in other modes.

 Tell LED3 to blink on source */

 A83B[8:6]= 1 */

				/* Restore LED4 source to external link,

				 * and re-enable interrupts.

	/* This is a workaround for E3+84833 until autoneg

	 * restart is fixed in f/w

*****************************************************************/

			54618SE PHY SECTION			  */

*****************************************************************/

 Configure LED4: set to INTR (0x6). */

 Accessing shadow register 0xe. */

 Configure INTR based on link status change. */

	/* This works with E3 only, no need to check the chip

	 * before determining the port.

 Drive pin high to bring the GPHY out of reset. */

 wait for GPHY to reset */

 reset phy */

 Wait for GPHY to reset */

 Flip the signal detect polarity (set 0x1c.0x1e[8]). */

 Set up fc */

 Please refer to Table 28B-3 of 802.3ab-1999 spec. */

 Read all advertisement */

 Disable forced speed */

 Advertise 10/100 link speed */

 Only 10/100 are allowed to work in FORCE mode */

 Enabled AUTO-MDIX when autoneg is disabled */

 Enabled AUTO-MDIX when autoneg is disabled */

			/* Need to advertise EEE only when requested,

			 * and either no LPI assertion was requested,

			 * or it was requested and a valid timer was set.

			 * Also notice full duplex is required for EEE.

 Handle legacy auto-grEEEn */

	/* In case of no EPIO routed to reset the GPHY, put it

	 * in low power mode.

	/* This works with E3 only, no need to check the chip

	 * before determining the port.

 Drive pin low to put GPHY in reset. */

 Get speed operation status */

 Read status to clear the PHY interrupt. */

 Omitting 100Base-T4 for now */

 Should not happen */

 Check legacy speed AN resolution */

 Report LP advertised speeds */

 Enable master/slave manual mmode and set to master */

 mii write 9 [bits set 11 12] */

 forced 1G and disable autoneg */

 set val [mii read 0] */

 set val [expr $val & [bits clear 6 12 13]] */

 set val [expr $val | [bits set 6 8]] */

 mii write 0 $val */

 Set external loopback and Tx using 6dB coding */

 mii write 0x18 7 */

 set val [mii read 0x18] */

 mii write 0x18 [expr $val | [bits set 10 15]] */

 This register opens the gate for the UMAC despite its name */

	/* Maximum Frame Length (RW). Defines a 14-Bit maximum frame

	 * length used by the MAC receive logic to check frames.

*****************************************************************/

			SFX7101 PHY SECTION			  */

*****************************************************************/

 SFX7101_XGXS_TEST1 */

 Restore normal power mode*/

 HW reset */

 Restart autoneg */

 Save spirom version */

 If link is up print the AN outcome of the SFX7101 PHY */

 Read LP advertised speeds */

 Writes a self-clearing reset */

 Wait for clear */

 Low power mode is controlled by GPIO 2 */

 The PHY reset is controlled by GPIO 1 */

*****************************************************************/

			STATIC PHY DECLARATION			  */

*****************************************************************/

 req_duplex = */0,

 rsrv = */0,

 req_duplex = */0,

 rsrv = */0,

****************************************************************/

                                                               */

 Populate the phy according. Main function: bnx2x_populate_phy   */

                                                               */

****************************************************************/

 Get the 4 lanes xgxs config rx and tx */

		/* INT_PHY and EXT_PHY1 share the same value location in

		 * the shmem. When num_phys is greater than 1, than this value

		 * applies only to EXT_PHY1

 Check Dual mode */

		/* Set the appropriate supported and flags indications per

		 * interface type of the chip

		/* Enable MDC/MDIO work-around for E3 A0 since free running MDC

		 * was not set as expected. For B0, ECO will be enabled so there

		 * won't be an issue there

 Select the phy type */

 BCM8727_NOC => BCM8727 no over current */

 In case external PHY wasn't found */

	/* The shmem address of the phy version is located on different

	 * structures. In case this structure is too old, do not set

	 * the address

 Check specific mdc mdio settings */

 Check specific mdc mdio settings */

		/* Remove 100Mb link supported for BCM84833/4 when phy fw

		 * version lower than or equal to 1.39

 Populate the default phy configuration for MF mode */

		/* Update media type for non-PMF sync only for the first time

		 * In case the media type changes afterwards, it will be updated

		 * using the update_status function

 Set bmac loopback */

 Set bmac loopback */

	/* Set WC to loopback mode since link is required to provide clock

	 * to the XMAC in 20G mode

 Set 10G XGXS loopback */

 Set external phy loopback */

 Open / close the gate between the NIG and the BRB */

 Sync the link parameters */

	/*

	 * The module verification was already done by previous link owner,

	 * so this call is meant only to get warning message

 Re-enable the NIG/MAC */

 Increment LFA count */

 Clear link flap reason */

 Disable NIG DRAIN */

 Enable interrupts */

 Store the new link parameters */

 Clear the "Don't Clear Statistics" bit, and set reason */

 Set link flap reason */

 Increment link flap counter */

 Proceed with regular link initialization */

 Driver opens NIG-BRB filters */

 Check if link flap can be avoided */

 Disable attentions */

 Disable attentions */

 Activate nig drain */

 Disable nig egress interface */

 Disable emac */

	/* The PHY reset is controlled by GPIO 1

	 * Hold it as vars low

 Clear link led */

 Clear latching indication */

 Disable nig ingress interface */

 Reset BigMac */

	/*

	 * Activate NIG drain so that during this time the device won't send

	 * anything while it is unable to response.

	/*

	 * Close gracefully the gate from BMAC to NIG such that no half packets

	 * are passed.

 Wait 10ms for the pipe to clean up*/

	/* Clean the NIG-BRB using the network filters in a way that will

	 * not cut a packet in the middle.

	/*

	 * Re-open the gate between the BMAC and the NIG, after verifying the

	 * gate to the BRB is closed, otherwise packets may arrive to the

	 * firmware before driver had initialized it. The target is to achieve

	 * minimum management protocol down time.

 Disable NIG drain */

***************************************************************************/

				Common function				    */

***************************************************************************/

 PART1 - Reset both phys */

 In E2, same phy is using for port0 of the two paths */

 Extract the ext phy address for the port */

 Disable attentions */

		/* Need to take the phy out of low power mode in order

		 * to write to access its registers

 Reset the phy */

 Add delay of 150ms after reset */

 PART2 - Download firmware to both phys */

 Only set bit 10 = 1 (Tx power down) */

 Phase1 of TX_POWER_DOWN reset */

	/* Toggle Transmitter: Power down and then up with 600ms delay

	 * between

 PART3 - complete TX_POWER_DOWN process, and set GPIO2 back to low */

 Phase2 of POWER_DOWN_RESET */

 Release bit 10 (Release Tx power down) */

 Read modify write the SPI-ROM version select register */

 set GPIO2 back to LOW */

 Use port1 because of the static port-swap */

 Enable the module detection interrupt */

 In E2, same phy is using for port0 of the two paths */

 Extract the ext phy address for the port */

 Reset phy*/

 Set fault module detected LED on */

 Don't override the io_gpio and io_port */

	/* Retrieve the reset gpio/port which control the reset.

	 * Default is GPIO1, PORT1

 Calculate the port based on port swap */

 Initiate PHY reset*/

 PART1 - Reset both phys */

 In E2, same phy is using for port0 of the two paths */

 Extract the ext phy address for the port */

 disable attentions */

 Reset the phy */

 Add delay of 150ms after reset */

 PART2 - Download firmware to both phys */

 Disable PHY transmitter output */

		/* GPIO1 affects both ports, so there's need to pull

		 * it for single port alone

		/* GPIO3's are linked, and so both need to be toggled

		 * to obtain required 2us pulse.

 Enable EPIO */

 Check if common init was already done */

 Read the ext_phy_type for arbitrary port(0) */

 Ignore check if no external input PIN available */

 Returns 0 if no change occurred since last check; 1 otherwise. */

 Compare new value with previous value */

 If values differ */

 Do not touch the link in case physical link down */

	/* a. Update shmem->link_status accordingly

	 * b. Update link_vars->link_up

 activate nig drain */

		/* Set LED mode to off since the PHY doesn't know about these

		 * errors

 Clear nig drain */

 Update the LED according to the link state */

 Update link status in the shared memory */

 C. Trigger General Attention */

/******************************************************************************

* Description:

*	This function checks for half opened connection change indication.

*	When such change occurs, it calls the bnx2x_analyze_link_error

*	to check if Remote Fault is set or cleared. Reception of remote fault

*	status message in the MAC indicates that the peer's MAC has detected

*	a fault, for example, due to break in the TX side of fiber.

*

 In case link status is physically up @ 10G do */

 Check E3 XMAC */

		/* Note that link speed cannot be queried here, since it may be

		 * zero while link is down. In case UMAC is active, LSS will

		 * simply not be set

 Clear stick bits (Requires rising edge) */

 Check E1X / E2 BMAC */

  Read BIGMAC_REGISTER_RX_LSS_STATUS */

 Get The SFP+ TX_Fault controlling pin ([eg]pio) */

 Change TX_Fault led, set link status for further syncs */

 If module is unapproved, led should be on regardless */

	/* Once KR2 was disabled, wait 5 seconds before checking KR2 recovery

	 * Since some switches tend to reinit the AN process and clear the

	 * the advertised BP/NP after ~2 seconds causing the KR2 to be disabled

	 * and recovered many times

 CL73 has not begun yet */

	/* In case NP bit is not set in the BasePage, or it is set,

	 * but only KX is advertised, declare this link partner as non-KR2

	 * device.

 In case KR2 is already disabled, check if we need to re-enable it */

 KR2 is enabled, but not KR2 device */

 Disable KR2 on both lanes */

 Restart AN on leading lane */

 Clean trail, interrupt corrects the leds */

 Update link status in the shared memory */

 Set GPIO3 to trigger SFP+ module insertion/removal */

 Open appropriate AEU for interrupts */

 Enable the GPIO to trigger interrupt */

/* bnx2x_ethtool.c: QLogic Everest network driver.

 *

 * Copyright (c) 2007-2013 Broadcom Corporation

 * Copyright (c) 2014 QLogic Corporation

 * All rights reserved

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 *

 * Maintained by: Ariel Elior <ariel.elior@qlogic.com>

 * Written by: Eliezer Tamir

 * Based on code from Michael Chan's bnx2 driver

 * UDP CSUM errata workaround by Arik Gendelman

 * Slowpath and fastpath rework by Vladislav Zolotarov

 * Statistics and Link management by Yitchak Gertner

 *

/* Note: in the format strings below %s is replaced by the queue-name which is

 * either its index or 'fcoe' for the fcoe queue. Make sure the format string

 * length does not exceed ETH_GSTRING_LEN - MAX_QUEUE_NAME_LEN + 2

 1 */	{ Q_STATS_OFFSET32(total_bytes_received_hi), 8, "[%s]: rx_bytes" },

 10 */{ Q_STATS_OFFSET32(total_unicast_packets_transmitted_hi),

 1 */	{ STATS_OFFSET32(total_bytes_received_hi),

 10 */{ STATS_OFFSET32(rx_stat_etherstatsfragments_hi),

 20 */{ STATS_OFFSET32(rx_err_discard_pkt),

 30 */{ STATS_OFFSET32(tx_stat_dot3statssinglecollisionframes_hi),

 40 */{ STATS_OFFSET32(tx_stat_etherstatspkts512octetsto1023octets_hi),

 Dual Media boards present all available port types */

 Publish LP advertised speeds and FC */

 If received a request for an unknown duplex, assume full*/

 use 10G if no link detected */

 store value for following "load" */

 Save new config in case command complete successfully */

 Get the new cfg_idx */

 Restore old config in case command failed */

 advertise the requested speed and duplex if supported */

 forced speed */

 advertise the requested speed and duplex if supported */

 Set new config */

 Calculate the total preset regs length */

****** Paged registers info selectors ********/

/**

 * bnx2x_read_pages_regs - read "paged" registers

 *

 * @bp:		device handle

 * @p:		output buffer

 * @preset:	the preset value

 *

 * Reads "paged" memories: memories that may only be read by first writing to a

 * specific address ("write address") and then reading from a specific address

 * ("read address"). There may be more than one write address per "page" and

 * more than one read address per write address.

 addresses of the paged registers */

 number of paged registers */

 write addresses */

 number of write addresses */

 read addresses info */

 number of read addresses */

 Read the idle_chk registers */

 Read the regular registers */

 Read the CAM registers */

			/* In case of wreg_addr register, read additional

			   registers from read_regs array

 Paged registers are supported in E2 & E3 only */

 Read "paged" registers */

 Read all registers, by reading all preset registers */

 Skip presets with IOR */

	/* Disable parity attentions as long as following dump may

	 * cause false alarms by reading never written registers. We

	 * will re-enable parity attentions right after the dump.

 dump_meta_data presents OR of CHIP and PATH. */

	/* This isn't really an error, but since attention handling is going

	 * to print the GRC timeouts using this macro, we use the same.

 Actually read the registers */

 Re-enable parity attentions */

 Use the ethtool_dump "flag" field as the dump preset index */

 Calculate the requested preset idx length */

	/* Disable parity attentions as long as following dump may

	 * cause false alarms by reading never written registers. We

	 * will re-enable parity attentions right after the dump.

 dump_meta_data presents OR of CHIP and PATH. */

 Actually read the registers */

 Re-enable parity attentions */

 dump MCP trace */

/* Per pf misc lock must be acquired before the per port mcp lock. Otherwise,

 * had we done things the other way around, if two pfs from the same port would

 * attempt to access nvram at the same time, we could run into a scenario such

 * as:

 * pf A takes the port lock.

 * pf B succeeds in taking the same lock since they are from the same port.

 * pf A takes the per pf misc lock. Performs eeprom access.

 * pf A finishes. Unlocks the per pf misc lock.

 * Pf B takes the lock and proceeds to perform it's own access.

 * pf A unlocks the per port lock, while pf B is still working (!).

 * mcp takes the per port lock and corrupts pf B's access (and/or has it's own

 * access corrupted by pf B)

 acquire HW lock: protect against other PFs in PF Direct Assignment */

 adjust timeout for emulation/FPGA */

 request access to nvram interface */

 adjust timeout for emulation/FPGA */

 relinquish nvram interface */

 release HW lock: protect against other PFs in PF Direct Assignment */

 enable both bits, even on read */

 disable both bits, even after read */

 build the command word */

 need to clear DONE bit separately */

 address of the NVRAM to read from */

 issue a read command */

 adjust timeout for emulation/FPGA */

 wait for completion */

			/* we read nvram data in cpu order

			 * but ethtool sees it as an array of bytes

			 * converting to big-endian will do the work

 request access to nvram interface */

 enable access to nvram interface */

 read the first word(s) */

 advance to the next dword */

 disable access to nvram interface */

 parameters already validated in ethtool_get_eeprom */

 Read A0 section */

 Limit transfer size to the A0 section boundary */

 Read A2 section */

 Limit transfer size to the A2 section boundary */

 build the command word */

 need to clear DONE bit separately */

 write the data */

 address of the NVRAM to write to */

 issue the write command */

 adjust timeout for emulation/FPGA */

 wait for completion */

 request access to nvram interface */

 enable access to nvram interface */

		/* nvram data is returned as an array of bytes

		 * convert it back to cpu order

 disable access to nvram interface */

 ethtool */

 request access to nvram interface */

 enable access to nvram interface */

		/* Notice unlike bnx2x_nvram_read_dword() this will not

		 * change val using be32_to_cpu(), which causes data to flip

		 * if the eeprom is read and then written back. This is due

		 * to tools utilizing this functionality that would break

		 * if this would be resolved.

 advance to the next dword */

		/* At end of each 4Kb page, release nvram lock to allow MFW

		 * chance to take it for its own use.

 disable access to nvram interface */

 parameters already validated in ethtool_set_eeprom */

 PHY eeprom can be accessed only by the PMF */

 'PHYP' (0x50485950): prepare phy for FW upgrade */

 'PHYR' (0x50485952): re-init link after FW upgrade */

 'PHYC' (0x53985943): PHY FW upgrade completed */

 DSP Remove Download Mode */

 wait 0.5 sec to allow it to run */

	/* If size isn't already set, we give an estimation of the number

	 * of buffers we'll have. We're neglecting some possible conditions

	 * [we couldn't know for certain at this point if number of queues

	 * might shrink] but the number would be correct for the likely

	 * scenario.

 SHMEM value is in 16u units --> Convert to 1u units. */

 All is well; Apply changes*/

 Restart link to propagate changes */

 0 */		{ BNX2X_CHIP_MASK_ALL,

 10 */	{ BNX2X_CHIP_MASK_ALL,

 20 */	{ BNX2X_CHIP_MASK_E1X | BNX2X_CHIP_MASK_E2,

 30 */	{ BNX2X_CHIP_MASK_ALL,

 e3 A0 */

	/* Repeat the test twice:

	 * First by writing 0x00000000, second by writing 0xffffffff

 Restore the original register's value */

 verify value is as expected */

 e3 */

 pre-Check the parity status */

 Go through all the memories */

 Check the parity status */

 check the loopback mode */

 prepare the loopback packet */

 send the loopback packet */

 start + pbd */

 turn on parsing and get a BD */

 make sure descriptor update is observed by the HW */

 start + pbd */

	/* Unlike HC IGU won't generate an interrupt for status block

	 * updates that have been performed while interrupts were

	 * disabled.

		/* Disable local BHes to prevent a dead-lock situation between

		 * sch_direct_xmit() and bnx2x_run_loopback() (calling

		 * bnx2x_tx_int()), as both are taking netif_tx_lock().

 Update producers */

 Zero-length images and AFEX profiles do not have CRC */

 bootstrap */

 dir */

 manuf_info */

 feature_info */

 upgrade_key_info */

 manuf_key_info */

 manuf_info2 */

 feature_info */

 Send an EMPTY ramrod on the first queue */

 offline tests are not supported in MF mode */

 save current value of input enable for TX port IF */

 disable input for TX port IF */

 wait until link state is restored */

 internal LB */

 external LB */

 restore input for TX port IF */

 wait until link state is restored */

/* ethtool statistics are displayed for all regular ethernet queues and the

 * fcoe L2 queue if not disabled

 First 4 tests cannot be done in MF mode */

 skip this counter */

 4-byte counter */

 8-byte counter */

 skip this counter */

 4-byte counter */

 8-byte counter */

 cycle on/off once per second */

 For TCP only 4-tupple hash is supported */

 For UDP either 2-tupple hash or 4-tupple hash is supported */

 For IP only 2-tupple hash is supported */

 RSS is not supported for these protocols */

 Get the current configuration of the RSS indirection table */

	/*

	 * We can't use a memcpy() as an internal storage of an

	 * indirection table is a u8 array while indir->ring_index

	 * points to an array of u32.

	 *

	 * Indirection table contains the FW Client IDs, so we need to

	 * align the returned table to the Client ID of the leading RSS

	 * queue.

	/* We require at least one supported parameter to be changed and no

	 * change in any of the unsupported parameters

		/*

		 * The same as in bnx2x_get_rxfh: we can't use a memcpy()

		 * as an internal storage of an indirection table is a u8 array

		 * while indir->ring_index points to an array of u32.

		 *

		 * Indirection table contains the FW Client IDs, so we need to

		 * align the received table to the Client ID of the leading RSS

		 * queue

/**

 * bnx2x_get_channels - gets the number of RSS queues.

 *

 * @dev:		net device

 * @channels:		returns the number of max / current queues

/**

 * bnx2x_change_num_queues - change the number of RSS queues.

 *

 * @bp:			bnx2x private structure

 * @num_rss:		rss count

 *

 * Re-configure interrupt mode to get the new number of MSI-X

 * vectors and re-add NAPI objects.

/**

 * bnx2x_set_channels - sets the number of RSS queues.

 *

 * @dev:		net device

 * @channels:		includes the number of queues requested

	/* We don't support separate rx / tx channels.

	 * We don't allow setting 'other' channels.

 Check if there was a change in the active parameters */

	/* Set the requested number of queues in bp context.

	 * Note that the actual number of queues created during load may be

	 * less than requested if memory is low.

/* bnx2x_main.c: QLogic Everest network driver.

 *

 * Copyright (c) 2007-2013 Broadcom Corporation

 * Copyright (c) 2014 QLogic Corporation

 * All rights reserved

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 *

 * Maintained by: Ariel Elior <ariel.elior@qlogic.com>

 * Written by: Eliezer Tamir

 * Based on code from Michael Chan's bnx2 driver

 * UDP CSUM errata workaround by Arik Gendelman

 * Slowpath and fastpath rework by Vladislav Zolotarov

 * Statistics and Link management by Yitchak Gertner

 *

 for dev_info() */

 FW files */

 Time in jiffies before concluding the transmitter is hung */

 indexed by board_type, above */

 Global resources for unloading a previously loaded device */

 Forward declaration */

/****************************************************************************

* General service functions

/* used only at init

 * locking is done by mcp

 copy command into DMAE command memory and set DMAE command go */

 set the opcode */

 fill in the completion parameters */

 issue a dmae command over the init-channel and wait for completion */

	/* Lock the dmae channel. Disable BHs to prevent a dead-lock

	 * as long as this code is called both from syscall context and

	 * from ndo_set_rx_mode() flow that may be called from BH.

 reset completion */

 post the command on the channel used for initializations */

 wait for completion */

 set opcode and fixed command fields */

 fill in addresses and len */

 issue the command and wait for completion */

 set opcode and fixed command fields */

 fill in addresses and len */

 issue the command and wait for completion */

 print the asserts */

 read a single assert entry */

 log entry if it contains a valid assert */

 sanity */

 validate TRCB signature */

 read cyclic buffer pointer */

 dump buffer after the mark */

 dump buffer before the mark */

	/* in E1 we must use only PCI configuration space to disable

	 * MSI/MSIX capability

	 * It's forbidden to disable IGU_PF_CONF_MSI_MSIX_EN in HC block

		/* Since IGU_PF_CONF_MSI_MSIX_EN still always on

		 * Use mask register to prevent from HC sending interrupts

		 * after we exit the function

 Indices */

 Common */

 Rx */

 Tx */

 host sb data */

 VF cannot access FW refelection for status block */

 fw sb data */

 copy sb data in here */

 SB_SMs data */

 Indices data */

 event queue */

 Rings */

 Rx */

 Tx */

/*

 * FLR Support for E2

 *

 * bnx2x_pf_flr_clnup() is called during nic_load in the per function HW

 * initialization.

 10 milliseconds */

 usec */

 200 */

 Common routines with VF FLR cleanup */

 adjust polling timeout */

 Verify the command queues are flushed P0, P1, P4 */

 Verify the transmission buffers are flushed P0, P1, P4 */

 Zero completion for next FLR */

/* PF FLR specific routines

 wait for CFC PF usage-counter to zero (includes all the VFs) */

 Wait for DQ PF usage-counter to zero (until DQ cleanup) */

 Wait for QM PF usage-counter to zero (until DQ cleanup) */

 Wait for Timer PF usage-counters to zero (until DQ cleanup) */

 Wait DMAE PF usage counter to zero */

 Re-enable PF target read access */

 Poll HW usage counters */

 Zero the igu 'trailing edge' and 'leading edge' */

 Send the FW cleanup command */

 ATC cleanup */

 Verify TX hw is flushed */

 Wait 100ms (not adjusted according to platform) */

 Verify no pending pci transactions */

 Debug */

	/*

	 * Master enable - Due to WB DMAE writes performed before this

	 * register is re-initialized as part of the regular function init

	/*

	 * Ensure that HC_CONFIG is written before leading/trailing edge config

 init leading/trailing edge */

 enable nig and gpio3 attention */

 Clean previous status - need to configure igu prior to ack*/

 init leading/trailing edge */

 enable nig and gpio3 attention */

 prevent the HW from sending interrupts */

 make sure all ISRs are done */

 make sure sp_task is not running */

 fast path */

/*

 * General service functions

 Return true if succeeded to acquire the lock */

 Validating that the resource is within range */

 Try to acquire the lock */

/**

 * bnx2x_get_leader_lock_resource - get the recovery leader resource id

 *

 * @bp:	driver handle

 *

 * Returns the recovery leader resource id according to the engine this function

 * belongs to. Currently only only 2 engines is supported.

/**

 * bnx2x_trylock_leader_lock- try to acquire a leader lock.

 *

 * @bp: driver handle

 *

 * Tries to acquire a leader lock for current engine.

 schedule the sp task and mark that interrupt occurred (runs from ISR) */

	/* Set the interrupt occurred bit for the sp-task to recognize it

	 * must ack the interrupt and transition according to the IGU

	 * state machine.

	/* The sp_task must execute only after this bit

	 * is set, otherwise we will get out of sync and miss all

	 * further interrupts. Hence, the barrier.

 schedule sp_task to workqueue */

	/* If cid is within VF range, replace the slowpath object with the

	 * one corresponding to this VF

		/* q_obj->complete_cmd() failure means that this was

		 * an unexpected completion.

		 *

		 * In this case we don't want to increase the bp->spq_left

		 * because apparently we haven't sent this command the first

		 * place.

 push the change in bp->spq_left and towards the memory */

		/* if Q update ramrod is completed for last Q in AFEX vif set

		 * flow, then ACK MCP at the end

		 *

		 * mark pending ACK to MCP bit.

		 * prevent case that both bits are cleared.

		 * At the end of load/unload driver checks that

		 * sp_state is cleared, and this order prevents

		 * races

 schedule the sp task as mcp ack is required */

 Return here if interrupt is shared and it's not for us */

 Handle Rx or Tx according to SB id */

		/* schedule sp task to perform default status block work, ack

		 * attentions and enable interrupts.

 Link */

/*

 * General service functions

 Validating that the resource is within range */

 Validating that the resource is not already taken */

 Try for 5 second every 5ms */

 Try to acquire the lock */

 Validating that the resource is within range */

 Validating that the resource is currently taken */

 The GPIO should be swapped if swap register is set and active */

 read GPIO value */

 get the requested pin value */

 The GPIO should be swapped if swap register is set and active */

 read GPIO and mask except the float bits */

 clear FLOAT and set CLR */

 clear FLOAT and set SET */

 set FLOAT */

 Any port swapping should be handled by caller. */

 read GPIO and mask except the float bits */

 set CLR */

 set SET */

 set FLOAT */

 The GPIO should be swapped if swap register is set and active */

 read GPIO int */

 clear SET and set CLR */

 clear CLR and set SET */

 Only 2 SPIOs are configurable */

 read SPIO and mask except the float bits */

 clear FLOAT and set CLR */

 clear FLOAT and set SET */

 set FLOAT */

	/* Initialize link parameters structure variables

	 * It is recommended to turn off RX FC for jumbo frames

	 *  for better performance

 Prefer doing PHY loopback at highest speed */

/* Calculates the sum of vn_min_rates.

   It's needed for further normalizing of the min_rates.

   Returns:

     sum of vn_min_rates.

       or

     0 - if all the min_rates are 0.

     In the later case fairness algorithm should be deactivated.

     If not all min_rates are zero then those that are zeroes will be set to 1.

 Skip hidden vns */

 If min rate is zero - set it to 1 */

 if ETS or all min rates are zeros - disable fairness */

 maxCfg in percents of linkspeed */

 SD modes */

 maxCfg is absolute in 100Mb units */

 what should be the default value in this case */

	/* For 2 port configuration the absolute function number formula

	 * is:

	 *      abs_func = 2 * vn + BP_PORT + BP_PATH

	 *

	 *      and there are 4 functions per port

	 *

	 * For 4 port configuration it is

	 *      abs_func = 4 * vn + 2 * BP_PORT + BP_PATH

	 *

	 *      and there are 2 functions per port

abs*/func = n * (2 * vn + BP_PORT(bp)) + BP_PATH(bp);

 read mf conf from shmem */

 vn_weight_sum and enable fairness if not 0 */

 calculate and set min-max rate for each vn */

 always enable rate shaping and fairness */

 rate shaping and fairness are disabled */

 init cmng mode in HW according to local configuration */

 rate shaping and fairness are disabled */

 This function is called upon link interrupt */

 Make sure that we are synced with the current statistics */

 reset old mac stats */

 read updated dcb configuration */

 indicate link status */

 VF */

		/* if bulletin board did not have an update for link status

		 * __bnx2x_link_report will report current status

		 * but it will NOT duplicate report in case of already reported

		 * during sampling bulletin board.

	/* no need to wait for RAMROD completion, so don't

	 * set RAMROD_COMP_WAIT flag

 if ramrod can not be sent, response to MCP immediately */

 validate only LIST_SET and LIST_GET are received from switch */

 set parameters according to cmd_type */

	/* if ramrod can not be sent, respond to MCP immediately for

	 * SET and GET requests (other are not triggered from MCP)

 write response to scratchpad, for MCP */

 send ack message to MCP */

 if VIF_SET is "enabled" */

 set rate limit directly to internal RAM */

 read relevant values from mf_cfg struct in shmem */

 send ramrod to FW, return in case of failure */

 notify link down because BP->flags is disabled */

 send INVALID VIF ramrod to FW */

 Reset the default afex VLAN */

 Prepare parameters for function state transitions */

 Re-learn the S-tag from shmem */

 Configure new S-tag in LLH */

 Send Ramrod to update FW of change */

	/*

	 * We need the mb() to ensure the ordering between the writing to

	 * bp->port.pmf here and reading it from the bnx2x_periodic_task().

 queue a periodic task */

 enable nig attention */

 end of Link */

 slow path */

/*

 * General service functions

 send the MCP a request, block until there is a reply */

 let the FW do it's magic ... */

 Give the FW up to 5 second (500*10ms) */

 is this a reply to our command? */

 FW BUG! */

 Enable the function in the FW */

 spq */

/**

 * bnx2x_get_common_flags - Return common flags

 *

 * @bp:		device handle

 * @fp:		queue handle

 * @zero_stats:	TRUE if statistics zeroing is needed

 *

 * Return the flags that are common for the Tx-only and not normal connections.

 PF driver will always initialize the Queue to an ACTIVE state */

	/* tx only connections collect statistics (on the same index as the

	 * parent connection). The statistics are zeroed when the parent

	 * connection is initialized.

 calculate other queue flags */

 For FCoE - force usage of default priority (for afex) */

 Always set HW VLAN stripping */

 configure silent vlan removal */

 Always use mini-jumbo MTU for FCoE L2 ring */

 validate SGE ring has enough to cross high threshold */

 pause - not for e1 */

		/*

		 * validate that rings have enough entries to cross

		 * high thresholds

 rxq setup */

	/* This should be a maximum number of data bytes that may be

	 * placed on the BD (not including paddings).

	/* Maximum number or simultaneous TPA aggregation for this Queue.

	 *

	 * For PF Clients it should be the maximum available number.

	 * VF driver(s) may want to define it to a smaller value.

	/* configure silent vlan removal

	 * if multi function mode is afex, then mask default vlan

	/*

	 * set the tss leading client id for TX classification ==

	 * leading RSS client id

 reset IGU PF statistics: MSIX + ATTN */

 PF */

 ATTN */

	/*

	 * Congestion management values depend on the link rate

	 * There is no active link so initial link rate is set to 10 Gbps.

	 * When the link comes up The congestion management values are

	 * re-calculated according to the actual link rate.

 Only the PMF sets the HW */

 init Event Queue - PCI bus guarantees correct endianity*/

 Tx queue should be only re-enabled */

	/*

	 * Should not call netif_carrier_on since it will be called if the link

	 * is up when checking for link state

	/* get DRV_INFO_ETH_STAT_NUM_MACS_REQUIRED macs, placing them in the

	 * mac_local field in ether_stat struct. The base address is offset by 2

	 * bytes to account for the field being 8 bytes but a mac address is

	 * only 6 bytes. Likewise, the stride for the get_n_elements function is

	 * 2 bytes to compensate from the 6 bytes of a mac to the 8 bytes

	 * allocated by the ether_stat struct, so the macs will land in their

	 * proper positions.

 insert FCoE stats from ramrod response */

 ask L5 driver to add data to the struct */

 ask L5 driver to add data to the struct */

/* called due to MCP event (on pmf):

 *	reread new bandwidth configuration

 *	configure FW

 *	notify others function about the change

	/* Workaround for MFW bug.

	 * MFW is not supposed to generate BW attention in

	 * single function mode.

 if drv_info version supported by MFW doesn't match - send NACK */

 Must prevent other flows from accessing drv_info_to_mcp */

 if op code isn't supported - send NACK */

	/* if we got drv_info attn from MFW then these fields are defined in

	 * shmem2 for sure

	/* Since possible management wants both this and get_driver_version

	 * need to wait until management notifies us it finished utilizing

	 * the buffer.

 Management is done; need to clear indication */

 Must not proceed when `bnx2x_handle_drv_info_req' is feasible */

 Parse ethernet driver version */

 Try getting storage driver version via cnic */

 Update Driver load time, possibly broken in y2038 */

 Check & notify On-Chip dump. */

 sanity */

 if (event & DRV_STATUS_OEM_EVENT_MASK) */ {

		/* This is the only place besides the function initialization

		 * where the bp->flags can change so it is done without any

		 * locks

 Report results to MCP */

 must be called under the spq lock */

 must be called under the spq lock */

	/*

	 * Make sure that BD data is updated before writing the producer:

	 * BD data is written to the memory, the producer is read from the

	 * memory, thus we need a full memory barrier to ensure the ordering.

/**

 * bnx2x_is_contextless_ramrod - check if the current command ends on EQ

 *

 * @cmd:	command to check

 * @cmd_type:	command type

/**

 * bnx2x_sp_post - place a single command on an SP ring

 *

 * @bp:		driver handle

 * @command:	command to place (e.g. SETUP, FILTER_RULES, etc.)

 * @cid:	SW CID the command is related to

 * @data_hi:	command private data address (high 32 bits)

 * @data_lo:	command private data address (low 32 bits)

 * @cmd_type:	command type (e.g. NONE, ETH)

 *

 * SP data is handled as if it's always an address pair, thus data fields are

 * not swapped to little endian in upper functions. Instead this function swaps

 * data as if it's two u32 fields.

 CID needs port number to be encoded int it */

	/* In some cases, type may already contain the func-id

	 * mainly in SRIOV related use cases, so we add it here only

	 * if it's not already set.

	/*

	 * It's ok if the actual decrement is issued towards the memory

	 * somewhere between the spin_lock and spin_unlock. Thus no

	 * more explicit memory barrier is needed.

 acquire split MCP access lock register */

 release split MCP access lock register */

 status block is written to by the chip */

 Do not reorder: indices reading should complete before handling */

/*

 * slow path service functions

 save nig interrupt mask */

			/* If nig_mask is not set, no need to call the update

			 * function.

 handle unicore attn? */

 if hardwired */

 now set back the mask */

		/* Verify that IGU ack through BAR was written before restoring

		 * NIG mask. This loop should exit after 2-3 iterations max.

 mark the failure */

 log the failure */

	/* Schedule device reset (unload)

	 * This is due to some boards consuming sufficient power when driver is

	 * up to overheat if fan fails.

 Fan failure attention */

 DORQ discard attention */

 CFC error attention */

 RQ_USDMDP_FIFO_OVERFLOW */

 start dcbx state machine */

  sync with link */

			/* Always call it here: bnx2x_link_report() will

			 * prevent the link indication duplication.

/*

 * Bits map:

 * 0-7   - Engine0 load counter.

 * 8-15  - Engine1 load counter.

 * 16    - Engine0 RESET_IN_PROGRESS bit.

 * 17    - Engine1 RESET_IN_PROGRESS bit.

 * 18    - Engine0 ONE_IS_LOADED. Set when there is at least one active function

 *         on the engine

 * 19    - Engine1 ONE_IS_LOADED.

 * 20    - Chip reset flow bit. When set none-leader must wait for both engines

 *         leader to complete (check for both RESET_IN_PROGRESS bits and not for

 *         just the one belonging to its engine).

 *

/*

 * Set the GLOBAL_RESET bit.

 *

 * Should be run under rtnl lock

/*

 * Clear the GLOBAL_RESET bit.

 *

 * Should be run under rtnl lock

/*

 * Checks the GLOBAL_RESET bit.

 *

 * should be run under rtnl lock

/*

 * Clear RESET_IN_PROGRESS bit for the current engine.

 *

 * Should be run under rtnl lock

 Clear the bit */

/*

 * Set RESET_IN_PROGRESS for the current engine.

 *

 * should be run under rtnl lock

 Set the bit */

/*

 * Checks the RESET_IN_PROGRESS bit for the given engine.

 * should be run under rtnl lock

 return false if bit is set */

/*

 * set pf load for the current pf.

 *

 * should be run under rtnl lock

 get the current counter value */

 set bit of that PF */

 clear the old value */

 set the new one */

/**

 * bnx2x_clear_pf_load - clear pf load mark

 *

 * @bp:		driver handle

 *

 * Should be run under rtnl lock.

 * Decrements the load counter for the current engine. Returns

 * whether other functions are still loaded

 get the current counter value */

 clear bit of that PF */

 clear the old value */

 set the new one */

/*

 * Read the load status for the current engine.

 *

 * should be run under rtnl lock

 Each bit is real error! */

 Clear the bit */

 Each bit is real error! */

 Clear the bit */

 Each bit is real error! */

 Clear the bit */

 clear latched SCPAD PATIRY from MCP */

 Clear the bit */

 Each bit is real error! */

 Clear the bit */

/**

 * bnx2x_chk_parity_attn - checks for parity attentions.

 *

 * @bp:		driver handle

 * @global:	true if there was a global attention

 * @print:	show parity attention in syslog

	/* Since MCP attentions can't be disabled inside the block, we need to

	 * read AEU registers to see whether they're currently disabled

	/* need to take HW lock because MCP or other port might also

 Disable HW interrupts */

		/* In case of parity errors don't handle attentions so that

		 * other function would "see" parity errors.

 read local copy of bits */

 look for changed bits */

 handle bits that were raised */

 No memory barriers */

 Clear pending state for the last command */

 If there are pending mcast commands - send them */

 Always push next commands out, don't wait here */

		/* This is only relevant for 57710 where multicast MACs are

		 * configured as unicast MACs using the same ramrod.

 Send rx_mode command again if was requested */

 called with rtnl_lock */

 Send Q update command with afex vlan removal values for all Qs */

 set silent vlan removal values according to vlan mode */

 in access mode mark mask and value are 0 to strip all vlans */

 Set the appropriate Queue object */

 send the ramrod */

 clear pending completion bit */

 mark latest Q bit */

 send Q update ramrod for FCoE Q */

 If no FCoE ring - ACK MCP now */

	/* The hw_cos range is 1-255, 257 - the sw_cons range is 0-254, 256.

	 * when we get the next-page we need to adjust so the loop

	 * condition below will be met. The next element is the size of a

	 * regular element and hence incrementing by 1

	/* This function may never run in parallel with itself for a

	 * specific bp, thus there is no need in "paired" read memory

	 * barrier here.

 handle eq element */

 nothing to do with stats comp */

 handle according to cid range */

			/*

			 * we may want to verify here that the bp state is

			 * HALTING

 elem CID originates from FW; actually LE */

				/* We will perform the Queues update from

				 * sp_rtnl task as all Queue SP operations

				 * should run under rtnl_lock.

 unknown event log error and continue */

 for */

 Make sure that above mem writes were issued towards the memory */

 update producer */

 make sure the atomic interrupt_occurred has been written */

 what work needs to be performed? */

 HW attentions */

 SP events: STAT_QUERY and others */

				/* Prevent local bottom-halves from running as

				 * we are going to change the local NAPI list.

 Handle EQ completions */

 if status is non zero then perhaps something went wrong */

 ack status block only if something was actually handled */

 afex - poll to check if VIFSET_ACK should be sent to MFW */

	/* schedule sp task to perform default status block work, ack

	 * attentions and enable interrupts.

 end of slow path */

		/* The delta between driver pulse and mcp response

		 * should not get too big. If the MFW is more than 5 pulses

		 * behind, we should worry about it enough to generate an error

		 * log.

 sample pf vf bulletin board for new posts from pf */

 end of Statistics */

 nic init */

/*

 * nic init service functions

 helper: writes FP SP data to FW - data_size in dwords */

 disable the function first */

 helper:  writes SP SB data to FW */

 allocates state machine ids. */

 zero out state machine indices */

 rx indices */

 tx indices */

 map indices */

 rx indices */

 tx indices */

 write indices to HW - PCI guarantees endianity of regpairs */

 ATTN */

 take care of sig[0]..sig[4] */

			/*

			 * enable5 is separate from the rest of the registers,

			 * and therefore the address skip is 4

			 * and not 16 between the different groups

 PCI guarantees endianity of regpairs */

 we want a warning message before it gets wrought... */

 called with netif_addr_lock_bh() */

 Prepare ramrod parameters */

 Clear the flags first */

		/*

		 * 'drop all' supersedes any accept flags that may have been

		 * passed to the function.

 internal switching mode */

 internal switching mode */

		/* According to definition of SI mode, iface in promisc mode

		 * should receive matched and unmatched (in resolution of port)

		 * unicast packets.

 internal switching mode */

 called with netif_addr_lock_bh() */

 Configure rx_mode of FCoE Queue */

	/* Zero this manually as its initialization is

 nothing to do */

		/* internal memory per function is

 We want Client ID to be the same as IGU SB ID for 57712 */

 qZone id equals to FW (per path) client id */

 init shortcut */

 Setup SB indices */

 Configure Queue State object */

 init tx data */

 nothing more for vf to do here */

	/**

	 * Configure classification DBs: Always enable Tx switching

 qZone id equals to FW (per path) client id */

 init shortcut */

 Configure Queue State object */

 No multi-CoS for FCoE L2 client */

 ensure status block indices were read */

 flush all */

 Setup NIC internals and enable interrupts */

 ensure status block indices were read */

 Initialize MOD_ABS interrupts */

 initialize the default status block and sp ring */

 flush all before enabling interrupts */

 Check for SPIO5 */

 gzip service functions */

 check gzip header */

 nic load/unload */

/*

 * General service functions

 send a NIG loopback debug packet */

 Ethernet source and destination addresses */

 SOP */

 NON-IP protocol */

 EOP, eop_bvalid = 0 */

/* some of the internal memories

 * are not directly readable from the driver

 * to test them we send debug packets

 Disable inputs of parser neighbor blocks */

  Write 0 to parser credits for CFC search request */

 send Ethernet packet */

 TODO do i reset NIG statistic? */

 Wait until NIG register shows 1 packet of size 0x10 */

 Wait until PRS register shows 1 packet */

 Reset and init BRB, PRS */

 Disable inputs of parser neighbor blocks */

 Write 0 to parser credits for CFC search request */

 send 10 Ethernet packets */

	/* Wait until NIG register shows 10 + 1

 Wait until PRS register shows 2 packets */

 Write 1 to parser credits for CFC search request */

 Wait until PRS register shows 3 packets */

 Wait until NIG register shows 1 packet of size 0x10 */

 clear NIG EOP FIFO */

 Reset and init BRB, PRS, NIG */

 set NIC mode */

 Enable inputs of parser neighbor blocks */

 OK */

	/*

	 * mask read length error interrupts in brb for parser

	 * (parsing unit and 'checksum and crc' unit)

	 * these errors are legal (PU reads fixed length and CAC can cause

	 * read length error on truncated packets)

	REG_WR(bp, XSEM_REG_XSEM_INT_MASK_0, 0); */

	REG_WR(bp, XSEM_REG_XSEM_INT_MASK_1, 0); */

	REG_WR(bp, USEM_REG_USEM_INT_MASK_0, 0); */

	REG_WR(bp, USEM_REG_USEM_INT_MASK_1, 0); */

	REG_WR(bp, CSEM_REG_CSEM_INT_MASK_0, 0); */

	REG_WR(bp, CSEM_REG_CSEM_INT_MASK_1, 0); */

	REG_WR(bp, TSEM_REG_TSEM_INT_MASK_0, 0); */

 enable VFC attentions: bits 11 and 12, bits 31:13 reserved */

	REG_WR(bp, MISC_REG_MISC_INT_MASK, 0); */

 bit 3,4 masked */

 reset_common */

	/*

	 * The fan failure mechanism is usually related to the PHY type since

	 * the power consumption of the board is affected by the PHY. Currently,

	 * fan is required for most designs with SFX7101, BCM8727 and BCM8481.

 Fan failure is indicated by SPIO 5 */

 set to active low mode */

 enable interrupt to signal the IGU */

 Avoid common init in case MFW supports LFA */

 make sure this value is 0 */

/**

 * bnx2x_init_hw_common - initialize the HW at the COMMON phase.

 *

 * @bp:		driver handle

	/*

	 * take the RESET lock to protect undi_unload flow from accessing

	 * registers while we're resetting the chip

		/**

		 * 4-port mode or 2-port mode we need to turn of master-enable

		 * for everyone, after that, turn it back on for self.

		 * so, we disregard multi-function or not, and always disable

		 * for all functions on the given path, this means 0,2,4,6 for

		 * path 0 and 1,3,5,7 for path 1

 clear pf enable */

		/* enable HW interrupt from PXP on USDM overflow

 let the HW do it's magic ... */

 finish PXP init */

	/* Timers bug workaround E2 only. We need to set the entire ILT to

	 * have entries with value "0" and valid bit on.

	 * This needs to be done by the first PF that is loaded in a path

	 * (i.e. common phase)

/* In E2 there is a bug in the timers block that can cause function 6 / 7

 * (i.e. vnic3) to start even if it is marked as "scan-off".

 * This occurs when a different function (func2,3) is being marked

 * as "scan-off". Real-life scenario for example: if a driver is being

 * load-unloaded while func6,7 are down. This will cause the timer to access

 * the ilt, translate to a logical address and send a request to read/write.

 * Since the ilt for the function that is down is not valid, this will cause

 * a translation error which is unrecoverable.

 * The Workaround is intended to make sure that when this happens nothing fatal

 * will occur. The workaround:

 *	1.  First PF driver which loads on a path will:

 *		a.  After taking the chip out of reset, by using pretend,

 *		    it will write "0" to the following registers of

 *		    the other vnics.

 *		    REG_WR(pdev, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER, 0);

 *		    REG_WR(pdev, CFC_REG_WEAK_ENABLE_PF,0);

 *		    REG_WR(pdev, CFC_REG_STRONG_ENABLE_PF,0);

 *		    And for itself it will write '1' to

 *		    PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER to enable

 *		    dmae-operations (writing to pram for example.)

 *		    note: can be done for only function 6,7 but cleaner this

 *			  way.

 *		b.  Write zero+valid to the entire ILT.

 *		c.  Init the first_timers_ilt_entry, last_timers_ilt_entry of

 *		    VNIC3 (of that port). The range allocated will be the

 *		    entire ILT. This is needed to prevent  ILT range error.

 *	2.  Any PF driver load flow:

 *		a.  ILT update with the physical addresses of the allocated

 *		    logical pages.

 *		b.  Wait 20msec. - note that this timeout is needed to make

 *		    sure there are no requests in one of the PXP internal

 *		    queues with "old" ILT addresses.

 *		c.  PF enable in the PGLC.

 *		d.  Clear the was_error of the PF in the PGLC. (could have

 *		    occurred while driver was down)

 *		e.  PF enable in the CFC (WEAK + STRONG)

 *		f.  Timers scan enable

 *	3.  PF driver unload flow:

 *		a.  Clear the Timers scan_en.

 *		b.  Polling for scan_on=0 for that PF.

 *		c.  Clear the PF enable bit in the PXP.

 *		d.  Clear the PF enable in the CFC (WEAK + STRONG)

 *		e.  Write zero+valid to all ILT entries (The valid bit must

 *		    stay set)

 *		f.  If this is VNIC 3 of a port then also init

 *		    first_timers_ilt_entry to zero and last_timers_ilt_entry

 *		    to the last entry in the ILT.

 *

 *	Notes:

 *	Currently the PF error in the PGLC is non recoverable.

 *	In the future the there will be a recovery routine for this error.

 *	Currently attention is masked.

 *	Having an MCP lock on the load/unload process does not guarantee that

 *	there is no Timer disable during Func6/7 enable. This is because the

 *	Timers scan is currently being cleared by the MCP on FLR.

 *	Step 2.d can be done only for PF6/7 and the driver can also check if

 *	there is error before clearing it. But the flow above is simpler and

 *	more general.

 *	All ILT entries are written by zero+valid and not just PF6/7

 *	ILT entries since in the future the ILT entries allocation for

 *	PF-s might be dynamic.

 initialize dummy TM client */

		/* Step 1: set zeroes to all ilt page entries with valid bit on

		 * Step 2: set the timers first/last ilt entry to point

		 * to the entire range to prevent ILT range error for 3rd/4th

		 * vnic	(this code assumes existence of the vnic)

		 *

		 * both steps performed by call to bnx2x_ilt_client_init_op()

		 * with dummy TM client

		 *

		 * we must use pretend since PXP2_REG_RQ_##blk##_FIRST_ILT

		 * and his brother are split registers

 let the HW do it's magic ... */

 clean the DMAE memory */

 QM queues pointers table */

 soft reset pulse */

 enable hw interrupt from doorbell Q */

			/* configure that VNTag and VLAN headers must be

			 * received in afex mode

			/* Bit-map indicating which L2 hdrs may appear

			 * after the basic Ethernet header

 reset VFC memories */

 sync semi rtc */

			/* configure that VNTag and VLAN headers must be

			 * sent in afex mode

 we currently assume that a context is 1024 bytes */

 enable context validation interrupt from CFC */

 set the thresholds to prevent CFC/CDU race */

 Reset PCIE errors for debug */

 in E3 this done in per-port section */

 not applicable for E2 (and above ...) */

 finish CFC init */

		/* read NIG statistic

 do internal memory self test */

 clear PXP2 attentions */

/**

 * bnx2x_init_hw_common_chip - init HW at the COMMON_CHIP phase.

 *

 * @bp:		driver handle

 In E2 2-PORT mode, same ext phy is used for the two paths */

	/* Timers bug workaround: disables the pf_master bit in pglue at

	 * common phase, we need to enable it here before any dmae access are

	 * attempted. Therefore we manually added the enable-master to the

	 * port phase (it also happens in the function phase)

 QM cid (connection) count */

 (24*1024 + val*4)/256 */

 14*1024/256 */

 configure headers for AFEX mode */

			/* Ovlan exists only if we are in multi-function +

			 * switch-dependent mode, in switch-independent there

			 * is no ovlan headers

 configure PBF to work without PAUSE mtu 9000 */

 update threshold */

 update init credit */

 probe changes */

	/* init aeu_mask_attn_func_0/1:

	 *  - SF mode: bits 3-7 are masked. Only bits 0-2 are in use

	 *  - MF mode: bit 3 is masked. Bits 0-2 are in use as in SF

 Enable DCBX attention for all but E1 */

 SCPAD_PARITY should NOT trigger close the gates */

		/* Bit-map indicating which L2 hdrs may appear after the

		 * basic Ethernet header

 0x2 disable mf_ov, 0x1 enable */

 If SPIO5 is set to generate interrupts, enable it for this port */

 Not supported in BC mode */

 wait for clean up to finish */

PF*/);

 T1 hash bits value determines the T1 number of entries */

 Prepare parameters for function state transitions */

 Function parameters */

 Close input from network */

 Close BMC to host */

	/* Suspend Tx switching to the PF. Completion of this ramrod

	 * further guarantees that all the packets of that PF / child

	 * VFs in BRB were processed by the Parser, so it is safe to

	 * change the NIC_MODE register.

 Change NIC_MODE register */

 Open input from network */

 Enable BMC to host */

 Resume Tx switching to the PF */

 Configure searcher as part of function hw init */

 Reset NIC mode */

/* previous driver DMAE transaction may have occurred when pre-boot stage ended

 * and boot began, or when kdump kernel was loaded. Either case would invalidate

 * the addresses of the transaction, resulting in was-error bit set in the pci

 * causing all hw-to-host pcie transactions to timeout. If this happened we want

 * to clear the interrupt which detected this from the pglueb and the was done

 * bit

 FLR cleanup - hmmm */

 set MSI reconfigure capability */

	/* since BNX2X_FIRST_VF_CID > 0 the PF L2 cids precedes

	 * those of the VFs, so start line should be reset

 Set NIC mode */

		/* Turn on a single ISR mode in IGU if driver is going to use

		 * INT#x or MSI

		/*

		 * Timers workaround bug: function init part.

		 * Need to wait 20msec after initializing ILT,

		 * needed to make sure there are no requests in

		 * one of the PXP internal queues with "old" ILT addresses

		/*

		 * Master enable - Due to WB DMAE writes performed before this

		 * register is re-initialized as part of the regular function

		 * init

 Enable the function in IGU */

 no dpm */

 HC init per function */

			/**

			 * Producer memory:

			 * E2 mode: address 0-135 match to the mapping memory;

			 * 136 - PF0 default prod; 137 - PF1 default prod;

			 * 138 - PF2 default prod; 139 - PF3 default prod;

			 * 140 - PF0 attn prod;    141 - PF1 attn prod;

			 * 142 - PF2 attn prod;    143 - PF3 attn prod;

			 * 144-147 reserved.

			 *

			 * E1.5 mode - In backward compatible mode;

			 * for non default SB; each even line in the memory

			 * holds the U producer and each odd line hold

			 * the C producer. The first 128 producers are for

			 * NDSB (PF0 - 0-31; PF1 - 32-63 and so on). The last 20

			 * producers are for the DSB for each PF.

			 * Each PF has five segments: (the order inside each

			 * segment is PF0; PF1; PF2; PF3) - 128-131 U prods;

			 * 132-135 C prods; 136-139 X prods; 140-143 T prods;

			 * 144-147 attn prods;

 non-default-status-blocks */

 send consumer update with value 0 */

 default-status-blocks */

			/*

			 * igu prods come in chunks of E1HVN_MAX (4) -

			 * does not matters what is the current chip mode

 send consumer update with 0 */

			/* !!! These should become driver const once

 Reset PCIE errors for debug */

dwords*/

 Clear "false" parity errors in MSI-X table */

 Clear HC parity attention */

 Enable STORMs SP logging */

 size = the status block + ramrod buffers */

 allocate searcher T2 table, as it wasn't allocated before */

 write address to which L5 should insert its values */

 allocate searcher T2 table */

	/* Allocate memory for CDU context:

	 * This memory is allocated separately and not in the generic ILT

	 * functions because CDU differs in few aspects:

	 * 1. There are multiple entities allocating memory for context -

	 * 'regular' driver, CNIC and SRIOV driver. Each separately controls

	 * its own ILT lines.

	 * 2. Since CDU page-size is not a single 4KB page (which is the case

	 * for the other ILT clients), to be efficient we want to support

	 * allocation of sub-page-size in the last entry.

	 * 3. Context pointers are used by the driver to pass to FW / update

	 * the context (for the other ILT clients the pointers are used just to

	 * free the memory during unload).

 Slow path ring */

 EQ */

/*

 * Init service functions

 Fill general parameters */

 Fill a user request section if needed */

 Set the command: ADD or DEL */

 do not treat adding same MAC as error */

 Fill general parameters */

 Fill a user request section if needed */

 Set the command: ADD or DEL */

 Do not treat adding same vlan as error. */

 Mark that hw forgot all entries */

 Wait for completion of requested */

 Set the mac type of addresses we want to clear */

 vf */

 VF */

/**

 * bnx2x_set_int_mode - configure interrupt mode

 *

 * @bp:		driver handle

 *

 * In case of MSI-X it will also try to enable MSI-X.

 attempt to enable msix */

 msix attained */

 vfs use only msix */

 failed to enable multiple MSI-X */

 must be called prior to any HW initializations */

 CDU */

 QM */

 4 bytes for each cid */

 SRC */

 TM */

/**

 * bnx2x_pf_q_prep_init - prepare INIT transition parameters

 *

 * @bp:			driver handle

 * @fp:			pointer to fastpath

 * @init_params:	pointer to parameters structure

 *

 * parameters configured:

 *      - HC configuration

 *      - Queue's CDU context

 FCoE Queue uses Default SB, thus has no HC capabilities */

		/* If HC is supported, enable host coalescing in the transition

		 * to INIT state.

 HC rate */

 FW SB ID */

		/*

		 * CQ index among the SB indices: FCoE clients uses the default

		 * SB, therefore it's different.

 set maximum number of COSs supported by this queue */

 set the context pointers queue object */

 Set the command */

 Set tx-only QUEUE flags: don't zero statistics */

 choose the index of the cid to send the slow path on */

 Set general TX_ONLY_SETUP parameters */

 Set Tx TX_ONLY_SETUP parameters */

 send the ramrod */

/**

 * bnx2x_setup_queue - setup queue

 *

 * @bp:		driver handle

 * @fp:		pointer to fastpath

 * @leading:	is leading

 *

 * This function performs 2 steps in a Queue state machine

 *      actually: 1) RESET->INIT 2) INIT->SETUP

 reset IGU state skip FCoE L2 queue */

 We want to wait for completion in this context */

 Prepare the INIT parameters */

 Set the command */

 Change the state to INIT */

 Now move the Queue to the SETUP state... */

 Set QUEUE flags */

 Set general SETUP parameters */

 Set the command */

 Change the state to SETUP */

 loop through the relevant tx-only indices */

 prepare and send tx-only ramrod*/

 We want to wait for completion in this context */

 close tx-only connections */

 ascertain this is a normal queue*/

 send halt terminate on tx-only connection */

 send halt terminate on tx-only connection */

 Stop the primary connection: */

 ...halt the connection */

 ...terminate the connection */

 ...delete cfc entry */

 Disable the function in the FW */

 FP SBs */

 CNIC SB */

 SP SB */

 Configure IGU */

 Disable Timer scan */

		/*

		 * Wait for at least 10ms and up to 2 second for the timers

		 * scan to complete

 Clear ILT */

	/* Timers workaround bug for E2: if this is vnic-3,

	 * we need to set the entire ilt range for this timers.

 use dummy TM client */

 this assumes that reset_port() called before reset_func()*/

 Reset physical Link */

 Do not rcv packets to BRB */

 Do not direct rcv packets that are not for MCP to the BRB */

 Configure AEU */

 Check for BRB port occupancy */

 TODO: Close Doorbell port? */

 Prepare parameters for function state transitions */

 Prepare parameters for function state transitions */

	/*

	 * Try to stop the function the 'good way'. If fails (in case

	 * of a parity error during bnx2x_chip_cleanup()) and we are

	 * not in a debug mode, perform a state transaction in order to

	 * enable further HW_RESET transaction.

/**

 * bnx2x_send_unload_req - request unload mode from the MCP.

 *

 * @bp:			driver handle

 * @unload_mode:	requested function's unload mode

 *

 * Return unload mode returned by the MCP: COMMON, PORT or FUNC.

 Select the UNLOAD request mode */

		/* The mac address is written to entries 1-4 to

		 * preserve entry 0 which is used by the PMF

 Enable the PME and clear the status */

 Send the request to the MCP */

/**

 * bnx2x_send_unload_done - send UNLOAD_DONE command to the MCP.

 *

 * @bp:		driver handle

 * @keep_link:		true iff link should be kept up

 Report UNLOAD_DONE to MCP */

	/*

	 * (assumption: No Attention from MCP at this stage)

	 * PMF probably in the middle of TX disable/enable transaction

	 * 1. Sync IRS for default SB

	 * 2. Sync SP queue - this guarantees us that attention handling started

	 * 3. Wait, that TX disable/enable transaction completes

	 *

	 * 1+2 guarantee that if DCBx attention was scheduled it already changed

	 * pending bit of transaction from STARTED-->TX_STOPPED, if we already

	 * received completion for the transaction the state is TX_STOPPED.

	 * State will return to STARTED after completion of TX_STOPPED-->STARTED

	 * transaction.

 make sure default SB ISR is done */

		/*

		 * Failed to complete the transaction in a "good way"

		 * Force both transactions with CLR bit

 STARTED-->TX_ST0PPED */

 TX_ST0PPED-->STARTED */

 Disable sending PTP packets to host */

 Reset PTP event detection rules */

 Disable the PTP feature */

 Called during unload, to stop PTP-related stuff */

	/* Cancel PTP work queue. Should be done after the Tx queues are

	 * drained to prevent additional scheduling.

 Disable PTP in HW */

 Wait until tx fastpath tasks complete */

 Give HW time to discard old tx messages */

 Clean all ETH MACs */

 Clean up UC list  */

	/* The whole *vlan_obj structure may be not initialized if VLAN

	 * filtering offload is not supported by hardware. Currently this is

	 * true for all hardware covered by CHIP_IS_E1x().

 Remove all currently configured VLANs */

 Disable LLH */

	/* Set "drop all" (stop Rx).

	 * We need to take a netif_addr_lock() here in order to prevent

	 * a race between the completion code and this code.

 Schedule the rx_mode command */

 Cleanup multicast configuration */

	/*

	 * Send the UNLOAD_REQUEST to the MCP. This will return if

	 * this function should perform FUNC, PORT or COMMON HW

	 * reset.

	/*

	 * (assumption: No Attention from MCP at this stage)

	 * PMF probably in the middle of TX disable/enable transaction

	/* Close multi and leading connections

	 * Completions for ramrods are collected in a synchronous way

	/* If SP settings didn't get completed so far - something

	 * very wrong has happen.

	/* stop_ptp should be after the Tx queues are drained to prevent

	 * scheduling to the cancelled PTP work queue. It should also be after

	 * function stop ramrod is sent, since as part of this ramrod FW access

	 * PTP registers.

 Disable HW interrupts, NAPI */

 Delete all NAPI objects */

 Release IRQs */

	/* Reset the chip, unless PCI function is offline. If we reach this

	 * point following a PCI error handling, it means device is really

	 * in a bad state and we're about to remove it, so reset the chip

	 * is not a good idea.

 Report UNLOAD_DONE to MCP */

 Close gates #2, #3 and #4: */

 Gates #2 and #4a are closed/opened for "not E1" only */

 #4 */

 #2 */

 #3 */

 Prevent interrupts from HC on both ports */

 Prevent incoming interrupts in IGU */

 `magic' bit */

 Do some magic... */

/**

 * bnx2x_clp_reset_done - restore the value of the `magic' bit.

 *

 * @bp:		driver handle

 * @magic_val:	old value of the `magic' bit.

 Restore the `magic' bit value... */

/**

 * bnx2x_reset_mcp_prep - prepare for MCP reset.

 *

 * @bp:		driver handle

 * @magic_val:	old value of 'magic' bit.

 *

 * Takes care of CLP configurations.

 Set `magic' bit in order to save MF config */

 Get shmem offset */

 Clear validity map flags */

 5 seconds (in ms) */

 100 ms */

/**

 * bnx2x_mcp_wait_one - wait for MCP_ONE_TIMEOUT

 *

 * @bp:	driver handle

	/* special handling for emulation and FPGA,

/*

 * initializes bp->common.shmem_base and waits for validity signature to appear

		/* If we read all 0xFFs, means we are in PCI error state and

		 * should bail out to avoid crashes on adapter's FW reads.

 Restore the `magic' bit value */

/*

 * Reset the whole chip except for:

 *      - PCIE core

 *      - PCI Glue, PSWHST, PXP/PXP2 RF (all controlled by

 *              one reset bit)

 *      - IGU

 *      - MISC (including AEU)

 *      - GRC

 *      - RBCN, RBCP

	/*

	 * Bits that have to be set in reset_mask2 if we want to reset 'global'

	 * (per chip) blocks.

	/* Don't reset the following blocks.

	 * Important: per port blocks (such as EMAC, BMAC, UMAC) can't be

	 *            reset, as in 4 port device they might still be owned

	 *            by the MCP (there is only one leader per path).

	/*

	 * Keep the following blocks in reset:

	 *  - all xxMACs are handled by the bnx2x_link code.

 Full reset masks according to the chip */

 CHIP_IS_E3 */

 Don't reset global blocks unless we need to */

	/*

	 * In case of attention in the QM, we need to reset PXP

	 * (MISC_REGISTERS_RESET_REG_2_RST_PXP_RQ_RD_WR) before QM

	 * because otherwise QM reset would release 'close the gates' shortly

	 * before resetting the PXP, then the PSWRQ would send a write

	 * request to PGLUE. Then when PXP is reset, PGLUE would try to

	 * read the payload data from PSWWR, but PSWWR would not

	 * respond. The write queue in PGLUE would stuck, dmae commands

	 * would not return. Therefore it's important to reset the second

	 * reset register (containing the

	 * MISC_REGISTERS_RESET_REG_2_RST_PXP_RQ_RD_WR bit) before the

	 * first one (containing the MISC_REGISTERS_RESET_REG_1_RST_QM

	 * bit).

/**

 * bnx2x_er_poll_igu_vq - poll for pending writes bit.

 * It should get cleared in no more than 1s.

 *

 * @bp:	driver handle

 *

 * It should get cleared in no more than 1s. Returns 0 if

 * pending writes bit gets cleared.

 Empty the Tetris buffer, wait for 1s */

 Close gates #2, #3 and #4 */

 Poll for IGU VQs for 57712 and newer chips */

 TBD: Indicate that "process kill" is in progress to MCP */

 Clear "unprepared" bit */

	/* Wait for 1ms to empty GLUE and PCI-E core queues,

	 * PSWHST, GRC and PSWRD Tetris buffer.

 Prepare to chip reset: */

 MCP */

 PXP */

 reset the chip */

 clear errors in PGB */

 Recover after reset: */

 MCP */

 TBD: Add resetting the NO_MCP mode DB here */

 Open the gates #2, #3 and #4 */

	/* TBD: IGU/AEU preparation bring back the AEU/IGU to a

	/* if not going to reset MCP - load "fake" driver to reset HW while

	 * driver is owner of the HW

 Try to recover after the failure */

	/*

	 * Clear RESET_IN_PROGRES and RESET_GLOBAL bits and update the driver

	 * state.

 unload "fake driver" if it was loaded */

 Disconnect this device */

	/*

	 * Block ifup for all function on this engine until "process kill"

	 * or power cycle.

 Shut down the power */

/*

 * Assumption: runs under rtnl lock. This together with the fact

 * that it's called only from bnx2x_sp_rtnl() ensure that it

 * will never be called when netif_running(bp->dev) is false.

 Try to get a LEADER_LOCK HW lock */

				/*

				 * Check if there is a global attention and if

				 * there was a global attention, set the global

				 * reset bit.

 Stop the driver */

 If interface has been removed - break */

			/* Ensure "is_leader", MCP command sequence and

			 * "recovery_state" update values are seen on other

			 * CPUs.

				/*

				 * In case of a parity in a global block, let

				 * the first leader that performs a

				 * leader_reset() reset the global blocks in

				 * order to clear global attentions. Otherwise

				 * the gates will remain closed for that

				 * engine.

					/* Wait until all other functions get

					 * down.

					/* If all other functions got down -

					 * try to bring the chip back to

					 * normal. In any case it's an exit

					 * point for a leader.

					/* If we are here, means that the

					 * leader has succeeded and doesn't

					 * want to be a leader any more. Try

					 * to continue as a none-leader.

 non-leader */

					/* Try to get a LEADER_LOCK HW lock as

					 * long as a former leader may have

					 * been unloaded by the user or

					 * released a leadership by another

					 * reason.

						/* I'm a leader now! Restart a

						 * switch case.

					/*

					 * If there was a global attention, wait

					 * for it to be cleared.

 Disconnect this device */

 Shut down the power */

 Prepare parameters for function state transitions */

 Function parameters */

 Re-enable inner-rss for the offloaded UDP tunnels */

/* bnx2x_nic_unload() flushes the bnx2x_wq, thus reset task is

 * scheduled on a general queue in order to prevent a dead lock.

		/*

		 * Clear all pending SP commands as we are going to reset the

		 * function anyway.

		/*

		 * Clear all pending SP commands as we are going to reset the

		 * function anyway.

 Immediately indicate link as down */

		/* When ret value shows failure of allocation failure,

		 * the nic is rebooted again. If open still fails, a error

		 * message to notify the user.

	/*

	 * in case of fan failure we need to reset id if the "stop on error"

	 * debug flag is set, since we trying to prevent permanent overheating

	 * damage

	/* work which needs rtnl lock not-taken (as it takes the lock itself and

	 * can be called from other contexts as well)

 enable SR-IOV if applicable */

	/*

	 * The barrier is needed to ensure the ordering between the writing to

	 * the bp->port.pmf in the bnx2x_nic_load() or bnx2x_pmf_update() and

	 * the reading here.

 Re-queue task in 1 sec */

/*

 * Init service functions

 reset addresses as they also mark which values were changed */

			/*

			 * use rd/wr since we cannot use dmae. This is safe

			 * since MCP won't access the bus due to the request

			 * to unload, and no function on the path can be

			 * loaded at this time.

	/* UNDI marks its presence in DORQ -

	 * it initializes CID offset for normal bell to 0x7

 Check whether the entry for this path already exists */

 Create an entry for this path and add it */

 only bootcode REQ_BC_VER_4_INITIATE_FLR and onwards support flr */

 Test if previous unload process was already finished for this path */

 Cannot proceed with FLR if UNDI is loaded, since FW does not match */

	/* If function has FLR capabilities, and existing FW version matches

	 * the one required, then FLR will be sufficient to clean any residue

	 * left by previous driver

 fw version is good */

 FLR was performed */

 Close the MCP request, return failure*/

	/* It is possible a previous function received 'common' answer,

	 * but hasn't loaded yet, therefore creating a scenario of

	 * multiple functions receiving 'common' on the same path.

 Reset should be performed after BRB is emptied */

 Close the MAC Rx to prevent BRB from filling up */

 close LLH filters for both ports towards the BRB */

 Check if the UNDI driver was previously loaded */

 clear the UNDI indication */

 clear possible idle check errors */

 block FW from writing to host */

 wait until BRB is empty */

 reset timer as long as BRB actually gets emptied */

 If UNDI resides in memory, manually increment it */

 No packets are in the pipeline, path is ready for reset */

	/* clear hw from errors which may have resulted from an interrupted

	 * dmae transaction.

 Release previously held locks */

 Lock MCP using an unload request */

 If Path is marked by EEH, ignore unload status */

 non-common reply from MCP might require looping */

 Mark function if its port was used to boot from SAN */

 Get the chip revision id and number. */

 chip num:16-31, rev:12-15, metal:4-11, bond_id:0-3 */

	/* Metal is read from PCI regs, but we can't access >=0x400 from

	 * the configuration space (so we need to reg_rd)

 force 57811 according to MISC register */

 Set doorbell size */

 0..3 */

 0, 2, 4, 6 */

 N/A */

 0..7 */

		/* for now only warn

 IGU in normal mode - read CAM */

 default status block */

	/* Due to new PF resource allocation by MFW T7.4 and above, it's

	 * optional that number of CAM entries will not be equal to the value

	 * advertised in PCI.

	 * Driver should use the minimal value of both as the actual status

	 * block count

 Aggregation of supported attributes of all external phys */

 mask what we support according to speed_cap_mask per configuration */

 force 10G, no AN */

	/* If the device is capable of WoL, set the default state according

	 * to the HW

	/*

	 * If connected directly, work with the internal PHY, otherwise, work

	 * with the external PHY

 Configure link feature according to nvram value */

 Get the number of maximum allowed iSCSI connections */

	/*

	 * If maximum allowed number of connections is zero -

	 * disable the feature.

 Port info */

 Node info */

 iterate over absolute function ids for this path: */

 SF */

 Get the number of maximum allowed FCoE connections */

 Calculate the number of maximum allowed FCoE tasks */

 check if FCoE resources must be shared between different functions */

 Read the WWN: */

 Port info */

 Node info */

		/* Read the WWN info only if the FCoE feature is enabled for

		 * this function.

	/*

	 * If maximum allowed number of connections is zero -

	 * disable the feature.

	/*

	 * iSCSI may be dynamically disabled but reading

	 * info here we will decrease memory usage by driver

	 * if the feature is disabled for good

		/* iSCSI and FCoE NPAR MACs: if there is no either iSCSI or

		 * FCoE MAC then the appropriate feature should be disabled.

		 * In non SD mode features configuration comes from struct

		 * func_ext_config.

 SD MODE */

 use primary mac as iscsi mac */

 use primary mac as fip mac */

		/* If this is a storage-only interface, use SAN mac as

		 * primary MAC. Notice that for SD this is already the case,

		 * as the SAN mac was copied from the primary MAC.

 Disable iSCSI OOO if MAC configuration is invalid. */

 Disable FCoE if MAC configuration is invalid. */

 Zero primary MAC configuration */

 in SF read MACs from port configuration */

 Read physical port identifier from shmem */

 Take function: tmp = func */

 Take port: tmp = port */

 check for legal mac (upper bytes) */

abs*/func = BP_ABS_FUNC(bp);

 Validate that chip access is feasible */

	/*

	 * initialize IGU parameters

 do not allow device reset during IGU info processing */

	/*

	 * set base FW non-default (fast path) status block id, this value is

	 * used to initialize the fw_sb_id saved on the fp/queue structure to

	 * determine the id used by the FW.

	else /*

	      * 57712 - we currently use one FW SB per IGU SB (Rx and Tx of

	      * the same queue are indicated on the same IGU SB). So we prefer

	      * FW and IGU SBs to be the same value.

	/*

	 * Initialize MF configuration

		/*

		 * get mf configuration:

		 * 1. Existence of MF configuration

		 * 2. MAC address must be legal (check only upper bytes)

		 *    for  Switch-Independent mode;

		 *    OVLAN must be legal for Switch-Dependent mode

		 * 3. SF_MODE configures specific MF mode

 get mf configuration */

 get OV configuration */

 if valid: update device mtu */

 Unknown configuration */

 Unknown configuration: reset mf_config */

		/* check if other port on the path needs ovlan:

		 * Since MF configuration is shared between ports

		 * Possible mixed modes are only

		 * {SF, SI} {SF, SD} {SD, SF} {SI, SF}

 adjust igu_sb_cnt to MF for E1H */

 port info */

 Get MAC addresses */

 vendor specific info */

if (CHIP_REV(bp) == CHIP_REV_Bx)*/

(__BIG_ENDIAN)*/

 need to reset chip if undi was active */

 init fw_seq */

 Reduce memory usage in kdump environment by disabling TPA */

 Set TPA flags */

 make sure that the numbers are in the right granularity */

 multiple tx priority */

	/* We need at least one default status block for slow-path events,

	 * second status block for the L2 queue, and a third status block for

	 * CNIC if supported.

 PF w/o cnic */

/****************************************************************************

* General service functions

/*

 * net_device service functions

 called with rtnl_lock */

	/* If parity had happen during the unload, then attentions

	 * and/or RECOVERY_IN_PROGRES may still be set. In this case we

	 * want the first function loaded on the current engine to

	 * complete the recovery.

	 * Parity recovery is only relevant for PF driver.

				/* If there are attentions and they are in a

				 * global blocks, set the GLOBAL_RESET bit

				 * regardless whether it will be this function

				 * that will complete the recovery or not.

				/* Only the first function on the current

				 * engine should try to recover in open. In case

				 * of attentions in global blocks only the first

				 * in the chip should try to recover.

 recovery has failed... */

 called with rtnl_lock */

 Unload the driver, release IRQs */

/**

 * bnx2x_set_uc_list - configure a new unicast MACs list.

 *

 * @bp: driver handle

 *

 * We will use zero (0) as a MAC type for these MACs.

 First schedule a cleanup up of old configuration */

 do not treat adding same MAC as error */

 Execute the pending commands */

 don't care */,

 first, clear all configured multicast MACs */

 then, configure a new MACs list */

 Now add the new MACs */

 On older adapters, we need to flush and re-add filters */

 Override the curently configured set of mc filters */

 If no mc addresses are required, flush the configuration */

 If bp->state is OPEN, should be called with netif_addr_lock_bh() */

 Schedule an SP task to handle rest of change */

 some multicasts */

 release bh lock, as bnx2x_set_uc_list might sleep */

			/* configuring mcast to a vf involves sleeping (when we

			 * wait for the pf's response).

 handle ISCSI SD mode */

 Schedule the rx_mode command */

		/* VF will need to request the PF to make this change, and so

		 * the VF needs to release the bottom-half lock prior to the

		 * request (as it will likely require sleep on the VF side)

 called with rtnl_lock */

 The HW expects different devad if CL22 is used */

 called with rtnl_lock */

 The HW expects different devad if CL22 is used */

 called with rtnl_lock */

 query the bulletin board for mac address configured by the PF */

	/*

	 * A skb with gso_size + header length > 9700 will cause a

	 * firmware panic. Drop GSO support.

	 *

	 * Eventually the upper layer should not pass these packets down.

	 *

	 * For speed, if the gso_size is <= 9000, assume there will

	 * not be 700 bytes of headers and pass it through. Only do a

	 * full (slow) validation if the gso_size is > 9000.

	 *

	 * (Due to the way SKB_BY_FRAGS works this will also do a full

	 * validation in that case.)

 Configure all non-configured entries */

 Don't set rx mode here. Our caller will do it. */

	/* In E1/E1H use pci device function given by kernel.

	 * In E2/E3 read physical function from ME register since these chips

	 * support Physical Device Assignment where kernel BDF maybe arbitrary

	 * (depending on hypervisor).

 chip is E2/3*/

 clean indirect addresses */

 Set PCIe reset type to fundamental for EEH recovery */

 AER (Advanced Error reporting) configuration */

	/*

	 * Clean the following indirect addresses for all functions since it

	 * is not used by the driver.

		/* Enable internal target-read (in case we are probed after PF

		 * FLR). Must be done prior to any BAR read access. Only for

		 * 57712 and up

	/* For VF we'll know whether to enable VLAN filtering after

	 * getting a response to CHANNEL_TLV_ACQUIRE from PF.

 Add Loopback capability to the device */

 MTU range, 46 - 9600 */

 get_port_hwinfo() will set prtad and mmds properly */

	/* Make sure none of the offsets and sizes make us read beyond

 Likewise for the init_ops offsets */

 Check FW version */

/*

   Ops array is stored in the following format:

   {op(8bit), offset(24bit, big endian), data(32bit, big endian)}

/* IRO array is stored in the following format:

 * {base(24bit), m1(16bit), m2(16bit), m3(16bit), size(16bit) }

 Initialize the pointers to the init arrays */

 Blob */

 Opcodes */

 Offsets */

 STORMs firmware */

 IRO */

 Prepare DMAE related driver resources */

 must be called after sriov-enable */

/**

 * bnx2x_get_num_non_def_sbs - return the number of none default SBs

 * @pdev: pci device

 * @cnic_cnt: count

 *

	/*

	 * If MSI-X is not supported - return number of SBs needed to support

	 * one fast path queue: one FP queue + SB for CNIC

	/*

	 * The value in the PCI configuration space is the index of the last

	 * entry, namely one less than the actual size of the table, which is

	 * exactly what we want to return from this function: number of all SBs

	 * without the default SB.

	 * For VFs there is no default SB, then we return (index+1).

 nig_tsgen registers relative address */

 FW workaround for setting drift */

 Prepare parameters for function state transitions */

 Function parameters */

		/* Changed not to allow val = 8, 16, 24 as these values

		 * are not supported in workaround.

 Re-init the timecounter */

 Enable (or disable) ancillary features of the phc subsystem */

 Fill the ptp_clock_info struct and register PTP clock*/

 In PPB */

	/* Management FW 'remembers' living interfaces. Allow it some time

	 * to forget previously living interfaces, allowing a proper re-load.

	/* An estimated maximum supported CoS number according to the chip

	 * version.

	 * We will try to roughly estimate the maximum number of CoSes this chip

	 * may support in order to minimize the memory allocated for Tx

	 * netdev_queue's. This number will be accurately calculated during the

	 * initialization of bp->max_cos based on the chip versions AND chip

	 * revision in the bnx2x_init_bp().

 add another SB for VF as it has no default SB */

 Maximum number of RSS queues: one IGU SB goes to CNIC */

 Maximum number of netdev Rx queues: RSS + FCoE L2 */

	/* Maximum number of netdev Tx queues:

	 * Maximum TSS queues * Maximum supported number of CoS  + FCoE L2

 dev zeroed in init_etherdev */

	/* Map doorbells here as we need the real value of bp->max_cos which

	 * is initialized in bnx2x_init_bp() to determine the number of

	 * l2 connections.

 VF with OLD Hypervisor or old PF do not support filtering */

 Enable SRIOV if capability found in configuration space */

 calc qm_cid_count */

 disable FCOE L2 queue for E1x*/

 Set bp->num_queues for MSI-X mode*/

	/* Configure interrupt mode: try to enable MSI-X/MSI if

	 * needed.

 register the net device */

 Add storage MAC address */

 Delete storage MAC address */

 Delete app tlvs from dcbnl */

 Close the interface - either directly or implicitly */

 Power on: we can't let PCI layer write to us while we are in D3 */

		/* Set endianity registers to reset values in case next driver

		 * boots in different endianty environment.

 Disable MSI/MSI-X */

 Power off */

 Make sure RESET task is not scheduled before continuing */

 send message via vfpf channel to release the resources of this vf */

 Assumes no further PCIe PM changes will occur */

		/* For vfs, doorbells are part of the regview and were unmapped

		 * along with it. FW is only loaded by PF.

 Stop Tx */

 Delete all NAPI objects */

/**

 * bnx2x_io_error_detected - called when PCI error is detected

 * @pdev: Pointer to PCI device

 * @state: The current pci connection state

 *

 * This function is called after a PCI bus error affecting

 * this device has been detected.

 Request a slot reset */

/**

 * bnx2x_io_slot_reset - called after the PCI bus has been reset

 * @pdev: Pointer to PCI device

 *

 * Restart the card from scratch, as if from a cold-boot.

 MCP should have been reset; Need to wait for validity */

 Report UNLOAD_DONE to MCP */

		/* We should have reseted the engine, so It's fair to

		 * assume the FW will no longer write to the bnx2x driver.

/**

 * bnx2x_io_resume - called when traffic can start flowing again

 * @pdev: Pointer to PCI device

 *

 * This callback is called when the error recovery driver tells us that

 * its OK to resume normal operation.

	/* Don't remove the netdevice, as there are scenarios which will cause

	 * the kernel to hang, e.g., when trying to remove bnx2i while the

	 * rootfs is mounted from SAN.

 Free globally allocated resources */

/**

 * bnx2x_set_iscsi_eth_mac_addr - set iSCSI MAC(s).

 * @bp:		driver handle

 *

 * This function will wait until the ramrod completion returns.

 * Return 0 if success, -ENODEV if ramrod doesn't return.

 count denotes the number of new completions we have seen */

		/* Set validation for iSCSI L2 client before sending SETUP

		 *  ramrod

		/*

		 * There may be not more than 8 L2, not more than 8 L5 SPEs

		 * and in the air. We also check that number of outstanding

		 * COMMON ramrods is not more than the EQ and SPQ can

		 * accommodate.

/*

 * for commands that have no data

 first we tell CNIC and only then we count this as a completion */

/* Called with netif_addr_lock_bh() taken.

 * Sets an rx_mode config for an iSCSI ETH client.

 * Doesn't block.

 * Completion should be checked outside.

		/* Start accepting on iSCSI L2 ring. Accept all multicasts

		 * because it's the only way for UIO Queue to accept

		 * multicasts (in non-promiscuous mode only one Queue per

		 * function will receive multicast packets (leading in our

		 * case).

 Clear STOP_PENDING bit if START is requested */

 Clear START_PENDING bit if STOP is requested */

 rtnl_lock is held.  */

 Configure the iSCSI classification object */

 Set iSCSI MAC address */

 Start accepting on iSCSI L2 ring */

 bits to wait on */

 rtnl_lock is held.  */

 Stop accepting on iSCSI L2 ring */

 bits to wait on */

 Unset iSCSI L2 MAC */

 first write capability to shmem2 */

 if reached here - should write fcoe capabilities */

 For storage-only interfaces, change driver state */

 Read the table contents from nvram */

	/* Since bnx2x_nvram_read() returns data in be32, we need to convert

	 * the number of entries back to cpu endianness.

 Copy the data into cnic-provided struct */

 Schedule driver to read CNIC driver versions */

	/* If both iSCSI and FCoE are disabled - return NULL in

	 * order to indicate CNIC that it should not try to work

	 * with this device.

/* called only on E1H or E2.

 * When pretending to be PF, the pretend value is the function number 0...7

 * When pretending to be VF, the pretend val is the PF-num:VF-valid:ABS-VFID

 * combination

 get my own pretend register */

	/* FW may take a while to complete timestamping; try a bit and if it's

	 * still not complete, may indicate an error state - bail out then.

 Read Tx timestamp registers */

 There is a valid timestamp value */

 Reset timestamp register to allow new timestamp */

 Reset timestamp register to allow new timestamp */

 Read the PHC */

 Prepare parameters for function state transitions */

 Function parameters */

 send queue update ramrod to enable PTP packets */

 send the ramrod on all the queues of the PF */

 Set the appropriate Queue object */

 Update the Queue state */

 Initialize PTP detection for UDP/IPv4 events */

 Initialize PTP detection for UDP/IPv4 or UDP/IPv6 events */

 Initialize PTP detection L2 events */

 Initialize PTP detection L2, UDP/IPv4 or UDP/IPv6 events */

 Indicate to FW that this PF expects recorded PTP packets */

 Enable sending PTP packets to host */

 Configures HW for PTP */

 Reset PTP event detection rules - will be configured in the IOCTL */

 Disable PTP packets to host - will be configured in the IOCTL*/

 Enable the PTP feature */

 Enable the free-running counter */

 Reset drift register (offset register is not reset) */

 Reset possibly old timestamps */

 Called during load, to initialize PTP-related stuff */

 Configure PTP in HW */

 Init work queue for Tx timestamping */

	/* Init cyclecounter and timecounter. This is done only in the first

	 * load. If done in every load, PTP application will fail when doing

	 * unload / load (e.g. MTU change) while it is running.

/* bnx2x_stats.c: QLogic Everest network driver.

 *

 * Copyright (c) 2007-2013 Broadcom Corporation

 * Copyright (c) 2014 QLogic Corporation

 * All rights reserved

 *

 * This program is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License as published by

 * the Free Software Foundation.

 *

 * Maintained by: Ariel Elior <ariel.elior@qlogic.com>

 * Written by: Eliezer Tamir

 * Based on code from Michael Chan's bnx2 driver

 * UDP CSUM errata workaround by Arik Gendelman

 * Slowpath and fastpath rework by Vladislav Zolotarov

 * Statistics and Link management by Yitchak Gertner

 *

 Statistics */

/*

 * General service functions

 'newest' convention - shmem2 cotains the size of the port stats */

 prevent newer BC from causing buffer overflow */

	/* Older convention - all BCs support the port stats' fields up until

	 * the 'not_used' field

 if PFC stats are supported by the MFW, DMA them as well */

/*

 * Init service functions

/* Post the next statistics ramrod. Protect it with the spin in

 * order to ensure the strict order between statistics ramrods

 * (each ramrod has a sequence number passed in a

 * bp->fw_stats_req->hdr.drv_stats_counter and ramrods must be

 * sent in order).

 adjust the ramrod to include VF queues statistics */

 send FW stats ramrod */

 Update MCP's statistics if possible */

 loader */

/*

 * Statistics service functions

 should be called under stats_sema */

 sanity */

 sanity */

 MCP */

 MAC */

 EMAC is special */

 EMAC_REG_EMAC_RX_STAT_AC (EMAC_REG_EMAC_RX_STAT_AC_COUNT)*/

 EMAC_REG_EMAC_RX_STAT_AC_28 */

 EMAC_REG_EMAC_TX_STAT_AC (EMAC_REG_EMAC_TX_STAT_AC_COUNT)*/

 configure the params according to MAC type */

			/* BIGMAC_REGISTER_TX_STAT_GTPKT ..

 handled by MSTAT */

 handled by MSTAT */

 TX stats */

 RX stats */

 NIG */

 sanity */

 should be called under stats_sema */

	/* vfs travel through here as part of the statistics FSM, but no action

	 * is required

 the macros below will use "bmac1_stats" type */

 the macros below will use "bmac2_stats" type */

 collect PFC stats */

 collect pfc stats */

 unreached */

 unreached */

	/* Make sure we use the value of the counter

	 * used for sending the last stats ramrod.

 are storm stats valid? */

 vfs stat counter is managed by pf */

		/*

		 * sum to total_bytes_received all

		 * unicast/multicast/broadcast

		/*

		 * sum to total_bytes_transmitted all

		 * unicast/multicast/broadcast

 TPA aggregations completed */

 Number of network frames aggregated by TPA */

 Total number of bytes in completed TPA aggregations */

		/* vf doesn't collect HW statistics, and doesn't get completions

		 * perform only update

 vf is done */

 state	event	*/

 DISABLED	PMF	*/ {bnx2x_stats_pmf_update, STATS_STATE_DISABLED},

		LINK_UP	*/ {bnx2x_stats_start,      STATS_STATE_ENABLED},

		UPDATE	*/ {bnx2x_stats_do_nothing, STATS_STATE_DISABLED},

		STOP	*/ {bnx2x_stats_do_nothing, STATS_STATE_DISABLED}

 ENABLED	PMF	*/ {bnx2x_stats_pmf_start,  STATS_STATE_ENABLED},

		LINK_UP	*/ {bnx2x_stats_restart,    STATS_STATE_ENABLED},

		UPDATE	*/ {bnx2x_stats_update,     STATS_STATE_ENABLED},

		STOP	*/ {bnx2x_stats_stop,       STATS_STATE_DISABLED}

	/* Statistics update run from timer context, and we don't want to stop

	 * that context in case someone is in the middle of a transition.

	 * For other events, wait a bit until lock is taken.

 sanity */

/* This function will prepare the statistics ramrod data the way

 * we will only have to increment the statistics counter and

 * send the ramrod each time we have to.

	/* storm_counters struct contains the counters of completed

	 * statistics requests per storm which are incremented by FW

	 * each time it completes hadning a statistics ramrod. We will

	 * check these counters in the timer handler and discard a

	 * (statistics) ramrod completion.

	/* prepare to the first stats ramrod (will be completed with

	 * the counters equal to zero) - init counters to somethig different.

*** Port FW statistics data ****/

 For port query index is a DONT CARE */

 For port query funcID is a DONT CARE */

*** PF FW statistics data ****/

 For PF query index is a DONT CARE */

*** FCoE FW statistics data ****/

 For FCoE query index is a DONT CARE */

*** Clients' queries ****/

	/* first queue query index depends whether FCoE offloaded request will

	 * be included in the ramrod

 add FCoE queue query if needed */

 function stats */

 mark the end of statistics initialization */

abs*/port = BP_PORT(bp);

 port and func stats for management */

 pmf should retrieve port statistics from SP on a non-init*/

 port stats */

 Prepare statistics ramrod data */

 Clean SP from previous statistics */

 save queue statistics */

 save net_device_stats statistics */

 store port firmware statistics */

		/* sum to rx_frames_discarded all discraded

		 * packets due to size, ttl0 and checksum

	/* now add FCoE statistics which are collected separately

	 * (both offloaded and non offloaded)

	/* if port stats are requested, add them to the PMF

	 * stats, as anyway they will be accumulated by the

	 * MCP before sent to the switch

	/* Wait for statistics to end [while blocking further requests],

	 * then run supplied function 'safely'.

	/* No need to restart statistics - if they're enabled, the timer

	 * will restart the statistics.

/* bnx2x_dcb.c: QLogic Everest network driver.

 *

 * Copyright 2009-2013 Broadcom Corporation

 * Copyright 2014 QLogic Corporation

 * All rights reserved

 *

 * Unless you and QLogic execute a separate written software license

 * agreement governing use of this software, this software is licensed to you

 * under the terms of the GNU General Public License version 2, available

 * at http://www.gnu.org/licenses/old-licenses/gpl-2.0.html (the "GPL").

 *

 * Notwithstanding the above, under no circumstances may you combine this

 * software in any way with any other QLogic software provided under a

 * license other than the GPL, without QLogic's express prior written

 * consent.

 *

 * Maintained by: Ariel Elior <ariel.elior@qlogic.com>

 * Written by: Dmitry Kravkov

 *

 forward declarations of dcbx related functions */

 helpers: read/write len bytes from addr into buff by REG_RD/REG_WR */

 Tx COS configuration */

		/*

		 * We configure only the pauseable bits (non pauseable aren't

		 * configured at all) it's done to avoid false pauses from

		 * network

	/*

	 * Rx COS configuration

	 * Changing PFC RX configuration .

	 * In RX COS0 will always be configured to lossless and COS1 to lossy

 RX COS0 */

 RX COS1 */

 PG */

 pfc */

 Choose the highest priority */

 Use 0 as the default application priority for all. */

		/* If we have received a non-zero default application

		 * priority, then use that for applications which are

		 * not configured with any priority.

 Clean up old settings of ets on COS */

 maps unmapped priorities to to the same COS as L2 */

 all ones */

 get unmapped priorities by clearing mapped bits */

 find cos for nw prio and extend it with unmapped */

 extend the bitmask with unmapped */

error*/

error*/

		/*

		 * 1. Fills up common PFC structures if required

		 * 2. Configure NIG, MAC and BRB via the elink

 valid COS entries */

 no ETS */

 sanity */

 If we join a group and there is bw_tbl and strict then bw rules */

		/* Do not allow 0-100 configuration

		 * since PBF does not support it

		 * force 1-99 instead

/*

 * In E3B0 the configuration may have more than 2 COS.

 COS is SP */

 COS is BW */

 Configure the ETS in HW */

 save features and flags */

 save features and error */

 Choose the highest priority */

 avoid invalid user-priority */

	/* setup tc must be called under rtnl lock, but we can't take it here

	 * as we are handling an attention on a work queue which must be

	 * flushed at some rtnl-locked contexts (e.g. if down)

			/**

			 * Delete app tlvs from dcbnl before reading new

			 * negotiation results

 Read remote mib if dcbx is in the FW */

 Read neg results if dcbx is in the FW */

 mark DCBX result for PMF migration */

			/*

			 * Add new app tlvs to dcbnl

			/*

			 * reconfigure the netdevice with the results of the new

			 * dcbx negotiation.

			/*

			 * allow other functions to update their netdevices

			 * accordingly

 ets may affect cmng configuration: reinit it in hw */

		/*

		 * Send a notification for the new negotiated parameters

shortcuts*/

 Read the data first */

 FOR IEEE dp->admin_tc_supported_tx_enable */

 For IEEE admin_ets_recommendation_tx_enable */

 For IEEE admin_ets_reco_valid */

		/*For IEEE admin_recommendation_bw_percentage

 Write the data. */

 0 - CEE; 1 - IEEE */

 only PMF can send ADMIN msg to MFW in old MFW versions */

	/* validate:

	 * chip of good for dcbx version,

	 * dcb is wanted

	 * shmem2 contains DCBX support fields

			/* need HW lock to avoid scenario of two drivers

			 * writing in parallel to shmem

 Let HW start negotiation */

			/* release HW lock only after MFW acks that it finished

			 * reading values from shmem

 fills help_data according to pg_info */

shortcut*/

 Set to invalid */

 Only one priority than only one COS */

 There can be only one strict pg */

			/* If we join a group and one is strict

			 * than the bw rules

debug*/

 single priority group */

		/* If there are both pauseable and non-pauseable priorities,

		 * the pauseable priorities go to the first queue and

		 * the non-pauseable priorities go to the second queue.

 Pauseable */

 Non pauseable.*/

			/* If there are only pauseable priorities,

			 * then one/two priorities go to the first queue

			 * and one priority goes to the second queue.

 All priorities except FCOE */

 Only FCOE priority.*/

			/* If there are only non-pauseable priorities,

			 * they will all go to the same queue.

 priority group which is not BW limited (PG#15):*/

			/* If there are both pauseable and non-pauseable

			 * priorities, the pauseable priorities go to the first

			 * queue and the non-pauseable priorities

			 * go to the second queue.

 Pauseable */

 Non pause-able.*/

			/* If there are only pauseable priorities or

			 * only non-pauseable,* the lower priorities go

			 * to the first queue and the higher priorities go

			 * to the second queue.

 Remove priority tested */

			/* Both queues are strict priority,

			 * and that with the highest priority

			 * gets the highest strict priority in the arbiter.

	/* If there are both pauseable and non-pauseable priorities,

	 * the pauseable priorities go to the first queue and

	 * the non-pauseable priorities go to the second queue.

			/* If one PG contains both pauseable and

			 * non-pauseable priorities then ETS is disabled.

 Pauseable */

 Non pauseable. */

 0 is pauseable */

 1 is pauseable */

		/* If there are only pauseable priorities or

		 * only non-pauseable, each PG goes to a queue.

 There can be only one strict pg */

 protect index */

 Entries joined strict priority rules */

 Entries can be joined join BW */

 Joined the entries */

	/* If there are both pauseable and non-pauseable priorities,

	 * the pauseable priorities go to the first queue and the

	 * non-pauseable priorities go to the second queue.

		/* If two BW-limited PG-s were combined to one queue,

		 * the BW is their sum.

		 *

		 * If there are only pauseable priorities or only non-pauseable,

		 * and there are both BW-limited and non-BW-limited PG-s,

		 * the BW-limited PG/s go to one queue and the non-BW-limited

		 * PG/s go to the second queue.

		 *

		 * If there are only pauseable priorities or only non-pauseable

		 * and all are BW limited, then	two priorities go to the first

		 * queue and one priority goes to the second queue.

		 *

		 * We will join this two cases:

		 * if one is BW limited it will go to the second queue

		 * otherwise the last priority will get it

					/* last entry will be handled separately

					 * If no priority is strict than last

					 * entry goes to last queue.

				/* If we join a group and one is strict

				 * than the bw rules

 default E2 settings */

 last entry needed put all the entries left */

 Fill BW entry */

	/*

	 * if the number of requested PG-s in CEE is greater than 3

	 * then the results are not determined since this is a violation

	 * of the standard.

 Fill BW entry */

			/*

			 * If there are still VOQ-s which have no associated PG,

			 * then associate these VOQ-s to PG15. These PG-s will

			 * be used for SP between priorities on PG15.

 the entry will represent the number of COSes used */

 Validate the pg value */

 defaults */

 E2 + E3A0 */

 sanity */

 to disable DCB - the structure must be zeroed */

shortcut*/

 Fw version should be incremented each update */

 Fill priority parameters */

		/* Fill COS parameters based on COS calculated to

 we never want the FW to add a 0 vlan tag */

	/* if we need to synchronize DCBX result from prev PMF

	 * read it from shmem and update bp and netdev accordingly

 Read neg results if dcbx is in the FW */

		/*

		 * Add new app tlvs to dcbnl

		/*

		 * Send a notification for the new negotiated parameters

		/*

		 * reconfigure the netdevice with the results of the new

		 * dcbx negotiation.

 DCB netlink */

	/* validate dcbnl call that may change HW state:

	 * DCB is on and DCBX mode was SUCCESSFULLY set by the user.

 Fail to set state to "enabled" if dcbx is disabled in nvram */

 first the HW mac address */

 second SAN address */

	/**

	 * bw_pct ignored -	band-width percentage devision between user

	 *			priorities within the same group is not

	 *			standard and hence not supported

	 *

	 * prio_type ignored -	priority levels within the same group are not

	 *			standard and hence are not supported. According

	 *			to the standard pgid 15 is dedicated to strict

	 *			priority traffic (on the port level).

	 *

	 * up_map ignored

	/**

	 * bw_pct ignored -	band-width percentage devision between user

	 *			priorities within the same group is not

	 *			standard and hence not supported

	 *

	 * prio_type ignored -	priority levels within the same group are not

	 *			standard and hence are not supported. According

	 *			to the standard pgid 15 is dedicated to strict

	 *			priority traffic (on the port level).

	 *

	 * up_map ignored

 8 priorities for PGs */

 8 priorities for PFC */

 never gets here */

 iterate over the app entries looking for idtype and idval */

 if found overwrite up */

 not found use first-free */

 app table is full */

 up configured, if not 0 make sure feature is enabled */

 verify idtype */

 set dcbx mode */

 ignore the 'advertise' flag */

 ignore enable, always enabled */

 BCM_DCBNL */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Broadcom GENET MDIO routines

 *

 * Copyright (c) 2014-2017 Broadcom

 speed */

 duplex */

 pause capability defaults to Symmetric */

 Manual override */

	/* Program UMAC and RGMII block based on established

	 * link speed, duplex, and pause. The speed set in

	 * umac->cmd tell RGMII block which clock to use for

	 * transmit -- 25MHz(100Mbps) or 125MHz(1Gbps).

	 * Receive clock is provided by the PHY.

/* setup netdev link state when PHY link status change and

 * update UMAC and RGMII block when link up

 EXT_GPHY_CTRL is only valid for GENETv4 and onward */

 Speed settings are set in bcmgenet_mii_setup() */

		/* Irrespective of the actually configured PHY speed (100 or

		 * 1000) GENETv4 only has an internal GPHY so we will just end

		 * up masking the Gigabit features from what we support, not

		 * switching to the EPHY

		/* of_mdiobus_register took care of reading the 'max-speed'

		 * PHY property for us, effectively limiting the PHY supported

		 * capabilities, use that knowledge to also configure the

		 * Reverse MII interface correctly.

		/* RGMII_NO_ID: TXC transitions at the same time as TXD

		 *		(requires PCB or receiver-side delay)

		 *

		 * ID is implicitly disabled for 100Mbps (RG)MII operation.

 RGMII_TXID:	Add 2ns delay on TXC (90 degree shift) */

	/* This is an external PHY (xMII), so we need to enable the RGMII

	 * block for the interface to work

 Communicate the integrated PHY revision */

	/* This is an ugly quirk but we have not been correctly interpreting

	 * the phy_interface values and we have done that across different

	 * drivers, so at least we are consistent in our mistakes.

	 *

	 * When the Generic PHY driver is in use either the PHY has been

	 * strapped or programmed correctly by the boot loader so we should

	 * stick to our incorrect interpretation since we have validated it.

	 *

	 * Now when a dedicated PHY driver is in use, we need to reverse the

	 * meaning of the phy_interface_mode values to something that the PHY

	 * driver will interpret and act on such that we have two mistakes

	 * canceling themselves so to speak. We only do this for the two

	 * modes that GENET driver officially supports on Broadcom STB chips:

	 * PHY_INTERFACE_MODE_RGMII and PHY_INTERFACE_MODE_RGMII_TXID. Other

	 * modes are not *officially* supported with the boot loader and the

	 * scripted environment generating Device Tree blobs for those

	 * platforms.

	 *

	 * Note that internal PHY, MoCA and fixed-link configurations are not

	 * affected because they use different phy_interface_t values or the

	 * Generic PHY driver.

	/* Configure port multiplexer based on what the probed PHY device since

	 * reading the 'max-speed' property determines the maximum supported

	 * PHY speed which is needed for bcmgenet_mii_config() to configure

	 * things appropriately.

	/* The internal PHY has its link interrupts routed to the

	 * Ethernet MAC ISRs. On GENETv5 there is a hardware issue

	 * that prevents the signaling of link UP interrupts when

	 * the link operates at 10Mbps, so fallback to polling for

	 * those versions of GENET.

		/*

		 * Internal or external PHY with MDIO access

	/* Unimac MDIO bus controller starts at UniMAC offset + MDIO_CMD

	 * and is 2 * 32-bits word long, 8 bytes total.

 Retain this platform_device pointer for later cleanup */

	/* We need to specifically look up whether this PHY interface is

	 * internal or not *before* we even try to probe the PHY driver

	 * over MDIO as we may have shut down the internal PHY for power

	 * saving purposes.

 Fetch the PHY phandle */

	/* In the case of a fixed PHY, the DT node associated

	 * to the PHY is the Ethernet MAC DT node.

 Get the link mode */

 Make sure we initialize MoCA PHYs with a link down */

		/*

		 * Internal or external PHY with MDIO access

		/*

		 * MoCA port or no MDIO access.

		 * Use fixed PHY to represent the link layer.

 Make sure we initialize MoCA PHYs with a link down */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Broadcom GENET (Gigabit Ethernet) controller driver

 *

 * Copyright (c) 2014-2020 Broadcom

 Maximum number of hardware queues, downsized if needed */

 Default highest priority queue for multi queue support */

 Tx/Rx DMA register offset, skip 256 descriptors */

 Forward declarations */

	/* MIPS chips strapped for BE will automagically configure the

	 * peripheral registers for CPU-native byte order.

	/* Register writes to GISB bus can take couple hundred nanoseconds

	 * and are done for each packet, save these expensive writes unless

	 * the platform is explicitly configured for 64-bits/LPAE.

 Combined address + length/status setter */

	/* Register writes to GISB bus can take couple hundred nanoseconds

	 * and are done for each packet, save these expensive writes unless

	 * the platform is explicitly configured for 64-bits/LPAE.

/* These macros are defined to deal with register map change

 * between GENET1.1 and GENET2. Only those currently being used

 * by driver are defined.

 RX/TX DMA register accessors */

 Set at runtime once bcmgenet version is known */

/* RDMA/TDMA ring registers and accessors

 * we merge the common fields and just prefix with T/D the registers

 * having different meaning depending on the direction

/* GENET v4 supports 40-bits pointer addressing

 * for obvious reasons the LO and HI word parts

 * are contiguous, but this offsets the other

 * registers.

 Set at runtime once GENET version is known */

 Specify IP Ether Type */

 Only supports 20 byte IPv4 header */

		/* Ring 0 flows can be handled by the default Descriptor Ring

		 * We'll map them to ring 0, but don't enable the filter

 Other Rx rings are direct mapped here */

/* bcmgenet_hfb_clear

 *

 * Clear Hardware Filter Block and disable all filtering.

 Turn on the clock */

 Turn off the clock */

 Make sure we reflect the value of CRC_CMD_FWD */

	/* Base system clock is 125Mhz, DMA timeout is this reference clock

	 * divided by 1024, which yields roughly 8.192us, our maximum value

	 * has to fit in the DMA_TIMEOUT_MASK (16 bits)

	/* GENET TDMA hardware does not support a configurable timeout, but will

	 * always generate an interrupt either after MBDONE packets have been

	 * transmitted, or when the ring is empty.

	/* Program all TX queues with the same values, as there is no

	 * ethtool knob to do coalescing on a per-queue basis

 report active state when link is up */

 otherwise report stored settings */

 standard ethtool support functions. */

 reg offset from UMAC base for misc counters */

/* There is a 0xC gap between the end of RX and beginning of TX stats and then

 * between the end of TX stats and the beginning of the RX RUNT

/* Hardware counters must be kept in sync because the order/offset

 * is important here (order in structure declaration = order in hardware)

 general stats */

 UniMAC RSV counters */

 UniMAC TSV counters */

 UniMAC RUNT counters */

 Misc UniMAC counters */

 Per TX queues */

 clear if overflowed */

 clear if overflowed */

 clear if overflowed */

 Reset Offset */

 clear if overflowed */

 Enable EEE and switch to a 27Mhz clock automatically */

 Do the same for thing for RBUF */

 don't allow mask which isn't valid */

 don't allow mask which isn't valid */

 don't allow mask which isn't valid */

 don't allow mask which isn't valid */

 standard ethtool support functions. */

 Power down the unimac, based on mode. */

 Power down LED */

 enable APD */

 Advancing local write pointer */

 Rewinding local write pointer */

/* Simple helper to free a transmit control block's resources

 * Returns an skb when the last transmit control block associated with the

 * skb is freed.  The skb should be freed by the caller if necessary.

 Simple helper to free a receive control block's resources */

 Unlocked version of the reclaim routine */

 Clear status before servicing to reduce spurious interrupts */

 Compute how many buffers are transmitted since last xmit call */

 Reclaim transmitted buffers */

/* Reallocate the SKB to put enough headroom in front of it and insert

 * the transmit checksum offsets in the descriptors

		/* If 64 byte status block enabled, must make sure skb has

		 * enough headroom for us to insert 64B status block.

 don't use UDP flag */

 Set the special UDP flag for UDP */

	/* Mapping strategy:

	 * queue_mapping = 0, unclassified, packet xmited through ring16

	 * queue_mapping = 1, goes to ring 0. (highest priority queue

	 * queue_mapping = 2, goes to ring 1.

	 * queue_mapping = 3, goes to ring 2.

	 * queue_mapping = 4, goes to ring 3.

	/* Retain how many bytes will be sent on the wire, without TSB inserted

	 * by transmit checksum offload

 add the Transmit Status Block */

 Transmit single SKB or head of fragment list */

 xmit fragment */

		/* Note: if we ever change from DMA_TX_APPEND_CRC below we

		 * will need to restore software padding of "runt" packets

 Decrement total BD count and advance our write pointer */

 Packets are ready, update producer index */

 Back up for failed control block mapping */

 Unmap successfully mapped control blocks */

 Allocate a new Rx skb */

 DMA-map the new Rx skb */

 Grab the current Rx skb from the ring and DMA-unmap it */

 Put the new Rx skb on the ring */

 Return the current Rx skb to caller */

/* bcmgenet_desc_rx - descriptor based rx process.

 * this could be called from bottom half, or from NAPI polling method.

 Clear status before servicing to reduce spurious interrupts */

 Clear HW register when we reach 75% of maximum 0xFFFF */

		/* DMA flags and length are still valid no matter how

		 * we got the Receive Status Vector (64B RSB or register)

 report errors */

 error packet */

 remove RSB and hardware 2bytes added for IP alignment */

Finish setting up the received SKB and send it to the kernel*/

 Notify kernel */

 Rx NAPI polling method */

 Assign skb to RX DMA descriptor. */

 loop here for each buffer needing assign */

	/* UniMAC stops on a packet boundary, wait for a full-size packet

	 * to be processed

 7358a0/7552a0: bad default in RBUF_FLUSH_CTRL.umac_sw_rst */

 issue soft reset and disable MAC while updating its registers */

 Mask all interrupts.*/

	/* Monitor cable plug/unplugged event for internal PHY, external PHY

	 * and MoCA PHY

 clear tx/rx counter */

 init tx registers, enable TSB */

 init rx registers, enable ip header optimization and RSB */

 enable rx checksumming */

	/* If UniMAC forwards CRC, we need to skip over it to get

	 * a valid CHK bit to be set in the per-packet status word

 Configure backpressure vectors for MoCA */

 bp_mask: back pressure mask */

 Enable MDIO interrupts on GENET v3+ */

 If DIM was enabled, re-apply default parameters */

 Initialize a Tx ring along with corresponding hardware registers */

 Set flow period for ring != 16 */

 Disable rate control for now */

 Set start and end address, read and write pointers */

 Initialize Tx NAPI */

 Initialize a RDMA ring */

 Initialize Rx NAPI */

 Set start and end address, read and write pointers */

/* Initialize Tx queues

 *

 * Queues 0-3 are priority-based, each one has 32 descriptors,

 * with queue 0 being the highest priority queue.

 *

 * Queue 16 is the default Tx queue with

 * GENET_Q16_TX_BD_CNT = 256 - 4 * 32 = 128 descriptors.

 *

 * The transmit control block pool is then partitioned as follows:

 * - Tx queue 0 uses tx_cbs[0..31]

 * - Tx queue 1 uses tx_cbs[32..63]

 * - Tx queue 2 uses tx_cbs[64..95]

 * - Tx queue 3 uses tx_cbs[96..127]

 * - Tx queue 16 uses tx_cbs[128..255]

 Enable strict priority arbiter mode */

 Initialize Tx priority queues */

 Initialize Tx default queue 16 */

 Set Tx queue priorities */

 Enable Tx queues */

 Enable Tx DMA */

/* Initialize Rx queues

 *

 * Queues 0-15 are priority queues. Hardware Filtering Block (HFB) can be

 * used to direct traffic to these queues.

 *

 * Queue 16 is the default Rx queue with GENET_Q16_RX_BD_CNT descriptors.

 Initialize Rx priority queues */

 Initialize Rx default queue 16 */

 Enable rings */

 Configure ring as descriptor ring and re-enable DMA if enabled */

 Disable TDMA to stop add more frames in TX DMA */

 Check TDMA status register to confirm TDMA is disabled */

 Wait 10ms for packet drain in both tx and rx dma */

 Disable RDMA */

 Check RDMA status register to confirm RDMA is disabled */

 init_edma: Initialize DMA control register */

 Initialize common Rx ring structures */

 Initialize common TX ring structures */

 Init rDma */

 Initialize Rx queues */

 Init tDma */

 Initialize Tx queues */

 Interrupt bottom half */

 Link UP/DOWN event */

 bcmgenet_isr1: handle Rx and Tx priority queues */

 Read irq status */

 clear interrupts */

 Check Rx priority queue interrupts */

 Check Tx priority queue interrupts */

 bcmgenet_isr0: handle Rx and Tx default queues + other stuff */

 Read irq status */

 clear interrupts */

 all other interested interrupts handled in bottom half */

 Save irq status for bottom-half processing. */

 Acknowledge the interrupt */

 Invoke the main RX/TX interrupt handler */

 And the interrupt handler for RX/TX priority queues */

 Returns a reusable dma control register value */

 disable DMA */

 Start the network engine */

 Monitor link interrupts now */

 Turn on the clock */

	/* If this is an internal GPHY, power it back on now, before UniMAC is

	 * brought out of reset as absolutely no UniMAC activity is allowed

 take MAC out of reset */

	/* Apply features again in case we changed them while interface was

	 * down

 Disable RX/TX DMA and flush TX queues */

 Reinitialize TDMA and RDMA and SW housekeeping */

 Always enable ring 16 - descriptor ring */

 HFB init */

 Disable MAC receive */

 Disable MAC transmit. TX DMA disabled must be done before this */

	/* Wait for pending work items to complete. Since interrupts are

	 * disabled no new work will be scheduled.

 tx reclaim */

 Really kill the PHY state machine and disconnect from it */

 Re-enable TX interrupts if disabled */

 Number of filters needed */

	/*

	 * Turn on promicuous mode for three scenarios

	 * 1. IFF_PROMISC flag is set

	 * 2. IFF_ALLMULTI flag is set

	 * 3. The number of filters needed exceeds the number filters

	 *    supported by the hardware.

 update MDF filter */

 Broadcast */

 my own address.*/

 Unicast */

 Multicast */

 Enable filters */

 Set the hardware MAC address. */

	/* Setting the MAC address at the hardware level is not possible

	 * without disabling the UniMAC RX/TX enable bits.

 Array of GENET hardware parameters/characteristics */

 Infer hardware parameters from the detected GENET version */

 enum genet_version starts at 1 */

 Read GENET HW version */

 Print the GENET core version */

	/* Store the integrated PHY revision for the MDIO probing function

	 * to pass this information to the PHY driver. The PHY driver expects

	 * to find the PHY major revision in bits 15:8 while the GENET register

	 * stores that information in bits 7:0, account for that.

	 *

	 * On newer chips, starting with PHY revision G0, a new scheme is

	 * deployed similar to the Starfighter 2 switch with GPHY major

	 * revision in bits 15:8 and patch level in bits 7:0. Major revision 0

	 * is reserved as well as special value 0x01ff, we have a small

	 * heuristic to check for the new GPHY revision and re-arrange things

	 * so the GPHY driver is happy.

		/* The EPHY revision should come from the MDIO registers of

		 * the PHY not from GENET.

 This is reserved so should require special treatment */

 This is the good old scheme, just GPHY major, no minor nor patch */

 This is the new scheme, GPHY major rolls over with 0x10 = rev G0 */

 Up to GENET_MAX_MQ_CNT + 1 TX queues and RX queues */

 Set default pause parameters */

 Set default features */

 Request the WOL interrupt and advertise suspend if available */

	/* Set the needed headroom to account for any possible

	 * features enabling/disabling at runtime

 Mii wait queue */

 Always use RX_BUF_LENGTH (2KB) buffer for all chips */

	/* If this is an internal GPHY, power it on now, before UniMAC is

	 * brought out of reset as absolutely no UniMAC activity is allowed

	/* setup number of real queues  + 1 (GENET_V1 has 0 hardware queues

	 * just the ring 16 descriptor based TX

 Set default coalescing parameters */

 libphy will determine the link state */

 Turn off the main clock, WOL clock is handled separately */

 Turn on the clock */

		/* Account for Wake-on-LAN events and clear those events

		 * (Some devices need more time between enabling the clocks

		 *  and the interrupt register reflecting the wake event so

		 *  read the register twice)

 From WOL-enabled suspend, switch to regular clock */

	/* If this is an internal GPHY, power it back on now, before UniMAC is

	 * brought out of reset as absolutely no UniMAC activity is allowed

 Speed settings must be restored */

 Restore enabled features */

 Restore hardware filters */

 Disable RX/TX DMA and flush TX queues */

 Reinitialize TDMA and RDMA and SW housekeeping */

 Always enable ring 16 - descriptor ring */

 Disable filtering */

 Prepare the device for Wake-on-LAN and switch to the slow clock */

 Let the framework handle resumption and leave the clocks on */

 Turn off the clocks */

 CONFIG_PM_SLEEP */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Broadcom GENET (Gigabit Ethernet) Wake-on-LAN support

 *

 * Copyright (c) 2014-2020 Broadcom

/* ethtool function - get WOL (Wake on LAN) settings, Only Magic Packet

 * Detection is supported through ethtool

/* ethtool function - set WOL (Wake on LAN) settings.

 * Only for magic packet detection mode.

 Flag the device and relevant IRQ as wakeup capable */

 Avoid unbalanced enable_irq_wake calls */

 Avoid unbalanced disable_irq_wake calls */

 Can't suspend with WoL if MAC is still in reset */

 disable RX */

 Do not leave UniMAC in MPD mode only */

 Enable CRC forward */

 Receiver must be enabled for WOL MP detection */

 failed to suspend so skip the rest */

 Disable Magic Packet Detection */

 already reset so skip the rest */

 Disable WAKE_FILTER Detection */

 already reset so skip the rest */

 Disable CRC Forward */

 starfire.c: Linux device driver for the Adaptec Starfire network adapter. */

/*

	Written 1998-2000 by Donald Becker.



	Current maintainer is Ion Badulescu <ionut ta badula tod org>. Please

	send all bug reports to me, and not to Donald Becker, as this code

	has been heavily modified from Donald's original version.



	This software may be used and distributed according to the terms of

	the GNU General Public License (GPL), incorporated herein by reference.

	Drivers based on or derived from this code fall under the GPL and must

	retain the authorship, copyright and license notice.  This file is not

	a complete program and may only be used when the entire operating

	system is licensed under the GPL.



	The information below comes from Donald Becker's original driver:



	The author may be reached as becker@scyld.com, or C/O

	Scyld Computing Corporation

	410 Severn Ave., Suite 210

	Annapolis MD 21403



	Support and updates available at

	http://www.scyld.com/network/starfire.html

	[link no longer provides useful info -jgarzik]



 Processor type for cache alignment. */

/*

 * The current frame processor firmware fails to checksum a fragment

 * of length 1. If and when this is fixed, the #define below can be removed.

/*

 * If using the broken firmware, data must be padded to the next 32-bit boundary.

/*

 * Define this if using the driver with the zero-copy patch

/* The user-configurable values.

 Used for tuning interrupt latency vs. overhead. */

 1 normal messages, 0 quiet .. 7 verbose. */

/* Maximum number of multicast addresses to filter (vs. rx-all-multicast).

 Whether to do TCP/UDP checksums in hardware */

 Size of each temporary Rx buffer.*/

/*

 * Set the copy breakpoint for the copy-only-tiny-frames scheme.

 * Setting to > 1518 effectively disables this feature.

 *

 * NOTE:

 * The ia64 doesn't allow for unaligned loads even of integers being

 * misaligned on a 2 byte boundary. Thus always force copying of

 * packets as the starfire doesn't allow for misaligned DMAs ;-(

 * 23/10/2000 - Jes

 *

 * The Alpha and the Sparc don't like unaligned loads, either. On Sparc64,

 * at least, having unaligned frames leads to a rather serious performance

 * penalty. -Ion

 = 0 */;

 PCI DMA burst size -- on sparc64 we want to force it to 64 bytes, on the others the default of 128 is fine. */

 Operational parameters that are set at compile time. */

/* The "native" ring sizes are either 256 or 2048.

   However in some modes a descriptor may be marked to wrap the ring earlier.

 The completion queues are fixed at 1024 entries i.e. 4K or 8KB. */

 All queues must be aligned on a 256-byte boundary */

 Operational parameters that usually are not changed. */

 Time in jiffies before concluding the transmitter is hung. */

 64-bit dma_addr_t */

 This chip uses 64 bit addresses. */

 32-bit dma_addr_t */

 Firmware names */

/*

				Theory of Operation



I. Board Compatibility



This driver is for the Adaptec 6915 "Starfire" 64 bit PCI Ethernet adapter.



II. Board-specific settings



III. Driver operation



IIIa. Ring buffers



The Starfire hardware uses multiple fixed-size descriptor queues/rings.  The

ring sizes are set fixed by the hardware, but may optionally be wrapped

earlier by the END bit in the descriptor.

This driver uses that hardware queue size for the Rx ring, where a large

number of entries has no ill effect beyond increases the potential backlog.

The Tx ring is wrapped with the END bit, since a large hardware Tx queue

disables the queue layer priority ordering and we have no mechanism to

utilize the hardware two-level priority queue.  When modifying the

RX/TX_RING_SIZE pay close attention to page sizes and the ring-empty warning

levels.



IIIb/c. Transmit/Receive Structure



See the Adaptec manual for the many possible structures, and options for

each structure.  There are far too many to document all of them here.



For transmit this driver uses type 0/1 transmit descriptors (depending

on the 32/64 bitness of the architecture), and relies on automatic

minimum-length padding.  It does not use the completion queue

consumer index, but instead checks for non-zero status entries.



For receive this driver uses type 2/3 receive descriptors.  The driver

allocates full frame size skbuffs for the Rx ring buffers, so all frames

should fit in a single descriptor.  The driver does not use the completion

queue consumer index, but instead checks for non-zero status entries.



When an incoming frame is less than RX_COPYBREAK bytes long, a fresh skbuff

is allocated and the frame is copied to the new skbuff.  When the incoming

frame is larger, the skbuff is passed directly up the protocol stack.

Buffers consumed this way are replaced by newly allocated skbuffs in a later

phase of receive.



A notable aspect of operation is that unaligned buffers are not permitted by

the Starfire hardware.  Thus the IP header at offset 14 in an ethernet frame

isn't longword aligned, which may cause problems on some machine

e.g. Alphas and IA64. For these architectures, the driver is forced to copy

the frame into a new skbuff unconditionally. Copied frames are put into the

skbuff at an offset of "+2", thus 16-byte aligning the IP header.



IIId. Synchronization



The driver runs as two independent, single-threaded flows of control.  One

is the send-packet routine, which enforces single-threaded use by the

dev->tbusy flag.  The other thread is the interrupt handler, which is single

threaded by the hardware and interrupt handling software.



The send packet thread has partial control over the Tx ring and the netif_queue

status. If the number of free Tx slots in the ring falls below a certain number

(currently hardcoded to 4), it signals the upper layer to stop the queue.



The interrupt handler has exclusive control over the Rx ring and records stats

from the Tx ring.  After reaping the stats, it marks the Tx queue entry as

empty by incrementing the dirty_tx mark. Iff the netif_queue is stopped and the

number of free Tx slow is above the threshold, it signals the upper layer to

restart the queue.



IV. Notes



IVb. References



The Adaptec Starfire manuals, available only from Adaptec.

http://www.scyld.com/expert/100mbps.html

http://www.scyld.com/expert/NWay.html



IVc. Errata



- StopOnPerr is broken, don't enable

- Hardware ethernet padding exposes random data, perform software padding

  instead (unverified -- works correctly for all the hardware I have)



 A chip capabilities table, matching the CH_xxx entries in xxx_pci_tbl[] above. */

/* Offsets to the device registers.

   Unlike software-only systems, device drivers interact with complex hardware.

   It's not useful to define symbolic names for every register bit in the

   device.  The name can only partially document the semantics and make

   the driver longer and more difficult to read.

   In general, only the important configuration values or bits changed

   multiple times should be defined symbolically.

 Low and High priority. */

 64 bit address extension. */

/*

 * Bits in the interrupt status/mask registers.

 * Warning: setting Intr[Ab]NormalSummary in the IntrEnable register

 * enables all the interrupt sources that are or'ed into those status bits.

 not quite bits */

 Bits in the RxFilterMode register. */

 Bits in the TxMode register */

 Bits in the TxDescCtrl register. */

 Bits in the RxDescQCtrl register. */

 Bits in the RxDMACtrl register. */

 Bits in the RxCompletionAddr register */

 Bits in the TxCompletionAddr register */

 Bits in the GenCtrl register */

 Bits in the IntrTimerCtrl register */

 The Rx and Tx buffer descriptors. */

 Completion queue entry. */

 Low 16 bits is length. */

 Low 16 bits is length. */

 Low 16 bits is length. */

 Partial checksum */

 Low 16 bits is length. */

 partial checksum */

 XXX: this is ugly and I'm not sure it's worth the trouble -Ion */

 not VLAN_SUPPORT */

 not VLAN_SUPPORT */

 Type 1 Tx descriptor. */

 Upper bits are status, lower 16 length. */

 Type 2 Tx descriptor. */

 Upper bits are status, lower 16 length. */

 not ADDR_64BITS */

 not ADDR_64BITS */

 timestamp, index. */

 interrupt status */

 Descriptor rings first for alignment. */

 The addresses of rx/tx-in-place skbuffs. */

 Pointers to completion queues (full pages). */

 Frequently used values: keep some adjacent for cache effect. */

 Producer/consumer ring indices */

 Based on MTU+slack. */

 These values keep track of the transceiver/media in use. */

 Set if speed == 100MBit. */

 MII transceiver section. */

 MII lib hooks/info */

 MII device addresses. */

 MII device addresses. */

 VLAN_SUPPORT */

 enable MWI -- it vastly improves Rx performance on sparc64 */

 Starfire can do TCP/UDP checksumming */

 ZEROCOPY */

 VLAN_RX_KILL_VID */

 ADDR_64BITS */

 Serial EEPROM reads are hidden by the hardware. */

 Dump the EEPROM contents during development. */

 Issue soft reset */

 Reset the chip to erase previous misconfiguration. */

 wait a little longer */

 timer resolution is 128 * 0.8us */

 there can be only one PHY on-board */

 Read the MII Management Data I/O (MDIO) interfaces. */

 ??? Should we add a busy-wait here? */

 The busy-wait will occur before a read. */

 Do we ever need to reset the chip??? */

 Disable the Rx and Tx, and reset the chip. */

 Allocate the various queues. */

 Start with no carrier, it gets adjusted later */

 Set the size of the Rx buffers. */

 Set up the Rx DMA controller. */

 Set Tx descriptor */

 Fill both the Tx SA register and the Rx perfect filter. */

	/* The first entry is special because it bypasses the VLAN filter.

 Initialize other registers. */

 Configure the PCI bus bursts and FIFO thresholds. */

 modified when link is up. */

 Enable GPIO interrupts on link change */

 Set the interrupt mask */

 Enable PCI interrupts. */

 Set VLAN type to 802.1q */

 VLAN_SUPPORT */

 Load Rx/Tx firmware into the frame processors */

 Enable the Rx and Tx units, and the Rx/Tx frame processors. */

 Enable the Rx and Tx units only. */

 do nothing */;

 Perhaps we should reinitialize the hardware here. */

	/*

	 * Stop and restart the interface.

	 * Cheat and increase the debug level temporarily.

 Trigger an immediate transmit demand. */

 prevent tx timeout */

 Initialize the Rx and Tx rings, along with various 'dev' bits. */

 Fill in the Rx buffers.  Handle allocation failure gracefully. */

 Grrr, we cannot offset to correctly align the IP header. */

 Clear the remainder of the Rx buffer ring. */

 Mark the last entry as wrapping the ring. */

 Clear the completion rings. */

	/*

	 * be cautious here, wrapping the queue has weird semantics

	 * and we may not have enough slots even when it seems we do.

 ZEROCOPY && HAS_BROKEN_FIRMWARE */

 scavenge the tx descriptors twice per TX_RING_SIZE */

 Non-x86: explicitly flush descriptor cache lines here. */

	/* Ensure all descriptors are written back before the transmit is

 Update the producer index. */

 4 is arbitrary, but should be ok */

/* The interrupt handler does all of the Rx thread work and cleans up

 flush PCI posting buffers */

 Paranoia check */

		/* Scavenge the skbuff list based on the Tx-done queue.

		   There are redundant checks here that may be cleaned up

 The ring is no longer full, wake the queue. */

 Stats overflow */

 Media change interrupt. */

 Abnormal error summary/uncommon events handlers. */

/*

 * This routine is logically part of the interrupt/poll handler, but separated

 * for clarity and better register allocation.

 If EOP is set on the next entry, it's a new packet. Send it up. */

 There was an error. */

 out of rx quota */

 Implicitly Truncate */

		/* Check if the packet is long enough to accept without copying

 16 byte align the IP header */

 Remove after testing. */

 You will want this info for the initial debug. */

		/*

		 * This feature doesn't seem to be working, at least

		 * with the two firmware versions I have. If the GFP sees

		 * an IP fragment, it either ignores it completely, or reports

		 * "bad checksum" on it.

		 *

		 * Maybe I missed something -- corrections are welcome.

		 * Until then, the printk stays. :-) -Ion

 VLAN_SUPPORT */

 out of rx quota */

 Restart Rx engine if stopped. */

 Refill the Rx ring buffers. */

 Better luck next round. */

 reset status first */

 link is up */

 autonegotiation is enabled */

 autonegotiation is disabled */

 duplex setting */

 Came close to underrunning the Tx FIFO, increase threshold. */

 This adapter architecture needs no SMP locks. */

 The chip only need report frame silently dropped. */

 VLAN_SUPPORT */

 VLAN_SUPPORT */

 Set promiscuous. */

 Too many to match, or accept all multicasts. */

 Use the 16 element perfect filter, skip first two entries. */

 Must use a multicast hash table. */

 Multicast hash filter */

			/* The chip uses the upper 9 CRC bits

 Clear the perfect filter list, skip first two entries. */

 Disable interrupts by clearing the interrupt mask. */

 Stop the chip's Tx and Rx processes. */

 TX_RING_SIZE is huge! */; i++)

 RX_RING_SIZE */; i++) {

 Free all the skbuffs in the Rx queue. */

 An invalid address. */

 XXX: add wakeup code -- requires firmware for MagicPacket */

 go to sleep in D3 mode */

 Will also free np!! */

 when a module, this is printed whether or not devices are found in probe */

/*

 *   Copyright (c) 2011, 2012, Qualcomm Atheros Communications Inc.

 *   Copyright (c) 2014, I2SE GmbH

 *

 *   Permission to use, copy, modify, and/or distribute this software

 *   for any purpose with or without fee is hereby granted, provided

 *   that the above copyright notice and this permission notice appear

 *   in all copies.

 *

 *   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL

 *   WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED

 *   WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL

 *   THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR

 *   CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM

 *   LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,

 *   NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN

 *   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

/*   This module implements the Qualcomm Atheros SPI protocol for

 *   kernel-based SPI device; it is essentially an Ethernet-to-SPI

 *   serial converter;

   Modules parameters     */

		/* This could only happen by interferences on the SPI line.

		 * So retry later ...

 remove the skb from the queue */

		/* XXX After inconsistent lock states netif_tx_lock()

		 * has been replaced by netif_tx_lock_bh() and so on.

 Allocate rx SKB if we don't have one available. */

 Read the packet size. */

		/* This could only happen by interferences on the SPI line.

		 * So retry later ...

/*   Check that tx ring stores only so much bytes

 *   that fit into the internal QCA buffer.

/*   Flush the tx ring. This function is only safe to

 *   call from the qcaspi_spi_thread.

	/* XXX After inconsistent lock states netif_tx_lock()

	 * has been replaced by netif_tx_lock_bh() and so on.

		/* Read signature twice, if not valid

		 * go back to unknown state.

 ensure that the WRBUF is empty */

 Check signature twice, if not valid go to unknown state. */

 don't reset right away */

 Read signature, if not valid stay in unknown state */

 TODO: use GPIO to reset QCA7000 in legacy mode*/

 reset did not seem to take place, try again */

 not synced. */

 restart sync */

 restart sync */

			/* can only handle other interrupts

			 * if sync has occurred

 SPI thread takes care of TX queue */

 Trigger tx queue flush and QCA7000 reset */

 MTU range: 46 - 1500 */

 sentinel */ }

 sentinel */ }

/*

 *   Copyright (c) 2011, 2012, Qualcomm Atheros Communications Inc.

 *   Copyright (c) 2017, I2SE GmbH

 *

 *   Permission to use, copy, modify, and/or distribute this software

 *   for any purpose with or without fee is hereby granted, provided

 *   that the above copyright notice and this permission notice appear

 *   in all copies.

 *

 *   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL

 *   WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED

 *   WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL

 *   THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR

 *   CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM

 *   LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,

 *   NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN

 *   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

/*   This module implements the Qualcomm Atheros UART protocol for

 *   kernel-based UART device; it is essentially an Ethernet-to-UART

 *   serial converter;

 transmit lock */

 Flushes transmit buffer   */

 pointer to next XMIT byte */

 bytes left in XMIT queue  */

 Write out any remaining transmit buffer. Scheduled when tty is writable */

 First make sure we're connected. */

		/* Now serial buffer is almost free & we can start

		 * transmission of another packet

/* Called by the driver when there's room for more data.

 * Schedule the transmit.

 Finish setting up the device info. */

 MTU range: 46 - 1500 */

 Flush any pending characters in the driver. */

/*

 *

 *   Copyright (c) 2011, 2012, Qualcomm Atheros Communications Inc.

 *   Copyright (c) 2014, I2SE GmbH

 *

 *   Permission to use, copy, modify, and/or distribute this software

 *   for any purpose with or without fee is hereby granted, provided

 *   that the above copyright notice and this permission notice appear

 *   in all copies.

 *

 *   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL

 *   WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED

 *   WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL

 *   THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR

 *   CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM

 *   LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,

 *   NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN

 *   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

 *

/*   This module implements the Qualcomm Atheros SPI protocol for

 *   kernel-based SPI device.

/*

 *   Copyright (c) 2011, 2012, Atheros Communications Inc.

 *   Copyright (c) 2014, I2SE GmbH

 *

 *   Permission to use, copy, modify, and/or distribute this software

 *   for any purpose with or without fee is hereby granted, provided

 *   that the above copyright notice and this permission notice appear

 *   in all copies.

 *

 *   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL

 *   WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED

 *   WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL

 *   THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR

 *   CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM

 *   LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,

 *   NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN

 *   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

/*   Atheros ethernet framing. Every Ethernet frame is surrounded

 *   by an atheros frame while transmitted over a serial channel;

/*   Gather received bytes and try to extract a full ethernet frame by

 *   following a simple state machine.

 *

 * Return:   QCAFRM_GATHER       No ethernet frame fully received yet.

 *           QCAFRM_NOHEAD       Header expected but not found.

 *           QCAFRM_INVLEN       Atheros frame length is invalid

 *           QCAFRM_NOTAIL       Footer expected but not found.

 *           > 0                 Number of byte in the fully received

 *                               Ethernet frame

 by default, just go to next state */

 first two bytes of length must be 0 */

 4 bytes header pattern */

 2 bytes length. */

 Borrow offset field to hold length for now. */

 Remaining number of bytes. */

 Receiving Ethernet frame itself. */

 Frame is fully received. */

/*

 *   Copyright (c) 2011, 2012, Qualcomm Atheros Communications Inc.

 *   Copyright (c) 2014, I2SE GmbH

 *

 *   Permission to use, copy, modify, and/or distribute this software

 *   for any purpose with or without fee is hereby granted, provided

 *   that the above copyright notice and this permission notice appear

 *   in all copies.

 *

 *   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL

 *   WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED

 *   WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL

 *   THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR

 *   CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM

 *   LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,

 *   NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN

 *   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

/*   This file contains debugging routines for use in the QCA7K driver.

/* The order of these strings must match the order of the fields in

 * struct qcaspi_stats

 * See qca_spi.h

 CONFIG_DEBUG_FS */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2013-2018, The Linux Foundation. All rights reserved.

 *

 * RMNET Data virtual network driver

 RX/TX Fixup */

 Network Device Operations */

 struct assignment */

/* Called by kernel whenever a new rmnet<n> device is created. Sets MTU,

 * flags, ARP type, needed headroom, etc...

 Raw IP mode */

 No header */

 This perm addr will be used as interface identifier by IPv6 */

 Exposed API */

	/* Although we expect similar number of enable/disable

	 * commands, optimize for the disable. That is more

	 * latency sensitive than enable

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2013-2018, The Linux Foundation. All rights reserved.

	/* Ignore the ip family and pass the sequence number for both v4 and v6

	 * sequence. User space does not support creating dedicated flows for

	 * the 2 protocols

 Command data immediately follows the MAP header */

/* Process MAP command frame and send N/ACK message as appropriate. Message cmd

 * name is decoded here and appropriate handler is called.

 Command data immediately follows the MAP header */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2013-2018, 2021, The Linux Foundation. All rights reserved.

 *

 * RMNET Data ingress/egress handler

 Helper Functions */

 Generic handler */

 MAP handler */

 Packet contains a MAP command (not data) */

 Subtract MAP header */

 Ingress / Egress Entry Points */

/* Processes packet as per ingress data format for receiving device. Logical

 * endpoint is determined from packet inspection. Packet is then sent to the

 * egress device listed in the logical endpoint configuration.

/* Modifies packet as per logical endpoint configuration and egress data format

 * for egress device configured in logical endpoint. Packet is then transmitted

 * on the egress device.

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2013-2018, 2021, The Linux Foundation. All rights reserved.

 *

 * RMNET Data MAP protocol

	/* Computing the checksum over just the IPv4 header--including its

	 * checksum field--should yield 0.  If it doesn't, the IP header

	 * is bad, so return an error and let the IP layer drop it.

 We don't support checksum offload on IPv4 fragments */

 Checksum offload is only supported for UDP and TCP protocols */

 RFC 768: UDP checksum is optional for IPv4, and is 0 if unused */

	/* The checksum value in the trailer is computed over the entire

	 * IP packet, including the IP header and payload.  To derive the

	 * transport checksum from this, we first subract the contribution

	 * of the IP header from the trailer checksum.  We then add the

	 * checksum computed over the pseudo header.

	 *

	 * We verified above that the IP header contributes zero to the

	 * trailer checksum.  Therefore the checksum in the trailer is

	 * just the checksum computed over the IP payload.



	 * If the IP payload arrives intact, adding the pseudo header

	 * checksum to the IP payload checksum will yield 0xffff (negative

	 * zero).  This means the trailer checksum and the pseudo checksum

	 * are additive inverses of each other.  Put another way, the

	 * message passes the checksum test if the trailer checksum value

	 * is the negated pseudo header checksum.

	 *

	 * Knowing this, we don't even need to examine the transport

	 * header checksum value; it is already accounted for in the

	 * checksum value found in the trailer.

 The cast is required to ensure only the low 16 bits are examined */

	/* Checksum offload is only supported for UDP and TCP protocols;

	 * the packet cannot include any IPv6 extension headers

	/* The checksum value in the trailer is computed over the entire

	 * IP packet, including the IP header and payload.  To derive the

	 * transport checksum from this, we first subract the contribution

	 * of the IP header from the trailer checksum.  We then add the

	 * checksum computed over the pseudo header.

	/* It's sufficient to compare the IP payload checksum with the

	 * negated pseudo checksum to determine whether the packet

	 * checksum was good.  (See further explanation in comments

	 * in rmnet_map_ipv4_dl_csum_trailer()).

	 *

	 * The cast is required to ensure only the low 16 bits are

	 * examined.

 Ask for checksum offloading */

/* Adds MAP header to front of skb->data

 * Padding is calculated and set appropriately in MAP header. Mux ID is

 * initialized to 0.

 Set next_hdr bit for csum offload packets */

 This is a data packet, so the CMD bit is 0 */

/* Deaggregates a single packet

 * A whole new buffer is allocated for each portion of an aggregated frame.

 * Caller should keep calling deaggregate() on the source skb until 0 is

 * returned, indicating that there are no more packets to deaggregate. Caller

 * is responsible for freeing the original skb.

 Mapv5 data pkt without csum hdr is invalid */

 Some hardware can send us empty frames. Catch them */

/* Validates packet checksums. Function takes a pointer to

 * the beginning of a buffer which contains the IP payload +

 * padding + checksum trailer.

 * Only IPv4 and IPv6 are supported along with TCP & UDP.

 * Fragmented or tunneled packets are not supported.

/* Generates UL checksum meta info header for IPv4 and IPv6 over TCP and UDP

 * packets that are supported for UL checksum offload.

 Process a MAPv5 packet header */

 Pull csum v5 header */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2013-2018, The Linux Foundation. All rights reserved.

 *

 * RMNET configuration engine

 Local Definitions and Declarations */

 Needs rtnl lock */

 bridge device */

 real device */

 real device */

 IFLA_RMNET_MUX_ID */

 IFLA_RMNET_FLAGS */

	/* If there is more than one rmnet dev attached, its probably being

	 * used for muxing. Skip the briding in that case

 Startup/Shutdown */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.

/* Qualcomm Technologies, Inc. EMAC Ethernet Controller MAC layer support

 EMAC_MAC_CTRL */

 EMAC_DESC_CTRL_3 */

 EMAC_DESC_CTRL_4 */

 EMAC_DESC_CTRL_6 */

 EMAC_DESC_CTRL_9 */

 EMAC_TXQ_CTRL_0 */

 EMAC_TXQ_CTRL_1 */

 EMAC_TXQ_CTRL_2 */

 EMAC_RXQ_CTRL_0 */

 EMAC_RXQ_CTRL_1 */

 EMAC_RXQ_CTRL_2 */

 EMAC_RXQ_CTRL_3 */

 EMAC_DMA_CTRL */

 EMAC_MAILBOX_13 */

 EMAC_MAILBOX_2 */

 EMAC_MAILBOX_3 */

 EMAC_MAILBOX_11 */

 EMAC_AXI_MAST_CTRL */

 EMAC_MAILBOX_12 */

 EMAC_MAILBOX_9 */

 EMAC_MAILBOX_10 */

 EMAC_ATHR_HEADER_CTRL */

 EMAC_MAILBOX_0 */

 EMAC_MAILBOX_5 */

 EMAC_MISC_CTRL */

 EMAC_MAILBOX_7 */

 EMAC_MAILBOX_8 */

 EMAC_MAILBOX_15 */

 EMAC_MAILBOX_16 */

 EMAC_EMAC_WRAPPER_TX_TS_INX */

 EMAC Errors in emac_rrd.word[3] */

 Error bits that will result in a received frame being discarded */

 Calculate the CRC of the MAC address */

	/* The HASH Table is an array of 2 32-bit registers. It is

	 * treated like an array of 64 bits (BitArray[hash_value]).

	 * Use the upper 6 bits of the above CRC as the hash value.

 definitions for RSS */

 Config MAC modes */

 Config descriptor rings */

 TPD (Transmit Packet Descriptor) */

 RFD (Receive Free Descriptor) & RRD (Receive Return Descriptor) */

	/* Load all of the base addresses above and ensure that triggering HW to

	 * read ring pointers is flushed

 Config transmit parameters */

 Config receive parameters */

 Config dma */

 config DMA and ensure that configuration is flushed to HW */

 set MAC address */

	/* for example: 00-A0-C6-11-22-33

	 * 0<-->C6112233, 1<-->00A0.

 low 32bit word */

 hight 32bit word */

 reset may take up to 100usec */

 interrupt clear-on-read */

 enable tx queue */

 enable rx queue */

 enable mac control */

 enable RX/TX */

	/* Configure MAC flow control. If set to automatic, then match

	 * whatever the PHY does. Otherwise, enable or disable it, depending

	 * on what the user configured via ethtool.

 If it's set to automatic, then update our local values */

 setup link speed */

 other parameters */

	/* Enable single-pause-frame mode if requested.

	 *

	 * If enabled, the EMAC will send a single pause frame when the RX

	 * queue is full.  This normally leads to packet loss because

	 * the pause frame disables the remote MAC only for 33ms (the quanta),

	 * and then the remote MAC continues sending packets even though

	 * the RX queue is still full.

	 *

	 * If disabled, the EMAC sends a pause frame every 31ms until the RX

	 * queue is no longer full.  Normally, this is the preferred

	 * method of operation.  However, when the system is hung (e.g.

	 * cores are halted), the EMAC interrupt handler is never called

	 * and so the RX queue fills up quickly and stays full.  The resuling

	 * non-stop "flood" of pause frames sometimes has the effect of

	 * disabling nearby switches.  In some cases, other nearby switches

	 * are also affected, shutting down the entire network.

	 *

	 * The user can enable or disable single-pause-frame mode

	 * via ethtool.

	/* enable interrupt read clear, low power sleep mode and

	 * the irq moderators

 stopping mac may take upto 1msec */

 Free all descriptors of given transmit queue */

 ring already cleared, nothing to do */

 clear the descriptor ring */

 Free all descriptors of given receive queue */

 ring already cleared, nothing to do */

 clear the descriptor rings */

 Free all buffers associated with given transmit queue */

 Allocate TX descriptor ring for the given transmit queue */

 Free all buffers associated with given transmit queue */

 Allocate RX descriptor rings for the given receive queue */

 Allocate all TX and RX descriptor rings */

	/* Ring DMA buffer. Each ring may need up to 8 bytes for alignment,

	 * hence the additional padding bytes are allocated.

 8 byte per one Tx and two Rx rings */

 Free all TX and RX descriptor rings */

 Initialize descriptor rings */

 Produce new receive free descriptor */

 Fill up receive queue's RFD with preallocated receive buffers */

 this always has a blank rx_buffer*/

 Bringup the interface/HW */

 enable mac irq */

 Bring down the interface/HW */

	/* Interrupts must be disabled before the PHY is disconnected, to

	 * avoid a race condition where adjust_link is null when we get

	 * an interrupt.

 Consume next received packet descriptor */

 mark rrd as processed */

 Produce new transmit descriptor */

 Mark the last transmit descriptor as such (for the transmit packet) */

 Push the received skb to upper layers */

 Process receive event */

 good receive */

		/* Due to a HW issue in L4 check sum detection (UDP/TCP frags

		 * with DF set are marked as error), drop packets based on the

		 * error mask rather than the summary bit (ignoring L4F errors)

 get the number of free transmit descriptors */

 Process transmit event */

 Initialize all queue data structures */

 Fill up transmit descriptors with TSO and Checksum offload information */

 we only need to do csum */

 ipv6 tso need an extra tpd */

 Fill up transmit descriptors */

 if Large Segment Offload is (in TCP Segmentation Offload struct) */

 The last tpd */

	/* The last buffer info contain the skb address,

	 * so it will be freed after unmap

 One of the memory mappings failed, so undo everything */

 Transmit the packet using specified transmit queue */

	/* Make sure the are enough free descriptors to hold one

	 * maximum-sized SKB.  We need one desc for each fragment,

	 * one for the checksum (emac_tso_csum), one for TSO, and

	 * and one for the SKB header.

 update produce idx */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.

/* Qualcomm Technologies, Inc. EMAC PHY Controller driver.

 EMAC base register offsets */

 EMAC_MDIO_CTRL */

 EMAC_PHY_STS */

 Configure the MDIO bus and connect the external PHY */

 Create the mii_bus object for talking to the MDIO bus */

			/* If we can't read a valid phy address, then assume

			 * that there is only one phy on this mdio bus.

		/* of_phy_find_device() claims a reference to the phydev,

		 * so we do that here manually as well. When the driver

		 * later unloads, it can unilaterally drop the reference

		 * without worrying about ACPI vs DT.

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.

/* Qualcomm Technologies, Inc. FSM9900 EMAC SGMII Controller driver.

 EMAC_QSERDES register offsets */

 EMAC_SGMII register offsets */

 Power up the Ser/Des engine */

 Mask out all the SGMII Interrupt */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.

/* Qualcomm Technologies, Inc. QDF2400 EMAC SGMII Controller driver.

 EMAC_SGMII register offsets */

 SGMII digital lane registers */

 SGMII digital lane register values */

 CDR Settings */

 TX/RX Settings */

 PCS lane-x init */

 SGMII lane-x init */

 Power up PCS and start reset lane state machine */

 Wait for c_ready assertion */

 Disable digital and SERDES loopback */

 Mask out all the SGMII Interrupt */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.

 Qualcomm Technologies, Inc. EMAC Gigabit Ethernet Driver */

 The RRD size if timestamping is enabled: */

 in sync with enum emac_clk_id */

 reinitialize */

 NAPI */

 Transmit the packet */

 disable the interrupt */

 reset MAC */

	/* Schedule the napi for receive queue with interrupt

	 * status bit set

 enable the interrupt */

 Configure VLAN tag strip/insert feature */

	/* We only need to reprogram the hardware if the VLAN tag features

	 * have changed, and if it's already running.

	/* emac_mac_mode_config() uses netdev->features to configure the EMAC,

	 * so make sure it's set first.

 Configure Multicast and Promiscuous modes */

 update multicast address filtering */

 Change the Maximum Transfer Unit (MTU) */

 Called when the network interface is made active */

 allocate rx/tx dma buffer & descriptors */

 Called when the network interface is disabled */

 Respond to a TX hang */

/**

 * emac_update_hw_stats - read the EMAC stat registers

 * @adpt: pointer to adapter struct

 *

 * Reads the stats registers and write the values to adpt->stats.

 *

 * adpt->stats.lock must be held while calling this function,

 * and while reading from adpt->stats.

 additional rx status */

 update tx status */

 additional tx status */

 Provide network statistics info for the interface */

 return parsed statistics */

 Watchdog task routine, called to reinitialize the EMAC */

 Initialize various data structures  */

 descriptors */

 dma */

 irq moderator */

 others */

 default to automatic flow control */

 Disable single-pause-frame mode by default */

 Get the clock */

 Initialize clocks */

	/* On ACPI platforms, clocks are controlled by firmware and/or

	 * ACPI, not by drivers.

 Enable clocks; needs emac_clks_phase1_init to be called before */

 Get the resources */

 get mac address */

 Core 0 interrupt */

 base register address */

 CSR register address */

	/* The TPD buffer address is limited to:

	 * 1. PTP:	45bits. (Driver doesn't support yet.)

	 * 2. NON-PTP:	46bits.

 initialize clocks */

 init external phy */

 init internal sgmii phy */

 enable clocks */

 set hw features */

 MTU range: 46 - 9194 */

 Initialize queues */

 Closing the SGMII turns off its interrupts */

 Resetting the MAC turns off all DMA and its interrupts */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.

/* Qualcomm Technologies, Inc. EMAC SGMII Controller driver.

 EMAC_SGMII register offsets */

 Initialize the SGMII link between the internal and external PHYs. */

	/* Always use autonegotiation. It works no matter how the external

	 * PHY is configured.

 Ensure interrupt clear command is written to HW */

	/* After set the IRQ_GLOBAL_CLEAR bit, the status clearing must

	 * be confirmed before clearing the bits in other registers.

	 * It takes a few cycles for hw to clear the interrupt status.

 Finalize clearing procedure */

 Ensure that clearing procedure finalization is written to HW */

 The number of decode errors that triggers a reset */

	/* If we get a decoding error and CDR is not locked, then try

	 * resetting the internal PHY.  The internal PHY uses an embedded

	 * clock with Clock and Data Recovery (CDR) to recover the

	 * clock and data.

		/* The SGMII is capable of recovering from some decode

		 * errors automatically.  However, if we get multiple

		 * decode errors in a row, then assume that something

		 * is wrong and reset the interface.

 We only care about consecutive decode errors. */

 Reset PHY */

 Ensure phy-reset command is written to HW before the release cmd */

	/* Ensure phy-reset release command is written to HW before initializing

	 * SGMII

 Make sure interrupts are cleared and disabled first */

 Make sure interrupts are disabled */

 The error interrupts are only valid after the link is up */

 Clear and enable interrupts */

 Disable interrupts */

				/* Older versions of the QDF2432 ACPI tables do

				 * not have an _HRV property.

 Something is wrong with the tables */

 Base address is the first address */

 v2 SGMII has a per-lane digital digital, so parse it if it exists */

	/* We've remapped the addresses, so we don't need the device any

	 * more.  of_find_device_by_node() says we should release it.

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2016, The Linux Foundation. All rights reserved.

	/* We don't have separate queues/rings for small/large frames, so

	 * reject any attempt to specify those values separately.

 Selected registers that might want to track during runtime. */

 Every time emac_regs[] above is changed, increase this version number. */

 SPDX-License-Identifier: GPL-2.0-only

/* Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.

/* Qualcomm Technologies, Inc. QDF2432 EMAC SGMII Controller driver.

 EMAC_SGMII register offsets */

 SGMII digital lane registers */

 SGMII digital lane register values */

 CDR Settings */

 TX/RX Settings */

 PCS lane-x init */

 SGMII lane-x init */

 Power up PCS and start reset lane state machine */

 Wait for c_ready assertion */

 Disable digital and SERDES loopback */

 Mask out all the SGMII Interrupt */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Xilinx Axi Ethernet device driver

 *

 * Copyright (c) 2008 Nissin Systems Co., Ltd.,  Yoshio Kashiwagi

 * Copyright (c) 2005-2008 DLA Systems,  David H. Lynch Jr. <dhlii@dlasys.net>

 * Copyright (c) 2008-2009 Secret Lab Technologies Ltd.

 * Copyright (c) 2010 - 2011 Michal Simek <monstr@monstr.eu>

 * Copyright (c) 2010 - 2011 PetaLogix

 * Copyright (c) 2019 SED Systems, a division of Calian Ltd.

 * Copyright (c) 2010 - 2012 Xilinx, Inc. All rights reserved.

 *

 * This is a driver for the Xilinx Axi Ethernet which is used in the Virtex6

 * and Spartan6.

 *

 * TODO:

 *  - Add Axi Fifo support.

 *  - Factor out Axi DMA code into separate driver.

 *  - Test and fix basic multicast filtering.

 *  - Add support for extended multicast filtering.

 *  - Test basic VLAN support.

 *  - Add support for extended VLAN support.

 Descriptors defines for Tx and Rx DMA */

 Must be shorter than length of ethtool_drvinfo.driver field to fit */

 Match table for of_platform binding */

 Option table for setting up Axi Ethernet hardware options */

 Turn on jumbo packet support for both Rx and Tx */

 Turn on VLAN packet support for both Rx and Tx */

 Turn on FCS stripping on receive packets */

 Turn on FCS insertion on transmit packets */

 Turn off length/type field checking on receive packets */

 Turn on Rx flow control */

 Turn on Tx flow control */

 Turn on promiscuous frame filtering */

 Enable transmitter */

 Enable receiver */

/**

 * axienet_dma_in32 - Memory mapped Axi DMA register read

 * @lp:		Pointer to axienet local structure

 * @reg:	Address offset from the base address of the Axi DMA core

 *

 * Return: The contents of the Axi DMA register

 *

 * This function returns the contents of the corresponding Axi DMA register.

/**

 * axienet_dma_out32 - Memory mapped Axi DMA register write.

 * @lp:		Pointer to axienet local structure

 * @reg:	Address offset from the base address of the Axi DMA core

 * @value:	Value to be written into the Axi DMA register

 *

 * This function writes the desired value into the corresponding Axi DMA

 * register.

/**

 * axienet_dma_bd_release - Release buffer descriptor rings

 * @ndev:	Pointer to the net_device structure

 *

 * This function is used to release the descriptors allocated in

 * axienet_dma_bd_init. axienet_dma_bd_release is called when Axi Ethernet

 * driver stop api is called.

 If we end up here, tx_bd_v must have been DMA allocated. */

		/* A NULL skb means this descriptor has not been initialised

		 * at all.

		/* For each descriptor, we programmed cntrl with the (non-zero)

		 * descriptor size, after it had been successfully allocated.

		 * So a non-zero value in there means we need to unmap it.

/**

 * axienet_dma_bd_init - Setup buffer descriptor rings for Axi DMA

 * @ndev:	Pointer to the net_device structure

 *

 * Return: 0, on success -ENOMEM, on failure

 *

 * This function is called to initialize the Rx and Tx DMA descriptor

 * rings. This initializes the descriptors with required default values

 * and is called when Axi Ethernet driver reset is called.

 Reset the indexes which are used for accessing the BDs */

 Allocate the Tx and Rx buffer descriptors. */

 Start updating the Rx channel control register */

 Update the interrupt coalesce count */

 Update the delay timer count */

 Enable coalesce, delay timer and error interrupts */

 Write to the Rx channel control register */

 Start updating the Tx channel control register */

 Update the interrupt coalesce count */

 Update the delay timer count */

 Enable coalesce, delay timer and error interrupts */

 Write to the Tx channel control register */

	/* Populate the tail pointer and bring the Rx Axi DMA engine out of

	 * halted state. This will make the Rx side ready for reception.

	/* Write to the RS (Run-stop) bit in the Tx channel control register.

	 * Tx channel is now ready to run. But only after we write to the

	 * tail pointer register that the Tx channel will start transmitting.

/**

 * axienet_set_mac_address - Write the MAC address

 * @ndev:	Pointer to the net_device structure

 * @address:	6 byte Address to be written as MAC address

 *

 * This function is called to initialize the MAC address of the Axi Ethernet

 * core. It writes to the UAW0 and UAW1 registers of the core.

 Set up unicast MAC address filter set its mac address */

/**

 * netdev_set_mac_address - Write the MAC address (from outside the driver)

 * @ndev:	Pointer to the net_device structure

 * @p:		6 byte Address to be written as MAC address

 *

 * Return: 0 for all conditions. Presently, there is no failure case.

 *

 * This function is called to initialize the MAC address of the Axi Ethernet

 * core. It calls the core specific axienet_set_mac_address. This is the

 * function that goes into net_device_ops structure entry ndo_set_mac_address.

/**

 * axienet_set_multicast_list - Prepare the multicast table

 * @ndev:	Pointer to the net_device structure

 *

 * This function is called to initialize the multicast table during

 * initialization. The Axi Ethernet basic multicast support has a four-entry

 * multicast table which is initialized here. Additionally this function

 * goes into the net_device_ops structure entry ndo_set_multicast_list. This

 * means whenever the multicast table entries need to be updated this

 * function gets called.

		/* We must make the kernel realize we had to move into

		 * promiscuous mode. If it was a promiscuous mode request

		 * the flag is already set. If not we set it.

/**

 * axienet_setoptions - Set an Axi Ethernet option

 * @ndev:	Pointer to the net_device structure

 * @options:	Option to be enabled/disabled

 *

 * The Axi Ethernet core has multiple features which can be selectively turned

 * on or off. The typical options could be jumbo frame option, basic VLAN

 * option, promiscuous mode option etc. This function is used to set or clear

 * these options in the Axi Ethernet hardware. This is done through

 * axienet_option structure .

	/* Reset Axi DMA. This would reset Axi Ethernet core as well. The reset

	 * process of Axi DMA takes a while to complete as all pending

	 * commands/transfers will be flushed or completed during this

	 * reset process.

	 * Note that even though both TX and RX have their own reset register,

	 * they both reset the entire DMA core, so only one needs to be used.

/**

 * axienet_device_reset - Reset and initialize the Axi Ethernet hardware.

 * @ndev:	Pointer to the net_device structure

 *

 * This function is called to reset and initialize the Axi Ethernet core. This

 * is typically called during initialization. It does a reset of the Axi DMA

 * Rx/Tx channels and initializes the Axi DMA BDs. Since Axi DMA reset lines

 * areconnected to Axi Ethernet reset lines, this in turn resets the Axi

 * Ethernet core. No separate hardware reset is done for the Axi Ethernet

 * core.

 * Returns 0 on success or a negative error number otherwise.

	/* Sync default options with HW but leave receiver and

	 * transmitter disabled.

/**

 * axienet_free_tx_chain - Clean up a series of linked TX descriptors.

 * @ndev:	Pointer to the net_device structure

 * @first_bd:	Index of first descriptor to clean up

 * @nr_bds:	Number of descriptors to clean up, can be -1 if unknown.

 * @sizep:	Pointer to a u32 filled with the total sum of all bytes

 * 		in all cleaned-up descriptors. Ignored if NULL.

 *

 * Would either be called after a successful transmit operation, or after

 * there was an error when setting up the chain.

 * Returns the number of descriptors handled.

		/* If no number is given, clean up *all* descriptors that have

		 * been completed by the MAC.

/**

 * axienet_start_xmit_done - Invoked once a transmit is completed by the

 * Axi DMA Tx channel.

 * @ndev:	Pointer to the net_device structure

 *

 * This function is invoked from the Axi DMA Tx isr to notify the completion

 * of transmit operation. It clears fields in the corresponding Tx BDs and

 * unmaps the corresponding buffer so that CPU can regain ownership of the

 * buffer. It finally invokes "netif_wake_queue" to restart transmission if

 * required.

 Matches barrier in axienet_start_xmit */

/**

 * axienet_check_tx_bd_space - Checks if a BD/group of BDs are currently busy

 * @lp:		Pointer to the axienet_local structure

 * @num_frag:	The number of BDs to check for

 *

 * Return: 0, on success

 *	    NETDEV_TX_BUSY, if any of the descriptors are not free

 *

 * This function is invoked before BDs are allocated and transmission starts.

 * This function returns 0 if a BD or group of BDs can be allocated for

 * transmission. If the BD or any of the BDs are not free the function

 * returns a busy status. This is invoked from axienet_start_xmit.

/**

 * axienet_start_xmit - Starts the transmission.

 * @skb:	sk_buff pointer that contains data to be Txed.

 * @ndev:	Pointer to net_device structure.

 *

 * Return: NETDEV_TX_OK, on success

 *	    NETDEV_TX_BUSY, if any of the descriptors are not free

 *

 * This function is invoked from upper layers to initiate transmission. The

 * function uses the next available free BDs and populates their fields to

 * start the transmission. Additionally if checksum offloading is supported,

 * it populates AXI Stream Control fields with appropriate values.

 Matches barrier in axienet_start_xmit_done */

 Space might have just been freed - check again */

 Tx Full Checksum Offload Enabled */

 Tx Partial Checksum Offload Enabled */

 Tx Full Checksum Offload Enabled */

 Start the transfer */

/**

 * axienet_recv - Is called from Axi DMA Rx Isr to complete the received

 *		  BD processing.

 * @ndev:	Pointer to net_device structure.

 *

 * This function is invoked from the Axi DMA Rx isr to process the Rx BDs. It

 * does minimal processing and invokes "netif_rx" to complete further

 * processing.

skb_checksum_none_assert(skb);*/

 if we're doing Rx csum offload, set it up */

/**

 * axienet_tx_irq - Tx Done Isr.

 * @irq:	irq number

 * @_ndev:	net_device pointer

 *

 * Return: IRQ_HANDLED if device generated a TX interrupt, IRQ_NONE otherwise.

 *

 * This is the Axi DMA Tx done Isr. It invokes "axienet_start_xmit_done"

 * to complete the BD processing.

 Disable coalesce, delay timer and error interrupts */

 Write to the Tx channel control register */

 Disable coalesce, delay timer and error interrupts */

 Write to the Rx channel control register */

/**

 * axienet_rx_irq - Rx Isr.

 * @irq:	irq number

 * @_ndev:	net_device pointer

 *

 * Return: IRQ_HANDLED if device generated a RX interrupt, IRQ_NONE otherwise.

 *

 * This is the Axi DMA Rx Isr. It invokes "axienet_recv" to complete the BD

 * processing.

 Disable coalesce, delay timer and error interrupts */

 Finally write to the Tx channel control register */

 Disable coalesce, delay timer and error interrupts */

 write to the Rx channel control register */

/**

 * axienet_eth_irq - Ethernet core Isr.

 * @irq:	irq number

 * @_ndev:	net_device pointer

 *

 * Return: IRQ_HANDLED if device generated a core interrupt, IRQ_NONE otherwise.

 *

 * Handle miscellaneous conditions indicated by Ethernet core IRQ.

/**

 * axienet_open - Driver open routine.

 * @ndev:	Pointer to net_device structure

 *

 * Return: 0, on success.

 *	    non-zero error value on failure

 *

 * This is the driver open routine. It calls phylink_start to start the

 * PHY device.

 * It also allocates interrupt service routines, enables the interrupt lines

 * and ISR handling. Axi Ethernet core is reset through Axi DMA core. Buffer

 * descriptors are initialized.

	/* When we do an Axi Ethernet reset, it resets the complete core

	 * including the MDIO. MDIO must be disabled before resetting.

	 * Hold MDIO bus lock to avoid MDIO accesses during the reset.

 Enable worker thread for Axi DMA error handling */

 Enable interrupts for Axi DMA Tx */

 Enable interrupts for Axi DMA Rx */

 Enable interrupts for Axi Ethernet core (if defined) */

/**

 * axienet_stop - Driver stop routine.

 * @ndev:	Pointer to net_device structure

 *

 * Return: 0, on success.

 *

 * This is the driver stop routine. It calls phylink_disconnect to stop the PHY

 * device. It also removes the interrupt handlers and disables the interrupts.

 * The Axi DMA Tx/Rx BDs are released.

 Give DMAs a chance to halt gracefully */

 Do a reset to ensure DMA is really stopped */

/**

 * axienet_change_mtu - Driver change mtu routine.

 * @ndev:	Pointer to net_device structure

 * @new_mtu:	New mtu value to be applied

 *

 * Return: Always returns 0 (success).

 *

 * This is the change mtu driver routine. It checks if the Axi Ethernet

 * hardware supports jumbo frames before changing the mtu. This can be

 * called only when the device is not up.

/**

 * axienet_poll_controller - Axi Ethernet poll mechanism.

 * @ndev:	Pointer to net_device structure

 *

 * This implements Rx/Tx ISR poll mechanisms. The interrupts are disabled prior

 * to polling the ISRs and are enabled back after the polling is done.

/**

 * axienet_ethtools_get_drvinfo - Get various Axi Ethernet driver information.

 * @ndev:	Pointer to net_device structure

 * @ed:		Pointer to ethtool_drvinfo structure

 *

 * This implements ethtool command for getting the driver information.

 * Issue "ethtool -i ethX" under linux prompt to execute this function.

/**

 * axienet_ethtools_get_regs_len - Get the total regs length present in the

 *				   AxiEthernet core.

 * @ndev:	Pointer to net_device structure

 *

 * This implements ethtool command for getting the total register length

 * information.

 *

 * Return: the total regs length

/**

 * axienet_ethtools_get_regs - Dump the contents of all registers present

 *			       in AxiEthernet core.

 * @ndev:	Pointer to net_device structure

 * @regs:	Pointer to ethtool_regs structure

 * @ret:	Void pointer used to return the contents of the registers.

 *

 * This implements ethtool command for getting the Axi Ethernet register dump.

 * Issue "ethtool -d ethX" to execute this function.

/**

 * axienet_ethtools_get_pauseparam - Get the pause parameter setting for

 *				     Tx and Rx paths.

 * @ndev:	Pointer to net_device structure

 * @epauseparm:	Pointer to ethtool_pauseparam structure.

 *

 * This implements ethtool command for getting axi ethernet pause frame

 * setting. Issue "ethtool -a ethX" to execute this function.

/**

 * axienet_ethtools_set_pauseparam - Set device pause parameter(flow control)

 *				     settings.

 * @ndev:	Pointer to net_device structure

 * @epauseparm:Pointer to ethtool_pauseparam structure

 *

 * This implements ethtool command for enabling flow control on Rx and Tx

 * paths. Issue "ethtool -A ethX tx on|off" under linux prompt to execute this

 * function.

 *

 * Return: 0 on success, -EFAULT if device is running

/**

 * axienet_ethtools_get_coalesce - Get DMA interrupt coalescing count.

 * @ndev:	Pointer to net_device structure

 * @ecoalesce:	Pointer to ethtool_coalesce structure

 * @kernel_coal: ethtool CQE mode setting structure

 * @extack:	extack for reporting error messages

 *

 * This implements ethtool command for getting the DMA interrupt coalescing

 * count on Tx and Rx paths. Issue "ethtool -c ethX" under linux prompt to

 * execute this function.

 *

 * Return: 0 always

/**

 * axienet_ethtools_set_coalesce - Set DMA interrupt coalescing count.

 * @ndev:	Pointer to net_device structure

 * @ecoalesce:	Pointer to ethtool_coalesce structure

 * @kernel_coal: ethtool CQE mode setting structure

 * @extack:	extack for reporting error messages

 *

 * This implements ethtool command for setting the DMA interrupt coalescing

 * count on Tx and Rx paths. Issue "ethtool -C ethX rx-frames 5" under linux

 * prompt to execute this function.

 *

 * Return: 0, on success, Non-zero error value on failure.

 Only support the mode we are configured for */

 nothing meaningful to do */

/**

 * axienet_dma_err_handler - Work queue task for Axi DMA Error

 * @work:	pointer to work_struct

 *

 * Resets the Axi DMA and Axi Ethernet devices, and reconfigures the

 * Tx/Rx BDs.

	/* When we do an Axi Ethernet reset, it resets the complete core

	 * including the MDIO. MDIO must be disabled before resetting.

	 * Hold MDIO bus lock to avoid MDIO accesses during the reset.

 Start updating the Rx channel control register */

 Update the interrupt coalesce count */

 Update the delay timer count */

 Enable coalesce, delay timer and error interrupts */

 Finally write to the Rx channel control register */

 Start updating the Tx channel control register */

 Update the interrupt coalesce count */

 Update the delay timer count */

 Enable coalesce, delay timer and error interrupts */

 Finally write to the Tx channel control register */

	/* Populate the tail pointer and bring the Rx Axi DMA engine out of

	 * halted state. This will make the Rx side ready for reception.

	/* Write to the RS (Run-stop) bit in the Tx channel control register.

	 * Tx channel is now ready to run. But only after we write to the

	 * tail pointer register that the Tx channel will start transmitting

	/* Sync default options with HW but leave receiver and

	 * transmitter disabled.

/**

 * axienet_probe - Axi Ethernet probe function.

 * @pdev:	Pointer to platform device structure.

 *

 * Return: 0, on success

 *	    Non-zero error value on failure.

 *

 * This is the probe routine for Axi Ethernet driver. This is called before

 * any other driver routines are invoked. It allocates and sets up the Ethernet

 * device. Parses through device tree and populates fields of

 * axienet_local. It registers the Ethernet device.

 clear multicast */

 MTU range: 64 - 9000 */

		/* For backward compatibility, if named AXI clock is not present,

		 * treat the first clock specified as the AXI clock.

 Map device registers */

 Setup checksum offload, but default to off if not specified */

 Can checksum TCP/UDP over IPv4. */

 Can checksum TCP/UDP over IPv4. */

	/* For supporting jumbo frames, the Axi Ethernet hardware must have

	 * a larger Rx/Tx Memory. Typically, the size must be large so that

	 * we can enable jumbo option and start supporting jumbo frames.

	 * Here we check for memory allocated for Rx/Tx in the hardware from

	 * the device-tree and accordingly set flags.

 Start with the proprietary, and broken phy_type */

 Find the DMA node, map the DMA registers, and decode the DMA IRQs */

 Check for these resources directly on the Ethernet node. */

	/* Autodetect the need for 64-bit DMA pointers.

	 * When the IP is configured for a bus width bigger than 32 bits,

	 * writing the MSB registers is mandatory, even if they are all 0.

	 * We can detect this case by writing all 1's to one such register

	 * and see if that sticks: when the IP is configured for 32 bits

	 * only, those registers are RES0.

	 * Those MSB registers were introduced in IP v7.1, which we check first.

 sanity check */

 Check for Ethernet core IRQ (optional) */

 Retrieve the MAC address */

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Xilinx EmacLite Linux driver for the Xilinx Ethernet MAC Lite device.

 *

 * This is a new flat driver which is based on the original emac_lite

 * driver from John Williams <john.williams@xilinx.com>.

 *

 * 2007 - 2013 (c) Xilinx, Inc.

 Register offsets for the EmacLite Core */

 Transmit Buffer */

 MDIO Address Register */

 MDIO Write Data Register */

 MDIO Read Data Register */

 MDIO Control Register */

 GIE Register */

 Tx status */

 Tx packet length */

 Receive Buffer */

 Rx packet length */

 Rx status */

 Next Tx/Rx buffer's offset */

 MDIO Address Register Bit Masks */

 Register Address */

 PHY Address */

 RD/WR Operation */

 MDIO Write Data Register Bit Masks */

 Data to be Written */

 MDIO Read Data Register Bit Masks */

 Data to be Read */

 MDIO Control Register Bit Masks */

 MDIO Status Mask */

 MDIO Enable */

 Global Interrupt Enable Register (GIER) Bit Masks */

 Global Enable */

 Transmit Status Register (TSR) Bit Masks */

 Tx complete */

 Program the MAC address */

 Tx interrupt enable bit */

#define XEL_TSR_XMIT_ACTIVE_MASK 0x80000000	/* Buffer is active, SW bit

						 * only. This is not documented

						 * in the HW spec

 Define for programming the MAC address into the EmacLite */

 Receive Status Register (RSR) */

 Rx complete */

 Rx interrupt enable bit */

 Transmit Packet Length Register (TPLR) */

 Tx packet length */

 Receive Packet Length Register (RPLR) */

 Rx packet length */

 Offset to length field */

 Shift value for length */

 General Ethernet Definitions */

 Max ARP packet size */

 IP Length Offset */

 Tx timeout is 60 seconds. */

 BUFFER_ALIGN(adr) calculates the number of bytes to the next alignment. */

/**

 * struct net_local - Our private per device data

 * @ndev:		instance of the network device

 * @tx_ping_pong:	indicates whether Tx Pong buffer is configured in HW

 * @rx_ping_pong:	indicates whether Rx Pong buffer is configured in HW

 * @next_tx_buf_to_use:	next Tx buffer to write to

 * @next_rx_buf_to_use:	next Rx buffer to read from

 * @base_addr:		base address of the Emaclite device

 * @reset_lock:		lock used for synchronization

 * @deferred_skb:	holds an skb (for transmission at a later time) when the

 *			Tx buffer is not free

 * @phy_dev:		pointer to the PHY device

 * @phy_node:		pointer to the PHY device node

 * @mii_bus:		pointer to the MII bus

 * @last_link:		last link status

************************/

 EmacLite driver calls */

************************/

/**

 * xemaclite_enable_interrupts - Enable the interrupts for the EmacLite device

 * @drvdata:	Pointer to the Emaclite device private data

 *

 * This function enables the Tx and Rx interrupts for the Emaclite device along

 * with the Global Interrupt Enable.

 Enable the Tx interrupts for the first Buffer */

 Enable the Rx interrupts for the first buffer */

 Enable the Global Interrupt Enable */

/**

 * xemaclite_disable_interrupts - Disable the interrupts for the EmacLite device

 * @drvdata:	Pointer to the Emaclite device private data

 *

 * This function disables the Tx and Rx interrupts for the Emaclite device,

 * along with the Global Interrupt Enable.

 Disable the Global Interrupt Enable */

 Disable the Tx interrupts for the first buffer */

 Disable the Rx interrupts for the first buffer */

/**

 * xemaclite_aligned_write - Write from 16-bit aligned to 32-bit aligned address

 * @src_ptr:	Void pointer to the 16-bit aligned source address

 * @dest_ptr:	Pointer to the 32-bit aligned destination address

 * @length:	Number bytes to write from source to destination

 *

 * This function writes data from a 16-bit aligned buffer to a 32-bit aligned

 * address in the EmacLite device.

		/* This barrier resolves occasional issues seen around

		 * cases where the data is not properly flushed out

		 * from the processor store buffers to the destination

		 * memory locations.

 Output a word */

 Set up to output the remaining data */

 Output the remaining data */

		/* This barrier resolves occasional issues seen around

		 * cases where the data is not properly flushed out

		 * from the processor store buffers to the destination

		 * memory locations.

/**

 * xemaclite_aligned_read - Read from 32-bit aligned to 16-bit aligned buffer

 * @src_ptr:	Pointer to the 32-bit aligned source address

 * @dest_ptr:	Pointer to the 16-bit aligned destination address

 * @length:	Number bytes to read from source to destination

 *

 * This function reads data from a 32-bit aligned address in the EmacLite device

 * to a 16-bit aligned buffer.

 Copy each word into the temporary buffer */

 Read data from source */

 Set up to read the remaining data */

 Read the remaining data */

/**

 * xemaclite_send_data - Send an Ethernet frame

 * @drvdata:	Pointer to the Emaclite device private data

 * @data:	Pointer to the data to be sent

 * @byte_count:	Total frame size, including header

 *

 * This function checks if the Tx buffer of the Emaclite device is free to send

 * data. If so, it fills the Tx buffer with data for transmission. Otherwise, it

 * returns an error.

 *

 * Return:	0 upon success or -1 if the buffer(s) are full.

 *

 * Note:	The maximum Tx packet size can not be more than Ethernet header

 *		(14 Bytes) + Maximum MTU (1500 bytes). This is excluding FCS.

 Determine the expected Tx buffer address */

 If the length is too large, truncate it */

 Check if the expected buffer is available */

 Switch to next buffer if configured */

		/* If the expected buffer is full, try the other buffer,

		 * if it is configured in HW

 Buffers were full, return failure */

 Buffer was full, return failure */

 Write the frame to the buffer */

	/* Update the Tx Status Register to indicate that there is a

	 * frame to send. Set the XEL_TSR_XMIT_ACTIVE_MASK flag which

	 * is used by the interrupt handler to check whether a frame

	 * has been transmitted

/**

 * xemaclite_recv_data - Receive a frame

 * @drvdata:	Pointer to the Emaclite device private data

 * @data:	Address where the data is to be received

 * @maxlen:    Maximum supported ethernet packet length

 *

 * This function is intended to be called from the interrupt context or

 * with a wrapper which waits for the receive frame to be available.

 *

 * Return:	Total number of bytes received

 Determine the expected buffer address */

 Verify which buffer has valid data */

		/* The instance is out of sync, try other buffer if other

		 * buffer is configured, return 0 otherwise. If the instance is

		 * out of sync, do not update the 'next_rx_buf_to_use' since it

		 * will correct on subsequent calls

 No data was available */

 Verify that buffer has valid data */

 No data was available */

	/* Get the protocol type of the ethernet frame that arrived

	/* Check if received ethernet frame is a raw ethernet frame

	 * or an IP packet or an ARP packet

			/* Field contains type other than IP or ARP, use max

			 * frame size and let user parse it

 Use the length in the frame, plus the header and trailer */

 Read from the EmacLite device */

 Acknowledge the frame */

/**

 * xemaclite_update_address - Update the MAC address in the device

 * @drvdata:	Pointer to the Emaclite device private data

 * @address_ptr:Pointer to the MAC address (MAC address is a 48-bit value)

 *

 * Tx must be idle and Rx should be idle for deterministic results.

 * It is recommended that this function should be called after the

 * initialization and before transmission of any packets from the device.

 * The MAC address can be programmed using any of the two transmit

 * buffers (if configured).

 Determine the expected Tx buffer address */

 Update the MAC address in the EmacLite */

 Wait for EmacLite to finish with the MAC address update */

/**

 * xemaclite_set_mac_address - Set the MAC address for this device

 * @dev:	Pointer to the network device instance

 * @address:	Void pointer to the sockaddr structure

 *

 * This function copies the HW address from the sockaddr strucutre to the

 * net_device structure and updates the address in HW.

 *

 * Return:	Error if the net device is busy or 0 if the addr is set

 *		successfully

/**

 * xemaclite_tx_timeout - Callback for Tx Timeout

 * @dev:	Pointer to the network device

 * @txqueue:	Unused

 *

 * This function is called when Tx time out occurs for Emaclite device.

 Reset the device */

 Shouldn't really be necessary, but shouldn't hurt */

 To exclude tx timeout */

 prevent tx timeout */

 We're all ready to go. Start the queue */

*********************/

 Interrupt Handlers */

*********************/

/**

 * xemaclite_tx_handler - Interrupt handler for frames sent

 * @dev:	Pointer to the network device

 *

 * This function updates the number of packets transmitted and handles the

 * deferred skb, if there is one.

 prevent tx timeout */

/**

 * xemaclite_rx_handler- Interrupt handler for frames received

 * @dev:	Pointer to the network device

 *

 * This function allocates memory for a socket buffer, fills it with data

 * received and hands it over to the TCP/IP stack.

 Couldn't get memory. */

	/* A new skb should have the data halfword aligned, but this code is

	 * here just in case that isn't true. Calculate how many

	 * bytes we should reserve to get the data to start on a word

	 * boundary

 Tell the skb how much data we got */

 Send the packet upstream */

/**

 * xemaclite_interrupt - Interrupt handler for this driver

 * @irq:	Irq of the Emaclite device

 * @dev_id:	Void pointer to the network device instance used as callback

 *		reference

 *

 * Return:	IRQ_HANDLED

 *

 * This function handles the Tx and Rx interrupts of the EmacLite device.

 Check if there is Rx Data available */

 Check if the Transmission for the first buffer is completed */

 Check if the Transmission for the second buffer is completed */

 If there was a Tx interrupt, call the Tx Handler */

*********************/

 MDIO Bus functions */

*********************/

/**

 * xemaclite_mdio_wait - Wait for the MDIO to be ready to use

 * @lp:		Pointer to the Emaclite device private data

 *

 * This function waits till the device is ready to accept a new MDIO

 * request.

 *

 * Return:	0 for success or ETIMEDOUT for a timeout

	/* wait for the MDIO interface to not be busy or timeout

	 * after some time.

/**

 * xemaclite_mdio_read - Read from a given MII management register

 * @bus:	the mii_bus struct

 * @phy_id:	the phy address

 * @reg:	register number to read from

 *

 * This function waits till the device is ready to accept a new MDIO

 * request and then writes the phy address to the MDIO Address register

 * and reads data from MDIO Read Data register, when its available.

 *

 * Return:	Value read from the MII management register

	/* Write the PHY address, register number and set the OP bit in the

	 * MDIO Address register. Set the Status bit in the MDIO Control

	 * register to start a MDIO read transaction.

/**

 * xemaclite_mdio_write - Write to a given MII management register

 * @bus:	the mii_bus struct

 * @phy_id:	the phy address

 * @reg:	register number to write to

 * @val:	value to write to the register number specified by reg

 *

 * This function waits till the device is ready to accept a new MDIO

 * request and then writes the val to the MDIO Write Data register.

 *

 * Return:      0 upon success or a negative error upon failure

	/* Write the PHY address, register number and clear the OP bit in the

	 * MDIO Address register and then write the value into the MDIO Write

	 * Data register. Finally, set the Status bit in the MDIO Control

	 * register to start a MDIO write transaction.

/**

 * xemaclite_mdio_setup - Register mii_bus for the Emaclite device

 * @lp:		Pointer to the Emaclite device private data

 * @dev:	Pointer to OF device structure

 *

 * This function enables MDIO bus in the Emaclite device and registers a

 * mii_bus.

 *

 * Return:	0 upon success or a negative error upon failure

	/* Don't register the MDIO bus if the phy_node or its parent node

	 * can't be found.

	/* Enable the MDIO bus by asserting the enable bit in MDIO Control

	 * register.

/**

 * xemaclite_adjust_link - Link state callback for the Emaclite device

 * @ndev: pointer to net_device struct

 *

 * There's nothing in the Emaclite device to be configured when the link

 * state changes. We just print the status.

 hash together the state values to decide if something has changed */

/**

 * xemaclite_open - Open the network device

 * @dev:	Pointer to the network device

 *

 * This function sets the MAC address, requests an IRQ and enables interrupts

 * for the Emaclite device and starts the Tx queue.

 * It also connects to the phy device, if MDIO is included in Emaclite device.

 *

 * Return:	0 on success. -ENODEV, if PHY cannot be connected.

 *		Non-zero error value on failure.

 Just to be safe, stop the device first */

 EmacLite doesn't support giga-bit speeds */

 Don't advertise 1000BASE-T Full/Half duplex speeds */

 Advertise only 10 and 100mbps full/half duplex speeds */

 Restart auto negotiation */

 Set the MAC address each time opened */

 Grab the IRQ */

 Enable Interrupts */

 We're ready to go */

/**

 * xemaclite_close - Close the network device

 * @dev:	Pointer to the network device

 *

 * This function stops the Tx queue, disables interrupts and frees the IRQ for

 * the Emaclite device.

 * It also disconnects the phy device associated with the Emaclite device.

 *

 * Return:	0, always.

/**

 * xemaclite_send - Transmit a frame

 * @orig_skb:	Pointer to the socket buffer to be transmitted

 * @dev:	Pointer to the network device

 *

 * This function checks if the Tx buffer of the Emaclite device is free to send

 * data. If so, it fills the Tx buffer with data from socket buffer data,

 * updates the stats and frees the socket buffer. The Tx completion is signaled

 * by an interrupt. If the Tx buffer isn't free, then the socket buffer is

 * deferred and the Tx queue is stopped so that the deferred socket buffer can

 * be transmitted when the Emaclite device is free to transmit data.

 *

 * Return:	NETDEV_TX_OK, always.

		/* If the Emaclite Tx buffer is busy, stop the Tx queue and

		 * defer the skb for transmission during the ISR, after the

		 * current transmission is complete

 Take the time stamp now, since we can't do this in an ISR. */

/**

 * get_bool - Get a parameter from the OF device

 * @ofdev:	Pointer to OF device structure

 * @s:		Property to be retrieved

 *

 * This function looks for a property in the device node and returns the value

 * of the property if its found or 0 if the property is not found.

 *

 * Return:	Value of the parameter if the parameter is found, or 0 otherwise

/**

 * xemaclite_ethtools_get_drvinfo - Get various Axi Emac Lite driver info

 * @ndev:       Pointer to net_device structure

 * @ed:         Pointer to ethtool_drvinfo structure

 *

 * This implements ethtool command for getting the driver information.

 * Issue "ethtool -i ethX" under linux prompt to execute this function.

/**

 * xemaclite_of_probe - Probe method for the Emaclite device.

 * @ofdev:	Pointer to OF device structure

 *

 * This function probes for the Emaclite device in the device tree.

 * It initializes the driver data structure and the hardware, sets the MAC

 * address and registers the network device.

 * It also registers a mii_bus for the Emaclite device, if MDIO is included

 * in the device.

 *

 * Return:	0, if the driver is bound to the Emaclite device, or

 *		a negative error if there is failure.

 Create an ethernet device instance */

 Get IRQ for the device */

 Clear the Tx CSR's in case this is a restart */

 Set the MAC address in the EmacLite device */

 Finally, register the device */

/**

 * xemaclite_of_remove - Unbind the driver from the Emaclite device.

 * @of_dev:	Pointer to OF device structure

 *

 * This function is called if a device is physically removed from the system or

 * if the driver module is being unloaded. It frees any resources allocated to

 * the device.

 *

 * Return:	0, always.

 Un-register the mii_bus, if configured */

 Ioctl MII Interface */

 Match table for OF platform binding */

 end of list */ },

 SPDX-License-Identifier: GPL-2.0

/*

 * MDIO bus driver for the Xilinx TEMAC device

 *

 * Copyright (c) 2009 Secret Lab Technologies, Ltd.

/* ---------------------------------------------------------------------

 * MDIO Bus functions

	/* Write the PHY address to the MIIM Access Initiator register.

	 * When the transfer completes, the PHY register value will appear

	/* First write the desired value into the write data register

	 * and then write the address into the access initiator register

 Get MDIO bus frequency (if specified) */

 Calculate a reasonable divisor for the clock rate */

 worst-case default setting */

	/* Enable the MDIO bus by asserting the enable bit and writing

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Driver for Xilinx TEMAC Ethernet device

 *

 * Copyright (c) 2008 Nissin Systems Co., Ltd.,  Yoshio Kashiwagi

 * Copyright (c) 2005-2008 DLA Systems,  David H. Lynch Jr. <dhlii@dlasys.net>

 * Copyright (c) 2008-2009 Secret Lab Technologies Ltd.

 *

 * This is a driver for the Xilinx ll_temac ipcore which is often used

 * in the Virtex and Spartan series of chips.

 *

 * Notes:

 * - The ll_temac hardware uses indirect access for many of the TEMAC

 *   registers, include the MDIO bus.  However, indirect access to MDIO

 *   registers take considerably more clock cycles than to TEMAC registers.

 *   MDIO accesses are long, so threads doing them should probably sleep

 *   rather than busywait.  However, since only one indirect access can be

 *   in progress at any given time, that means that *all* indirect accesses

 *   could end up sleeping (to wait for an MDIO access to complete).

 *   Fortunately none of the indirect accesses are on the 'hot' path for tx

 *   or rx, so this should be okay.

 *

 * TODO:

 * - Factor out locallink DMA code into separate driver

 * - Fix support for hardware checksumming.

 * - Testing.  Lots and lots of testing.

 *

 needed for sizeof(tcphdr) */

 needed for sizeof(udphdr) */

 Descriptors defines for Tx and Rx DMA */

/* ---------------------------------------------------------------------

 * Low level register access functions

/* Poll for maximum 20 ms.  This is similar to the 2 jiffies @ 100 Hz

 * that was used before, and should cover MDIO bus speed down to 3200

 * Hz.

/*

 * temac_indirect_busywait - Wait for current indirect register access

 * to complete.

/*

 * temac_indirect_in32 - Indirect register read access.  This function

 * must be called without lp->indirect_lock being held.

/*

 * temac_indirect_in32_locked - Indirect register read access.  This

 * function must be called with lp->indirect_lock being held.  Use

 * this together with spin_lock_irqsave/spin_lock_irqrestore to avoid

 * repeated lock/unlock and to ensure uninterrupted access to indirect

 * registers.

	/* This initial wait should normally not spin, as we always

	 * try to wait for indirect access to complete before

	 * releasing the indirect_lock.

 Initiate read from indirect register */

	/* Wait for indirect register access to complete.  We really

	 * should not see timeouts, and could even end up causing

	 * problem for following indirect access, so let's make a bit

	 * of WARN noise.

 Value is ready now */

/*

 * temac_indirect_out32 - Indirect register write access.  This function

 * must be called without lp->indirect_lock being held.

/*

 * temac_indirect_out32_locked - Indirect register write access.  This

 * function must be called with lp->indirect_lock being held.  Use

 * this together with spin_lock_irqsave/spin_lock_irqrestore to avoid

 * repeated lock/unlock and to ensure uninterrupted access to indirect

 * registers.

	/* As in temac_indirect_in32_locked(), we should normally not

	 * spin here.  And if it happens, we actually end up silently

	 * ignoring the write request.  Ouch.

 Initiate write to indirect register */

	/* As in temac_indirect_in32_locked(), we should not see timeouts

	 * here.  And if it happens, we continue before the write has

	 * completed.  Not good.

/*

 * temac_dma_in32_* - Memory mapped DMA read, these function expects a

 * register input that is based on DCR word addresses which are then

 * converted to memory mapped byte addresses.  To be assigned to

 * lp->dma_in32.

/*

 * temac_dma_out32_* - Memory mapped DMA read, these function expects

 * a register input that is based on DCR word addresses which are then

 * converted to memory mapped byte addresses.  To be assigned to

 * lp->dma_out32.

/* DMA register access functions can be DCR based or memory mapped.

 * The PowerPC 440 is DCR based, the PowerPC 405 and MicroBlaze are both

 * memory mapped.

/*

 * temac_dma_dcr_in32 - DCR based DMA read

/*

 * temac_dma_dcr_out32 - DCR based DMA write

/*

 * temac_dcr_setup - If the DMA is DCR based, then setup the address and

 * I/O  functions

 setup the dcr address mapping if it's in the device tree */

 no DCR in the device tree, indicate a failure */

/*

 * temac_dcr_setup - This is a stub for when DCR is not supported,

 * such as with MicroBlaze and x86

/*

 * temac_dma_bd_release - Release buffer descriptor rings

 Reset Local Link (DMA) */

/*

 * temac_dma_bd_init - Setup buffer descriptor rings

 allocate the tx and rx ring buffer descriptors. */

 returns a virtual address and a physical address. */

 returns physical address of skb->data */

 Configure DMA channel (irq setup) */

 Use 1 Bit Wide Counters. Currently Not Used!

 Init descriptor indexes */

 Enable RX DMA transfers */

 Prepare for TX DMA transfer */

/* ---------------------------------------------------------------------

 * net_device_ops

 set up unicast MAC address filter set its mac address */

	/* There are reserved bits in EUAW1

 Clear all or remaining/unused address table entries */

 Enable address filter block if currently disabled */

 Turn on jumbo packet support for both Rx and Tx */

 Turn on VLAN packet support for both Rx and Tx */

 Turn on FCS stripping on receive packets */

 Turn on FCS insertion on transmit packets */

 Turn on length/type field checking on receive packets */

 Turn on flow control */

 Turn on flow control */

 Turn on promiscuous frame filtering (all frames are received ) */

 Enable transmitter if not already enabled */

 Enable receiver? */

/*

 * temac_setoptions

 Initialize temac */

 Perform a software reset */

 0x300 host enable bit ? */

 reset PHY through control register ?:1 */

 Reset the receiver and wait for it to finish reset */

 Reset the transmitter and wait for it to finish reset */

 Disable the receiver */

 Reset Local Link (DMA) */

	/* Sync default options with HW

 Set address filter table */

 Init Driver variable */

 prevent tx timeout */

 hash together the state values to decide if something has changed */

 Write new speed setting out to TEMAC */

		/* Make sure that the other fields are read after bd is

		 * released by dma

		/* app0 must be visible last, as it is used to flag

		 * availability of the bd

 Matches barrier in temac_start_xmit */

 Make sure to read next bd app0 after this one */

 Matches barrier in temac_start_xmit_done */

 Space might have just been freed - check again */

 TX Checksum Enabled */

 initial checksum seed */

	/* Mark last fragment with skb address, so it can be consumed

	 * in temac_start_xmit_done()

 Kick off the transfer */

 DMA start */

	/* Process all received buffers, passing them on network

	 * stack.  After this, the buffer descriptors will be in an

	 * un-allocated stage, where no skb is allocated for it, and

	 * they are therefore not available for TEMAC/DMA.

		/* While this should not normally happen, we can end

		 * here when GFP_ATOMIC allocations fail, and we

		 * therefore have un-allocated buffers.

 Loop over all completed buffer descriptors */

 The buffer is not valid for DMA anymore */

 if we're doing rx csum offload, set it up */

			/* Convert from device endianness (be32) to cpu

			 * endiannes, and if necessary swap the bytes

			 * (back) for proper IP checksum byte order

			 * (be16).

 The skb buffer is now owned by network stack above */

	/* DMA operations will halt when the last buffer descriptor is

	 * processed (ie. the one pointed to by RX_TAILDESC_PTR).

	 * When that happens, no more interrupt events will be

	 * generated.  No IRQ_COAL or IRQ_DLY, and not even an

	 * IRQ_ERR.  To avoid stalling, we schedule a delayed work

	 * when there is a potential risk of that happening.  The work

	 * will call this function, and thus re-schedule itself until

	 * enough buffers are available again.

	/* Allocate new buffers for those buffer descriptors that were

	 * passed to network stack.  Note that GFP_ATOMIC allocations

	 * can fail (e.g. when a larger burst of GFP_ATOMIC

	 * allocations occurs), so while we try to allocate all

	 * buffers in the same interrupt where they were processed, we

	 * continue with what we could get in case of allocation

	 * failure.  Allocation of remaining buffers will be retried

	 * in following calls.

 All skb's allocated */

 Move tail pointer when buffers have been allocated */

/* Function scheduled to ensure a restart in case of DMA halt

 * condition caused by running out of buffer descriptors.

 Read and clear the status registers */

/* ---------------------------------------------------------------------

 * SYSFS device attributes

/* ---------------------------------------------------------------------

 * ethtool support

	/* With typical LocalLink clock speed of 200 MHz and

	 * C_PRESCALAR=1023, each delay count corresponds to 5.12 us.

 Init network device structure */

 Can checksum TCP/UDP over IPv4. */

 Can checksum all the packets. */

 Can checksum IPV6 TCP/UDP */

 Can DMA to high memory. */

 Transmit VLAN hw accel */

 Receive VLAN hw acceleration */

 Receive VLAN filtering */

 cannot handle VLAN pkts */

 Enable software GSO. */

 Has multiple TX/RX queues */

 large receive offload */

 setup temac private info structure */

 Setup mutex for synchronization of indirect register access */

 map device registers */

	/* Select register access functions with the specified

	 * endianness mode.  Default for OF devices is big-endian.

 Setup checksum offload, but default to off if not specified */

 Can checksum TCP/UDP over IPv4. */

	/* Defaults for IRQ delay/coalescing setup.  These are

	 * configuration values, so does not belong in device-tree.

 Setup LocalLink DMA */

		/* Find the DMA node, map the DMA registers, and

		 * decode the DMA IRQs.

		/* Setup the DMA register accesses, could be DCR or

		 * memory mapped.

 no DCR in the device tree, try non-DCR */

 Get DMA RX and TX interrupts */

 Finished with the DMA node; drop the reference */

 2nd memory resource specifies DMA registers */

 Get DMA RX and TX interrupts */

 IRQ delay/coalescing setup */

 Error handle returned DMA RX and TX interrupts */

 Retrieve the MAC address */

 Add the device attributes */

 SPDX-License-Identifier: GPL-2.0

/*

 * MDIO bus driver for the Xilinx Axi Ethernet device

 *

 * Copyright (c) 2009 Secret Lab Technologies, Ltd.

 * Copyright (c) 2010 - 2011 Michal Simek <monstr@monstr.eu>

 * Copyright (c) 2010 - 2011 PetaLogix

 * Copyright (c) 2019 SED Systems, a division of Calian Ltd.

 * Copyright (c) 2010 - 2012 Xilinx, Inc. All rights reserved.

 2.5 MHz */

 150 MHz */

 Wait till MDIO interface is ready to accept a new transaction.*/

 Enable the MDIO MDC. Called prior to a read/write operation */

 Disable the MDIO MDC. Called after a read/write operation*/

/**

 * axienet_mdio_read - MDIO interface read function

 * @bus:	Pointer to mii bus structure

 * @phy_id:	Address of the PHY device

 * @reg:	PHY register to read

 *

 * Return:	The register contents on success, -ETIMEDOUT on a timeout

 *

 * Reads the contents of the requested register from the requested PHY

 * address by first writing the details into MCR register. After a while

 * the register MRD is read to obtain the PHY register content.

/**

 * axienet_mdio_write - MDIO interface write function

 * @bus:	Pointer to mii bus structure

 * @phy_id:	Address of the PHY device

 * @reg:	PHY register to write to

 * @val:	Value to be written into the register

 *

 * Return:	0 on success, -ETIMEDOUT on a timeout

 *

 * Writes the value to the requested register by first writing the value

 * into MWD register. The the MCR register is then appropriately setup

 * to finish the write operation.

/**

 * axienet_mdio_enable - MDIO hardware setup function

 * @lp:		Pointer to axienet local data structure.

 *

 * Return:	0 on success, -ETIMEDOUT on a timeout.

 *

 * Sets up the MDIO interface by initializing the MDIO clock and enabling the

 * MDIO interface in hardware.

		/* Legacy fallback: detect CPU clock frequency and use as AXI

		 * bus clock frequency. This only works on certain platforms.

	/* clk_div can be calculated by deriving it from the equation:

	 * fMDIO = fHOST / ((1 + clk_div) * 2)

	 *

	 * Where fMDIO <= 2500000, so we get:

	 * fHOST / ((1 + clk_div) * 2) <= 2500000

	 *

	 * Then we get:

	 * 1 / ((1 + clk_div) * 2) <= (2500000 / fHOST)

	 *

	 * Then we get:

	 * 1 / (1 + clk_div) <= ((2500000 * 2) / fHOST)

	 *

	 * Then we get:

	 * 1 / (1 + clk_div) <= (5000000 / fHOST)

	 *

	 * So:

	 * (1 + clk_div) >= (fHOST / 5000000)

	 *

	 * And finally:

	 * clk_div >= (fHOST / 5000000) - 1

	 *

	 * fHOST can be read from the flattened device tree as property

	 * "clock-frequency" from the CPU

	/* If there is any remainder from the division of

	 * fHOST / (MAX_MDIO_FREQ * 2), then we need to add

	 * 1 to the clock divisor or we will surely be above 2.5 MHz

/**

 * axienet_mdio_disable - MDIO hardware disable function

 * @lp:		Pointer to axienet local data structure.

 *

 * Disable the MDIO interface in hardware.

/**

 * axienet_mdio_setup - MDIO setup function

 * @lp:		Pointer to axienet local data structure.

 *

 * Return:	0 on success, -ETIMEDOUT on a timeout, -ENOMEM when

 *		mdiobus_alloc (to allocate memory for mii bus structure) fails.

 *

 * Sets up the MDIO interface by initializing the MDIO clock.

 * Register the MDIO interface.

/**

 * axienet_mdio_teardown - MDIO remove function

 * @lp:		Pointer to axienet local data structure.

 *

 * Unregisters the MDIO and frees any associate memory for mii bus.

/* sis900.c: A SiS 900/7016 PCI Fast Ethernet driver for Linux.

   Copyright 1999 Silicon Integrated System Corporation

   Revision:	1.08.10 Apr. 2 2006



   Modified from the driver which is originally written by Donald Becker.



   This software may be used and distributed according to the terms

   of the GNU General Public License (GPL), incorporated herein by reference.

   Drivers based on this skeleton fall under the GPL and must retain

   the authorship (implicit copyright) notice.



   References:

   SiS 7016 Fast Ethernet PCI Bus 10/100 Mbps LAN Controller with OnNow Support,

   preliminary Rev. 1.0 Jan. 14, 1998

   SiS 900 Fast Ethernet PCI Bus 10/100 Mbps LAN Single Chip with OnNow Support,

   preliminary Rev. 1.0 Nov. 10, 1998

   SiS 7014 Single Chip 100BASE-TX/10BASE-T Physical Layer Solution,

   preliminary Rev. 1.0 Jan. 18, 1998



   Rev 1.08.10 Apr.  2 2006 Daniele Venzano add vlan (jumbo packets) support

   Rev 1.08.09 Sep. 19 2005 Daniele Venzano add Wake on LAN support

   Rev 1.08.08 Jan. 22 2005 Daniele Venzano use netif_msg for debugging messages

   Rev 1.08.07 Nov.  2 2003 Daniele Venzano <venza@brownhat.org> add suspend/resume support

   Rev 1.08.06 Sep. 24 2002 Mufasa Yang bug fix for Tx timeout & add SiS963 support

   Rev 1.08.05 Jun.  6 2002 Mufasa Yang bug fix for read_eeprom & Tx descriptor over-boundary

   Rev 1.08.04 Apr. 25 2002 Mufasa Yang <mufasa@sis.com.tw> added SiS962 support

   Rev 1.08.03 Feb.  1 2002 Matt Domsch <Matt_Domsch@dell.com> update to use library crc32 function

   Rev 1.08.02 Nov. 30 2001 Hui-Fen Hsu workaround for EDB & bug fix for dhcp problem

   Rev 1.08.01 Aug. 25 2001 Hui-Fen Hsu update for 630ET & workaround for ICS1893 PHY

   Rev 1.08.00 Jun. 11 2001 Hui-Fen Hsu workaround for RTL8201 PHY and some bug fix

   Rev 1.07.11 Apr.  2 2001 Hui-Fen Hsu updates PCI drivers to use the new pci_set_dma_mask for kernel 2.4.3

   Rev 1.07.10 Mar.  1 2001 Hui-Fen Hsu <hfhsu@sis.com.tw> some bug fix & 635M/B support

   Rev 1.07.09 Feb.  9 2001 Dave Jones <davej@suse.de> PCI enable cleanup

   Rev 1.07.08 Jan.  8 2001 Lei-Chun Chang added RTL8201 PHY support

   Rev 1.07.07 Nov. 29 2000 Lei-Chun Chang added kernel-doc extractable documentation and 630 workaround fix

   Rev 1.07.06 Nov.  7 2000 Jeff Garzik <jgarzik@pobox.com> some bug fix and cleaning

   Rev 1.07.05 Nov.  6 2000 metapirat<metapirat@gmx.de> contribute media type select by ifconfig

   Rev 1.07.04 Sep.  6 2000 Lei-Chun Chang added ICS1893 PHY support

   Rev 1.07.03 Aug. 24 2000 Lei-Chun Chang (lcchang@sis.com.tw) modified 630E equalizer workaround rule

   Rev 1.07.01 Aug. 08 2000 Ollie Lho minor update for SiS 630E and SiS 630E A1

   Rev 1.07    Mar. 07 2000 Ollie Lho bug fix in Rx buffer ring

   Rev 1.06.04 Feb. 11 2000 Jeff Garzik <jgarzik@pobox.com> softnet and init for kernel 2.4

   Rev 1.06.03 Dec. 23 1999 Ollie Lho Third release

   Rev 1.06.02 Nov. 23 1999 Ollie Lho bug in mac probing fixed

   Rev 1.06.01 Nov. 16 1999 Ollie Lho CRC calculation provide by Joseph Zbiciak (im14u2c@primenet.com)

   Rev 1.06 Nov. 4 1999 Ollie Lho (ollie@sis.com.tw) Second release

   Rev 1.05.05 Oct. 29 1999 Ollie Lho (ollie@sis.com.tw) Single buffer Tx/Rx

   Chin-Shan Li (lcs@sis.com.tw) Added AMD Am79c901 HomePNA PHY support

   Rev 1.05 Aug. 7 1999 Jim Huang (cmhuang@sis.com.tw) Initial release

 Processor type for cache alignment. */

 User space memory access functions */

 Use SIS900_DEF_MSG as value */

 Time in jiffies before concluding the transmitter is hung. */

 record the first mii structure */

 Link status detection timer. */

 1: auto-negotiate complete  */

 producer/consumer pointers for Tx/Rx ring */

 The saved address of a sent/receive-in-place packet buffer */

 The Tx queue is full. */

 EEPROM data */

/**

 *	sis900_get_mac_addr - Get MAC address for stand alone SiS900 model

 *	@pci_dev: the sis900 pci device

 *	@net_dev: the net device to get address for

 *

 *	Older SiS900 and friends, use EEPROM to store MAC address.

 *	MAC address is read from read_eeprom() into @net_dev->dev_addr.

 check to see if we have sane EEPROM */

 get MAC address from EEPROM */

/**

 *	sis630e_get_mac_addr - Get MAC address for SiS630E model

 *	@pci_dev: the sis900 pci device

 *	@net_dev: the net device to get address for

 *

 *	SiS630E model, use APC CMOS RAM to store MAC address.

 *	APC CMOS RAM is accessed through ISA bridge.

 *	MAC address is read into @net_dev->dev_addr.

/**

 *	sis635_get_mac_addr - Get MAC address for SIS635 model

 *	@pci_dev: the sis900 pci device

 *	@net_dev: the net device to get address for

 *

 *	SiS635 model, set MAC Reload Bit to load Mac address from APC

 *	to rfdr. rfdr is accessed through rfcr. MAC address is read into

 *	@net_dev->dev_addr.

 disable packet filtering before setting filter */

 load MAC addr to filter data register */

 enable packet filtering */

/**

 *	sis96x_get_mac_addr - Get MAC address for SiS962 or SiS963 model

 *	@pci_dev: the sis900 pci device

 *	@net_dev: the net device to get address for

 *

 *	SiS962 or SiS963 model, use EEPROM to store MAC address. And EEPROM

 *	is shared by

 *	LAN and 1394. When accessing EEPROM, send EEREQ signal to hardware first

 *	and wait for EEGNT. If EEGNT is ON, EEPROM is permitted to be accessed

 *	by LAN, otherwise it is not. After MAC address is read from EEPROM, send

 *	EEDONE signal to refuse EEPROM access by LAN.

 *	The EEPROM map of SiS962 or SiS963 is different to SiS900.

 *	The signature field in SiS962 or SiS963 spec is meaningless.

 *	MAC address is read into @net_dev->dev_addr.

 get MAC address from EEPROM */

/**

 *	sis900_probe - Probe for sis900 device

 *	@pci_dev: the sis900 pci device

 *	@pci_id: the pci device ID

 *

 *	Check and probe sis900 net device for @pci_dev.

 *	Get mac address according to the chip revision,

 *	and assign SiS900-specific entries in the device structure.

 *	ie: sis900_open(), sis900_start_xmit(), sis900_close(), etc.

 when built into the kernel, we only print version if device is found */

 setup various bits in PCI command register */

 We do a request_region() to register /proc/ioports info. */

 IO region. */

 The SiS900-specific entries in the device structure. */

 Get Mac address according to the chip revision */

 630ET : set the mii access mode as software-mode */

 probe for mii transceiver */

 save our host bridge revision */

 print some information about our NIC */

 Detect Wake on Lan support */

/**

 *	sis900_mii_probe - Probe MII PHY for sis900

 *	@net_dev: the net device to probe for

 *

 *	Search for total of 32 possible mii phy addresses.

 *	Identify and set current phy if found one,

 *	return error if it failed to found.

 search for total of 32 possible mii phy addresses */

 select default PHY for mac */

 Reset phy if default phy is internal sis900 */

 workaround for ICS1893 PHY */

 SiS 630E has some bugs on default value of PHY registers */

mdio_write(net_dev, sis_priv->cur_phy, MII_CONTROL, 0x1000);

/**

 *	sis900_default_phy - Select default PHY for sis900 mac.

 *	@net_dev: the net device to probe for

 *

 *	Select first detected PHY with link as default.

 *	If no one is link on, select PHY whose types is HOME as default.

 *	If HOME doesn't exist, select LAN.

 Link ON & Not select default PHY & not ghost PHY */

/**

 * 	sis900_set_capability - set the media capability of network adapter.

 *	@net_dev : the net device to probe for

 *	@phy : default PHY

 *

 *	Set the media capability of network adapter according to

 *	mii status register. It's necessary before auto-negotiate.

 Delay between EEPROM clock transitions. */

/**

 *	read_eeprom - Read Serial EEPROM

 *	@ioaddr: base i/o address

 *	@location: the EEPROM location to read

 *

 *	Read Serial EEPROM through EEPROM Access Register.

 *	Note that location is in word (16 bits) unit

 Shift the read command (9) bits out. */

 read the 16-bits data in */

 Terminate the EEPROM access. */

/* Read and write the MII management registers using software-generated

   serial MDIO protocol. Note that the command bits and data bits are

 Synchronize the MII management interface by shifting 32 one bits out. */

/**

 *	mdio_read - read MII PHY register

 *	@net_dev: the net device to read

 *	@phy_id: the phy address to read

 *	@location: the phy register id to read

 *

 *	Read MII registers through MDIO and MDC

 *	using MDIO management frame structure and protocol(defined by ISO/IEC).

 *	Please see SiS7014 or ICS spec

 Read the 16 data bits. */

/**

 *	mdio_write - write MII PHY register

 *	@net_dev: the net device to write

 *	@phy_id: the phy address to write

 *	@location: the phy register id to write

 *	@value: the register value to write with

 *

 *	Write MII registers with @value through MDIO and MDC

 *	using MDIO management frame structure and protocol(defined by ISO/IEC)

 *	please see SiS7014 or ICS spec

 Shift the command bits out. */

 Shift the value bits out. */

 Clear out extra bits. */

/**

 *	sis900_reset_phy - reset sis900 mii phy.

 *	@net_dev: the net device to write

 *	@phy_addr: default phy address

 *

 *	Some specific phy can't work properly without reset.

 *	This function will be called during initialization and

 *	link status change from ON to DOWN.

/*

 * Polling 'interrupt' - used by things like netconsole to send skbs

 * without having to re-enable interrupts. It's not called while

 * the interrupt routine is executing.

/**

 *	sis900_open - open sis900 device

 *	@net_dev: the net device to open

 *

 *	Do some initialization and start net interface.

 *	enable interrupts and set sis900 timer.

 Soft reset the chip. */

 Equalizer workaround Rule */

 Workaround for EDB */

 Enable all known interrupts by setting the interrupt mask. */

	/* Set the timer to switch to check for link beat and perhaps switch

/**

 *	sis900_init_rxfilter - Initialize the Rx filter

 *	@net_dev: the net device to initialize for

 *

 *	Set receive filter address to our MAC address

 *	and enable packet filtering.

 disable packet filtering before setting filter */

 load MAC addr to filter data register */

 enable packet filtering */

/**

 *	sis900_init_tx_ring - Initialize the Tx descriptor ring

 *	@net_dev: the net device to initialize for

 *

 *	Initialize the Tx descriptor ring,

 load Transmit Descriptor Register */

/**

 *	sis900_init_rx_ring - Initialize the Rx descriptor ring

 *	@net_dev: the net device to initialize for

 *

 *	Initialize the Rx descriptor ring,

 *	and pre-allocate receive buffers (socket buffer)

 init RX descriptor */

 allocate sock buffers */

			/* not enough memory for skbuff, this makes a "hole"

			   on the buffer ring, it is not clear how the

			   hardware will react to this kind of degenerated

 load Receive Descriptor Register */

/**

 *	sis630_set_eq - set phy equalizer value for 630 LAN

 *	@net_dev: the net device to set equalizer value

 *	@revision: 630 LAN revision number

 *

 *	630E equalizer workaround rule(Cyrus Huang 08/15)

 *	PHY register 14h(Test)

 *	Bit 14: 0 -- Automatically detect (default)

 *		1 -- Manually set Equalizer filter

 *	Bit 13: 0 -- (Default)

 *		1 -- Speed up convergence of equalizer setting

 *	Bit 9 : 0 -- (Default)

 *		1 -- Disable Baseline Wander

 *	Bit 3~7   -- Equalizer filter setting

 *	Link ON: Set Bit 9, 13 to 1, Bit 14 to 0

 *	Then calculate equalizer value

 *	Then set equalizer value, and set Bit 14 to 1, Bit 9 to 0

 *	Link Off:Set Bit 13 to 1, Bit 14 to 0

 *	Calculate Equalizer value:

 *	When Link is ON and Bit 14 is 0, SIS900PHY will auto-detect proper equalizer value.

 *	When the equalizer is stable, this value is not a fixed value. It will be within

 *	a small range(eg. 7~9). Then we get a minimum and a maximum value(eg. min=7, max=9)

 *	0 <= max <= 4  --> set equalizer to max

 *	5 <= max <= 14 --> set equalizer to max+1 or set equalizer to max+2 if max == min

 *	max >= 15      --> set equalizer to max+5 or set equalizer to max+6 if max == min

 630E rule to determine the equalizer value */

 630B0&B1 rule to determine the equalizer value */

 write equalizer value and setting */

/**

 *	sis900_timer - sis900 timer routine

 *	@t: timer list containing a pointer to sis900 net device

 *

 *	On each timer ticks we check two things,

 *	link status (ON/OFF) and link mode (10/100/Full/Half)

 Link OFF -> ON */

 Search for new PHY */

 Link ON -> OFF */

 Change mode issue */

/**

 *	sis900_check_mode - check the media mode for sis900

 *	@net_dev: the net device to be checked

 *	@mii_phy: the mii phy

 *

 *	Older driver gets the media mode from mii status output

 *	register. Now we set our media capability and auto-negotiate

 *	to get the upper bound of speed and duplex between two ends.

 *	If the types of mii phy is HOME, it doesn't need to auto-negotiate

 *	and autong_complete should be set to 1.

/**

 *	sis900_set_mode - Set the media mode of mac register.

 *	@sp:     the device private data

 *	@speed : the transmit speed to be determined

 *	@duplex: the duplex mode to be determined

 *

 *	Set the media mode of mac register txcfg/rxcfg according to

 *	speed and duplex of phy. Bit EDB_MASTER_EN indicates the EDB

 *	bus is used instead of PCI bus. When this bit is set 1, the

 *	Max DMA Burst Size for TX/RX DMA should be no larger than 16

 *	double words.

 Can accept Jumbo packet */

/**

 *	sis900_auto_negotiate - Set the Auto-Negotiation Enable/Reset bit.

 *	@net_dev: the net device to read mode for

 *	@phy_addr: mii phy address

 *

 *	If the adapter is link-on, set the auto-negotiate enable/reset bit.

 *	autong_complete should be set to 0 when starting auto-negotiation.

 *	autong_complete should be set to 1 if we didn't start auto-negotiation.

 *	sis900_timer will wait for link on again if autong_complete = 0.

 (Re)start AutoNegotiate */

/**

 *	sis900_read_mode - read media mode for sis900 internal phy

 *	@net_dev: the net device to read mode for

 *	@speed  : the transmit speed to be determined

 *	@duplex : the duplex mode to be determined

 *

 *	The capability of remote end will be put in mii register autorec

 *	after auto-negotiation. Use AND operation to get the upper bound

 *	of speed and duplex between two ends.

 AutoNegotiate completed */

 Workaround for Realtek RTL8201 PHY issue */

/**

 *	sis900_tx_timeout - sis900 transmit timeout routine

 *	@net_dev: the net device to transmit

 *	@txqueue: index of hanging queue

 *

 *	print transmit timeout status

 *	disable interrupts and do some tasks

 Disable interrupts by clearing the interrupt mask. */

 use spinlock to prevent interrupt handler accessing buffer ring */

 discard unsent packets */

 prevent tx timeout */

 load Transmit Descriptor Register */

 Enable all known interrupts by setting the interrupt mask. */

/**

 *	sis900_start_xmit - sis900 start transmit routine

 *	@skb: socket buffer pointer to put the data being transmitted

 *	@net_dev: the net device to transmit with

 *

 *	Set the transmit buffer descriptor,

 *	and write TxENA to enable transmit state machine.

 *	tell upper layer if the buffer is full

 Calculate the next Tx descriptor entry. */

 set the transmit buffer descriptor and enable Transmit State Machine */

 dirty_tx is met in the cycle of cur_tx, buffer full */

 Typical path, tell upper layer that more transmission is possible */

 buffer full, tell upper layer no more transmission */

/**

 *	sis900_interrupt - sis900 interrupt handler

 *	@irq: the irq number

 *	@dev_instance: the client data object

 *

 *	The interrupt handler does all of the Rx thread work,

 *	and cleans up after the Tx thread

 nothing interesting happened */

 why dow't we break after Tx/Rx case ?? keyword: full-duplex */

 Rx interrupt */

 Tx interrupt */

 something strange happened !!! */

/**

 *	sis900_rx - sis900 receive routine

 *	@net_dev: the net device which receives data

 *

 *	Process receive interrupt events,

 *	put buffer to higher layer and refill buffer pool

 *	Note: This function is called by interrupt handler,

 *	don't do "too much" work here

 ``TOOLONG'' flag means jumbo packet received. */

 corrupted packet received */

 reset buffer descriptor state */

			/* refill the Rx buffer, what if there is not enough

				/*

				 * Not enough memory to refill the buffer

				 * so we need to recycle the old one so

				 * as to avoid creating a memory hole

				 * in the rx ring

			/* This situation should never happen, but due to

			   some unknown bugs, it is possible that

 give the socket buffer to upper layers */

 some network statistics */

 while

	/* refill the Rx buffer, what if the rate of refilling is slower

				/* not enough memory for skbuff, this makes a

				 * "hole" on the buffer ring, it is not clear

				 * how the hardware will react to this kind

 re-enable the potentially idle receive state matchine */

/**

 *	sis900_finish_xmit - finish up transmission of packets

 *	@net_dev: the net device to be transmitted on

 *

 *	Check for error condition and free socket buffer etc

 *	schedule for more transmission as needed

 *	Note: This function is called by interrupt handler,

 *	don't do "too much" work here

			/* The packet is not transmitted yet (owned by hardware) !

			 * Note: this is an almost impossible condition

 packet unsuccessfully transmitted */

 packet successfully transmitted */

 Free the original skb. */

		/* The ring is no longer full, clear tx_full and schedule

/**

 *	sis900_close - close sis900 device

 *	@net_dev: the net device to be closed

 *

 *	Disable interrupts, stop the Tx and Rx Status Machine

 *	free Tx and RX socket buffer

 Disable interrupts by clearing the interrupt mask. */

 Stop the chip's Tx and Rx Status Machine */

 Free Tx and RX skbuff */

 Green! Put the chip in low-power mode. */

/**

 *	sis900_get_drvinfo - Return information about driver

 *	@net_dev: the net device to probe

 *	@info: container for info returned

 *

 *	Process ethtool command such as "ehtool -i" to show information

/**

 *	sis900_set_wol - Set up Wake on Lan registers

 *	@net_dev: the net device to probe

 *	@wol: container for info passed to the driver

 *

 *	Process ethtool command "wol" to setup wake on lan features.

 *	SiS900 supports sending WoL events if a correct packet is received,

 *	but there is no simple way to filter them to only a subset (broadcast,

 *	multicast, unicast or arp).

 read 16 bits, and index by 16 bits */

 read 16 bits, and index by 16 bits */

/**

 *	mii_ioctl - process MII i/o control command

 *	@net_dev: the net device to command for

 *	@rq: parameter for command

 *	@cmd: the i/o command

 *

 *	Process MII command like read/write MII register

 Get address of MII PHY in use. */

 Read MII PHY register. */

 Write MII PHY register. */

/**

 *	sis900_set_config - Set media type by net_device.set_config

 *	@dev: the net device for media type change

 *	@map: ifmap passed by ifconfig

 *

 *	Set media type to 10baseT, 100baseT or 0(for auto) by ifconfig

 *	we support only port changes. All other runtime configuration

 *	changes will be ignored

		/* we switch on the ifmap->port field. I couldn't find anything

		 * like a definition or standard for the values of that field.

		 * I think the meaning of those values is device specific. But

		 * since I would like to change the media type via the ifconfig

		 * command I use the definition from linux/netdevice.h

 use auto here */

			/* we are going to change the media type, so the Link

			 * will be temporary down and we need to reflect that

			 * here. When the Link comes up again, it will be

			 * sensed by the sis_timer procedure, which also does

 read current state */

			/* enable auto negotiation and reset the negotioation

			 * (I don't really know what the auto negatiotiation

			 * reset really means, but it sounds for me right to

 10BaseT */

			/* we are going to change the media type, so the Link

			 * will be temporary down and we need to reflect that

			 * here. When the Link comes up again, it will be

			 * sensed by the sis_timer procedure, which also does

 set Speed to 10Mbps */

 read current state */

 disable auto negotiation and force 10MBit mode*/

 100BaseT */

 100BaseTx */

			/* we are going to change the media type, so the Link

			 * will be temporary down and we need to reflect that

			 * here. When the Link comes up again, it will be

			 * sensed by the sis_timer procedure, which also does

 set Speed to 100Mbps */

 disable auto negotiation and enable 100MBit Mode */

 10Base2 */

 AUI */

 100BaseFx */

 These Modes are not supported (are they?)*/

/**

 *	sis900_mcast_bitnr - compute hashtable index

 *	@addr: multicast address

 *	@revision: revision id of chip

 *

 *	SiS 900 uses the most sigificant 7 bits to index a 128 bits multicast

 *	hash table, which makes this function a little bit different from other drivers

 *	SiS 900 B0 & 635 M/B uses the most significat 8 bits to index 256 bits

 *   	multicast hash table.

 leave 8 or 7 most siginifant bits */

/**

 *	set_rx_mode - Set SiS900 receive mode

 *	@net_dev: the net device to be set

 *

 *	Set SiS900 receive mode for promiscuous, multicast, or broadcast mode.

 *	And set the appropriate multicast filter.

 *	Multicast hash table changes from 128 to 256 bits for 635M/B & 900B0.

 256/128 bits multicast hash table */

 635 Hash Table entries = 256(2^16) */

 Accept any kinds of packets */

 too many multicast addresses or accept all multicast packet */

		/* Accept Broadcast packet, destination address matchs our

		 * MAC address, use Receive Filter to reject unwanted MCAST

 update Multicast Hash Table in Receive Filter */

 why plus 0x04 ??, That makes the correct value for hash table. */

	/* sis900 is capable of looping back packets at MAC level for

 We must disable Tx/Rx before setting loopback mode */

 enable loopback */

 restore cr */

/**

 *	sis900_reset - Reset sis900 MAC

 *	@net_dev: the net device to reset

 *

 *	reset sis900 MAC and wait until finished

 *	reset through command register

 *	change backoff algorithm for 900B0 & 635 M/B

 Check that the chip has finished the reset. */

/**

 *	sis900_remove - Remove sis900 device

 *	@pci_dev: the pci device to be removed

 *

 *	remove and release SiS900 net device

 Stop the chip's Tx and Rx Status Machine */

 Workaround for EDB */

 Enable all known interrupts by setting the interrupt mask. */

 when a module, this is printed whether or not devices are found in probe */

/*

   sis190.c: Silicon Integrated Systems SiS190 ethernet driver



   Copyright (c) 2003 K.M. Liu <kmliu@sis.com>

   Copyright (c) 2003, 2004 Jeff Garzik <jgarzik@pobox.com>

   Copyright (c) 2003, 2004, 2005 Francois Romieu <romieu@fr.zoreil.com>



   Based on r8169.c, tg3.c, 8139cp.c, skge.c, epic100.c and SiS 190/191

   genuine driver.



   This software may be used and distributed according to the terms of

   the GNU General Public License (GPL), incorporated herein by reference.

   Drivers based on or derived from this code fall under the GPL and must

   retain the authorship, copyright and license notice.  This file is not

   a complete program and may only be used when the entire operating

   system is licensed under the GPL.



   See the file COPYING in this distribution for more information.



 [8..1024] */

 [8..8192] */

 Enhanced PHY access register bit definitions */

 7016 only */

 Write/read MMIO register */

 reserved

 unused (Control/Status)

 reserved

 unused

 unused (Interrupt Timer)

 unused (Power Mgmt Control/Status)

 reserved

 unused (GMAC IO Compensation)

 unused (GMAC IO Control)

 unused (Tx MAC Timer/TryLimit)

 unused (RGMII Tx Internal Delay)

 reserved

 Undocumented		= 0x6c,

 unused (Rx WOL Data Access)

 unused (Rx MPS Control)

 reserved

 IntrStatus */

 unused

 unused

 unused

 unused

 unused

 unused

 unused

 {Rx/Tx}CmdBits */

 unused

 unused

 Cfg9346Bits */

 unused

 unused

 RxMacControl */

 unused

 unused

 RxConfigBits */

 0x1a in RxControl ?

 TxConfigBits */

 DMA burst value (0-7) is shift this many bits */

 unused

 unused

 TBICSRBit */

 unused

 _Desc.status */

 RXOWN/TXOWN

 RXINT/TXINT

 CRCOFF/CRCEN

 PREADD/PADEN

 _Desc.size */

 TxDesc.status */

 TSO ? -- FR

 RxDesc.status */

 RxDesc.PSize */

 multi-desc pkt when > 1 ? -- FR

	/*

	 * The asic could apparently do vlan, TSO, jumbo (sis191 only) and

	 * provide two (unused with Linux) Tx queues. No publicly

	 * available documentation alas.

 unused

 unused

 unused

 unused

 unused

 EEPROM Addresses */

 unused

/*

 * Maximum number of multicast addresses to filter (vs. Rx-all-multicast).

 * The chips use a 64 element hash table based on the Ethernet CRC.

 Stop the chip's Tx and Rx DMA processes. */

netif_info(tp, intr, dev, "Rx PSize = %08x\n", status);

	/*

	 * It would not be needed if queueing was allowed to be enabled

	 * again too early (hint: think preempt and unclocked smp systems).

/*

 * The interrupt handler does all of the Rx thread work and cleans up after

 * the Tx thread.

	netif_info(tp, intr, dev, "status = %08x\n", status);

 Multicast hash filter */

 Too many to filter perfectly -- accept all multicasts. */

 Enable all known interrupts by setting the interrupt mask. */

 FIXME: needlessly high ?  -- FR 02/07/2005

 Rejoice ! */

 check for gigabit speed */

 Set Tx Delay in RGMII mode.

 RxDesc->size has a licence to kill the lower bits */

	/*

	 * Rx and Tx descriptors need 256 bytes alignment.

	 * dma_alloc_coherent() guarantees a stronger alignment.

 Half Duplex */

 gigabit HD */

/**

 *	sis190_default_phy - Select default PHY for sis190 mac.

 *	@dev: the net device to probe for

 *

 *	Select first detected PHY with link as default.

 *	If no one is link on, select PHY whose types is HOME as default.

 *	If HOME doesn't exist, select LAN.

 Link ON & Not select default PHY & not ghost PHY.

/**

 *	sis190_mii_probe - Probe MII PHY for sis190

 *	@dev: the net device to probe for

 *

 *	Search for total of 32 possible mii phy addresses.

 *	Identify and set current phy if found one,

 *	return error if it failed to found.

 Try next mii if the current one is not accessible.

 Select default PHY for mac */

 Disable Tx, if not already */

 Disable interrupts by clearing the interrupt mask. */

 Stop a shared interrupt from scavenging while we are. */

 ...and finally, reset everything. */

 Check to see if there is a sane EEPROM */

 Get MAC address from EEPROM */

/**

 *	sis190_get_mac_addr_from_apc - Get MAC address for SiS96x model

 *	@pdev: PCI device

 *	@dev:  network device to get address for

 *

 *	SiS96x model, use APC CMOS RAM to store MAC address.

 *	APC CMOS RAM is accessed through ISA bridge.

 *	MAC address is read into @net_dev->dev_addr.

 Enable port 78h & 79h to access APC Registers. */

 Restore the value to ISA Bridge */

/**

 *      sis190_init_rxfilter - Initialize the Rx filter

 *      @dev: network device to initialize

 *

 *      Set receive filter address to our MAC address

 *      and enable packet filtering.

	/*

	 * Disable packet filtering before setting filter.

	 * Note: SiS's driver writes 32 bits but RxMacControl is 16 bits

	 * only and followed by RxMacAddr (6 bytes). Strange. -- FR

 Enable 10/100 Full/Half Mode, leave MII_ADVERTISE bit4:0

 unchanged.

 Enable 1000 Full Mode.

 Enable auto-negotiation and restart auto-negotiation.

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * Tehuti Networks(R) Network Driver

 * ethtool interface implementation

 * Copyright (C) 2007 Tehuti Networks Ltd. All rights reserved

/*

 * RX HW/SW interaction overview

 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 * There are 2 types of RX communication channels between driver and NIC.

 * 1) RX Free Fifo - RXF - holds descriptors of empty buffers to accept incoming

 * traffic. This Fifo is filled by SW and is readen by HW. Each descriptor holds

 * info about buffer's location, size and ID. An ID field is used to identify a

 * buffer when it's returned with data via RXD Fifo (see below)

 * 2) RX Data Fifo - RXD - holds descriptors of full buffers. This Fifo is

 * filled by HW and is readen by SW. Each descriptor holds status and ID.

 * HW pops descriptor from RXF Fifo, stores ID, fills buffer with incoming data,

 * via dma moves it into host memory, builds new RXD descriptor with same ID,

 * pushes it into RXD Fifo and raises interrupt to indicate new RX data.

 *

 * Current NIC configuration (registers + firmware) makes NIC use 2 RXF Fifos.

 * One holds 1.5K packets and another - 26K packets. Depending on incoming

 * packet size, HW desides on a RXF Fifo to pop buffer from. When packet is

 * filled with data, HW builds new RXD descriptor for it and push it into single

 * RXD Fifo.

 *

 * RX SW Data Structures

 * ~~~~~~~~~~~~~~~~~~~~~

 * skb db - used to keep track of all skbs owned by SW and their dma addresses.

 * For RX case, ownership lasts from allocating new empty skb for RXF until

 * accepting full skb from RXD and passing it to OS. Each RXF Fifo has its own

 * skb db. Implemented as array with bitmask.

 * fifo - keeps info about fifo's size and location, relevant HW registers,

 * usage and skb db. Each RXD and RXF Fifo has its own fifo structure.

 * Implemented as simple struct.

 *

 * RX SW Execution Flow

 * ~~~~~~~~~~~~~~~~~~~~

 * Upon initialization (ifconfig up) driver creates RX fifos and initializes

 * relevant registers. At the end of init phase, driver enables interrupts.

 * NIC sees that there is no RXF buffers and raises

 * RD_INTR interrupt, isr fills skbs and Rx begins.

 * Driver has two receive operation modes:

 *    NAPI - interrupt-driven mixed with polling

 *    interrupt-driven only

 *

 * Interrupt-driven only flow is following. When buffer is ready, HW raises

 * interrupt and isr is called. isr collects all available packets

 * (bdx_rx_receive), refills skbs (bdx_rx_alloc_skbs) and exit.



 * Rx buffer allocation note

 * ~~~~~~~~~~~~~~~~~~~~~~~~~

 * Driver cares to feed such amount of RxF descriptors that respective amount of

 * RxD descriptors can not fill entire RxD fifo. The main reason is lack of

 * overflow check in Bordeaux for RxD fifo free/used size.

 * FIXME: this is NOT fully implemented, more work should be done

 *

 Definitions needed by ISR or NAPI functions */

 Definitions needed by FW loading */

 Definitions needed by hw_start */

 Definitions needed by bdx_close */

 Definitions needed by bdx_probe */

/*************************************************************************

 *    Print Info                                                         *

/*************************************************************************

 *    Code                                                               *

/**

 * bdx_fifo_init - create TX/RX descriptor fifo for host-NIC communication.

 * @priv: NIC private structure

 * @f: fifo to initialize

 * @fsz_type: fifo size type: 0-4KB, 1-8KB, 2-16KB, 3-32KB

 * @reg_CFG0: offsets of registers relative to base address

 * @reg_CFG1: offsets of registers relative to base address

 * @reg_RPTR: offsets of registers relative to base address

 * @reg_WPTR: offsets of registers relative to base address

 *

 * 1K extra space is allocated at the end of the fifo to simplify

 * processing of descriptors that wraps around fifo's end

 *

 * Returns 0 on success, negative value on failure

 *

 dma_alloc_coherent gives us 4k-aligned memory */

/**

 * bdx_fifo_free - free all resources used by fifo

 * @priv: NIC private structure

 * @f: fifo to release

/**

 * bdx_link_changed - notifies OS about hw link state.

 * @priv: hw adapter structure

/**

 * bdx_isr_napi - Interrupt Service Routine for Bordeaux NIC

 * @irq: interrupt number

 * @dev: network device

 *

 * Return IRQ_NONE if it was not our interrupt, IRQ_HANDLED - otherwise

 *

 * It reads ISR register to know interrupt reasons, and proceed them one by one.

 * Reasons of interest are:

 *    RX_DESC - new packet has arrived and RXD fifo holds its descriptor

 *    RX_FREE - number of free Rx buffers in RXF fifo gets low

 *    TX_FREE - packet was transmited and RXF fifo holds its descriptor

 Not our interrupt */

			/* NOTE: we get here if intr has slipped into window

			 * between these lines in bdx_poll:

			 *    bdx_enable_interrupts(priv);

			 *    return 0;

			 * currently intrs are disabled (since we read ISR),

			 * and we have failed to register next poll.

			 * so we read the regs to trigger chip

		/* from time to time we exit to let NAPI layer release

/**

 * bdx_fw_load - loads firmware to NIC

 * @priv: NIC private structure

 *

 * Firmware is loaded via TXD fifo, so it must be initialized first.

 * Firware must be loaded once per NIC not per PCI device provided by NIC (NIC

 * can have few of them). So all drivers use semaphore register to choose one

 * that will actually load FW to NIC.

/**

 * bdx_hw_start - inits registers and starts HW's Rx and Tx engines

 * @priv: NIC private structure

 10G overall max length (vlan, eth&ip header, ip payload, crc) */

NOTE: test script uses this */

cpu_to_le32(rcm.val)); */

NOTE: test script uses this */

 old val = 0x300064 */

 Enable timer interrupt once in 2 secs. */

WRITE_REG(priv, regGTMR0, ((GTMR_SEC * 2) & GTMR_DATA)); */

 reset sequences: read, write 1, read, write 0 */

 check that the PLLs are locked and reset ended */

 do any PCI-E read transaction */

 failure */

 reset sequences: read, write 1, read, write 0 */

 check that the PLLs are locked and reset ended */

 do any PCI-E read transaction */

 failure */

 1. load MAC (obsolete) */

 2. disable Rx (and Tx) */

 3. disable port */

 4. disable queue */

 5. wait until hw is disabled */

 6. disable intrs */

 7. reset queue */

 8. reset port */

 9. zero all read and write pointers */

 10. unseet port disable */

 11. unset queue disable */

 12. unset queue reset */

 13. unset port reset */

 14. enable Rx */

 skiped. will be done later */

 15. save MAC (obsolete) */

 bdx_reset - performs right type of reset depending on hw type */

/**

 * bdx_close - Disables a network interface

 * @ndev: network interface device structure

 *

 * Returns 0, this is not allowed to fail

 *

 * The close entry point is called when an interface is de-activated

 * by the OS.  The hardware is still under the drivers control, but

 * needs to be disabled.  A global MAC reset is issued to stop the

 * hardware, and all transmit and receive resources are freed.

/**

 * bdx_open - Called when a network interface is made active

 * @ndev: network interface device structure

 *

 * Returns 0 on success, negative value on failure

 *

 * The open entry point is called when a network interface is made

 * active by the system (IFF_UP).  At this point all resources needed

 * for transmit and receive operations are allocated, the interrupt

 * handler is registered with the OS, the watchdog timer is started,

 * and the stack is notified that the interface is ready.

/**

 * __bdx_vlan_rx_vid - private helper for adding/killing VLAN vid

 * @ndev: network device

 * @vid:  VLAN vid

 * @enable: enable or disable vlan

 *

 * Passes VLAN filter table to hardware

/**

 * bdx_vlan_rx_add_vid - kernel hook for adding VLAN vid to hw filtering table

 * @ndev: network device

 * @proto: unused

 * @vid:  VLAN vid to add

/**

 * bdx_vlan_rx_kill_vid - kernel hook for killing VLAN vid in hw filtering table

 * @ndev: network device

 * @proto: unused

 * @vid:  VLAN vid to kill

/**

 * bdx_change_mtu - Change the Maximum Transfer Unit

 * @ndev: network interface device structure

 * @new_mtu: new value for maximum frame size

 *

 * Returns 0 on success, negative on failure

 IMF - imperfect (hash) rx multicat filter */

 PMF - perfect rx multicat filter */

 FIXME: RXE(OFF) */

 set IMF to accept all multicast frmaes */

 set IMF to deny all multicast frames */

 set PMF to deny all multicast frames */

 use PMF to accept first MAC_MCST_NUM (15) addresses */

		/* TBD: sort addresses and write them in ascending order

		 * into RX_MAC_MCST regs. we skip this phase now and accept ALL

 accept the rest of addresses throu IMF */

 enable RX */

 FIXME: RXE(ON) */

	/*

	   if (netif_running(dev))

	   return -EBUSY

Do the statistics-update work*/

Fill HW structure */

First 12 statistics - 0x7200 - 0x72B0 */

 0x72C0-0x72E0 RSRV */

 0x7330-0x7360 RSRV */

 0x73A0-0x73B0 RSRV */

/*************************************************************************

 *     Rx DB                                                             *

			db->stack[i] = nelem - i - 1;	/* to make first allocs

/*************************************************************************

 *     Rx Init                                                           *

/**

 * bdx_rx_init - initialize RX all related HW and SW resources

 * @priv: NIC private structure

 *

 * Returns 0 on success, negative value on failure

 *

 * It creates rxf and rxd fifos, update relevant HW registers, preallocate

 * skb for rx. It assumes that Rx is desabled in HW

 * funcs are grouped for better cache usage

 *

 * RxD fifo is smaller than RxF fifo by design. Upon high load, RxD will be

 * filled and packets will be dropped by nic without getting into host or

 * cousing interrupt. Anyway, in that condition, host has no chance to process

 * all packets, but dropping in nic is cheaper, since it takes 0 cpu cycles

 TBD: ensure proper packet size */

/**

 * bdx_rx_free_skbs - frees and unmaps all skbs allocated for the fifo

 * @priv: NIC private structure

 * @f: RXF fifo

/**

 * bdx_rx_free - release all Rx resources

 * @priv: NIC private structure

 *

 * It assumes that Rx is desabled in HW

/*************************************************************************

 *     Rx Engine                                                         *

/**

 * bdx_rx_alloc_skbs - fill rxf fifo with new skbs

 * @priv: nic's private structure

 * @f: RXF fifo that needs skbs

 *

 * It allocates skbs, build rxf descs and push it (rxf descr) into rxf fifo.

 * skb's virtual and physical addresses are stored in skb db.

 * To calculate free space, func uses cached values of RPTR and WPTR

 * When needed, it also updates RPTR and WPTR.

 TBD: do not update WPTR if no desc were written */

 INFO=1 BC=3 */

TBD: to do - delayed rxf wptr like in txd */

 INFO=1 BC=3 */

/**

 * bdx_rx_receive - receives full packets from RXD fifo and pass them to OS

 * NOTE: a special treatment is given to non-continuous descriptors

 * that start near the end, wraps around and continue at the beginning. a second

 * part is copied right after the first, and then descriptor is interpreted as

 * normal. fifo has an extra space to allow such operations

 * @priv: nic's private structure

 * @f: RXF fifo that needs skbs

 * @budget: maximum number of packets to receive

 TBD: replace memcpy func call by explicite inline asm */

 Unmarshalled descriptor - copy of descriptor in host order */

 size is negative :-) */

 test for partially arrived descriptor */

skb_put(skb2, len); */

 Non-IP packets aren't checksum-offloaded */

 FIXME: do smth to minimize pci accesses    */

/*************************************************************************

 * Debug / Temprorary Code                                               *

/*

 * TX HW/SW interaction overview

 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 * There are 2 types of TX communication channels between driver and NIC.

 * 1) TX Free Fifo - TXF - holds ack descriptors for sent packets

 * 2) TX Data Fifo - TXD - holds descriptors of full buffers.

 *

 * Currently NIC supports TSO, checksuming and gather DMA

 * UFO and IP fragmentation is on the way

 *

 * RX SW Data Structures

 * ~~~~~~~~~~~~~~~~~~~~~

 * txdb - used to keep track of all skbs owned by SW and their dma addresses.

 * For TX case, ownership lasts from geting packet via hard_xmit and until HW

 * acknowledges sent by TXF descriptors.

 * Implemented as cyclic buffer.

 * fifo - keeps info about fifo's size and location, relevant HW registers,

 * usage and skb db. Each RXD and RXF Fifo has its own fifo structure.

 * Implemented as simple struct.

 *

 * TX SW Execution Flow

 * ~~~~~~~~~~~~~~~~~~~~

 * OS calls driver's hard_xmit method with packet to sent.

 * Driver creates DMA mappings, builds TXD descriptors and kicks HW

 * by updating TXD WPTR.

 * When packet is sent, HW write us TXF descriptor and SW frees original skb.

 * To prevent TXD fifo overflow without reading HW registers every time,

 * SW deploys "tx level" technique.

 * Upon strart up, tx level is initialized to TXD fifo length.

 * For every sent packet, SW gets its TXD descriptor sizei

 * (from precalculated array) and substructs it from tx level.

 * The size is also stored in txdb. When TXF ack arrives, SW fetch size of

 * original TXD descriptor from txdb and adds it to tx level.

 * When Tx level drops under some predefined treshhold, the driver

 * stops the TX queue. When TX level rises above that level,

 * the tx queue is enabled again.

 *

 * This technique avoids eccessive reading of RPTR and WPTR registers.

 * As our benchmarks shows, it adds 1.5 Gbit/sec to NIS's throuput.

/**

 * __bdx_tx_db_ptr_next - helper function, increment read/write pointer + wrap

 * @db: tx data base

 * @pptr: read or write pointer

 sanity */

 expect either read */

 or write pointer */

 pointer has to be */

 in range */

/**

 * bdx_tx_db_inc_rptr - increment read pointer

 * @db: tx data base

 can't read from empty db */

/**

 * bdx_tx_db_inc_wptr - increment write pointer

 * @db: tx data base

	BDX_ASSERT(db->rptr == db->wptr);	/* we can not get empty db as

/**

 * bdx_tx_db_init - creates and initializes tx db

 * @d: tx data base

 * @sz_type: size of tx fifo

 *

 * Returns 0 on success, error code otherwise

	/*

	 * In order to differentiate between db is empty and db is full

	 * states at least one element should always be empty in order to

	 * avoid rptr == wptr which means db is empty

 just after last element */

 all dbs are created equally empty */

/**

 * bdx_tx_db_close - closes tx db and frees all memory

 * @d: tx data base

/*************************************************************************

 *     Tx Engine                                                         *

/* sizes of tx desc (including padding if needed) as function

 qword = 64 bit */

/**

 * bdx_tx_map_skb - creates and stores dma mappings for skb's data blocks

 * @priv: NIC private structure

 * @skb: socket buffer to map

 * @txdd: TX descriptor to use

 *

 * It makes dma mappings for skb's data blocks and writes them to PBL of

 * new tx descriptor. It also stores them in the tx db, so they could be

 * unmaped after data was sent. It is reponsibility of a caller to make

 * sure that there is enough space in the tx db. Last element holds pointer

 * to skb itself and marked with zero length

 add skb clean up info. */

/* init_txd_sizes - precalculate sizes of descriptors for skbs up to 16 frags

 * number of frags is used as index to fetch correct descriptors size,

	/* 7 - is number of lwords in txd with one phys buffer

 pad it with 1 lword */

/* bdx_tx_init - initialize all Tx related stuff.

	/* The TX db has to keep mappings for all packets sent (on TxD)

/**

 * bdx_tx_space - calculates available space in TX fifo

 * @priv: NIC private structure

 *

 * Returns available space in TX fifo in bytes

/**

 * bdx_tx_transmit - send packet to NIC

 * @skb: packet to send

 * @ndev: network device assigned to NIC

 * Return codes:

 * o NETDEV_TX_OK everything ok.

 * o NETDEV_TX_BUSY Cannot transmit packet, try later

 *   Usually a bug, means queue start/stop flow control is broken in

 *   the driver. Note: the driver must NOT put the skb in its DMA ring.

 full checksum */

 build tx descriptor */

 started with valid wptr */

Cut VLAN ID to 12 bits */

	/* increment TXD write pointer. In case of

	   fifo wrapping copy reminder of the descriptor

 finished with valid wptr */

		/* Force memory writes to complete before letting h/w

		   know there are new descriptors to fetch.

		   (might be needed on platforms like IA64)

	/* Force memory writes to complete before letting h/w

	   know there are new descriptors to fetch.

	   (might be needed on platforms like IA64)

 NETIF_F_LLTX driver :( */

/**

 * bdx_tx_cleanup - clean TXF fifo, run in the context of IRQ.

 * @priv: bdx adapter

 *

 * It scans TXF fifo for descriptors, frees DMA mappings and reports to OS

 * that those packets were sent

 started with valid rptr */

 unmap all the fragments */

 first has to come tx_maps containing dma */

 '-' koz len is negative */

 now should come skb pointer - free it */

 let h/w know which TXF descriptors were cleaned */

	/* We reclaimed resources, so in case the Q is stopped by xmit callback,

/**

 * bdx_tx_free_skbs - frees all skbs from TXD fifo.

 * @priv: NIC private structure

 *

 * It gets called when OS stops this dev, eg upon "ifconfig down" or rmmod

 bdx_tx_free - frees all Tx resources */

/**

 * bdx_tx_push_desc - push descriptor to TxD fifo

 * @priv: NIC private structure

 * @data: desc's data

 * @size: desc's size

 *

 * Pushes desc to TxD fifo and overlaps it if needed.

 * NOTE: this func does not check for available space. this is responsibility

 *    of the caller. Neither does it check that data size is smaller than

 *    fifo size.

/**

 * bdx_tx_push_desc_safe - push descriptor to TxD fifo in a safe way

 * @priv: NIC private structure

 * @data: desc's data

 * @size: desc's size

 *

 * NOTE: this func does check for available space and, if necessary, waits for

 *   NIC to read existing data before writing new one.

		/* we substruct 8 because when fifo is full rptr == wptr

		   which also means that fifo is empty, we can understand

 prevent endless loop */

 give hw a chance to clean fifo */

/**

 * bdx_probe - Device Initialization Routine

 * @pdev: PCI device information struct

 * @ent: entry in bdx_pci_tbl

 *

 * Returns 0 on success, negative on failure

 *

 * bdx_probe initializes an adapter identified by a pci_dev structure.

 * The OS initialization, configuring of the adapter private structure,

 * and a hardware reset occur.

 *

 * functions and their order used as explained in

 * /usr/src/linux/Documentation/DMA-{API,mapping}.txt

 *

 TBD: netif_msg should be checked and implemented. I disable it for now */

************* pci *****************/

 it triggers interrupt, dunno why. */

 it's not a problem though */

************* netdev **************/

 ethtool interface */

		/* these fields are used for info purposes only

************* priv ****************/

 Initialize fifo sizes. */

 Initialize the initial coalescing registers. */

		/* ndev->xmit_lock spinlock is not used.

		 * Private priv->tx_lock is used for synchronization

		 * between transmit and TX irq cleanup.  In addition

		 * set multicast list callback has to use priv->tx_lock.

 MTU range: 60 - 16384 */

bdx_hw_reset(priv); */

***************** Ethtool interface *********************/

 get strings for statistics counters */

 0x7200 */

 0x7210 */

 0x7220 */

 0x7230 */

 0x7240 */

 0x7250 */

 0x7260 */

 0x7270 */

 0x7280 */

 0x7290 */

 0x72A0 */

 0x72B0 */

 0x72C0-0x72E0 RSRV */

 0x72F0 */

 0x7300 */

 0x7310 */

 0x7320 */

 0x7330-0x7360 RSRV */

 0x7370 */

 0x7380 */

 0x7390 */

 0x73A0-0x73B0 RSRV */

 0x73C0 */

 0x73D0 */

 0x73E0 */

 0x73F0 */

/*

 * bdx_get_link_ksettings - get device-specific settings

 * @netdev

 * @ecmd

/*

 * bdx_get_drvinfo - report driver information

 * @netdev

 * @drvinfo

/*

 * bdx_get_coalesce - get interrupt coalescing parameters

 * @netdev

 * @ecoal

	/* PCK_TH measures in multiples of FIFO bytes

 adaptive parameters ignored */

/*

 * bdx_set_coalesce - set interrupt coalescing parameters

 * @netdev

 * @ecoal

 Check for valid input */

 Translate from packets to multiples of FIFO bytes */

 Convert RX fifo size to number of pending packets */

 Convert TX fifo size to number of pending packets */

/*

 * bdx_get_ringparam - report ring sizes

 * @netdev

 * @ring

max_pending - the maximum-sized FIFO we allow */

/*

 * bdx_set_ringparam - set ring sizes

 * @netdev

 * @ring

Is there anything to do? */

/*

 * bdx_get_strings - return a set of strings that describe the requested objects

 * @netdev

 * @data

/*

 * bdx_get_sset_count - return number of statistics or tests

 * @netdev

/*

 * bdx_get_ethtool_stats - return device's hardware L2 statistics

 * @netdev

 * @stats

 * @data

 Update stats from HW */

 Copy data to user buffer */

/*

 * bdx_set_ethtool_ops - ethtool interface implementation

 * @netdev

/**

 * bdx_remove - Device Removal Routine

 * @pdev: PCI device information struct

 *

 * bdx_remove is called by the PCI subsystem to alert the driver

 * that it should release a PCI device.  The could be caused by a

 * Hot-Plug event, or because the driver is going to be removed from

 * memory.

bdx_hw_reset_direct(nic->regs); */

/*

 * print_driver_id - print parameters of the driver build

 SPDX-License-Identifier: GPL-2.0

/* cavium_ptp.c - PTP 1588 clock on Cavium hardware

 * Copyright (c) 2003-2015, 2017 Cavium, Inc.

/**

 * cavium_ptp_adjfine() - Adjust ptp frequency

 * @ptp_info: PTP clock info

 * @scaled_ppm: how much to adjust by, in parts per million, but with a

 *              16 bit binary fractional field

	/* The hardware adds the clock compensation value to the PTP clock

	 * on every coprocessor clock cycle. Typical convention is that it

	 * represent number of nanosecond betwen each cycle. In this

	 * convention compensation value is in 64 bit fixed-point

	 * representation where upper 32 bits are number of nanoseconds

	 * and lower is fractions of nanosecond.

	 * The scaled_ppm represent the ratio in "parts per bilion" by which the

	 * compensation value should be corrected.

	 * To calculate new compenstation value we use 64bit fixed point

	 * arithmetic on following formula

	 * comp = tbase + tbase * scaled_ppm / (1M * 2^16)

	 * where tbase is the basic compensation value calculated initialy

	 * in cavium_ptp_init() -> tbase = 1/Hz. Then we use endian

	 * independent structure definition to write data to PTP register.

/**

 * cavium_ptp_adjtime() - Adjust ptp time

 * @ptp_info:   PTP clock info

 * @delta: how much to adjust by, in nanosecs

 Sync, for network driver to get latest value */

/**

 * cavium_ptp_gettime() - Get hardware clock time with adjustment

 * @ptp_info: PTP clock info

 * @ts:  timespec

/**

 * cavium_ptp_settime() - Set hardware clock time. Reset adjustment

 * @ptp_info: PTP clock info

 * @ts:  timespec

/**

 * cavium_ptp_enable() - Request to enable or disable an ancillary feature.

 * @ptp_info: PTP clock info

 * @rq:  request

 * @on:  is it on

	/* For `cavium_ptp_get()` we need to differentiate between the case

	 * when the core has not tried to probe this device and the case when

	 * the probe failed.  In the later case we pretend that the

	 * initialization was successful and keep the error in

	 * `dev->driver_data`.

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more details.

/*

 * @file octeon_console.c

* Can change without breaking ABI */

* minimum alignment of bootmem alloced blocks */

* CVMX bootmem descriptor major version */

 CVMX bootmem descriptor minor version */

 Current versions */

 10 times per second */

/* First three members of cvmx_bootmem_desc are left in original

 * positions for backwards compatibility.

 * Assumes big endian target

* spinlock to control access to list */

* flags for indicating various conditions */

* incremented changed when incompatible changes made */

	/** incremented changed when compatible changes made,

	 *  reset to zero when major incremented

* number of elements in named blocks array */

* length of name array in bootmem blocks */

* address of named memory block descriptors */

/* Structure that defines a single console.

 *

 * Note: when read_index == write_index, the buffer is empty.

 * The actual usable size of each console is console_buf_size -1;

/* This is the main container structure that contains all the information

 * about all PCI consoles.  The address of this structure is passed to various

 * routines that operation on PCI consoles.

 must be 64 bit aligned here... */

 Array of addresses of octeon_pci_console structures */

 Implicit storage for console_addr_array */

/*

 * This function is the implementation of the get macros defined

 * for individual structure members. The argument are generated

 * by the macros inorder to read only the needed memory.

 *

 * @param oct    Pointer to current octeon device

 * @param base   64bit physical address of the complete structure

 * @param offset Offset from the beginning of the structure to the member being

 *               accessed.

 * @param size   Size of the structure member.

 *

 * @return Value of the structure member promoted into a u64.

/*

 * This function retrieves the string name of a named block. It is

 * more complicated than a simple memcpy() since the named block

 * descriptor may not be directly accessible.

 *

 * @param addr   Physical address of the named block descriptor

 * @param str    String to receive the named block string name

 * @param len    Length of the string buffer, which must match the length

 *               stored in the bootmem descriptor.

 See header file for descriptions of functions */

/*

 * Check the version information on the bootmem descriptor

 *

 * @param exact_match

 *               Exact major version to check against. A zero means

 *               check that the version supports named blocks.

 *

 * @return Zero if the version is correct. Negative if the version is

 *         incorrect. Failures also cause a message to be displayed.

/*

 * Find a named block on the remote Octeon

 *

 * @param name      Name of block to find

 * @param base_addr Address the block is at (OUTPUT)

 * @param size      The size of the block (OUTPUT)

 *

 * @return Zero on success, One on failure.

 fill this in if any sharing is needed */

 fill this in if any sharing is needed */

 Write command to bootloader */

	/* Bootloader should accept command very quickly

	 * if it really was ready

 Output a line at a time, prefixed */

			/* We need to output 'line', prefaced by 'leftover'.

			 * However, it is possible we're being called to

			 * output 'leftover' by itself (in the case of nothing

			 * having been read from the console).

			 *

			 * To avoid duplication, check for this condition.

 Save off any leftovers */

		/* Take console output regardless of whether it will

		 * be logged

	/* If nothing is read after polling the console,

	 * output any leftovers if any

 append '\n' as terminator for 'output_console_line' */

	/* Dedicate one of Octeon's BAR1 index registers to create a static

	 * mapping to a region of Octeon DRAM that contains the PCI console

	 * named block.

	/* num_consoles > 0, is an indication that the consoles

	 * are accessible

		/* Take console output regardless of whether it will

		 * be logged

	/* If nothing is read after polling the console,

	 * output any leftovers if any

 an empty string means use default debug console enablement */

/*

 * Removes all consoles

 *

 * @param oct         octeon device

	/* Check to see if any data is available.

	 * Maybe optimize this with 64-bit read.

	/* Check to see if what we want to read is not contiguous, and limit

	 * ourselves to the contiguous block

 load all images */

 Write in 4MB chunks*/

 download the image */

	/* Pass date and time information to NIC at the time of loading

	 * firmware and periodically update the host time to NIC firmware.

	 * This is to make NIC firmware use the same time reference as Host,

	 * so that it is easy to correlate logs from firmware and host for

	 * debugging.

	 *

	 * Octeon always uses UTC time. so timezone information is not sent.

 Invoke the bootcmd */

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more

 * details.

 Define this to return the request status comaptible to old code */

#define OCTEON_USE_OLD_REQ_STATUS*/

 Return 0 on success, 1 on failure */

	/* Initialize a list to holds requests that have been posted to Octeon

	 * but has yet to be fetched by octeon

 Initialize the spinlock for this instruction queue */

 Set the 32B/64B mode for each input queue */

 Return 0 on success, 1 on failure */

 make sure doorbell write goes through */

	/* This ensures that the read index does not wrap around to the same

	 * position if queue gets full before Octeon could fetch any instr.

 "index" is returned, host_write_index is modified. */

	/* Flush the command into memory. We need to be sure the data is in

	 * memory before indicating that the instruction is pending.

 Can only run in process context */

			/* We're expecting a response from Octeon.

			 * It's up to lio_process_ordered_list() to

			 * process  sc. Add sc to the ordered soft

			 * command response list because we expect

			 * a response from Octeon.

 Can only be called from process context */

 Process any outstanding IQ packets. */

/* Process instruction queue after timeout.

 * This routine gets called from a workqueue or when removing the module.

 return immediately, if no work pending */

 If jiffies - last_db_time < db_timeout do nothing  */

 Flush the instruction queue */

/* Called by the Poll thread at regular intervals to check the instruction

 * queue for commands to be posted and for commands that were fetched by Octeon.

	/* Get the lock and prevent other tasks and tx interrupt handler from

	 * running.

	/* This is only done here to expedite packets being flushed

	 * for cases where there are no IQ completion interrupts.

 opcode/subcode specific parameters (ossp) */

PKI IH3*/

 pki_ih3 irh+ossp[0]+ossp[1]+rdp+rptr = 48 bytes */

PKI IH3*/

 pki_h3 + irh + ossp[0] + ossp[1] = 32 bytes */

 opcode/subcode specific parameters (ossp) */

 irh+ossp[0]+ossp[1]+rdp+rptr = 40 bytes */

 irh + ossp[0] + ossp[1] = 24 bytes */

 lock for response_list */

 timeout; move sc to zombie list */

 lock for response_list */

 Start data at 128 byte boundary */

 Start rdata at 128 byte boundary */

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more details.

		/* Prevent service of instruction queue for all DMA engines

		 * Engine 5 will remain 0. Engines 0 - 4 will be setup by

		 * core.

	/* DPI_SLI_PRT_CFG has MPS and MRRS settings that will be set

	 * separately.

 68XX specific */

 clear out NUMP field */

 put max_oqs in NUMP field */

 Disable per-port backpressure. */

	/* Default error timeout value should be 0x200000 to avoid host hang

	 * when reads invalid register

 Set M_VEND1_DRP and M_VEND0_DRP bits */

 Determine variant of card */

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more details.

/**

 * pcierror_quiesce_device - Cause device to go quiet so it can be safely removed/reset/etc

 * @oct: Pointer to Octeon device

	/* Disable the input and output queues now. No more packets will

	 * arrive from Octeon, but we should wait for all packet processing

	 * to finish.

 To allow for in-flight requests */

 Force all requests waiting to be fetched by OCTEON to complete. */

 Force all pending ordered list requests to time out. */

 We do not need to wait for output queue packets to be processed. */

/**

 * cleanup_aer_uncorrect_error_status - Cleanup PCI AER uncorrectable error status

 * @dev: Pointer to PCI device

 Clear corresponding nonfatal bits */

 Clear corresponding fatal bits */

/**

 * stop_pci_io - Stop all PCI IO to a given device

 * @oct: Pointer to Octeon device

 No more instructions will be forwarded. */

 Disable interrupts  */

 clear the affinity_cpumask */

 making it a common function for all OCTEON models */

/**

 * liquidio_pcie_error_detected - called when PCI error is detected

 * @pdev: Pointer to PCI device

 * @state: The current pci connection state

 *

 * This function is called after a PCI bus error affecting

 * this device has been detected.

 Non-correctable Non-fatal errors */

 Non-correctable Fatal errors */

 For PCI-E Advanced Error Recovery (AER) Interface */

 For AER */

/**

 * print_link_info - Print link information

 * @netdev: network device

/**

 * octnet_link_status_change - Routine to notify MTU change

 * @work: work_struct data structure

	/* lio->linfo.link.s.mtu always contains max MTU of the lio interface.

	 * this API is invoked only when new max-MTU of the interface is

	 * less than current MTU.

/**

 * setup_link_status_change_wq - Sets up the mtu status change work

 * @netdev: network device

/**

 * update_link_status - Update link status

 * @netdev: network device

 * @ls: link status structure

 *

 * Called on receipt of a link status response from the core application to

 * update each interface's link status.

/**

 * liquidio_vf_probe - PCI probe handler

 * @pdev: PCI device structure

 * @ent: unused

 Assign octeon_device for this device to the private data area. */

 set linux specific device pointer */

/**

 * octeon_pci_flr - PCI FLR for each Octeon device.

 * @oct: octeon device

 Quiesce the device completely */

/**

 * octeon_destroy_resources - Destroy resources associated with octeon device

 * @oct: octeon device

 No more instructions will be forwarded. */

		/* Disable the input and output queues now. No more packets will

		 * arrive from Octeon, but we should wait for all packet

		 * processing to finish.

		/* Force all requests waiting to be fetched by OCTEON to

		 * complete.

 Disable interrupts  */

 Soft reset the octeon device before exiting */

 Disable the device, releasing the PCI INT */

 Nothing to be done here either */

/**

 * send_rx_ctrl_cmd - Send Rx control command

 * @lio: per-network private data

 * @start_stop: whether to start or stop

		/* Sleep on a wait queue till the cond flag indicates that the

		 * response arrived or timed-out.

/**

 * liquidio_destroy_nic_device - Destroy NIC device interface

 * @oct: octeon device

 * @ifidx: which interface to destroy

 *

 * Cleanup associated with each interface for an Octeon device  when NIC

 * module is being unloaded or if initialization fails during load.

 Delete NAPI */

/**

 * liquidio_stop_nic_module - Stop complete NIC functionality

 * @oct: octeon device

/**

 * liquidio_vf_remove - Cleans up resources at unload time

 * @pdev: PCI device structure

	/* Reset the octeon device and cleanup all memory allocated for

	 * the octeon device by driver.

	/* This octeon device has been removed. Update the global

	 * data structure to reflect this. Free the device structure.

/**

 * octeon_pci_os_setup - PCI initialization for each Octeon device.

 * @oct: octeon device

 setup PCI stuff first */

 Enable PCI DMA Master. */

/**

 * free_netbuf - Unmap and free network buffer

 * @buf: buffer

/**

 * free_netsgbuf - Unmap and free gather buffer

 * @buf: buffer

/**

 * free_netsgbuf_with_resp - Unmap and free gather buffer with response

 * @buf: buffer

 Don't free the skb yet */

/**

 * liquidio_open - Net device open for LiquidIO

 * @netdev: network device

 Ready for link status updates */

 tell Octeon to start forwarding packets to host */

/**

 * liquidio_stop - jNet device stop for LiquidIO

 * @netdev: network device

 tell Octeon to stop forwarding packets to host */

 Inform that netif carrier is down */

 Wait for any pending Rx descriptors */

/**

 * get_new_flags - Converts a mask based on net device flags

 * @netdev: network device

 *

 * This routine generates a octnet_ifflags mask from the net device flags

 * received from the OS.

		/* Accept all multicast addresses if there are more than we

		 * can handle

 copy all the addresses into the udd */

/**

 * liquidio_set_mcast_list - Net device set_multicast_list

 * @netdev: network device

 Create a ctrl pkt command to be sent to core app. */

 copy all the addresses into the udd */

 no need to swap bytes */

	/* Apparently, any activity in this call from the kernel has to

	 * be atomic. So we won't wait for response.

/**

 * liquidio_set_mac - Net device set_mac_address

 * @netdev: network device

 * @p: opaque pointer to sockaddr

 The MAC Address is presented in network byte order. */

 detailed rx_errors: */

 recved pkt with crc error */

 recv'd frame alignment error */

 detailed tx_errors */

/**

 * hwtstamp_ioctl - Handler for SIOCSHWTSTAMP ioctl

 * @netdev: network device

 * @ifr: interface request

/**

 * liquidio_ioctl - ioctl handler

 * @netdev: network device

 * @ifr: interface request

 * @cmd: command

/* send_nic_timestamp_pkt - Send a data packet that will be timestamped

 * @oct: octeon device

 * @ndata: pointer to network data

 * @finfo: pointer to private network data

/**

 * liquidio_xmit - Transmit networks packets to the Octeon interface

 * @skb: skbuff struct to be passed to network layer.

 * @netdev: pointer to network device

 * @returns whether the packet was transmitted to the device okay or not

 *             (NETDEV_TX_OK or NETDEV_TX_BUSY)

	/* Check for all conditions in which the current packet cannot be

	 * transmitted.

	/* Use space in skb->cb to store info used to unmap and

	 * free the buffers.

 Prepare the attributes for the data to be passed to OSI. */

 defer sending if queue is full */

 Offload checksum calculation for TCP/UDP packets */

 HW insert VLAN tag */

/**

 * liquidio_tx_timeout - Network device Tx timeout

 * @netdev: pointer to network device

 * @txqueue: index of the hung transmit queue

/** Sending command to enable/disable RX checksum offload

 * @param netdev                pointer to network device

 * @param command               OCTNET_CMD_TNL_RX_CSUM_CTL

 * @param rx_cmd_bit            OCTNET_CMD_RXCSUM_ENABLE/

 *                              OCTNET_CMD_RXCSUM_DISABLE

 * @returns                     SUCCESS or FAILURE

/** Sending command to add/delete VxLAN UDP port to firmware

 * @param netdev                pointer to network device

 * @param command               OCTNET_CMD_VXLAN_PORT_CONFIG

 * @param vxlan_port            VxLAN port to be added or deleted

 * @param vxlan_cmd_bit         OCTNET_CMD_VXLAN_PORT_ADD,

 *                              OCTNET_CMD_VXLAN_PORT_DEL

 * @returns                     SUCCESS or FAILURE

/** \brief Net device fix features

 * @param netdev  pointer to network device

 * @param request features requested

 * @returns updated features list

 Disable LRO if RXCSUM is off */

/** \brief Net device set features

 * @param netdev  pointer to network device

 * @param features features to enable/disable

/**

 * setup_nic_devices - Setup network interfaces

 * @octeon_dev:  octeon device

 *

 * Called during init time for each device. It assumes the NIC

 * is already up and running.  The link information for each

 * interface is passed in link_info.

 This is to handle link status changes */

	/* REQTYPE_RESP_NET and REQTYPE_SOFT_COMMAND do not have free functions.

	 * They are handled directly.

 Soft instr is freed by driver in case of failure. */

		/* Sleep on a wait queue till the cond flag indicates that the

		 * response arrived or timed-out.

		/* Associate the routines that will handle different

		 * netdev tasks.

		/* Copy of transmit encapsulation capabilities:

		 * TSO, TSO6, Checksums for this device

 Add any unchangeable hw features */

 MTU range: 68 - 16000 */

		/* Point to the  properties for octeon device to which this

		 * interface belongs.

 64-bit swap required on LE machines */

 Copy MAC Address to OS network device structure */

		/* For VFs, enable Octeon device interrupts here,

		 * as this is contingent upon IO queue setup

		/* By default all interfaces on a single Octeon uses the same

		 * tx and rx queues

 Register ethtool support */

 Register the network device with the OS */

		/* Sending command to firmware to enable Rx checksum offload

		 * by default at the time of setup of Liquidio driver for

		 * this device

/**

 * liquidio_init_nic_module - initialize the NIC

 * @oct: octeon device

 *

 * This initialization routine is called once the Octeon device application is

 * up and running

	/* only default iq and oq were initialized

	 * initialize the rest as well run port_config command for each port

/**

 * octeon_device_init - Device initialization for each Octeon device that is probed

 * @oct:  octeon device

	/* Enable access to the octeon device and make its DMA capability

	 * known to the OS.

	/* Initialize the dispatch mechanism used to push packets arriving on

	 * Octeon Output queues.

 Initialize soft command buffer pool */

 Setup the data structures that manage this Octeon's Input queues. */

	/* Initialize lists to manage the requests of different types that

	 * arrive from user & kernel applications for this octeon device.

 Setup the interrupt handler and record the INT SUM register address*/

	/* ***************************************************************

	 * The interrupts need to be enabled for the PF<-->VF handshake.

	 * They are [re]-enabled after the PF<-->VF handshake so that the

	 * correct OQ tick value is used (i.e. the value retrieved from

	 * the PF as part of the handshake).

 Enable Octeon device interrupts */

	/* Here we [re]-enable the interrupts so that the correct OQ tick value

	 * is used (i.e. the value that was retrieved during the handshake)

 Enable Octeon device interrupts */

 *************************************************************** */

 Enable the input and output queues for this Octeon device */

	/* Send Credit for Octeon Output queues. Credits are always sent after

	 * the output queue is enabled.

 Packets can start arriving on the output queues from this point. */

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more details.

 Octeon's interface mode of operation */

 statistics of PF */

 statistics of VF */

 statistics of host tx queue */

 statistics of host rx queue */

 LiquidIO driver private flags */

FEC_OFF*/

 ETHTOOL_FEC_RS */

 ETHTOOL_FEC_OFF */

 VF */

	/* Disable the input and output queues now. No more packets will

	 * arrive from Octeon.

 clear the affinity_cpumask */

 non-iov vector's argument is oct struct */

 Enable Octeon device interrupts */

/* This routine provides PHY access routines for

 * mdio  clause45 .

		/* Sleep on a wait queue till the cond flag indicates that the

		 * response arrived

 Save the current LED settings */

 Configure Beacon values */

 Restore LED settings */

	/* Disable the input and output queues now. No more packets will

	 * arrive from Octeon.

 Delete NAPI */

		/* The value of queue_count_update decides whether it is the

		 * queue count or the descriptor count that is being

		 * re-configured.

	/* Re-configuration of queues can happen in two scenarios, SRIOV enabled

	 * and SRIOV disabled. Few things like recreating queue zero, resetting

	 * glists and IRQs are required for both. For the latter, some more

	 * steps like updating sriov_info for the octeon device need to be done.

		/* Delete mbox for PF which is SRIOV disabled because sriov_info

		 * will be now changed.

 For PF re-configure sriov related information */

	/* The following are needed in case of queue count re-configuration and

	 * not for descriptor count re-configuration.

 Recreating mbox for PF that is SRIOV disabled */

		/* Deleting and recreating IRQs whether the interface is SRIOV

		 * enabled or disabled.

 Enable the input and output queues for this Octeon device */

		/* Informing firmware about the new queue count. It is required

		 * for firmware to allocate more number of queues than those at

		 * load time.

 Once firmware is aware of the new value, queues can be recreated */

		/* Send firmware the information about new number of queues

		 * if the interface is a VF or a PF that is SRIOV enabled.

 Change RX/TX DESCS  count */

	/* Notes: Not supporting any auto negotiation in these

	 * drivers. Just report pause frame support.

	/* Notes: Not supporting any auto negotiation in these

	 * drivers.

no flow control for half duplex*/

do not support autoneg of link flow control*/

enable rx pause*/

disable rx pause*/

enable tx pause*/

disable tx pause*/

sum of oct->droq[oq_no]->stats->rx_pkts_received */

sum of oct->instr_queue[iq_no]->stats.tx_done */

sum of oct->droq[oq_no]->stats->rx_bytes_received */

sum of oct->instr_queue[iq_no]->stats.tx_tot_bytes */

	/*sum of oct->droq[oq_no]->stats->rx_dropped +

	 *oct->droq[oq_no]->stats->dropped_nodispatch +

	 *oct->droq[oq_no]->stats->dropped_toomany +

	 *oct->droq[oq_no]->stats->dropped_nomem

sum of oct->instr_queue[iq_no]->stats.tx_dropped */

 firmware tx stats */

	/*per_core_stats[cvmx_get_core_num()].link_stats[mdata->from_ifidx].

	 *fromhost.fw_total_sent

per_core_stats[i].link_stats[port].fromwire.fw_total_fwd */

per_core_stats[j].link_stats[i].fromhost.fw_err_pko */

per_core_stats[j].link_stats[i].fromhost.fw_err_pki */

per_core_stats[j].link_stats[i].fromhost.fw_err_link */

	/*per_core_stats[cvmx_get_core_num()].link_stats[idx].fromhost.

	 *fw_err_drop

per_core_stats[cvmx_get_core_num()].link_stats[idx].fromhost.fw_tso */

	/*per_core_stats[cvmx_get_core_num()].link_stats[idx].fromhost.

	 *fw_tso_fwd

	/*per_core_stats[cvmx_get_core_num()].link_stats[idx].fromhost.

	 *fw_err_tso

	/*per_core_stats[cvmx_get_core_num()].link_stats[idx].fromhost.

	 *fw_tx_vxlan

 Multicast packets sent by this port */

 mac tx statistics */

CVMX_BGXX_CMRX_TX_STAT5 */

CVMX_BGXX_CMRX_TX_STAT4 */

CVMX_BGXX_CMRX_TX_STAT15 */

CVMX_BGXX_CMRX_TX_STAT14 */

CVMX_BGXX_CMRX_TX_STAT17 */

CVMX_BGXX_CMRX_TX_STAT0 */

CVMX_BGXX_CMRX_TX_STAT3 */

CVMX_BGXX_CMRX_TX_STAT2 */

CVMX_BGXX_CMRX_TX_STAT0 */

CVMX_BGXX_CMRX_TX_STAT1 */

CVMX_BGXX_CMRX_TX_STAT16 */

CVMX_BGXX_CMRX_TX_STAT6 */

 RX firmware stats */

	/*per_core_stats[cvmx_get_core_num()].link_stats[ifidx].fromwire.

	 *fw_total_rcvd

	/*per_core_stats[cvmx_get_core_num()].link_stats[ifidx].fromwire.

	 *fw_total_fwd

 Multicast packets received on this port */

per_core_stats[core_id].link_stats[ifidx].fromwire.jabber_err */

per_core_stats[core_id].link_stats[ifidx].fromwire.l2_err */

per_core_stats[core_id].link_stats[ifidx].fromwire.frame_err */

	/*per_core_stats[cvmx_get_core_num()].link_stats[ifidx].fromwire.

	 *fw_err_pko

per_core_stats[j].link_stats[i].fromwire.fw_err_link */

	/*per_core_stats[cvmx_get_core_num()].link_stats[lro_ctx->ifidx].

	 *fromwire.fw_err_drop

	/*per_core_stats[cvmx_get_core_num()].link_stats[lro_ctx->ifidx].

	 *fromwire.fw_rx_vxlan

	/*per_core_stats[cvmx_get_core_num()].link_stats[lro_ctx->ifidx].

	 *fromwire.fw_rx_vxlan_err

 LRO */

	/*per_core_stats[cvmx_get_core_num()].link_stats[ifidx].fromwire.

	 *fw_lro_pkts

	/*per_core_stats[cvmx_get_core_num()].link_stats[ifidx].fromwire.

	 *fw_lro_octs

per_core_stats[j].link_stats[i].fromwire.fw_total_lro */

per_core_stats[j].link_stats[i].fromwire.fw_lro_aborts */

	/*per_core_stats[cvmx_get_core_num()].link_stats[ifidx].fromwire.

	 *fw_lro_aborts_port

	/*per_core_stats[cvmx_get_core_num()].link_stats[ifidx].fromwire.

	 *fw_lro_aborts_seq

	/*per_core_stats[cvmx_get_core_num()].link_stats[ifidx].fromwire.

	 *fw_lro_aborts_tsval

	/*per_core_stats[cvmx_get_core_num()].link_stats[ifidx].fromwire.

	 *fw_lro_aborts_timer

 intrmod: packet forward rate */

per_core_stats[j].link_stats[i].fromwire.fw_lro_aborts */

 mac: link-level stats */

CVMX_BGXX_CMRX_RX_STAT0 */

CVMX_BGXX_CMRX_RX_STAT1 */

CVMX_PKI_STATX_STAT5 */

CVMX_PKI_STATX_STAT5 */

wqe->word2.err_code or wqe->word2.err_level */

CVMX_BGXX_CMRX_RX_STAT2 */

CVMX_BGXX_CMRX_RX_STAT6 */

CVMX_BGXX_CMRX_RX_STAT4 */

wqe->word2.err_code or wqe->word2.err_level */

lio->link_changes*/

packets to network port*/

# of packets tx to network */

# of bytes tx to network */

# of packets dropped */

# of tx fails due to queue full */

XXX gather entries sent */

instruction to firmware: data and control */

# of instructions to the queue */

# of instructions processed */

# of instructions could not be processed */

bytes sent through the queue */

tso request*/

vxlan request*/

txq restart*/

 RX */

packets send to TCP/IP network stack */

# of packets to network stack */

# of bytes to network stack */

# of packets dropped */

control and data path*/

 sum of oct->droq[oq_no]->stats->rx_pkts_received */

 sum of oct->instr_queue[iq_no]->stats.tx_done */

 sum of oct->droq[oq_no]->stats->rx_bytes_received */

 sum of oct->instr_queue[iq_no]->stats.tx_tot_bytes */

	 /* sum of oct->droq[oq_no]->stats->rx_dropped +

	  * oct->droq[oq_no]->stats->dropped_nodispatch +

	  * oct->droq[oq_no]->stats->dropped_toomany +

	  * oct->droq[oq_no]->stats->dropped_nomem

 sum of oct->instr_queue[iq_no]->stats.tx_dropped */

 lio->link_changes */

 packets to network port */

 # of packets tx to network */

 # of bytes tx to network */

 # of packets dropped */

 # of tx fails due to queue full */

 XXX gather entries sent */

 instruction to firmware: data and control */

 # of instructions to the queue */

 # of instructions processed */

 # of instructions could not be processed */

 bytes sent through the queue */

 tso request */

 vxlan request */

 txq restart */

 RX */

 packets send to TCP/IP network stack */

 # of packets to network stack */

 # of bytes to network stack */

 control and data path */

  get interrupt moderation parameters */

 Alloc soft command */

	/* Sleep on a wait queue till the cond flag indicates that the

	 * response arrived or timed-out.

  Configure interrupt moderation parameters */

 Alloc soft command */

	/* Sleep on a wait queue till the cond flag indicates that the

	 * response arrived or timed-out.

 Enable/Disable auto interrupt Moderation */

 Config Cnt based interrupt values */

consider setting resend bit*/

consider writing to resend bit here*/

 Config Time based interrupt values */

consider writing to resend bit here*/

consider setting resend bit*/

 Config Cnt based interrupt values */

clear wmark and count.dont want to write count back*/

consider setting resend bit*/

 Return register dump len. */

 PCI  Window Registers */

0x29030 or 0x29040*/

0x27080 or 0x27090*/

0x27000 or 0x27010*/

0x29120*/

0x27300*/

0x27200*/

29130*/

0x29140*/

0x29160*/

0x29180*/

0x291E0*/

0x29210*/

0x29220*/

PF only*/

0x29260*/

0x29270*/

0x10040*/

0x10080*/

0x10090*/

0x10050*/

0x10070*/

0x100a0*/

0x100b0*/

0x100c0*/

0x10000*/

0x10010*/

0x10020*/

0x10030*/

0x10040*/

 PCI  Window Registers */

 PCI  Window Registers */

 PCI  Interrupt Register */

 PCI  Output queue registers */

 PCI  Input queue registers */

 PCI  DMA registers */

 PCI  Index registers */

 PCI CONFIG Registers */

  Return register dump user app.  */

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more details.

/* Change the value of SLI Packet Input Jabber Register to allow

 * VXLAN TSO packets which can be 64424 bytes, exceeding the

 * MAX_GSO_SIZE we supplied to the kernel

In cn23xx_soft_reset*/

In cn23xx_set_dpi_regs*/

In cn23xx_setup_pcie_mps and cn23xx_setup_pcie_mrrs */

In cn23xx_specific_regs_setup */

In cn23xx_setup_global_mac_regs*/

In cn23xx_setup_global_input_regs*/

In cn23xx_setup_global_output_regs*/

In cn23xx_enable_interrupt and cn23xx_disable_interrupt*/

In cn23xx_setup_iq_regs*/

In cn23xx_setup_oq_regs*/

 Initiate chip-wide soft reset */

 Wait for 100ms as Octeon resets. */

 restore the  reset value*/

 Enable Link error reporting */

	/* Bits 29:24 of RST_BOOT[PNR_MUL] holds the ref.clock MULTIPLIER

	 * for SLI.

 TBD: get the info in Hand-shake */

 This gives the SLI clock per microsec */

 This gives the clock cycles per millisecond */

 This gives the oq ticks (1024 core clock cycles) per millisecond */

	/* time_intr is in microseconds. The next 2 steps gives the oq ticks

	 *  corressponding to time_intr.

 programming SRN and TRS for each MAC(0..3)  */

 By default, mapping all 64 IOQs to  a single MACs */

 setting SRN <6:0>  */

 setting SRN <6:0>  */

 setting TRS <23:16> */

 setting RPVF <39:32> */

 setting NVFS <55:48> */

 write these settings to MAC register */

As per HRM reg description, s/w cant write 0 to ENB. */

to make the queue off, need to set the RST bit. */

 Reset the Enable bit for all the 64 IQs.  */

 set RST bit to 1. This bit applies to both IQ and OQ */

wait until the RST bit is clear or the RST and quite bits are set*/

	/** Set the MAC_NUM and PVF_NUM in IQ_PKT_CONTROL reg

	 * for all queues.Only PF can set these bits.

	 * bits 29:30 indicate the MAC num.

	 * bits 32:47 indicate the PVF num.

 for VF assigned queues. */

 VF1, VF2,........ */

	/* Select ES, RO, NS, RDSIZE,DPTR Fomat#0 for

	 * pf queues

 Set WMARK level for triggering PI_INT */

 intr_threshold = CN23XX_DEF_IQ_INTR_THRESHOLD & */

* Set Output queue watermark to 0 to disable backpressure */

 clear IPTR */

 set DPTR */

 reset BMODE */

		/* No Relaxed Ordering, No Snoop, 64-bit Byte swap

		 * for Output Queue ScatterList

		 * reset ROR_P, NSR_P

		/* No Relaxed Ordering, No Snoop, 64-bit Byte swap

		 * for Output Queue Data

		 * reset ROR, NSR

 set the ES bit */

 write all the selected settings */

		/* Enabling these interrupt in oct->fn_list.enable_interrupt()

		 * routine which called after IOQ init.

		 * Set up interrupt packet and time thresholds

		 * for all the OQs

* Setting the water mark level for pko back pressure **/

	/** Disabling setting OQs in reset when ring has no dorebells

	 * enabling this will cause of head of line blocking

 Do it only for pass1.1. and pass1.2 */

* Enable channel-level backpressure */

 program the MAC(0..3)_RINFO before setting up input/output regs */

	/* Default error timeout value should be 0x200000 to avoid host hang

	 * when reads invalid register

 set SLI_PKT_IN_JABBER to handle large VXLAN packets */

 Write the start of the input queue's ring and its size  */

	/* Remember the doorbell & instruction count register addr

	 * for this queue

	/* Store the current instruction counter (used in flush_iq

	 * calculation)

 Set CINT_ENB to enable IQ interrupt   */

		/* Clear the count by writing back what we read, but don't

		 * enable interrupts

 Get the mapped address of the pkt_sent and pkts_credit regs */

		/* Enable this output queue to generate Packet Timer Interrupt

		/* Enable this output queue to generate Packet Count Interrupt

read and clear by writing 1*/

 PF mbox interrupt reg */

 PF writes into SIG0 reg */

 PF reads from SIG1 reg */

Mail Box Thread creation*/

 set the corresponding IQ IS_64B bit */

 set the corresponding IQ ENB bit */

			/* IOQs are in reset by default in PEM2 mode,

			 * clearing reset bit

 set the corresponding OQ ENB bit */

** Disable Input Queues. ***/

 start the Reset for a particular ring */

		/* Wait until hardware indicates that the particular IQ

		 * is out of reset.

 Reset the doorbell register for this Input Queue. */

** Disable Output Queues. ***/

		/* Wait until hardware indicates that the particular IQ

		 * is out of reset.It given that SLI_PKT_RING_RST is

		 * common for both IQs and OQs

 Reset the doorbell register for this Output Queue. */

 clear the SLI_PKT(0..63)_CNTS[CNT] reg value */

	/* If our device has interrupted, then proceed. Also check

	 * for all f's if interrupt was triggered on an error

	 * and the PCI read fails.

 Write count reg in sli_pkt_cnts to clear these int.*/

 We will clear the count when we update the read_index. */

	/* Never need to handle msix mbox intr for pf. They arrive on the last

	 * msix

 When VFs write into MBOX_SIG2 reg,these intr is set in PF */

 Clear the current interrupts */

	/*  The PEM(0..3)_BAR1_INDEX(0..15)[ADDR_IDX]<23:4> stores

	 *  bits <41:22> of the Core Addr

 always call with lock held */

	/* Modulo of the new index with the IQ size will give us

	 * the new index.  The iq->reset_instr_cnt is always zero for

	 * cn23xx, so no extra adjustments are needed.

  Divide the single write to multiple writes based on the flag. */

 Enable Interrupt */

 Disable Interrupts */

* Read Function Dependency Link reg to get the function number */

		/* Under some virtual environments, extended PCI regs are

		 * inaccessible, in which case the above read will have failed.

		 * In this case, read the PF number from the

		 * SLI_PKT0_INPUT_CONTROL reg (written by f/w)

 validate PF num by reading RINFO; f/w writes RINFO.trs == 1*/

 the first ring of the pf */

	/* If there's more than one active PF on this NIC, then that

	 * implies that the NIC firmware is loaded and running.  This check

	 * prevents a rare false negative that might occur if we only relied

	 * on checking the SCR2_BIT_FW_LOADED flag.  The false negative would

	 * happen if the PF driver sees SCR2_BIT_FW_LOADED as cleared even

	 * though the firmware was already loaded but still booting and has yet

	 * to set SCR2_BIT_FW_LOADED.

 1sec

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more details.

/**

 * octeon_mbox_read:

 * @mbox: Pointer mailbox

 *

 * Reads the 8-bytes of data from the mbox register

 * Writes back the acknowldgement inidcating completion of read

/**

 * octeon_mbox_write:

 * @oct: Pointer Octeon Device

 * @mbox_cmd: Cmd to send to mailbox.

 *

 * Populates the queue specific mbox structure

 * with cmd information.

 * Write the cmd to mbox register

/**

 * octeon_mbox_process_cmd:

 * @mbox: Pointer mailbox

 * @mbox_cmd: Pointer to command received

 *

 * Process the cmd received in mbox

 VF version is in mbox_cmd->data[0] */

 Sending core cofig info to the corresponding active VF.*/

/**

 * octeon_mbox_process_message

 * @mbox: mailbox

 *

 * Process the received mbox message.

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2017 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more details.

 Swap tx and rx stats as VF rep is a switch port */

	/* ifidx 1-63 for PF0 VFs

	 * ifidx 65-127 for PF1 VFs

	/* Multiple buffers are not used for vf_rep packets.

	 * So just buffer_size[0] is valid.

 Multiple buffers are not used for vf_rep packets. */

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more details.

/**

 * octeon_console_debug_enabled - determines if a given console has debug enabled.

 * @console: console to check

 * Return:  1 = enabled. 0 otherwise

 Polling interval for determining when NIC application is alive */

 runtime link query interval */

/* update localtime to octeon firmware every 60 seconds.

 * make firmware to use same time reference, so that it will be easy to

 * correlate firmware logged events/errors with host events, for debugging.

 time to wait for possible in-flight requests in milliseconds */

/* Octeon device properties to be used by the NIC module.

 * Each octeon device in the system will be represented

 * by this structure in the NIC module.

			/* set time and cnt interrupt thresholds for this DROQ

			 * for NAPI

/**

 * force_io_queues_off - Forces all IO queues off on a given device

 * @oct: Pointer to Octeon device

 Reset the Enable bits for Input Queues. */

 Reset the Enable bits for Output Queues. */

/**

 * pcierror_quiesce_device - Cause device to go quiet so it can be safely removed/reset/etc

 * @oct: Pointer to Octeon device

	/* Disable the input and output queues now. No more packets will

	 * arrive from Octeon, but we should wait for all packet processing

	 * to finish.

 To allow for in-flight requests */

 Force all requests waiting to be fetched by OCTEON to complete. */

 Force all pending ordered list requests to time out. */

 We do not need to wait for output queue packets to be processed. */

/**

 * cleanup_aer_uncorrect_error_status - Cleanup PCI AER uncorrectable error status

 * @dev: Pointer to PCI device

 Clear corresponding nonfatal bits */

 Clear corresponding fatal bits */

/**

 * stop_pci_io - Stop all PCI IO to a given device

 * @oct: Pointer to Octeon device

 No more instructions will be forwarded. */

 Disable interrupts  */

 Release the interrupt line */

 making it a common function for all OCTEON models */

/**

 * liquidio_pcie_error_detected - called when PCI error is detected

 * @pdev: Pointer to PCI device

 * @state: The current pci connection state

 *

 * This function is called after a PCI bus error affecting

 * this device has been detected.

 Non-correctable Non-fatal errors */

 Non-correctable Fatal errors */

	/* Always return a DISCONNECT. There is no support for recovery but only

	 * for a clean shutdown.

/**

 * liquidio_pcie_mmio_enabled - mmio handler

 * @pdev: Pointer to PCI device

	/* We should never hit this since we never ask for a reset for a Fatal

	 * Error. We always return DISCONNECT in io_error above.

	 * But play safe and return RECOVERED for now.

/**

 * liquidio_pcie_slot_reset - called after the pci bus has been reset.

 * @pdev: Pointer to PCI device

 *

 * Restart the card from scratch, as if from a cold-boot. Implementation

 * resembles the first-half of the octeon_resume routine.

	/* We should never hit this since we never ask for a reset for a Fatal

	 * Error. We always return DISCONNECT in io_error above.

	 * But play safe and return RECOVERED for now.

/**

 * liquidio_pcie_resume - called when traffic can start flowing again.

 * @pdev: Pointer to PCI device

 *

 * This callback is called when the error recovery driver tells us that

 * its OK to resume normal operation. Implementation resembles the

 * second-half of the octeon_resume routine.

 Nothing to be done here. */

 For PCI-E Advanced Error Recovery (AER) Interface */

 68xx */

 66xx */

 23xx pf */

 For AER */

/**

 * liquidio_init_pci - register PCI driver

/**

 * liquidio_deinit_pci - unregister PCI driver

/**

 * check_txq_status - Check Tx queue status, and take appropriate action

 * @lio: per-network private data

 * Return: 0 if full, number of queues woken up otherwise

 check each sub-queue state */

/**

 * print_link_info -  Print link information

 * @netdev: network device

/**

 * octnet_link_status_change - Routine to notify MTU change

 * @work: work_struct data structure

	/* lio->linfo.link.s.mtu always contains max MTU of the lio interface.

	 * this API is invoked only when new max-MTU of the interface is

	 * less than current MTU.

/**

 * setup_link_status_change_wq - Sets up the mtu status change work

 * @netdev: network device

/**

 * update_link_status - Update link status

 * @netdev: network device

 * @ls: link status structure

 *

 * Called on receipt of a link status response from the core application to

 * update each interface's link status.

/**

 * lio_sync_octeon_time - send latest localtime to octeon firmware so that

 * firmware will correct it's time, in case there is a time skew

 *

 * @work: work scheduled to send time update to octeon firmware

 Get time of the day */

/**

 * setup_sync_octeon_time_wq - prepare work to periodically update local time to octeon firmware

 *

 * @netdev: network device which should send time update to firmware

/**

 * cleanup_sync_octeon_time_wq - destroy wq

 *

 * @netdev: network device which should send time update to firmware

 *

 * Stop scheduling and destroy the work created to periodically update local

 * time to octeon firmware.

 sleep for a couple of seconds so that we don't hog the CPU */

/**

 * liquidio_probe - PCI probe handler

 * @pdev: PCI device structure

 * @ent: unused

 Enable PTP for 6XXX Device */

 Assign octeon_device for this device to the private data area. */

 set linux specific device pointer */

 first LiquidIO NIC is detected */

			/* Each NIC gets one watchdog kernel thread.  The first

			 * PF (of each NIC) that gets pci_driver->probe()'d

			 * creates that thread.

/**

 * octeon_pci_flr - PCI FLR for each Octeon device.

 * @oct: octeon device

 Quiesce the device completely */

/**

 * octeon_destroy_resources - Destroy resources associated with octeon device

 * @oct: octeon device

 No more instructions will be forwarded. */

 Remove any consoles */

		/* Disable the input and output queues now. No more packets will

		 * arrive from Octeon, but we should wait for all packet

		 * processing to finish.

		/* Force all requests waiting to be fetched by OCTEON to

		 * complete.

 Disable interrupts  */

 clear the affinity_cpumask */

 non-iov vector's argument is oct struct */

 Release the interrupt line */

 Wait for any pending operations */

 Force any pending handshakes to complete */

		/* Soft reset the octeon device before exiting.

		 * However, if fw was loaded from card (i.e. autoboot),

		 * perform an FLR instead.

		 * Implementation note: only soft-reset the device

		 * if it is a CN6XXX OR the LAST CN23XX device.

 Disable the device, releasing the PCI INT */

 Nothing to be done here either */

 end switch (oct->status) */

/**

 * send_rx_ctrl_cmd - Send Rx control command

 * @lio: per-network private data

 * @start_stop: whether to start or stop

		/* Sleep on a wait queue till the cond flag indicates that the

		 * response arrived or timed-out.

/**

 * liquidio_destroy_nic_device - Destroy NIC device interface

 * @oct: octeon device

 * @ifidx: which interface to destroy

 *

 * Cleanup associated with each interface for an Octeon device  when NIC

 * module is being unloaded or if initialization fails during load.

 Delete NAPI */

/**

 * liquidio_stop_nic_module - Stop complete NIC functionality

 * @oct: octeon device

/**

 * liquidio_remove - Cleans up resources at unload time

 * @pdev: PCI device structure

	/* Reset the octeon device and cleanup all memory allocated for

	 * the octeon device by driver.

	/* This octeon device has been removed. Update the global

	 * data structure to reflect this. Free the device structure.

/**

 * octeon_chip_specific_setup - Identify the Octeon device and to map the BAR address space

 * @oct: octeon device

/**

 * octeon_pci_os_setup - PCI initialization for each Octeon device.

 * @oct: octeon device

 setup PCI stuff first */

 Enable PCI DMA Master. */

/**

 * free_netbuf - Unmap and free network buffer

 * @buf: buffer

/**

 * free_netsgbuf - Unmap and free gather buffer

 * @buf: buffer

/**

 * free_netsgbuf_with_resp - Unmap and free gather buffer with response

 * @buf: buffer

 Don't free the skb yet */

/**

 * liquidio_ptp_adjfreq - Adjust ptp frequency

 * @ptp: PTP clock info

 * @ppb: how much to adjust by, in parts-per-billion

	/* The hardware adds the clock compensation value to the

	 * PTP clock on every coprocessor clock cycle, so we

	 * compute the delta in terms of coprocessor clocks.

/**

 * liquidio_ptp_adjtime - Adjust ptp time

 * @ptp: PTP clock info

 * @delta: how much to adjust by, in nanosecs

/**

 * liquidio_ptp_gettime - Get hardware clock time, including any adjustment

 * @ptp: PTP clock info

 * @ts: timespec

/**

 * liquidio_ptp_settime - Set hardware clock time. Reset adjustment

 * @ptp: PTP clock info

 * @ts: timespec

/**

 * liquidio_ptp_enable - Check if PTP is enabled

 * @ptp: PTP clock info

 * @rq: request

 * @on: is it on

/**

 * oct_ptp_open - Open PTP clock source

 * @netdev: network device

/**

 * liquidio_ptp_init - Init PTP clock

 * @oct: octeon device

 Enable */

/**

 * load_firmware - Load firmware to device

 * @oct: octeon device

 *

 * Maps device to firmware filename, requests firmware, and downloads it

/**

 * octnet_poll_check_txq_status - Poll routine for checking transmit queue status

 * @work: work_struct data structure

/**

 * setup_tx_poll_fn - Sets up the txq poll check

 * @netdev: network device

/**

 * liquidio_open - Net device open for LiquidIO

 * @netdev: network device

 Ready for link status updates */

 tell Octeon to start forwarding packets to host */

 start periodical statistics fetch */

/**

 * liquidio_stop - Net device stop for LiquidIO

 * @netdev: network device

 Stop any link updates */

 Inform that netif carrier is down */

 Tell Octeon that nic interface is down. */

 Wait for any pending Rx descriptors */

/**

 * get_new_flags - Converts a mask based on net device flags

 * @netdev: network device

 *

 * This routine generates a octnet_ifflags mask from the net device flags

 * received from the OS.

		/* Accept all multicast addresses if there are more than we

		 * can handle

/**

 * liquidio_set_mcast_list - Net device set_multicast_list

 * @netdev: network device

 Create a ctrl pkt command to be sent to core app. */

 copy all the addresses into the udd */

 no need to swap bytes */

	/* Apparently, any activity in this call from the kernel has to

	 * be atomic. So we won't wait for response.

/**

 * liquidio_set_mac - Net device set_mac_address

 * @netdev: network device

 * @p: pointer to sockaddr

 The MAC Address is presented in network byte order. */

 detailed rx_errors: */

 recved pkt with crc error    */

 recv'd frame alignment error */

 recv'r fifo overrun */

 detailed tx_errors */

/**

 * hwtstamp_ioctl - Handler for SIOCSHWTSTAMP ioctl

 * @netdev: network device

 * @ifr: interface request

/**

 * liquidio_ioctl - ioctl handler

 * @netdev: network device

 * @ifr: interface request

 * @cmd: command

/**

 * handle_timestamp - handle a Tx timestamp response

 * @oct: octeon device

 * @status: response status

 * @buf: pointer to skb

/**

 * send_nic_timestamp_pkt - Send a data packet that will be timestamped

 * @oct: octeon device

 * @ndata: pointer to network data

 * @finfo: pointer to private network data

 * @xmit_more: more is coming

/**

 * liquidio_xmit - Transmit networks packets to the Octeon interface

 * @skb: skbuff struct to be passed to network layer.

 * @netdev: pointer to network device

 *

 * Return: whether the packet was transmitted to the device okay or not

 *             (NETDEV_TX_OK or NETDEV_TX_BUSY)

	/* Check for all conditions in which the current packet cannot be

	 * transmitted.

	/* Use space in skb->cb to store info used to unmap and

	 * free the buffers.

 Prepare the attributes for the data to be passed to OSI. */

 defer sending if queue is full */

	/* pr_info(" XMIT - valid Qs: %d, 1st Q no: %d, cpu:  %d, q_no:%d\n",

	 *	lio->linfo.num_txpciq, lio->txq, cpu, ndata.q_no);

 Offload checksum calculation for TCP/UDP packets */

 HW insert VLAN tag */

/**

 * liquidio_tx_timeout - Network device Tx timeout

 * @netdev:    pointer to network device

 * @txqueue: index of the hung transmit queue

/**

 * liquidio_set_rxcsum_command - Sending command to enable/disable RX checksum offload

 * @netdev:                pointer to network device

 * @command:               OCTNET_CMD_TNL_RX_CSUM_CTL

 * @rx_cmd:                OCTNET_CMD_RXCSUM_ENABLE/OCTNET_CMD_RXCSUM_DISABLE

 * Returns:                SUCCESS or FAILURE

/**

 * liquidio_vxlan_port_command - Sending command to add/delete VxLAN UDP port to firmware

 * @netdev:                pointer to network device

 * @command:               OCTNET_CMD_VXLAN_PORT_CONFIG

 * @vxlan_port:            VxLAN port to be added or deleted

 * @vxlan_cmd_bit:         OCTNET_CMD_VXLAN_PORT_ADD,

 *                              OCTNET_CMD_VXLAN_PORT_DEL

 * Return:                     SUCCESS or FAILURE

/**

 * liquidio_fix_features - Net device fix features

 * @netdev:  pointer to network device

 * @request: features requested

 * Return: updated features list

Disable LRO if RXCSUM is off */

/**

 * liquidio_set_features - Net device set features

 * @netdev:  pointer to network device

 * @features: features to enable/disable

	/* Sending command to firmware to enable/disable RX checksum

	 * offload settings using ethtool

 vfidx is 0 based, but vf_num (param1) is 1 based */

 The MAC Address is presented in network byte order. */

 Clear */

		vfidx + 1; /* vfidx is 0 based,

			    * but vf_num (param1) is 1 based

 vfidx is 0 based, but vf_num (param2) is 1 based */

 vfidx is 0 based, but vf_num (param1) is 1 based */

 Wait for response or timeout */

 trusted vf is not supported by firmware older than 1.7.1 */

 Set */

 Clear */

 vfidx is 0 based, but vf_num (param1) is 1 based */

/**

 * liquidio_init - Entry point for the liquidio module

 init handshake failed */

 starter handshake failed */

/**

 * setup_nic_devices - Setup network interfaces

 * @octeon_dev:  octeon device

 *

 * Called during init time for each device. It assumes the NIC

 * is already up and running.  The link information for each

 * interface is passed in link_info.

 This is to handle link status changes */

	/* REQTYPE_RESP_NET and REQTYPE_SOFT_COMMAND do not have free functions.

	 * They are handled directly.

 Soft instr is freed by driver in case of failure. */

		/* Sleep on a wait queue till the cond flag indicates that the

		 * response arrived or timed-out.

 Verify f/w version (in case of 'auto' loading from flash) */

 extract micro version field; point past '<maj>.<min>.' */

		/* Associate the routines that will handle different

		 * netdev tasks.

		/*  Copy of transmit encapsulation capabilities:

		 *  TSO, TSO6, Checksums for this device

 Add any unchangeable hw features */

HW_VLAN_RX and HW_VLAN_FILTER is always on*/

 MTU range: 68 - 16000 */

		/* Point to the  properties for octeon device to which this

		 * interface belongs.

 64-bit swap required on LE machines */

 Copy MAC Address to OS network device structure */

		/* By default all interfaces on a single Octeon uses the same

		 * tx and rx queues

 Register ethtool support */

 Register the network device with the OS */

		/* Sending command to firmware to enable Rx checksum offload

		 * by default at the time of setup of Liquidio driver for

		 * this device

 speed control unsupported in f/w older than 1.7.2 */

 don't read FEC setting if unsupported by f/w (see above) */

		/* init lookup table that maps DPI ring number to VF pci_dev

		 * struct pointer

/**

 * liquidio_init_nic_module - initialize the NIC

 * @oct: octeon device

 *

 * This initialization routine is called once the Octeon device application is

 * up and running

	/* only default iq and oq were initialized

	 * initialize the rest as well

 run port_config command for each port */

	/* Call vf_rep_modinit if the firmware is switchdev capable

	 * and do it from the first liquidio function probed.

/**

 * nic_starter - finish init

 * @work:  work struct work_struct

 *

 * starter callback that invokes the remaining initialization work after the NIC is up and running.

	/* If the status of the device is CORE_OK, the core

	 * application has reported its application type. Call

	 * any registered handlers now and move to the RUNNING

	 * state.

 the first 64-bit word of data is the vf_num */

/**

 * octeon_device_init - Device initialization for each Octeon device that is probed

 * @octeon_dev:  octeon device

	/* Enable access to the octeon device and make its DMA capability

	 * known to the OS.

 Identify the Octeon type and map the BAR address space. */

	/* Only add a reference after setting status 'OCT_DEV_PCI_MAP_DONE',

	 * since that is what is required for the reference to be removed

	 * during de-initialization (see 'octeon_destroy_resources').

	/* CN23XX supports preloaded firmware if the following is true:

	 *

	 * The adapter indicates that firmware is currently running AND

	 * 'fw_type' is 'auto'.

	 *

	 * (default state is NEEDS_TO_BE_LOADED, override it if appropriate).

 If loading firmware, only first device of adapter needs to do so. */

	/* Here, [local variable] 'fw_state' is set to one of:

	 *

	 *   FW_IS_PRELOADED:       No firmware is to be loaded (see above)

	 *   FW_NEEDS_TO_BE_LOADED: The driver's first instance will load

	 *                          firmware to the adapter.

	 *   FW_IS_BEING_LOADED:    The driver's second instance will not load

	 *                          firmware to the adapter.

	/* Prior to f/w load, perform a soft reset of the Octeon device;

	 * if error resetting, return w/error.

	/* Initialize the dispatch mechanism used to push packets arriving on

	 * Octeon Output queues.

	/* Initialize soft command buffer pool

  Setup the data structures that manage this Octeon's Input queues. */

	/* Initialize lists to manage the requests of different types that

	 * arrive from user & kernel applications for this octeon device.

		/* The input and output queue registers were setup earlier (the

		 * queues were not enabled). Any additional registers

		 * that need to be programmed should be done now.

 Initialize the tasklet that handles output queue packet processing.*/

	/* Setup the interrupt handler and record the INT SUM register address

 Enable Octeon device interrupts */

	/* Send Credit for Octeon Output queues. Credits are always sent BEFORE

	 * the output queue is enabled.

	 * This ensures that we'll receive the f/w CORE DRV_ACTIVE message in

	 * case we've configured CN23XX_SLI_GBL_CONTROL[NOPTR_D] = 0.

	 * Otherwise, it is possible that the DRV_ACTIVE message will be sent

	 * before any credits have been issued, causing the ring to be reset

	 * (and the f/w appear to never have started).

 Enable the input and output queues for this Octeon device */

 Wait for the octeon to initialize DDR after the soft-reset.*/

 user probably pressed Control-C */

 Divert uboot to take commands from host instead. */

		/* If console debug enabled, specify empty string to use default

		 * enablement ELSE specify NULL string for 'disabled'.

			/* If console was added AND we're logging console output

			 * then set our console print function.

/**

 * octeon_dbg_console_print - Debug console print function

 * @oct:  octeon device

 * @console_num: console number

 * @prefix:      first portion of line to display

 * @suffix:      second portion of line to display

 *

 * The OCTEON debug console outputs entire lines (excluding '\n').

 * Normally, the line will be passed in the 'prefix' parameter.

 * However, due to buffering, it is possible for a line to be split into two

 * parts, in which case they will be passed as the 'prefix' parameter and

 * 'suffix' parameter.

/**

 * liquidio_exit - Exits the module

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more details.

 Wait for 10ms as Octeon resets. */

 Enable Link error reporting */

 Read config register for MPS */

 Turn off any MPS bits */

 Set MPS */

 Set MPS in DPI_SLI_PRT0_CFG to the same value. */

 Read config register for MRRS */

 Turn off any MRRS bits */

 Set MRRS */

 Set MRRS in SLI_S2M_PORT0_CTL to the same value. */

 Set MRRS in DPI_SLI_PRT0_CFG to the same value. */

	/* Bits 29:24 of MIO_RST_BOOT holds the ref. clock multiplier

	 * for SLI.

 This gives the SLI clock per microsec */

	/* core clock per us / oq ticks will be fractional. TO avoid that

	 * we use the method below.

 This gives the clock cycles per millisecond */

 This gives the oq ticks (1024 core clock cycles) per millisecond */

	/* time_intr is in microseconds. The next 2 steps gives the oq ticks

	 * corressponding to time_intr.

 Select Round-Robin Arb, ES, RO, NS for Input Queues */

 Instruction Read Size - Max 4 instructions per PCIE Read */

 Select PCIE Port for all Input rings. */

 66XX SPECIFIC */

 Disable RING_EN if only upto 4 rings are used. */

 Disable per-port backpressure. */

 / Select PCI-E Port for all Output queues */

 / Set Output queue watermark to 0 to disable backpressure */

 / Select Packet count instead of bytes for SLI_PKTi_CNTS[CNT] */

	/* Select ES, RO, NS setting from register for Output Queue Packet

	 * Address

	/* No Relaxed Ordering, No Snoop, 64-bit swap for Output

	 * Queue ScatterList

 / ENDIAN_SPECIFIC CHANGES - 0 works for LE. */

 / No Relaxed Ordering, No Snoop, 64-bit swap for Output Queue Data */

 / Set up interrupt packet and time threshold */

	/* Default error timeout value should be 0x200000 to avoid host hang

	 * when reads invalid register

 Write the start of the input queue's ring and its size  */

	/* Remember the doorbell & instruction count register addr for this

	 * queue

	/* Store the current instruction counter

	 * (used in flush_iq calculation)

	/* Backpressure for this queue - WMARK set to all F's. This effectively

	 * disables the backpressure mechanism.

 Get the mapped address of the pkt_sent and pkts_credit regs */

 Enable this output queue to generate Packet Timer Interrupt */

 Enable this output queue to generate Packet Timer Interrupt */

 Reset the Enable bits for Input Queues. */

 Wait until hardware indicates that the queues are out of reset. */

 Reset the doorbell register for each Input queue. */

 Reset the Enable bits for Output Queues. */

 Wait until hardware indicates that the queues are out of reset. */

 Reset the doorbell register for each Output queue. */

	/* Bits 17:4 of the PCI_BAR1_INDEXx stores bits 35:22 of

	 * the Core Addr

	/* The new instr cnt reg is a 32-bit counter that can roll over. We have

	 * noted the counter's initial value at init time into

	 * reset_instr_cnt

	/* Modulo of the new index with the IQ size will give us

	 * the new index.

 Enable Interrupt */

 Disable Interrupts */

	/* CN63xx Pass2 and newer parts implements the SLI_MAC_NUMBER register

	 * to determine the PCIE port #

 disable interrupts for this droq */

 Reset the PKT_CNT/TIME_INT registers. */

 reset PKT_CNT register:66xx */

	/* If our device has interrupted, then proceed.

	 * Also check for all f's if interrupt was triggered on an error

	 * and the PCI read fails.

 Clear the current interrupts */

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more details.

/** Default configuration

 *  for CN66XX OCTEON Models.

* IQ attributes */

* OQ attributes */

 For ethernet interface 0:  Port cfg Attributes */

 Max Txqs: Half for each of the two ports :max_iq/2 */

 Actual configured value. Range could be: 1...max_txqs */

 Max Rxqs: Half for each of the two ports :max_oq/2  */

 Actual configured value. Range could be: 1...max_rxqs */

 Num of desc for rx rings */

 Num of desc for tx rings */

		/* SKB size, We need not change buf size even for Jumbo frames.

		 * Octeon can send jumbo frames in 4 consecutive descriptors,

 Max Txqs: Half for each of the two ports :max_iq/2 */

 Actual configured value. Range could be: 1...max_txqs */

 Max Rxqs: Half for each of the two ports :max_oq/2  */

 Actual configured value. Range could be: 1...max_rxqs */

 Num of desc for rx rings */

 Num of desc for tx rings */

		/* SKB size, We need not change buf size even for Jumbo frames.

		 * Octeon can send jumbo frames in 4 consecutive descriptors,

* Miscellaneous attributes */

 Host driver link query interval */

 Octeon link query interval */

 Control queue group */

/** Default configuration

 *  for CN68XX OCTEON Model.

* IQ attributes */

* OQ attributes */

 Max Txqs: Half for each of the two ports :max_iq/2 */

 Actual configured value. Range could be: 1...max_txqs */

 Max Rxqs: Half for each of the two ports :max_oq/2  */

 Actual configured value. Range could be: 1...max_rxqs */

 Num of desc for rx rings */

 Num of desc for tx rings */

		/* SKB size, We need not change buf size even for Jumbo frames.

		 * Octeon can send jumbo frames in 4 consecutive descriptors,

 Max Txqs: Half for each of the two ports :max_iq/2 */

 Actual configured value. Range could be: 1...max_txqs */

 Max Rxqs: Half for each of the two ports :max_oq/2  */

 Actual configured value. Range could be: 1...max_rxqs */

 Num of desc for rx rings */

 Num of desc for tx rings */

		/* SKB size, We need not change buf size even for Jumbo frames.

		 * Octeon can send jumbo frames in 4 consecutive descriptors,

 Max Txqs: Half for each of the two ports :max_iq/2 */

 Actual configured value. Range could be: 1...max_txqs */

 Max Rxqs: Half for each of the two ports :max_oq/2  */

 Actual configured value. Range could be: 1...max_rxqs */

 Num of desc for rx rings */

 Num of desc for tx rings */

		/* SKB size, We need not change buf size even for Jumbo frames.

		 * Octeon can send jumbo frames in 4 consecutive descriptors,

 Max Txqs: Half for each of the two ports :max_iq/2 */

 Actual configured value. Range could be: 1...max_txqs */

 Max Rxqs: Half for each of the two ports :max_oq/2  */

 Actual configured value. Range could be: 1...max_rxqs */

 Num of desc for rx rings */

 Num of desc for tx rings */

		/* SKB size, We need not change buf size even for Jumbo frames.

		 * Octeon can send jumbo frames in 4 consecutive descriptors,

* Miscellaneous attributes */

 Host driver link query interval */

 Octeon link query interval */

 Control queue group */

/** Default configuration

 *  for CN68XX OCTEON Model.

* IQ attributes */

* OQ attributes */

 Max Txqs: Half for each of the two ports :max_iq/2 */

 Actual configured value. Range could be: 1...max_txqs */

 Max Rxqs: Half for each of the two ports :max_oq/2  */

 Actual configured value. Range could be: 1...max_rxqs */

 Num of desc for rx rings */

 Num of desc for tx rings */

		/* SKB size, We need not change buf size even for Jumbo frames.

		 * Octeon can send jumbo frames in 4 consecutive descriptors,

 Max Txqs: Half for each of the two ports :max_iq/2 */

 Actual configured value. Range could be: 1...max_txqs */

 Max Rxqs: Half for each of the two ports :max_oq/2  */

 Actual configured value. Range could be: 1...max_rxqs */

 Num of desc for rx rings */

 Num of desc for tx rings */

		/* SKB size, We need not change buf size even for Jumbo frames.

		 * Octeon can send jumbo frames in 4 consecutive descriptors,

* Miscellaneous attributes */

 Host driver link query interval */

 Octeon link query interval */

 Control queue group */

* IQ attributes */

* OQ attributes */

 For ethernet interface 0:  Port cfg Attributes */

 Max Txqs: Half for each of the two ports :max_iq/2 */

 Actual configured value. Range could be: 1...max_txqs */

 Max Rxqs: Half for each of the two ports :max_oq/2  */

 Actual configured value. Range could be: 1...max_rxqs */

 Num of desc for rx rings */

 Num of desc for tx rings */

		/* SKB size, We need not change buf size even for Jumbo frames.

		 * Octeon can send jumbo frames in 4 consecutive descriptors,

 Max Txqs: Half for each of the two ports :max_iq/2 */

 Actual configured value. Range could be: 1...max_txqs */

 Max Rxqs: Half for each of the two ports :max_oq/2  */

 Actual configured value. Range could be: 1...max_rxqs */

 Num of desc for rx rings */

 Num of desc for tx rings */

		/* SKB size, We need not change buf size even for Jumbo frames.

		 * Octeon can send jumbo frames in 4 consecutive descriptors,

 Host driver link query interval */

 Octeon link query interval */

 Control queue group */

 locks device array (i.e. octeon_device[]) */

/** Register a device's bus location at initialization time.

 *  @param octeon_dev - pointer to the octeon device structure.

 *  @param bus        - PCIe bus #

 *  @param dev        - PCIe device #

 *  @param func       - PCIe function #

 *  @param is_pf      - TRUE for PF, FALSE for VF

 *  @return reference count of device's adapter

 Like the reference count, the f/w state is shared 'per-adapter' */

 here, refcount is guaranteed to be 1 */

		/* If another device is at same bus/dev, use its refcounter

		 * (and f/w state variable).

/** Deregister a device at de-initialization time.

 *  @param octeon_dev - pointer to the octeon device structure.

 *  @return reference count of device's adapter

 this function is only for setting up the first queue */

 prevent memory leak */

		/* IOQs will already be in reset.

		 * If RST bit is set, wait for quiet bit to be set.

		 * Once quiet bit is set, clear the RST bit.

 Disable the i/p and o/p queues for this Octeon. */

/* octeon_register_dispatch_fn

 * Parameters:

 *   octeon_id - id of the octeon device.

 *   opcode    - opcode for which driver should call the registered function

 *   subcode   - subcode for which driver should call the registered function

 *   fn        - The function to call when a packet with "opcode" arrives in

 *		  octeon output queues.

 *   fn_arg    - The argument to be passed when calling function "fn".

 * Description:

 *   Registers a function and its argument to be called when a packet

 *   arrives in Octeon output queues with "opcode".

 * Returns:

 *   Success: 0

 *   Failure: 1

 * Locks:

 *   No locks are held.

 Add dispatch function to first level of lookup table */

	/* Check if there was a function already registered for this

	 * opcode/subcode.

		/* Add dispatch function to linked list of fn ptrs

		 * at the hashed index.

 Retruns the host firmware handshake OCTEON specific configuration */

	/* check the OCTEON Device model & return the corresponding octeon

	 * configuration

 scratch register address is same in all the OCT-II and CN70XX models */

/* Get the octeon device pointer.

 *  @param octeon_id  - The id for which the octeon device pointer is required.

 *  @return Success: Octeon device pointer.

 *  @return Failure: NULL.

	/* The windowed read happens when the LSB of the addr is written.

	 * So write MSB first

 Read back to preserve ordering of writes */

 The write happens when the LSB is written. So write MSB first. */

 Read the MSB to ensure ordering of writes. */

 Check to make sure a DDR interface is enabled */

 wait 100 ms */

/* Get the octeon id assigned to the octeon device passed as argument.

 *  This function is exported to other modules.

 *  @param dev - octeon device pointer passed as a void *.

 *  @return octeon device id

 the whole thing needs to be atomic, ideally */

 this write needs to be flushed before we release the lock */

	/*write resend. Writing RESEND in SLI_PKTX_CNTS should be enough

	 *to trigger tx interrupts as well, if they are pending.

we race with firmrware here. read and write the IN_DONE_CNTS*/

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more

 * details.

		/* check if octeon has finished DMA'ing a response

		 * to where rptr is pointing to

			/* This logic ensures that all 64b have been written.

			 * 1. check byte 0 for non-FF

			 * 2. if non-FF, then swap result from BE to host order

			 * 3. check byte 7 (swapped to 0) for non-FF

			 * 4. if non-FF, use the low 32-bit status code

			 * 5. if either byte 0 or byte 7 is FF, don't use status

 retrieve 16-bit firmware status */

 i.e. no error */

 we have received a response or we have timed out */

 remove node from linked list */

					/* caller does not wait for response

					 * from firmware

 sc with callback function */

 sc is freed by caller */

 no response yet */

		/* If we hit the Max Ordered requests to process every loop,

		 * we quit

		 * and let this function be invoked the next time the poll

		 * thread runs

		 * to process the remaining requests. This function can take up

		 * the entire CPU if there is no upper limit to the requests

		 * processed.

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more details.

 OOM task polling interval */

/**

 * lio_delete_glists - Delete gather lists

 * @lio: per-network private data

/**

 * lio_setup_glists - Setup gather lists

 * @oct: octeon_device

 * @lio: per-network private data

 * @num_iqs: count of iqs to allocate

	/* allocate memory to store virtual and dma base address of

	 * per glist consistent memory

 vfidx is 0 based, but vf_num (param1) is 1 based */

	/* Case to handle "OCTNET_CMD_TNL_RX_CSUM_CTL"

	 * Command passed by NIC driver

		/* Case to handle "OCTNET_CMD_TNL_TX_CSUM_CTL"

		 * Command passed by NIC driver

		/* Case to handle "OCTNET_CMD_VXLAN_PORT_CONFIG"

		 * Command passed by NIC driver

	/* no need to notify the firmware of the macaddr change because

	 * the PF did that already

 Runs in interrupt context. */

	/* This is needed because the first IQ does not have

	 * a netdev associated with it.

/**

 * octeon_setup_droq - Setup output queue

 * @oct: octeon device

 * @q_no: which queue

 * @num_descs: how many descriptors

 * @desc_size: size of each descriptor

 * @app_ctx: application context

 droq creation and local register settings. */

 Enable the droq queues */

	/* Send Credit for Octeon Output queues. Credits are always

	 * sent after the output queue is enabled.

/**

 * liquidio_push_packet - Routine to push packets arriving on Octeon interface upto network layer.

 * @octeon_id:octeon device id.

 * @skbuff:   skbuff struct to be passed to network layer.

 * @len:      size of total data received.

 * @rh:       Control header associated with the packet

 * @param:    additional control data with the packet

 * @arg:      farg registered in droq_ops

 Do not proceed if the interface is not in RUNNING state. */

 For Paged allocation use the frags */

				/* timestamp is included from the hardware at

				 * the beginning of the packet.

					/* Nanoseconds are in the first 64-bits

					 * of the packet.

 checksum has already been verified */

		/* Setting Encapsulation field on basis of status received

		 * from the firmware

 inbound VLAN tag */

/**

 * napi_schedule_wrapper - wrapper for calling napi_schedule

 * @param: parameters to pass to napi_schedule

 *

 * Used when scheduling on different CPUs

/**

 * liquidio_napi_drv_callback - callback when receive interrupt occurs and we are in NAPI mode

 * @arg: pointer to octeon output queue

/**

 * liquidio_napi_poll - Entry point for NAPI polling

 * @napi: NAPI structure

 * @budget: maximum number of items to process

 Handle Droq descriptors */

 Flush the instruction queue */

		/* TODO: move this check to inside octeon_flush_iq,

		 * once check_db_timeout is removed

 Process iq buffers with in the budget limits */

		/* Update iq read-index rather than waiting for next interrupt.

		 * Return back if tx_done is false.

 sub-queue status update */

 force enable interrupt if reg cnts are high to avoid wraparound */

/**

 * liquidio_setup_io_queues - Setup input and output queues

 * @octeon_dev: octeon device

 * @ifidx: Interface index

 * @num_iqs: input io queue count

 * @num_oqs: output io queue count

 *

 * Note: Queues are with respect to the octeon device. Thus

 * an input queue is for egress packets, and output queues

 * are for ingress packets.

 set up DROQs. */

 designate a CPU for this droq */

		/* 23XX PF/VF can send/recv control messages (via the first

		 * PF/VF-owned droq) from the firmware even if the ethX

		 * interface is down, so that's why poll_mode must be off

		 * for the first droq.

 set up IQs. */

 XPS */

 this will be flushed periodically by check iq db */

/**

 * liquidio_schedule_droq_pkt_handlers - Droq packet processor sceduler

 * @oct: octeon device

/**

 * liquidio_legacy_intr_handler - Interrupt handler for octeon

 * @irq: unused

 * @dev: octeon device

 Disable our interrupts for the duration of ISR */

 Re-enable our interrupts  */

/**

 * octeon_setup_interrupt - Setup interrupt for octeon device

 * @oct: octeon device

 * @num_ioqs: number of queues

 *

 *  Enable interrupt in Octeon device as given in the PCI interrupt mask.

			/* one non ioq interrupt for handling

			 * sli_mac_pf_int_sum

 allocate storage for the names assigned to each irq */

		/*Assumption is that pf msix vectors start from pf srn to pf to

		 * trs and not from 0. if not change this code

 For PF, there is one non-ioq interrupt handler */

 Freeing the non-ioq irq vector here . */

 clearing affinity mask. */

 assign the cpu mask for this msix interrupt vector */

 allocate storage for the names assigned to the irq */

/**

 * liquidio_change_mtu - Net device change_mtu

 * @netdev: network device

 * @new_mtu: the new max transmit unit size

	/* Sleep on a wait queue till the cond flag indicates that the

	 * response arrived or timed-out.

 RX link-level stats */

 Accounts for over/under-run of buffers */

 RX firmware stats */

 Number of packets that are LROed      */

 Number of octets that are LROed       */

 Number of LRO packets formed          */

 Number of times lRO of packet aborted */

 intrmod: packet forward rate */

 TX link-level stats */

 Packets sent after one collision*/

 Packets sent after multiple collision*/

 Packets not sent due to max collisions */

 Packets not sent due to max deferrals */

 Accounts for over/under-run of buffers */

 Total number of collisions detected */

 firmware stats */

 Alloc soft command */

 report spoofchk every 2 seconds */

 Alloc soft command */

 Wait for response or timeout */

				/* unable to access boot variables

				 * get the default value based on the NIC type

 SEAPI_CMD_FEC_DISABLE(0) or SEAPI_CMD_FEC_RS(1) */

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more details.

/** Get the argument that the user set when registering dispatch

 *  function for a given opcode/subcode.

 *  @param  octeon_dev - the octeon device pointer.

 *  @param  opcode     - the opcode for which the dispatch argument

 *                       is to be checked.

 *  @param  subcode    - the subcode for which the dispatch argument

 *                       is to be checked.

 *  @return  Success: void * (argument to the dispatch function)

 *  @return  Failure: NULL

 *

/** Check for packets on Droq. This function should be called with lock held.

 *  @param  droq - Droq on which count is checked.

 *  @return Returns packet count.

 we shall write to cnts  at napi irq enable or end of droq tasklet */

	/* max_empty_descs is the max. no. of descs that can have no buffers.

	 * If the empty desc count goes beyond this value, we cannot safely

	 * read in a 64K packet sent by Octeon

	 * (64K is max pkt size from Octeon)

 For 56xx Pass1, this function won't be called, so no checks. */

/* octeon_create_recv_info

 * Parameters:

 *  octeon_dev - pointer to the octeon device structure

 *  droq       - droq in which the packet arrived.

 *  buf_cnt    - no. of buffers used by the packet.

 *  idx        - index in the descriptor for the first buffer in the packet.

 * Description:

 *  Allocates a recv_info_t and copies the buffer addresses for packet data

 *  into the recv_pkt space which starts at an 8B offset from recv_info_t.

 *  Flags the descriptors for refill later. If available descriptors go

 *  below the threshold to receive a 64K pkt, new buffers are first allocated

 *  before the recv_pkt_t is created.

 *  This routine will be called in interrupt context.

 * Returns:

 *  Success: Pointer to recv_info_t

 *  Failure: NULL.

/* If we were not able to refill all buffers, try to move around

 * the buffers that were not dispatched.

 while */

/* octeon_droq_refill

 * Parameters:

 *  droq       - droq in which descriptors require new buffers.

 * Description:

 *  Called during normal DROQ processing in interrupt mode or by the poll

 *  thread to refill the descriptors from which buffers were dispatched

 *  to upper layers. Attempts to allocate new buffers. If that fails, moves

 *  up buffers (that were not dispatched) to form a contiguous ring.

 * Returns:

 *  No of descriptors refilled.

		/* If a valid buffer exists (happens if there is no dispatch),

		 * reuse the buffer, else allocate.

			/* Either recycle the existing pages or go for

			 * new page alloc

			/* If a buffer could not be allocated, no point in

			 * continuing

	/* if droq->refill_count

	 * The refill count would not change in pass two. We only moved buffers

	 * to close the gap in the ring, but we would still have the same no. of

	 * buffers to refill.

/** check if we can allocate packets to get out of oom.

 *  @param  droq - Droq being checked.

 *  @return 1 if fails to refill minimum

		/* Flush the droq descriptor data to memory to be sure

		 * that when we update the credits the data in memory

		 * is accurate.

 Len of resp hdr in included in the received data len. */

				/* nicbuf allocation can fail. We'll handle it

				 * inside the loop.

				/* Flush the droq descriptor data to memory to

				 * be sure that when we update the credits the

				 * data in memory is accurate.

 for (each packet)... */

 Increment refill_count by the number of buffers processed. */

 Make sure there are no pkts_pending */

 If there are packets pending. schedule tasklet again */

/*

 * Utility function to poll for packets. check_hw_for_packets must be

 * called before calling this routine.

 Enable Pkt Interrupt */

 don't bother flushing the enables */

 Allocate the DS for the new droq. */

Disable the pkt o/p for this Q  */

 Initialize the Droq */

 Global Droq register settings */

	/* As of now not required, as setting are done for all 32 Droqs at

	 * the same time.

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more

 * details.

 Core mem read/write with temporary bar1 settings. */

 op = 1 to read, op = 0 to write. */

 Save the original index reg value. */

		/* If operation crosses a 4MB boundary, split the transfer

		 * at the 4MB

		 * boundary.

 read from core */

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more

 * details.

 Copy existing command structure into the soft command */

	/* Add in the response related fields. Opcode and Param are already

	 * there.

pkiih3 + irh + ossp[0] + ossp[1] + rdp + rptr = 40 bytes */

 irh + ossp[0] + ossp[1] + rdp + rptr = 40 bytes */

 a response is required */

 Endian-Swap for UDD should have been done by caller. */

	/* Allow only rx ctrl command to stop traffic on the chip

	 * during offline operations

 caller holds lock, can not sleep */

/**********************************************************************

 * Author: Cavium, Inc.

 *

 * Contact: support@cavium.com

 *          Please include "LiquidIO" in the subject.

 *

 * Copyright (c) 2003-2016 Cavium, Inc.

 *

 * This file is free software; you can redistribute it and/or modify

 * it under the terms of the GNU General Public License, Version 2, as

 * published by the Free Software Foundation.

 *

 * This file is distributed in the hope that it will be useful, but

 * AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty

 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or

 * NONINFRINGEMENT.  See the GNU General Public License for more details.

 This gives the SLI clock per microsec */

 This gives the clock cycles per millisecond */

 This gives the oq ticks (1024 core clock cycles) per millisecond */

	/* time_intr is in microseconds. The next 2 steps gives the oq ticks

	 * corressponding to time_intr.

 set RST bit to 1. This bit applies to both IQ and OQ */

 wait until the RST bit is clear or the RST and QUIET bits are set */

		/* Select ES, RO, NS, RDSIZE,DPTR Fomat#0 for

		 * the Input Queues

 set the wmark level to trigger PI_INT */

 clear IPTR */

 set DPTR */

 reset BMODE */

		/* No Relaxed Ordering, No Snoop, 64-bit Byte swap

		 * for Output Queue ScatterList reset ROR_P, NSR_P

		/* No Relaxed Ordering, No Snoop, 64-bit Byte swap

		 * for Output Queue Data reset ROR, NSR

 set the ES bit */

 write all the selected settings */

 Write the start of the input queue's ring and its size */

	/* Remember the doorbell & instruction count register addr

	 * for this queue

	/* Store the current instruction counter (used in flush_iq

	 * calculation)

 Set CINT_ENB to enable IQ interrupt */

 Get the mapped address of the pkt_sent and pkts_credit regs */

 VF mbox interrupt reg */

 VF reads from SIG0 reg */

 VF writes into SIG1 reg */

 set the corresponding IQ IS_64B bit */

 set the corresponding IQ ENB bit */

 set the corresponding OQ ENB bit */

	/* per HRM, rings can only be disabled via reset operation,

	 * NOT via SLI_PKT()_INPUT/OUTPUT_CONTROL[ENB]

 Sending VF_ACTIVE indication to the PF driver */

 read and clear by writing 1 */

	/* If our device has interrupted, then proceed. Also check

	 * for all f's if interrupt was triggered on an error

	 * and the PCI read fails.

 Write count reg in sli_pkt_cnts to clear these int. */

 We will clear the count when we update the read_index. */

	/* Modulo of the new index with the IQ size will give us

	 * the new index.  The iq->reset_instr_cnt is always zero for

	 * cn23xx, so no extra adjustments are needed.

			/* Set up interrupt packet and time thresholds

			 * for all the OQs

 Set CINT_ENB to enable IQ interrupt */

 Set queue-0 MBOX_ENB to enable VF mailbox interrupt */

 Write all 1's in INT_LEVEL reg to disable PO_INT */

 INPUT_CONTROL[RPVF] gives the VF IOq count */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2015 Cavium, Inc.

 ETHTOOL Support for VNIC_VF Device*/

 Update LMAC stats */

 Mailbox registers */

 Tx/Rx statistics */

 All completion queue's registers */

 All receive queue's registers */

		/* Padding, was NIC_QSET_SQ_0_7_CNM_CHG, which

		 * produces bus errors when read

 Due to HW errata this is not supported on T88 pass 1.x silicon */

 Permitted lengths are 1K, 2K, 4K, 8K, 16K, 32K, 64K */

 Get no of queues device supports and current queue count */

 Set no of Tx, Rx queues to be used */

 Supported only for 10G/40G interfaces */

 Supported only for 10G/40G interfaces */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2015 Cavium, Inc.

/* NOTE: Packets bigger than 1530 are split across multiple pages and XDP needs

 * the buffer to be contiguous. Allow XDP to be set up only if we don't exceed

 * this value, keeping headroom for the 14 byte Ethernet header and two

 * VLAN tags (for QinQ)

 Supported devices */

 end of table */

/* The Cavium ThunderX network controller can *only* be found in SoCs

 * containing the ThunderX ARM64 CPU implementation.  All accesses to the device

 * registers on this platform are implicitly strongly ordered with respect

 * to memory accesses. So writeq_relaxed() and readq_relaxed() are safe to use

 * with no memory barriers in this driver.  The readq()/writeq() functions add

 * explicit ordering operation which in this case are redundant, and only

 * add overhead.

 Register read/write APIs */

 VF -> PF mailbox communication */

 Wait for previous message to be acked, timeout 2sec */

/* Checks if VF is able to comminicate with PF

* and also gets the VNIC number this VF is associated to.

		/* Primary VF: make note of secondary VF's pointer

		 * to be used while packet transmission.

		/* Secondary VF/Qset: make note of primary VF's pointer

		 * to be used while packet reception, to handover packet

		 * to primary VF's netdev.

 Request PF to allocate additional Qsets */

 Only primary VF should request */

 No response from PF */

 Return if no Secondary Qsets available */

 Set no of Rx/Tx queues in each of the SQsets */

 Initialize secondary Qset's queues and its interrupts */

 Update stack with actual Rx/Tx queue count allocated */

/* Send this Qset's nicvf pointer to PF.

 * PF inturn sends primary VF's nicvf struct to secondary Qsets/VFs

 * so that packets received by these Qsets can use primary VF's netdev

 Enable Qset */

 Initialize queues and HW for data transfer */

 Retrieve packet buffer's DMA address and length */

 Check if XDP program has changed headers */

		/* Check if it's a recycled page, if not

		 * unmap the DMA mapping.

		 *

		 * Recycled page holds an extra reference.

 Build SKB and pass on packet to network stack */

		/* Check if it's a recycled page, if not

		 * unmap the DMA mapping.

		 *

		 * Recycled page holds an extra reference.

 Sync for 'ptp_skb' */

 New timestamp request can be queued now */

 Check for timestamp requested skb */

 Check if timestamping is timedout, which is set to 10us */

 Get the timestamp */

 Free the original skb */

 Sync 'ptp_skb' */

 Check for errors */

 Is this a XDP designated Tx queue */

 Check if it's recycled page or else unmap DMA mapping */

 Release page reference for recycling */

 Check for dummy descriptor used for HW TSO offload on 88xx */

 Get actual TSO descriptors and free them */

 If timestamp is requested for this skb, don't free it */

		/* In case of SW TSO on 88xx, only last segment will have

		 * a SKB attached, so just free SQEs here.

 The first 8 bytes is the timestamp */

 Use primary VF's 'nicvf' struct */

 Check for errors */

 For XDP, ignore pkts spanning multiple pages */

 Packet consumed by XDP */

 If error packet, drop it here */

 HW by default verifies TCP/UDP/SCTP checksums */

 Check for stripped VLAN */

 Get no of valid CQ entries to process */

 Get head of the valid CQ entries */

 Get the CQ descriptor */

 Initiate prefetch for next descriptor */

 Ignore for now */

 Ring doorbell to inform H/W to reuse processed CQEs */

 Update SQ's descriptor free count */

 Handle XDP TX queues */

 Wakeup TXQ if its stopped earlier due to SQ full */

 To read updated queue and carrier status */

 Slow packet rate, exit polling */

 Re-enable interrupts */

/* Qset error interrupt handler

 *

 * As of now only CQ errors are handled

 Check if it is CQ err */

 Process already queued CQEs and reconfig CQ */

 Re-enable Qset error interrupt */

 Check for spurious interrupt */

 Disable interrupts */

 Schedule NAPI */

 Clear interrupt */

 Disable RBDR interrupt and schedule softirq */

 Clear interrupt */

 Disable Qset err interrupt and schedule softirq */

 CQ interrupts */

 Leave CPU0 for RBDR and other interrupts */

 Register CQ interrupts */

 Register RBDR interrupt */

 Register QS error interrupt */

 Set IRQ affinities */

 Free registered interrupts */

 Disable MSI-X */

/* Initialize MSIX vectors and register MISC interrupt.

 * Send READY message to PF to check if its alive

 Return if mailbox interrupt is already registered */

 Enable MSI-X */

 Register Misc interrupt */

 Enable mailbox interrupt */

 Check if VF is able to communicate with PF */

 Check for minimum packet length */

	/* In XDP case, initial HW tx queues are used for XDP,

	 * but stack's queue mapping starts at '0', so skip the

	 * Tx queues attached to Rx queues for XDP.

 Get secondary Qset's SQ structure */

 Barrier, so that stop_queue visible to other cpus */

 Check again, incase another cpu freed descriptors */

 wait till all queued set_rx_mode tasks completes */

 Teardown secondary qsets first */

 Disable RBDR & QS error interrupts */

 Wait for pending IRQ handlers to finish */

		/* CQ intr is enabled while napi_complete,

		 * so disable it now

 Free resources */

 Disable HW Qset */

 disable mailbox interrupt */

 Free any pending SKB saved to receive timestamp */

 Clear multiqset info */

 wait till all queued set_rx_mode tasks completes if any */

 Register NAPI handler for processing CQEs */

 Check if we got MAC address from PF or else generate a radom MAC */

 Init tasklet for handling Qset err interrupt */

 Init RBDR tasklet which will refill RBDR */

 Configure CPI alorithm */

 Configure PTP timestamp */

 Configure receive side scaling and MTU */

 Clear percpu stats */

 Initialize the queues */

 Make sure queue initialization is written */

 Enable Qset err interrupt */

 Enable completion queue interrupt */

 Enable RBDR threshold interrupt */

 Send VF config done msg to PF */

	/* For now just support only the usual MTU sized frames,

	 * plus some headroom for VLAN, QinQ.

 Rx stats */

 Tx stats */

	/* On T88 pass 2.0, the dummy SQE added for TSO notification

	 * via CQE has 'dont_send' set. Hence HW drops the pkt pointed

	 * pointed by dummy SQE and results in tx_drops counter being

	 * incremented. Subtracting it from tx_tso counter will give

	 * exact tx_drops counter.

 Update RQ and SQ stats */

 Set XDP Tx queue count same as Rx queue count */

	/* If queue count > MAX_CMP_QUEUES_PER_QS, then additional qsets

	 * needs to be allocated, check how many.

 Set primary Qset's resources */

 Update stack */

	/* For now just support only the usual MTU sized frames,

	 * plus some headroom for VLAN, QinQ.

	/* ALL SQs attached to CQs i.e same as RQs, are treated as

	 * XDP Tx queues and more Tx queues are allocated for

	 * network stack to send pkts out.

	 *

	 * No of Tx queues are either same as Rx queues or whatever

	 * is left in max no of queues possible.

 Detach old prog, if any */

 Attach BPF program */

 Calculate Tx queues needed for XDP and network stack */

 Reinitialize interface, clean slate */

	/* To avoid checks while retrieving buffer address from CQE_RX,

	 * do not support XDP for T88 pass1.x silicons which are anyway

	 * not in use widely.

 reserved for future extensions */

	/* From the inside of VM code flow we have only 128 bits memory

	 * available to send message to host's PF, so send all mc addrs

	 * one by one, starting from flush command in case if kernel

	 * requests to configure specific MAC filtering

 flush DMAC filters and reset RX mode */

		/* once enabling filtering, we need to signal to PF to add

		 * its' own LMAC to the filter to accept packets for it.

 check if we have any specific MACs to be added to PF DMAC filter */

 now go through kernel list of MACs and add them one by one */

 and finally set rx mode for PF accordingly */

	/* Save message data locally to prevent them from

	 * being overwritten by next ndo_set_rx_mode call().

 here we need to copy mc addrs */

 In virtualized environment we proceed without ptp */

 Restrict multiqset support only for host bound VFs */

 Set max number of queues per VF */

	/* If no of CPUs are too low, there won't be any queues left

	 * for XDP_TX, hence double it.

 Initialize mutex that serializes usage of VF's mailbox */

 MAP VF's configuration registers */

 Check if PF is alive and get MAC address for this VF */

 Get iommu domain for iova to physical addr conversion */

 Check if this VF is in QS only mode */

 MTU range: 64 - 9200 */

	/* Check if this Qset is assigned to different VF.

	 * If yes, clean primary and all secondary Qsets.

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2016 Cavium, Inc.

 Register offsets */

 Supported devices */

 end of table */

 Take DLL out of reset */

 Take clock tree out of reset */

 Wait for DLL to lock */

	/* Configure DLL - enable or bypass

	 * TX no bypass, RX bypass

	/* Enable compensation controller and force the

	 * write to be visible to HW by readig back.

 Wait for compensation state machine to lock */

 enable the XCV block */

 set operating speed */

 Reset datapaths */

 Enable the packet flow */

 Return credits to RGX */

 Disable packet flow */

 MAP configuration registers */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2015 Cavium, Inc.

 RX_DMAC_CTL configuration */

 actual number of DMACs configured */

 overal number of possible DMACs could be configured per LMAC */

 DMAC:VFs tracking filter array */

 ID within BGX */

 ID on board */

 Total no of LMACs in system */

 Supported devices */

 end of table */

/* The Cavium ThunderX network controller can *only* be found in SoCs

 * containing the ThunderX ARM64 CPU implementation.  All accesses to the device

 * registers on this platform are implicitly strongly ordered with respect

 * to memory accesses. So writeq_relaxed() and readq_relaxed() are safe to use

 * with no memory barriers in this driver.  The readq()/writeq() functions add

 * explicit ordering operation which in this case are redundant, and only

 * add overhead.

 Register read/write APIs */

 Return number of BGX present in HW */

 Return number of LMAC configured for this BGX */

 Returns the current link status of LMAC */

 reset CAM filters */

	/* We've got reset filters request from some of attached VF, while the

	 * others might want to keep their configuration. So in this case lets

	 * iterate over all of configured filters and decrease number of

	 * referencies. if some addresses get zero refs remove them from list

	/* At the same time we could have several VFs 'attached' to some

	 * particular LMAC, and each VF is represented as network interface

	 * for kernel. So from user perspective it should be possible to

	 * manipulate with its' (VF) receive modes. However from PF

	 * driver perspective we need to keep track of filter configurations

	 * for different VFs to prevent filter values dupes

 keep it for further tracking */

 skip zero addresses as meaningless */

 configure DCAM filtering for designated LMAC */

	/* since we might have several VFs attached to particular LMAC

	 * and kernel could call mcast config for each of them with the

	 * same MAC, check if requested MAC is already in filtering list and

	 * updare/prepare list of MACs to be applied later to HW filters

 disable all MCASTs and DMAC filtering */

 check requested bits and set filtergin mode appropriately */

 enable TX FIFO Underflow interrupt */

 Disable TX FIFO Underflow interrupt */

 Enables or disables timestamp insertion by BGX for Rx packets */

 Wait for BGX RX to be idle */

 Wait for BGX TX to be idle */

 speed 0 */

 speed_msb 1 */

 slottime 0 */

 samp_pt */

 speed 0 */

 speed_msb 0 */

 slottime 0 */

 samp_pt */

 speed 1 */

 speed_msb 0 */

 slottime 1 */

 samp_pt */

 Restore CMR config settings */

 Configure BGX LMAC in internal loopback mode */

 max packet size */

 Disable frame alignment if using preamble */

 Enable lmac */

 PCS reset */

 power down, reset autoneg, autoneg enable */

		/* In scenarios where PHY driver is not present or it's a

		 * non-standard PHY, FW sets AN_EN to inform Linux driver

		 * to do auto-neg and link polling or not.

 Disable disparity check for QSGMII */

 Reset SPU */

 Disable LMAC */

 Set interleaved running disparity for RXAUI */

 Clear receive packet disable */

 clear all interrupts */

 training enable */

 Append FCS to each packet */

 Disable forward error correction */

 Disable autoneg */

 Enable lmac */

 Enable receive and transmission of pause frames */

 Configure pause time and interval */

 take lmac_count into account */

 max packet size */

 wait for PCS to come out of reset */

 Clear rcvflt bit (latching high) and read it back */

 Wait for BGX RX to be idle */

 Wait for BGX TX to be idle */

 Check for MAC RX faults */

 0 - Link is okay, 1 - Local fault, 2 - Remote fault */

	/* Rx local/remote fault seen.

	 * Do lmac reinit to see if condition recovers

Link state bit is sticky, read it again*/

 Receive link is latching low. Force it high and verify it */

 Errors, clear link_up state */

 FCS and PAD */

 FCS and PAD */

 actual number of filters available to exact LMAC */

 Enable lmac */

 Restore default cfg, incase low level firmware changed it */

 Default to below link speed and duplex */

 Destroy work queue */

 Disable packet reception */

 Give chance for Rx/Tx FIFO to get drained */

 Disable packet transmission */

 Disable serdes lanes */

 Disable LMAC */

 Set lmac type and lane2serdes mapping */

 Set the backpressure AND mask */

 Disable all MAC filtering */

 Disable MAC steering (NCSI traffic) */

 Nothing to do */

		/* There is no way to determine if DLM0/2 is QSGMII or

		 * DLM1/3 is configured to QSGMII as bootloader will

		 * configure all LMACs, so take whatever is configured

		 * by low level firmware.

		/* Read LMAC0 type to figure out QLM mode

		 * This is configured by low level firmware

	/* For DLMs or SLMs on 80/81/83xx so many lane configurations

	 * are possible and vary across boards. Also Kernel doesn't have

	 * any way to identify board type/info and since firmware does,

	 * just take lmac type and serdes lane config as is.

 Check if config is reset value */

 Init all LMAC's type to invalid */

 It is assumed that low level firmware sets this value */

 Currently only sets the MAC address. */

 move to next LMAC */

 CONFIG_ACPI */

		/* Should always be an OF node.  But if it is not, we

		 * cannot handle it, so exit the loop.

		/* If there is no phy or defective firmware presents

		 * this cortina phy, for which there is no driver

		 * support, ignore it.

 Wait until the phy drivers are available */

	/* We are bailing out, try not to leak device reference counts

	 * for phy devices we may have already found.

 CONFIG_OF_MDIO */

 clear interrupts */

 MAP configuration registers */

	/* On 81xx all are DLMs and on 83xx there are 3 BGX QLMs and one

	 * BGX i.e BGX2 can be split across 2 DLMs.

 Enable all LMACs */

 Disable all LMACs */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2015 Cavium, Inc.

 Rx/Tx chans */

 TL1 per BGX or per LMAC */

 No of VF enabled */

 Register start address */

 Secondary qsets enabled */

 MSI-X */

 Supported devices */

 end of table */

/* The Cavium ThunderX network controller can *only* be found in SoCs

 * containing the ThunderX ARM64 CPU implementation.  All accesses to the device

 * registers on this platform are implicitly strongly ordered with respect

 * to memory accesses. So writeq_relaxed() and readq_relaxed() are safe to use

 * with no memory barriers in this driver.  The readq()/writeq() functions add

 * explicit ordering operation which in this case are redundant, and only

 * add overhead.

 Register read/write APIs */

 PF -> VF mailbox communication APIs */

 Clear it, to avoid spurious interrupts (if any) */

 Enable mailbox interrupt for all VFs */

 One mailbox intr enable reg per 64 VFs */

/* Send a mailbox message to VF

 * @vf: vf to which this message to be sent

 * @mbx: Message to be sent

	/* In first revision HW, mbox interrupt is triggerred

	 * when PF writes to MBOX(1), in next revisions when

	 * PF writes to MBOX(0)

		/* see the comment for nic_reg_write()/nic_reg_read()

		 * functions above

/* Responds to VF's READY message with VF's

 * ID, node, MAC address e.t.c

 * @vf: VF which sent READY message

/* ACKs VF's mailbox message

 * @vf: VF to which ACK to be sent

/* NACKs VF's mailbox message that PF is not able to

 * complete the action

 * @vf: VF to which ACK to be sent

/* Flush all in flight receive packets to memory and

 * bring down an active RQ

 Wait till sync cycle is finished */

 Get BGX Rx/Tx stats and respond to VF's request */

 Update hardware min/max frame size */

 Update corresponding LMAC credits */

	/* Enforce MTU in HW

	 * This config is supported only from 88xx pass 2.0 onwards.

 Set minimum transmit packet size */

	/* There is a issue in HW where-in while sending GSO sized

	 * pkts as part of TSO, if pkt len falls below this size

	 * NIC will zero PAD packet and also updates IP total length.

	 * Hence set this value to lessthan min pkt size of MAC+IP+TCP

	 * headers, BGX will do the padding to transmit 64 byte pkt.

 81xx's RGX has only one LMAC */

/* Function to check number of LMACs present and set VF::LMAC mapping.

 * Mapping will be used while initializing channels.

 Program LMAC credits */

 channel credit enable */

 Max outstanding pkt count */

 48KB BGX Tx buffer size, each unit is of size 16bytes */

		/* On CN81XX there are only 8 VFs but max possible no of

		 * interfaces are 9.

 Max RSSI / Max interfaces */

 Max RSSI / Max interfaces */

 Enable NIC HW block */

 Enable backpressure */

	/* TNS and TNS bypass modes are present only on 88xx

	 * Also offset of this CSR has changed in 81xx and 83xx.

 Disable TNS mode on both interfaces */

 Configure timestamp generation timeout to 10us */

 PKIND configuration */

 Timer config */

 Enable VLAN ethertype matching and stripping */

 Check if HW expected value is higher (could be in future chips) */

 Channel parse index configuration */

 Rx channel configuration */

 3 bits of PCP */

 3 bits PCP + DEI */

 6bits DSCP */

 RSS Qset, Qidx mapping */

 Determine port to channel adder */

 3 bits CS out of 6bits DSCP */

 Leave RSS_SIZE as '0' to disable RSS */

 Set MPI_ALG to '0' to disable MCAM parsing */

 MPI index is same as CPI if MPI_ALG is not enabled */

 Responsds to VF with its RSS indirection table size */

/* Receive side scaling configuration

 * configure:

 * - RSS index

 * - indir table i.e hash::RQ mapping

 * - no of hash bits to consider

/* 4 level transmit side scheduler configutation

 * for TNS bypass mode

 *

 * Sample configuration for SQ0 on 88xx

 * VNIC0-SQ0 -> TL4(0)   -> TL3[0]   -> TL2[0]  -> TL1[0] -> BGX0

 * VNIC1-SQ0 -> TL4(8)   -> TL3[2]   -> TL2[0]  -> TL1[0] -> BGX0

 * VNIC2-SQ0 -> TL4(16)  -> TL3[4]   -> TL2[1]  -> TL1[0] -> BGX0

 * VNIC3-SQ0 -> TL4(24)  -> TL3[6]   -> TL2[1]  -> TL1[0] -> BGX0

 * VNIC4-SQ0 -> TL4(512) -> TL3[128] -> TL2[32] -> TL1[1] -> BGX1

 * VNIC5-SQ0 -> TL4(520) -> TL3[130] -> TL2[32] -> TL1[1] -> BGX1

 * VNIC6-SQ0 -> TL4(528) -> TL3[132] -> TL2[33] -> TL1[1] -> BGX1

 * VNIC7-SQ0 -> TL4(536) -> TL3[134] -> TL2[33] -> TL1[1] -> BGX1

 24 bytes for FCS, IPG and preamble */

	/* For 88xx 0-511 TL4 transmits via BGX0 and

	 * 512-1023 TL4s transmit via BGX1.

	/* On 88xx 0-127 channels are for BGX0 and

	 * 127-255 channels for BGX1.

	 *

	 * On 81xx/83xx TL3_CHAN reg should be configured with channel

	 * within LMAC i.e 0-7 and not the actual channel number like on 88xx

 Enable backpressure on the channel */

 No priorities as of now */

	/* Unlike 88xx where TL2s 0-31 transmits to TL1 '0' and rest to TL1 '1'

	 * on 81xx/83xx TL2 needs to be configured to transmit to one of the

	 * possible LMACs.

	 *

	 * This register doesn't exist on 88xx.

 Send primary nicvf pointer to secondary QS's VF */

 Send SQS's nicvf pointer to primary QS's VF */

/* Find next available Qset that can be assigned as a

 * secondary Qset to a VF.

 Allocate additional Qsets for requested VF */

	/* Enable moving average calculation.

	 * Keep the LVL/AVG delay to HW enforced minimum so that, not too many

	 * packets sneek in between average calculations.

 Reset statistics counters */

 Configure tunnel parsing parameters */

 Enable or disable HW timestamping by BGX for pkts received on a LMAC */

		/* Skiplen to exclude 8byte timestamp while parsing pkt

		 * If not configured, will result in L2 errors.

 Adjust max packet length allowed */

/* Get BGX LMAC link status and update corresponding VF

 * if there is a change, valid only if internal L2 switch

 * is not present otherwise VF link is always treated as up

 Get BGX, LMAC indices for the VF */

 Get interface link status */

 Send a mbox message to VF with current link status */

 reply with link status */

 Interrupt handler to handle mailbox messages from VFs */

 Check if its a secondary Qset */

 Assign this Qset to primary Qset's VF */

		/* Enable CQE_RX2_S extension in CQE_RX descriptor.

		 * This gets appended by default on 81xx/83xx chips,

		 * for consistency enabling the same on 88xx pass2

		 * where this is introduced.

 NACK */

 Last message of VF config msg sequence */

 First msg in VF teardown sequence */

 NACK */

 NACK */

 NACK */

 NACK */

 Enable MSI-X */

 Register mailbox interrupt handler */

 Enable mailbox interrupt */

	/* Secondary Qsets are needed only if CPU count is

	 * morethan MAX_QUEUES_PER_QSET.

 Check if its a multi-node environment */

 MAP PF's configuration registers */

 Get HW capability info */

 Allocate memory for LMAC tracking elements */

 Initialize hardware */

 Register interrupts */

 Configure SRIOV */

 SPDX-License-Identifier: GPL-2.0-only

/*

 * Copyright (C) 2015 Cavium, Inc.

 Poll a register for a specific value */

 Allocate memory for a queue's descriptors */

 Save address, need it while freeing */

 Align memory address for 'align_bytes' */

 Free queue's descriptor memory */

/* Allocate a new page or recycle one if possible

 *

 * We cannot optimize dma mapping here, since

 * 1. It's only one RBDR ring for 8 Rx queues.

 * 2. CQE_RX gives address of the buffer where pkt has been DMA'ed

 *    and not idx into RBDR ring, so can't refer to saved info.

 * 3. There are multiple receive buffers per page

 Check if page is already allocated */

 Check if page can be recycled */

		/* This page can be recycled if internal ref_count and page's

		 * ref_count are equal, indicating that the page has been used

		 * once for packet transmission. For non-XDP mode, internal

		 * ref_count is always '1'.

 Check for space */

 Page can still be used */

 Save the page in page cache */

 Take additional page references for recycling */

		/* Since there is single RBDR (i.e single core doing

		 * page recycling) per 8 Rx queues, in XDP mode adjusting

		 * page references atomically is the biggest bottleneck, so

		 * take bunch of references at a time.

		 *

		 * So here, below reference counts defer by '1'.

		/* In non-XDP case, single 64K page is divided across multiple

		 * receive buffers, so cost of recycling is less anyway.

		 * So we can do with just one extra reference.

 Prefetch refcount of next page in page cache */

 Allocate buffer for packet reception */

	/* Check if request can be accomodated in previous allocated page.

	 * But in XDP mode only one buffer per page is permitted.

 Get new page, either recycled or new one */

 Reserve space for header modifications by BPF program */

 Check if it's recycled */

 HW will ensure data coherency, CPU sync not required */

 Build skb around receive buffer */

 Now build an skb to give to stack */

 Allocate RBDR ring and populate receive buffers */

 Buffer size has to be in multiples of 128 bytes */

	/* Initialize page recycling stuff.

	 *

	 * Can't use single buffer per page especially with 64K pages.

	 * On embedded platforms i.e 81xx/83xx available memory itself

	 * is low and minimum ring size of RBDR is 8K, that takes away

	 * lots of memory.

	 *

	 * But for XDP it has to be a single buffer per page.

 To free already allocated and mapped ones */

 Free RBDR ring and its receive buffers */

 Release page references */

 Release buffer of tail desc */

 Sync page cache info */

 Release additional page references held for recycling */

 Free RBDR ring */

/* Refill receive buffer descriptors with new buffers.

 Check if it's enabled */

 Get no of desc's to be refilled */

 Doorbell can be ringed with a max of ring size minus 1 */

 Sync page cache info */

 Start filling descs from tail */

 make sure all memory stores are done before ringing doorbell */

 Check if buffer allocation failed */

 Notify HW */

 Re-enable RBDR interrupts only if buffer allocation is success */

 Alloc rcv buffers in non-atomic mode for better success */

 In Softirq context, alloc rcv buffers in atomic mode */

 Initialize completion queue */

 Initialize transmit queue */

 Check if this SQ is a XDP TX queue */

 Alloc memory to save page pointers for XDP_TX */

 Preallocate memory for TSO segment's header */

 Unmap DMA mapped skb data buffers */

 HW will ensure data coherency, CPU sync not required */

 Free pending skbs in the queue */

 Check for dummy descriptor used for HW TSO offload on 88xx */

 Get actual TSO descriptors and unmap them */

 Disable send queue */

 Check if SQ is stopped */

 Reset send queue */

 Make sure all packets in the pipeline are written back into mem */

 Disable timer threshold (doesn't get reset upon CQ reset */

 Disable completion queue */

 Reset completion queue */

 Save head and tail pointers for feeing up buffers */

	/* If RBDR FIFO is in 'FAIL' state then do a reset first

	 * before relaiming.

 Disable RBDR */

 Enable first VLAN stripping */

 Configure Secondary Qsets, if any */

 Reset all RQ/SQ and VF stats */

 Configures receive queue */

 Disable receive queue */

 all writes of RBDR data to be loaded into L2 Cache as well*/

 Driver have no proper error path for failed XDP RX-queue info reg */

 Send a mailbox msg to PF to config RQ */

	/* RQ drop config

	 * Enable CQ drop to reserve sufficient CQEs for all tx packets

		/* Enable checking L3/L4 length and TCP/UDP checksums

		 * Also allow IPv6 pkts with zero UDP checksum.

 Enable Receive queue */

 Configures completion queue */

 Reset completion queue */

 Set completion queue base address */

 Enable Completion queue */

 Set threshold value for interrupt generation */

 Configures transmit queue */

 Reset send queue */

 Send a mailbox msg to PF to config SQ */

 Set queue base address */

 Enable send queue  & set queue size */

	/* CQ's level at which HW will stop processing SQEs to avoid

	 * transmitting a pkt with no space in CQ to post CQE_TX.

 Set threshold value for interrupt generation */

 Set queue:cpu affinity for better load distribution */

 Configures receive buffer descriptor ring */

 Set descriptor base address */

 Enable RBDR  & set queue size */

 Buffer size should be in multiples of 128 bytes */

 Notify HW */

 Set threshold value for interrupt generation */

 Requests PF to assign and enable Qset */

 Send a mailbox msg to PF to config Qset */

 Enable Tx timestamping capability */

 Free receive buffer descriptor ring */

 Free completion queue */

 Free send queue */

 Alloc receive buffer descriptor ring */

 Alloc send queue */

 Alloc completion queue */

 Set count of each queue */

 Set queue lengths */

	/* Take primary VF's queue lengths.

	 * This is needed to take queue lengths set from ethtool

	 * into consideration.

	/* Reset RXQ's stats.

	 * SQ's stats will get reset automatically once SQ is reset.

/* Get a free desc from SQ

 * returns descriptor ponter & descriptor number

 Rollback to previous tail pointer when descriptors not used */

 Free descriptor back to SQ for future use */

 Ring doorbell so that H/W restarts processing SQEs */

 XDP Transmit APIs */

 make sure all memory stores are done before ringing doorbell */

 Inform HW to xmit all TSO segments */

/* Calculate no of SQ subdescriptors needed to transmit all

 * segments of this TSO packet.

 * Taken from 'Tilera network driver' with a minor modification.

 id of the current fragment */

 current fragment size */

 bytes used from the current fragment */

 size of the current piece of payload */

 One edesc for header and for each piece of the payload. */

 Advance as needed. */

 Use bytes from the current fragment. */

 The last segment may be less than gso_size. */

 '+ gso_segs' for SQ_HDR_SUDESCs for each segment */

 Get the number of SQ descriptors needed to xmit this skb */

 Dummy descriptors to get TSO pkt completion notification */

/* Add SQ HEADER subdescriptor.

 * First subdescriptor for every send descriptor.

		/* post_cqe = 0, to avoid HW posting a CQE for every TSO

		 * segment transmitted on 88xx.

 Enable notification via CQE after processing SQE */

 No of subdescriptors following this */

 Offload checksum calculation to HW */

 Enable IP csum calculation */

 For non-tunneled pkts, point this to L2 ethertype */

 Check if timestamp is requested */

 Tx timestamping not supported along with TSO, so ignore request */

 HW supports only a single outstanding packet to timestamp */

 Mark the SKB for later reference */

	/* Finally enable timestamp generation

	 * Since 'post_cqe' is also set, two CQEs will be posted

	 * for this packet i.e CQE_TYPE_SEND and CQE_TYPE_SEND_PTP.

/* SQ GATHER subdescriptor

 * Must follow HDR descriptor

/* Add HDR + IMMEDIATE subdescriptors right after descriptors of a TSO

 * packet so that a CQE is posted as a notifation for transmission of

 * TSO packet.

 Enable notification via CQE after processing SQE */

 There is no packet to transmit here */

 Actual TSO header SQE index, needed for cleanup */

 make sure all memory stores are done before ringing doorbell */

 Inform HW to xmit all TSO segments */

/* Segment a TSO packet into 'gso_size' segments and append

 * them to SQ for transfer

 Save Qentry for adding HDR_SUBDESC at the end */

 Add segment's header */

 HDR_SUDESC + GATHER */

 Add segment's payload fragments */

 Save SKB in the last segment for freeing */

 Append an skb to a SQ for packet transfer. */

 Check if its a TSO packet */

 Add SQ header subdesc */

 Add SQ gather subdescs */

 HW will ensure data coherency, CPU sync not required */

 Check for scattered buffer */

			/* Free entire chain of mapped buffers

			 * here 'i' = frags mapped + above mapped skb->data

 Use original PCI dev for debug log */

		/* Check if it's a recycled page, if not

		 * unmap the DMA mapping.

		 *

		 * Recycled page holds an extra reference.

 Receive buffers in XDP mode are mapped from page start */

 Returns SKB for a received packet */

	/* Except 88xx pass1 on all other chips CQE_RX2_S is added to

	 * CQE_RX at word6, hence buffer pointers move by word

	 *

	 * Use existing 'hw_tso' flag which will be set for all chips

	 * except 88xx pass1 instead of a additional cache line

	 * access (or miss) by using pci dev's revision.

 First fragment */

 Add fragments */

 Next buffer pointer */

 Enable interrupt */

 Disable interrupt */

 Clear interrupt */

 Check if interrupt is enabled */

 If interrupt type is unknown, we treat it disabled. */

 Check for errors in the receive cmp.queue entry */

 Check for errors in the send cmp.queue entry */

/*

 * This file is subject to the terms and conditions of the GNU General Public

 * License.  See the file "COPYING" in the main directory of this archive

 * for more details.

 *

 * Copyright (C) 2009-2012 Cavium, Inc

/* Ring sizes that are powers of two allow for more efficient modulo

 * opertions.

 Allow 8 bytes for vlan and FCS. */

 Length of the buffer/packet in bytes */

 For TX, signals that the packet should be timestamped */

 The RX error code */

 Physical address of the buffer */

 The tx_list lock also protects the ring related variables */

 RX variables only touched in napi_poll.  No locking necessary. */

 CN56XX pass 1 needs 8 bytes of padding.  */

 Put it in the ring.  */

		/* Make sure there is no reorder of filling the ring and ringing

		 * the bell

 Ring the bell.  */

 Acknowledge to hardware that we have the buffer.  */

 Read the hardware TX timestamp if one was recorded */

 Read the timestamp */

 Remove the timestamp from the FIFO */

 Tell the kernel about the timestamp */

 These reads also clear the count registers.  */

 Do an atomic update. */

 These reads also clear the count registers.  */

 Do an atomic update. */

/*

 * Dequeue a receive skb and its corresponding ring entry.  The ring

 * entry is returned, *pskb is updated to point to the skb.

 A good packet, send it up. */

 Process the RX timestamp if it was recorded */

 The first 8 bytes are the timestamp */

		/* Packet split across skbs.  This can happen if we

		 * increase the MTU.  Buffers that are already in the

		 * rx ring can then end up being too small.  As the rx

		 * ring is refilled, buffers sized for the new MTU

		 * will be used and we should go back to the normal

		 * non-split case.

 Some other error, discard it. */

		/* Error statistics are accumulated in

		 * octeon_mgmt_update_rx_stats.

 Discard the whole mess. */

 Tell the hardware we processed a packet.  */

 Check for more packets. */

 We stopped because no more packets were available. */

 Reset the hardware to clean state.  */

 1 - Accept on CAM match */

 1 - Reject all multicast.  */

		/* One CAM entry for the primary address, leaves seven

		 * for the secondary addresses.

 2 - Accept all multicast.  */

 0 - Use CAM.  */

 Add primary address. */

 Disable packet I/O. */

 Allow broadcast */

 Restore packet I/O. */

	/* HW lifts the limit if the frame is VLAN tagged

	 * (+4 bytes per each tag, up to two tags)

	/* Set the hardware to truncate packets larger than the MTU. The jabber

	 * register must be set to a multiple of 8 bytes, so round up. JABBER is

	 * an unconditional limit, so we need to account for two possible VLAN

	 * tags.

 Clear any pending interrupts */

 reserved for future extensions */

 Check the status of hardware for tiemstamps */

 Get the current state of the PTP clock */

			/* The clock has not been configured to use an

			 * external source.  Program it to use the main clock

			 * reference.

 The clock is already programmed to use a GPIO */

 Enable the clock if it wasn't done already */

 Disable GMX before we make any changes. */

 Restore the GMX enable state only if link is set */

 1000 MBits is only supported on 6XXX chips */

 Only matters for half-duplex */

 No link */

 Write the new GMX setting with the port still disabled. */

 Read GMX CFG again to make sure the config is completed. */

 MII (both speeds) and RGMII 1000 speed. */

 RGMII mode */

 No PHYs in the simulator. */

 Allocate ring buffers.  */

 Bring it out of reset if needed. */

		/* Force compensation values, as they are not

		 * determined properly by HW

	/* Enable the port HW. Packets are not allowed until

	 * cvmx_mgmt_port_enable() is called.

 Strip the ending CRC */

 Enable the port */

 Arbitration mode */

 MII CB-request FIFO programmable high watermark */

 Read the PHY to find the mode of the interface. */

 Set the mode of the interface, RGMII/MII. */

		/* MII clocks counts are based on the 125Mhz

		 * reference, which has an 8nS period. So our delays

		 * need to be multiplied by this factor.

 Take the DLL and clock tree out of reset */

 Force write out before wait */

		/* Wait for the DLL to lock. External 125 MHz

		 * reference clock must be stable at this point.

 Enable the interface */

 Read the value back to force the previous write */

 Enable the compensation controller */

 Force write out before wait. */

 For compensation state to lock. */

		/* Default Interframe Gaps are too small.  Recommended

		 * workaround is.

		 *

		 * AGL_GMX_TX_IFG[IFG1]=14

		 * AGL_GMX_TX_IFG[IFG2]=10

 Clear statistics. */

 Clear on read. */

 Clear any pending interrupts */

 Interrupt every single RX packet */

 Interrupt when we have 1 or more packets to clean.  */

 Enable receive and transmit interrupts */

 Enable packet I/O. */

	/* When set, disables the length check for non-min sized pkts

	 * with padding in the client data.

 When set, disables the length check for VLAN pkts */

 When set, PREAMBLE checking is  less strict */

 Control Pause Frames can match station SMAC */

 Control Pause Frames can match globally assign Multicast address */

 Forward pause information to TX block */

 Drop Control Pause Frames */

 Strip off the preamble */

	/* This port is configured to send PREAMBLE+SFD to begin every

	 * frame.  GMX checks that the PREAMBLE is sent correctly.

 Configure the port duplex, speed and enables */

	/* PHY is not present in simulator. The carrier is enabled

	 * while initializing the phy for simulator, leave it enabled.

 dma_unmap is a nop on Octeon, so just free everything.  */

 Put it in the ring.  */

 Ring the bell.  */

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 * Copyright (C) 2020 Marvell International Ltd.

 update HW configuration */

 update SW configuration (busy bits, pointers) */

 update both HW and SW configuration */

 There's a 1:1 mapping between SecY and TX SC */

 Rotate keys u32[8] */

 MACSEC counters */

 forward to SA/SC table */

	/* The C bit is clear if and only if the Secure Data is

	 * exactly the same as the User Data and the ICV is 16 octets long.

 match all MACSEC ethertype packets */

 strip SecTAG & forward for decryption */

 If SCI is absent, then match by SA alone */

 Init Ethertype bypass filters */

 Match eth_type only */

 match for eth_type */

 Bypass MACSEC modules */

 Match eth_type only */

 match for eth_type */

 Bypass MACSEC modules */

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 *

 * Copyright (C) 2014-2019 aQuantia Corporation

 * Copyright (C) 2019-2020 Marvell International Ltd.

 File aq_ethtool.c: Definition of ethertool related functions. */

 Toeplitz */

 We do not allow change in unsupported parameters */

 Fill out the redirection table */

 Fill out the rss hash key */

	/* Atlantic only supports timing based coalescing

	/* We do not support frame counting. Check this

 SPDX-License-Identifier: GPL-2.0-only

 Copyright (C) 2014-2019 aQuantia Corporation. */

 File aq_filters.c: RX filters related functions. */

/* Function rebuilds array of vlan filters so that filters with assigned

 * queue have a precedence over just vlans on the interface.

 remove vlan if it was in table without queue assignment */

 otherwise left in promiscue mode */

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 *

 * Copyright (C) 2014-2019 aQuantia Corporation

 * Copyright (C) 2019-2020 Marvell International Ltd.

/* File aq_ptp.c:

 * Definition of functions for Linux PTP support.

 reset active flag if timeout detected */

/* aq_ptp_adjfine

 * @ptp: the ptp clock structure

 * @ppb: parts per billion adjustment from base

 *

 * adjust the frequency of the ptp cycle counter by the

 * indicated ppb from the base frequency.

/* aq_ptp_adjtime

 * @ptp: the ptp clock structure

 * @delta: offset to adjust the cycle counter by

 *

 * adjust the timer by resetting the timecounter structure.

/* aq_ptp_gettime

 * @ptp: the ptp clock structure

 * @ts: timespec structure to hold the current time value

 *

 * read the timecounter and return the correct value on ns,

 * after converting it into a struct timespec.

/* aq_ptp_settime

 * @ptp: the ptp clock structure

 * @ts: the timespec containing the new time for the cycle counter

 *

 * reset the timecounter to use a new base value instead of the kernel

 * wall timer value.

	/* Notify hardware of request to being sending pulses.

	 * If period is ZERO then pulsen is disabled.

 verify the request channel is there */

	/* we cannot support periods greater

	 * than 4 seconds due to reg limit

	/* convert to unsigned 64b ns,

	 * verify we can put it in a 32b register

 verify the value is in range supported by hardware */

 convert to unsigned 64b ns */

 TODO convert to AQ time */

 verify the request channel is there */

 PPS - pulse per second */

/* aq_ptp_gpio_feature_enable

 * @ptp: the ptp clock structure

 * @rq: the requested feature to change

 * @on: whether to enable or disable the feature

/* aq_ptp_verify

 * @ptp: the ptp clock structure

 * @pin: index of the pin in question

 * @func: the desired function to use

 * @chan: the function channel index to use

 verify the requested pin is there */

 enforce locked channels, no changing them */

 we want to keep the functions locked as well */

/* aq_ptp_tx_hwtstamp - utility function which checks for TX time stamp

 * @adapter: the private adapter struct

 *

 * if the timestamp is valid, we convert it into the timecounter ns

 * value, then store that result into the hwtstamps structure which

 * is passed up the network stack

/* aq_ptp_rx_hwtstamp - utility function which checks for RX time stamp

 * @adapter: pointer to adapter struct

 * @skb: particular skb to send timestamp with

 *

 * if the timestamp is valid, we convert it into the timecounter ns

 * value, then store that result into the hwtstamps structure which

 * is passed up the network stack

 Processing PTP TX traffic */

 Processing HW_TIMESTAMP RX traffic */

 Processing PTP RX traffic */

	/* Frags cannot be bigger 16KB

	 * because PTP usually works

	 * without Jumbo even in a background

 Drop packet because it doesn't make sence to delay it */

 Load offsets for PTP */

 100M */

 1G */

 2.5G */

 5G */

 10G */

 enable ptp counter */

 disable ptp */

 PTP external GPIO nanoseconds count */

 Sync1588 pin was triggered */

 Additional RX ring is allocated for PTP HWTS on A1 */

 Only Receive ring for HWTS */

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 *

 * Copyright (C) 2018-2019 aQuantia Corporation

 * Copyright (C) 2019-2020 Marvell International Ltd.

 Set Address register. */

 Send Address command. */

 Send Read command. */

 Read result. */

 Set Address register. */

 Send Address command. */

 Send Write command. */

 PMA Standard Device Identifier 2: Address 1.3 */

	/* PMA Standard Device Identifier:

	 * Address 1.2 = MSW,

	 * Address 1.3 = LSW

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 *

 * Copyright (C) 2014-2019 aQuantia Corporation

 * Copyright (C) 2019-2020 Marvell International Ltd.

 File aq_pci_func.c: Definition of PCI functions. */

ATL_REGS_SIZE*/)) {

 Request IRQ vector for PTP */

enable interrupts */

 net device init */

 Reinitialize Nic/Vecs objects */

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 *

 * Copyright (C) 2014-2019 aQuantia Corporation

 * Copyright (C) 2019-2020 Marvell International Ltd.

/* File aq_vec.c: Definition of common structure for vector of Rx and Tx rings.

 * Definition of functions for Rx and Tx rings. Friendly module for aq_nic.

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 *

 * Copyright (C) 2014-2019 aQuantia Corporation

 * Copyright (C) 2019-2020 Marvell International Ltd.

/* File aq_hw_utils.c: Definitions of helper functions used across

 * hardware layer.

/* Most of 64-bit registers are in LSW, MSW form.

   Counters are normally implemented by HW as latched pairs:

   reading LSW first locks MSW, to overcome LSW overflow

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 *

 * Copyright (C) 2014-2019 aQuantia Corporation

 * Copyright (C) 2019-2020 Marvell International Ltd.

 File aq_ring.c: Definition of functions for Rx/Tx rings. */

 Drop the ref for being in the ring. */

 One means ring is the only user and can reuse */

 Try reuse buffer */

				/* Buffer exhausted. We have other users and

				 * should release this page and realloc

 Send all PTP traffic to 0 queue */

 This data should mimic aq_ethtool_queue_rx_stat_names structure */

 This data should mimic aq_ethtool_queue_tx_stat_names structure */

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 *

 * Copyright (C) 2014-2019 aQuantia Corporation

 * Copyright (C) 2019-2020 Marvell International Ltd.

 File aq_main.c: Main file for aQuantia Linux driver. */

		/* Hardware adds the Timestamp for PTPv2 802.AS1

		 * and PTPv2 IPv4 UDP.

		 * We have to push even general 320 port messages to the ptp

		 * queue explicitly. This is a limitation of current firmware

		 * and hardware PTP design of the chip. Otherwise ptp stream

		 * will fail to sync

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 *

 * Copyright (C) 2014-2019 aQuantia Corporation

 * Copyright (C) 2019-2020 Marvell International Ltd.

 File aq_drvinfo.c: Definition of common code for firmware info in sys.*/

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 *

 * Copyright (C) 2014-2019 aQuantia Corporation

 * Copyright (C) 2019-2020 Marvell International Ltd.

 File aq_nic.c: Definition of common code for NIC. */

 Recalculate the number of vectors */

 cfg->vecs should be power of 2 for RSS */

rss rings */

 Checks hw_caps and 'corrects' aq_nic_cfg in runtime */

descriptors */

	/* Check if we have enough vectors allocated for

	 * link status IRQ. If no - we'll know link state from

	 * slower service task.

		/* Driver has to update flow control settings on RX block

		 * on any link event.

		 * We should query FW whether it negotiated FC.

	/* Some engineering samples of Aquantia NICs are provisioned with a

	 * partially populated MAC, which is still invalid.

 Restore default settings */

		/* Disable the PTP on NICs where it's known to cause datapath

		 * problems.

		 * Ideally this should have been done by PHY provisioning, but

		 * many units have been shipped with enabled PTP block already.

 UDP GSO Hardware does not replace packet length. */

 Above status update may stop the queue. Check this. */

 Asym is when either RX or TX, but not both */

 msecs plays no role - configuration is always fixed in PHY */

	/* if already the same configuration or

	 * disable request (tcs is 0) and we already is disabled

 Changing the number of TCs might change the number of vectors */

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 * Copyright (C) 2020 Marvell International Ltd.

/* This should never be used on non atomic fields,

 * treat any > u32 read as non atomic.

 No actions */

	/* There's only one temperature sensor on A2, use it for

	 * both MAC and PHY.

	/* We should put renegotiate status back to zero

	 * after command completes

 A2 FW version is stored in reverse order */

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 * Copyright (C) 2020 Marvell International Ltd.

 rpf */

 TX */

 set action resolver record */

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 * Copyright (C) 2020 Marvell International Ltd.

 TPS Descriptor rate init */

 TPS VM init */

 Tx buf size TC0 */

 QoS Rx buf size per TC */

 QoS 802.1p priority -> TC mapping */

 ATL2 Apply ring to TC mapping */

 Scale factor is based on the number of bits in fractional portion */

 By default max_credit is based upon MTU (in unit of 64b) */

 in unit of 4b */

 First, calculate weights where min_rate is specified */

	/* WSP, if min_rate is set for at least one TC.

	 * RR otherwise.

	/* Data TC Arbiter takes precedence over Descriptor TC Arbiter,

	 * leave Descriptor TC Arbiter as RR.

 Nominal rate is always 10G */

			/* A value of 1 indicates the queue is not

			 * rate controlled.

 Tx TC/RSS number config */

 Tx interrupts */

 misc */

	/* Action Resolver Table (ART) is used by RPF to decide which action

	 * to take with a packet based upon input tag and tag mask, where:

	 *  - input tag is a combination of 3-bit VLan Prio (PTP) and

	 *    29-bit concatenation of all tags from filter block;

	 *  - tag mask is a mask used for matching against input tag.

	 * The input_tag is compared with the all the Requested_tags in the

	 * Record table to find a match. Action field of the selected matched

	 * REC entry is used for further processing. If multiple entries match,

	 * the lowest REC entry, Action field will be selected.

	/* FW reserves the beginning of ART, thus all driver entries must

	 * start from the offset specified in FW caps.

	/* Configure ART to map given VLan Prio (PCP) to the TC index for

	 * RSS redirection table.

 turn VLAN promisc mode too */

 Rx TC/RSS number config */

 Rx flow control */

 RSS Ring selection */

 Multicast filters */

 Vlan filters */

 Always accept untagged packets */

 Rx Interrupts */

 Reset link status and read out initial hardware counters */

 Interrupts */

 Interrupts */

 HW timers are in 2us units */

 10Gbit */

 5Gbit */

 5Gbit 5GS */

 2.5Gbit */

 1Gbit */

 100Mbit */

 10Gbit */

 5Gbit */

 5Gbit 5GS */

 2.5Gbit */

 1Gbit */

 100Mbit */

 Update user visible ITR settings */

 set promisc in case of disabing the vlan filter */

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 * Copyright (C) 2020 Marvell International Ltd.

 Host boot requested */

 Wait for RBL boot */

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 * Copyright (C) 2020 Marvell International Ltd.

/*******************************************************************************

 *                               MDIO wrappers

/*******************************************************************************

 *                          MACSEC config and status

	/* NOTE: MSS registers must always be read/written as adjacent pairs.

	 * For instance, to write either or both 1E.80A0 and 80A1, we have to:

	 * 1. Write 1E.80A0 first

	 * 2. Then write 1E.80A1

	 *

	 * For HHD devices: These writes need to be performed consecutively, and

	 * to ensure this we use the PIF mailbox to delegate the reads/writes to

	 * the FW.

	 *

	 * For EUR devices: Not need to use the PIF mailbox; it is safe to

	 * write to the registers directly.

 Write the packed record words to the data buffer registers. */

 Clear out the unused data buffer registers. */

 Select the table and row index to write to */

/*! Read the specified Ingress LUT table row.

 *  packed_record - [OUT] The table row data (raw).

 Select the table and row index to read */

! Write packed_record to the specified Egress LUT table row. */

 Write the packed record words to the data buffer registers. */

 Clear out the unused data buffer registers. */

 Select the table and row index to write to */

 Select the table and row index to read */

	/* If the row that we want to read is odd, first read the previous even

	 * row, throw that value away, and finally read the desired row.

	 * This is a workaround for EUR devices that allows us to read

	 * odd-numbered rows.  For HHD devices: this workaround will not work,

	 * so don't bother; odd-numbered rows are not readable.

	/* If the row that we want to read is odd, first read the previous even

	 * row, throw that value away, and finally read the desired row.

	/* If the row that we want to read is odd, first read the previous even

	 * row, throw that value away, and finally read the desired row.

	/* If the row that we want to read is odd, first read the previous even

	 * row, throw that value away, and finally read the desired row.

	/* If the row that we want to read is odd, first read the previous even

	 * row, throw that value away, and finally read the desired row.

	/* If the row that we want to read is odd, first read the previous even

	 * row, throw that value away, and finally read the desired row.

 Toggle the Egress MIB clear bit 0->1->0 */

 Toggle the Ingress MIB clear bit 0->1->0 */

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 *

 * Copyright (C) 2014-2019 aQuantia Corporation

 * Copyright (C) 2019-2020 Marvell International Ltd.

/* File hw_atl_llh.c: Definitions of bitfield and register access functions for

 * Atlantic registers.

 global */

 stats */

 interrupt */

 register address for bitfield imr_rx{r}_en */

 bitmask for bitfield imr_rx{r}_en */

 lower bit position of bitfield imr_rx{r}_en */

 register address for bitfield imr_tx{t}_en */

 bitmask for bitfield imr_tx{t}_en */

 lower bit position of bitfield imr_tx{t}_en */

 register address for bitfield imr_rx{r}[4:0] */

 bitmask for bitfield imr_rx{r}[4:0] */

 lower bit position of bitfield imr_rx{r}[4:0] */

 register address for bitfield imr_tx{t}[4:0] */

 bitmask for bitfield imr_tx{t}[4:0] */

 lower bit position of bitfield imr_tx{t}[4:0] */

 set RSC interrupt */

 set RSC delay */

 rdm */

 reg */

 RPB: rx packet buffer */

 rpf */

 register address for bitfield rx_tc_up{t}[2:0] */

 bitmask for bitfield rx_tc_up{t}[2:0] */

 lower bit position of bitfield rx_tc_up{t}[2:0] */

 RPO: rx packet offload */

 Register address for bitfield lro{L}_des_max[1:0] */

 Bitmask for bitfield lro{L}_des_max[1:0] */

 Lower bit position of bitfield lro{L}_des_max[1:0] */

 rx */

 tdm */

 thm */

 TPB: tx packet buffer */

 TPO: tx packet offload */

 TPS: tx packet scheduler */

 tx */

 msm */

 pci */

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 *

 * Copyright (C) 2014-2019 aQuantia Corporation

 * Copyright (C) 2019-2020 Marvell International Ltd.

 File hw_atl_b0.c: Definition of Atlantic hardware specific functions. */

 Init TC2 for PTP_TX */

 Init TC2 for PTP_RX */

 No flow control for PTP */

 TPS Descriptor rate init */

 TPS VM init */

 Tx buf size TC0 */

 QoS Rx buf size per TC */

 QoS 802.1p priority -> TC mapping */

 TX checksums offloads*/

 RX checksums offloads*/

 LSO offloads*/

 Outer VLAN tag offload */

 LRO offloads */

		/* the LRO timebase divider is 5 uS (0x61a),

		 * which is multiplied by 50(0x32)

		 * to get a maximum coalescing interval of 250 uS,

		 * which is the default value

 Scale factor is based on the number of bits in fractional portion */

 By default max_credit is based upon MTU (in unit of 64b) */

 First, calculate weights where min_rate is specified */

	/* WSP, if min_rate is set for at least one TC.

	 * RR otherwise.

	 *

	 * NB! MAC FW sets arb mode itself if PTP is enabled. We shouldn't

	 * overwrite it here in that case.

	/* Data TC Arbiter takes precedence over Descriptor TC Arbiter,

	 * leave Descriptor TC Arbiter as RR.

 Nominal rate is always 10G */

			/* A value of 1 indicates the queue is not

			 * rate controlled.

 Tx TC/Queue number config */

 Tx interrupts */

 misc */

 Rx TC/RSS number config */

 Rx flow control */

 RSS Ring selection */

 Multicast filters */

 Vlan filters */

 Always accept untagged packets

 Rx Interrupts */

 misc */

 Force limit MRRS on RDM/TDM to 2K */

	/* TX DMA total request limit. B0 hardware is not capable to

	 * handle more than (8K-MRRS) incoming DMA data.

	 * Value 24 in 256byte units

 Reset link status and read out initial hardware counters */

 Interrupts */

 Interrupts */

 Enable link interrupt */

 PAY_LEN */

 enable tx context */

 Tx checksum offloads */

 Rx ring set mode */

 Mapping interrupt vector */

 Set Tx threshold */

 Mapping interrupt vector */

 Make sure descriptors are updated before bump tail*/

 RxD is not done */

 RxD is not done */

 Checksum offload workaround for small packets */

 MAC error or DMA error */

 last 4 byte */

 LRO */

 jumbo */

 HW timers are in 2us units */

 10Gbit */

 5Gbit */

 5Gbit 5GS */

 2.5Gbit */

 1Gbit */

 100Mbit */

 10Gbit */

 5Gbit */

 5Gbit 5GS */

 2.5Gbit */

 1Gbit */

 100Mbit */

 Update user visible ITR settings */

	/* Invalidate Descriptor Cache to prevent writing to the cached

	 * descriptors and to the data pointer of those descriptors

 For accuracy, the digit is extended */

 MAC MCP counter freq is macfreq / 4 */

 Apply time offset */

 Enable/disable Sync1588 GPIO Timestamping */

 PTP external GPIO clock seconds count 15:0 */

 PTP external GPIO clock seconds count 31:16 */

 PTP external GPIO clock nanoseconds count 15:0 */

 PTP external GPIO clock nanoseconds count 31:16 */

	/* The TIMESTAMP in the end of package has following format:

	 * (big-endian)

	 *   struct {

	 *     uint64_t sec;

	 *     uint32_t ns;

	 *     uint16_t stream_id;

	 *   };

/*

 * @brief Set VLAN filter table

 * @details Configure VLAN filter table to accept (and assign the queue) traffic

 *  for the particular vlan ids.

 * Note: use this function under vlan promisc mode not to lost the traffic

 *

 * @param aq_hw_s

 * @param aq_rx_filter_vlan VLAN filter configuration

 * @return 0 - OK, <0 - error

 set promisc in case of disabing the vland filter */

 Set AFE Temperature Sensor to on (off by default)

 Reset internal capacitors, biasing, and counters

 Set AFE Temperature Sensor back to off

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 *

 * Copyright (C) 2014-2019 aQuantia Corporation

 * Copyright (C) 2019-2020 Marvell International Ltd.

/* File hw_atl_utils.c: Definition of common functions for Atlantic hardware

 * abstraction layer.

 Cleanup SPI */

 Kickstart MAC */

 Reset SPI again because of possible interrupted SPI burst */

 Clear SPI reset state */

 FW reset */

 Kickstart PHY - skipped */

 Global software reset*/

 Old FW requires fixed delay after init */

 Alter RBL status */

 Cleanup SPI */

 Global software reset*/

 Wait for RBL boot */

 Restore NVR */

 Old FW requires fixed delay after init */

		/* FW 1.x may bootup in an invalid POWER state (WOL feature).

		 * We should work around this by forcing its state back to DEINIT

 Acquire 2 semaphores before issuing reset for FW 4.x */

 1000 times by 10us = 10ms */

 check 10 times by 1ms */

	/* On interface DEINIT we disable DW (raise bit)

	 * Otherwise enable DW (clear bit)

 Set new state bits */

 chip revision */

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 *

 * Copyright (C) 2014-2019 aQuantia Corporation

 * Copyright (C) 2019-2020 Marvell International Ltd.

 File hw_atl_a0.c: Definition of Atlantic hardware specific functions. */

 check 10 times by 1ms */

 check 10 times by 1ms */

 TPS Descriptor rate init */

 TPS VM init */

 TPS TC credits init */

 Tx buf size */

 QoS Rx buf size per TC */

 QoS 802.1p priority -> TC mapping */

 TX checksums offloads*/

 RX checksums offloads*/

 LSO offloads*/

 Tx interrupts */

 misc */

 Rx TC/RSS number config */

 Rx flow control */

 RSS Ring selection */

 Multicast filters */

 Vlan filters */

 Rx Interrupts */

 misc */

 Reset link status and read out initial hardware counters */

 Interrupts */

 Interrupts */

 PAY_LEN */

 Tx checksum offloads */

 Rx ring set mode */

 Mapping interrupt vector */

 Set Tx threshold */

 Mapping interrupt vector */

 RxD is not done */

 Checksum offload workaround for small packets */

 status error or DMA error */

 last 4 byte */

 jumbo */

 10Gbit */

 5Gbit */

 5Gbit 5GS */

 2.5Gbit */

 1Gbit */

 100Mbit */

 SPDX-License-Identifier: GPL-2.0-only

/* Atlantic Network Driver

 *

 * Copyright (C) 2014-2019 aQuantia Corporation

 * Copyright (C) 2019-2020 Marvell International Ltd.

/* File hw_atl_utils_fw2x.c: Definition of firmware 2.x functions for

 * Atlantic hardware abstraction layer.

 check 10 times by 1ms */

	/* There is not explicit mode of RX only pause frames,

	 * thus, we join this mode with FC full.

	 * FC full is either Rx, either Tx, or both.

 No actions */

 Toggle statistics bit for FW to update */

 Wait FW to report back */

 Toggle statistics bit for FW to 0x36C.18 (CTRL_TEMPERATURE) */

 Wait FW to report back */

	/* Convert PHY temperature from 1/256 degree Celsius

	 * to 1/1000 degree Celsius.

 Write data to drvIface Mailbox */

 Toggle statistics bit for FW to update */

 Wait FW to report back */

 Write macsec request to cfg memory */

 Toggle 0x368.CAPS_LO_MACSEC bit */

 Wait FW to report back */

 Read status of write operation */

 SPDX-License-Identifier: GPL-2.0-only

/* 10G controller driver for Samsung SoCs

 *

 * Copyright (C) 2013 Samsung Electronics Co., Ltd.

 *		http://www.samsung.com

 *

 * Author: Siva Reddy Kallam <siva.kallam@samsung.com>

 TX/RX IRQ events */

 Bus access errors */

 EEE-LPI stats */

 RX specific */

 L2 error */

 L2 Pkt type */

 L3/L4 Pkt type */

 Filter specific */

 RX context specific */

		/* We are asking for enabling the EEE but it is safe

		 * to verify all by invoking the eee_init function.

		 * In case of failure it will return an error.

 Do not change tx_lpi_timer in case of failure */

 Report default options for RSS on sxgbe */

	/* RSS does not support anything other than hashing

	 * to queues on src and dst IPs and ports

 Read SXGBE RSS control register and update */

 MAC registers */

 MTL registers */

 DMA registers */

 SPDX-License-Identifier: GPL-2.0-only

/* 10G controller driver for Samsung SoCs

 *

 * Copyright (C) 2013 Samsung Electronics Co., Ltd.

 *		http://www.samsung.com

 *

 * Author: Siva Reddy Kallam <siva.kallam@samsung.com>

 CONFIG_OF */

/**

 * sxgbe_platform_probe

 * @pdev: platform device pointer

 * Description: platform_device probe function. It allocates

 * the necessary resources and invokes the main to init

 * the net device, register the mdio bus etc.

 Get memory resource */

 Get the SXGBE common INT information */

 Get MAC address if available (DT) */

 Get the TX/RX IRQ numbers */

/**

 * sxgbe_platform_remove

 * @pdev: platform device pointer

 * Description: this function calls the main to free the net resources

 * and calls the platforms hook and release the resources (e.g. mem).

 CONFIG_PM */

 sentinel */ }

 SPDX-License-Identifier: GPL-2.0-only

/* 10G controller driver for Samsung SoCs

 *

 * Copyright (C) 2013 Samsung Electronics Co., Ltd.

 *		http://www.samsung.com

 *

 * Author: Siva Reddy Kallam <siva.kallam@samsung.com>

 write command */

 post read  increament address */

 read command */

 skip the address frame */

 mii busy */

 3 seconds */

 set mdio address register */

 set mdio address register */

 Ports 0-3 only support C22. */

/**

 * sxgbe_mdio_read

 * @bus: points to the mii_bus structure

 * @phyaddr: address of phy port

 * @phyreg: address of register with in phy register

 * Description: this function used for C45 and C22 MDIO Read

/**

 * sxgbe_mdio_write

 * @bus: points to the mii_bus structure

 * @phyaddr: address of phy port

 * @phyreg: address of phy registers

 * @phydata: data to be written into phy register

 * Description: this function is used for C45 and C22 MDIO write

 allocate the new mdio bus */

 assign mii bus fields */

 register with kernel subsystem */

			/* If an IRQ was provided to be assigned after

			 * the bus probe, do it here.

			/* If we're  going to bind the MAC to this PHY bus,

			 * and no PHY number was provided to the MAC,

			 * use the one probed here.

 SPDX-License-Identifier: GPL-2.0-only

/* 10G controller driver for Samsung SoCs

 *

 * Copyright (C) 2013 Samsung Electronics Co., Ltd.

 *		http://www.samsung.com

 *

 * Author: Siva Reddy Kallam <siva.kallam@samsung.com>

 MAC core initialization */

 TX configuration */

	/* Other configurable parameters IFP, IPG, ISR, ISM

	 * needs to be set if needed

 RX configuration */

	/* Other configurable parameters CST, SPEN, USP, GPSLCE

	 * WD, LM, S2KP, HDSMS, GPSL, ELEN, ARPEN needs to be

	 * set if needed

 Dump MAC registers */

 Reading this register shall clear all the LPI status bits */

 Handle extra events on specific interrupts hw dependent */

 Set power management mode (e.g. magic frame) */

 Set/Get Unicast MAC addresses */

 extract and assign address */

 If supported then get the optional core features */

 clear the speed bits */

 set the speed */

	/* Enable the LPI mode for transmit path with Tx automate bit set.

	 * When Tx Automate bit is set, MAC internally handles the entry

	 * to LPI mode after all outstanding and pending packets are

	 * transmitted.

 If the PHY link status is UP then set PLS */

	/* Program the timers in the LPI timer control register:

	 * LS: minimum time (ms) for which the link

	 *  status from PHY should be ok before transmitting

	 *  the LPI pattern.

	 * TW: minimum time (us) for which the core waits

	 *  after it has stopped transmitting the LPI pattern.

 SPDX-License-Identifier: GPL-2.0-only

/* 10G controller driver for Samsung SoCs

 *

 * Copyright (C) 2013 Samsung Electronics Co., Ltd.

 *		http://www.samsung.com

 *

 * Author: Siva Reddy Kallam <siva.kallam@samsung.com>

 Module parameters */

 The default timer value as per the sxgbe specification 1 sec(1000 ms) */

/**

 * sxgbe_verify_args - verify the driver parameters.

 * Description: it verifies if some wrong parameter is passed to the driver.

 * Note that wrong parameters are replaced with the default values.

 Check and enter in LPI mode */

 Exit and disable EEE in case of we are are in LPI state. */

/**

 * sxgbe_eee_ctrl_timer

 * @t: timer list containing a data

 * Description:

 *  If there is no data transfer and if we are not in LPI state,

 *  then MAC Transmitter can be moved to LPI state.

/**

 * sxgbe_eee_init

 * @priv: private device pointer

 * Description:

 *  If the EEE support has been enabled while configuring the driver,

 *  if the GMAC actually supports the EEE (from the HW cap reg) and the

 *  phy can also manage EEE, so enable the LPI state and start the timer

 *  to verify if the tx path can enter in LPI state.

 MAC core supports the EEE feature. */

 Check if the PHY supports EEE */

	/* When the EEE has been already initialised we have to

	 * modify the PLS bit in the LPI ctrl & status reg according

	 * to the PHY link status. For this reason.

/**

 * sxgbe_clk_csr_set - dynamically set the MDC clock

 * @priv: driver private structure

 * Description: this is to dynamically set the MDC clock according to the csr

 * clock input.

	/* assign the proper divider, this will be used during

	 * mdio communication

 minimum number of free TX descriptors required to wake up TX process */

/**

 * sxgbe_adjust_link

 * @dev: net device structure

 * Description: it adjusts the link parameters.

	/* SXGBE is not supporting auto-negotiation and

	 * half duplex mode. so, not handling duplex change

	 * in this function. only handling speed and link status

 Alter the MAC settings for EEE */

/**

 * sxgbe_init_phy - PHY initialization

 * @ndev: net device structure

 * Description: it initializes the driver's PHY state, and attaches the PHY

 * to the mac driver.

 *  Return value:

 *  0 on success

 assign default link status */

 Stop Advertising 1000BASE Capability if interface is not GMII */

/**

 * sxgbe_clear_descriptors: clear descriptors

 * @priv: driver private structure

 * Description: this function is called to clear the tx and rx descriptors

 * in case of both basic and extended descriptors are used.

 Clear the Rx/Tx descriptors */

/**

 * sxgbe_free_rx_buffers - free what sxgbe_init_rx_buffers() allocated

 * @dev: net device structure

 * @p: dec pointer

 * @i: index

 * @dma_buf_sz: size

 * @rx_ring: ring to be freed

 *

 * Description:  this function initializes the DMA RX descriptor

/**

 * init_tx_ring - init the TX descriptor ring

 * @dev: net device structure

 * @queue_no: queue

 * @tx_ring: ring to be initialised

 * @tx_rsize: ring size

 * Description:  this function initializes the DMA TX descriptor

 TX ring is not allcoated */

 allocate memory for TX descriptors */

 allocate memory for TX skbuff array */

 assign queue number */

 initialise counters */

/**

 * free_rx_ring - free the RX descriptor ring

 * @dev: net device structure

 * @rx_ring: ring to be initialised

 * @rx_rsize: ring size

 * Description:  this function initializes the DMA RX descriptor

/**

 * init_rx_ring - init the RX descriptor ring

 * @dev: net device structure

 * @queue_no: queue

 * @rx_ring: ring to be initialised

 * @rx_rsize: ring size

 * Description:  this function initializes the DMA RX descriptor

 Set the max buffer size according to the MTU. */

 RX ring is not allcoated */

 assign queue number */

 allocate memory for RX descriptors */

 allocate memory for RX skbuff array */

 initialise the buffers */

 initialise counters */

/**

 * free_tx_ring - free the TX descriptor ring

 * @dev: net device structure

 * @tx_ring: ring to be initialised

 * @tx_rsize: ring size

 * Description:  this function initializes the DMA TX descriptor

/**

 * init_dma_desc_rings - init the RX/TX descriptor rings

 * @netd: net device structure

 * Description:  this function initializes the DMA RX/TX descriptors

 * and allocates the socket buffers. It suppors the chained and ring

 * modes.

 Allocate memory for queue structures and TX descs */

		/* save private pointer in each ring this

		 * pointer is needed during cleaing TX queue

 Allocate memory for queue structures and RX descs */

		/* save private pointer in each ring this

		 * pointer is needed during cleaing TX queue

 Release the DMA TX buffers */

 Release the TX ring memory also */

 Release the RX ring memory also */

/**

 *  sxgbe_mtl_operation_mode - HW MTL operation mode

 *  @priv: driver private structure

 *  Description: it sets the MTL operation mode: tx/rx MTL thresholds

 *  or Store-And-Forward capability.

 TX/RX threshold control */

 set TC mode for TX QUEUES */

 set TC mode for RX QUEUES */

 set TC mode for TX QUEUES */

 set TC mode for RX QUEUES */

/**

 * sxgbe_tx_queue_clean:

 * @tqueue: queue pointer

 * Description: it reclaims resources after transmission completes.

 Check if the descriptor is owned by the DMA. */

 wake up queue */

/**

 * sxgbe_tx_all_clean:

 * @priv: driver private structure

 * Description: it reclaims resources after transmission completes.

/**

 * sxgbe_restart_tx_queue: irq tx error mng function

 * @priv: driver private structure

 * @queue_num: queue number

 * Description: it cleans the descriptors and restarts the transmission

 * in case of errors.

 stop the queue */

 stop the tx dma */

 free the skbuffs of the ring */

 initialise counters */

 start the tx dma */

 wakeup the queue */

/**

 * sxgbe_reset_all_tx_queues: irq tx error mng function

 * @priv: driver private structure

 * Description: it cleans all the descriptors and

 * restarts the transmission on all queues in case of errors.

	/* On TX timeout of net device, resetting of all queues

	 * may not be proper way, revisit this later if needed

/**

 * sxgbe_get_hw_features: get XMAC capabilities from the HW cap. register.

 * @priv: driver private structure

 * Description:

 *  new GMAC chip generations have a new register to indicate the

 *  presence of the optional feature/functions.

 *  This can be also used to override the value passed through the

 *  platform and necessary for old MAC10/100 and GMAC chips.

 Read First Capability Register CAP[0] */

 Read First Capability Register CAP[1] */

 Read First Capability Register CAP[2] */

/**

 * sxgbe_check_ether_addr: check if the MAC addr is valid

 * @priv: driver private structure

 * Description:

 * it is to verify if the MAC address is valid, in case of failures it

 * generates a random MAC address

/**

 * sxgbe_init_dma_engine: DMA init.

 * @priv: driver private structure

 * Description:

 * It inits the DMA invoking the specific SXGBE callback.

 * Some DMA parameters can be passed from the platform;

 * in case of these are not passed a default is kept for the MAC or GMAC.

/**

 * sxgbe_init_mtl_engine: MTL init.

 * @priv: driver private structure

 * Description:

 * It inits the MTL invoking the specific SXGBE callback.

/**

 * sxgbe_disable_mtl_engine: MTL disable.

 * @priv: driver private structure

 * Description:

 * It disables the MTL queues by invoking the specific SXGBE callback.

/**

 * sxgbe_tx_timer: mitigation sw timer for tx.

 * @t: timer pointer

 * Description:

 * This is the timer handler to directly invoke the sxgbe_tx_clean.

/**

 * sxgbe_tx_init_coalesce: init tx mitigation options.

 * @priv: driver private structure

 * Description:

 * This inits the transmit coalesce parameters: i.e. timer rate,

 * timer handler and default threshold used for enabling the

 * interrupt on completion bit.

/**

 *  sxgbe_open - open entry point of the driver

 *  @dev : pointer to the device structure.

 *  Description:

 *  This function is the open entry point of the driver.

 *  Return value:

 *  0 on success and an appropriate (-)ve integer as defined in errno.h

 *  file on failure.

 Init the phy */

 Create and initialize the TX/RX descriptors chains. */

 DMA initialization and SW reset */

  MTL initialization */

 Copy the MAC addr into the HW  */

 Initialize the MAC Core */

 Request the IRQ lines */

	/* If the LPI irq is different from the mac irq

	 * register a dedicated handler

 Request TX DMA irq lines */

 Request RX DMA irq lines */

 Enable the MAC Rx/Tx */

 Set the HW DMA mode and the COE */

 Extra statistics */

 Start the ball rolling... */

 initialise TX coalesce parameters */

/**

 *  sxgbe_release - close entry point of the driver

 *  @dev : device pointer.

 *  Description:

 *  This is the stop entry point of the driver.

 Stop and disconnect the PHY */

 delete TX timers */

 Stop TX/RX DMA and clear the descriptors */

 disable MTL queue */

 Release and free the Rx/Tx resources */

 Disable the MAC Rx/Tx */

 Prepare first Tx descriptor for doing TSO operation */

 Write first Tx descriptor with appropriate value */

/**

 *  sxgbe_xmit: Tx entry point of the driver

 *  @skb : the socket buffer

 *  @dev : device pointer

 *  Description : this is the tx entry point of the driver.

 *  It programs the chain or the ring and supports oversized frames

 *  and SG feature.

 get the TX queue handle */

 save the skb address */

 TSO support */

 prepare the descriptor */

 memory barrier to flush descriptor */

 set the owner */

 close the descriptors */

 memory barrier to flush descriptor */

 set owner for first desc */

 memory barrier to flush descriptor */

 display current ring */

 declare that device is doing timestamping */

/**

 * sxgbe_rx_refill: refill used skb preallocated buffers

 * @priv: driver private structure

 * Description : this is to reallocate the skb for the reception process

 * that is based on zero-copy.

 Added memory barrier for RX descriptor modification */

 Added memory barrier for RX descriptor modification */

/**

 * sxgbe_rx: receive the frames from the remote host

 * @priv: driver private structure

 * @limit: napi bugget.

 * Description :  this the function called by the napi poll method.

 * It gets all the frames inside the ring.

		/* Read the status of the incoming frame and also get checksum

		 * value based on whether it is enabled in SXGBE hardware or

		 * not.

/**

 *  sxgbe_poll - sxgbe poll method (NAPI)

 *  @napi : pointer to the napi structure.

 *  @budget : maximum number of packets that the current CPU can receive from

 *	      all interfaces.

 *  Description :

 *  To look at the incoming frames and clear the tx resources.

 first, clean the tx queues */

/**

 *  sxgbe_tx_timeout

 *  @dev : Pointer to net device structure

 *  @txqueue: index of the hanging queue

 *  Description: this function is called when a packet transmission fails to

 *   complete within a reasonable time. The driver will mark the error in the

 *   netdev structure and arrange for the device to be reset to a sane state

 *   in order to transmit a new packet.

/**

 *  sxgbe_common_interrupt - main ISR

 *  @irq: interrupt number.

 *  @dev_id: to pass the net device pointer.

 *  Description: this is the main driver interrupt service routine.

 *  It calls the DMA ISR and also the core ISR to manage PMT, MMC, LPI

 *  interrupts.

 For LPI we need to save the tx status */

/**

 *  sxgbe_tx_interrupt - TX DMA ISR

 *  @irq: interrupt number.

 *  @dev_id: to pass the net device pointer.

 *  Description: this is the tx dma interrupt service routine.

 get the channel status */

 check for normal path */

 check for unrecoverable error */

 check for TC configuration change */

 step of TX TC is 32 till 128, otherwise 64 */

/**

 *  sxgbe_rx_interrupt - RX DMA ISR

 *  @irq: interrupt number.

 *  @dev_id: to pass the net device pointer.

 *  Description: this is the rx dma interrupt service routine.

 get the channel status */

 check for TC configuration change */

 step of TC is 32 */

/*  sxgbe_get_stats64 - entry point to see statistical information of device

 *  @dev : device pointer.

 *  @stats : pointer to hold all the statistical information of device.

 *  Description:

 *  This function is a driver entry point whenever ifconfig command gets

 *  executed to see device statistics. Statistics are number of

 *  bytes sent or received, errors occurred etc.

	/* Freeze the counter registers before reading value otherwise it may

	 * get updated by hardware while we are reading them

/*  sxgbe_set_features - entry point to set offload features of the device.

 *  @dev : device pointer.

 *  @features : features which are required to be set.

 *  Description:

 *  This function is a driver entry point and called by Linux kernel whenever

 *  any device features are set or reset by user.

 *  Return value:

 *  This function returns 0 after setting or resetting device features.

/*  sxgbe_change_mtu - entry point to change MTU size for the device.

 *  @dev : device pointer.

 *  @new_mtu : the new MTU size for the device.

 *  Description: the Maximum Transfer Unit (MTU) is used by the network layer

 *  to drive packet transmission. Ethernet has an MTU of 1500 octets

 *  (ETH_DATA_LEN). This value can be changed with ifconfig.

 *  Return value:

 *  0 on success and an appropriate (-)ve integer as defined in errno.h

 *  file on failure.

	/* Recevice ring buffer size is needed to be set based on MTU. If MTU is

	 * changed then reinitilisation of the receive ring buffers need to be

	 * done. Hence bring interface down and bring interface back up

	/* For MAC Addr registers se have to set the Address Enable (AE)

	 * bit that has no effect on the High Reg 0 where the bit 31 (MO)

	 * is RO.

/**

 * sxgbe_set_rx_mode - entry point for setting different receive mode of

 * a device. unicast, multicast addressing

 * @dev : pointer to the device structure

 * Description:

 * This function is a driver entry point which gets called by the kernel

 * whenever different receive mode like unicast, multicast and promiscuous

 * must be enabled/disabled.

 * Return value:

 * void.

 pass all multi */

 Hash filter for multicast */

			/* The upper 6 bits of the calculated CRC are used to

			 * index the contens of the hash table

			/* The most significant bit determines the register to

			 * use (H/L) while the other 5 bits determine the bit

			 * within the register.

 Handle multiple unicast addresses (perfect filtering) */

		/* Switch to promiscuous mode if more than 16 addrs

		 * are required

 Enable Receive all mode (to debug filtering_fail errors) */

/**

 * sxgbe_poll_controller - entry point for polling receive by device

 * @dev : pointer to the device structure

 * Description:

 * This function is used by NETCONSOLE and other diagnostic tools

 * to allow network I/O with interrupts disabled.

 * Return value:

 * Void.

/*  sxgbe_ioctl - Entry point for the Ioctl

 *  @dev: Device pointer.

 *  @rq: An IOCTL specefic structure, that can contain a pointer to

 *  a proprietary structure used to pass information to the driver.

 *  @cmd: IOCTL command

 *  Description:

 *  Currently it supports the phy_mii_ioctl(...) and HW time stamping.

 Get the hardware ops */

 set the MDIO communication Address/Data regisers */

	/* Assigning the default link settings

	 * no SXGBE defined default values to be set in registers,

	 * so assigning as 0 for port and duplex

/**

 *  sxgbe_hw_init - Init the GMAC device

 *  @priv: driver private structure

 *  Description: this function checks the HW capability

 *  (if supported) and sets the driver's features.

 get the hardware ops */

 get the controller id */

 get the H/W features */

/**

 * sxgbe_drv_probe

 * @device: device pointer

 * @plat_dat: platform data pointer

 * @addr: iobase memory address

 * Description: this is the main probe function used to

 * call the alloc_etherdev, allocate the priv structure.

 Verify driver arguments */

 Init MAC and get the capabilities */

 allocate memory resources for Descriptor rings */

 assign filtering support */

 MTU range: 68 - 9000 */

 Enable TCP segmentation offload for all DMA channels */

 Enable Rx checksum offload */

 Initialise pause frame settings */

 Rx Watchdog is available, enable depend on platform data */

	/* If a specific clk_csr value is passed from the platform

	 * this means that the CSR Clock Range selection cannot be

	 * changed at run-time and it is fixed. Viceversa the driver'll try to

	 * set the MDC clock dynamically according to the csr actual

	 * clock input.

 MDIO bus Registration */

/**

 * sxgbe_drv_remove

 * @ndev: net device pointer

 * Description: this function resets the TX/RX processes, disables the MAC RX/TX

 * changes the link status, releases the DMA descriptor rings.

 CONFIG_PM */

 Driver is configured as Platform driver */

 MODULE */

 SPDX-License-Identifier: GPL-2.0-only

/* 10G controller driver for Samsung SoCs

 *

 * Copyright (C) 2013 Samsung Electronics Co., Ltd.

 *		http://www.samsung.com

 *

 * Author: Siva Reddy Kallam <siva.kallam@samsung.com>

 DMA core initialization */

	/* if fix_burst = 0, Set UNDEF = 1 of DMA_Sys_Mode Register.

	 * if fix_burst = 1, Set UNDEF = 0 of DMA_Sys_Mode Register.

	 * burst_map is bitmap for  BLEN[4, 8, 16, 32, 64, 128 and 256].

	 * Set burst_map irrespective of fix_burst value.

 write burst len map */

 set the pbl */

 program the TX pbl */

 program the RX pbl */

 program desc registers */

 program tail pointers */

	/* assumption: upper 32 bits are constant and

	 * same as TX/RX desc list

 program the ring sizes */

 Enable TX/RX interrupts */

 Enable TX/RX interrupts */

 Disable TX/RX interrupts */

 TX Normal Interrupt Summary */

 TX Abnormal Interrupt Summary */

			/* Assumption: FBE bit is the combination of

			 * all the bus access erros and cleared when

			 * the respective error bits cleared

 check for actual cause */

 context descriptor error */

 clear the served bits */

 RX Normal Interrupt Summary */

 RX Abnormal Interrupt Summary */

			/* Assumption: FBE bit is the combination of

			 * all the bus access erros and cleared when

			 * the respective error bits cleared

 check for actual cause */

 clear the served bits */

 Program the HW RX Watchdog */

 SPDX-License-Identifier: GPL-2.0-only

/* 10G controller driver for Samsung SoCs

 *

 * Copyright (C) 2013 Samsung Electronics Co., Ltd.

 *		http://www.samsung.com

 *

 * Author: Siva Reddy Kallam <siva.kallam@samsung.com>

 DMA TX descriptor ring initialization */

 Assign buffer lengths for descriptor */

 Set VLAN control information */

 Set the owner of Normal descriptor */

 Get the owner of Normal descriptor */

 Invoked by the xmit function to close the tx descriptor */

 Clean the tx descriptor as soon as the tx irq is received */

/* Clear interrupt on tx frame completion. When this bit is

 * set an interrupt happens as soon as the frame is transmitted

 Last tx segment reports the transmit status */

 Get the buffer size from the descriptor */

 Set tx timestamp enable bit */

 get tx timestamp status */

 TX Context Descripto Specific */

 Set the owner of TX context descriptor */

 Get the owner of TX context descriptor */

 Set TX mss in TX context Descriptor */

 Get TX mss from TX context Descriptor */

 Set TX tcmssv in TX context Descriptor */

 Reset TX ostc in TX context Descriptor */

 Set IVLAN information */

 Return IVLAN Tag */

 Set VLAN Tag */

 Return VLAN Tag */

 Set Time stamp */

 Close TX context descriptor */

 WB status of context descriptor */

 DMA RX descriptor ring initialization */

 Get RX own bit */

 Set RX own bit */

 Set Interrupt on completion bit */

 Get the receive frame size */

 Return first Descriptor status */

 Return Last Descriptor status */

 Return the RX status looking at the WB fields */

 L3/L4 Pkt type */

 Filter */

 Get own bit of context descriptor */

 Set own bit for context descriptor */

 Return the reception status looking at Context control information */

 ptp */

 Get rx timestamp status */

 SPDX-License-Identifier: GPL-2.0-only

/* 10G controller driver for Samsung SoCs

 *

 * Copyright (C) 2013 Samsung Electronics Co., Ltd.

 *		http://www.samsung.com

 *

 * Author: Siva Reddy Kallam <siva.kallam@samsung.com>

 ETS Algorith */

 For Dynamic DMA channel mapping for Rx queue */

 0 means 256 bytes */

 0 means 256 bytes */

 TX specific MTL mode settings */

 set the TTC values */

 write into TXQ operation register */

 RX specific MTL mode settings */

 write into RXQ operation register */

/*************************************************************************

 * myri10ge.c: Myricom Myri-10G Ethernet driver.

 *

 * Copyright (C) 2005 - 2011 Myricom, Inc.

 * All rights reserved.

 *

 * Redistribution and use in source and binary forms, with or without

 * modification, are permitted provided that the following conditions

 * are met:

 * 1. Redistributions of source code must retain the above copyright

 *    notice, this list of conditions and the following disclaimer.

 * 2. Redistributions in binary form must reproduce the above copyright

 *    notice, this list of conditions and the following disclaimer in the

 *    documentation and/or other materials provided with the distribution.

 * 3. Neither the name of Myricom, Inc. nor the names of its contributors

 *    may be used to endorse or promote products derived from this software

 *    without specific prior written permission.

 *

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"

 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE

 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE

 * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE

 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR

 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF

 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS

 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN

 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)

 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE

 * POSSIBILITY OF SUCH DAMAGE.

 *

 *

 * If the eeprom on your board is not recent enough, you will need to get a

 * newer firmware image at:

 *   http://www.myri.com/scs/download-Myri10GE.html

 *

 * Contact Information:

 *   <help@myri.com>

 *   Myricom, Inc., 325N Santa Anita Avenue, Arcadia, CA 91006

 lanai ptr for recv ring */

 host shadow of recv ring */

 number of rx slots -1 */

 lanai ptr for sendq */

 "go" doorbell ptr */

 "stop" doorbell ptr */

 host shadow of sendq */

 number of transmit slots -1  */

 transmit slots submitted     */

 packets started */

 transmit slots completed     */

 packets completed */

 transmit ring        */

 boundary transmits cannot cross */

 running?             */

 eeprom mac address */

 Careful: must be accessed under kernel_param_lock() */

 -1 == auto */

 enable msi by default */

 defaults above */

 ensure buf is aligned to 8 bytes */

	/* wait up to 15ms. Longest command is the DMA benchmark,

	 * which is capped at 5ms, but runs from a timeout handler

	 * that runs every 7.8ms. So a 15ms timeout leaves us with

	 * a 2.2ms margin

		/* if atomic is set, do not sleep,

		 * and try to get the completion quickly

 use msleep for most command */

/*

 * The eeprom strings on the lanaiX have the format

 * SN=x\0

 * MAC=x:x:x:x:x:x\0

 * PT:ddd mmm xx xx:xx:xx xx\0

 * PV:ddd mmm xx xx:xx:xx xx\0

/*

 * Enable or disable periodic RDMAs from the host to make certain

 * chipsets resend dropped PCIe messages

 clear confirmation addr */

	/* send a rdma command to the PCIe engine, and wait for the

	 * response in the confirmation address.  The firmware should

	 * write a -1 there to indicate it is alive and well

 confirm addr MSW */

 confirm addr LSW */

 confirm data */

 dummy addr MSW */

 dummy addr LSW */

 enable? */

 check firmware type */

 save firmware version for ethtool */

 check size */

 check id */

 corruption checking is good for parity recovery and buggy chipset */

 find running firmware header */

	/* copy header of running firmware from SRAM to host memory to

	/* check to see if adopted firmware has bug where adopting

	 * it will cause broadcasts to be filtered unless the NIC

 probe for IPv6 TSO support */

		/* Do not attempt to adopt firmware if there

 clear confirmation addr */

	/* send a reload command to the bootstrap MCP, and wait for the

	 *  response in the confirmation address.  The firmware should

	 * write a -1 there to indicate it is alive and well

 confirm addr MSW */

 confirm addr LSW */

 confirm data */

	/* FIX: All newest firmware should un-protect the bottom of

	 * the sram before handoff. However, the very first interfaces

	 * do not. Therefore the handoff copy must skip the first 8 bytes

 where the code starts */

 length of code */

 where to copy to */

 where to jump to */

	/* Run a small DMA test.

	 * The magic multipliers to the length tell the firmware

	 * to do DMA read, write, or read+write tests.  The

	 * results are returned in cmd.data0.  The upper 16

	 * bits or the return is the number of transfers completed.

	 * The lower 16 bits is the time in 0.5us ticks that the

	 * transfers took to complete.

	/* try to send a reset command to the card to see if it

	/*

	 * Use non-ndis mcp_slot (eg, 4 bytes total,

	 * no toeplitz hash value returned.  Older firmware will

	 * not understand this command, but will use the correct

	 * sized mcp_slot, so we ignore error returns

 Now exchange information about interrupts  */

	/*

	 * Even though we already know how many slices are supported

	 * via myri10ge_probe_slices() MXGEFW_CMD_GET_MAX_RSS_QUEUES

	 * has magic side effects, and must be called after a reset.

	 * It must be called prior to calling any RSS related cmds,

	 * including assigning an interrupt queue for anything but

	 * slice 0.  It must also be called *after*

	 * MXGEFW_CMD_SET_INTRQ_SIZE, since the intrq size is used by

	 * the firmware to compute offsets.

 ask the maximum number of slices it supports */

		/*

		 * MXGEFW_CMD_ENABLE_RSS_QUEUES must be called prior

		 * to setting up the interrupt queue DMA

		/* Firmware older than 1.4.32 only supports multiple

		 * RX queues, so if we get an error, first retry using a

 CONFIG_MYRI10GE_DCA */

 reset mcp/driver shared state back to 0 */

 CONFIG_MYRI10GE_DCA */

 try to refill entire ring */

 we can use part of previous page */

 we need a new page */

		/* note that this is the address of the start of the

 start next packet on a cacheline boundary */

 don't cross a 4KB boundary */

 copy 8 descriptors to the firmware at a time */

 unmap the recvd page if we're the only or last user of it */

/*

 * GRO does not support acceleration of tagged vlan frames, and

 * this NIC does not support vlan tag offload, so we must pop

 * the tag ourselves to be able to achieve GRO performance that

 * is comparable to LRO.

 fixup csum if needed */

 pop tag */

 Bytes to copy from page to skb linear memory */

 Fill skb_frag_t(s) with data from our receive */

 remove padding */

 Mark as free */

	/*

	 * Make a minimal effort to prevent the NIC from polling an

	 * idle tx queue.  If we can't get the lock we leave the queue

	 * active. In this case, either a thread was about to start

	 * using the queue anyway, or we lost a race and the NIC will

	 * waste some of its resources polling an inactive queue for a

	 * while.

 start the queue if we've stopped it */

 restock receive rings if needed */

 process as many rx events as NAPI will allow */

	/* an interrupt on a non-zero receive-only slice is implicitly

 make sure it is our IRQ, and that the DMA has finished */

	/* low bit indicates receives are present, so schedule

 Wait for IRQ line to go low, if using INTx */

 check for transmit completes and receives */

 Only slice 0 updates stats */

	/*

	 * parse the product code to deterimine the interface type

	 * (CX4, XFP, Quad Ribbon Fiber) by looking at the character

	 * after the 3rd dash in the driver's cached copy of the

	 * EEPROM's product code string.

 We've found either an XFP, quad ribbon fiber, or SFP+ */

 device-specific stats */

 force stats update */

 firmware stats are useful only in the first slice */

/*

 * Use a low-level command to change the LED behavior. Rather than

 * blinking (which is the normal case), when identify is used, the

 * yellow LED turns solid.

 find running firmware header */

 get ring sizes */

 allocate the host shadow rings */

 ensure req_list entries are aligned to 8 bytes */

 allocate the host info rings */

 Fill the receive rings */

 If not allocated, skip it */

 Mark as free */

 Firmware cannot support multicast without STATS_DMA_V2 */

 setup the indirection table */

 just enable an identity mapping */

	/* decide what small buffer size to use.  For good TCP rx

	 * performance, it is important to not receive 1514 byte

	 * frames into jumbo buffers, as it confuses the socket buffer

	 * accounting code, leading to drops and erratic performance.

 enough for a TCP header */

 enough for a vlan encapsulated ETH_DATA_LEN frame */

 Override the small buffer size? */

	/* Firmware needs the big buff size as a power of 2.  Lie and

	 * tell him the buffer is larger, because we only use 1

	 * buffer/pkt, and the mtu will prevent overruns.

 setup the per-slice data structures */

		/* only firmware which supports multiple TX queues

		 * supports setting up the tx stats on non-zero

 must happen prior to any irq */

 now give firmware buffers sizes, and MTU */

	/*

	 * Set Linux style TSO mode; this is needed only on newer

	 *  firmware versions.  Older versions default to Linux

	 *  style TSO

/* copy an array of struct mcp_kreq_ether_send's to the mcp.  Copy

/*

 * copy an array of struct mcp_kreq_ether_send's to the mcp.  Copy

 * at most 32 bytes at a time, so as to avoid involving the software

 * pio handler in the nic.   We re-write the first segment's flags

 * to mark them valid only after writing the entire chain.

 force write every 32 bytes */

		/* submit all but the first request, and ensure

 submit the first request */

 barrier before setting valid flag */

 re-write the last 32-bits with the valid flags */

 Free any DMA resources we've alloced and clear out the skb slot */

/*

 * Transmit a packet.  We need to split the packet so that a single

 * segment does not cross myri10ge->tx_boundary, so this makes segment

 * counting tricky.  So rather than try to count segments up front, we

 * just give up if there are too few segments to hold a reasonably

 * fragmented packet currently available.  If we run

 * out of segments while preparing a packet for DMA, we just linearize

 * it and try again.

 we are out of transmit resources */

 Setup checksum offloading, if needed */

		/* If the headers are excessively large, then we must

 TSO */

 this removes any CKSUM flag from before */

		/* negative cum_len signifies to the

		 * send loop that we are still in the

		 * header portion of the TSO packet.

		/* for IPv6 TSO, the checksum offset stores the

		 * TCP header length, to save the firmware from

 Can only handle headers <= max_tso6 long */

		/* for TSO, pseudo_hdr_offset holds mss.

		 * The firmware figures out where to put

 Mark small packets, and pad out tiny packets */

 pad frames to at least ETH_ZLEN bytes */

			/* The packet is gone, so we must

 map the skb for DMA */

	/* "rdma_count" is the number of RDMAs belonging to the

	 * current packet BEFORE the current send request. For

	 * non-TSO packets, this is equal to "count".

	 * For TSO packets, rdma_count needs to be reset

	 * to 0 after a segment cut.

	 *

	 * The rdma_count field of the send request is

	 * the number of RDMAs of the packet starting at

	 * that request. For TSO send requests with one ore more cuts

	 * in the middle, this is the number of RDMAs starting

	 * after the last cut in the request. All previous

	 * segments before the last cut implicitly have 1 RDMA.

	 *

	 * Since the number of RDMAs is not known beforehand,

	 * it must be filled-in retroactively - after each

	 * segmentation cut or at the end of the entire packet.

		/* Break the SKB or Fragment up into pieces which

 TSO */

 payload */

 header ends */

 complete solid 16-byte block; does this matter? */

 map next fragment for DMA */

	/* if using multiple tx queues, make sure NIC polls the

	/* can be called from atomic contexts,

 This firmware is known to not support multicast */

 Disable multicast filtering */

 request to disable multicast filtering, so quit here */

 Flush the filters */

 Walk the multicast list, and add each address */

 Enable multicast filtering */

 change the dev structure */

		/* if we change the mtu on an active device, we must

/*

 * Enable ECRC to align PCI-E Completion packets on an 8-byte boundary.

 * Only do it if the bridge is a root port since we don't want to disturb

 * any other device, except if forced with myri10ge_ecrc_enable > 1.

 check that the bridge is a root port */

			/* Walk the hierarchy up to the root port

/*

 * The Lanai Z8E PCI-E interface achieves higher Read-DMA throughput

 * when the PCI-E Completion packets are aligned on an 8-byte

 * boundary.  Some PCI-E chip sets always align Completion packets; on

 * the ones that do not, the alignment can be enforced by enabling

 * ECRC generation (if supported).

 *

 * When PCI-E Completion packets are not aligned, it is actually more

 * efficient to limit Read-DMA transactions to 2KB, rather than 4KB.

 *

 * If the driver can neither enable ECRC nor verify that it has

 * already been enabled, then it must use a firmware image which works

 * around unaligned completion packets (myri10ge_rss_ethp_z8e.dat), and it

 * should also ensure that it never gives the device a Read-DMA which is

 * larger than 2KB by setting the tx_boundary to 2KB.  If ECRC is

 * enabled, then the driver should use the aligned (myri10ge_rss_eth_z8e.dat)

 * firmware image, and set tx_boundary to 4KB.

	/*

	 * Verify the max read request size was set to 4KB

	 * before trying the test with 4KB.

	/*

	 * load the optimized firmware (which assumes aligned PCIe

	 * completions) in order to see if it works on this host.

	/*

	 * Enable ECRC if possible

	/*

	 * Run a DMA test which watches for unaligned completions and

	 * aborts on the first one seen.

 keep the aligned firmware */

 fall back to using the unaligned firmware */

		/* Check to see if Link is less than 8 or if the

		 * upstream bridge is known to provide aligned

		/* a sram parity error can cause a surprise link

		 * down; since we expect and can recover from sram

 give card time to respond */

enter read32 mode */

read REBOOT_STATUS (0xfffffff0) */

 nic seems like it might be stuck.. */

/*

 * This watchdog is used to check whether the board has suffered

 * from a parity error and needs to be recovered.

		/* Bus master DMA disabled?  Check to see

		 * if the card rebooted due to a parity error

		/*

		 * A rebooted nic will come back with config space as

		 * it was after power was applied to PCIe bus.

		 * Attempt to restore config space which was saved

		 * when the driver was loaded, or the last time the

		 * nic was resumed from power saving mode.

 save state again for accounting reasons */

		/* if we get back -1's from our slot, perhaps somebody

		 * powered off our card.  Don't try to reset it in

		/* Perhaps it is a software error. See if stuck slice

/*

 * We use our own timer routine rather than relying upon

 * netdev->tx_timeout because we have a very large hardware transmit

 * queue.  Due to the large queue, the netdev->tx_timeout function

 * cannot detect a NIC with a parity error in a timely fashion if the

 * NIC is lightly loaded.

	/* if we've sent or received no traffic, poll the NIC to

	 * ensure it is still there.  Otherwise, we risk not noticing

 rearm timer */

 Wait till napi structs are no longer used, and then free ss. */

/*

 * This function determines the number of slices supported.

 * The number slices is the minimum of the number of CPUS,

 * the number of MSI-X irqs supported, the number of slices

 * supported by the firmware

 try to load the slice aware rss firmware */

 don't free old_fw if we override it. */

 hit the board with a reset to ensure it is alive */

 tell it the size of the interrupt queues */

 ask the maximum number of slices it supports */

 Only allow multiple slices if MSI-X is usable */

	/* if the admin did not specify a limit to how many

	 * slices we should use, cap it automatically to the

	/* Now try to allocate as many MSI-X vectors as we have

	 * slices. We give up on MSI-X if we can only get a single

	/* Find the vendor-specific cap so we can check

 Set our max read request to 4KB */

 MTU range: 68 - 9000 */

 fake NETIF_F_HW_VLAN_CTAG_RX for good GRO performance */

	/* make sure we can get an irq, and that MSI can be

	/* Save configuration space to be restored if the

 Setup the watchdog timer */

/*

 * myri10ge_remove

 *

 * Does what is necessary to shutdown one Myrinet device. Called

 *   once for each Myrinet card by the kernel when a module is

 *   unloaded.

 avoid a memory leak */

 CONFIG_MYRI10GE_DCA */

 SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB

/*

 * Copyright 2015-2020 Amazon.com, Inc. or its affiliates. All rights reserved.

	/* Make sure we read the rest of the descriptor after the phase bit

	 * has been read

	/* Make sure everything was written into the bounce buffer before

	 * writing the bounce buffer to the device

 The line is completed. Copy it to dev */

 Switch phase bit in case of wrap around */

 bounce buffer was used, so write it and get a new one */

 Switch phase bit in case of wrap around */

 bits 0-9 of the mss */

 bits 10-13 of the mss */

 Extended meta desc */

	/* When disable meta caching is set, don't bother to save the meta and

	 * compare it to the stored version, just create the meta

 Cache the meta desc */

****************************************************************************/

****************************     API      **********************************/

****************************************************************************/

 num_bufs +1 for potential meta desc */

 If the caller doesn't want to send packets */

 Set first desc when we don't have meta descriptor */

 Bits 0-9 */

 Bits 10-15 */

 The first desc share the same desc as the header */

 set the last desc indicator */

 Update SQ head ptr */

 Get rx flags from the last pkt */

 SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB

/*

 * Copyright 2015-2020 Amazon.com, Inc. or its affiliates. All rights reserved.

 CONFIG_RFS_ACCEL */

 Time in jiffies before concluding the transmitter is hung. */

 Increase a stat by cnt while holding syncp seqlock on 32bit machines */

	/* Change the state of the device to trigger reset

	 * Check that we are not in the middle or a trigger already

 prepare the packet's descriptors to dma engine */

	/* In case there isn't enough space in the queue for the packet,

	 * we simply drop it. All other failure reasons of

	 * ena_com_prepare_tx() are fatal and therefore require a device reset.

/* This is the XDP napi callback. XDP queues use a separate napi callback

 * than Rx/Tx queues.

	/* If the device is about to reset or down, avoid unmask

	 * the interrupt and return 0 so NAPI won't reschedule

 Designate part of the packet for LLQ */

	/* trigger the dma engine. ena_ring_tx_doorbell()

	 * calls a memory barrier inside it.

 We assume that all rings have the same XDP program */

 Other CPU ids might try to send thorugh this queue */

 Ring doorbell to make device aware of the packets */

 Return number of packets sent */

 Find xmit queue */

 The XDP queues are shared between XDP_TX and XDP_REDIRECT */

/* Provides a way for both kernel and bpf-prog to know

 * more about the RX-queue a given XDP frame arrived on.

/* This is the main xdp callback, it's used by the kernel to set/unset the xdp

 * program as well as to query the current xdp program id.

 CONFIG_RFS_ACCEL */

 TX common ring state */

 TX specific ring state */

 Don't init RX queues for xdp queues */

 RX common ring state */

 RX specific ring state */

/* ena_setup_tx_resources - allocate I/O Tx resources (Descriptors)

 * @adapter: network interface device structure

 * @qid: queue index

 *

 * Return 0 on success, negative on failure

 Req id ring for TX out of order completions */

 Reset tx statistics */

/* ena_free_tx_resources - Free I/O Tx Resources per Queue

 * @adapter: network interface device structure

 * @qid: queue index

 *

 * Free all transmit software resources

 rewind the index freeing the rings as we go */

/* ena_free_all_io_tx_resources - Free I/O Tx Resources for All Queues

 * @adapter: board private structure

 *

 * Free all transmit software resources

/* ena_setup_rx_resources - allocate I/O Rx resources (Descriptors)

 * @adapter: network interface device structure

 * @qid: queue index

 *

 * Returns 0 on success, negative on failure

	/* alloc extra element so in rx path

	 * we can always prefetch rx_info + 1

 Req id ring for receiving RX pkts out of order */

 Reset rx statistics */

/* ena_free_rx_resources - Free I/O Rx Resources

 * @adapter: network interface device structure

 * @qid: queue index

 *

 * Free all receive software resources

/* ena_setup_all_rx_resources - allocate I/O Rx queues resources for all queues

 * @adapter: board private structure

 *

 * Return 0 on success, negative on failure

 rewind the index freeing the rings as we go */

/* ena_free_all_io_rx_resources - Free I/O Rx Resources for All Queues

 * @adapter: board private structure

 *

 * Free all receive software resources

	/* This would allocate the page on the same NUMA node the executing code

	 * is running on.

	/* To enable NIC-side port-mirroring, AKA SPAN port,

	 * we make the buffer readable from the nic as well

 restore page offset value in case it has been changed by device */

 if previous allocated page is not used */

 We handle DMA here */

 ena_com_write_sq_doorbell issues a wmb() */

/* ena_refill_all_rx_bufs - allocate all queues Rx buffers

 * @adapter: board private structure

 unmap remaining mapped pages */

/* ena_free_tx_bufs - Free Tx Buffers per Queue

 * @tx_ring: TX ring for which buffers be freed

 Trigger device reset */

 prefetch skb_end_pointer() to speedup skb_shinfo(skb) */

	/* need to make the rings circular update visible to

	 * ena_start_xmit() before checking for netif_queue_stopped().

 save virt address of first buffer */

 sync this buffer for CPU use */

 Populate skb's linear part */

/* ena_rx_checksum - indicate in skb if hw indicated a good cksum

 * @adapter: structure containing adapter specific data

 * @ena_rx_ctx: received packet context/metadata

 * @skb: skb currently being received and modified

 Rx csum disabled */

 For fragmented packets the checksum isn't valid */

 if IP and error */

 ipv4 checksum error */

 if TCP/UDP */

 TCP/UDP checksum error */

 Override hash type if the packet is fragmented */

	/* If for some reason we received a bigger packet than

	 * we expect, then we simply drop it

 The xdp program might expand the headers */

/* ena_clean_rx_irq - Cleanup RX irq

 * @rx_ring: RX ring to clean

 * @napi: napi handler

 * @budget: how many packets driver is allowed to clean

 *

 * Returns the number of cleaned buffers.

 First descriptor might have an offset set by the device */

 allocate skb and fill it */

				/* Packets was passed for transmission, unmap it

				 * from RX side.

 Optimization, try to batch new rx buffers */

	/* Rx ring can be NULL when for XDP tx queues which don't have an

	 * accompanying rx_ring pair.

	/* Update intr register: rx intr delay,

	 * tx intr delay and interrupt unmask

	/* It is a shared MSI-X.

	 * Tx and Rx CQ have pointer to it.

	 * So we use one of them to reach the intr reg

	 * The Tx ring is used because the rx_ring is NULL for XDP queues

 Check only one ring since the 2 rings are running on the same cpu */

	/* On netpoll the budget is zero and the handler should only clean the

	 * tx completions.

	/* If the device is about to reset or down, avoid unmask

	 * the interrupt and return 0 so NAPI won't reschedule

		/* Update numa and unmask the interrupt only when schedule

		 * from the interrupt context (vs from sk_busy_loop)

 make sure interrupts_masked is read */

			/* We apply adaptive moderation on Rx path only.

			 * Tx uses static interrupt moderation.

 Don't call the aenq handler before probe is done */

/* ena_intr_msix_io - MSI-X Interrupt Handler for Tx/Rx

 * @irq: interrupt number

 * @data: pointer to a network interface private napi device structure

 Used to check HW health */

 write interrupts_masked before calling napi */

/* Reserve a single MSI-X vector for management (admin + aenq).

 * plus reserve one vector for each potential io queue.

 * the number of potential io queues is the minimum of what the device

 * supports and the number of vCPUs.

 Reserved the max msix vectors we might need */

 CONFIG_RFS_ACCEL */

 Configure the Rx forwarding */

 In case the RSS table wasn't initialized by probe */

 Set indirect table */

 Configure hash function (if supported) */

 Configure hash inputs (if supported) */

 enable transmits */

/* This function allows queue allocation to backoff when the system is

 * low on memory. If there is not enough memory to allocate io queues

 * the driver will try to allocate smaller queues.

 *

 * The backoff algorithm is as follows:

 *  1. Try to allocate TX and RX and if successful.

 *  1.1. return success

 *

 *  2. Divide by 2 the size of the larger of RX and TX queues (or both if their size is the same).

 *

 *  3. If TX or RX is smaller than 256

 *  3.1. return failure.

 *  4. else

 *  4.1. go back to 1.

	/* current queue sizes might be set to smaller than the requested

	 * ones due to past queue allocation failures.

		/* Decrease the size of the larger queue, or

		 * decrease both if they are the same size.

	/* napi poll functions should be initialized before running

	 * request_irq(), to handle a rare condition where there is a pending

	 * interrupt, causing the ISR to fire immediately while the poll

	 * function wasn't set yet, causing a null dereference

 Enable completion queues interrupt */

	/* schedule napi in case we had pending packets

	 * from the last time we disable napi

 After this point the napi handler won't enable the tx queue */

 After destroy the queue there won't be any new interrupts */

 stop submitting admin commands on a device that was reset */

/* ena_open - Called when a network interface is made active

 * @netdev: network interface device structure

 *

 * Returns 0 on success, negative value on failure

 *

 * The open entry point is called when a network interface is made

 * active by the system (IFF_UP).  At this point all resources needed

 * for transmit and receive operations are allocated, the interrupt

 * handler is registered with the OS, the watchdog timer is started,

 * and the stack is notified that the interface is ready.

 Notify the stack of the actual queue counts. */

/* ena_close - Disables a network interface

 * @netdev: network interface device structure

 *

 * Returns 0, this is not allowed to fail

 *

 * The close entry point is called when an interface is de-activated

 * by the OS.  The hardware is still under the drivers control, but

 * needs to be disabled.  A global MAC reset is issued to stop the

 * hardware, and all transmit and receive resources are freed.

 Check for device status and issue reset if needed*/

 rtnl lock already obtained in dev_ioctl() layer */

	/* We need to destroy the rss table so that the indirection

	 * table will be reinitialized by ena_up()

		/* When the device is LLQ mode, the driver will copy

		 * the header into the device memory space.

		 * the ena_com layer assume the header is in a linear

		 * memory space.

		 * This assumption might be wrong since part of the header

		 * can be in the fragmented buffers.

		 * Use skb_header_pointer to make sure the header is in a

		 * linear memory space.

 Called with netif_tx_lock. */

  Determine which tx ring we will be placed on */

 set flags and meta data */

	/* stop the queue when no more space available, the packet can have up

	 * to sgl_size + 2. one for the meta descriptor and one for header

	 * (if the header is larger than tx_max_header_size).

		/* There is a rare condition where this function decide to

		 * stop the queue but meanwhile clean_tx_irq updates

		 * next_to_completion and terminates.

		 * The queue will remain stopped forever.

		 * To solve this issue add a mb() to make sure that

		 * netif_tx_stop_queue() write is vissible before checking if

		 * there is additional space in the queue.

		/* trigger the dma engine. ena_ring_tx_doorbell()

		 * calls a memory barrier inside it.

	/* we suspect that this is good for in--kernel network services that

	 * want to loop incoming skb rx to tx in normal user generated traffic,

	 * most probably we will not get to this

 Allocate only the host info */

 allocate 32 bytes for each string and 64bit for the value */

	/* The PCIe configuration space revision id indicate if mmio reg

	 * read is disabled

 ENA admin level init */

	/* To enable the msix interrupts the driver needs to know the number

	 * of queues. So the driver uses polling mode to retrieve this

	 * information

 Get Device Attributes*/

 Try to turn all the available aenq groups */

	/* Stop the device from sending AENQ events (in case reset flag is set

	 *  and device is up, ena_down() already reset the device.

 return reset reason to default value */

 If the interface was up before the reset bring it up */

 no pending Tx at this location */

			/* If after graceful period interrupt is still not

			 * received, we schedule a reset

 Make sure the driver doesn't turn the device in other process */

 trigger napi schedule after 2 consecutive detections */

/* For the rare case where the device runs out of Rx descriptors and the

 * napi handler failed to refill new Rx descriptors (due to a lack of memory

 * for example).

 * This case will lead to a deadlock:

 * The device won't send interrupts since all the new Rx packets will be dropped

 * The napi handler won't allocate new Rx descriptors so the device will be

 * able to send new packets.

 *

 * This scenario can happen when the kernel's vm.min_free_kbytes is too small.

 * It is recommended to have at least 512MB, with a minimum of 128MB for

 * constrained environment).

 *

 * When such a situation is detected - Reschedule napi

 Check for keep alive expiration */

 convert to usec */

 Reset the timer */

 In case of LLQ use the llq fields for the tx SQ/CQ */

 1 IRQ for mgmnt and 1 IRQs for each IO direction */

 Set offload features */

 Copy mac address */

 Set offload features */

/* ena_probe - Device Initialization Routine

 * @pdev: PCI device information struct

 * @ent: entry in ena_pci_tbl

 *

 * Returns 0 on success, negative on failure

 *

 * ena_probe initializes an adapter identified by a pci_dev structure.

 * The OS initialization, configuring of the adapter private structure,

 * and a hardware reset occur.

	/* Initial TX and RX interrupt delay. Assumes 1 usec granularity.

	 * Updated during device initialization with the real granularity

 stop submitting admin commands on a device that was reset */

****************************************************************************/

/* __ena_shutoff - Helper used in both PCI remove/shutdown routines

 * @pdev: PCI device information struct

 * @shutdown: Is it a shutdown operation? If false, means it is a removal

 *

 * __ena_shutoff is a helper routine that does the real work on shutdown and

 * removal paths; the difference between those paths is with regards to whether

 * dettach or unregister the netdevice.

 CONFIG_RFS_ACCEL */

	/* Make sure timer and reset routine won't be called after

	 * freeing device resources.

 lock released inside the below if-else block */

/* ena_remove - Device Removal Routine

 * @pdev: PCI device information struct

 *

 * ena_remove is called by the PCI subsystem to alert the driver

 * that it should release a PCI device.

/* ena_shutdown - Device Shutdown Routine

 * @pdev: PCI device information struct

 *

 * ena_shutdown is called by the PCI subsystem to alert the driver that

 * a shutdown/reboot (or kexec) is happening and device must be disabled.

/* ena_suspend - PM suspend callback

 * @dev_d: Device information struct

/* ena_resume - PM resume callback

 * @dev_d: Device information struct

/******************************************************************************

 ******************************** AENQ Handlers *******************************

/* ena_update_on_link_change:

 * Notify the network interface about the change in link status

	/* These stats are accumulated by the device, so the counters indicate

	 * all drops since last reset.

 This handler will called for unknown event group or unimplemented handlers*/

 SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB

/*

 * Copyright 2015-2020 Amazon.com, Inc. or its affiliates. All rights reserved.

****************************************************************************/

****************************************************************************/

 Timeout in micro-sec */

****************************************************************************/

****************************************************************************/

****************************************************************************/

 Abort - canceled by the driver */

 status from the device */

 In case of queue FULL */

 Allocate bounce buffers */

 Initiate the first bounce buffer */

 Use the basic completion descriptor for Rx */

 Go over all the completions */

		/* Do not read the rest of the completion entry before the

		 * phase bit was validated

 ENA didn't have any completion */

/*

 * Set the LLQ configurations of the firmware

 *

 * The driver provides only the enabled feature values to the device,

 * which in turn, checks if they are supported.

		/* The desc list entry size should be whole multiply of 8

		 * This requirement comes from __iowrite64_copy()

 Check for accelerated queue supported */

	/* In case the command wasn't completed find out the root cause.

	 * There might be 2 kinds of errors

	 * 1) No completion (timeout reached)

	 * 2) There is completion but the device didn't get any msi-x interrupt.

 Check if fallback to polling is enabled */

		/* Check if shifted to polling mode.

		 * This will happen if there is a completion without an interrupt

		 * and autopolling mode is enabled. Continuing normal execution in such case

/* This method read the hardware device register through posting writes

 * and waiting for response

 * On timeout the function will return ENA_MMIO_READ_TIMEOUT

 If readless is disabled, perform regular read */

/* There are two types to wait for completion.

 * Polling mode - wait until the completion is available.

 * Async mode - wait on wait queue until the completion is ready

 * (or the timeout expired).

 * It is expected that the IRQ called ena_com_handle_admin_completion

 * to mark the completions.

 Convert timeout from resolution of 100ms to us resolution. */

 Device attributes is always supported */

	/* The key buffer is stored in the device in an array of

	 * uint32 elements.

 update Rx */

 update Tx */

****************************************************************************/

******************************      API       ******************************/

****************************************************************************/

	/* Init head_db to mark that all entries in the queue

	 * are initially available

	/* Make sure the ENA version and the controller version are at least

	 * as the driver expects

 Validate the ctrl version without the implementation ID */

 Init CQ */

 header length is limited to 8 bits */

	/* Driver hints isn't mandatory admin command. So in case the

	 * command isn't supported set driver hints to 0

/* ena_handle_specific_aenq_event:

 * return the handler that is relevant to the specific event group

/* ena_aenq_intr_handler:

 * handles the aenq incoming events.

 * pop events from the queue and apply the specific handler

 Get first entry */

 Go over all the events */

		/* Make sure the phase bit (ownership) is as expected before

		 * reading the rest of the descriptor.

 Handle specific event*/

 call the actual event handler*/

 Get next event entry */

 Don't update aenq doorbell if there weren't any processed events */

 write the aenq doorbell after all AENQ descriptors were read */

 start reset */

 Write again the MMIO read request address */

 reset done */

 the resolution of timeout reg is 100ms */

 Validate hash function is supported */

 Make sure size is a mult of DWs */

 Restore the old function */

 ffs() returns 1 in case the lsb is set */

 Get the supported hash input */

 In case of failure, restore the old hash ctrl */

 Get the ctrl table */

 Make sure all the fields are supported */

 In case of failure, restore the old hash ctrl */

	/* The following function might return unsupported in case the

	 * device doesn't support setting the key / hash function. We can safely

	 * ignore this error and have indirection table support only.

	/* Host attribute config is called before ena_com_get_dev_attr_feat

	 * so ena_com can't check if the feature is supported.

 Interrupt moderation */

 no moderation supported, disable adaptive support */

 if moderation is supported by device we set adaptive moderation */

 Disable adaptive moderation by default - can be enabled later */

 SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB

/*

 * Copyright 2015-2020 Amazon.com, Inc. or its affiliates. All rights reserved.

 Tx stats */

 XDP TX queues don't have a RX queue counterpart */

 Rx stats */

 Tx stats */

			/* RX stats, in XDP there isn't a RX queue

			 * counterpart

	/* Our internal representation of the indices is: even indices

	 * for Tx and uneven indices for Rx. We need to convert the Rx

	 * indices to be consecutive

	/* We call this function in order to check if the device

	 * supports getting/setting the hash function.

 The check for max value is already done in ethtool */

 If there is a buffer, dump stats, otherwise print them to dmesg */

/* ======================================================================

 *

 * A PCMCIA ethernet driver for the 3com 3c589 card.

 *

 * Copyright (C) 1999 David A. Hinds -- dahinds@users.sourceforge.net

 *

 * 3c589_cs.c 1.162 2001/10/13 00:08:50

 *

 * The network driver code is based on Donald Becker's 3c589 code:

 *

 * Written 1994 by Donald Becker.

 * Copyright 1993 United States Government as represented by the

 * Director, National Security Agency.  This software may be used and

 * distributed according to the terms of the GNU General Public License,

 * incorporated herein by reference.

 * Donald Becker may be reached at becker@scyld.com

 *

 * Updated for 2.5.x by Alan Cox <alan@lxorguk.ukuu.org.uk>

 *

 * ======================================================================

/* To minimize the size of the driver source I only define operating

 * constants if they are used several times. You'll need the manual

 * if you want to understand driver details.

 Offsets from base I/O address. */

/* The top five bits written to EL3_CMD are a command, the lower

 * 11 bits are the parameter, if applicable.

 The SetRxFilter command accepts the following classes: */

 Register window 1 offsets, the window used in normal operation. */

 Remaining free bytes in Tx buffer. */

 Window 0: Set IRQ line in bits 12-15. */

 Window 4: Various transcvr/media bits. */

 Enable link beat and jabber for 10baseT. */

 Enable link light on 3C589E cards. */

 Time in jiffies before concluding Tx hung */

 For transceiver monitoring */

====================================================================*/

 Module parameters */

 Special hook for setting if_port when module is loaded */

====================================================================*/

 Create new ethernet device */

 tc589_detach */

 Is this a 3c562? */

 For the 3c562, the base address must be xx00-xx7f */

	/* The 3c589 has an extra EEPROM for configuration info, including

	 * the hardware address.  The 3c562 puts the address in the CIS.

 0 < len < 6 */

	/* The address and resource configuration register aren't loaded from

	 * the EEPROM and *must* be set to 0 and IRQ3 for the PCMCIA version.

 The if_port symbol can be set when the module is loaded */

 tc589_config */

====================================================================*/

 Use this for commands that may take time to finish */

/* Read a word from the EEPROM using the regular EEPROM access register.

 * Assume that we are in register window zero.

 Reading the eeprom takes 162 us */

/* Set transceiver type, perhaps to something other than what the user

 * specified in dev->if_port.

 On PCMCIA, this just turns on the LED */

 10baseT interface, enable link beat and jabber check. */

 Reset and restore all of the 3c589 registers. */

 Activate board. */

 Set the IRQ line. */

 Set the station address in window 2. */

 Switch to the stats window, and clear all stats by reading. */

 Switch to register set 1 for normal use. */

 Turn on statistics. */

 Enable the receiver. */

 Enable transmitter. */

 Allow status bits to be seen. */

 Ack all pending events, and set active indicator mask. */

 prevent tx timeout */

 Issue TX_RESET and TX_START commands. */

 Clear the Tx status stack. */

 reset transmitter on jabber error or underrun */

 Pop the status stack. */

 Put out the doubleword header... */

 ... and the packet rounded to a doubleword. */

 Interrupt us when the FIFO has room for max-sized packet. */

 The EL3 interrupt handler. */

 There's room in the FIFO for a full-sized packet. */

 Handle all uncommon interrupts. */

 Empty statistics. */

 Rx early is unused. */

 Tx overrun */

 Rx underrun */

 Clear all interrupts */

 Acknowledge the IRQ. */

	/* Check for pending interrupt with expired latency timer: with

	 * this, we can limp along even if the interrupt is blocked

	/* lp->lock guards the EL3 window. Window should always be 1 except

	 * when the lock is held

 Ignore collisions unless we've had no irq's recently */

 Try harder to detect carrier errors */

/* Update statistics.  We change to register window 6, so this should be run

* single-threaded if the device is active. This is expected to be a rare

* operation, and it's simpler for the rest of the driver to assume that

* window 1 is always valid rather than use a special window-state variable.

*

* Caller must hold the lock for this

 Turn off statistics updates while reading. */

 Switch to the stats window, and read everything. */

 Multiple collisions. */

 Rx packets   */

 Tx deferrals */

 Rx octets */

 Tx octets */

 Back to window 1, and turn statistics back on. */

 Error, update stats. */

 Pop the top of the Rx FIFO */

 Turn off statistics ASAP.  We update dev->stats below. */

 Disable the receiver and transmitter. */

 Turn off thinnet power.  Green! */

 Disable link beat and jabber */

 Switching back to window 0 disables the IRQ. */

 But we explicitly zero the IRQ line select anyway. */

 Check if the card still exists */

/*

	Written 1997-1998 by Donald Becker.



	This software may be used and distributed according to the terms

	of the GNU General Public License, incorporated herein by reference.



	This driver is for the 3Com ISA EtherLink XL "Corkscrew" 3c515 ethercard.



	The author may be reached as becker@scyld.com, or C/O

	Scyld Computing Corporation

	410 Severn Ave., Suite 210

	Annapolis MD 21403





	2000/2/2- Added support for kernel-level ISAPnP

		by Stephen Frost <sfrost@snowman.net> and Alessandro Zummo

	Cleaned up for 2.3.x/softnet by Jeff Garzik and Alan Cox.



	2001/11/17 - Added ethtool support (jgarzik)



	2002/10/28 - Locking updates for 2.5 (alan@lxorguk.ukuu.org.uk)



 "Knobs" that adjust features and parameters. */

/* Set the copy breakpoint for the copy-only-tiny-frames scheme.

 Allow setting MTU to a larger size, bypassing the normal ethernet setup. */

 Maximum events (Rx packets, etc.) to handle at each interrupt. */

 Enable the automatic media selection code -- usually set. */

/* Allow the use of fragment bus master transfers instead of only

   programmed-I/O for Vortex cards.  Full-bus-master transfers are always

   enabled by default on Boomerang cards.  If VORTEX_BUS_MASTER is defined,

 A few values that may be tweaked. */

 Keep the ring sizes a power of two for efficiency. */

 Size of each temporary Rx buffer. */

 "Knobs" for adjusting internal parameters. */

 Put out somewhat more debugging messages. (0 - no msg, 1 minimal msgs). */

/* Some values here only for performance evaluation and path-coverage

/* Number of times to check to see if the Tx FIFO has space, used in some

 Operational parameter that usually are not changed. */

 Time in jiffies before concluding Tx hung */

/* The size here is somewhat misleading: the Corkscrew also uses the ISA

   aliased registers at <base>+0x400.

/*

				Theory of Operation



I. Board Compatibility



This device driver is designed for the 3Com 3c515 ISA Fast EtherLink XL,

3Com's ISA bus adapter for Fast Ethernet.  Due to the unique I/O port layout,

it's not practical to integrate this driver with the other EtherLink drivers.



II. Board-specific settings



The Corkscrew has an EEPROM for configuration, but no special settings are

needed for Linux.



III. Driver operation



The 3c515 series use an interface that's very similar to the 3c900 "Boomerang"

PCI cards, with the bus master interface extensively modified to work with

the ISA bus.



The card is capable of full-bus-master transfers with separate

lists of transmit and receive descriptors, similar to the AMD LANCE/PCnet,

DEC Tulip and Intel Speedo3.



This driver uses a "RX_COPYBREAK" scheme rather than a fixed intermediate

receive buffer.  This scheme allocates full-sized skbuffs as receive

buffers.  The value RX_COPYBREAK is used as the copying breakpoint: it is

chosen to trade-off the memory wasted by passing the full-sized skbuff to

the queue layer for all frames vs. the copying cost of copying a frame to a

correctly-sized skbuff.





IIIC. Synchronization

The driver runs as two independent, single-threaded flows of control.  One

is the send-packet routine, which enforces single-threaded use by the netif

layer.  The other thread is the interrupt handler, which is single

threaded by the hardware and other software.



IV. Notes



Thanks to Terry Murphy of 3Com for providing documentation and a development

board.



The names "Vortex", "Boomerang" and "Corkscrew" are the internal 3Com

project names.  I use these names to eliminate confusion -- 3Com product

numbers and names are very similar and often confused.



The new chips support both ethernet (1.5K) and FDDI (4.5K) frame sizes!

This driver only supports ethernet frames because of the recent MTU limit

of 1.5K, but the changes to support 4.5K are minimal.

/* Operational definitions.

   These are not used by other compilation units and thus are not

   exported in a ".h" file.



   First the windows.  There are eight register windows, with the command

   and status registers available in each.

/* The top five bits written to EL3_CMD are a command, the lower

   11 bits are the parameter, if applicable.

   Note that 11 parameters bits was fine for ethernet, but the new chips

   can handle FDDI length frames (~4500 octets) and now parameters count

 The SetRxFilter command accepts the following classes: */

 Bits in the general status register. */

 DMA controller is still busy. */

 EL3_CMD is still busy. */

/* Register window 1 offsets, the window used in normal operation.

 Remaining free bytes in Tx buffer. */

 Corkscrew EEPROM command register. */

 Corkscrew EEPROM results register. */

 Window 0: EEPROM command register. */

 Window 0: EEPROM results register. */

 Enable erasing/writing for 10 msec. */

 Disable EWENB before 10 msec timeout. */

 EEPROM locations. */

 Window 3: MAC/config bits. */

 Window 4: Xcvr/media bits. */

 Enable SQE error counting for AUI. */

 Enable link beat and jabber for 10baseT. */

 Enable just link beat for 100TX/100FX. */

 Window 7: Bus Master control. */

 Boomerang-style bus master control registers.  Note ISA aliases! */

/* The Rx and Tx descriptor lists.

   Caution Alpha hackers: these types are 32 bits!  Note also the 8 byte

 Values for the Rx status entry. */

 See boomerang_rx() for actual error bits */

 The Rx and Tx rings are here to keep them quad-word-aligned. */

 The addresses of transmit- and receive-in-place skbuffs. */

 The next free ring entry */

 The ring entries to be free()ed. */

 Packet being eaten by bus master ctrl.  */

 Media selection timer. */

 Adapter capabilities word. */

 User-settable misc. driver options. */

 For media autoselection. */

 From Wn3_Options */

 Passed-in media type. */

 Read from the EEPROM. */

 Vortex can only do a fragment bus-m. */

 Boomerang  */

/* The action to take with a media selection timer tick.

   Note that we deviate from the 3Com order by checking 10base2 before AUI.

 Bits to set in Wn4_Media register. */

 The transceiver-present bit in Wn3_Config. */

 The media type to try next. */

 Time before we check media status. */

 terminate list */

 __ISAPNP__ */

/*

   Unfortunately maximizing the shared code between the integrated and

   module version of the driver results in a complicated set of initialization

   procedures.

   init_module() -- modules /  tc59x_init()  -- built-in

		The wrappers for corkscrew_scan()

   corkscrew_scan()  		 The common routine that scans for PCI and EISA cards

   corkscrew_found_device() Allocate a device structure when we find a card.

					Different versions exist for modules and built-in.

   corkscrew_probe1()		Fill in the device structure -- this is separated

					so that the modules code can put it in dev->init.

 This driver uses 'options' to pass the media type, full-duplex flag, etc. */

 Note: this is the only limit on the number of cards supported!! */

 A list of all installed Vortex devices, for removing the driver module. */

 we will need locking (and refcounting) if we ever use it for more */

 not MODULE */

 Check the resource configuration for a matching ioaddr. */

 Verify by reading the device ID from the EEPROM. */

 Pause for at least 162 us. for the read to take place. */

 irq = inw(ioaddr + 0x2002) & 15; */ 
 __ISAPNP__ */

 Check all locations on the ISA bus -- evil! */

 EEPROM contents */

 Read the station address from the EEPROM. */

 Pause for at least 162 us. for the read to take place. */

 Corkscrew */

 Tell them about an invalid IRQ. */

 Rx is broken at 10mbps, so we always disable it. */

 vp->full_bus_master_rx = 0; */

 The 3c51x-specific entries in the device structure. */

 Before initializing select the active media port. */

 Set the full-duplex bit. */

 Find first available media type, starting with 100baseTx. */

 Wait a few ticks for the RxReset command to complete. */

 Use the now-standard shared IRQ implementation. */

 Corkscrew: Cannot share ISA resources. */

 Set the station address and mask in window 2 each time opened. */

 Start the thinnet transceiver. We should really wait 50ms... */

 Switch to the stats window, and clear all stats by reading. */

 New: On the Vortex we must also clear the BadSSD counter. */

 ..and on the Boomerang we enable the extra statistics bits. */

 Switch to register set 7 for normal use. */

 Boomerang bus master. */

 Clear complete bit. */

 Bad news!  */

 Align IP on 16 byte boundaries */

 Wrap the ring. */

 Boomerang bus master Tx. */

 Room for a packet. */

 Clear the Tx ring. */

 Set receiver mode: presumably accept b-case and phys addr only. */

 Turn on statistics. */

 Enable the receiver. */

 Enable transmitter. */

 Allow status bits to be seen. */

 Ack all pending events, and set active indicator mask. */

 10baseT, 100baseTX, 100baseFX  */

 Other media types handled by Tx timeouts. */

 Go back to default. */

 AUTOMEDIA */

 Slight code bloat to be user friendly. */

 Issue TX_RESET and TX_START commands. */

 prevent tx timeout */

 Block a timer-based transmit from overlapping. */

 BOOMERANG bus-master */

 Calculate the next Tx descriptor entry. */

 No room to transmit with */

 vp->tx_full = 1; */

 Wait for the stall to complete. */

 Clear previous interrupt enable. */

 Put out the doubleword header... */

 Set the bus-master controller to transfer the packet. */

 queue will be woken at the DMADone interrupt. */

 ... and the packet rounded to a doubleword. */

 Interrupt us when the FIFO has room for max-sized packet. */

 ... and the packet rounded to a doubleword. */

 Interrupt us when the FIFO has room for max-sized packet. */

 bus master */

 Clear the Tx status stack. */

 A Tx-disabling error occurred.  */

 Pop the status stack. */

/* The interrupt handler does all of the Rx thread work and cleans up

 Use the now-standard shared IRQ implementation. */

		/* Some interrupt controllers store a bogus interrupt from boot-time.

		   Ignore a single early interrupt, but don't hang the machine for

 There's room in the FIFO for a full-sized packet. */

 It still hasn't been processed. */

 Ack the event. */

 Release the transferred buffer */

 Handle all uncommon interrupts at once. */

 Rx early is unused. */

 Empty statistics. */

 DEBUG HACK: Disable statistics as an interrupt source. */

 This occurs when we have the wrong media type! */

 Adapter failure requires Rx reset and reinit. */

 Set the Rx filter to the current state. */

 Re-enable the receiver. */

 Disable all pending interrupts. */

 Acknowledge the IRQ. */

 Error, update stats. */

 The packet length: up to 4.5K!. */

 Align IP on 16 byte boundaries */

 'skb_put()' points to the start of sk_buff data area. */

 Pop top Rx packet. */

 Wait a limited time to go to next packet. */

 Wait a limited time to skip this packet. */

 Error, update stats. */

 The packet length: up to 4.5K!. */

			/* Check if the packet is long enough to just accept without

 Align IP on 16 byte boundaries */

 'skb_put()' points to the start of sk_buff data area. */

 Pass up the skbuff already on the Rx ring. */

 Remove this checking code for final release. */

 Refill the Rx ring buffers. */

 Bad news!  */

 Align IP on 16 byte boundaries */

 Clear complete bit. */

 Turn off statistics ASAP.  We update lp->stats below. */

 Disable the receiver and transmitter. */

 Turn off thinnet power.  Green! */

 Free Boomerang bus master Rx buffers. */

 Free Boomerang bus master Tx buffers. */

/*  Update statistics.

	Unlike with the EL3 we need not worry about interrupts changing

	the window setting from underneath us, but we must still guard

	against a race condition with a StatsUpdate interrupt updating the

	table.  This is done by checking that the ASM (!) code generated uses

	atomic updates with '+='.

 Unlike the 3c5x9 we need not turn off stats updates while reading. */

 Switch to the stats window, and read everything. */

 Multiple collisions. */ inb(ioaddr + 2);

 Rx packets   */ inb(ioaddr + 7);

 Must read to clear */

 Tx deferrals */ inb(ioaddr + 8);

	/* Don't bother with register 9, an extension of registers 6&7.

	   If we do use the 6&7 values the atomic update assumption above

 Total Rx and Tx octets. */

 New: On the Vortex we must also clear the BadSSD counter. */

 We change back to window 7 (not 1) with the Vortex. */

/* This new version of set_rx_mode() supports v1.4 kernels.

   The Vortex chip has no documented multicast filter, so the only

   multicast setting is to receive all multicast frames.  At least

 MODULE */

/* 3c574.c: A PCMCIA ethernet driver for the 3com 3c574 "RoadRunner".



	Written 1993-1998 by

	Donald Becker, becker@scyld.com, (driver core) and

	David Hinds, dahinds@users.sourceforge.net (from his PC card code).

	Locking fixes (C) Copyright 2003 Red Hat Inc



	This software may be used and distributed according to the terms of

	the GNU General Public License, incorporated herein by reference.



	This driver derives from Donald Becker's 3c509 core, which has the

	following copyright:

	Copyright 1993 United States Government as represented by the

	Director, National Security Agency.

	



/*

				Theory of Operation



I. Board Compatibility



This device driver is designed for the 3Com 3c574 PC card Fast Ethernet

Adapter.



II. Board-specific settings



None -- PC cards are autoconfigured.



III. Driver operation



The 3c574 uses a Boomerang-style interface, without the bus-master capability.

See the Boomerang driver and documentation for most details.



IV. Notes and chip documentation.



Two added registers are used to enhance PIO performance, RunnerRdCtrl and

RunnerWrCtrl.  These are 11 bit down-counters that are preloaded with the

count of word (16 bits) reads or writes the driver is about to do to the Rx

or Tx FIFO.  The chip is then able to hide the internal-PCI-bus to PC-card

translation latency by buffering the I/O operations with an 8 word FIFO.

Note: No other chip accesses are permitted when this buffer is used.



A second enhancement is that both attribute and common memory space

0x0800-0x0fff can translated to the PIO FIFO.  Thus memory operations (faster

with *some* PCcard bridges) may be used instead of I/O operations.

This is enabled by setting the 0x10 bit in the PCMCIA LAN COR.



Some slow PC card bridges work better if they never see a WAIT signal.

This is configured by setting the 0x20 bit in the PCMCIA LAN COR.

Only do this after testing that it is reliable and improves performance.



The upper five bits of RunnerRdCtrl are used to window into PCcard

configuration space registers.  Window 0 is the regular Boomerang/Odie

register set, 1-5 are various PC card control registers, and 16-31 are

the (reversed!) CIS table.



A final note: writing the InternalConfig register in window 3 with an

invalid ramWidth is Very Bad.



V. References



http://www.scyld.com/expert/NWay.html

http://www.national.com/opf/DP/DP83840A.html



Thanks to Terry Murphy of 3Com for providing development information for

earlier 3Com products.



====================================================================*/

 Module parameters */

 Maximum events (Rx packets, etc.) to handle at each interrupt. */

 Force full duplex modes? */

 Autodetect link polarity reversal? */

====================================================================*/

 Time in jiffies before concluding the transmitter is hung. */

/* To minimize the size of the driver source and make the driver more

   readable not all constants are symbolically defined.

 Offsets from base I/O address. */

/* The top five bits written to EL3_CMD are a command, the lower

 The SetRxFilter command accepts the following classes: */

 EEPROM command/address, data. */

 Valid in all windows. */

 These assumes the larger EEPROM. */

 Enable erasing/writing for 10 msec. */

 Disable EWENB before 10 msec timeout. */

/* Register window 1 offsets, the window used in normal operation.

   On the "Odie" this window is always mapped at offsets 0x10-0x1f.

 Remaining free bytes in Tx buffer. */

 Window 3: MAC/config bits. */

 Window 4: Xcvr/media bits. */

 Enable link beat and jabber for 10baseT. */

 NWay media advertisement */

 MII device address */

 Read from the EEPROM/Wn3_Config. */

 for transceiver monitoring */

 Guards the Window selection */

/* Set iff a MII transceiver on any interface requires mdio preamble.

   This only set with the original DP83840 on older 3c905 boards, so the extra

 Index of functions. */

/*

	tc574_attach() creates an "instance" of the driver, allocating

	local data structures for one device.  The device is registered

	with Card Services.

 Create the PC card device object. */

 tc574_detach */

	/* The 3c574 normally uses an EEPROM for configuration info, including

	   the hardware address.  The future products may include a modem chip

 0 < len < 6 */

 Roadrunner only: Turn on the MII transceiver */

 Only advertise the FD media types. */

 tc574_config */

/*

  Use this for commands that may take time to finish

/* Read a word from the EEPROM using the regular EEPROM access register.

   Assume that we are in register window zero.

 Pause for at least 162 usec for the read to take place. */

/* MII transceiver control section.

   Read and write the MII registers using software-generated serial

   MDIO protocol.  See the MII specifications or DP83840A data sheet

   for details.

   The maxium data clock rate is 2.5 Mhz.  The timing is easily met by the

/* Generate the preamble required for initial synchronization and

 Establish sync by sending at least 32 logic ones. */

 Shift the read command bits out. */

 Read the two transition, 16 data, and wire-idle bits. */

 Shift the command bits out. */

 Leave the interface idle. */

 Reset and restore all of the 3c574 registers. */

 Clear any transactions in progress. */

 Set the station address and mask. */

 Reset config options */

 Roadrunner only: Turn on the MII transceiver. */

 Switch to the stats window, and clear all stats by reading. */

 .. enable any extra statistics bits.. */

 .. re-sync MII and re-fill what NWay is advertising. */

 works for TDK 78Q2120 series MII's */

 Switch to register set 1 for normal use, just for TxFree. */

 Turn on statistics. */

 Enable the receiver. */

 Enable transmitter. */

 Allow status bits to be seen. */

 Ack all pending events, and set active indicator mask. */

 prevent tx timeout */

 Issue TX_RESET and TX_START commands. */

 Clear the Tx status stack. */

 reset transmitter on jabber error or underrun */

 Pop the status stack. */

 Put out the doubleword header... */

 ... and the packet rounded to a doubleword. */

 TxFree appears only in Window 1, not offset 0x1c. */

		/* Interrupt us when the FIFO has room for max-sized packet. 

 The EL3 interrupt handler. */

 There's room in the FIFO for a full-sized packet. */

 Handle all uncommon interrupts. */

 Tx overrun */

 Rx underrun */

 Clear all interrupts */

 Acknowledge the IRQ. */

/*

    This timer serves two purposes: to check for missed interrupts

	(and as a last resort, poll the NIC for events), and to monitor

	the MII, reporting changes in cable status.

 cable, */ media, partner;

	/* Check for pending interrupt with expired latency timer: with

/*  Update statistics.

	Surprisingly this need not be run single-threaded, but it effectively is.

	The counters clear when read, so the adds must merely be atomic.

 No card. */

 Unlike the 3c509 we need not turn off stats updates while reading. */

 Switch to the stats window, and read everything. */

 Multiple collisions. */	   	inb(ioaddr + 2);

 Rx packets   */			   inb(ioaddr + 7);

 Tx deferrals */			   inb(ioaddr + 8);

 rx */				   inw(ioaddr + 10);

 tx */				   inw(ioaddr + 12);

 BadSSD */				   inb(ioaddr + 12);

 Error, update stats. */

 Provide ioctl() calls to examine the MII xcvr state. */

 Get the address of the PHY in use. */

 Read the specified MII register. */

 Write the specified MII register */

/* The Odie chip has a 64 bin multicast filter, but the bit layout is not

   documented.  Until it is we revert to receiving all multicast frames when

   any multicast reception is desired.

   Note: My other drivers emit a log message whenever promiscuous mode is

   entered to help detect password sniffers.  This is less desirable on

   typical PC card machines, so we omit the message.

 Turn off statistics ASAP.  We update lp->stats below. */

 Disable the receiver and transmitter. */

 Note: Switching to window 0 may disable the IRQ. */

 force interrupts off */

 typhoon.c: A Linux Ethernet device driver for 3Com 3CR990 family of NICs */

/*

	Written 2002-2004 by David Dillow <dave@thedillows.org>

	Based on code written 1998-2000 by Donald Becker <becker@scyld.com> and

	Linux 2.2.x driver by David P. McLean <davidpmclean@yahoo.com>.



	This software may be used and distributed according to the terms of

	the GNU General Public License (GPL), incorporated herein by reference.

	Drivers based on or derived from this code fall under the GPL and must

	retain the authorship, copyright and license notice.  This file is not

	a complete program and may only be used when the entire operating

	system is licensed under the GPL.



	This software is available on a public web site. It may enable

	cryptographic capabilities of the 3Com hardware, and may be

	exported from the United States under License Exception "TSU"

	pursuant to 15 C.F.R. Section 740.13(e).



	This work was funded by the National Library of Medicine under

	the Department of Energy project number 0274DD06D1 and NLM project

	number Y1-LM-2015-01.



	This driver is designed for the 3Com 3CR990 Family of cards with the

	3XP Processor. It has been tested on x86 and sparc64.



	KNOWN ISSUES:

	*) Cannot DMA Rx packets to a 2 byte aligned address. Also firmware

		issue. Hopefully 3Com will fix it.

	*) Waiting for a command response takes 8ms due to non-preemptable

		polling. Only significant for getting stats and creating

		SAs, but an ugly wart never the less.



	TODO:

	*) Doesn't do IPSEC offloading. Yet. Keep yer pants on, it's coming.

	*) Add more support for ethtool (especially for NIC stats)

	*) Allow disabling of RX checksum offloading

	*) Fix MAC changing to work while the interface is up

		(Need to put commands on the TX ring, which changes

		the locking)

	*) Add in FCS to {rx,tx}_bytes, since the hardware doesn't. See

		http://oss.sgi.com/cgi-bin/mesg.cgi?a=netdev&i=20031215152211.7003fe8e.rddunlap%40osdl.org

/* Set the copy breakpoint for the copy-only-tiny-frames scheme.

 * Setting to > 1518 effectively disables this feature.

/* Should we use MMIO or Port IO?

 * 0: Port IO

 * 1: MMIO

 * 2: Try MMIO, fallback to Port IO

 end user-configurable values */

/* Maximum number of multicast addresses to filter (vs. rx-all-multicast).

 Operational parameters that are set at compile time. */

/* Keep the ring sizes a power of two for compile efficiency.

 * The compiler will convert <unsigned>'%'<2^N> into a bit mask.

 * Making the Tx ring too large decreases the effectiveness of channel

 * bonding and packet priority.

 * There are no ill effects from too-large receive rings.

 *

 * We don't currently use the Hi Tx ring so, don't make it very big.

 *

 * Beware that if we start using the Hi Tx ring, we will need to change

 * typhoon_num_free_tx() and typhoon_tx_complete() to account for that.

/* The 3XP will preload and remove 64 entries from the free buffer

 * list, and we need one entry to keep the ring from wrapping, so

 * to keep this a power of two, we use 128 entries.

 Operational parameters that usually are not changed. */

 Time in jiffies before concluding the transmitter is hung. */

 directly indexed by enum typhoon_cards, above */

/* Notes on the new subsystem numbering scheme:

 * bits 0-1 indicate crypto capabilities: (0) variable, (1) DES, or (2) 3DES

 * bit 4 indicates if this card has secured firmware (we don't support it)

 * bit 8 indicates if this is a (0) copper or (1) fiber card

 * bits 12-16 indicate card type: (0) client and (1) server

/* Define the shared memory area

 * Align everything the 3XP will normally be using.

 * We'll need to move/align txHi if we start using that ring.

 Tx cache line section */

 Irq/Rx cache line section */

 general section */

 unused stuff (future use) */

/* These are the values for the typhoon.card_state variable.

 * These determine where the statistics will come from in get_stats().

 * The sleep image does not support the statistics we need.

/* PCI writes are not guaranteed to be posted in order, but outstanding writes

 * cannot pass a read, so this forces current writes to post.

/* We'll wait up to six seconds for a reset, and half a second normally.

	/* Increment a ring index -- we can use this for all rings execept

	 * the Rx rings, as they use different size descriptors

	 * otherwise, everything is the same size as a cmd_desc

 if we start using the Hi Tx ring, this needs updating */

 sizeof(struct rx_desc) != sizeof(struct cmd_desc) */

	/* The 3XP seems to need a little extra time to complete the load

	 * of the sleep image before we can reliably boot it. Failure to

	 * do this occasionally results in a hung adapter after boot in

	 * typhoon_init_one() while trying to read the MAC address or

	 * putting the card to sleep. 3Com's driver waits 5ms, but

	 * that seems to be overkill. However, if we can sleep, we might

	 * as well give it that much time. Otherwise, we'll give it 500us,

	 * which should be enough (I've see it work well at 100us, but still

	 * saw occasional problems.)

	/* We only get a hello request if we've not sent anything to the

	 * card in a long while. If the lock is held, then we're in the

	 * process of issuing a command, so we don't need to respond.

	/* this works for all descriptors but rx_desc, as they are a

	 * different size than the cmd_desc -- everyone else is the same

 if we start using the Hi Tx ring, this needs updating */

		/* If we're expecting a response, but the caller hasn't given

		 * us a place to put it, we'll provide one.

	/* "I feel a presence... another warrior is on the mesa."

	/* Ugh. We'll be here about 8ms, spinning our thumbs, unable to

	 * preempt or do anything other than take interrupts. So, don't

	 * wait for a response unless you have to.

	 *

	 * I've thought about trying to sleep here, but we're called

	 * from many contexts that don't allow that. Also, given the way

	 * 3Com has implemented irq coalescing, we would likely timeout --

	 * this has been observed in real life!

	 *

	 * The big killer is we have to wait to get stats from the card,

	 * though we could go to a periodic refresh of those if we don't

	 * mind them getting somewhat stale. The rest of the waiting

	 * commands occur during open/close/suspend/resume, so they aren't

	 * time critical. Creating SAs in the future will also have to

	 * wait here.

	/* Collect the error response even if we don't care about the

	 * rest of the response

		/* Ugh. If a response was added to the ring between

		 * the call to typhoon_process_response() and the clearing

		 * of tp->awaiting_resp, we could have missed the interrupt

		 * and it could hang in the ring an indeterminate amount of

		 * time. So, check for it, and interrupt ourselves if this

		 * is the case.

	/* we have two rings to choose from, but we only use txLo for now

	 * If we start using the Hi ring as well, we'll need to update

	 * typhoon_stop_runtime(), typhoon_interrupt(), typhoon_num_free_tx(),

	 * and TXHI_ENTRIES to match, as well as update the TSO code below

	 * to get the right DMA address

	/* We need one descriptor for each fragment of the sk_buff, plus the

	 * one for the ->data area of it.

	 *

	 * The docs say a maximum of 16 fragment descriptors per TCP option

	 * descriptor, then make a new packet descriptor and option descriptor

	 * for the next 16 fragments. The engineers say just an option

	 * descriptor is needed. I've tested up to 26 fragments with a single

	 * packet descriptor/option descriptor combo, so I use that for now.

	 *

	 * If problems develop with TSO, check this first.

	/* When checking for free space in the ring, we need to also

	 * account for the initial Tx descriptor, and we always must leave

	 * at least one descriptor unused in the ring so that it doesn't

	 * wrap and look empty.

	 *

	 * The only time we should loop here is when we hit the race

	 * between marking the queue awake and updating the cleared index.

	 * Just loop and it will appear. This comes from the acenic driver.

 The 3XP will figure out if this is UDP/TCP */

	/* No need to worry about padding packet -- the firmware pads

	 * it with zeros to ETH_ZLEN for us.

	/* Kick the 3XP

	/* If we don't have room to put the worst case packet on the

	 * queue, then we must stop the queue. We need 2 extra

	 * descriptors -- one to prevent ring wrap, and one for the

	 * Tx header.

		/* A Tx complete IRQ could have gotten between, making

		 * the ring free again. Only need to recheck here, since

		 * Tx is serialized.

 Too many to match, or accept all multicasts. */

	/* 3Com's Linux driver uses txMultipleCollisions as it's

	 * collisions value, but there is some other collision info as well...

	 *

	 * The extra status reported would be a good candidate for

	 * ethtool_ops->get_{strings,stats}()

 need to get stats to make these link speed/duplex valid */

 invalid */

 invalid */

	/* The *Hi members of iface are all init'd to zero by the memset().

 Force the writes to the shared memory area out before continuing. */

	/* Cannot just map the firmware image using dma_map_single() as

	 * the firmware is vmalloc()'d and may not be physically contiguous,

	 * so we allocate some coherent memory to copy the sections into.

	/* The ioread32() in typhoon_wait_interrupt() will force the

	 * last write to the command register to post, so

	 * we don't need a typhoon_post_pci_writes() after it.

			/* Do an pseudo IPv4 checksum on the data -- first

			 * need to convert each u16 to cpu order before

			 * summing. Fortunately, due to the properties of

			 * the checksum, we can do this once, at the end.

	/* Clear the Transmit and Command ready registers

			/* This tx_desc describes a packet.

			/* This tx_desc describes a memory mapping. Free it.

 This will need changing if we start to use the Hi Tx ring. */

		/* no room in ring, just drop the skb

 Tell the card about it */

	/* Please, 3com, fix the firmware to allow DMA to a unaligned

	 * address! Pretty please?

	/* Since no card does 64 bit DAC, the high bits will never

	 * change from zero.

 Tell the card about it */

 rxBuff ring is empty, try to fill it. */

	/* Since we cannot monitor the status of the link while sleeping,

	 * tell the world it went away.

	/* Post 2.x.x versions of the Sleep Image require a reset before

	 * we can download the Runtime Image. But let's not make users of

	 * the old firmware pay for the reset.

	/* Disable IRQ coalescing -- we can reenable it when 3Com gives

	 * us some more information on how to control it.

	/* Disable interrupts early, since we can't schedule a poll

	 * when called with !netif_running(). This will be posted

	 * when we force the posting of the command.

	/* Wait 1/2 sec for any outstanding transmits to occur

	 * We'll cleanup after the reset if this times out.

	/* save the statistics so when we bring the interface up again,

	 * the values reported to userspace are correct.

 cleanup any outstanding Tx packets */

 If we ever start using the Hi ring, it will need cleaning too */

 Reset the hardware, and turn off carrier to avoid more timeouts */

 Make sure there is no irq handler running on a different CPU. */

	/* If we're down, resume when we are upped.

	/* If we're down, we're already suspended.

 TYPHOON_OFFLOAD_VLAN is always on now, so this doesn't work */

	/* Ok, see if we can change our interrupt status register by

	 * sending ourselves an interrupt. If so, then MMIO works.

	 * The 50usec delay is arbitrary -- it could probably be smaller.

	/* sanity checks on IO and MMIO BARs

	/* map our registers

	/* allocate pci dma space for rx and tx descriptor rings

	/* Init sequence:

	 * 1) Reset the adapter to clear any bad juju

	 * 2) Reload the sleep image

	 * 3) Boot the sleep image

	 * 4) Get the hardware address.

	 * 5) Put the card to sleep.

	/* Now that we've reset the 3XP and are sure it's not going to

	 * write all over memory, enable bus mastering, and save our

	 * state for resuming after a suspend.

	/* Read the Sleep Image version last, so the response is valid

	 * later when we print out the version reported.

	/* Typhoon 1.0 Sleep Images return one response descriptor to the

	 * READ_VERSIONS command. Those versions are OK after waking up

	 * from sleep without needing a reset. Typhoon 1.1+ Sleep Images

	 * seem to need a little extra help to get started. Since we don't

	 * know how to nudge it along, just kick it.

 The chip-specific entries in the device structure. */

	/* We can handle scatter gather, up to 16 entries, and

	 * we can do IP checksumming (only version 4, doh...)

	 *

	 * There's no way to turn off the RX VLAN offloading and stripping

	 * on the current 3XP firmware -- it does not respect the offload

	 * settings -- so we only allow the user to toggle the TX processing.

	/* xp_resp still contains the response to the READ_VERSIONS command.

	 * For debugging, let the user know what version he has.

		/* This is the Typhoon 1.0 type Sleep Image, last 16 bits

		 * of version is Month/Day of build.

		/* This is the Typhoon 1.1+ type Sleep Image

 EtherLinkXL.c: A 3Com EtherLink PCI III/XL ethernet driver for linux. */

/*

	Written 1996-1999 by Donald Becker.



	This software may be used and distributed according to the terms

	of the GNU General Public License, incorporated herein by reference.



	This driver is for the 3Com "Vortex" and "Boomerang" series ethercards.

	Members of the series include Fast EtherLink 3c590/3c592/3c595/3c597

	and the EtherLink XL 3c900 and 3c905 cards.



	Problem reports and questions should be directed to

	vortex@scyld.com



	The author may be reached as becker@scyld.com, or C/O

	Scyld Computing Corporation

	410 Severn Ave., Suite 210

	Annapolis MD 21403



/*

 * FIXME: This driver _could_ support MTU changing, but doesn't.  See Don's hamachi.c implementation

 * as well as other drivers

 *

 * NOTE: If you make 'vortex_debug' a constant (#define vortex_debug 0) the driver shrinks by 2k

 * due to dead code elimination.  There will be some performance benefits from this due to

 * elimination of all the tests and reduced cache footprint.

 A few values that may be tweaked. */

 Keep the ring sizes a power of two for efficiency. */

 Size of each temporary Rx buffer.*/

 "Knobs" that adjust features and parameters. */

/* Set the copy breakpoint for the copy-only-tiny-frames scheme.

/* ARM systems perform better by disregarding the bus-master

 Allow setting MTU to a larger size, bypassing the normal ethernet setup. */

 Maximum events (Rx packets, etc.) to handle at each interrupt. */

 Tx timeout interval (millisecs) */

/* Allow aggregation of Tx interrupts.  Saves CPU load at the cost

 * of possible Tx stalls if the system is blocking interrupts

 * somewhere else.  Undefine this to disable.

 Put out somewhat more debugging messages. (0: no msg, 1 minimal .. 6). */

 For nr_irqs only. */

/* Kernel compatibility defines, some common to David Hinds' PCMCIA package.

 Operational parameter that usually are not changed. */

/* The Vortex size is twice that of the original EtherLinkIII series: the

   runtime register window, window 1, is now always mapped in.

   The Boomerang size is twice as large as the Vortex -- it has additional

/* Set iff a MII transceiver on any interface requires mdio preamble.

   This only set with the original DP83840 on older 3c905 boards, so the extra

/*

				Theory of Operation



I. Board Compatibility



This device driver is designed for the 3Com FastEtherLink and FastEtherLink

XL, 3Com's PCI to 10/100baseT adapters.  It also works with the 10Mbs

versions of the FastEtherLink cards.  The supported product IDs are

  3c590, 3c592, 3c595, 3c597, 3c900, 3c905



The related ISA 3c515 is supported with a separate driver, 3c515.c, included

with the kernel source or available from

    cesdis.gsfc.nasa.gov:/pub/linux/drivers/3c515.html



II. Board-specific settings



PCI bus devices are configured by the system at boot time, so no jumpers

need to be set on the board.  The system BIOS should be set to assign the

PCI INTA signal to an otherwise unused system IRQ line.



The EEPROM settings for media type and forced-full-duplex are observed.

The EEPROM media type should be left at the default "autoselect" unless using

10base2 or AUI connections which cannot be reliably detected.



III. Driver operation



The 3c59x series use an interface that's very similar to the previous 3c5x9

series.  The primary interface is two programmed-I/O FIFOs, with an

alternate single-contiguous-region bus-master transfer (see next).



The 3c900 "Boomerang" series uses a full-bus-master interface with separate

lists of transmit and receive descriptors, similar to the AMD LANCE/PCnet,

DEC Tulip and Intel Speedo3.  The first chip version retains a compatible

programmed-I/O interface that has been removed in 'B' and subsequent board

revisions.



One extension that is advertised in a very large font is that the adapters

are capable of being bus masters.  On the Vortex chip this capability was

only for a single contiguous region making it far less useful than the full

bus master capability.  There is a significant performance impact of taking

an extra interrupt or polling for the completion of each transfer, as well

as difficulty sharing the single transfer engine between the transmit and

receive threads.  Using DMA transfers is a win only with large blocks or

with the flawed versions of the Intel Orion motherboard PCI controller.



The Boomerang chip's full-bus-master interface is useful, and has the

currently-unused advantages over other similar chips that queued transmit

packets may be reordered and receive buffer groups are associated with a

single frame.



With full-bus-master support, this driver uses a "RX_COPYBREAK" scheme.

Rather than a fixed intermediate receive buffer, this scheme allocates

full-sized skbuffs as receive buffers.  The value RX_COPYBREAK is used as

the copying breakpoint: it is chosen to trade-off the memory wasted by

passing the full-sized skbuff to the queue layer for all frames vs. the

copying cost of copying a frame to a correctly-sized skbuff.



IIIC. Synchronization

The driver runs as two independent, single-threaded flows of control.  One

is the send-packet routine, which enforces single-threaded use by the

dev->tbusy flag.  The other thread is the interrupt handler, which is single

threaded by the hardware and other software.



IV. Notes



Thanks to Cameron Spitzer and Terry Murphy of 3Com for providing development

3c590, 3c595, and 3c900 boards.

The name "Vortex" is the internal 3Com project name for the PCI ASIC, and

the EISA version is called "Demon".  According to Terry these names come

from rides at the local amusement park.



The new chips support both ethernet (1.5K) and FDDI (4.5K) packet sizes!

This driver only supports ethernet packets because of the skbuff allocation

limit of 4K.

/* This table drives the PCI probe routines.  It's mostly boilerplate in all

   of the drivers, and will likely be provided by some future kernel.

 AKPM: Uses 0x230 as the base bitmaps for EEPROM reads */

/* note: this array directly indexed by above enums, and MUST

 * be kept in sync with both the enums above, and the PCI device

 * table below

 AKPM: from Don's 3c59x_cb.c 0.49H */

 AKPM: from Don's 3c59x_cb.c 0.49H */

 AKPM: from Don's 0.99M */

 AKPM: from Don's 0.99M */

 From pcmcia-cs-3.1.5 */

 AKPM: from Don's 0.99Q */

 NULL terminated list. */

 0 terminated list. */

/* Operational definitions.

   These are not used by other compilation units and thus are not

   exported in a ".h" file.



   First the windows.  There are eight register windows, with the command

   and status registers available in each.

/* The top five bits written to EL3_CMD are a command, the lower

   11 bits are the parameter, if applicable.

   Note that 11 parameters bits was fine for ethernet, but the new chip

   can handle FDDI length frames (~4500 octets) and now parameters count

 The SetRxFilter command accepts the following classes: */

 Bits in the general status register. */

 DMA controller is still busy.*/

 EL3_CMD is still busy.*/

/* Register window 1 offsets, the window used in normal operation.

 Remaining free bytes in Tx buffer. */

 Window 0: EEPROM command register. */

 Window 0: EEPROM results register. */

 Valid in all windows. */

 Enable erasing/writing for 10 msec. */

 Disable EWENB before 10 msec timeout. */

 EEPROM locations. */

 Window 2. */

 Window 3: MAC/config bits. */

 Window 4: Xcvr/media bits. */

 Enable SQE error counting for AUI. */

 Enable link beat and jabber for 10baseT. */

 Enable just link beat for 100TX/100FX. */

 Window 7: Bus Master control. */

 Boomerang bus master control registers. */

/* The Rx and Tx descriptor lists.

   Caution Alpha hackers: these types are 32 bits!  Note also the 8 byte

 Last Addr/Len pair in descriptor. */

 This packet has been downloaded */

 Last entry points to 0.   */

 Up to 63 addr/len pairs possible. */

 Set LAST_FRAG to indicate last pair. */

 Values for the Rx status entry. */

 See boomerang_rx() for actual error bits */

 Last entry points to 0.   */

 bits 0:12 length, others see below.  */

 Values for the Tx status entry. */

 IRQ when in FIFO, but maybe not sent. */

 Chip features we care about in vp->capabilities, read from the EEPROM. */

 The Rx and Tx rings should be quad-word-aligned. */

 The addresses of transmit- and receive-in-place skbuffs. */

 The next free ring entry */

 The ring entries to be free()ed. */

 NIC-specific extra stats */

 Packet being eaten by bus master ctrl.  */

 Allocated DMA address for bus master ctrl DMA.   */

 PCI configuration space information. */

 IO address space */

 CardBus function status addr space. */

 Some values here only for performance evaluation and path-coverage */

 The remainder are related to chip state, mostly media selection. */

 Media selection timer. */

 User-settable misc. driver options. */

 Passed-in media type. */

 Read from the EEPROM/Wn3_Config. */

 Vortex can only do a fragment bus-m. */

 Boomerang  */

 Use 802.3x flow control (PAUSE only) */

 Partner supports flow control */

 Wake-on-LAN is enabled */

 pci_dev->saved_config_space has sane contents */

 accept large frames */

 private in_irq indicator */

	/* {get|set}_wol operations are already serialized by rtnl.

	 * no additional locking is required for the enable_wol and acpi_set_WOL()

 From Wn3_Options. */

 Various, from EEPROM. */

 NWay media advertisement */

 MII device addresses. */

	u16 deferred;						/* Resend these interrupts when we

 Size of PCI region (for release_region) */

	/* Serialises access to hardware other than MII and variables below.

 Serialises access to MII */

 MII lib hooks/info */

 Serialises access to windowed regs */

 Register window */

/* The action to take with a media selection timer tick.

   Note that we deviate from the 3Com order by checking 10base2 before AUI.

 Bits to set in Wn4_Media register. */

 The transceiver-present bit in Wn3_Config.*/

 The media type to try next. */

 Time before we check media status. */

 number of ETHTOOL_GSTATS u64's */

 This driver uses 'options' to pass the media type, full-duplex flag, etc. */

 Option count limit only -- unlimited interfaces are supported. */

 Variables to work-around the Compaq PCI BIOS32 problem. */

 !CONFIG_PM */

 !CONFIG_PM */

 CONFIG_EISA */

 returns count found (>= 0), or negative on error */

		/*

		 * Because of the way EISA bus is probed, we cannot assume

		 * any device have been found when we exit from

		 * eisa_driver_register (the bus root driver may not be

		 * initialized yet). So we blindly assume something was

		 * found, and let the sysfs magic happened...

 Special code to work-around the Compaq PCI BIOS32 problem. */

 returns count (>= 0), or negative on error */

 wake up and enable device */

 Determine the default if the user didn't override us */

 If mapping fails, fall-back to BAR 0... */

/*

 * Start up the PCI/EISA device which is described by *gendev.

 * Return 0 on success.

 *

 * NOTE: pdev can be NULL, for the case of a Compaq device

 EEPROM contents */

 The lower four bits are the media type. */

		/*

		 * The 'options' param is passed in as the third arg to the

		 * LILO 'ether=' argument for non-modular use

 module list only for Compaq device */

 PCI-only startup logic */

 enable bus-mastering if necessary */

			/* Check the PCI latency value.  On the 3c590 series the latency timer

			   must be set to the maximum value to avoid data corruption that occurs

			   when the timer expires during a transfer.  This bug exists the Vortex

 Makes sure rings are at least 16 byte aligned. */

	/* if we are a PCI driver, we store info in pdev->driver_data

 Read the station address from the EEPROM. */

 Pause for at least 162 us. for the read to take place. */

 Grrr, needless incompatible change 3Com. */

	/* Unfortunately an all zero eeprom passes the checksum and this

 With every pack */

 Tell them about an invalid IRQ. */

 Extract our information from the EEPROM data. */

 Broken 3c916 */

			/*

			 * For the 3c905CX we look at index 24 first, because it bogusly

			 * reports an external PHY at all indices

 Only advertise the FD media types. */

 AKPM: vortex only */

 The 3c59x-specific entries in the device structure. */

 Actually, it still should work with iommu. */

 OK, that didn't work.  Do it the slow way.  One second */

 Set the full-duplex bit. */

 Go active */

 Before initializing select the active media port. */

 Find first available media type, starting with 100baseTx. */

	/*

	 * Don't reset the PHY - that upsets autonegotiation during DHCP operations.

 Set the station address and mask in window 2 each time opened. */

 Start the thinnet transceiver. We should really wait 50ms...*/

 Switch to the stats window, and clear all stats by reading. */

 New: On the Vortex we must also clear the BadSSD counter. */

 ..and on the Boomerang we enable the extra statistics bits. */

 Boomerang bus master. */

 Initialize the RxEarly register as recommended. */

 Boomerang bus master Tx. */

 Room for a packet. */

 Clear the Rx, Tx rings. */

 AKPM: this is done in vortex_open, too */

 Set receiver mode: presumably accept b-case and phys addr only. */

 enable 802.1q tagged frames */

 Turn on statistics. */

 Enable the receiver. */

 Enable transmitter. */

 Allow status bits to be seen. */

 Ack all pending events, and set active indicator mask. */

 The PCMCIA people are idiots.  */

 Use the now-standard shared IRQ implementation. */

 Boomerang bus master. */

 Clear complete bit. */

 Bad news!  */

 Align IP on 16 byte boundaries */

 Wrap the ring. */

 Other media types handled by Tx timeouts. */

 Go back to default. */

 AKPM: FIXME: Should reset Rx & Tx here.  P60 of 3c90xc.pdf */

 Slight code bloat to be user friendly. */

 Bad idea here.. but we might as well handle a few events. */

 Issue Tx Enable */

 prevent tx timeout */

/*

 * Handle uncommon interrupt sources.  This is a separate routine to minimize

 * the cache impact.

 Really "TxError" for us. */

 Presumably a tx-timeout. We must merely re-enable. */

 txJabber or txUnderrun */

 maxCollisions */

 Reset interface logic, but not download logic */

 Merely re-enable the transmitter. */

 Rx early is unused. */

 Empty statistics. */

 HACK: Disable statistics as an interrupt source. */

 This occurs when we have the wrong media type! */

 Restore all interrupt sources.  */

 Adapter failure requires Tx/Rx reset and reinit. */

 0x80000000 PCI master abort. */

 0x40000000 PCI target abort. */

 In this case, blow the card away */

 Must not enter D3 or we can't legally issue the reset! */

 AKPM: bug.  vortex_up() assumes that the rx ring is full. It may not be. */

 Reset Rx fifo and upload logic */

 Set the Rx filter to the current state. */

 enable 802.1q VLAN tagged frames */

 Re-enable the receiver. */

 Put out the doubleword header... */

 Set the bus-master controller to transfer the packet. */

 netif_wake_queue() will be called at the DMADone interrupt. */

 ... and the packet rounded to a doubleword. */

 AKPM: redundant? */

 Interrupt us when the FIFO has room for max-sized packet. */

 Clear the Tx status stack. */

 A Tx-disabling error occurred.  */

 Pop the status stack. */

 Calculate the next Tx descriptor entry. */

	/*

	 * We can't allow a recursion from our interrupt handler back into the

	 * tx routine, as they take the same spin lock, and that causes

	 * deadlock.  Just return NETDEV_TX_BUSY and let the stack try again in

	 * a bit

 Wait for the stall to complete. */

 Clear previous interrupt enable. */

		/* Dubious. If in boomeang_interrupt "faster" cyclone ifdef

		 * were selected, this would corrupt DN_COMPLETE. No?

/* The interrupt handler does all of the Rx thread work and cleans up

/*

 * This is the ISR for the vortex series chips.

 * full_bus_master_tx == 0 && full_bus_master_rx == 0

 No interrupt: shared IRQs cause this */

 h/w no longer present (hotplug)? */

 There's room in the FIFO for a full-sized packet. */

 Ack the event. */

 Release the transferred buffer */

					/*

					 * AKPM: FIXME: I don't think we need this.  If the queue was stopped due to

					 * insufficient FIFO room, the TxAvailable test will succeed and call

					 * netif_wake_queue()

 Interrupt when FIFO has room for max-sized packet. */

 Check for all uncommon interrupts at once. */

 Disable all pending interrupts. */

 The timer will reenable interrupts. */

 Acknowledge the IRQ. */

/*

 * This is the ISR for the boomerang series chips.

 * full_bus_master_tx == 1 && full_bus_master_rx == 1

 No interrupt: shared IRQs can cause this */

 h/w no longer present (hotplug)? */

 AKPM: the latter is faster, but cyclone-only */

 It still hasn't been processed. */

 It still hasn't been processed. */

 dev->stats.tx_packets++;  Counted below. */

 Check for all uncommon interrupts at once. */

 Disable all pending interrupts. */

 The timer will reenable interrupts. */

 Acknowledge the IRQ. */

 The PCMCIA people are idiots.  */

 Error, update stats. */

 The packet length: up to 4.5K!. */

 Align IP on 16 byte boundaries */

 'skb_put()' points to the start of sk_buff data area. */

 Pop top Rx packet. */

 Wait a limited time to go to next packet. */

 Error, update stats. */

 The packet length: up to 4.5K!. */

			/* Check if the packet is long enough to just accept without

 Align IP on 16 byte boundaries */

 'skb_put()' points to the start of sk_buff data area. */

				/* Pre-allocate the replacement skb.  If it or its

				 * mapping fails then recycle the buffer thats already

				 * in place

 Pass up the skbuff already on the Rx ring. */

 Use hardware checksum info. */

 Clear complete bit. */

 Turn off statistics ASAP.  We update dev->stats below. */

 Disable the receiver and transmitter. */

 Disable receiving 802.1q tagged frames */

 Turn off thinnet power.  Green! */

 Free Boomerang bus master Rx buffers. */

 Free Boomerang bus master Tx buffers. */

 Possible racy. But it's only debug stuff */

 AKPM: Used to be netif_running */

/*  Update statistics.

	Unlike with the EL3 we need not worry about interrupts changing

	the window setting from underneath us, but we must still guard

	against a race condition with a StatsUpdate interrupt updating the

	table.  This is done by checking that the ASM (!) code generated uses

	atomic updates with '+='.

 Unlike the 3c5x9 we need not turn off stats updates while reading. */

 Switch to the stats window, and read everything. */

 Rx packets	*/			window_read8(vp, 6, 7);   
	/* Don't bother with register 9, an extension of registers 6&7.

	   If we do use the 6&7 values the atomic update assumption above

 Extra stats for get_ethtool_stats() */

/*

 *	Must power the device up to do MDIO operations

 The kernel core really should have pci_get_power_state() */

/* Pre-Cyclone chips have no documented multicast filter, so the only

   multicast setting is to receive all multicast frames.  At least

/* Setup the card so that it can receive frames with an 802.1q VLAN tag.

   Note that this must be done after each RxReset due to some backwards

 The Ethernet Type used for 802.1q tagged frames */

		/* cyclone and tornado chipsets can recognize 802.1q

 MTU+Ethernet header */

 802.1Q VLAN tag */

		/* set VlanEtherType to let the hardware checksumming

 on older cards we have to enable large frames */

/* MII transceiver control section.

   Read and write the MII registers using software-generated serial

   MDIO protocol.  See the MII specifications or DP83840A data sheet

/* The maximum data clock rate is 2.5 Mhz.  The minimum timing is usually

   met by back-to-back PCI I/O cycles, but we insert a delay to avoid

/* Generate the preamble required for initial synchronization and

 Establish sync by sending at least 32 logic ones. */

 Shift the read command bits out. */

 Read the two transition, 16 data, and wire-idle bits. */

 Shift the command bits out. */

 Leave the interface idle. */

 ACPI: Advanced Configuration and Power Interface. */

 Set Wake-On-LAN mode and put the board into D3 (power-down) state. */

 Power up on: 1==Downloaded Filter, 2==Magic Packets, 4==Link Status. */

 The RxFilter must accept the WOL frames. */

 Change the power state to D3; RxEnable doesn't take effect. */

 Go active */

 Should really use issue_and_wait() here */

 Take care of the EISA devices */

 3c509.c: A 3c509 EtherLink3 ethernet driver for linux. */

/*

	Written 1993-2000 by Donald Becker.



	Copyright 1994-2000 by Donald Becker.

	Copyright 1993 United States Government as represented by the

	Director, National Security Agency.	 This software may be used and

	distributed according to the terms of the GNU General Public License,

	incorporated herein by reference.



	This driver is for the 3Com EtherLinkIII series.



	The author may be reached as becker@scyld.com, or C/O

	Scyld Computing Corporation

	410 Severn Ave., Suite 210

	Annapolis MD 21403



	Known limitations:

	Because of the way 3c509 ISA detection works it's difficult to predict

	a priori which of several ISA-mode cards will be detected first.



	This driver does not use predictive interrupt mode, resulting in higher

	packet latency but lower overhead.  If interrupts are disabled for an

	unusually long time it could also result in missed packets, but in

	practice this rarely happens.





	FIXES:

		Alan Cox:       Removed the 'Unexpected interrupt' bug.

		Michael Meskes:	Upgraded to Donald Becker's version 1.07.

		Alan Cox:	Increased the eeprom delay. Regardless of

				what the docs say some people definitely

				get problems with lower (but in card spec)

				delays

		v1.10 4/21/97 Fixed module code so that multiple cards may be detected,

				other cleanups.  -djb

		Andrea Arcangeli:	Upgraded to Donald Becker's version 1.12.

		Rick Payne:	Fixed SMP race condition

		v1.13 9/8/97 Made 'max_interrupt_work' an insmod-settable variable -djb

		v1.14 10/15/97 Avoided waiting..discard message for fast machines -djb

		v1.15 1/31/98 Faster recovery for Tx errors. -djb

		v1.16 2/3/98 Different ID port handling to avoid sound cards. -djb

		v1.18 12Mar2001 Andrew Morton

			- Avoid bogus detect of 3c590's (Andrzej Krzysztofowicz)

			- Reviewed against 1.18 from scyld.com

		v1.18a 17Nov2001 Jeff Garzik <jgarzik@pobox.com>

			- ethtool support

		v1.18b 1Mar2002 Zwane Mwaikambo <zwane@commfireservices.com>

			- Power Management support

		v1.18c 1Mar2002 David Ruggiero <jdr@farfalle.com>

			- Full duplex support

		v1.19  16Oct2002 Zwane Mwaikambo <zwane@linuxpower.ca>

			- Additional ethtool features

		v1.19a 28Oct2002 Davud Ruggiero <jdr@farfalle.com>

			- Increase *read_eeprom udelay to workaround oops with 2 cards.

		v1.19b 08Nov2002 Marc Zyngier <maz@wild-wind.fr.eu.org>

			- Introduce driver model for EISA cards.

		v1.20  04Feb2008 Ondrej Zary <linux@rainbow-software.org>

			- convert to isa_driver and pnp_driver and some cleanups

 A few values that may be tweaked. */

 Time in jiffies before concluding the transmitter is hung. */

 for udelay() */

/* Used to do a global count of all the cards in the system.  Must be

 * a global variable so that the eisa probe routines can increment

/* To minimize the size of the driver source I only define operating

   constants if they are used several times.  You'll need the manual

 Offsets from base I/O address. */

/* The top five bits written to EL3_CMD are a command, the lower

 The SetRxFilter command accepts the following classes: */

 Register window 1 offsets, the window used in normal operation. */

 Remaining free bytes in Tx buffer. */

 Window 0: Configuration control register */

 Window 0: Address configuration register */

 Window 0: Set IRQ line in bits 12-15. */

 Window 4: Various transcvr/media bits. */

 Enable link beat and jabber for 10baseT. */

 Window 4: Net diagnostic */

 Enable full-duplex ("external loopback") */

/*

 * Must be a power of two (we use a binary and in the

 * circular queue)

 skb send-queue */

 Parameters that may be passed into the module. */

 Maximum events (Rx packets, etc.) to handle at each interrupt. */

 generic device remove for all device types */

 Return 0 on success, 1 on error, 2 when found already detected PnP card */

	/* ISA boards are detected by sending the ID sequence to the

	   ID_PORT.  We find cards past the first by setting the 'current_tag'

	   on cards as they are found.  Cards with their tag set will not

 For the first probe, clear all board's tag registers. */

 Otherwise kill off already-found boards. */

	/* Read in EEPROM data, which does contention-select.

	   Only the lowest address board will stay "on-line".

		/* The ISA PnP 3c509 cards respond to the ID sequence too.

 Set the adaptor tag so that the next card can be found. */

 CONFIG_PNP */

 Skip to next card when PnP card found */

 Set the adaptor tag so that the next card can be found. */

 Activate the adaptor at the EEPROM location. */

 Free the interrupt so that some other card can use it. */

 Skip to next card when PnP card found */

 Set the adaptor tag so that the next card can be found. */

 Enable the card */

 Free the interrupt so that some other card can use it. */

 3Com Etherlink III (TP) */

 3Com Etherlink III */

 3Com Etherlink III (combo) */

 3Com Etherlink III (TPO) */

 3Com Etherlink III (TPC) */

 3Com Etherlink III compatible */

 3Com Etherlink III compatible */

 CONFIG_PNP */

 xcvr codes 1/3/4/12 */

 xcvr codes 0/8 */

 use eeprom value, but save user's full-duplex selection */

 The EL3-specific entries in the device structure. */

 Yeepee, The driver framework is calling us ! */

 Change the register set to the configuration window 0. */

 Restore the "Product ID" to the EEPROM read register. */

/* This remove works for all device types.

 *

/* Read a word from the EEPROM using the regular EEPROM access register.

   Assume that we are in register window zero.

	/* Pause for at least 162 us. for the read to take place.

 Read a word from the EEPROM when in the ISA ID probe state. */

	/* Issue read command, and pause for at least 162 us. for it to complete.

 Pause for at least 162 us. for the read to take place. */

 Some chips seem to require much longer */

 Transmitter timeout, serious problems. */

 prevent tx timeout */

 Issue TX_RESET and TX_START commands. */

	/*

	 *	We lock the driver against other processors. Note

	 *	we don't need to lock versus the IRQ as we suspended

	 *	that. This means that we lose the ability to take

	 *	an RX during a TX upload. That sucks a bit with SMP

	 *	on an original 3c509 (2K buffer)

	 *

	 *	Using disable_irq stops us crapping on other

	 *	time sensitive devices.

 Put out the doubleword header... */

 ... and the packet rounded to a doubleword. */

 Interrupt us when the FIFO has room for max-sized packet. */

 Clear the Tx status stack. */

 Pop the status stack. */

 The EL3 interrupt handler. */

 There's room in the FIFO for a full-sized packet. */

 Handle all uncommon interrupts. */

 Empty statistics. */

 Rx early is unused. */

 Really Tx error. */

 Pop the status stack. */

 Adapter failure requires Rx reset and reinit. */

 Set the Rx filter to the current state. */

 Re-enable the receiver. */

 Clear all interrupts. */

 Acknowledge the IRQ. */

 Ack IRQ */

/*

 * Polling receive - used by netconsole and other diagnostic tools

 * to allow network i/o with interrupts disabled.

	/*

	 *	This is fast enough not to bother with disable IRQ

	 *	stuff.

/*  Update statistics.  We change to register window 6, so this should be run

	single-threaded if the device is active. This is expected to be a rare

	operation, and it's simpler for the rest of the driver to assume that

	window 1 is always valid rather than use a special window-state variable.

 Turn off statistics updates while reading. */

 Switch to the stats window, and read everything. */

 Multiple collisions. */	   inb(ioaddr + 2);

 Rx packets	*/		   inb(ioaddr + 7);

 Tx deferrals */		   inb(ioaddr + 8);

 Total Rx and Tx octets. */

 Back to window 1, and turn statistics back on. */

 Error, update stats. */

 Align IP on 16 byte */

 'skb->data' points to the start of sk_buff data area. */

 Pop top Rx packet. */

 Delay. */

/*

 *     Set or clear the multicast filter for this adaptor.

 Switching back to window 0 disables the IRQ. */

		/* But we explicitly zero the IRQ line select anyway. Don't do

		 * it on EISA cards, it prevents the module from getting an

 obtain current transceiver via WN4_MEDIA? */

 hmm... */

 change XCVR type */

 fire up the DC-DC convertor if BNC gets enabled */

 Turn off statistics ASAP.  We update lp->stats below. */

 Disable the receiver and transmitter. */

 Turn off thinnet power.  Green! */

 Disable link beat and jabber, if_port may change here next open(). */

 Activating the board required and does no harm otherwise */

 Set the IRQ line. */

 Set the station address in window 2 each time opened. */

 BNC interface */

 Start the thinnet transceiver. We should really wait 50ms...*/

 10baseT interface */

		/* Combine secondary sw_info word (the adapter level) and primary

 temporarily assume full-duplex will be set */

 force full-duplex mode if 3c5x9b */

 set full-duplex mode based on eeprom config setting */

 xcvr=(0 || 4) OR user has an old 3c5x9 non "B" model */

 disable full duplex */

 Enable link beat and jabber check. */

 Switch to the stats window, and clear all stats by reading. */

 Switch to register set 1 for normal use. */

 Accept b-case and phys addr only. */

 Turn on statistics. */

 Enable the receiver. */

 Enable transmitter. */

 Allow status bits to be seen. */

 Ack all pending events, and set active indicator mask. */

 Power Management support functions */

 CONFIG_PM */

 CONFIG_PNP */

 Select an open I/O location at 0x1*0 to do ISA contention select. */

 Start with 0x110 to avoid some sound cards.*/

/* Synopsys DesignWare Core Enterprise Ethernet (XLGMAC) Driver

 *

 * Copyright (c) 2017 Synopsys, Inc. (www.synopsys.com)

 *

 * This program is dual-licensed; you may select either version 2 of

 * the GNU General Public License ("GPL") or BSD license ("BSD").

 *

 * This Synopsys DWC XLGMAC software driver and associated documentation

 * (hereinafter the "Software") is an unsupported proprietary work of

 * Synopsys, Inc. unless otherwise expressly agreed to in writing between

 * Synopsys and you. The Software IS NOT an item of Licensed Software or a

 * Licensed Product under any End User Software License Agreement or

 * Agreement for Licensed Products with Synopsys or any supplement thereto.

 * Synopsys is a registered trademark of Synopsys, Inc. Other names included

 * in the SOFTWARE may be the trademarks of their respective owners.

 Descriptors */

 Array of descriptor data */

 Get the per DMA interrupt */

 Try to obtain pages, decreasing order if necessary */

 Map the pages */

 This data descriptor is responsible for unmapping page(s) */

 Get a new allocation next time */

 Set up the header page info */

 Set up the buffer page info */

 Save space for a context descriptor if needed */

 Map the TSO header */

 Map the (remainder of the) packet */

	/* Save the skb address in the last entry. We always have some data

	 * that has been mapped so desc_data is always advanced past the last

	 * piece of mapped data - use the entry pointed to by cur_index - 1.

 Save the number of descriptor entries used */

/* Synopsys DesignWare Core Enterprise Ethernet (XLGMAC) Driver

 *

 * Copyright (c) 2017 Synopsys, Inc. (www.synopsys.com)

 *

 * This program is dual-licensed; you may select either version 2 of

 * the GNU General Public License ("GPL") or BSD license ("BSD").

 *

 * This Synopsys DWC XLGMAC software driver and associated documentation

 * (hereinafter the "Software") is an unsupported proprietary work of

 * Synopsys, Inc. unless otherwise expressly agreed to in writing between

 * Synopsys and you. The Software IS NOT an item of Licensed Software or a

 * Licensed Product under any End User Software License Agreement or

 * Agreement for Licensed Products with Synopsys or any supplement thereto.

 * Synopsys is a registered trademark of Synopsys, Inc. Other names included

 * in the SOFTWARE may be the trademarks of their respective owners.

/* Synopsys DesignWare Core Enterprise Ethernet (XLGMAC) Driver

 *

 * Copyright (c) 2017 Synopsys, Inc. (www.synopsys.com)

 *

 * This program is dual-licensed; you may select either version 2 of

 * the GNU General Public License ("GPL") or BSD license ("BSD").

 *

 * This Synopsys DWC XLGMAC software driver and associated documentation

 * (hereinafter the "Software") is an unsupported proprietary work of

 * Synopsys, Inc. unless otherwise expressly agreed to in writing between

 * Synopsys and you. The Software IS NOT an item of Licensed Software or a

 * Licensed Product under any End User Software License Agreement or

 * Agreement for Licensed Products with Synopsys or any supplement thereto.

 * Synopsys is a registered trademark of Synopsys, Inc. Other names included

 * in the SOFTWARE may be the trademarks of their respective owners.

		/* If we haven't notified the hardware because of xmit_more

		 * support, tell it now

	/* Update the number of packets that will ultimately be transmitted

	 * along with the extra bytes for each extra packet

 TSO requires an extra descriptor if mss is different */

 TSO requires an extra descriptor for TSO header */

 VLAN requires an extra descriptor if tag is different */

 We can share with the TSO context descriptor */

	/* The DMA interrupt status register also reports MAC and MTL

	 * interrupts. So for polling mode, we just need to check for

	 * this register to be non-zero

		/* The TI or RI interrupt bits may still be set even if using

		 * per channel DMA interrupts. Check to be sure those are not

		 * enabled before using the private data napi structure.

 Disable Tx and Rx interrupts */

 Turn on polling */

 Restart the device on a Fatal Bus Error */

 Clear all interrupt signals */

	/* Per channel DMA interrupts are enabled, so we use the per

	 * channel napi structure and not the private data napi structure

 Disable Tx and Rx interrupts */

 Turn on polling */

 Disable Tx and Rx interrupts */

 Turn on polling */

 Using an unsigned int, 'i' will go to UINT_MAX and exit */

 If not running, "restart" will happen on open */

 TODO: Initialize the phy */

 Calculate the Rx buffer size before allocating rings */

 Allocate the channels and rings */

 Stop the device */

 Free the channels and rings */

 Prepare preliminary packet info for TX */

 Check that there are enough descriptors available */

 Report on the actual number of bytes (to be) sent */

 Configure required descriptor fields for transmission */

 Stop the queue in advance if there may not be enough descriptors */

 CONFIG_NET_POLL_CONTROLLER */

 Reset desc_data values */

 Make sure everything is written before the register write */

	/* Update the Rx Tail Pointer Register with address of

	 * the last cleaned entry

	/* Start with the header buffer which may contain just the header

	 * or the header plus data

 Add the remaining data as a frag */

 Nothing to do if there isn't a Tx ring for this channel */

 Be sure we get ring->cur before accessing descriptor data */

		/* Make sure descriptor fields are read after reading

		 * the OWN bit

 Free the SKB and reset the descriptor for re-use */

 Nothing to do if there isn't a Rx ring for this channel */

 First time in loop see if we need to restore state */

 Earlier error, just drain the remaining data */

 Length is cumulative, get this descriptor's length */

 Be sure we don't exceed the configured MTU */

 Check if we need to save state before leaving */

 Cleanup Tx ring first */

 Process Rx ring next */

 If we processed everything, we are done */

 Turn off polling */

 Enable Tx and Rx interrupts */

 Cleanup Tx ring first */

 Process Rx ring next */

 If we processed everything, we are done */

 Turn off polling */

 Enable Tx and Rx interrupts */

/* Synopsys DesignWare Core Enterprise Ethernet (XLGMAC) Driver

 *

 * Copyright (c) 2017 Synopsys, Inc. (www.synopsys.com)

 *

 * This program is dual-licensed; you may select either version 2 of

 * the GNU General Public License ("GPL") or BSD license ("BSD").

 *

 * This Synopsys DWC XLGMAC software driver and associated documentation

 * (hereinafter the "Software") is an unsupported proprietary work of

 * Synopsys, Inc. unless otherwise expressly agreed to in writing between

 * Synopsys and you. The Software IS NOT an item of Licensed Software or a

 * Licensed Product under any End User Software License Agreement or

 * Agreement for Licensed Products with Synopsys or any supplement thereto.

 * Synopsys is a registered trademark of Synopsys, Inc. Other names included

 * in the SOFTWARE may be the trademarks of their respective owners.

 Put the VLAN tag in the Rx descriptor */

 Don't check the VLAN type */

 Check only C-TAG (0x8100) packets */

 Don't consider an S-TAG (0x88A8) packet as a VLAN packet */

 Enable VLAN tag stripping */

 Enable VLAN filtering */

 Enable VLAN Hash Table filtering */

 Disable VLAN tag inverse matching */

 Only filter on the lower 12-bits of the VLAN tag */

	/* In order for the VLAN Hash Table filtering to be effective,

	 * the VLAN tag identifier in the VLAN Tag Register must not

	 * be zero.  Set the VLAN tag identifier to "1" to enable the

	 * VLAN Hash Table filtering.  This implies that a VLAN tag of

	 * 1 will always pass filtering.

 Disable VLAN filtering */

 Generate the VLAN Hash Table value */

 Get the CRC32 value of the VLAN ID */

 Set the VLAN Hash Table filtering register */

 Hardware will still perform VLAN filtering in promiscuous mode */

 Clear remaining additional MAC address entries */

 Build the MAC Hash Table register values */

 Set the MAC Hash Table registers */

 Filtering is done using perfect filtering and hash filtering */

 Indicate that VLAN Tx CTAGs come from context descriptors */

 Set the current VLAN Hash Table register value */

 Calculate the status register to read and the position within */

	/* The Tx engine cannot be stopped if it is actively processing

	 * descriptors. Wait for the Tx engine to enter the stopped or

	 * suspended state.  Don't wait forever though...

 Enable each Tx DMA channel */

 Enable each Tx queue */

 Enable MAC Tx */

 Prepare for Tx DMA channel stop */

 Disable MAC Tx */

 Disable each Tx queue */

 Disable each Tx DMA channel */

	/* The Rx engine cannot be stopped if it is actively processing

	 * packets. Wait for the Rx queue to empty the Rx fifo.  Don't

	 * wait forever though...

 Enable each Rx DMA channel */

 Enable each Rx queue */

 Enable MAC Rx */

 Disable MAC Rx */

 Prepare for Rx DMA channel stop */

 Disable each Rx queue */

 Disable each Rx DMA channel */

 Make sure everything is written before the register write */

	/* Issue a poll command to Tx DMA by writing address

	 * of next immediate free descriptor

 Start the Tx timer */

	/* Determine if an interrupt should be generated for this Tx:

	 *   Interrupt:

	 *     - Tx frame count exceeds the frame count setting

	 *     - Addition of Tx frame count to the frame count since the

	 *       last interrupt was set exceeds the frame count setting

	 *   No interrupt:

	 *     - No frame count setting specified (ethtool -C ethX tx-frames 0)

	 *     - Addition of Tx frame count to the frame count since the

	 *       last interrupt was set does not exceed the frame count setting

 Create a context descriptor if this is a TSO pkt_info */

 Set the MSS size */

 Mark it as a CONTEXT descriptor */

 Indicate this descriptor contains the MSS */

 Mark it as a CONTEXT descriptor */

 Set the VLAN tag */

 Indicate this descriptor contains the VLAN tag */

 Update buffer address (for TSO this is the header) */

 Update the buffer length */

 VLAN tag insertion check */

 Timestamp enablement check */

 Mark it as First Descriptor */

 Mark it as a NORMAL descriptor */

 Set OWN bit if not the first descriptor */

 Enable TSO */

 Enable CRC and Pad Insertion */

 Enable HW CSUM */

 Set the total length to be transmitted */

 Update buffer address */

 Update the buffer length */

 Set OWN bit */

 Mark it as NORMAL descriptor */

 Enable HW CSUM */

 Set LAST bit for the last descriptor */

 Set IC bit based on Tx coalescing settings */

 Save the Tx info to report back during cleanup */

	/* In case the Tx DMA engine is running, make sure everything

	 * is written to the descriptor(s) before setting the OWN bit

	 * for the first descriptor

 Set OWN bit for the first descriptor */

 Make sure ownership is written to the descriptor */

	/* Reset the Tx descriptor

	 *   Set buffer 1 (lo) address to zero

	 *   Set buffer 1 (hi) address to zero

	 *   Reset all other control bits (IC, TTSE, B2L & B1L)

	 *   Reset all other control bits (OWN, CTXT, FD, LD, CPC, CIC, etc)

 Make sure ownership is written to the descriptor */

 Initialze all descriptors */

 Initialize Tx descriptor */

 Update the total number of Tx descriptors */

 Update the starting address of descriptor ring */

 No coalescing, interrupt for every descriptor */

 Set interrupt based on Rx frame coalescing setting */

	/* Reset the Rx descriptor

	 *   Set buffer 1 (lo) address to header dma address (lo)

	 *   Set buffer 1 (hi) address to header dma address (hi)

	 *   Set buffer 2 (lo) address to buffer dma address (lo)

	 *   Set buffer 2 (hi) address to buffer dma address (hi) and

	 *     set control bits OWN and INTE

	/* Since the Rx DMA engine is likely running, make sure everything

	 * is written to the descriptor(s) before setting the OWN bit

	 * for the descriptor

 Make sure ownership is written to the descriptor */

 Initialize all descriptors */

 Initialize Rx descriptor */

 Update the total number of Rx descriptors */

 Update the starting address of descriptor ring */

 Update the Rx Descriptor Tail Pointer */

 Rx and Tx share CTXT bit, so check TDES3.CTXT bit */

 Rx and Tx share LD bit, so check TDES3.LD bit */

 Clear MTL flow control */

 Clear MAC flow control */

 Set MTL flow control */

 Set MAC flow control */

 Enable transmit flow control */

 Set pause time */

	/* Convert the input usec value to the watchdog timer value. Each

	 * watchdog timer value is equivalent to 256 clock cycles.

	 * Calculate the required value as:

	 *   ( usec * ( system_clock_mhz / 10^6 ) / 256

	/* Convert the input watchdog timer value to the usec value. Each

	 * watchdog timer value is equivalent to 256 clock cycles.

	 * Calculate the required value as:

	 *   ( riwt * 256 ) / ( system_clock_mhz / 10^6 )

 Set Tx to weighted round robin scheduling algorithm */

 Set Tx traffic classes to use WRR algorithm with equal weights */

 Set Rx to strict priority algorithm */

	/* Map the MTL Tx Queues to Traffic Classes

	 *   Note: Tx Queues >= Traffic Classes

 Map the 8 VLAN priority values to available MTL Rx queues */

	/* Configure one to one, MTL Rx queue to DMA Rx channel mapping

	 *  ie Q0 <--> CH0, Q1 <--> CH1 ... Q11 <--> CH11

 Calculate the configured fifo size */

 The configured value may not be the actual amount of fifo RAM */

	/* Each increment in the queue fifo size represents 256 bytes of

	 * fifo, with 0 representing 256 bytes. Distribute the fifo equally

	 * between the queues.

 Activate flow control when less than 4k left in fifo */

 De-activate flow control when more than 6k left in fifo */

 These registers are always 64 bit */

 Freeze counters */

 Un-freeze counters */

 Set counters to reset on read */

 Reset the counters */

 Program the hash key */

 Program the lookup table */

 Set the RSS options */

 Enable RSS */

 Clear all the interrupts which are set */

 Clear all interrupt enable bits */

		/* Enable following interrupts

		 *   NIE  - Normal Interrupt Summary Enable

		 *   AIE  - Abnormal Interrupt Summary Enable

		 *   FBEE - Fatal Bus Error Enable

			/* Enable the following Tx interrupts

			 *   TIE  - Transmit Interrupt Enable (unless using

			 *          per channel interrupts)

			/* Enable following Rx interrupts

			 *   RBUE - Receive Buffer Unavailable Enable

			 *   RIE  - Receive Interrupt Enable (unless using

			 *          per channel interrupts)

 Clear all the interrupts which are set */

 No MTL interrupts to be enabled */

 Enable Timestamp interrupt */

 Enable all counter interrupts */

 Check for data availability */

 Make sure descriptor fields are read after reading the OWN bit */

 Timestamp Context Descriptor */

 Normal Descriptor, be sure Context Descriptor bit is off */

 Indicate if a Context Descriptor is next */

 Get the header length */

 Get the RSS hash */

 Get the pkt_info length */

 Not all the data has been transferred for this pkt_info */

 This is the last of the data for this pkt_info */

 Set checksum done indicator as appropriate */

 Check for errors (only valid in last descriptor) */

 No error if err is 0 or etlt is 0 */

 Poll Until Poll Condition */

 Set enhanced addressing mode */

 Set the System Bus mode */

 Flush Tx queues */

 Initialize DMA related features */

 Initialize MTL related features */

 Initialize MAC related features */

 Issue a software reset */

 Poll Until Poll Condition */

 For MII speed configuration */

 For descriptor related operation */

 For Flow Control */

 For Vlan related config */

 For RX coalescing */

 For RX and TX threshold config */

 For RX and TX Store and Forward Mode config */

 For TX DMA Operating on Second Frame config */

 For RX and TX PBL config */

 For MMC statistics support */

 For Receive Side Scaling */

/* Synopsys DesignWare Core Enterprise Ethernet (XLGMAC) Driver

 *

 * Copyright (c) 2017 Synopsys, Inc. (www.synopsys.com)

 *

 * This program is dual-licensed; you may select either version 2 of

 * the GNU General Public License ("GPL") or BSD license ("BSD").

 *

 * This Synopsys DWC XLGMAC software driver and associated documentation

 * (hereinafter the "Software") is an unsupported proprietary work of

 * Synopsys, Inc. unless otherwise expressly agreed to in writing between

 * Synopsys and you. The Software IS NOT an item of Licensed Software or a

 * Licensed Product under any End User Software License Agreement or

 * Agreement for Licensed Products with Synopsys or any supplement thereto.

 * Synopsys is a registered trademark of Synopsys, Inc. Other names included

 * in the SOFTWARE may be the trademarks of their respective owners.

 Currently it uses a static mac address for test */

 Set default configuration data */

 Set irq, base_addr, MAC address, */

 Set all the function pointers */

 Issue software reset to device */

 Populate the hardware features */

 TODO: Set the PHY mode to XLGMII */

 Set the DMA mask */

	/* Channel and ring params initializtion

	 *  pdata->channel_count;

	 *  pdata->tx_ring_count;

	 *  pdata->rx_ring_count;

	 *  pdata->tx_desc_count;

	 *  pdata->rx_desc_count;

 Initialize RSS hash key and lookup table */

 Set device operations */

 Set device features */

 Use default watchdog timeout */

 Tx coalesce parameters initialization */

 Rx coalesce parameters initialization */

 Hardware feature register 0 */

 Hardware feature register 1 */

 Hardware feature register 2 */

 Translate the Hash Table size into actual number */

 Translate the address width setting into actual number */

	/* The Queue, Channel and TC counts are zero based so increment them

	 * to get the actual number

 HW Feature Register0 */

 HW Feature Register1 */

 HW Feature Register2 */

/* Synopsys DesignWare Core Enterprise Ethernet (XLGMAC) Driver

 *

 * Copyright (c) 2017 Synopsys, Inc. (www.synopsys.com)

 *

 * This program is dual-licensed; you may select either version 2 of

 * the GNU General Public License ("GPL") or BSD license ("BSD").

 *

 * This Synopsys DWC XLGMAC software driver and associated documentation

 * (hereinafter the "Software") is an unsupported proprietary work of

 * Synopsys, Inc. unless otherwise expressly agreed to in writing between

 * Synopsys and you. The Software IS NOT an item of Licensed Software or a

 * Licensed Product under any End User Software License Agreement or

 * Agreement for Licensed Products with Synopsys or any supplement thereto.

 * Synopsys is a registered trademark of Synopsys, Inc. Other names included

 * in the SOFTWARE may be the trademarks of their respective owners.

 MMC TX counters */

 MMC RX counters */

 Extra counters */

	/* S|SNPSVER: Synopsys-defined Version

	 * D|DEVID: Indicates the Device family

	 * U|USERVER: User-defined Version

 SPDX-License-Identifier: GPL-2.0-or-later

/*

 * EP93xx ethernet network device driver

 * Copyright (C) 2006 Lennert Buytenhek <buytenh@wantstofly.org>

 * Dedicated to Marija Kulikova.

 Strip FCS.  */

 Does the PHY support preamble suppress?  */

 Receive descriptor ring.  */

 Receive status ring.  */

 Transmit descriptor ring.  */

 Transmit status ring.  */

 @@@ Force down.  */

 Max HCLK 100 MHz, min MDIO clk 2.5 MHz.  */

 mac89x0.c: A Crystal Semiconductor CS89[02]0 driver for linux. */

/*

	Written 1996 by Russell Nelson, with reference to skeleton.c

	written 1993-1994 by Donald Becker.



	This software may be used and distributed according to the terms

	of the GNU General Public License, incorporated herein by reference.



	The author may be reached at nelson@crynwr.com, Crynwr

	Software, 11 Grant St., Potsdam, NY 13676



  Changelog:



  Mike Cruse        : mcruse@cti-ltd.com

                    : Changes for Linux 2.0 compatibility.

                    : Added dev_id parameter in net_interrupt(),

                    : request_irq() and free_irq(). Just NULL for now.



  Mike Cruse        : Added MOD_INC_USE_COUNT and MOD_DEC_USE_COUNT macros

                    : in net_open() and net_close() so kerneld would know

                    : that the module is in use and wouldn't eject the

                    : driver prematurely.



  Mike Cruse        : Rewrote init_module() and cleanup_module using 8390.c

                    : as an example. Disabled autoprobing in init_module(),

                    : not a good thing to do to other devices while Linux

                    : is running from all accounts.



  Alan Cox          : Removed 1.2 support, added 2.1 extra counters.



  David Huggins-Daines <dhd@debian.org>



  Split this off into mac89x0.c, and gutted it of all parts which are

  not relevant to the existing CS8900 cards on the Macintosh

  (i.e. basically the Daynaport CS and LC cards).  To be precise:



    * Removed all the media-detection stuff, because these cards are

    TP-only.



    * Lobotomized the ISA interrupt bogosity, because these cards use

    a hardwired NuBus interrupt and a magic ISAIRQ value in the card.



    * Basically eliminated everything not relevant to getting the

    cards minimally functioning on the Macintosh.



  I might add that these cards are badly designed even from the Mac

  standpoint, in that Dayna, in their infinite wisdom, used NuBus slot

  I/O space and NuBus interrupts for these cards, but neglected to

  provide anything even remotely resembling a NuBus ROM.  Therefore we

  have to probe for them in a brain-damaged ISA-like fashion.



  Arnaldo Carvalho de Melo <acme@conectiva.com.br> - 11/01/2001

  check kmalloc and release the allocated memory on failure in

  mac89x0_probe and in init_module

  use local_irq_{save,restore}(flags) in net_get_stat, not just

  local_irq_{dis,en}able()

/*

  Sources:



	Crynwr packet driver epktisa.



	Crystal Semiconductor data sheets.



 Information that need to be kept for each board. */

 one of: CS8900, CS8920, CS8920M */

 revision letter of the chip ('A'...) */

 the propercommand used to send a packet. */

 keep track of how many underruns in a row we get */

 Index to functions, as function prototypes. */

 For reading/writing registers ISA-style */

 These are for reading/writing registers in shared memory */

/* Probe for the CS8900 card in slot E.  We won't bother looking

 We might have to parameterize this later */

 Get out now if there's a real NuBus card in slot E */

	/* The pseudo-ISA bits always live at offset 0x300 (gee,

 Initialize the net_device structure. */

 Fill in the 'dev' fields. */

 Turn on shared memory */

 get the chip type */

	/* Check the chip type and revision in order to set the correct send command

 Try to read the MAC address */

 Big-endian (why??!) */

 print the IRQ and ethernet address. */

/* Open/initialize the board.  This is called (in the current kernel)

   sometime after booting when the 'ifconfig' program is run.



   This routine should set everything up anew at each open, even

   registers that "should" only need to be set once at boot, so that

   there is non-reboot way to recover if something goes wrong.

 Disable the interrupt for now */

 Grab the interrupt */

 Set up the IRQ - Apparently magic */

 set the Ethernet address */

 Turn on both receive and transmit operations */

 Receive only error free packets addressed to this card */

 now that we've got our act together, enable everything */

	/* keep the upload from being interrupted, since we

	   ask the chip to start transmitting before the

 initiate a transmit sequence */

 Test to see if the chip has allocated memory for the packet */

		/* Gasp!  It hasn't.  But that shouldn't happen since

 Write the contents of the packet */

/* The typical workload of the driver:

	/* we MUST read all the events out of the ISQ, otherwise we'll never

           get interrupted again.  As a consequence, we can't have any limit

           on the number of times we loop in the interrupt handler.  The

           hardware guarantees that eventually we'll run out of events.  Of

           course, if you're on a slow machine, and packets are arriving

           faster than you can read them off, you're screwed.  Hasta la

 Got a packet(s). */

				/* we tried to transmit a packet earlier,

                                   but inexplicably ran out of buffers.

                                   That shouldn't happen since we only ever

                                   load one packet.  Shrug.  Do the right

 We have a good packet(s), get it/them out of the buffers. */

 per str 172 */

 Malloc up new buffer. */

 The inverse routine to net_open(). */

 Update the statistics here. */

/* Get the current statistics.	This may be called with the card open or

 Update the statistics from the device registers. */

		/* The multicast-accept list is initialized to accept-all, and we

 in promiscuous mode, we accept errored packets, so we have to enable interrupts on them also */

 set the Ethernet address */

/* cs89x0.c: A Crystal Semiconductor (Now Cirrus Logic) CS89[02]0

 *           driver for linux.

 * Written 1996 by Russell Nelson, with reference to skeleton.c

 * written 1993-1994 by Donald Becker.

 *

 * This software may be used and distributed according to the terms

 * of the GNU General Public License, incorporated herein by reference.

 *

 * The author may be reached at nelson@crynwr.com, Crynwr

 * Software, 521 Pleasant Valley Rd., Potsdam, NY 13676

 *

 * Other contributors:

 * Mike Cruse        : mcruse@cti-ltd.com

 * Russ Nelson

 * Melody Lee        : ethernet@crystal.cirrus.com

 * Alan Cox

 * Andrew Morton

 * Oskar Schirmer    : oskar@scara.com

 * Deepak Saxena     : dsaxena@plexity.net

 * Dmitry Pervushin  : dpervushin@ru.mvista.com

 * Deepak Saxena     : dsaxena@plexity.net

 * Domenico Andreoli : cavokz@gmail.com

/*

 * Set this to zero to disable DMA code

 *

 * Note that even if DMA is turned off we still support the 'dma' and  'use_dma'

 * module options so we don't break any startup scripts.

/*

 * Set this to zero to remove all the debug statements via

 * dead code elimination

/* Sources:

 *	Crynwr packet driver epktisa.

 *	Crystal Semiconductor data sheets.

/* First, a few definitions that the brave might change.

 * A zero-terminated list of I/O addresses to be probed. Some special flags..

 * Addr & 1 = Read back the address port, look for signature and reset

 * the page window before probing

 * Addr & 3 = Reset the page window and probe

 * The CLPS eval board has the Cirrus chip at 0x80090300, in ARM IO space,

 * but it is possible that a Cirrus board could be plugged into the ISA

 * slots.

/* The cs8900 has 4 IRQ pins, software selectable. cs8900_irq_map maps

 * them to system IRQ numbers. This mapping is card specific and is set to

 * the configuration of the Cirrus Eval board for this chip.

 gcc will remove all the debug code for us */

 The number of low I/O ports used by the ethercard. */

 we allow the user to override various values normally set in the EEPROM */

 pick one of these three */

 pick one of these three */

 Information that need to be kept for each board. */

 one of: CS8900, CS8920, CS8920M */

 revision letter of the chip ('A'...) */

 the proper send command: TX_NOW, TX_AFTER_381, or TX_AFTER_ALL */

 auto-negotiation word from EEPROM */

 adapter configuration from EEPROM */

 ISA configuration from EEPROM */

 IRQ map from EEPROM */

 what mode are we in? 0, RX_MULTCAST_ACCEPT, or RX_ALL_ACCEPT */

 a copy of PP_RxCFG */

 either 0 or LOW_RX_SQUELCH, depending on configuration. */

 keep track of how many underruns in a row we get */

 force various values; see FORCE* above. */

 CS89x0 virtual address. */

 Flag: we're using dma */

 DMA channel */

 16 or 64 */

 points to the beginning of the buffer */

 points to the end of the buffer */

 points to the next packet  */

 Example routines you must write ;->. */

/*

 * Permit 'cs89x0_dma=N' in the kernel boot environment

 ALLOW_DMA */

	/* check to see if the EEPROM is ready,

	 * a timeout is used just in case EEPROM is ready when

	 * SI_BUSY in the PP_SelfST is clear

 Now send the EEPROM read command and EEPROM location to read */

 Search the mapping table for the corresponding IRQ pin. */

 Not found */

 INTRQ0 pin is used for interrupt generation. */

 per str 172 */

/*********************************

 * This page contains DMA routines

 not that we support it... */

 Reset the DMA pointer */

 Does ISA config specify DMA burst ? */

 did they ask for 64K? */

 we need memory enabled to use DMA. */

 Malloc up new buffer. */

 AKPM: advance bp to the next frame */

 longword align L3 header */

 ALLOW_DMA */

	/* control the DC to DC convertor in the SelfControl register.

	 * Note: This is hooked up to a general purpose pin, might not

	 * always be a DC to DC convertor.

 Enable the HCB1 bit as an output */

 Wait for the DC/DC converter to power up - 500ms */

 send a test packet - return true if carrier bits are ok */

 A 46 in network order */

 DSAP=0 & SSAP=0 fields */

 Control (Test Req + P bit set) */

 Test to see if the chip has allocated memory for the packet */

 this shouldn't happen */

 Write the contents of the packet */

 wait a couple of jiffies for packet to be received */

	/* If connected to another full duplex capable 10-Base-T card

	 * the link pulses seem to be lost when the auto detect bit in

	 * the LineCTL is set.  To overcome this the auto detect bit will

	 * be cleared whilst testing the 10-Base-T interface.  This would

	 * not be necessary for the sparrow chip but is simpler to do it

	 * anyway.

	/* Delay for the hardware to work out if the TP cable is present

	 * - 150ms

 CS8900 doesn't support AUTO, change to HALF*/

 We have a good packet(s), get it/them out of the buffers. */

 Malloc up new buffer. */

 longword align L3 header */

/* The typical workload of the driver:

 * Handle the network interface interrupts.

	/* we MUST read all the events out of the ISQ, otherwise we'll never

	 * get interrupted again.  As a consequence, we can't have any limit

	 * on the number of times we loop in the interrupt handler.  The

	 * hardware guarantees that eventually we'll run out of events.  Of

	 * course, if you're on a slow machine, and packets are arriving

	 * faster than you can read them off, you're screwed.  Hasta la

	 * vista, baby!

 Got a packet(s). */

 Inform upper layers. */

				/* we tried to transmit a packet earlier,

				 * but inexplicably ran out of buffers.

				 * That shouldn't happen since we only ever

				 * load one packet.  Shrug.  Do the right

				 * thing anyway.

 Inform upper layers. */

				/* transmit cycle is done, although

				 * frame wasn't transmitted - this

				 * avoids having to wait for the upper

				 * layers to timeout on us, in the

				 * event of a tx underrun

 Inform upper layers. */

/* Open/initialize the board.  This is called (in the current kernel)

   sometime after booting when the 'ifconfig' program is run.



   This routine should set everything up anew at each open, even

   registers that "should" only need to be set once at boot, so that

   there is non-reboot way to recover if something goes wrong.

 AKPM: do we need to do any locking here? */

 Allow interrupts to be generated by the chip */

 Cirrus' release had this: */

 And 2.3.47 had this: */

 writereg(dev, PP_BufCFG, GENERATE_SW_INTERRUPT); */

 disable interrupts. */

 FIXME: Cirrus' release had this: */

 And 2.3.47 had this: */

 Why? */

 auto_init as well */

 ALLOW_DMA */

 set the Ethernet address */

 while we're testing the interface, leave interrupts disabled */

 Set the LineCTL quintuplet based on adapter configuration read from EEPROM */

 check to make sure that they have the "right" hardware available */

 set the hardware to the configured choice */

 check "ignore missing media" bit */

 Yes! I don't care if I see a link pulse */

 check "ignore missing media" bit */

 Yes! I don't care if I see a carrrier */

 check "ignore missing media" bit */

 Yes! I don't care if I can xmit a packet */

 Turn on both receive and transmit operations */

 Receive only error free packets addressed to this card */

 now that we've got our act together, enable everything */

 turn memory on */

 The inverse routine to net_open(). */

 Update the statistics here. */

/* Get the current statistics.

 * This may be called with the card open or closed.

 Update the statistics from the device registers. */

	/* If we get here, some higher level has decided we are broken.

 Try to restart the adaptor. */

	/* keep the upload from being interrupted, since we

	 * ask the chip to start transmitting before the

	 * whole packet has been completely uploaded.

 initiate a transmit sequence */

 Test to see if the chip has allocated memory for the packet */

		/* Gasp!  It hasn't.  But that shouldn't happen since

		 * we're waiting for TxOk, so return 1 and requeue this packet.

 Write the contents of the packet */

	/* We DO NOT call netif_wake_queue() here.

	 * We also DO NOT call netif_start_queue().

	 *

	 * Either of these would cause another bottom half run through

	 * net_send_packet() before this packet has fully gone out.

	 * That causes us to hit the "Gasp!" above and the send is rescheduled.

	 * it runs like a dog.  We just return and wait for the Tx completion

	 * interrupt handler to restart the netdevice layer

		/* The multicast-accept list is initialized to accept-all,

		 * and we rely on higher-level filtering for now.

	/* in promiscuous mode, we accept errored packets,

	 * so we have to enable interrupts on them also

 set the Ethernet address */

/*

 * Polling receive - used by netconsole and other diagnostic tools

 * to allow network i/o with interrupts disabled.

 wait 30 ms */

 Hardware problem requires PNP registers to be reconfigured after a reset */

 Wait until the chip is reset */

 !CONFIG_MACH_MX31ADS */

/* This is the real probe routine.

 * Linux has a history of friendly device probes on the ISA bus.

 * A good device probes avoids doing writes, and

 * verifies that the correct device exists and functions.

 * Return 0 on success.

 Initialize the device structure. */

 Could make this an option... */

 get the chip type */

	/* Check the chip type and revision in order to set the correct

	 * send command.  CS8920 revision C and CS8900 revision F can use

	 * the faster send.

	/* Here we read the current configuration of the chip.

	 * If there is no Extended EEPROM then the idea is to not disturb

	 * the chip configuration, it should have been correctly setup by

	 * automatic EEPROM read on reset. So, if the chip says it read

	 * the EEPROM the driver will always do *something* instead of

	 * complain that adapter_cnf is 0.

 Load the MAC. */

		/* Load the Adapter Configuration.

		 * Note:  Barring any more specific information from some

		 * other source (ie EEPROM+Schematics), we would not know

		 * how to operate a 10Base2 interface on the AUI port.

		 * However, since we  do read the status of HCB1 and use

		 * settings that always result in calls to control_dc_dc(dev,0)

		 * a BNC interface should work if the enable pin

		 * (dc/dc converter) is on HCB1.

		 * It will be called AUI however.

 Preserve the setting of the HCB1 pin. */

 Save the sqelch bit */

 Check if the card is in 10Base-t only mode */

 Check if the card is in AUI only mode */

 Check if the card is in Auto mode. */

 IRQ. Other chips already probe, see below. */

 First check to see if an EEPROM is attached. */

		/* Check if the chip was able to read its own configuration starting

		/* This reads an extended EEPROM that is not documented

		 * in the CS8900 datasheet.

 get transmission control word  but keep the autonegotiation bits */

 Store adapter configuration */

 Store ISA configuration */

 eeprom_buff has 32-bit ints, so we can't just memcpy it */

 store the initial memory base address */

 allow them to force multiple transceivers.  If they force multiple, autosense */

 FIXME: We don't let you set dc-dc polarity or low RX squelch from the command line: add it here */

 FIXME: We don't let you set the IMM bit from the command line: add it to lp->auto_neg_cnf here */

	/* FIXME: we don't set the Ethernet address on the command line.  Use

	 * ifconfig IFACE hw ether AABBCCDDEEFF

 If this is a CS8900 then no pnp soft */

 Check if the ISA IRQ has been set  */

 Translate the IRQ using the IRQ mapping table. */

 fixed IRQ map for CS8900 */

 print the ethernet address. */

/*

 * This function converts the I/O port address used by the cs89x0_probe() and

 * init_module() functions to the I/O memory address used by the

 * cs89x0_probe1() function.

	/* if they give us an odd I/O address, then do ONE write to

	 * the address port, to get it back to address zero, where we

	 * expect to find the EISA signature word. An IO with a base of 0x3

	 * will skip the test for the ADD_PORT.

/* Check for a network adaptor of this type, and return '0' iff one exists.

 * If dev->base_addr == 0, probe all likely locations.

 * If dev->base_addr == 1, always return failure.

 * If dev->base_addr == 2, allocate space for the device and return success

 * (detachable devices only).

 * Return 0 on success.

 Check a single specified location. */

 Don't probe at all. */

/* Support the 'debug' module parm even if we're compiled for non-debug to

 * avoid breaking someone's startup scripts

 These generate unused var warnings if ALLOW_DMA = 0 */

 or 64 */

 No other value than -1 for duplex seems to be currently interpreted */

/*

 * media=t             - specify media type

 * or media=2

 * or media=aui

 * or medai=auto

 * duplex=0            - specify forced half/full/autonegotiate duplex

 * debug=#             - debug level

 *

 * Default Chip Configuration:

 * DMA Burst = enabled

 * IOCHRDY Enabled = enabled

 * UseSA = enabled

 * CS8900 defaults to half-duplex if not specified on command-line

 * CS8920 defaults to autoneg if not specified on command-line

 * Use reset defaults for other config parameters

 *

 * Assumptions:

 * media type specified is supported (circuitry is present)

 * if memory address is > 1MB, then required mem decode hw is present

 * if 10B-2, then agent other than driver will enable DC/DC converter

 * (hw or software util)

 boy, they'd better get these right */

 MODULE */

 CONFIG_CS89x0_ISA */

	/* This platform_get_resource() call will not return NULL, because

	 * the same call in cs89x0_platform_probe() has returned a non NULL

	 * value.

 CONFIG_CS89x0_PLATFORM */

 SPDX-License-Identifier: GPL-2.0

/* Copyright (c) 2016-2017, National Instruments Corp.

 *

 * Author: Moritz Fischer <mdf@kernel.org>

 Axi DMA Register definitions */

 Channel control */

 Status */

 Current descriptor pointer */

 Tail descriptor pointer */

 Channel control */

 Status */

 Current descriptor pointer */

 Tail descriptor pointer */

 Start/stop DMA channel */

 Reset DMA engine */

 Requested len */

 First tx packet */

 Last tx packet */

 All control bits */

 Delay timeout counter */

 Coalesce counter */

 Completion intr */

 Delay interrupt */

 Error interrupt */

 All interrupts */

 Default TX/RX Threshold and waitbound values for SGDMA mode */

 Actual len */

 Completed */

 Decode error */

 Slave error */

 Internal err */

 All errors */

 First rx pkt */

 Last rx pkt */

 All status bits */

 Packet size info */

 Size of Ethernet header */

 Size of Ethernet trailer (FCS) */

 Max MTU of an Ethernet frame */

 Max MTU of a jumbo Eth. frame */

 Connection to PHY device */

 MDIO bus data */

 MII bus reference */

 IO registers, dma functions and IRQs */

 Buffer descriptors */

 Reset the indexes which are used for accessing the BDs */

 Allocate the Tx and Rx buffer descriptors. */

 Start updating the Rx channel control register */

 Update the interrupt coalesce count */

 Update the delay timer count */

 Enable coalesce, delay timer and error interrupts */

 Write to the Rx channel control register */

 Start updating the Tx channel control register */

 Update the interrupt coalesce count */

 Update the delay timer count */

 Enable coalesce, delay timer and error interrupts */

 Write to the Tx channel control register */

	/* Populate the tail pointer and bring the Rx Axi DMA engine out of

	 * halted state. This will make the Rx side ready for reception.

	/* Write to the RS (Run-stop) bit in the Tx channel control register.

	 * Tx channel is now ready to run. But only after we write to the

	 * tail pointer register that the Tx channel will start transmitting.

	/* Reset Axi DMA. This would reset NIXGE Ethernet core as well.

	 * The reset process of Axi DMA takes a while to complete as all

	 * pending commands/transfers will be flushed or completed during

	 * this reset process.

 last buffer of the frame */

 Start the transfer */

		/* For now mark them as CHECKSUM_NONE since

		 * we don't have offload capabilities

 FIXME: bail out and clean up */

 If there's more, reschedule, but clear */

 if not, turn on RX IRQs again ... */

 Disable coalesce, delay timer and error interrupts */

 Write to the Tx channel control register */

 Disable coalesce, delay timer and error interrupts */

 Write to the Rx channel control register */

 Turn of IRQs because NAPI */

 Disable coalesce, delay timer and error interrupts */

 Finally write to the Tx channel control register */

 Disable coalesce, delay timer and error interrupts */

 write to the Rx channel control register */

 Start updating the Rx channel control register */

 Update the interrupt coalesce count */

 Update the delay timer count */

 Enable coalesce, delay timer and error interrupts */

 Finally write to the Rx channel control register */

 Start updating the Tx channel control register */

 Update the interrupt coalesce count */

 Update the delay timer count */

 Enable coalesce, delay timer and error interrupts */

 Finally write to the Tx channel control register */

	/* Populate the tail pointer and bring the Rx Axi DMA engine out of

	 * halted state. This will make the Rx side ready for reception.

	/* Write to the RS (Run-stop) bit in the Tx channel control register.

	 * Tx channel is now ready to run. But only after we write to the

	 * tail pointer register that the Tx channel will start transmitting

 Enable tasklets for Axi DMA error handling */

 Enable interrupts for Axi DMA Tx */

 Enable interrupts for Axi DMA Rx */

 Enable identification LED override*/

 Restore LED settings */

 Match table for of_platform binding */

 MTU range: 64 - 9000 */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017 Netronome Systems, Inc. */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

/*

 * nfp_main.c

 * Authors: Jakub Kicinski <jakub.kicinski@netronome.com>

 *          Alejandro Lucero <alejandro.lucero@netronome.com>

 *          Jason McMullan <jason.mcmullan@netronome.com>

 *          Rolf Neugebauer <rolf.neugebauer@netronome.com>

 Required last entry. */

 Callers should hold the devlink instance lock */

 Check if cmd field is clear */

 Write data_len and wipe reserved */

 Read back for ordering */

 Write cmd and wipe return value */

 Wait for command to go to 0 (NFP_MBOX_NO_CMD) */

 Copy output if any (could be error info, do it before reading ret) */

 Check if there is an error */

 Refresh cached information */

 For backwards compatibility if symbol not found allow all */

	/* If the VFs are assigned we cannot shut down SR-IOV without

	 * causing issues, so just leave the hardware available but

	 * disabled

/**

 * nfp_net_fw_find() - Find the correct firmware image for netdev mode

 * @pdev:	PCI Device structure

 * @pf:		NFP PF Device structure

 *

 * Return: firmware if found and requested successfully.

 First try to find a firmware image specific for this device */

 Then try the PCI name */

 Finally try the card type and media */

/**

 * nfp_fw_load() - Load the firmware image

 * @pdev:       PCI Device structure

 * @pf:		NFP PF Device structure

 * @nsp:	NFP SP handle

 *

 * Return: -ERRNO, 0 for no firmware loaded, 1 for firmware loaded

		/* Don't propagate this error to stick with legacy driver

		 * behavior, failure will be detected later during init.

		/* Don't flag the fw_loaded in this case since other devices

		 * may reuse the firmware when configured this way

	/* We don't want to unload firmware when other devices may still be

	 * dependent on it, which could be the case if there are multiple

	 * devices that could load firmware.

 Optional per-PCI PF mailbox */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2016-2019 Netronome Systems, Inc. */

	/* CCM is for FW communication which is request-reply.  To make sure

	 * we don't reuse the message ID too early after timeout - limit the

	 * number of requests in flight.

	/* We didn't get a response - try last time and atomically drop

	 * the tag even if no response is matched.

 0 reply_size means caller will do the validation */

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2017-2018 Netronome Systems, Inc. */

	/* TX and RX stats are flipped as we are returning the stats as seen

	 * at the switch port corresponding to the VF.

 Set features the lower device can support with representors */

 Advertise but disable TSO by default. */

	/* Preclean must happen before we remove the reprs reference from the

	 * app below.

 SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)

 Copyright (C) 2015-2018 Netronome Systems, Inc. */

/*

 * nfp_net_common.c

 * Netronome network device driver: Common functions between PF and VF

 * Authors: Jakub Kicinski <jakub.kicinski@netronome.com>

 *          Jason McMullan <jason.mcmullan@netronome.com>

 *          Rolf Neugebauer <rolf.neugebauer@netronome.com>

 *          Brad Petrus <brad.petrus@netronome.com>

 *          Chris Telfer <chris.telfer@netronome.com>

/**

 * nfp_net_get_fw_version() - Read and parse the FW version

 * @fw_ver:	Output fw_version structure to read to

 * @ctrl_bar:	Mapped address of the control BAR

/* Firmware reconfig

 *

 * Firmware reconfig may take a while so we have two versions of it -

 * synchronous and asynchronous (posted).  All synchronous callers are holding

 * RTNL so we don't have to worry about serializing them.

 ensure update is written before pinging HW */

 Pass 0 as update to run posted reconfigs. */

	/* Poll update field, waiting for NFP to ack the config.

	 * Do an opportunistic wait-busy loop, afterward sleep.

 If sync caller is present it will take over from us */

 Read reconfig status and report errors */

/**

 * nfp_net_reconfig_post() - Post async reconfig request

 * @nn:      NFP Net device to reconfigure

 * @update:  The value for the update field in the BAR config

 *

 * Record FW reconfiguration request.  Reconfiguration will be kicked off

 * whenever reconfiguration machinery is idle.  Multiple requests can be

 * merged together!

 Sync caller will kick off async reconf when it's done, just post */

 Opportunistically check if the previous command is done */

 Run the posted reconfigs which were issued before we started */

/**

 * __nfp_net_reconfig() - Reconfigure the firmware

 * @nn:      NFP Net device to reconfigure

 * @update:  The value for the update field in the BAR config

 *

 * Write the update word to the BAR and ping the reconfig queue.  The

 * poll until the firmware has acknowledged the update by zeroing the

 * update word.

 *

 * Return: Negative errno on error, 0 on success

/**

 * nfp_net_mbox_reconfig() - Reconfigure the firmware via the mailbox

 * @nn:        NFP Net device to reconfigure

 * @mbox_cmd:  The value for the mailbox command

 *

 * Helper function for mailbox updates

 *

 * Return: Negative errno on error, 0 on success

/* Interrupt configuration and handling

/**

 * nfp_net_irq_unmask() - Unmask automasked interrupt

 * @nn:       NFP Network structure

 * @entry_nr: MSI-X table entry

 *

 * Clear the ICR for the IRQ entry.

/**

 * nfp_net_irqs_alloc() - allocates MSI-X irqs

 * @pdev:        PCI device structure

 * @irq_entries: Array to be initialized and used to hold the irq entries

 * @min_irqs:    Minimal acceptable number of interrupts

 * @wanted_irqs: Target number of interrupts to allocate

 *

 * Return: Number of irqs obtained or 0 on error.

/**

 * nfp_net_irqs_assign() - Assign interrupts allocated externally to netdev

 * @nn:		 NFP Network structure

 * @irq_entries: Table of allocated interrupts

 * @n:		 Size of @irq_entries (number of entries to grab)

 *

 * After interrupts are allocated with nfp_net_irqs_alloc() this function

 * should be called to assign them to a specific netdev (port).

/**

 * nfp_net_irqs_disable() - Disable interrupts

 * @pdev:        PCI device structure

 *

 * Undoes what @nfp_net_irqs_alloc() does.

/**

 * nfp_net_irq_rxtx() - Interrupt service routine for RX/TX rings.

 * @irq:      Interrupt

 * @data:     Opaque data structure

 *

 * Return: Indicate if the interrupt has been handled.

	/* Currently we cannot tell if it's a rx or tx interrupt,

	 * since dim does not need accurate event_ctr to calculate,

	 * we just use this counter for both rx and tx dim.

	/* The FW auto-masks any interrupt, either via the MASK bit in

	 * the MSI-X table or via the per entry ICR field.  So there

	 * is no need to disable interrupts here.

/**

 * nfp_net_read_link_status() - Reread link status from control BAR

 * @nn:       NFP Network structure

/**

 * nfp_net_irq_lsc() - Interrupt service routine for link state changes

 * @irq:      Interrupt

 * @data:     Opaque data structure

 *

 * Return: Indicate if the interrupt has been handled.

/**

 * nfp_net_irq_exn() - Interrupt service routine for exceptions

 * @irq:      Interrupt

 * @data:     Opaque data structure

 *

 * Return: Indicate if the interrupt has been handled.

 XXX TO BE IMPLEMENTED */

/**

 * nfp_net_tx_ring_init() - Fill in the boilerplate for a TX ring

 * @tx_ring:  TX ring structure

 * @r_vec:    IRQ vector servicing this ring

 * @idx:      Ring index

 * @is_xdp:   Is this an XDP TX ring?

/**

 * nfp_net_rx_ring_init() - Fill in the boilerplate for a RX ring

 * @rx_ring:  RX ring structure

 * @r_vec:    IRQ vector servicing this ring

 * @idx:      Ring index

/**

 * nfp_net_aux_irq_request() - Request an auxiliary interrupt (LSC or EXN)

 * @nn:		NFP Network structure

 * @ctrl_offset: Control BAR offset where IRQ configuration should be written

 * @format:	printf-style format to construct the interrupt name

 * @name:	Pointer to allocated space for interrupt name

 * @name_sz:	Size of space for interrupt name

 * @vector_idx:	Index of MSI-X vector used for this interrupt

 * @handler:	IRQ handler to register for this interrupt

/**

 * nfp_net_aux_irq_free() - Free an auxiliary interrupt (LSC or EXN)

 * @nn:		NFP Network structure

 * @ctrl_offset: Control BAR offset where IRQ configuration should be written

 * @vector_idx:	Index of MSI-X vector used for this interrupt

/* Transmit

 *

 * One queue controller peripheral queue is used for transmit.  The

 * driver en-queues packets for transmit by advancing the write

 * pointer.  The device indicates that packets have transmitted by

 * advancing the read pointer.  The driver maintains a local copy of

 * the read and write pointer in @struct nfp_net_tx_ring.  The driver

 * keeps @wr_p in sync with the queue controller write pointer and can

 * determine how many packets have been transmitted by comparing its

 * copy of the read pointer @rd_p with the read pointer maintained by

 * the queue controller peripheral.

/**

 * nfp_net_tx_full() - Check if the TX ring is full

 * @tx_ring: TX ring to check

 * @dcnt:    Number of descriptors that need to be enqueued (must be >= 1)

 *

 * This function checks, based on the *host copy* of read/write

 * pointer if a given TX ring is full.  The real TX queue may have

 * some newly made available slots.

 *

 * Return: True if the ring is full.

 Wrappers for deciding when to stop and restart TX queues */

/**

 * nfp_net_tx_ring_stop() - stop tx ring

 * @nd_q:    netdev queue

 * @tx_ring: driver tx queue structure

 *

 * Safely stop TX ring.  Remember that while we are running .start_xmit()

 * someone else may be cleaning the TX ring completions so we need to be

 * extra careful here.

 We can race with the TX completion out of NAPI so recheck */

/**

 * nfp_net_tx_tso() - Set up Tx descriptor for LSO

 * @r_vec: per-ring structure

 * @txbuf: Pointer to driver soft TX descriptor

 * @txd: Pointer to HW TX descriptor

 * @skb: Pointer to SKB

 * @md_bytes: Prepend length

 *

 * Set up Tx descriptor for LSO, do nothing for non-LSO skbs.

 * Return error on packet header greater than maximum supported LSO header size.

/**

 * nfp_net_tx_csum() - Set TX CSUM offload flags in TX descriptor

 * @dp:  NFP Net data path struct

 * @r_vec: per-ring structure

 * @txbuf: Pointer to driver soft TX descriptor

 * @txd: Pointer to TX descriptor

 * @skb: Pointer to SKB

 *

 * This function sets the TX checksum flags in the TX descriptor based

 * on the configuration and the protocol of the packet to be transmitted.

 Pure ACK out of order already */

 encryption wasn't necessary */

 we don't re-check ring space */

 jump forward, a TX may have gotten lost, need to sync TX */

		/* conn handle is opaque, we just use u64 to be able to quickly

		 * compare it to zero

/**

 * nfp_net_tx() - Main transmit entry point

 * @skb:    SKB to transmit

 * @netdev: netdev structure

 *

 * Return: NETDEV_TX_OK on success.

 Start with the head skbuf */

 Stash the soft descriptor of the head then initialize it */

 Build TX descriptor */

 Do not reorder - tso may adjust pkt cnt, vlan may override fields */

 Gather DMA */

 all descs must match except for in addr, length and eop */

/**

 * nfp_net_tx_complete() - Handled completed TX packets

 * @tx_ring:	TX ring structure

 * @budget:	NAPI budget (only used as bool to determine if in NAPI context)

 Work out how many descriptors have been transmitted */

 unmap head */

 unmap fragment */

 check for last gather fragment */

 Make sure TX thread will see updated tx_ring->rd_p */

 Work out how many descriptors have been transmitted */

/**

 * nfp_net_tx_ring_reset() - Free any untransmitted buffers and reset pointers

 * @dp:		NFP Net data path struct

 * @tx_ring:	TX ring structure

 *

 * Assumes that the device is stopped, must be idempotent.

 unmap head */

 unmap fragment */

 check for last gather fragment */

/* Receive processing

/**

 * nfp_net_rx_alloc_one() - Allocate and map page frag for RX

 * @dp:		NFP Net data path struct

 * @dma_addr:	Pointer to storage for DMA address (output param)

 *

 * This function will allcate a new page frag, map it for DMA.

 *

 * Return: allocated page frag or NULL on failure.

/**

 * nfp_net_rx_give_one() - Put mapped skb on the software and hardware rings

 * @dp:		NFP Net data path struct

 * @rx_ring:	RX ring structure

 * @frag:	page fragment buffer

 * @dma_addr:	DMA address of skb mapping

 Stash SKB and DMA address away */

 Fill freelist descriptor */

		/* Update write pointer of the freelist queue. Make

		 * sure all writes are flushed before telling the hardware.

/**

 * nfp_net_rx_ring_reset() - Reflect in SW state of freelist after disable

 * @rx_ring:	RX ring structure

 *

 * Assumes that the device is stopped, must be idempotent.

	/* wr_p == rd_p means ring was never fed FL bufs.  RX rings are always

	 * kept at cnt - 1 FL bufs.

 Move the empty entry to the end of the list */

/**

 * nfp_net_rx_ring_bufs_free() - Free any buffers currently on the RX ring

 * @dp:		NFP Net data path struct

 * @rx_ring:	RX ring to remove buffers from

 *

 * Assumes that the device is stopped and buffers are in [0, ring->cnt - 1)

 * entries.  After device is disabled nfp_net_rx_ring_reset() must be called

 * to restore required ring geometry.

		/* NULL skb can only happen when initial filling of the ring

		 * fails to allocate enough buffers and calls here to free

		 * already allocated ones.

/**

 * nfp_net_rx_ring_bufs_alloc() - Fill RX ring with buffers (don't give to FW)

 * @dp:		NFP Net data path struct

 * @rx_ring:	RX ring to remove buffers from

/**

 * nfp_net_rx_ring_fill_freelist() - Give buffers from the ring to FW

 * @dp:	     NFP Net data path struct

 * @rx_ring: RX ring to fill

/**

 * nfp_net_rx_csum_has_errors() - group check if rxd has any csum errors

 * @flags: RX descriptor flags field in CPU byte order

/**

 * nfp_net_rx_csum() - set SKB checksum field based on RX descriptor flags

 * @dp:  NFP Net data path struct

 * @r_vec: per-ring structure

 * @rxd: Pointer to RX descriptor

 * @meta: Parsed metadata prepend

 * @skb: Pointer to SKB

	/* Assume that the firmware will never report inner CSUM_OK unless outer

	 * L4 headers were successfully parsed. FW will always report zero UDP

	 * checksum as CSUM_OK.

	/* If we have both skb and rxbuf the replacement buffer allocation

	 * must have failed, count this as an alloc failure.

	/* skb is build based on the frag, free_skb() would free the frag

	 * so to be able to reuse it we need an extra ref.

 Reject if xdp_adjust_tail grow packet beyond DMA area */

 Stash the soft descriptor of the head then initialize it */

 Build TX descriptor */

/**

 * nfp_net_rx() - receive up to @budget packets on @rx_ring

 * @rx_ring:   RX ring to receive from

 * @budget:    NAPI budget

 *

 * Note, this function is separated out from the napi poll function to

 * more cleanly separate packet receive code from other bookkeeping

 * functions performed in the napi poll function.

 *

 * Return: Number of packets received.

		/* Memory barrier to ensure that we won't do other reads

		 * before the DD bit.

		/*         < meta_len >

		 *  <-- [rx_offset] -->

		 *  ---------------------------------------------------------

		 * | [XX] |  metadata  |             packet           | XXXX |

		 *  ---------------------------------------------------------

		 *         <---------------- data_len --------------->

		 *

		 * The rx_offset is fixed for all packets, the meta_len can vary

		 * on a packet by packet basis. If rx_offset is set to zero

		 * (_RX_OFFSET_DYNAMIC) metadata starts at the beginning of the

		 * buffer and is immediately followed by the packet (no [XX]).

 Stats update */

/**

 * nfp_net_poll() - napi poll function

 * @napi:    NAPI structure

 * @budget:  NAPI budget

 *

 * Return: number of packets polled.

/* Control device data path

 Start with the head skbuf */

 Stash the soft descriptor of the head then initialize it */

 Build TX descriptor */

	/* Memory barrier to ensure that we won't do other reads

	 * before the DD bit.

 Stats update */

/* Setup and Configuration

/**

 * nfp_net_vecs_init() - Assign IRQs and setup rvecs.

 * @nn:		NFP Network structure

/**

 * nfp_net_tx_ring_free() - Free resources allocated to a TX ring

 * @tx_ring:   TX ring to free

/**

 * nfp_net_tx_ring_alloc() - Allocate resource for a TX ring

 * @dp:        NFP Net data path struct

 * @tx_ring:   TX Ring structure to allocate

 *

 * Return: 0 on success, negative errno otherwise.

/**

 * nfp_net_rx_ring_free() - Free resources allocated to a RX ring

 * @rx_ring:  RX ring to free

/**

 * nfp_net_rx_ring_alloc() - Allocate resource for a RX ring

 * @dp:	      NFP Net data path struct

 * @rx_ring:  RX ring to allocate

 *

 * Return: 0 on success, negative errno otherwise.

 Setup NAPI */

/**

 * nfp_net_rss_write_itbl() - Write RSS indirection table to device

 * @nn:      NFP Net device to reconfigure

/**

 * nfp_net_rss_write_key() - Write RSS hash key to device

 * @nn:      NFP Net device to reconfigure

/**

 * nfp_net_coalesce_write_cfg() - Write irq coalescence configuration to HW

 * @nn:      NFP Net device to reconfigure

	/* Compute factor used to convert coalesce '_usecs' parameters to

	 * ME timestamp ticks.  There are 16 ME clock cycles for each timestamp

	 * count.

 copy RX interrupt coalesce parameters */

 copy TX interrupt coalesce parameters */

/**

 * nfp_net_write_mac_addr() - Write mac address to the device control BAR

 * @nn:      NFP Net device to reconfigure

 * @addr:    MAC address to write

 *

 * Writes the MAC address from the netdev to the device control BAR.  Does not

 * perform the required reconfig.  We do a bit of byte swapping dance because

 * firmware is LE.

/**

 * nfp_net_clear_config_and_disable() - Clear control BAR and disable NFP

 * @nn:      NFP Net device to reconfigure

 *

 * Warning: must be fully idempotent.

 Write the DMA address, size and MSI-X info to the device */

/**

 * nfp_net_set_config_and_enable() - Write control BAR and enable NFP

 * @nn:      NFP Net device to reconfigure

 Enable device */

/**

 * nfp_net_close_stack() - Quiesce the stack (part of close)

 * @nn:	     NFP Net device to reconfigure

/**

 * nfp_net_close_free_all() - Free all runtime resources

 * @nn:      NFP Net device to reconfigure

/**

 * nfp_net_netdev_close() - Called when the device is downed

 * @netdev:      netdev structure

	/* Step 1: Disable RX and TX rings from the Linux kernel perspective

	/* Step 2: Tell NFP

	/* Step 3: Free resources

	/* Compute factor used to convert coalesce '_usecs' parameters to

	 * ME timestamp ticks.  There are 16 ME clock cycles for each timestamp

	 * count.

 copy RX interrupt coalesce parameters */

	/* Compute factor used to convert coalesce '_usecs' parameters to

	 * ME timestamp ticks.  There are 16 ME clock cycles for each timestamp

	 * count.

 copy TX interrupt coalesce parameters */

/**

 * nfp_net_open_stack() - Start the device from stack's perspective

 * @nn:      NFP Net device to reconfigure

	/* Step 1: Allocate resources for rings and the like

	 * - Request interrupts

	 * - Allocate RX and TX ring resources

	 * - Setup initial RSS table

	/* Step 2: Configure the NFP

	 * - Ifup the physical interface if it exists

	 * - Enable rings from 0 to tx_rings/rx_rings - 1.

	 * - Write MAC address (in case it changed)

	 * - Set the MTU

	 * - Set the Freelist buffer size

	 * - Enable the FW

	/* Step 3: Enable for kernel

	 * - put some freelist descriptors on each RX ring

	 * - enable NAPI on each ring

	 * - enable all TX queues

	 * - set link state

 ring dumping depends on vNICs being opened/closed under rtnl */

 Clear things which need to be recomputed */

 XDP-enabled tests */

 Prepare new rings */

 Stop device, swap in new rings, try to start the firmware */

 Try with old configuration and old rings */

	/* Priority tagged packets with vlan id 0 are processed by the

	 * NFP as untagged packets

	/* Priority tagged packets with vlan id 0 are processed by the

	 * NFP as untagged packets

 Collect software stats */

 Add in device stats */

 Assume this is not called with features we have not advertised */

 We can't do TSO over double tagged packets (802.1AD) */

 Ensure that inner L4 header offset fits into TX descriptor field */

		/* Assume worst case scenario of having longest possible

		 * metadata prepend - 8B

 VXLAN/GRE check */

	/* If port is defined, devlink_port is registered and devlink core

	 * is taking care of name formatting.

 We need RX reconfig to remap the buffers (BIDIR vs FROM_DEV) */

/**

 * nfp_net_info() - Print general info about the NIC

 * @nn:      NFP Net device to reconfigure

/**

 * nfp_net_alloc() - Allocate netdev and related structure

 * @pdev:         PCI device

 * @ctrl_bar:     PCI IOMEM with vNIC config memory

 * @needs_netdev: Whether to allocate a netdev for this vNIC

 * @max_tx_rings: Maximum number of TX rings supported by device

 * @max_rx_rings: Maximum number of RX rings supported by device

 *

 * This function allocates a netdev device and fills in the initial

 * part of the @struct nfp_net structure.  In case of control device

 * nfp_net structure is allocated without the netdev.

 *

 * Return: NFP Net device structure, or ERR_PTR on error.

/**

 * nfp_net_free() - Undo what @nfp_net_alloc() did

 * @nn:      NFP Net device to reconfigure

/**

 * nfp_net_rss_key_sz() - Get current size of the RSS key

 * @nn:		NFP Net device instance

 *

 * Return: size of the RSS key for currently selected hash function.

/**

 * nfp_net_rss_init() - Set the initial RSS parameters

 * @nn:	     NFP Net device to reconfigure

 Read the RSS function capability and select first supported func */

 Enable IPv4/IPv6 TCP by default */

/**

 * nfp_net_irqmod_init() - Set the initial IRQ moderation parameters

 * @nn:	     NFP Net device to reconfigure

	/* Advertise/enable offloads based on capabilities

	 *

	 * Note: netdev->features show the currently enabled features

	 * and netdev->hw_features advertises which features are

	 * supported.  By default we enable most features.

 Advertise but disable TSO by default. */

 Finalise the netdev setup */

 MTU range: 68 - hw-specific max */

 Get some of the read-only fields from the BAR */

	/* ABI 4.x and ctrl vNIC always use chained metadata, in other cases

	 * we allow use of non-chained metadata if RSS(v1) is the only

	 * advertised capability requiring metadata.

	/* RSS(v1) uses non-chained metadata format, except in ABI 4.x where

	 * it has the same meaning as RSSv2.

 Determine RX packet/metadata boundary offset */

 For control vNICs mask out the capabilities app doesn't want. */

/**

 * nfp_net_init() - Initialise/finalise the nfp_net structure

 * @nn:		NFP Net device structure

 *

 * Return: 0 on success or negative errno on error.

 Set default MTU and Freelist buffer size */

 Allow L2 Broadcast and Multicast through by default, if supported */

 Allow IRQ moderation, if supported */

 Stash the re-configuration queue away.  First odd queue in TX Bar */

 Make sure the FW knows the netdev is supposed to be disabled here */

/**

 * nfp_net_clean() - Undo what nfp_net_init() did.

 * @nn:		NFP Net device structure

